/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 48 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
typedef void DFL(char * );
#line 51 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
typedef void FILEONLY(char *file );
#line 56 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
typedef void FILELINE(char *file , char *line );
#line 106 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 105 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 112 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
struct symbols {
   char *name ;
};
#line 117 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
struct symfile {
   char *filename ;
   struct symbols *symbollist ;
   int symbolcnt ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 18 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct file {
   struct file *next ;
   struct file *parent ;
   char *name ;
   int lineno ;
   int flags ;
};
#line 30
enum tristate {
    no = 0,
    mod = 1,
    yes = 2
} ;
#line 30 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
typedef enum tristate tristate;
#line 34
enum expr_type {
    E_NONE = 0,
    E_OR = 1,
    E_AND = 2,
    E_NOT = 3,
    E_EQUAL = 4,
    E_UNEQUAL = 5,
    E_CHOICE = 6,
    E_SYMBOL = 7,
    E_RANGE = 8
} ;
#line 38
struct expr;
#line 38
struct symbol;
#line 38 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
union expr_data {
   struct expr *expr ;
   struct symbol *sym ;
};
#line 43 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct expr {
   enum expr_type type ;
   union expr_data left ;
   union expr_data right ;
};
#line 52 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct expr_value {
   struct expr *expr ;
   tristate tri ;
};
#line 57 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct symbol_value {
   void *val ;
   tristate tri ;
};
#line 62
enum symbol_type {
    S_UNKNOWN = 0,
    S_BOOLEAN = 1,
    S_TRISTATE = 2,
    S_INT = 3,
    S_HEX = 4,
    S_STRING = 5,
    S_OTHER = 6
} ;
#line 66
struct property;
#line 66 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct symbol {
   struct symbol *next ;
   char *name ;
   char *help ;
   enum symbol_type type ;
   struct symbol_value curr ;
   struct symbol_value user ;
   tristate visible ;
   int flags ;
   struct property *prop ;
   struct expr *dep ;
   struct expr *dep2 ;
   struct expr_value rev_dep ;
};
#line 102
enum prop_type {
    P_UNKNOWN = 0,
    P_PROMPT = 1,
    P_COMMENT = 2,
    P_MENU = 3,
    P_DEFAULT = 4,
    P_CHOICE = 5,
    P_SELECT = 6,
    P_RANGE = 7
} ;
#line 106
struct menu;
#line 106 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct property {
   struct property *next ;
   struct symbol *sym ;
   enum prop_type type ;
   char const   *text ;
   struct expr_value visible ;
   struct expr *expr ;
   struct menu *menu ;
   struct file *file ;
   int lineno ;
};
#line 127 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct menu {
   struct menu *next ;
   struct menu *parent ;
   struct menu *list ;
   struct symbol *sym ;
   struct property *prompt ;
   struct expr *dep ;
   unsigned int flags ;
   struct file *file ;
   int lineno ;
   void *data ;
};
#line 22 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
enum __anonenum_input_mode_24 {
    ask_all = 0,
    ask_new = 1,
    ask_silent = 2,
    set_default = 3,
    set_yes = 4,
    set_mod = 5,
    set_no = 6,
    set_random = 7
} ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 176 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct gstr;
#line 44 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
struct kconf_id {
   int name ;
   int token ;
   unsigned int flags ;
   enum symbol_type stype ;
};
#line 88 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
struct gstr {
   size_t len ;
   char *s ;
};
#line 89 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.hash.c"
struct kconf_id_strings_t {
   char kconf_id_strings_str2[sizeof("if")] ;
   char kconf_id_strings_str3[sizeof("int")] ;
   char kconf_id_strings_str4[sizeof("help")] ;
   char kconf_id_strings_str5[sizeof("endif")] ;
   char kconf_id_strings_str6[sizeof("select")] ;
   char kconf_id_strings_str7[sizeof("endmenu")] ;
   char kconf_id_strings_str8[sizeof("tristate")] ;
   char kconf_id_strings_str9[sizeof("endchoice")] ;
   char kconf_id_strings_str10[sizeof("range")] ;
   char kconf_id_strings_str11[sizeof("string")] ;
   char kconf_id_strings_str12[sizeof("default")] ;
   char kconf_id_strings_str13[sizeof("def_bool")] ;
   char kconf_id_strings_str14[sizeof("menu")] ;
   char kconf_id_strings_str16[sizeof("def_boolean")] ;
   char kconf_id_strings_str17[sizeof("def_tristate")] ;
   char kconf_id_strings_str18[sizeof("mainmenu")] ;
   char kconf_id_strings_str20[sizeof("menuconfig")] ;
   char kconf_id_strings_str21[sizeof("config")] ;
   char kconf_id_strings_str22[sizeof("on")] ;
   char kconf_id_strings_str23[sizeof("hex")] ;
   char kconf_id_strings_str26[sizeof("source")] ;
   char kconf_id_strings_str27[sizeof("depends")] ;
   char kconf_id_strings_str28[sizeof("optional")] ;
   char kconf_id_strings_str31[sizeof("enable")] ;
   char kconf_id_strings_str32[sizeof("comment")] ;
   char kconf_id_strings_str33[sizeof("requires")] ;
   char kconf_id_strings_str34[sizeof("bool")] ;
   char kconf_id_strings_str37[sizeof("boolean")] ;
   char kconf_id_strings_str41[sizeof("choice")] ;
   char kconf_id_strings_str46[sizeof("prompt")] ;
};
#line 192 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
union YYSTYPE {
   char *string ;
   struct file *file ;
   struct symbol *symbol ;
   struct expr *expr ;
   struct menu *menu ;
   struct kconf_id *id ;
};
#line 192 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
typedef union YYSTYPE YYSTYPE;
#line 255 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
union yyalloc {
   short yyss ;
   YYSTYPE yyvs ;
};
#line 43 "scripts/kconfig/lex.zconf.c"
typedef short flex_int16_t;
#line 44 "scripts/kconfig/lex.zconf.c"
typedef int flex_int32_t;
#line 139
struct yy_buffer_state;
#line 139 "scripts/kconfig/lex.zconf.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 175 "scripts/kconfig/lex.zconf.c"
typedef unsigned int yy_size_t;
#line 180 "scripts/kconfig/lex.zconf.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 333 "scripts/kconfig/lex.zconf.c"
typedef int yy_state_type;
#line 756 "scripts/kconfig/lex.zconf.c"
struct __anonstruct_current_pos_30 {
   struct file *file ;
   int lineno ;
};
#line 764 "scripts/kconfig/lex.zconf.c"
struct buffer {
   struct buffer *parent ;
   YY_BUFFER_STATE state ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_32 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_32 regmatch_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 578 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 46 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
int exitstatus  =    0;
#line 49 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
DFL *defaultline  ;
#line 52 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
FILEONLY *internalfunctions  ;
#line 53 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
FILEONLY *externalfunctions  ;
#line 54 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
FILEONLY *symbolsonly  ;
#line 57 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
FILELINE *singlefunctions  ;
#line 58 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
FILELINE *entity_system  ;
#line 68 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void usage(void) 
{ 


  {
  {
#line 70
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: docproc {doc|depend} file\n");
#line 71
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Input is read from file.tmpl. Output is sent to stdout\n");
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"doc: frontend when generating kernel documentation\n");
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"depend: generate list of files referenced within file\n");
  }
#line 74
  return;
}
}
#line 79 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void exec_kernel_doc(char **svec ) 
{ 
  pid_t pid ;
  int ret ;
  char *real_filename ;
  int rflen ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  union __anonunion_53 __constr_expr_0 ;
  union __anonunion_54 __constr_expr_1 ;

  {
  {
#line 87
  fflush(stdout);
#line 88
  pid = fork();
  }
  {
#line 89
  if (pid == -1) {
#line 89
    goto case_neg_1;
  }
#line 92
  if (pid == 0) {
#line 92
    goto case_0;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 90
  perror("vfork" + 1);
#line 91
  exit(1);
  }
  case_0: /* CIL Label */ 
  {
#line 93
  tmp = getenv("SRCTREE");
#line 93
  tmp___0 = strlen((char const   *)tmp);
#line 93
  rflen = (int )tmp___0;
#line 94
  tmp___1 = strlen("scripts/kernel-doc");
#line 94
  rflen = (int )((size_t )rflen + tmp___1);
#line 95
  tmp___2 = __builtin_alloca((unsigned long )(rflen + 1));
#line 95
  real_filename = (char *)tmp___2;
#line 96
  tmp___3 = getenv("SRCTREE");
#line 96
  strcpy((char */* __restrict  */)real_filename, (char const   */* __restrict  */)tmp___3);
#line 97
  strcat((char */* __restrict  */)real_filename, (char const   */* __restrict  */)"scripts/kernel-doc");
#line 98
  execvp((char const   *)real_filename, (char * const  *)svec);
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"exec ");
#line 100
  perror((char const   *)real_filename);
#line 101
  exit(1);
  }
  switch_default: /* CIL Label */ 
  {
#line 103
  waitpid(pid, & ret, 0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  __constr_expr_1.__in = ret;
#line 105
  if ((__constr_expr_1.__i & 127) == 0) {
#line 106
    __constr_expr_0.__in = ret;
#line 106
    exitstatus |= (__constr_expr_0.__i & 65280) >> 8;
  } else {
#line 108
    exitstatus = 255;
  }
#line 109
  return;
}
}
#line 124 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
struct symfile symfilelist[250]  ;
#line 125 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
int symfilecnt  =    0;
#line 127 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void add_new_symbol(struct symfile *sym , char *symname ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 129
  tmp = realloc((void *)sym->symbollist, (unsigned long )(sym->symbolcnt + 1) * sizeof(char *));
#line 129
  sym->symbollist = (struct symbols *)tmp;
#line 131
  tmp___0 = sym->symbolcnt;
#line 131
  (sym->symbolcnt) ++;
#line 131
  (sym->symbollist + tmp___0)->name = strdup((char const   *)symname);
  }
#line 132
  return;
}
}
#line 135 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
struct symfile *add_new_file(char *filename ) 
{ 
  int tmp ;

  {
  {
#line 137
  tmp = symfilecnt;
#line 137
  symfilecnt ++;
#line 137
  symfilelist[tmp].filename = strdup((char const   *)filename);
  }
#line 138
  return (& symfilelist[symfilecnt - 1]);
}
}
#line 141 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
struct symfile *filename_exist(char *filename ) 
{ 
  int i ;
  int tmp ;

  {
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < symfilecnt)) {
#line 144
      goto while_break;
    }
    {
#line 145
    tmp = strcmp((char const   *)symfilelist[i].filename, (char const   *)filename);
    }
#line 145
    if (tmp == 0) {
#line 146
      return (& symfilelist[i]);
    }
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return ((struct symfile *)((void *)0));
}
}
#line 154 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void adddep(char *file ) 
{ 


  {
  {
#line 154
  printf((char const   */* __restrict  */)"\t%s", file);
  }
#line 154
  return;
}
}
#line 155 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void adddep2(char *file , char *line___0 ) 
{ 


  {
  {
#line 155
  line___0 = line___0;
#line 155
  adddep(file);
  }
#line 155
  return;
}
}
#line 156 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void noaction(char *line___0 ) 
{ 


  {
#line 156
  line___0 = line___0;
#line 156
  return;
}
}
#line 157 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void noaction2(char *file , char *line___0 ) 
{ 


  {
#line 157
  file = file;
#line 157
  line___0 = line___0;
#line 157
  return;
}
}
#line 160 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void printline(char *line___0 ) 
{ 


  {
  {
#line 160
  printf((char const   */* __restrict  */)"%s", line___0);
  }
#line 160
  return;
}
}
#line 167 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void find_export_symbols(char *filename ) 
{ 
  FILE *fp ;
  struct symfile *sym ;
  char line___0[2048] ;
  int rflen ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *real_filename ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *p ;
  char *e ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  struct symfile *tmp___9 ;

  {
  {
#line 172
  tmp___9 = filename_exist(filename);
  }
#line 172
  if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
    {
#line 173
    tmp = getenv("SRCTREE");
#line 173
    tmp___0 = strlen((char const   *)tmp);
#line 173
    tmp___1 = strlen((char const   *)filename);
#line 173
    rflen = (int )(tmp___0 + tmp___1);
#line 174
    tmp___2 = __builtin_alloca((unsigned long )(rflen + 1));
#line 174
    real_filename = (char *)tmp___2;
#line 175
    tmp___3 = getenv("SRCTREE");
#line 175
    strcpy((char */* __restrict  */)real_filename, (char const   */* __restrict  */)tmp___3);
#line 176
    strcat((char */* __restrict  */)real_filename, (char const   */* __restrict  */)filename);
#line 177
    sym = add_new_file(filename);
#line 178
    fp = fopen((char const   */* __restrict  */)real_filename, (char const   */* __restrict  */)"r");
    }
#line 179
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 181
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"docproc: ");
#line 182
      perror((char const   *)real_filename);
      }
    }
    {
#line 184
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 184
      tmp___8 = fgets((char */* __restrict  */)(line___0), 2048, (FILE */* __restrict  */)fp);
      }
#line 184
      if (! tmp___8) {
#line 184
        goto while_break;
      }
      {
#line 187
      p = strstr((char const   *)(line___0), "EXPORT_SYMBOL_GPL");
      }
#line 187
      if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 187
        goto _L;
      } else {
        {
#line 187
        p = strstr((char const   *)(line___0), "EXPORT_SYMBOL");
        }
#line 187
        if ((unsigned long )p != (unsigned long )((char *)0)) {
          _L: /* CIL Label */ 
          {
#line 190
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 190
            tmp___4 = __ctype_b_loc();
            }
#line 190
            if (! ((int const   )*(*tmp___4 + (int )*p) & 8)) {
#line 190
              if (! ((int )*p == 95)) {
#line 190
                goto while_break___0;
              }
            }
#line 191
            p ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 193
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 193
            tmp___5 = __ctype_b_loc();
            }
#line 193
            if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 193
              goto while_break___1;
            }
#line 194
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 195
          if ((int )*p != 40) {
#line 196
            goto while_continue;
          } else {
#line 198
            p ++;
          }
          {
#line 199
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 199
            tmp___6 = __ctype_b_loc();
            }
#line 199
            if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 199
              goto while_break___2;
            }
#line 200
            p ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 201
          e = p;
          {
#line 202
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 202
            tmp___7 = __ctype_b_loc();
            }
#line 202
            if (! ((int const   )*(*tmp___7 + (int )*e) & 8)) {
#line 202
              if (! ((int )*e == 95)) {
#line 202
                goto while_break___3;
              }
            }
#line 203
            e ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 204
          *e = (char )'\000';
#line 205
          add_new_symbol(sym, p);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 208
    fclose(fp);
    }
  }
#line 210
  return;
}
}
#line 221 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void docfunctions(char *filename , char *type ) 
{ 
  int i ;
  int j ;
  int symcnt ;
  int idx ;
  char **vec ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct symfile *sym ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 224
  symcnt = 0;
#line 225
  idx = 0;
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (i <= symfilecnt)) {
#line 228
      goto while_break;
    }
#line 229
    symcnt += symfilelist[i].symbolcnt;
#line 228
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  tmp = malloc((unsigned long )((2 + 2 * symcnt) + 2) * sizeof(char *));
#line 230
  vec = (char **)tmp;
  }
#line 231
  if ((unsigned long )vec == (unsigned long )((void *)0)) {
    {
#line 232
    perror("docproc: ");
#line 233
    exit(1);
    }
  }
#line 235
  tmp___0 = idx;
#line 235
  idx ++;
#line 235
  *(vec + tmp___0) = (char *)"kernel-doc";
#line 236
  tmp___1 = idx;
#line 236
  idx ++;
#line 236
  *(vec + tmp___1) = (char *)"-docbook";
#line 237
  i = 0;
  {
#line 237
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 237
    if (! (i < symfilecnt)) {
#line 237
      goto while_break___0;
    }
#line 238
    sym = & symfilelist[i];
#line 239
    j = 0;
    {
#line 239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 239
      if (! (j < sym->symbolcnt)) {
#line 239
        goto while_break___1;
      }
#line 240
      tmp___2 = idx;
#line 240
      idx ++;
#line 240
      *(vec + tmp___2) = type;
#line 241
      tmp___3 = idx;
#line 241
      idx ++;
#line 241
      *(vec + tmp___3) = (sym->symbollist + j)->name;
#line 239
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 237
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 244
  tmp___4 = idx;
#line 244
  idx ++;
#line 244
  *(vec + tmp___4) = filename;
#line 245
  *(vec + idx) = (char *)((void *)0);
#line 246
  printf((char const   */* __restrict  */)"<!-- %s -->\n", filename);
#line 247
  exec_kernel_doc(vec);
#line 248
  fflush(stdout);
#line 249
  free((void *)vec);
  }
#line 250
  return;
}
}
#line 251 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void intfunc(char *filename ) 
{ 


  {
  {
#line 251
  docfunctions(filename, (char *)"-nofunction");
  }
#line 251
  return;
}
}
#line 252 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void extfunc(char *filename ) 
{ 


  {
  {
#line 252
  docfunctions(filename, (char *)"-function");
  }
#line 252
  return;
}
}
#line 259 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void singfunc(char *filename , char *line___0 ) 
{ 
  char *vec[200] ;
  int i ;
  int idx ;
  int startofsym ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 262
  idx = 0;
#line 263
  startofsym = 1;
#line 264
  tmp = idx;
#line 264
  idx ++;
#line 264
  vec[tmp] = (char *)"kernel-doc";
#line 265
  tmp___0 = idx;
#line 265
  idx ++;
#line 265
  vec[tmp___0] = (char *)"-docbook";
#line 268
  i = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! *(line___0 + i)) {
#line 268
      goto while_break;
    }
    {
#line 269
    tmp___1 = __ctype_b_loc();
    }
#line 269
    if ((int const   )*(*tmp___1 + (int )*(line___0 + i)) & 8192) {
#line 270
      *(line___0 + i) = (char )'\000';
#line 271
      startofsym = 1;
#line 272
      goto __Cont;
    }
#line 274
    if (startofsym) {
#line 275
      startofsym = 0;
#line 276
      tmp___2 = idx;
#line 276
      idx ++;
#line 276
      vec[tmp___2] = (char *)"-function";
#line 277
      tmp___3 = idx;
#line 277
      idx ++;
#line 277
      vec[tmp___3] = line___0 + i;
    }
    __Cont: /* CIL Label */ 
#line 268
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  tmp___4 = idx;
#line 280
  idx ++;
#line 280
  vec[tmp___4] = filename;
#line 281
  vec[idx] = (char *)((void *)0);
#line 282
  exec_kernel_doc(vec);
  }
#line 283
  return;
}
}
#line 293 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
void parse_file(FILE *infile ) 
{ 
  char line___0[2048] ;
  char *s ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 297
    tmp___5 = fgets((char */* __restrict  */)(line___0), 2048, (FILE */* __restrict  */)infile);
    }
#line 297
    if (! tmp___5) {
#line 297
      goto while_break;
    }
#line 298
    if ((int )line___0[0] == 33) {
#line 299
      s = line___0 + 2;
      {
#line 301
      if ((int )line___0[1] == 69) {
#line 301
        goto case_69;
      }
#line 306
      if ((int )line___0[1] == 73) {
#line 306
        goto case_73;
      }
#line 311
      if ((int )line___0[1] == 68) {
#line 311
        goto case_68;
      }
#line 316
      if ((int )line___0[1] == 70) {
#line 316
        goto case_70;
      }
#line 325
      goto switch_default;
      case_69: /* CIL Label */ 
      {
#line 302
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 302
        if (*s) {
          {
#line 302
          tmp = __ctype_b_loc();
          }
#line 302
          if ((int const   )*(*tmp + (int )*s) & 8192) {
#line 302
            goto while_break___0;
          }
        } else {
#line 302
          goto while_break___0;
        }
#line 302
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 303
      *s = (char )'\000';
#line 304
      (*externalfunctions)(line___0 + 2);
      }
#line 305
      goto switch_break;
      case_73: /* CIL Label */ 
      {
#line 307
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 307
        if (*s) {
          {
#line 307
          tmp___0 = __ctype_b_loc();
          }
#line 307
          if ((int const   )*(*tmp___0 + (int )*s) & 8192) {
#line 307
            goto while_break___1;
          }
        } else {
#line 307
          goto while_break___1;
        }
#line 307
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 308
      *s = (char )'\000';
#line 309
      (*internalfunctions)(line___0 + 2);
      }
#line 310
      goto switch_break;
      case_68: /* CIL Label */ 
      {
#line 312
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 312
        if (*s) {
          {
#line 312
          tmp___1 = __ctype_b_loc();
          }
#line 312
          if ((int const   )*(*tmp___1 + (int )*s) & 8192) {
#line 312
            goto while_break___2;
          }
        } else {
#line 312
          goto while_break___2;
        }
#line 312
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 313
      *s = (char )'\000';
#line 314
      (*symbolsonly)(line___0 + 2);
      }
#line 315
      goto switch_break;
      case_70: /* CIL Label */ 
      {
#line 318
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 318
        if (*s) {
          {
#line 318
          tmp___2 = __ctype_b_loc();
          }
#line 318
          if ((int const   )*(*tmp___2 + (int )*s) & 8192) {
#line 318
            goto while_break___3;
          }
        } else {
#line 318
          goto while_break___3;
        }
#line 318
        s ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 319
      tmp___3 = s;
#line 319
      s ++;
#line 319
      *tmp___3 = (char )'\000';
      {
#line 321
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 321
        tmp___4 = __ctype_b_loc();
        }
#line 321
        if (! ((int const   )*(*tmp___4 + (int )*s) & 8192)) {
#line 321
          goto while_break___4;
        }
#line 322
        s ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 323
      (*singlefunctions)(line___0 + 2, s);
      }
#line 324
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 326
      (*defaultline)(line___0);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 330
      (*defaultline)(line___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  fflush(stdout);
  }
#line 334
  return;
}
}
#line 337 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/docproc.c"
int main(int argc , char **argv ) 
{ 
  FILE *infile ;
  int tmp ;
  int tmp___0 ;

  {
#line 340
  if (argc != 3) {
    {
#line 341
    usage();
#line 342
    exit(1);
    }
  }
  {
#line 345
  infile = fopen((char const   */* __restrict  */)*(argv + 2), (char const   */* __restrict  */)"r");
  }
#line 346
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 347
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"docproc: ");
#line 348
    perror((char const   *)*(argv + 2));
#line 349
    exit(2);
    }
  }
  {
#line 352
  tmp___0 = strcmp("doc", (char const   *)*(argv + 1));
  }
#line 352
  if (tmp___0 == 0) {
    {
#line 362
    defaultline = & noaction;
#line 363
    internalfunctions = & find_export_symbols;
#line 364
    externalfunctions = & find_export_symbols;
#line 365
    symbolsonly = & find_export_symbols;
#line 366
    singlefunctions = & noaction2;
#line 367
    parse_file(infile);
#line 370
    fseek(infile, 0L, 0);
#line 371
    defaultline = & printline;
#line 372
    internalfunctions = & intfunc;
#line 373
    externalfunctions = & extfunc;
#line 374
    symbolsonly = & printline;
#line 375
    singlefunctions = & singfunc;
#line 377
    parse_file(infile);
    }
  } else {
    {
#line 379
    tmp = strcmp("depend", (char const   *)*(argv + 1));
    }
#line 379
    if (tmp == 0) {
      {
#line 383
      printf((char const   */* __restrict  */)"%s\t", *(argv + 2));
#line 384
      defaultline = & noaction;
#line 385
      internalfunctions = & adddep;
#line 386
      externalfunctions = & adddep;
#line 387
      symbolsonly = & adddep;
#line 388
      singlefunctions = & adddep2;
#line 389
      parse_file(infile);
#line 390
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 394
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option: %s\n",
              *(argv + 1));
#line 395
      exit(1);
      }
    }
  }
  {
#line 397
  fclose(infile);
#line 398
  fflush(stdout);
  }
#line 399
  return (exitstatus);
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 125 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
char *target  ;
#line 126 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
char *depfile  ;
#line 127 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
char *cmdline  ;
#line 139 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void print_cmdline(void) 
{ 


  {
  {
#line 141
  printf((char const   */* __restrict  */)"cmd_%s := %s\n\n", target, cmdline);
  }
#line 142
  return;
}
}
#line 144 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
char *str_config  =    (char *)((void *)0);
#line 145 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
int size_config  =    0;
#line 146 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
int len_config  =    0;
#line 152 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void grow_config(int len ) 
{ 
  void *tmp ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (len_config + len > size_config)) {
#line 154
      goto while_break;
    }
#line 155
    if (size_config == 0) {
#line 156
      size_config = 2048;
    }
    {
#line 157
    size_config *= 2;
#line 157
    tmp = realloc((void *)str_config, (size_t )size_config);
#line 157
    str_config = (char *)tmp;
    }
#line 158
    if ((unsigned long )str_config == (unsigned long )((void *)0)) {
      {
#line 159
      perror("fixdep:malloc");
#line 159
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 168 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
int is_defined_config(char const   *name , int len ) 
{ 
  char const   *pconfig ;
  char const   *plast ;
  int tmp ;

  {
#line 171
  plast = (char const   *)((str_config + len_config) - len);
#line 172
  pconfig = (char const   *)(str_config + 1);
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! ((unsigned long )pconfig < (unsigned long )plast)) {
#line 172
      goto while_break;
    }
#line 173
    if ((int const   )*(pconfig + -1) == 10) {
#line 173
      if ((int const   )*(pconfig + len) == 10) {
        {
#line 173
        tmp = memcmp((void const   *)pconfig, (void const   *)name, (size_t )len);
        }
#line 173
        if (! tmp) {
#line 176
          return (1);
        }
      }
    }
#line 172
    pconfig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return (0);
}
}
#line 184 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void define_config(char const   *name , int len ) 
{ 
  int tmp ;

  {
  {
#line 186
  grow_config(len + 1);
#line 188
  memcpy((void */* __restrict  */)(str_config + len_config), (void const   */* __restrict  */)name,
         (size_t )len);
#line 189
  len_config += len;
#line 190
  tmp = len_config;
#line 190
  len_config ++;
#line 190
  *(str_config + tmp) = (char )'\n';
  }
#line 191
  return;
}
}
#line 196 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void clear_config(void) 
{ 


  {
  {
#line 198
  len_config = 0;
#line 199
  define_config("", 0);
  }
#line 200
  return;
}
}
#line 205 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void use_config(char *m , int slen ) 
{ 
  char *s ;
  void *tmp ;
  char *p ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 207
  tmp = __builtin_alloca((unsigned long )(slen + 1));
#line 207
  s = (char *)tmp;
#line 210
  tmp___0 = is_defined_config((char const   *)m, slen);
  }
#line 210
  if (tmp___0) {
#line 211
    return;
  }
  {
#line 213
  define_config((char const   *)m, slen);
#line 215
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)m, (size_t )slen);
#line 215
  *(s + slen) = (char)0;
#line 217
  p = s;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((unsigned long )p < (unsigned long )(s + slen))) {
#line 217
      goto while_break;
    }
#line 218
    if ((int )*p == 95) {
#line 219
      *p = (char )'/';
    } else {
      {
#line 221
      tmp___1 = tolower((int )*p);
#line 221
      *p = (char )tmp___1;
      }
    }
#line 217
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  printf((char const   */* __restrict  */)"    $(wildcard include/config/%s.h) \\\n",
         s);
  }
#line 224
  return;
}
}
#line 226 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void parse_config_file(char *map , size_t len ) 
{ 
  char *end_3 ;
  char *end_7 ;
  char *p ;
  char *q ;
  int off ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 229
  end_3 = (map + len) - 3;
#line 230
  end_7 = (map + len) - 7;
#line 231
  p = map;
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! ((unsigned long )p <= (unsigned long )end_3)) {
#line 235
      goto while_break;
    }
    {
#line 237
    tmp = __ctype_b_loc();
    }
#line 237
    if (! ((int const   )*(*tmp + (int )*p) & 8)) {
#line 237
      if (! ((int )*p == 95)) {
#line 238
        goto __Cont;
      }
    }
#line 241
    if ((unsigned long )p < (unsigned long )end_7) {
#line 241
      if ((int )*(p + 6) == 95) {
        {
#line 242
        tmp___0 = memcmp((void const   *)p, (void const   *)"CONFIG", (size_t )6);
        }
#line 242
        if (! tmp___0) {
#line 242
          goto conf7;
        }
        {
#line 243
        tmp___1 = memcmp((void const   *)p, (void const   *)"ENABLE", (size_t )6);
        }
#line 243
        if (! tmp___1) {
#line 243
          goto conf7;
        }
        {
#line 244
        tmp___2 = memcmp((void const   *)p, (void const   *)"IF_NOT", (size_t )6);
        }
#line 244
        if (! tmp___2) {
#line 244
          goto conf7;
        }
      }
    }
#line 248
    if ((int )*(p + 0) == 73) {
#line 248
      if ((int )*(p + 1) == 70) {
#line 248
        if ((int )*(p + 2) == 95) {
#line 249
          off = 3;
#line 250
          goto conf;
        }
      }
    }
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if ((unsigned long )p <= (unsigned long )end_3) {
        {
#line 254
        tmp___3 = __ctype_b_loc();
        }
#line 254
        if (! ((int const   )*(*tmp___3 + (int )*p) & 8)) {
#line 254
          if (! ((int )*p == 95)) {
#line 254
            goto while_break___0;
          }
        }
      } else {
#line 254
        goto while_break___0;
      }
#line 255
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    goto __Cont;
    conf7: 
#line 258
    off = 7;
    conf: 
#line 260
    p += off;
#line 261
    q = p;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! ((unsigned long )q < (unsigned long )(end_3 + 3))) {
#line 261
        goto while_break___1;
      }
      {
#line 262
      tmp___4 = __ctype_b_loc();
      }
#line 262
      if (! ((int const   )*(*tmp___4 + (int )*q) & 8)) {
#line 262
        if (! ((int )*q == 95)) {
#line 263
          goto while_break___1;
        }
      }
#line 261
      q ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 265
    if ((unsigned long )q != (unsigned long )p) {
      {
#line 266
      use_config(p, (int )(q - p));
      }
    }
    __Cont: /* CIL Label */ 
#line 235
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return;
}
}
#line 272 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
int strrcmp(char *s , char *sub ) 
{ 
  int slen ;
  size_t tmp ;
  int sublen ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 274
  tmp = strlen((char const   *)s);
#line 274
  slen = (int )tmp;
#line 275
  tmp___0 = strlen((char const   *)sub);
#line 275
  sublen = (int )tmp___0;
  }
#line 277
  if (sublen > slen) {
#line 278
    return (1);
  }
  {
#line 280
  tmp___1 = memcmp((void const   *)((s + slen) - sublen), (void const   *)sub, (size_t )sublen);
  }
#line 280
  return (tmp___1);
}
}
#line 283 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void do_config_file(char *filename ) 
{ 
  struct stat st ;
  int fd ;
  void *map ;

  {
  {
#line 289
  fd = open((char const   *)filename, 0);
  }
#line 290
  if (fd < 0) {
    {
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: ");
#line 292
    perror((char const   *)filename);
#line 293
    exit(2);
    }
  }
  {
#line 295
  fstat(fd, & st);
  }
#line 296
  if (st.st_size == 0L) {
    {
#line 297
    close(fd);
    }
#line 298
    return;
  }
  {
#line 300
  map = mmap((void *)0, (size_t )st.st_size, 1, 2, fd, (__off_t )0);
  }
#line 301
  if ((long )map == -1L) {
    {
#line 302
    perror("fixdep: mmap");
#line 303
    close(fd);
    }
#line 304
    return;
  }
  {
#line 307
  parse_config_file((char *)map, (size_t )st.st_size);
#line 309
  munmap(map, (size_t )st.st_size);
#line 311
  close(fd);
  }
#line 312
  return;
}
}
#line 314 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void parse_dep_file(void *map , size_t len ) 
{ 
  char *m ;
  char *end ;
  char *p ;
  char *s ;
  void *tmp ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 316
  m = (char *)map;
#line 317
  end = m + len;
#line 319
  tmp = __builtin_alloca(len);
#line 319
  s = (char *)tmp;
#line 321
  tmp___0 = memchr((void const   *)m, ':', len);
#line 321
  p = (char *)tmp___0;
  }
#line 322
  if (! p) {
    {
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: parse error\n");
#line 324
    exit(1);
    }
  }
  {
#line 326
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)m, (size_t )(p - m));
#line 326
  *(s + (p - m)) = (char)0;
#line 327
  printf((char const   */* __restrict  */)"deps_%s := \\\n", target);
#line 328
  m = p + 1;
#line 330
  clear_config();
  }
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! ((unsigned long )m < (unsigned long )end)) {
#line 332
      goto while_break;
    }
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      if ((unsigned long )m < (unsigned long )end) {
#line 333
        if (! ((int )*m == 32)) {
#line 333
          if (! ((int )*m == 92)) {
#line 333
            if (! ((int )*m == 10)) {
#line 333
              if (! ((int )*m == 13)) {
#line 333
                goto while_break___0;
              }
            }
          }
        }
      } else {
#line 333
        goto while_break___0;
      }
#line 334
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 335
    p = m;
    {
#line 336
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 336
      if ((unsigned long )p < (unsigned long )end) {
#line 336
        if (! ((int )*p != 32)) {
#line 336
          goto while_break___1;
        }
      } else {
#line 336
        goto while_break___1;
      }
#line 336
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 337
    if ((unsigned long )p == (unsigned long )end) {
      {
#line 338
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 338
        p --;
#line 338
        tmp___1 = __ctype_b_loc();
        }
#line 338
        if ((int const   )*(*tmp___1 + (int )*p) & 8) {
#line 338
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 339
      p ++;
    }
    {
#line 341
    memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)m, (size_t )(p - m));
#line 341
    *(s + (p - m)) = (char)0;
#line 342
    tmp___2 = strrcmp(s, (char *)"include/autoconf.h");
    }
#line 342
    if (tmp___2) {
      {
#line 342
      tmp___3 = strrcmp(s, (char *)"arch/um/include/uml-config.h");
      }
#line 342
      if (tmp___3) {
        {
#line 342
        tmp___4 = strrcmp(s, (char *)".ver");
        }
#line 342
        if (tmp___4) {
          {
#line 345
          printf((char const   */* __restrict  */)"  %s \\\n", s);
#line 346
          do_config_file(s);
          }
        }
      }
    }
#line 348
    m = p + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 350
  printf((char const   */* __restrict  */)"\n%s: $(deps_%s)\n\n", target, target);
#line 351
  printf((char const   */* __restrict  */)"$(deps_%s):\n", target);
  }
#line 352
  return;
}
}
#line 354 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void print_deps(void) 
{ 
  struct stat st ;
  int fd ;
  void *map ;

  {
  {
#line 360
  fd = open((char const   *)depfile, 0);
  }
#line 361
  if (fd < 0) {
    {
#line 362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: ");
#line 363
    perror((char const   *)depfile);
#line 364
    exit(2);
    }
  }
  {
#line 366
  fstat(fd, & st);
  }
#line 367
  if (st.st_size == 0L) {
    {
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: %s is empty\n",
            depfile);
#line 369
    close(fd);
    }
#line 370
    return;
  }
  {
#line 372
  map = mmap((void *)0, (size_t )st.st_size, 1, 2, fd, (__off_t )0);
  }
#line 373
  if ((long )map == -1L) {
    {
#line 374
    perror("fixdep: mmap");
#line 375
    close(fd);
    }
#line 376
    return;
  }
  {
#line 379
  parse_dep_file(map, (size_t )st.st_size);
#line 381
  munmap(map, (size_t )st.st_size);
#line 383
  close(fd);
  }
#line 384
  return;
}
}
#line 386 "/home/june/collector/temp/busybox-1.21.0/scripts/basic/fixdep.c"
void traps(void) 
{ 


  {
#line 397
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 321
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 580
extern int putchar(int __c ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 3 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc_proto.h"
void conf_parse(char const   *name ) ;
#line 4
int conf_read(char const   *name ) ;
#line 5
int conf_read_simple(char const   *name ) ;
#line 6
int conf_write(char const   *name ) ;
#line 9
struct menu rootmenu ;
#line 11
_Bool menu_is_visible(struct menu *menu ) ;
#line 12
char const   *menu_get_prompt(struct menu *menu ) ;
#line 14
struct menu *menu_get_parent_menu(struct menu *menu ) ;
#line 24
void sym_calc_value(struct symbol *sym ) ;
#line 25
enum symbol_type sym_get_type(struct symbol *sym ) ;
#line 26
_Bool sym_tristate_within_range(struct symbol *sym , tristate val ) ;
#line 27
_Bool sym_set_tristate_value(struct symbol *sym , tristate val ) ;
#line 31
_Bool sym_set_string_value(struct symbol *sym , char const   *newval ) ;
#line 32
_Bool sym_is_changable(struct symbol *sym ) ;
#line 35
char const   *sym_get_string_value(struct symbol *sym ) ;
#line 65 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
char *conf_get_default_confname(void) ;
#line 107 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
__inline static tristate sym_get_tristate_value(struct symbol *sym ) 
{ 


  {
#line 109
  return (sym->curr.tri);
}
}
#line 113 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
__inline static struct symbol *sym_get_choice_value(struct symbol *sym ) 
{ 


  {
#line 115
  return ((struct symbol *)sym->curr.val);
}
}
#line 118 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_set_choice_value(struct symbol *ch , struct symbol *chval ) 
{ 
  _Bool tmp ;

  {
  {
#line 120
  tmp = sym_set_tristate_value(chval, (tristate )2);
  }
#line 120
  return (tmp);
}
}
#line 123 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_choice(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 125
  if (sym->flags & 16) {
#line 125
    tmp = 1;
  } else {
#line 125
    tmp = 0;
  }
#line 125
  return ((_Bool )tmp);
}
}
#line 138 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_has_value(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 140
  if (sym->flags & 2048) {
#line 140
    tmp = 0;
  } else {
#line 140
    tmp = 1;
  }
#line 140
  return ((_Bool )tmp);
}
}
#line 19 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static void conf(struct menu *menu ) ;
#line 20
static void check_conf(struct menu *menu ) ;
#line 22 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
enum __anonenum_input_mode_24 input_mode  =    (enum __anonenum_input_mode_24 )0;
#line 32 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
char *defconfig_file  ;
#line 34 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static int indent  =    1;
#line 35 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static int valid_stdin  =    1;
#line 36 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static int conf_cnt  ;
#line 37 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static char line[128]  ;
#line 38 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static struct menu *rootEntry  ;
#line 40 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static char nohelp_text[47]  = 
#line 40
  {      (char )'S',      (char )'o',      (char )'r',      (char )'r', 
        (char )'y',      (char )',',      (char )' ',      (char )'n', 
        (char )'o',      (char )' ',      (char )'h',      (char )'e', 
        (char )'l',      (char )'p',      (char )' ',      (char )'a', 
        (char )'v',      (char )'a',      (char )'i',      (char )'l', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'t',      (char )'h',      (char )'i', 
        (char )'s',      (char )' ',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'y',      (char )'e',      (char )'t', 
        (char )'.',      (char )'\n',      (char )'\000'};
#line 42 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static void strip(char *str ) 
{ 
  char *p ;
  int l ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 44
  p = str;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    tmp = __ctype_b_loc();
    }
#line 47
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 47
      goto while_break;
    }
#line 48
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  tmp___0 = strlen((char const   *)p);
#line 49
  l = (int )tmp___0;
  }
#line 50
  if ((unsigned long )p != (unsigned long )str) {
    {
#line 51
    memmove((void *)str, (void const   *)p, (size_t )(l + 1));
    }
  }
#line 52
  if (! l) {
#line 53
    return;
  }
#line 54
  p = (str + l) - 1;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 55
    tmp___2 = __ctype_b_loc();
    }
#line 55
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 55
      goto while_break___0;
    }
#line 56
    tmp___1 = p;
#line 56
    p --;
#line 56
    *tmp___1 = (char)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 57
  return;
}
}
#line 59 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static void check_stdin(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 61
  if (! valid_stdin) {
#line 61
    if ((unsigned int )input_mode == 2U) {
      {
#line 62
      tmp = gettext("aborted!\n\n");
#line 62
      printf((char const   */* __restrict  */)tmp);
#line 63
      tmp___0 = gettext("Console input/output is redirected. ");
#line 63
      printf((char const   */* __restrict  */)tmp___0);
#line 64
      tmp___1 = gettext("Run \'make oldconfig\' to update configuration.\n\n");
#line 64
      printf((char const   */* __restrict  */)tmp___1);
#line 65
      exit(1);
      }
    }
  }
#line 67
  return;
}
}
#line 69 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static void conf_askvalue(struct symbol *sym , char const   *def ) 
{ 
  enum symbol_type type ;
  enum symbol_type tmp ;
  tristate val ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  long tmp___8 ;
  _Bool tmp___9 ;

  {
  {
#line 71
  tmp = sym_get_type(sym);
#line 71
  type = tmp;
#line 74
  tmp___0 = sym_has_value(sym);
  }
#line 74
  if (! tmp___0) {
    {
#line 75
    printf((char const   */* __restrict  */)"(NEW) ");
    }
  }
  {
#line 77
  line[0] = (char )'\n';
#line 78
  line[1] = (char)0;
#line 80
  tmp___1 = sym_is_changable(sym);
  }
#line 80
  if (! tmp___1) {
    {
#line 81
    printf((char const   */* __restrict  */)"%s\n", def);
#line 82
    line[0] = (char )'\n';
#line 83
    line[1] = (char)0;
    }
#line 84
    return;
  }
  {
#line 91
  if ((unsigned int )input_mode == 7U) {
#line 91
    goto case_7;
  }
#line 91
  if ((unsigned int )input_mode == 4U) {
#line 91
    goto case_7;
  }
#line 91
  if ((unsigned int )input_mode == 5U) {
#line 91
    goto case_7;
  }
#line 91
  if ((unsigned int )input_mode == 6U) {
#line 91
    goto case_7;
  }
#line 98
  if ((unsigned int )input_mode == 2U) {
#line 98
    goto case_2;
  }
#line 98
  if ((unsigned int )input_mode == 1U) {
#line 98
    goto case_2;
  }
#line 104
  if ((unsigned int )input_mode == 0U) {
#line 104
    goto case_0;
  }
#line 108
  if ((unsigned int )input_mode == 3U) {
#line 108
    goto case_3;
  }
#line 111
  goto switch_default;
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 92
  tmp___2 = sym_has_value(sym);
  }
#line 92
  if (tmp___2) {
    {
#line 93
    printf((char const   */* __restrict  */)"%s\n", def);
    }
#line 94
    return;
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 99
  tmp___3 = sym_has_value(sym);
  }
#line 99
  if (tmp___3) {
    {
#line 100
    printf((char const   */* __restrict  */)"%s\n", def);
    }
#line 101
    return;
  }
  {
#line 103
  check_stdin();
  }
  case_0: /* CIL Label */ 
  {
#line 105
  fflush(stdout);
#line 106
  fgets((char */* __restrict  */)(line), 128, (FILE */* __restrict  */)stdin);
  }
#line 107
  return;
  case_3: /* CIL Label */ 
  {
#line 109
  printf((char const   */* __restrict  */)"%s\n", def);
  }
#line 110
  return;
  switch_default: /* CIL Label */ 
#line 112
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 118
  if ((unsigned int )type == 5U) {
#line 118
    goto case_5___0;
  }
#line 118
  if ((unsigned int )type == 4U) {
#line 118
    goto case_5___0;
  }
#line 118
  if ((unsigned int )type == 3U) {
#line 118
    goto case_5___0;
  }
#line 121
  goto switch_default___0;
  case_5___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 119
  printf((char const   */* __restrict  */)"%s\n", def);
  }
#line 120
  return;
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 125
  if ((unsigned int )input_mode == 4U) {
#line 125
    goto case_4___1;
  }
#line 132
  if ((unsigned int )input_mode == 5U) {
#line 132
    goto case_5___1;
  }
#line 148
  if ((unsigned int )input_mode == 6U) {
#line 148
    goto case_6___0;
  }
#line 155
  if ((unsigned int )input_mode == 7U) {
#line 155
    goto case_7___0;
  }
#line 167
  goto switch_default___1;
  case_4___1: /* CIL Label */ 
  {
#line 126
  tmp___4 = sym_tristate_within_range(sym, (tristate )2);
  }
#line 126
  if (tmp___4) {
#line 127
    line[0] = (char )'y';
#line 128
    line[1] = (char )'\n';
#line 129
    line[2] = (char)0;
#line 130
    goto switch_break___1;
  }
  case_5___1: /* CIL Label */ 
#line 133
  if ((unsigned int )type == 2U) {
    {
#line 134
    tmp___5 = sym_tristate_within_range(sym, (tristate )1);
    }
#line 134
    if (tmp___5) {
#line 135
      line[0] = (char )'m';
#line 136
      line[1] = (char )'\n';
#line 137
      line[2] = (char)0;
#line 138
      goto switch_break___1;
    }
  } else {
    {
#line 141
    tmp___6 = sym_tristate_within_range(sym, (tristate )2);
    }
#line 141
    if (tmp___6) {
#line 142
      line[0] = (char )'y';
#line 143
      line[1] = (char )'\n';
#line 144
      line[2] = (char)0;
#line 145
      goto switch_break___1;
    }
  }
  case_6___0: /* CIL Label */ 
  {
#line 149
  tmp___7 = sym_tristate_within_range(sym, (tristate )0);
  }
#line 149
  if (tmp___7) {
#line 150
    line[0] = (char )'n';
#line 151
    line[1] = (char )'\n';
#line 152
    line[2] = (char)0;
#line 153
    goto switch_break___1;
  }
  case_7___0: /* CIL Label */ 
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    tmp___8 = random();
#line 157
    val = (tristate )(tmp___8 % 3L);
#line 156
    tmp___9 = sym_tristate_within_range(sym, val);
    }
#line 156
    if (tmp___9) {
#line 156
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  if ((unsigned int )val == 0U) {
#line 160
    goto case_0___0;
  }
#line 161
  if ((unsigned int )val == 1U) {
#line 161
    goto case_1___0;
  }
#line 162
  if ((unsigned int )val == 2U) {
#line 162
    goto case_2___0;
  }
#line 159
  goto switch_break___2;
  case_0___0: /* CIL Label */ 
#line 160
  line[0] = (char )'n';
#line 160
  goto switch_break___2;
  case_1___0: /* CIL Label */ 
#line 161
  line[0] = (char )'m';
#line 161
  goto switch_break___2;
  case_2___0: /* CIL Label */ 
#line 162
  line[0] = (char )'y';
#line 162
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 164
  line[1] = (char )'\n';
#line 165
  line[2] = (char)0;
#line 166
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 168
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 170
  printf((char const   */* __restrict  */)"%s", line);
  }
#line 171
  return;
}
}
#line 173 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
int conf_string(struct menu *menu ) 
{ 
  struct symbol *sym ;
  char const   *def ;
  char const   *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  _Bool tmp___2 ;

  {
#line 175
  sym = menu->sym;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    printf((char const   */* __restrict  */)"%*s%s ", indent - 1, "", (menu->prompt)->text);
#line 180
    printf((char const   */* __restrict  */)"(%s) ", sym->name);
#line 181
    def = sym_get_string_value(sym);
#line 182
    tmp = sym_get_string_value(sym);
    }
#line 182
    if (tmp) {
      {
#line 183
      printf((char const   */* __restrict  */)"[%s] ", def);
      }
    }
    {
#line 184
    conf_askvalue(sym, def);
    }
    {
#line 186
    if ((int )line[0] == 10) {
#line 186
      goto case_10;
    }
#line 188
    if ((int )line[0] == 63) {
#line 188
      goto case_63;
    }
#line 195
    goto switch_default;
    case_10: /* CIL Label */ 
#line 187
    goto switch_break;
    case_63: /* CIL Label */ 
#line 190
    if ((int )line[1] == 10) {
#line 191
      if ((menu->sym)->help) {
#line 191
        tmp___0 = (menu->sym)->help;
      } else {
#line 191
        tmp___0 = nohelp_text;
      }
      {
#line 191
      printf((char const   */* __restrict  */)"\n%s\n", tmp___0);
#line 192
      def = (char const   *)((void *)0);
      }
#line 193
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 196
    tmp___1 = strlen((char const   *)(line));
#line 196
    line[tmp___1 - 1UL] = (char)0;
#line 197
    def = (char const   *)(line);
    }
    switch_break: /* CIL Label */ ;
    }
#line 199
    if (def) {
      {
#line 199
      tmp___2 = sym_set_string_value(sym, def);
      }
#line 199
      if (tmp___2) {
#line 200
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 204 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static int conf_sym(struct menu *menu ) 
{ 
  struct symbol *sym ;
  tristate oldval ;
  tristate newval ;
  char const   *help ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;

  {
#line 206
  sym = menu->sym;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 211
    printf((char const   */* __restrict  */)"%*s%s ", indent - 1, "", (menu->prompt)->text);
    }
#line 212
    if (sym->name) {
      {
#line 213
      printf((char const   */* __restrict  */)"(%s) ", sym->name);
      }
    }
    {
#line 214
    putchar('[');
#line 215
    oldval = sym_get_tristate_value(sym);
    }
    {
#line 217
    if ((unsigned int )oldval == 0U) {
#line 217
      goto case_0;
    }
#line 220
    if ((unsigned int )oldval == 1U) {
#line 220
      goto case_1;
    }
#line 223
    if ((unsigned int )oldval == 2U) {
#line 223
      goto case_2;
    }
#line 216
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 218
    putchar('N');
    }
#line 219
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 221
    putchar('M');
    }
#line 222
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 224
    putchar('Y');
    }
#line 225
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 227
    if ((unsigned int )oldval != 0U) {
      {
#line 227
      tmp = sym_tristate_within_range(sym, (tristate )0);
      }
#line 227
      if (tmp) {
        {
#line 228
        printf((char const   */* __restrict  */)"/n");
        }
      }
    }
#line 229
    if ((unsigned int )oldval != 1U) {
      {
#line 229
      tmp___0 = sym_tristate_within_range(sym, (tristate )1);
      }
#line 229
      if (tmp___0) {
        {
#line 230
        printf((char const   */* __restrict  */)"/m");
        }
      }
    }
#line 231
    if ((unsigned int )oldval != 2U) {
      {
#line 231
      tmp___1 = sym_tristate_within_range(sym, (tristate )2);
      }
#line 231
      if (tmp___1) {
        {
#line 232
        printf((char const   */* __restrict  */)"/y");
        }
      }
    }
#line 233
    if (sym->help) {
      {
#line 234
      printf((char const   */* __restrict  */)"/?");
      }
    }
    {
#line 235
    printf((char const   */* __restrict  */)"] ");
#line 236
    tmp___2 = sym_get_string_value(sym);
#line 236
    conf_askvalue(sym, tmp___2);
#line 237
    strip(line);
    }
    {
#line 241
    if ((int )line[0] == 78) {
#line 241
      goto case_78;
    }
#line 241
    if ((int )line[0] == 110) {
#line 241
      goto case_78;
    }
#line 247
    if ((int )line[0] == 77) {
#line 247
      goto case_77;
    }
#line 247
    if ((int )line[0] == 109) {
#line 247
      goto case_77;
    }
#line 253
    if ((int )line[0] == 89) {
#line 253
      goto case_89;
    }
#line 253
    if ((int )line[0] == 121) {
#line 253
      goto case_89;
    }
#line 258
    if ((int )line[0] == 0) {
#line 258
      goto case_0___0;
    }
#line 261
    if ((int )line[0] == 63) {
#line 261
      goto case_63;
    }
#line 263
    goto switch_default;
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 242
    newval = (tristate )0;
#line 243
    if (! line[1]) {
#line 244
      goto switch_break___0;
    } else {
      {
#line 243
      tmp___3 = strcmp((char const   *)(& line[1]), "o");
      }
#line 243
      if (! tmp___3) {
#line 244
        goto switch_break___0;
      }
    }
#line 245
    goto while_continue;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 248
    newval = (tristate )1;
#line 249
    if (! line[1]) {
#line 250
      goto switch_break___0;
    }
#line 251
    goto while_continue;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 254
    newval = (tristate )2;
#line 255
    if (! line[1]) {
#line 256
      goto switch_break___0;
    } else {
      {
#line 255
      tmp___4 = strcmp((char const   *)(& line[1]), "es");
      }
#line 255
      if (! tmp___4) {
#line 256
        goto switch_break___0;
      }
    }
#line 257
    goto while_continue;
    case_0___0: /* CIL Label */ 
#line 259
    newval = oldval;
#line 260
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 262
    goto help;
    switch_default: /* CIL Label */ 
#line 264
    goto while_continue;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 266
    tmp___5 = sym_set_tristate_value(sym, newval);
    }
#line 266
    if (tmp___5) {
#line 267
      return (0);
    }
    help: 
#line 269
    help = (char const   *)(nohelp_text);
#line 270
    if (sym->help) {
#line 271
      help = (char const   *)sym->help;
    }
    {
#line 272
    printf((char const   */* __restrict  */)"\n%s\n", help);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 276 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static int conf_choice(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct symbol *def_sym ;
  struct menu *child ;
  _Bool is_new ;
  _Bool tmp ;
  int tmp___0 ;
  tristate tmp___1 ;
  tristate tmp___2 ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  int cnt ;
  int def ;
  char const   *tmp___5 ;
  _Bool tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  _Bool tmp___9 ;
  char *tmp___10 ;
  unsigned short const   **tmp___11 ;
  long tmp___12 ;
  _Bool tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;

  {
  {
#line 282
  sym = menu->sym;
#line 283
  tmp = sym_has_value(sym);
  }
#line 283
  if (tmp) {
#line 283
    tmp___0 = 0;
  } else {
#line 283
    tmp___0 = 1;
  }
  {
#line 283
  is_new = (_Bool )tmp___0;
#line 284
  tmp___4 = sym_is_changable(sym);
  }
#line 284
  if (tmp___4) {
    {
#line 285
    conf_sym(menu);
#line 286
    sym_calc_value(sym);
#line 287
    tmp___1 = sym_get_tristate_value(sym);
    }
    {
#line 288
    if ((unsigned int )tmp___1 == 0U) {
#line 288
      goto case_0;
    }
#line 290
    if ((unsigned int )tmp___1 == 1U) {
#line 290
      goto case_1;
    }
#line 292
    if ((unsigned int )tmp___1 == 2U) {
#line 292
      goto case_2;
    }
#line 287
    goto switch_break;
    case_0: /* CIL Label */ 
#line 289
    return (1);
    case_1: /* CIL Label */ 
#line 291
    return (0);
    case_2: /* CIL Label */ 
#line 293
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 296
    tmp___2 = sym_get_tristate_value(sym);
    }
    {
#line 297
    if ((unsigned int )tmp___2 == 0U) {
#line 297
      goto case_0___0;
    }
#line 299
    if ((unsigned int )tmp___2 == 1U) {
#line 299
      goto case_1___0;
    }
#line 302
    if ((unsigned int )tmp___2 == 2U) {
#line 302
      goto case_2___0;
    }
#line 296
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 298
    return (1);
    case_1___0: /* CIL Label */ 
    {
#line 300
    tmp___3 = menu_get_prompt(menu);
#line 300
    printf((char const   */* __restrict  */)"%*s%s\n", indent - 1, "", tmp___3);
    }
#line 301
    return (0);
    case_2___0: /* CIL Label */ 
#line 303
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 310
    tmp___5 = menu_get_prompt(menu);
#line 310
    printf((char const   */* __restrict  */)"%*s%s\n", indent - 1, "", tmp___5);
#line 311
    def_sym = sym_get_choice_value(sym);
#line 312
    def = 0;
#line 312
    cnt = def;
#line 313
    line[0] = (char)0;
#line 314
    child = menu->list;
    }
    {
#line 314
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 314
      if (! child) {
#line 314
        goto while_break___0;
      }
      {
#line 315
      tmp___6 = menu_is_visible(child);
      }
#line 315
      if (! tmp___6) {
#line 316
        goto __Cont;
      }
#line 317
      if (! child->sym) {
        {
#line 318
        tmp___7 = menu_get_prompt(child);
#line 318
        printf((char const   */* __restrict  */)"%*c %s\n", indent, '*', tmp___7);
        }
#line 319
        goto __Cont;
      }
#line 321
      cnt ++;
#line 322
      if ((unsigned long )child->sym == (unsigned long )def_sym) {
        {
#line 323
        def = cnt;
#line 324
        printf((char const   */* __restrict  */)"%*c", indent, '>');
        }
      } else {
        {
#line 326
        printf((char const   */* __restrict  */)"%*c", indent, ' ');
        }
      }
      {
#line 327
      tmp___8 = menu_get_prompt(child);
#line 327
      printf((char const   */* __restrict  */)" %d. %s", cnt, tmp___8);
      }
#line 328
      if ((child->sym)->name) {
        {
#line 329
        printf((char const   */* __restrict  */)" (%s)", (child->sym)->name);
        }
      }
      {
#line 330
      tmp___9 = sym_has_value(child->sym);
      }
#line 330
      if (! tmp___9) {
        {
#line 331
        printf((char const   */* __restrict  */)" (NEW)");
        }
      }
      {
#line 332
      printf((char const   */* __restrict  */)"\n");
      }
      __Cont: /* CIL Label */ 
#line 314
      child = child->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 334
    printf((char const   */* __restrict  */)"%*schoice", indent - 1, "");
    }
#line 335
    if (cnt == 1) {
      {
#line 336
      printf((char const   */* __restrict  */)"[1]: 1\n");
      }
#line 337
      goto conf_childs;
    }
    {
#line 339
    printf((char const   */* __restrict  */)"[1-%d", cnt);
    }
#line 340
    if (sym->help) {
      {
#line 341
      printf((char const   */* __restrict  */)"?");
      }
    }
    {
#line 342
    printf((char const   */* __restrict  */)"]: ");
    }
    {
#line 345
    if ((unsigned int )input_mode == 2U) {
#line 345
      goto case_2___1;
    }
#line 345
    if ((unsigned int )input_mode == 1U) {
#line 345
      goto case_2___1;
    }
#line 352
    if ((unsigned int )input_mode == 0U) {
#line 352
      goto case_0___1;
    }
#line 368
    if ((unsigned int )input_mode == 7U) {
#line 368
      goto case_7;
    }
#line 373
    if ((unsigned int )input_mode == 6U) {
#line 373
      goto case_6;
    }
#line 373
    if ((unsigned int )input_mode == 5U) {
#line 373
      goto case_6;
    }
#line 373
    if ((unsigned int )input_mode == 4U) {
#line 373
      goto case_6;
    }
#line 373
    if ((unsigned int )input_mode == 3U) {
#line 373
      goto case_6;
    }
#line 343
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    case_1___1: /* CIL Label */ 
#line 346
    if (! is_new) {
      {
#line 347
      cnt = def;
#line 348
      printf((char const   */* __restrict  */)"%d\n", cnt);
      }
#line 349
      goto switch_break___1;
    }
    {
#line 351
    check_stdin();
    }
    case_0___1: /* CIL Label */ 
    {
#line 353
    fflush(stdout);
#line 354
    fgets((char */* __restrict  */)(line), 128, (FILE */* __restrict  */)stdin);
#line 355
    strip(line);
    }
#line 356
    if ((int )line[0] == 63) {
#line 357
      if ((menu->sym)->help) {
#line 357
        tmp___10 = (menu->sym)->help;
      } else {
#line 357
        tmp___10 = nohelp_text;
      }
      {
#line 357
      printf((char const   */* __restrict  */)"\n%s\n", tmp___10);
      }
#line 359
      goto while_continue;
    }
#line 361
    if (! line[0]) {
#line 362
      cnt = def;
    } else {
      {
#line 363
      tmp___11 = __ctype_b_loc();
      }
#line 363
      if ((int const   )*(*tmp___11 + (int )line[0]) & 2048) {
        {
#line 364
        cnt = atoi((char const   *)(line));
        }
      } else {
#line 366
        goto while_continue;
      }
    }
#line 367
    goto switch_break___1;
    case_7: /* CIL Label */ 
    {
#line 369
    tmp___12 = random();
#line 369
    def = (int )(tmp___12 % (long )cnt + 1L);
    }
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 374
    cnt = def;
#line 375
    printf((char const   */* __restrict  */)"%d\n", cnt);
    }
#line 376
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    conf_childs: 
#line 380
    child = menu->list;
    {
#line 380
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 380
      if (! child) {
#line 380
        goto while_break___1;
      }
#line 381
      if (! child->sym) {
#line 382
        goto __Cont___0;
      } else {
        {
#line 381
        tmp___13 = menu_is_visible(child);
        }
#line 381
        if (! tmp___13) {
#line 382
          goto __Cont___0;
        }
      }
#line 383
      cnt --;
#line 383
      if (! cnt) {
#line 384
        goto while_break___1;
      }
      __Cont___0: /* CIL Label */ 
#line 380
      child = child->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 386
    if (! child) {
#line 387
      goto while_continue;
    }
    {
#line 388
    tmp___15 = strlen((char const   *)(line));
    }
#line 388
    if (tmp___15 > 0UL) {
      {
#line 388
      tmp___16 = strlen((char const   *)(line));
      }
#line 388
      if ((int )line[tmp___16 - 1UL] == 63) {
#line 389
        if ((child->sym)->help) {
#line 389
          tmp___14 = (child->sym)->help;
        } else {
#line 389
          tmp___14 = nohelp_text;
        }
        {
#line 389
        printf((char const   */* __restrict  */)"\n%s\n", tmp___14);
        }
#line 391
        goto while_continue;
      }
    }
    {
#line 393
    sym_set_choice_value(sym, child->sym);
    }
#line 394
    if (child->list) {
      {
#line 395
      indent += 2;
#line 396
      conf(child->list);
#line 397
      indent -= 2;
      }
    }
#line 399
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 403 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static void conf(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct property *prop ;
  struct menu *child ;
  _Bool tmp ;
  char const   *prompt ;
  _Bool tmp___0 ;

  {
  {
#line 409
  tmp = menu_is_visible(menu);
  }
#line 409
  if (! tmp) {
#line 410
    return;
  }
#line 412
  sym = menu->sym;
#line 413
  prop = menu->prompt;
#line 414
  if (prop) {
    {
#line 418
    if ((unsigned int )prop->type == 3U) {
#line 418
      goto case_3;
    }
#line 423
    if ((unsigned int )prop->type == 2U) {
#line 423
      goto case_2;
    }
#line 430
    goto switch_default;
    case_3: /* CIL Label */ 
#line 419
    if ((unsigned int )input_mode == 2U) {
#line 419
      if ((unsigned long )rootEntry != (unsigned long )menu) {
        {
#line 420
        check_conf(menu);
        }
#line 421
        return;
      }
    }
    case_2: /* CIL Label */ 
    {
#line 424
    prompt = menu_get_prompt(menu);
    }
#line 425
    if (prompt) {
      {
#line 426
      printf((char const   */* __restrict  */)"%*c\n%*c %s\n%*c\n", indent, '*', indent,
             '*', prompt, indent, '*');
      }
    }
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 435
  if (! sym) {
#line 436
    goto conf_childs;
  }
  {
#line 438
  tmp___0 = sym_is_choice(sym);
  }
#line 438
  if (tmp___0) {
    {
#line 439
    conf_choice(menu);
    }
#line 440
    if ((unsigned int )sym->curr.tri != 1U) {
#line 441
      return;
    }
#line 442
    goto conf_childs;
  }
  {
#line 448
  if ((unsigned int )sym->type == 5U) {
#line 448
    goto case_5;
  }
#line 448
  if ((unsigned int )sym->type == 4U) {
#line 448
    goto case_5;
  }
#line 448
  if ((unsigned int )sym->type == 3U) {
#line 448
    goto case_5;
  }
#line 451
  goto switch_default___0;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 449
  conf_string(menu);
  }
#line 450
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 452
  conf_sym(menu);
  }
#line 453
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  conf_childs: 
#line 457
  if (sym) {
#line 458
    indent += 2;
  }
#line 459
  child = menu->list;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! child) {
#line 459
      goto while_break;
    }
    {
#line 460
    conf(child);
#line 459
    child = child->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  if (sym) {
#line 462
    indent -= 2;
  }
#line 463
  return;
}
}
#line 465 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/conf.c"
static void check_conf(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct menu *child ;
  _Bool tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  tristate tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 470
  tmp = menu_is_visible(menu);
  }
#line 470
  if (! tmp) {
#line 471
    return;
  }
#line 473
  sym = menu->sym;
#line 474
  if (sym) {
    {
#line 474
    tmp___5 = sym_has_value(sym);
    }
#line 474
    if (! tmp___5) {
      {
#line 475
      tmp___2 = sym_is_changable(sym);
      }
#line 475
      if (tmp___2) {
#line 475
        goto _L;
      } else {
        {
#line 475
        tmp___3 = sym_is_choice(sym);
        }
#line 475
        if (tmp___3) {
          {
#line 475
          tmp___4 = sym_get_tristate_value(sym);
          }
#line 475
          if ((unsigned int )tmp___4 == 2U) {
            _L: /* CIL Label */ 
#line 477
            tmp___1 = conf_cnt;
#line 477
            conf_cnt ++;
#line 477
            if (! tmp___1) {
              {
#line 478
              tmp___0 = gettext("*\n* Restart config...\n*\n");
#line 478
              printf((char const   */* __restrict  */)tmp___0);
              }
            }
            {
#line 479
            rootEntry = menu_get_parent_menu(menu);
#line 480
            conf(rootEntry);
            }
          }
        }
      }
    }
  }
#line 484
  child = menu->list;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! child) {
#line 484
      goto while_break;
    }
    {
#line 485
    check_conf(child);
#line 484
    child = child->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 146 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct file *file_list  ;
#line 147 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct file *current_file  ;
#line 150
struct symbol symbol_yes ;
#line 150
struct symbol symbol_no ;
#line 150
struct symbol symbol_mod ;
#line 151 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
struct symbol *modules_sym  ;
#line 152
int cdebug ;
#line 153
struct expr *expr_alloc_symbol(struct symbol *sym ) ;
#line 154
struct expr *expr_alloc_one(enum expr_type type , struct expr *ce ) ;
#line 155
struct expr *expr_alloc_two(enum expr_type type , struct expr *e1 , struct expr *e2 ) ;
#line 156
struct expr *expr_alloc_comp(enum expr_type type , struct symbol *s1 , struct symbol *s2 ) ;
#line 157
struct expr *expr_alloc_and(struct expr *e1 , struct expr *e2 ) ;
#line 158
struct expr *expr_alloc_or(struct expr *e1 , struct expr *e2 ) ;
#line 159
struct expr *expr_copy(struct expr *org ) ;
#line 160
void expr_free(struct expr *e ) ;
#line 161
int expr_eq(struct expr *e1 , struct expr *e2 ) ;
#line 162
void expr_eliminate_eq(struct expr **ep1 , struct expr **ep2 ) ;
#line 163
tristate expr_calc_value(struct expr *e ) ;
#line 164
struct expr *expr_eliminate_yn(struct expr *e ) ;
#line 165
struct expr *expr_trans_bool(struct expr *e ) ;
#line 166
struct expr *expr_eliminate_dups(struct expr *e ) ;
#line 167
struct expr *expr_transform(struct expr *e ) ;
#line 168
int expr_contains_symbol(struct expr *dep , struct symbol *sym ) ;
#line 169
_Bool expr_depends_symbol(struct expr *dep , struct symbol *sym ) ;
#line 170
struct expr *expr_extract_eq_and(struct expr **ep1 , struct expr **ep2 ) ;
#line 171
struct expr *expr_extract_eq_or(struct expr **ep1 , struct expr **ep2 ) ;
#line 172
void expr_extract_eq(enum expr_type type , struct expr **ep , struct expr **ep1 ,
                     struct expr **ep2 ) ;
#line 173
struct expr *expr_trans_compare(struct expr *e , enum expr_type type , struct symbol *sym ) ;
#line 175
void expr_fprint(struct expr *e , FILE *out ) ;
#line 177
void expr_gstr_print(struct expr *e , struct gstr *gs ) ;
#line 179 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
__inline static int expr_is_yes(struct expr *e ) 
{ 
  int tmp ;

  {
#line 181
  if (! e) {
#line 181
    tmp = 1;
  } else
#line 181
  if ((unsigned int )e->type == 7U) {
#line 181
    if ((unsigned long )e->left.sym == (unsigned long )(& symbol_yes)) {
#line 181
      tmp = 1;
    } else {
#line 181
      tmp = 0;
    }
  } else {
#line 181
    tmp = 0;
  }
#line 181
  return (tmp);
}
}
#line 184 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.h"
__inline static int expr_is_no(struct expr *e ) 
{ 
  int tmp ;

  {
#line 186
  if (e) {
#line 186
    if ((unsigned int )e->type == 7U) {
#line 186
      if ((unsigned long )e->left.sym == (unsigned long )(& symbol_no)) {
#line 186
        tmp = 1;
      } else {
#line 186
        tmp = 0;
      }
    } else {
#line 186
      tmp = 0;
    }
  } else {
#line 186
    tmp = 0;
  }
#line 186
  return (tmp);
}
}
#line 9 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc_proto.h"
struct menu rootmenu  ;
#line 13
struct menu *menu_get_root_menu(struct menu *menu ) ;
#line 17 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc_proto.h"
struct symbol *symbol_hash[257]  ;
#line 18 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc_proto.h"
int sym_change_count  ;
#line 20
struct symbol *sym_lookup(char const   *name , int isconst ) ;
#line 21
struct symbol *sym_find(char const   *name ) ;
#line 22
struct symbol **sym_re_search(char const   *pattern ) ;
#line 23
char const   *sym_type_name(enum symbol_type type ) ;
#line 28
tristate sym_toggle_tristate_value(struct symbol *sym ) ;
#line 29
_Bool sym_string_valid(struct symbol *sym , char const   *str ) ;
#line 30
_Bool sym_string_within_range(struct symbol *sym , char const   *str ) ;
#line 33
struct property *sym_get_choice_prop(struct symbol *sym ) ;
#line 34
struct property *sym_get_default_prop(struct symbol *sym ) ;
#line 37
char const   *prop_get_type_name(enum prop_type type ) ;
#line 40
int expr_compare_type(enum expr_type t1 , enum expr_type t2 ) ;
#line 41
void expr_print(struct expr *e , void (*fn)(void * , char const   * ) , void *data ,
                int prevtoken ) ;
#line 51 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
int zconfparse(void) ;
#line 52
void zconfdump(FILE *out ) ;
#line 55
void zconf_starthelp(void) ;
#line 56
FILE *zconf_fopen(char const   *name ) ;
#line 57
void zconf_initscan(char const   *name ) ;
#line 58
void zconf_nextfile(char const   *name ) ;
#line 59
int zconf_lineno(void) ;
#line 60
char *zconf_curname(void) ;
#line 63
char const   conf_def_filename[8] ;
#line 71
void menu_init(void) ;
#line 72
struct menu *menu_add_menu(void) ;
#line 73
void menu_end_menu(void) ;
#line 74
void menu_add_entry(struct symbol *sym ) ;
#line 75
void menu_end_entry(void) ;
#line 76
void menu_add_dep(struct expr *dep ) ;
#line 77
struct property *menu_add_prop(enum prop_type type , char *prompt , struct expr *expr ,
                               struct expr *dep ) ;
#line 78
struct property *menu_add_prompt(enum prop_type type , char *prompt , struct expr *dep ) ;
#line 79
void menu_add_expr(enum prop_type type , struct expr *expr , struct expr *dep ) ;
#line 80
void menu_add_symbol(enum prop_type type , struct symbol *sym , struct expr *dep ) ;
#line 81
void menu_finalize(struct menu *parent ) ;
#line 82
void menu_set_type(int type ) ;
#line 85
struct file *file_lookup(char const   *name ) ;
#line 86
int file_write_dep(char const   *name ) ;
#line 92
struct gstr str_new(void) ;
#line 93
struct gstr str_assign(char const   *s ) ;
#line 94
void str_free(struct gstr *gs ) ;
#line 95
void str_append(struct gstr *gs , char const   *s ) ;
#line 96
void str_printf(struct gstr *gs , char const   *fmt  , ...) ;
#line 97
char const   *str_get(struct gstr *gs ) ;
#line 100
void sym_init(void) ;
#line 101
void sym_clear_all_valid(void) ;
#line 102
void sym_set_changed(struct symbol *sym ) ;
#line 103
struct symbol *sym_check_deps(struct symbol *sym ) ;
#line 104
struct property *prop_alloc(enum prop_type type , struct symbol *sym ) ;
#line 105
struct symbol *prop_get_symbol(struct property *prop ) ;
#line 128 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_choice_value(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 130
  if (sym->flags & 32) {
#line 130
    tmp = 1;
  } else {
#line 130
    tmp = 0;
  }
#line 130
  return ((_Bool )tmp);
}
}
#line 133 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_optional(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 135
  if (sym->flags & 256) {
#line 135
    tmp = 1;
  } else {
#line 135
    tmp = 0;
  }
#line 135
  return ((_Bool )tmp);
}
}
#line 45 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.hash.c"
__inline static unsigned int kconf_id_hash(char const   *str , unsigned int len ) ;
#line 45 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.hash.c"
static unsigned char asso_values[256]  = 
#line 45
  {      (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)25,      (unsigned char)10,      (unsigned char)15, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)5,      (unsigned char)47, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)0,      (unsigned char)10,      (unsigned char)0,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)5,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)20,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)20,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47, 
        (unsigned char)47,      (unsigned char)47,      (unsigned char)47,      (unsigned char)47};
#line 36 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.hash.c"
__inline static unsigned int kconf_id_hash(char const   *str , unsigned int len ) 
{ 
  register int hval ;

  {
#line 74
  hval = (int )len;
  {
#line 82
  if (hval == 1) {
#line 82
    goto case_1;
  }
#line 82
  if (hval == 2) {
#line 82
    goto case_1;
  }
#line 78
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 79
  hval += (int )asso_values[(unsigned char )*(str + 2)];
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 83
  hval += (int )asso_values[(unsigned char )*(str + 0)];
#line 84
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 86
  return ((unsigned int )hval);
}
}
#line 122 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.hash.c"
static struct kconf_id_strings_t kconf_id_strings_contents  = 
#line 122
     {{(char )'i', (char )'f', (char )'\000'}, {(char )'i', (char )'n', (char )'t',
                                              (char )'\000'}, {(char )'h', (char )'e',
                                                               (char )'l', (char )'p',
                                                               (char )'\000'}, {(char )'e',
                                                                                (char )'n',
                                                                                (char )'d',
                                                                                (char )'i',
                                                                                (char )'f',
                                                                                (char )'\000'},
    {(char )'s', (char )'e', (char )'l', (char )'e', (char )'c', (char )'t', (char )'\000'},
    {(char )'e', (char )'n', (char )'d', (char )'m', (char )'e', (char )'n', (char )'u',
     (char )'\000'}, {(char )'t', (char )'r', (char )'i', (char )'s', (char )'t',
                      (char )'a', (char )'t', (char )'e', (char )'\000'}, {(char )'e',
                                                                           (char )'n',
                                                                           (char )'d',
                                                                           (char )'c',
                                                                           (char )'h',
                                                                           (char )'o',
                                                                           (char )'i',
                                                                           (char )'c',
                                                                           (char )'e',
                                                                           (char )'\000'},
    {(char )'r', (char )'a', (char )'n', (char )'g', (char )'e', (char )'\000'}, {(char )'s',
                                                                                  (char )'t',
                                                                                  (char )'r',
                                                                                  (char )'i',
                                                                                  (char )'n',
                                                                                  (char )'g',
                                                                                  (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'a', (char )'u', (char )'l', (char )'t',
     (char )'\000'}, {(char )'d', (char )'e', (char )'f', (char )'_', (char )'b',
                      (char )'o', (char )'o', (char )'l', (char )'\000'}, {(char )'m',
                                                                           (char )'e',
                                                                           (char )'n',
                                                                           (char )'u',
                                                                           (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'_', (char )'b', (char )'o', (char )'o',
     (char )'l', (char )'e', (char )'a', (char )'n', (char )'\000'}, {(char )'d',
                                                                      (char )'e',
                                                                      (char )'f',
                                                                      (char )'_',
                                                                      (char )'t',
                                                                      (char )'r',
                                                                      (char )'i',
                                                                      (char )'s',
                                                                      (char )'t',
                                                                      (char )'a',
                                                                      (char )'t',
                                                                      (char )'e',
                                                                      (char )'\000'},
    {(char )'m', (char )'a', (char )'i', (char )'n', (char )'m', (char )'e', (char )'n',
     (char )'u', (char )'\000'}, {(char )'m', (char )'e', (char )'n', (char )'u',
                                  (char )'c', (char )'o', (char )'n', (char )'f',
                                  (char )'i', (char )'g', (char )'\000'}, {(char )'c',
                                                                           (char )'o',
                                                                           (char )'n',
                                                                           (char )'f',
                                                                           (char )'i',
                                                                           (char )'g',
                                                                           (char )'\000'},
    {(char )'o', (char )'n', (char )'\000'}, {(char )'h', (char )'e', (char )'x',
                                              (char )'\000'}, {(char )'s', (char )'o',
                                                               (char )'u', (char )'r',
                                                               (char )'c', (char )'e',
                                                               (char )'\000'}, {(char )'d',
                                                                                (char )'e',
                                                                                (char )'p',
                                                                                (char )'e',
                                                                                (char )'n',
                                                                                (char )'d',
                                                                                (char )'s',
                                                                                (char )'\000'},
    {(char )'o', (char )'p', (char )'t', (char )'i', (char )'o', (char )'n', (char )'a',
     (char )'l', (char )'\000'}, {(char )'e', (char )'n', (char )'a', (char )'b',
                                  (char )'l', (char )'e', (char )'\000'}, {(char )'c',
                                                                           (char )'o',
                                                                           (char )'m',
                                                                           (char )'m',
                                                                           (char )'e',
                                                                           (char )'n',
                                                                           (char )'t',
                                                                           (char )'\000'},
    {(char )'r', (char )'e', (char )'q', (char )'u', (char )'i', (char )'r', (char )'e',
     (char )'s', (char )'\000'}, {(char )'b', (char )'o', (char )'o', (char )'l',
                                  (char )'\000'}, {(char )'b', (char )'o', (char )'o',
                                                   (char )'l', (char )'e', (char )'a',
                                                   (char )'n', (char )'\000'}, {(char )'c',
                                                                                (char )'h',
                                                                                (char )'o',
                                                                                (char )'i',
                                                                                (char )'c',
                                                                                (char )'e',
                                                                                (char )'\000'},
    {(char )'p', (char )'r', (char )'o', (char )'m', (char )'p', (char )'t', (char )'\000'}};
#line 171
__inline struct kconf_id *kconf_id_lookup(char const   *str , unsigned int len ) ;
#line 171 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.hash.c"
static struct kconf_id wordlist[47]  = 
#line 171
  {      {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str2)),
      269, 3U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str3)),
      275, 1U, (enum symbol_type )3}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str4)),
      267, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str5)),
      270, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str6)),
      277, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str7)),
      260, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str8)),
      275, 1U, (enum symbol_type )2}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str9)),
      263, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str10)),
      278, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str11)),
      275, 1U, (enum symbol_type )5}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str12)),
      276, 1U, (enum symbol_type )0}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str13)),
      276, 1U, (enum symbol_type )1}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str14)),
      259, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str16)),
      276, 1U, (enum symbol_type )1}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str17)),
      276, 1U, (enum symbol_type )2}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str18)),
      258, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str20)),
      266, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str21)),
      265, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str22)),
      279, 2U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str23)),
      275, 1U, (enum symbol_type )4}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str26)),
      261, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str27)),
      271, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str28)),
      273, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str31)),
      277, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str32)),
      264, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str33)),
      272, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str34)),
      275, 1U, (enum symbol_type )1}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str37)),
      275, 1U, (enum symbol_type )1}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str41)),
      262, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str46)),
      274, 1U, 0U}};
#line 157 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.hash.c"
__inline struct kconf_id *kconf_id_lookup(char const   *str , unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register int o ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 213
  if (len <= 12U) {
#line 213
    if (len >= 2U) {
      {
#line 215
      tmp = kconf_id_hash(str, len);
#line 215
      key = (int )tmp;
      }
#line 217
      if (key <= 46) {
#line 217
        if (key >= 0) {
#line 219
          o = wordlist[key].name;
#line 220
          if (o >= 0) {
#line 222
            s = (char const   *)(& kconf_id_strings_contents) + o;
#line 224
            if ((int const   )*str == (int const   )*s) {
              {
#line 224
              tmp___0 = strncmp(str + 1, s + 1, (size_t )(len - 1U));
              }
#line 224
              if (! tmp___0) {
#line 224
                if ((int const   )*(s + len) == 0) {
#line 225
                  return (& wordlist[key]);
                }
              }
            }
          }
        }
      }
    }
  }
#line 229
  return ((struct kconf_id *)0);
}
}
#line 159 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
int cdebug  =    1;
#line 161
int zconflex(void) ;
#line 162
static void zconfprint(char const   *err  , ...) ;
#line 163
static void zconf_error(char const   *err  , ...) ;
#line 164
static void zconferror(char const   *err ) ;
#line 165
static _Bool zconf_endtoken(struct kconf_id *id , int starttoken , int endtoken ) ;
#line 169 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static struct menu *current_menu  ;
#line 169 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static struct menu *current_entry  ;
#line 334 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static unsigned char const   yytranslate[290]  = 
#line 334
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16, 
        (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20, 
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23,      (unsigned char const   )24, 
        (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34};
#line 475 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static unsigned char const   yyr1[105]  = 
#line 475
  {      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )36,      (unsigned char const   )37, 
        (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37, 
        (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37, 
        (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )38, 
        (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )39,      (unsigned char const   )39,      (unsigned char const   )39,      (unsigned char const   )39, 
        (unsigned char const   )39,      (unsigned char const   )40,      (unsigned char const   )40,      (unsigned char const   )41, 
        (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )46,      (unsigned char const   )46, 
        (unsigned char const   )46,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )51, 
        (unsigned char const   )51,      (unsigned char const   )51,      (unsigned char const   )51,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )52,      (unsigned char const   )52,      (unsigned char const   )52, 
        (unsigned char const   )53,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )57,      (unsigned char const   )57, 
        (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )60, 
        (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )62,      (unsigned char const   )62, 
        (unsigned char const   )62,      (unsigned char const   )63,      (unsigned char const   )64,      (unsigned char const   )65, 
        (unsigned char const   )66,      (unsigned char const   )67,      (unsigned char const   )68,      (unsigned char const   )68, 
        (unsigned char const   )68,      (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )69, 
        (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )70,      (unsigned char const   )71, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )72,      (unsigned char const   )72, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )74, 
        (unsigned char const   )75,      (unsigned char const   )75,      (unsigned char const   )75,      (unsigned char const   )75, 
        (unsigned char const   )75,      (unsigned char const   )75,      (unsigned char const   )75,      (unsigned char const   )76, 
        (unsigned char const   )76};
#line 491 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static unsigned char const   yyr2[105]  = 
#line 491
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )4, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )3, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )1};
#line 509 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static unsigned char const   yydefact[175]  = 
#line 509
  {      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )16,      (unsigned char const   )13,      (unsigned char const   )14, 
        (unsigned char const   )18,      (unsigned char const   )15,      (unsigned char const   )17,      (unsigned char const   )0, 
        (unsigned char const   )19,      (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )31, 
        (unsigned char const   )22,      (unsigned char const   )31,      (unsigned char const   )23,      (unsigned char const   )46, 
        (unsigned char const   )56,      (unsigned char const   )5,      (unsigned char const   )61,      (unsigned char const   )20, 
        (unsigned char const   )78,      (unsigned char const   )69,      (unsigned char const   )6,      (unsigned char const   )24, 
        (unsigned char const   )78,      (unsigned char const   )21,      (unsigned char const   )8,      (unsigned char const   )11, 
        (unsigned char const   )87,      (unsigned char const   )88,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )89,      (unsigned char const   )0,      (unsigned char const   )42,      (unsigned char const   )90, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )103, 
        (unsigned char const   )104,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )91,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )92,      (unsigned char const   )7,      (unsigned char const   )65,      (unsigned char const   )73, 
        (unsigned char const   )74,      (unsigned char const   )27,      (unsigned char const   )29,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )58, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )10, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )85,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )36,      (unsigned char const   )35, 
        (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )34,      (unsigned char const   )33, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )85,      (unsigned char const   )0, 
        (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )47,      (unsigned char const   )49, 
        (unsigned char const   )48,      (unsigned char const   )57,      (unsigned char const   )45,      (unsigned char const   )44, 
        (unsigned char const   )62,      (unsigned char const   )64,      (unsigned char const   )60,      (unsigned char const   )63, 
        (unsigned char const   )59,      (unsigned char const   )80,      (unsigned char const   )81,      (unsigned char const   )79, 
        (unsigned char const   )70,      (unsigned char const   )72,      (unsigned char const   )68,      (unsigned char const   )71, 
        (unsigned char const   )67,      (unsigned char const   )93,      (unsigned char const   )99,      (unsigned char const   )101, 
        (unsigned char const   )102,      (unsigned char const   )98,      (unsigned char const   )97,      (unsigned char const   )26, 
        (unsigned char const   )76,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )94,      (unsigned char const   )0,      (unsigned char const   )94,      (unsigned char const   )94, 
        (unsigned char const   )94,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )77, 
        (unsigned char const   )54,      (unsigned char const   )94,      (unsigned char const   )0,      (unsigned char const   )94, 
        (unsigned char const   )0,      (unsigned char const   )83,      (unsigned char const   )84,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )37,      (unsigned char const   )86,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )94,      (unsigned char const   )25,      (unsigned char const   )0, 
        (unsigned char const   )53,      (unsigned char const   )0,      (unsigned char const   )82,      (unsigned char const   )95, 
        (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40,      (unsigned char const   )0, 
        (unsigned char const   )52,      (unsigned char const   )55,      (unsigned char const   )41};
#line 532 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static short const   yydefgoto[42]  = 
#line 532
  {      (short const   )-1,      (short const   )1,      (short const   )2,      (short const   )25, 
        (short const   )26,      (short const   )99,      (short const   )27,      (short const   )28, 
        (short const   )29,      (short const   )30,      (short const   )64,      (short const   )100, 
        (short const   )31,      (short const   )32,      (short const   )114,      (short const   )33, 
        (short const   )66,      (short const   )110,      (short const   )67,      (short const   )34, 
        (short const   )118,      (short const   )35,      (short const   )68,      (short const   )36, 
        (short const   )37,      (short const   )126,      (short const   )38,      (short const   )70, 
        (short const   )39,      (short const   )40,      (short const   )41,      (short const   )101, 
        (short const   )102,      (short const   )69,      (short const   )103,      (short const   )141, 
        (short const   )142,      (short const   )42,      (short const   )73,      (short const   )156, 
        (short const   )59,      (short const   )60};
#line 544 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static short const   yypact[175]  = 
#line 544
  {      (short const   )-78,      (short const   )2,      (short const   )159,      (short const   )-78, 
        (short const   )-21,      (short const   )0,      (short const   )0,      (short const   )-12, 
        (short const   )0,      (short const   )1,      (short const   )4,      (short const   )0, 
        (short const   )27,      (short const   )38,      (short const   )60,      (short const   )58, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )100, 
        (short const   )-78,      (short const   )104,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )86,      (short const   )113, 
        (short const   )-78,      (short const   )114,      (short const   )-78,      (short const   )-78, 
        (short const   )125,      (short const   )127,      (short const   )128,      (short const   )-78, 
        (short const   )-78,      (short const   )60,      (short const   )60,      (short const   )210, 
        (short const   )65,      (short const   )-78,      (short const   )141,      (short const   )142, 
        (short const   )39,      (short const   )103,      (short const   )182,      (short const   )200, 
        (short const   )6,      (short const   )66,      (short const   )6,      (short const   )131, 
        (short const   )-78,      (short const   )146,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )196, 
        (short const   )-78,      (short const   )60,      (short const   )60,      (short const   )146, 
        (short const   )40,      (short const   )40,      (short const   )-78,      (short const   )-78, 
        (short const   )155,      (short const   )156,      (short const   )-2,      (short const   )60, 
        (short const   )0,      (short const   )0,      (short const   )60,      (short const   )105, 
        (short const   )40,      (short const   )194,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )206,      (short const   )-78,      (short const   )-78, 
        (short const   )183,      (short const   )0,      (short const   )0,      (short const   )195, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )197, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )60,      (short const   )213,      (short const   )216, 
        (short const   )212,      (short const   )203,      (short const   )212,      (short const   )190, 
        (short const   )212,      (short const   )40,      (short const   )208,      (short const   )-78, 
        (short const   )-78,      (short const   )212,      (short const   )222,      (short const   )212, 
        (short const   )219,      (short const   )-78,      (short const   )-78,      (short const   )60, 
        (short const   )223,      (short const   )-78,      (short const   )-78,      (short const   )224, 
        (short const   )225,      (short const   )212,      (short const   )-78,      (short const   )226, 
        (short const   )-78,      (short const   )227,      (short const   )-78,      (short const   )47, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )228, 
        (short const   )-78,      (short const   )-78,      (short const   )-78};
#line 567 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static short const   yypgoto[42]  = 
#line 567
  {      (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )164,      (short const   )-36,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )230,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )29, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )59,      (short const   )-78, 
        (short const   )-78,      (short const   )-78,      (short const   )-78,      (short const   )-78, 
        (short const   )198,      (short const   )220,      (short const   )24,      (short const   )157, 
        (short const   )-5,      (short const   )169,      (short const   )202,      (short const   )74, 
        (short const   )-53,      (short const   )-77};
#line 581 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static short const   yytable[265]  = 
#line 581
  {      (short const   )46,      (short const   )47,      (short const   )3,      (short const   )49, 
        (short const   )79,      (short const   )80,      (short const   )52,      (short const   )133, 
        (short const   )134,      (short const   )43,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )13,      (short const   )48,      (short const   )145, 
        (short const   )14,      (short const   )15,      (short const   )137,      (short const   )55, 
        (short const   )56,      (short const   )44,      (short const   )45,      (short const   )57, 
        (short const   )131,      (short const   )132,      (short const   )109,      (short const   )50, 
        (short const   )58,      (short const   )122,      (short const   )51,      (short const   )122, 
        (short const   )24,      (short const   )138,      (short const   )139,      (short const   )-28, 
        (short const   )88,      (short const   )143,      (short const   )-28,      (short const   )-28, 
        (short const   )-28,      (short const   )-28,      (short const   )-28,      (short const   )-28, 
        (short const   )-28,      (short const   )-28,      (short const   )-28,      (short const   )89, 
        (short const   )53,      (short const   )-28,      (short const   )-28,      (short const   )90, 
        (short const   )91,      (short const   )-28,      (short const   )92,      (short const   )93, 
        (short const   )94,      (short const   )95,      (short const   )96,      (short const   )54, 
        (short const   )97,      (short const   )55,      (short const   )56,      (short const   )88, 
        (short const   )161,      (short const   )98,      (short const   )-66,      (short const   )-66, 
        (short const   )-66,      (short const   )-66,      (short const   )-66,      (short const   )-66, 
        (short const   )-66,      (short const   )-66,      (short const   )81,      (short const   )82, 
        (short const   )-66,      (short const   )-66,      (short const   )90,      (short const   )91, 
        (short const   )152,      (short const   )55,      (short const   )56,      (short const   )140, 
        (short const   )61,      (short const   )57,      (short const   )112,      (short const   )97, 
        (short const   )84,      (short const   )123,      (short const   )58,      (short const   )123, 
        (short const   )121,      (short const   )117,      (short const   )85,      (short const   )125, 
        (short const   )149,      (short const   )62,      (short const   )167,      (short const   )-30, 
        (short const   )88,      (short const   )63,      (short const   )-30,      (short const   )-30, 
        (short const   )-30,      (short const   )-30,      (short const   )-30,      (short const   )-30, 
        (short const   )-30,      (short const   )-30,      (short const   )-30,      (short const   )89, 
        (short const   )72,      (short const   )-30,      (short const   )-30,      (short const   )90, 
        (short const   )91,      (short const   )-30,      (short const   )92,      (short const   )93, 
        (short const   )94,      (short const   )95,      (short const   )96,      (short const   )119, 
        (short const   )97,      (short const   )127,      (short const   )144,      (short const   )-75, 
        (short const   )88,      (short const   )98,      (short const   )-75,      (short const   )-75, 
        (short const   )-75,      (short const   )-75,      (short const   )-75,      (short const   )-75, 
        (short const   )-75,      (short const   )-75,      (short const   )-75,      (short const   )74, 
        (short const   )75,      (short const   )-75,      (short const   )-75,      (short const   )90, 
        (short const   )91,      (short const   )-75,      (short const   )-75,      (short const   )-75, 
        (short const   )-75,      (short const   )-75,      (short const   )-75,      (short const   )76, 
        (short const   )97,      (short const   )77,      (short const   )78,      (short const   )-2, 
        (short const   )4,      (short const   )121,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )13,      (short const   )86, 
        (short const   )87,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )129,      (short const   )17,      (short const   )18,      (short const   )19, 
        (short const   )20,      (short const   )21,      (short const   )22,      (short const   )88, 
        (short const   )23,      (short const   )135,      (short const   )136,      (short const   )-43, 
        (short const   )-43,      (short const   )24,      (short const   )-43,      (short const   )-43, 
        (short const   )-43,      (short const   )-43,      (short const   )89,      (short const   )146, 
        (short const   )-43,      (short const   )-43,      (short const   )90,      (short const   )91, 
        (short const   )104,      (short const   )105,      (short const   )106,      (short const   )107, 
        (short const   )155,      (short const   )7,      (short const   )8,      (short const   )97, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )13, 
        (short const   )108,      (short const   )148,      (short const   )14,      (short const   )15, 
        (short const   )158,      (short const   )159,      (short const   )160,      (short const   )147, 
        (short const   )151,      (short const   )81,      (short const   )82,      (short const   )163, 
        (short const   )130,      (short const   )165,      (short const   )155,      (short const   )81, 
        (short const   )82,      (short const   )82,      (short const   )24,      (short const   )113, 
        (short const   )116,      (short const   )157,      (short const   )124,      (short const   )171, 
        (short const   )115,      (short const   )120,      (short const   )162,      (short const   )128, 
        (short const   )72,      (short const   )81,      (short const   )82,      (short const   )153, 
        (short const   )81,      (short const   )82,      (short const   )154,      (short const   )81, 
        (short const   )82,      (short const   )166,      (short const   )81,      (short const   )82, 
        (short const   )164,      (short const   )168,      (short const   )169,      (short const   )170, 
        (short const   )172,      (short const   )173,      (short const   )174,      (short const   )65, 
        (short const   )71,      (short const   )83,      (short const   )0,      (short const   )150, 
        (short const   )111};
#line 612 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static short const   yycheck[265]  = 
#line 612
  {      (short const   )5,      (short const   )6,      (short const   )0,      (short const   )8, 
        (short const   )57,      (short const   )58,      (short const   )11,      (short const   )84, 
        (short const   )85,      (short const   )30,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )30,      (short const   )96, 
        (short const   )14,      (short const   )15,      (short const   )24,      (short const   )25, 
        (short const   )26,      (short const   )25,      (short const   )26,      (short const   )29, 
        (short const   )81,      (short const   )82,      (short const   )66,      (short const   )30, 
        (short const   )34,      (short const   )69,      (short const   )30,      (short const   )71, 
        (short const   )30,      (short const   )90,      (short const   )91,      (short const   )0, 
        (short const   )1,      (short const   )94,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )25,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )17,      (short const   )18,      (short const   )19,      (short const   )20, 
        (short const   )21,      (short const   )22,      (short const   )23,      (short const   )25, 
        (short const   )25,      (short const   )25,      (short const   )26,      (short const   )1, 
        (short const   )145,      (short const   )30,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )31,      (short const   )32, 
        (short const   )14,      (short const   )15,      (short const   )16,      (short const   )17, 
        (short const   )137,      (short const   )25,      (short const   )26,      (short const   )92, 
        (short const   )30,      (short const   )29,      (short const   )66,      (short const   )25, 
        (short const   )27,      (short const   )69,      (short const   )34,      (short const   )71, 
        (short const   )30,      (short const   )68,      (short const   )33,      (short const   )70, 
        (short const   )105,      (short const   )1,      (short const   )155,      (short const   )0, 
        (short const   )1,      (short const   )1,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )30,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )17,      (short const   )18,      (short const   )19,      (short const   )20, 
        (short const   )21,      (short const   )22,      (short const   )23,      (short const   )68, 
        (short const   )25,      (short const   )70,      (short const   )25,      (short const   )0, 
        (short const   )1,      (short const   )30,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )30, 
        (short const   )30,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )17,      (short const   )18,      (short const   )19,      (short const   )20, 
        (short const   )21,      (short const   )22,      (short const   )23,      (short const   )30, 
        (short const   )25,      (short const   )30,      (short const   )30,      (short const   )0, 
        (short const   )1,      (short const   )30,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )30, 
        (short const   )30,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )30,      (short const   )18,      (short const   )19,      (short const   )20, 
        (short const   )21,      (short const   )22,      (short const   )23,      (short const   )1, 
        (short const   )25,      (short const   )30,      (short const   )30,      (short const   )5, 
        (short const   )6,      (short const   )30,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )1, 
        (short const   )14,      (short const   )15,      (short const   )16,      (short const   )17, 
        (short const   )18,      (short const   )19,      (short const   )20,      (short const   )21, 
        (short const   )14,      (short const   )5,      (short const   )6,      (short const   )25, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )30,      (short const   )30,      (short const   )14,      (short const   )15, 
        (short const   )142,      (short const   )143,      (short const   )144,      (short const   )13, 
        (short const   )25,      (short const   )31,      (short const   )32,      (short const   )149, 
        (short const   )28,      (short const   )151,      (short const   )14,      (short const   )31, 
        (short const   )32,      (short const   )32,      (short const   )30,      (short const   )67, 
        (short const   )68,      (short const   )30,      (short const   )70,      (short const   )161, 
        (short const   )67,      (short const   )68,      (short const   )30,      (short const   )70, 
        (short const   )30,      (short const   )31,      (short const   )32,      (short const   )30, 
        (short const   )31,      (short const   )32,      (short const   )30,      (short const   )31, 
        (short const   )32,      (short const   )30,      (short const   )31,      (short const   )32, 
        (short const   )30,      (short const   )30,      (short const   )30,      (short const   )30, 
        (short const   )30,      (short const   )30,      (short const   )30,      (short const   )29, 
        (short const   )40,      (short const   )59,      (short const   )-1,      (short const   )106, 
        (short const   )66};
#line 645 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static unsigned char const   yystos[175]  = 
#line 645
  {      (unsigned char const   )0,      (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5, 
        (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )9, 
        (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20, 
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23,      (unsigned char const   )25, 
        (unsigned char const   )30,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )41, 
        (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )50,      (unsigned char const   )54,      (unsigned char const   )56, 
        (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )61,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )65,      (unsigned char const   )72,      (unsigned char const   )30, 
        (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )71,      (unsigned char const   )71, 
        (unsigned char const   )30,      (unsigned char const   )71,      (unsigned char const   )30,      (unsigned char const   )30, 
        (unsigned char const   )71,      (unsigned char const   )25,      (unsigned char const   )25,      (unsigned char const   )25, 
        (unsigned char const   )26,      (unsigned char const   )29,      (unsigned char const   )34,      (unsigned char const   )75, 
        (unsigned char const   )76,      (unsigned char const   )30,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )51,      (unsigned char const   )53, 
        (unsigned char const   )57,      (unsigned char const   )68,      (unsigned char const   )62,      (unsigned char const   )68, 
        (unsigned char const   )30,      (unsigned char const   )73,      (unsigned char const   )30,      (unsigned char const   )30, 
        (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )75, 
        (unsigned char const   )75,      (unsigned char const   )31,      (unsigned char const   )32,      (unsigned char const   )73, 
        (unsigned char const   )27,      (unsigned char const   )33,      (unsigned char const   )30,      (unsigned char const   )30, 
        (unsigned char const   )1,      (unsigned char const   )12,      (unsigned char const   )16,      (unsigned char const   )17, 
        (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22, 
        (unsigned char const   )23,      (unsigned char const   )25,      (unsigned char const   )30,      (unsigned char const   )40, 
        (unsigned char const   )46,      (unsigned char const   )66,      (unsigned char const   )67,      (unsigned char const   )69, 
        (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )21, 
        (unsigned char const   )30,      (unsigned char const   )40,      (unsigned char const   )52,      (unsigned char const   )67, 
        (unsigned char const   )69,      (unsigned char const   )39,      (unsigned char const   )49,      (unsigned char const   )72, 
        (unsigned char const   )39,      (unsigned char const   )50,      (unsigned char const   )55,      (unsigned char const   )61, 
        (unsigned char const   )72,      (unsigned char const   )30,      (unsigned char const   )40,      (unsigned char const   )69, 
        (unsigned char const   )39,      (unsigned char const   )50,      (unsigned char const   )60,      (unsigned char const   )61, 
        (unsigned char const   )72,      (unsigned char const   )30,      (unsigned char const   )28,      (unsigned char const   )75, 
        (unsigned char const   )75,      (unsigned char const   )76,      (unsigned char const   )76,      (unsigned char const   )30, 
        (unsigned char const   )30,      (unsigned char const   )24,      (unsigned char const   )75,      (unsigned char const   )75, 
        (unsigned char const   )71,      (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )75, 
        (unsigned char const   )25,      (unsigned char const   )76,      (unsigned char const   )1,      (unsigned char const   )13, 
        (unsigned char const   )30,      (unsigned char const   )71,      (unsigned char const   )70,      (unsigned char const   )25, 
        (unsigned char const   )75,      (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )14, 
        (unsigned char const   )74,      (unsigned char const   )30,      (unsigned char const   )74,      (unsigned char const   )74, 
        (unsigned char const   )74,      (unsigned char const   )76,      (unsigned char const   )30,      (unsigned char const   )74, 
        (unsigned char const   )30,      (unsigned char const   )74,      (unsigned char const   )30,      (unsigned char const   )75, 
        (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )74, 
        (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )30};
#line 982 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 995
  if (! yymsg) {
#line 996
    yymsg = "Deleting";
  }
  {
#line 1001
  if (yytype == 48) {
#line 1001
    goto case_48;
  }
#line 1011
  if (yytype == 54) {
#line 1011
    goto case_54;
  }
#line 1021
  if (yytype == 59) {
#line 1021
    goto case_59;
  }
#line 1032
  goto switch_default;
  case_48: /* CIL Label */ 
  {
#line 1004
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1006
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1007
    menu_end_menu();
    }
  }
#line 1010
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 1014
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1016
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1017
    menu_end_menu();
    }
  }
#line 1020
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 1024
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1026
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1027
    menu_end_menu();
    }
  }
#line 1030
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1033
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1035
  return;
}
}
#line 1057 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
int zconfchar  ;
#line 1060 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
YYSTYPE zconflval  ;
#line 1063 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
int zconfnerrs  ;
#line 1080 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
int zconfparse(void) 
{ 
  register int yystate ;
  register int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  short yyssa[200] ;
  short *yyss ;
  register short *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  register YYSTYPE *yyvsp ;
  size_t yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  size_t yysize ;
  short *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  size_t yynewbytes ;
  size_t yynewbytes___0 ;
  struct symbol *sym ;
  struct symbol *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  struct symbol *sym___0 ;
  struct symbol *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  struct symbol *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  struct expr *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  struct symbol *sym___1 ;
  struct symbol *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  _Bool tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  struct symbol *tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  char *tmp___40 ;
  _Bool tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  _Bool tmp___46 ;
  int tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;
  char *tmp___56 ;
  int tmp___57 ;
  char *tmp___58 ;

  {
#line 1096
  yytoken = 0;
#line 1108
  yyss = yyssa;
#line 1113
  yyvs = yyvsa;
#line 1120
  yystacksize = (size_t )200;
#line 1133
  yystate = 0;
#line 1134
  yyerrstatus = 0;
#line 1135
  zconfnerrs = 0;
#line 1136
  zconfchar = -2;
#line 1143
  yyssp = yyss;
#line 1144
  yyvsp = yyvs;
#line 1147
  *(yyvsp + 0) = zconflval;
#line 1149
  goto yysetstate;
  yynewstate: 
#line 1158
  yyssp ++;
  yysetstate: 
#line 1161
  *yyssp = (short )yystate;
#line 1163
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1166
    yysize = (size_t )((yyssp - yyss) + 1L);
#line 1195
    if (10000UL <= yystacksize) {
#line 1196
      goto yyoverflowlab;
    }
#line 1197
    yystacksize *= 2UL;
#line 1198
    if (10000UL < yystacksize) {
#line 1199
      yystacksize = (size_t )10000;
    }
    {
#line 1202
    yyss1 = yyss;
#line 1203
    tmp = malloc(yystacksize * (sizeof(short ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1203
    yyptr = (union yyalloc *)tmp;
    }
#line 1205
    if (! yyptr) {
#line 1206
      goto yyoverflowlab;
    }
    {
#line 1207
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1207
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1207
      yyss = & yyptr->yyss;
#line 1207
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1207
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1207
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1208
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1208
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1208
      yyvs = & yyptr->yyvs;
#line 1208
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1208
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1208
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1211
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1212
      free((void *)yyss1);
      }
    }
#line 1217
    yyssp = (yyss + yysize) - 1;
#line 1218
    yyvsp = (yyvs + yysize) - 1;
#line 1224
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1225
      goto yyabortlab;
    }
  }
#line 1230
  goto yybackup;
  yybackup: 
#line 1243
  yyn = (int )yypact[yystate];
#line 1244
  if (yyn == -78) {
#line 1245
    goto yydefault;
  }
#line 1250
  if (zconfchar == -2) {
    {
#line 1253
    zconfchar = zconflex();
    }
  }
#line 1256
  if (zconfchar <= 0) {
#line 1258
    yytoken = 0;
#line 1258
    zconfchar = yytoken;
  } else
#line 1263
  if ((unsigned int )zconfchar <= 289U) {
#line 1263
    yytoken = (int )yytranslate[zconfchar];
  } else {
#line 1263
    yytoken = 2;
  }
#line 1269
  yyn += yytoken;
#line 1270
  if (yyn < 0) {
#line 1271
    goto yydefault;
  } else
#line 1270
  if (264 < yyn) {
#line 1271
    goto yydefault;
  } else
#line 1270
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1271
    goto yydefault;
  }
#line 1272
  yyn = (int )yytable[yyn];
#line 1273
  if (yyn <= 0) {
#line 1275
    if (yyn == 0) {
#line 1276
      goto yyerrlab;
    } else
#line 1275
    if (yyn == -76) {
#line 1276
      goto yyerrlab;
    }
#line 1277
    yyn = - yyn;
#line 1278
    goto yyreduce;
  }
#line 1281
  if (yyn == 3) {
#line 1282
    goto yyacceptlab;
  }
#line 1288
  if (zconfchar != 0) {
#line 1289
    zconfchar = -2;
  }
#line 1291
  yyvsp ++;
#line 1291
  *yyvsp = zconflval;
#line 1296
  if (yyerrstatus) {
#line 1297
    yyerrstatus --;
  }
#line 1299
  yystate = yyn;
#line 1300
  goto yynewstate;
  yydefault: 
#line 1307
  yyn = (int )yydefact[yystate];
#line 1308
  if (yyn == 0) {
#line 1309
    goto yyerrlab;
  }
#line 1310
  goto yyreduce;
  yyreduce: 
#line 1318
  yylen = (int )yyr2[yyn];
#line 1328
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1334
  if (yyn == 8) {
#line 1334
    goto case_8;
  }
#line 1339
  if (yyn == 9) {
#line 1339
    goto case_9;
  }
#line 1344
  if (yyn == 10) {
#line 1344
    goto case_10;
  }
#line 1351
  if (yyn == 11) {
#line 1351
    goto case_11;
  }
#line 1356
  if (yyn == 25) {
#line 1356
    goto case_25;
  }
#line 1361
  if (yyn == 26) {
#line 1361
    goto case_26;
  }
#line 1366
  if (yyn == 27) {
#line 1366
    goto case_27;
  }
#line 1376
  if (yyn == 28) {
#line 1376
    goto case_28;
  }
#line 1384
  if (yyn == 29) {
#line 1384
    goto case_29;
  }
#line 1394
  if (yyn == 30) {
#line 1394
    goto case_30;
  }
#line 1406
  if (yyn == 37) {
#line 1406
    goto case_37;
  }
#line 1416
  if (yyn == 38) {
#line 1416
    goto case_38;
  }
#line 1424
  if (yyn == 39) {
#line 1424
    goto case_39;
  }
#line 1436
  if (yyn == 40) {
#line 1436
    goto case_40;
  }
#line 1444
  if (yyn == 41) {
#line 1444
    goto case_41;
  }
#line 1452
  if (yyn == 42) {
#line 1452
    goto case_42;
  }
#line 1463
  if (yyn == 43) {
#line 1463
    goto case_43;
  }
#line 1470
  if (yyn == 44) {
#line 1470
    goto case_44;
  }
#line 1480
  if (yyn == 52) {
#line 1480
    goto case_52;
  }
#line 1488
  if (yyn == 53) {
#line 1488
    goto case_53;
  }
#line 1501
  if (yyn == 54) {
#line 1501
    goto case_54;
  }
#line 1509
  if (yyn == 55) {
#line 1509
    goto case_55;
  }
#line 1521
  if (yyn == 58) {
#line 1521
    goto case_58;
  }
#line 1531
  if (yyn == 59) {
#line 1531
    goto case_59;
  }
#line 1541
  if (yyn == 65) {
#line 1541
    goto case_65;
  }
#line 1550
  if (yyn == 66) {
#line 1550
    goto case_66;
  }
#line 1557
  if (yyn == 67) {
#line 1557
    goto case_67;
  }
#line 1567
  if (yyn == 73) {
#line 1567
    goto case_73;
  }
#line 1575
  if (yyn == 74) {
#line 1575
    goto case_74;
  }
#line 1584
  if (yyn == 75) {
#line 1584
    goto case_75;
  }
#line 1591
  if (yyn == 76) {
#line 1591
    goto case_76;
  }
#line 1599
  if (yyn == 77) {
#line 1599
    goto case_77;
  }
#line 1606
  if (yyn == 82) {
#line 1606
    goto case_82;
  }
#line 1614
  if (yyn == 83) {
#line 1614
    goto case_83;
  }
#line 1622
  if (yyn == 84) {
#line 1622
    goto case_84;
  }
#line 1630
  if (yyn == 86) {
#line 1630
    goto case_86;
  }
#line 1637
  if (yyn == 89) {
#line 1637
    goto case_89;
  }
#line 1642
  if (yyn == 90) {
#line 1642
    goto case_90;
  }
#line 1647
  if (yyn == 91) {
#line 1647
    goto case_91;
  }
#line 1652
  if (yyn == 94) {
#line 1652
    goto case_94;
  }
#line 1657
  if (yyn == 95) {
#line 1657
    goto case_95;
  }
#line 1662
  if (yyn == 96) {
#line 1662
    goto case_96;
  }
#line 1667
  if (yyn == 97) {
#line 1667
    goto case_97;
  }
#line 1672
  if (yyn == 98) {
#line 1672
    goto case_98;
  }
#line 1677
  if (yyn == 99) {
#line 1677
    goto case_99;
  }
#line 1682
  if (yyn == 100) {
#line 1682
    goto case_100;
  }
#line 1687
  if (yyn == 101) {
#line 1687
    goto case_101;
  }
#line 1692
  if (yyn == 102) {
#line 1692
    goto case_102;
  }
#line 1697
  if (yyn == 103) {
#line 1697
    goto case_103;
  }
#line 1702
  if (yyn == 104) {
#line 1702
    goto case_104;
  }
#line 1332
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1336
  zconf_error("unexpected end statement");
  }
#line 1337
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1341
  zconf_error("unknown statement \"%s\"", (yyvsp + -2)->string);
  }
#line 1342
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1347
  zconf_error("unexpected option \"%s\"", (char const   *)(& kconf_id_strings_contents) + ((yyvsp + -2)->id)->name);
  }
#line 1349
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 1353
  zconf_error("invalid statement");
  }
#line 1354
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 1358
  zconf_error("unknown option \"%s\"", (yyvsp + -2)->string);
  }
#line 1359
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 1363
  zconf_error("invalid option");
  }
#line 1364
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 1369
  tmp___0 = sym_lookup((char const   *)(yyvsp + -1)->string, 0);
#line 1369
  sym = tmp___0;
#line 1370
  sym->flags |= 256;
#line 1371
  menu_add_entry(sym);
  }
#line 1372
  if (cdebug & 2) {
    {
#line 1372
    tmp___1 = zconf_lineno();
#line 1372
    tmp___2 = zconf_curname();
#line 1372
    printf((char const   */* __restrict  */)"%s:%d:config %s\n", tmp___2, tmp___1,
           (yyvsp + -1)->string);
    }
  }
#line 1374
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 1379
  menu_end_entry();
  }
#line 1380
  if (cdebug & 2) {
    {
#line 1380
    tmp___3 = zconf_lineno();
#line 1380
    tmp___4 = zconf_curname();
#line 1380
    printf((char const   */* __restrict  */)"%s:%d:endconfig\n", tmp___4, tmp___3);
    }
  }
#line 1382
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 1387
  tmp___5 = sym_lookup((char const   *)(yyvsp + -1)->string, 0);
#line 1387
  sym___0 = tmp___5;
#line 1388
  sym___0->flags |= 256;
#line 1389
  menu_add_entry(sym___0);
  }
#line 1390
  if (cdebug & 2) {
    {
#line 1390
    tmp___6 = zconf_lineno();
#line 1390
    tmp___7 = zconf_curname();
#line 1390
    printf((char const   */* __restrict  */)"%s:%d:menuconfig %s\n", tmp___7, tmp___6,
           (yyvsp + -1)->string);
    }
  }
#line 1392
  goto switch_break;
  case_30: /* CIL Label */ 
#line 1397
  if (current_entry->prompt) {
#line 1398
    (current_entry->prompt)->type = (enum prop_type )3;
  } else {
    {
#line 1400
    zconfprint("warning: menuconfig statement without prompt");
    }
  }
  {
#line 1401
  menu_end_entry();
  }
#line 1402
  if (cdebug & 2) {
    {
#line 1402
    tmp___8 = zconf_lineno();
#line 1402
    tmp___9 = zconf_curname();
#line 1402
    printf((char const   */* __restrict  */)"%s:%d:endconfig\n", tmp___9, tmp___8);
    }
  }
#line 1404
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 1409
  menu_set_type((int )((yyvsp + -2)->id)->stype);
  }
#line 1410
  if (cdebug & 2) {
    {
#line 1410
    tmp___10 = zconf_lineno();
#line 1410
    tmp___11 = zconf_curname();
#line 1410
    printf((char const   */* __restrict  */)"%s:%d:type(%u)\n", tmp___11, tmp___10,
           (unsigned int )((yyvsp + -2)->id)->stype);
    }
  }
#line 1414
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 1419
  menu_add_prompt((enum prop_type )1, (yyvsp + -2)->string, (yyvsp + -1)->expr);
  }
#line 1420
  if (cdebug & 2) {
    {
#line 1420
    tmp___12 = zconf_lineno();
#line 1420
    tmp___13 = zconf_curname();
#line 1420
    printf((char const   */* __restrict  */)"%s:%d:prompt\n", tmp___13, tmp___12);
    }
  }
#line 1422
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 1427
  menu_add_expr((enum prop_type )4, (yyvsp + -2)->expr, (yyvsp + -1)->expr);
  }
#line 1428
  if ((unsigned int )((yyvsp + -3)->id)->stype != 0U) {
    {
#line 1429
    menu_set_type((int )((yyvsp + -3)->id)->stype);
    }
  }
#line 1430
  if (cdebug & 2) {
    {
#line 1430
    tmp___14 = zconf_lineno();
#line 1430
    tmp___15 = zconf_curname();
#line 1430
    printf((char const   */* __restrict  */)"%s:%d:default(%u)\n", tmp___15, tmp___14,
           (unsigned int )((yyvsp + -3)->id)->stype);
    }
  }
#line 1434
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 1439
  tmp___16 = sym_lookup((char const   *)(yyvsp + -2)->string, 0);
#line 1439
  menu_add_symbol((enum prop_type )6, tmp___16, (yyvsp + -1)->expr);
  }
#line 1440
  if (cdebug & 2) {
    {
#line 1440
    tmp___17 = zconf_lineno();
#line 1440
    tmp___18 = zconf_curname();
#line 1440
    printf((char const   */* __restrict  */)"%s:%d:select\n", tmp___18, tmp___17);
    }
  }
#line 1442
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1447
  tmp___19 = expr_alloc_comp((enum expr_type )8, (yyvsp + -3)->symbol, (yyvsp + -2)->symbol);
#line 1447
  menu_add_expr((enum prop_type )7, tmp___19, (yyvsp + -1)->expr);
  }
#line 1448
  if (cdebug & 2) {
    {
#line 1448
    tmp___20 = zconf_lineno();
#line 1448
    tmp___21 = zconf_curname();
#line 1448
    printf((char const   */* __restrict  */)"%s:%d:range\n", tmp___21, tmp___20);
    }
  }
#line 1450
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 1455
  tmp___22 = sym_lookup((char const   *)((void *)0), 0);
#line 1455
  sym___1 = tmp___22;
#line 1456
  sym___1->flags |= 16;
#line 1457
  menu_add_entry(sym___1);
#line 1458
  menu_add_expr((enum prop_type )5, (struct expr *)((void *)0), (struct expr *)((void *)0));
  }
#line 1459
  if (cdebug & 2) {
    {
#line 1459
    tmp___23 = zconf_lineno();
#line 1459
    tmp___24 = zconf_curname();
#line 1459
    printf((char const   */* __restrict  */)"%s:%d:choice\n", tmp___24, tmp___23);
    }
  }
#line 1461
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 1466
  yyval.menu = menu_add_menu();
  }
#line 1468
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 1473
  tmp___27 = zconf_endtoken((yyvsp + 0)->id, 262, 263);
  }
#line 1473
  if (tmp___27) {
    {
#line 1474
    menu_end_menu();
    }
#line 1475
    if (cdebug & 2) {
      {
#line 1475
      tmp___25 = zconf_lineno();
#line 1475
      tmp___26 = zconf_curname();
#line 1475
      printf((char const   */* __restrict  */)"%s:%d:endchoice\n", tmp___26, tmp___25);
      }
    }
  }
#line 1478
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 1483
  menu_add_prompt((enum prop_type )1, (yyvsp + -2)->string, (yyvsp + -1)->expr);
  }
#line 1484
  if (cdebug & 2) {
    {
#line 1484
    tmp___28 = zconf_lineno();
#line 1484
    tmp___29 = zconf_curname();
#line 1484
    printf((char const   */* __restrict  */)"%s:%d:prompt\n", tmp___29, tmp___28);
    }
  }
#line 1486
  goto switch_break;
  case_53: /* CIL Label */ 
#line 1491
  if ((unsigned int )((yyvsp + -2)->id)->stype == 1U) {
#line 1491
    goto _L;
  } else
#line 1491
  if ((unsigned int )((yyvsp + -2)->id)->stype == 2U) {
    _L: /* CIL Label */ 
    {
#line 1492
    menu_set_type((int )((yyvsp + -2)->id)->stype);
    }
#line 1493
    if (cdebug & 2) {
      {
#line 1493
      tmp___30 = zconf_lineno();
#line 1493
      tmp___31 = zconf_curname();
#line 1493
      printf((char const   */* __restrict  */)"%s:%d:type(%u)\n", tmp___31, tmp___30,
             (unsigned int )((yyvsp + -2)->id)->stype);
      }
    }
  } else {
#line 1497
    goto yyerrorlab;
  }
#line 1499
  goto switch_break;
  case_54: /* CIL Label */ 
#line 1504
  (current_entry->sym)->flags |= 256;
#line 1505
  if (cdebug & 2) {
    {
#line 1505
    tmp___32 = zconf_lineno();
#line 1505
    tmp___33 = zconf_curname();
#line 1505
    printf((char const   */* __restrict  */)"%s:%d:optional\n", tmp___33, tmp___32);
    }
  }
#line 1507
  goto switch_break;
  case_55: /* CIL Label */ 
#line 1512
  if ((unsigned int )((yyvsp + -3)->id)->stype == 0U) {
    {
#line 1513
    tmp___34 = sym_lookup((char const   *)(yyvsp + -2)->string, 0);
#line 1513
    menu_add_symbol((enum prop_type )4, tmp___34, (yyvsp + -1)->expr);
    }
#line 1514
    if (cdebug & 2) {
      {
#line 1514
      tmp___35 = zconf_lineno();
#line 1514
      tmp___36 = zconf_curname();
#line 1514
      printf((char const   */* __restrict  */)"%s:%d:default\n", tmp___36, tmp___35);
      }
    }
  } else {
#line 1517
    goto yyerrorlab;
  }
#line 1519
  goto switch_break;
  case_58: /* CIL Label */ 
#line 1524
  if (cdebug & 2) {
    {
#line 1524
    tmp___37 = zconf_lineno();
#line 1524
    tmp___38 = zconf_curname();
#line 1524
    printf((char const   */* __restrict  */)"%s:%d:if\n", tmp___38, tmp___37);
    }
  }
  {
#line 1525
  menu_add_entry((struct symbol *)((void *)0));
#line 1526
  menu_add_dep((yyvsp + -1)->expr);
#line 1527
  yyval.menu = menu_add_menu();
  }
#line 1529
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 1534
  tmp___41 = zconf_endtoken((yyvsp + 0)->id, 269, 270);
  }
#line 1534
  if (tmp___41) {
    {
#line 1535
    menu_end_menu();
    }
#line 1536
    if (cdebug & 2) {
      {
#line 1536
      tmp___39 = zconf_lineno();
#line 1536
      tmp___40 = zconf_curname();
#line 1536
      printf((char const   */* __restrict  */)"%s:%d:endif\n", tmp___40, tmp___39);
      }
    }
  }
#line 1539
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 1544
  menu_add_entry((struct symbol *)((void *)0));
#line 1545
  menu_add_prompt((enum prop_type )3, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1546
  if (cdebug & 2) {
    {
#line 1546
    tmp___42 = zconf_lineno();
#line 1546
    tmp___43 = zconf_curname();
#line 1546
    printf((char const   */* __restrict  */)"%s:%d:menu\n", tmp___43, tmp___42);
    }
  }
#line 1548
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 1553
  yyval.menu = menu_add_menu();
  }
#line 1555
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 1560
  tmp___46 = zconf_endtoken((yyvsp + 0)->id, 259, 260);
  }
#line 1560
  if (tmp___46) {
    {
#line 1561
    menu_end_menu();
    }
#line 1562
    if (cdebug & 2) {
      {
#line 1562
      tmp___44 = zconf_lineno();
#line 1562
      tmp___45 = zconf_curname();
#line 1562
      printf((char const   */* __restrict  */)"%s:%d:endmenu\n", tmp___45, tmp___44);
      }
    }
  }
#line 1565
  goto switch_break;
  case_73: /* CIL Label */ 
#line 1570
  if (cdebug & 2) {
    {
#line 1570
    tmp___47 = zconf_lineno();
#line 1570
    tmp___48 = zconf_curname();
#line 1570
    printf((char const   */* __restrict  */)"%s:%d:source %s\n", tmp___48, tmp___47,
           (yyvsp + -1)->string);
    }
  }
  {
#line 1571
  zconf_nextfile((char const   *)(yyvsp + -1)->string);
  }
#line 1573
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 1578
  menu_add_entry((struct symbol *)((void *)0));
#line 1579
  menu_add_prompt((enum prop_type )2, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1580
  if (cdebug & 2) {
    {
#line 1580
    tmp___49 = zconf_lineno();
#line 1580
    tmp___50 = zconf_curname();
#line 1580
    printf((char const   */* __restrict  */)"%s:%d:comment\n", tmp___50, tmp___49);
    }
  }
#line 1582
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 1587
  menu_end_entry();
  }
#line 1589
  goto switch_break;
  case_76: /* CIL Label */ 
#line 1594
  if (cdebug & 2) {
    {
#line 1594
    tmp___51 = zconf_lineno();
#line 1594
    tmp___52 = zconf_curname();
#line 1594
    printf((char const   */* __restrict  */)"%s:%d:help\n", tmp___52, tmp___51);
    }
  }
  {
#line 1595
  zconf_starthelp();
  }
#line 1597
  goto switch_break;
  case_77: /* CIL Label */ 
#line 1602
  (current_entry->sym)->help = (yyvsp + 0)->string;
#line 1604
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 1609
  menu_add_dep((yyvsp + -1)->expr);
  }
#line 1610
  if (cdebug & 2) {
    {
#line 1610
    tmp___53 = zconf_lineno();
#line 1610
    tmp___54 = zconf_curname();
#line 1610
    printf((char const   */* __restrict  */)"%s:%d:depends on\n", tmp___54, tmp___53);
    }
  }
#line 1612
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 1617
  menu_add_dep((yyvsp + -1)->expr);
  }
#line 1618
  if (cdebug & 2) {
    {
#line 1618
    tmp___55 = zconf_lineno();
#line 1618
    tmp___56 = zconf_curname();
#line 1618
    printf((char const   */* __restrict  */)"%s:%d:depends\n", tmp___56, tmp___55);
    }
  }
#line 1620
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 1625
  menu_add_dep((yyvsp + -1)->expr);
  }
#line 1626
  if (cdebug & 2) {
    {
#line 1626
    tmp___57 = zconf_lineno();
#line 1626
    tmp___58 = zconf_curname();
#line 1626
    printf((char const   */* __restrict  */)"%s:%d:requires\n", tmp___58, tmp___57);
    }
  }
#line 1628
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 1633
  menu_add_prompt((enum prop_type )1, (yyvsp + -1)->string, (yyvsp + 0)->expr);
  }
#line 1635
  goto switch_break;
  case_89: /* CIL Label */ 
#line 1639
  yyval.id = (yyvsp + -1)->id;
#line 1640
  goto switch_break;
  case_90: /* CIL Label */ 
#line 1644
  yyval.id = (yyvsp + -1)->id;
#line 1645
  goto switch_break;
  case_91: /* CIL Label */ 
#line 1649
  yyval.id = (yyvsp + -1)->id;
#line 1650
  goto switch_break;
  case_94: /* CIL Label */ 
#line 1654
  yyval.expr = (struct expr *)((void *)0);
#line 1655
  goto switch_break;
  case_95: /* CIL Label */ 
#line 1659
  yyval.expr = (yyvsp + 0)->expr;
#line 1660
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 1664
  yyval.expr = expr_alloc_symbol((yyvsp + 0)->symbol);
  }
#line 1665
  goto switch_break;
  case_97: /* CIL Label */ 
  {
#line 1669
  yyval.expr = expr_alloc_comp((enum expr_type )4, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 1670
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 1674
  yyval.expr = expr_alloc_comp((enum expr_type )5, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 1675
  goto switch_break;
  case_99: /* CIL Label */ 
#line 1679
  yyval.expr = (yyvsp + -1)->expr;
#line 1680
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 1684
  yyval.expr = expr_alloc_one((enum expr_type )3, (yyvsp + 0)->expr);
  }
#line 1685
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 1689
  yyval.expr = expr_alloc_two((enum expr_type )1, (yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 1690
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 1694
  yyval.expr = expr_alloc_two((enum expr_type )2, (yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 1695
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 1699
  yyval.symbol = sym_lookup((char const   *)(yyvsp + 0)->string, 0);
#line 1699
  free((void *)(yyvsp + 0)->string);
  }
#line 1700
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 1704
  yyval.symbol = sym_lookup((char const   *)(yyvsp + 0)->string, 1);
#line 1704
  free((void *)(yyvsp + 0)->string);
  }
#line 1705
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1713
  yyvsp -= yylen;
#line 1714
  yyssp -= yylen;
#line 1719
  yyvsp ++;
#line 1719
  *yyvsp = yyval;
#line 1726
  yyn = (int )yyr1[yyn];
#line 1728
  yystate = (int )((int const   )yypgoto[yyn - 35] + (int const   )*yyssp);
#line 1729
  if (0 <= yystate) {
#line 1729
    if (yystate <= 264) {
#line 1729
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1730
        yystate = (int )yytable[yystate];
      } else {
#line 1732
        yystate = (int )yydefgoto[yyn - 35];
      }
    } else {
#line 1732
      yystate = (int )yydefgoto[yyn - 35];
    }
  } else {
#line 1732
    yystate = (int )yydefgoto[yyn - 35];
  }
#line 1734
  goto yynewstate;
  yyerrlab: 
#line 1742
  if (! yyerrstatus) {
    {
#line 1744
    zconfnerrs ++;
#line 1804
    zconferror("syntax error");
    }
  }
#line 1809
  if (yyerrstatus == 3) {
#line 1814
    if (zconfchar <= 0) {
#line 1818
      if (zconfchar == 0) {
        {
#line 1819
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1822
          yyvsp --;
#line 1822
          yyssp --;
#line 1823
          if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1824
            goto yyabortlab;
          }
          {
#line 1825
          yydestruct("Error: popping", (int )yystos[*yyssp], yyvsp);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 1831
      yydestruct("Error: discarding", yytoken, & zconflval);
#line 1832
      zconfchar = -2;
      }
    }
  }
#line 1838
  goto yyerrlab1;
  yyerrorlab: 
#line 1853
  yyvsp -= yylen;
#line 1854
  yyssp -= yylen;
#line 1855
  yystate = (int )*yyssp;
#line 1856
  goto yyerrlab1;
  yyerrlab1: 
#line 1863
  yyerrstatus = 3;
  {
#line 1865
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1867
    yyn = (int )yypact[yystate];
#line 1868
    if (yyn != -78) {
#line 1870
      yyn ++;
#line 1871
      if (0 <= yyn) {
#line 1871
        if (yyn <= 264) {
#line 1871
          if ((int const   )yycheck[yyn] == 1) {
#line 1873
            yyn = (int )yytable[yyn];
#line 1874
            if (0 < yyn) {
#line 1875
              goto while_break___2;
            }
          }
        }
      }
    }
#line 1880
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1881
      goto yyabortlab;
    }
    {
#line 1884
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 1885
    yyvsp --;
#line 1885
    yyssp --;
#line 1886
    yystate = (int )*yyssp;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1890
  if (yyn == 3) {
#line 1891
    goto yyacceptlab;
  }
#line 1893
  yyvsp ++;
#line 1893
  *yyvsp = zconflval;
#line 1899
  yystate = yyn;
#line 1900
  goto yynewstate;
  yyacceptlab: 
#line 1907
  yyresult = 0;
#line 1908
  goto yyreturn;
  yyabortlab: 
  {
#line 1914
  yydestruct("Error: discarding lookahead", yytoken, & zconflval);
#line 1916
  zconfchar = -2;
#line 1917
  yyresult = 1;
  }
#line 1918
  goto yyreturn;
  yyoverflowlab: 
  {
#line 1925
  zconferror("parser stack overflow");
#line 1926
  yyresult = 2;
  }
  yyreturn: 
#line 1932
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 1933
    free((void *)yyss);
    }
  }
#line 1935
  return (yyresult);
}
}
#line 1942 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
void conf_parse(char const   *name ) 
{ 
  struct symbol *sym ;
  int i ;

  {
  {
#line 1947
  zconf_initscan(name);
#line 1949
  sym_init();
#line 1950
  menu_init();
#line 1951
  modules_sym = sym_lookup("MODULES", 0);
#line 1952
  rootmenu.prompt = menu_add_prompt((enum prop_type )3, (char *)"Busybox Configuration",
                                    (struct expr *)((void *)0));
#line 1958
  zconfparse();
  }
#line 1959
  if (zconfnerrs) {
    {
#line 1960
    exit(1);
    }
  }
  {
#line 1961
  menu_finalize(& rootmenu);
#line 1962
  i = 0;
  }
  {
#line 1962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1962
    if (! (i < 257)) {
#line 1962
      goto while_break;
    }
#line 1962
    sym = symbol_hash[i];
    {
#line 1962
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1962
      if (! sym) {
#line 1962
        goto while_break___0;
      }
#line 1962
      if ((unsigned int )sym->type != 6U) {
        {
#line 1963
        sym_check_deps(sym);
        }
      }
#line 1962
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1962
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1966
  sym_change_count = 1;
#line 1967
  return;
}
}
#line 1969 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
char const   *zconf_tokenname(int token ) 
{ 


  {
  {
#line 1972
  if (token == 259) {
#line 1972
    goto case_259;
  }
#line 1973
  if (token == 260) {
#line 1973
    goto case_260;
  }
#line 1974
  if (token == 262) {
#line 1974
    goto case_262;
  }
#line 1975
  if (token == 263) {
#line 1975
    goto case_263;
  }
#line 1976
  if (token == 269) {
#line 1976
    goto case_269;
  }
#line 1977
  if (token == 270) {
#line 1977
    goto case_270;
  }
#line 1978
  if (token == 271) {
#line 1978
    goto case_271;
  }
#line 1971
  goto switch_break;
  case_259: /* CIL Label */ 
#line 1972
  return ("menu");
  case_260: /* CIL Label */ 
#line 1973
  return ("endmenu");
  case_262: /* CIL Label */ 
#line 1974
  return ("choice");
  case_263: /* CIL Label */ 
#line 1975
  return ("endchoice");
  case_269: /* CIL Label */ 
#line 1976
  return ("if");
  case_270: /* CIL Label */ 
#line 1977
  return ("endif");
  case_271: /* CIL Label */ 
#line 1978
  return ("depends");
  switch_break: /* CIL Label */ ;
  }
#line 1980
  return ("<token>");
}
}
#line 1983 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static _Bool zconf_endtoken(struct kconf_id *id , int starttoken , int endtoken ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1985
  if (id->token != endtoken) {
    {
#line 1986
    tmp = zconf_tokenname(starttoken);
#line 1986
    zconf_error("unexpected \'%s\' within %s block", (char const   *)(& kconf_id_strings_contents) + id->name,
                tmp);
#line 1988
    zconfnerrs ++;
    }
#line 1989
    return ((_Bool)0);
  }
#line 1991
  if ((unsigned long )current_menu->file != (unsigned long )current_file) {
    {
#line 1992
    tmp___0 = zconf_tokenname(starttoken);
#line 1992
    zconf_error("\'%s\' in different file than \'%s\'", (char const   *)(& kconf_id_strings_contents) + id->name,
                tmp___0);
#line 1994
    tmp___1 = zconf_tokenname(starttoken);
#line 1994
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: location of the \'%s\'\n",
            (current_menu->file)->name, current_menu->lineno, tmp___1);
#line 1997
    zconfnerrs ++;
    }
#line 1998
    return ((_Bool)0);
  }
#line 2000
  return ((_Bool)1);
}
}
#line 2003 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static void zconfprint(char const   *err  , ...) 
{ 
  va_list ap ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 2007
  tmp = zconf_lineno();
#line 2007
  tmp___0 = zconf_curname();
#line 2007
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          tmp___0, tmp);
#line 2008
  __builtin_va_start(ap, err);
#line 2009
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)err,
           ap);
#line 2010
  __builtin_va_end(ap);
#line 2011
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 2012
  return;
}
}
#line 2014 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static void zconf_error(char const   *err  , ...) 
{ 
  va_list ap ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 2018
  zconfnerrs ++;
#line 2019
  tmp = zconf_lineno();
#line 2019
  tmp___0 = zconf_curname();
#line 2019
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          tmp___0, tmp);
#line 2020
  __builtin_va_start(ap, err);
#line 2021
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)err,
           ap);
#line 2022
  __builtin_va_end(ap);
#line 2023
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 2024
  return;
}
}
#line 2026 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
static void zconferror(char const   *err ) 
{ 


  {
#line 2031
  return;
}
}
#line 2033 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
void print_quoted_string(FILE *out , char const   *str ) 
{ 
  char const   *p ;
  int len ;
  char *tmp ;

  {
  {
#line 2038
  _IO_putc('\"', out);
  }
  {
#line 2039
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2039
    tmp = strchr(str, '\"');
#line 2039
    p = (char const   *)tmp;
    }
#line 2039
    if (! p) {
#line 2039
      goto while_break;
    }
#line 2040
    len = (int )(p - str);
#line 2041
    if (len) {
      {
#line 2042
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%.*s",
              len, str);
      }
    }
    {
#line 2043
    fputs((char const   */* __restrict  */)"\\\"", (FILE */* __restrict  */)out);
#line 2044
    str = p + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2046
  fputs((char const   */* __restrict  */)str, (FILE */* __restrict  */)out);
#line 2047
  _IO_putc('\"', out);
  }
#line 2048
  return;
}
}
#line 2050 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
void print_symbol(FILE *out , struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct property *prop ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  size_t tmp___2 ;

  {
  {
#line 2052
  sym = menu->sym;
#line 2055
  tmp = sym_is_choice(sym);
  }
#line 2055
  if (tmp) {
    {
#line 2056
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"choice\n");
    }
  } else {
    {
#line 2058
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"config %s\n",
            sym->name);
    }
  }
  {
#line 2060
  if ((unsigned int )sym->type == 1U) {
#line 2060
    goto case_1;
  }
#line 2063
  if ((unsigned int )sym->type == 2U) {
#line 2063
    goto case_2;
  }
#line 2066
  if ((unsigned int )sym->type == 5U) {
#line 2066
    goto case_5;
  }
#line 2069
  if ((unsigned int )sym->type == 3U) {
#line 2069
    goto case_3;
  }
#line 2072
  if ((unsigned int )sym->type == 4U) {
#line 2072
    goto case_4;
  }
#line 2075
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2061
  fputs((char const   */* __restrict  */)"  boolean\n", (FILE */* __restrict  */)out);
  }
#line 2062
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2064
  fputs((char const   */* __restrict  */)"  tristate\n", (FILE */* __restrict  */)out);
  }
#line 2065
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2067
  fputs((char const   */* __restrict  */)"  string\n", (FILE */* __restrict  */)out);
  }
#line 2068
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2070
  fputs((char const   */* __restrict  */)"  integer\n", (FILE */* __restrict  */)out);
  }
#line 2071
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2073
  fputs((char const   */* __restrict  */)"  hex\n", (FILE */* __restrict  */)out);
  }
#line 2074
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2076
  fputs((char const   */* __restrict  */)"  ???\n", (FILE */* __restrict  */)out);
  }
#line 2077
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2079
  prop = sym->prop;
  {
#line 2079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2079
    if (! prop) {
#line 2079
      goto while_break;
    }
#line 2080
    if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 2081
      goto __Cont;
    }
    {
#line 2083
    if ((unsigned int )prop->type == 1U) {
#line 2083
      goto case_1___0;
    }
#line 2092
    if ((unsigned int )prop->type == 4U) {
#line 2092
      goto case_4___0;
    }
#line 2101
    if ((unsigned int )prop->type == 5U) {
#line 2101
      goto case_5___0;
    }
#line 2104
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 2084
    fputs((char const   */* __restrict  */)"  prompt ", (FILE */* __restrict  */)out);
#line 2085
    print_quoted_string(out, prop->text);
#line 2086
    tmp___0 = expr_is_yes(prop->visible.expr);
    }
#line 2086
    if (! tmp___0) {
      {
#line 2087
      fputs((char const   */* __restrict  */)" if ", (FILE */* __restrict  */)out);
#line 2088
      expr_fprint(prop->visible.expr, out);
      }
    }
    {
#line 2090
    fputc('\n', out);
    }
#line 2091
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 2093
    fputs((char const   */* __restrict  */)"  default ", (FILE */* __restrict  */)out);
#line 2094
    expr_fprint(prop->expr, out);
#line 2095
    tmp___1 = expr_is_yes(prop->visible.expr);
    }
#line 2095
    if (! tmp___1) {
      {
#line 2096
      fputs((char const   */* __restrict  */)" if ", (FILE */* __restrict  */)out);
#line 2097
      expr_fprint(prop->visible.expr, out);
      }
    }
    {
#line 2099
    fputc('\n', out);
    }
#line 2100
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 2102
    fputs((char const   */* __restrict  */)"  #choice value\n", (FILE */* __restrict  */)out);
    }
#line 2103
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2105
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  unknown prop %d!\n",
            (unsigned int )prop->type);
    }
#line 2106
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2079
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2109
  if (sym->help) {
    {
#line 2110
    tmp___2 = strlen((char const   *)sym->help);
#line 2110
    len = (int )tmp___2;
    }
    {
#line 2111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2111
      len --;
#line 2111
      if (! ((int )*(sym->help + len) == 10)) {
#line 2111
        goto while_break___0;
      }
#line 2112
      *(sym->help + len) = (char)0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2113
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  help\n%s\n",
            sym->help);
    }
  }
  {
#line 2115
  fputc('\n', out);
  }
#line 2116
  return;
}
}
#line 2118 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/zconf.tab.c"
void zconfdump(FILE *out ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct menu *menu ;
  int tmp ;

  {
#line 2124
  menu = rootmenu.list;
  {
#line 2125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2125
    if (! menu) {
#line 2125
      goto while_break;
    }
#line 2126
    sym = menu->sym;
#line 2126
    if (sym) {
      {
#line 2127
      print_symbol(out, menu);
      }
    } else {
#line 2128
      prop = menu->prompt;
#line 2128
      if (prop) {
        {
#line 2130
        if ((unsigned int )prop->type == 2U) {
#line 2130
          goto case_2;
        }
#line 2135
        if ((unsigned int )prop->type == 3U) {
#line 2135
          goto case_3;
        }
#line 2140
        goto switch_default;
        case_2: /* CIL Label */ 
        {
#line 2131
        fputs((char const   */* __restrict  */)"\ncomment ", (FILE */* __restrict  */)out);
#line 2132
        print_quoted_string(out, prop->text);
#line 2133
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out);
        }
#line 2134
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 2136
        fputs((char const   */* __restrict  */)"\nmenu ", (FILE */* __restrict  */)out);
#line 2137
        print_quoted_string(out, prop->text);
#line 2138
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out);
        }
#line 2139
        goto switch_break;
        switch_default: /* CIL Label */ ;
        switch_break: /* CIL Label */ ;
        }
        {
#line 2143
        tmp = expr_is_yes(prop->visible.expr);
        }
#line 2143
        if (! tmp) {
          {
#line 2144
          fputs((char const   */* __restrict  */)"  depends ", (FILE */* __restrict  */)out);
#line 2145
          expr_fprint(prop->visible.expr, out);
#line 2146
          fputc('\n', out);
          }
        }
        {
#line 2148
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out);
        }
      }
    }
#line 2151
    if (menu->list) {
#line 2152
      menu = menu->list;
    } else
#line 2153
    if (menu->next) {
#line 2154
      menu = menu->next;
    } else {
      {
#line 2155
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2155
        menu = menu->parent;
#line 2155
        if (! menu) {
#line 2155
          goto while_break___0;
        }
#line 2156
        if (menu->prompt) {
#line 2156
          if ((unsigned int )(menu->prompt)->type == 3U) {
            {
#line 2157
            fputs((char const   */* __restrict  */)"\nendmenu\n", (FILE */* __restrict  */)out);
            }
          }
        }
#line 2158
        if (menu->next) {
#line 2159
          menu = menu->next;
#line 2160
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2164
  return;
}
}
#line 142 "scripts/kconfig/lex.zconf.c"
int zconfleng  ;
#line 144
FILE *zconfin ;
#line 144
FILE *zconfout ;
#line 244 "scripts/kconfig/lex.zconf.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 245 "scripts/kconfig/lex.zconf.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 246 "scripts/kconfig/lex.zconf.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 264 "scripts/kconfig/lex.zconf.c"
static char yy_hold_char  ;
#line 265 "scripts/kconfig/lex.zconf.c"
static int yy_n_chars  ;
#line 269 "scripts/kconfig/lex.zconf.c"
static char *yy_c_buf_p  =    (char *)0;
#line 270 "scripts/kconfig/lex.zconf.c"
static int yy_init  =    1;
#line 271 "scripts/kconfig/lex.zconf.c"
static int yy_start  =    0;
#line 276 "scripts/kconfig/lex.zconf.c"
static int yy_did_buffer_switch_on_eof  ;
#line 278
void zconfrestart(FILE *input_file ) ;
#line 279
void zconf_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 280
YY_BUFFER_STATE zconf_create_buffer(FILE *file , int size ) ;
#line 281
void zconf_delete_buffer(YY_BUFFER_STATE b ) ;
#line 282
void zconf_flush_buffer(YY_BUFFER_STATE b ) ;
#line 283
void zconfpush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 284
void zconfpop_buffer_state(void) ;
#line 286
static void zconfensure_buffer_stack(void) ;
#line 287
static void zconf_load_buffer_state(void) ;
#line 288
static void zconf_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 292
YY_BUFFER_STATE zconf_scan_buffer(char *base , yy_size_t size ) ;
#line 293
YY_BUFFER_STATE zconf_scan_string(char const   *yy_str ) ;
#line 294
YY_BUFFER_STATE zconf_scan_bytes(char const   *bytes , int len ) ;
#line 296
void *zconfalloc(yy_size_t size ) ;
#line 297
void *zconfrealloc(void *ptr , yy_size_t size ) ;
#line 298
void zconffree(void *ptr ) ;
#line 331 "scripts/kconfig/lex.zconf.c"
FILE *zconfin  =    (FILE *)0;
#line 331 "scripts/kconfig/lex.zconf.c"
FILE *zconfout  =    (FILE *)0;
#line 335
int zconflineno ;
#line 337 "scripts/kconfig/lex.zconf.c"
int zconflineno  =    1;
#line 339 "scripts/kconfig/lex.zconf.c"
char *zconftext  ;
#line 341 "scripts/kconfig/lex.zconf.c"
static flex_int16_t const   yy_nxt[61][17]  = 
#line 341
  { {        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )12,        (flex_int16_t const   )13,        (flex_int16_t const   )14, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )15,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )12,        (flex_int16_t const   )13,        (flex_int16_t const   )14, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )15,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )17, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )18,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )17, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )18,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )19,        (flex_int16_t const   )20,        (flex_int16_t const   )21, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )19,        (flex_int16_t const   )20,        (flex_int16_t const   )21, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )23, 
            (flex_int16_t const   )22,        (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )25, 
            (flex_int16_t const   )22}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )23, 
            (flex_int16_t const   )22,        (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )25, 
            (flex_int16_t const   )22}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )26,        (flex_int16_t const   )26,        (flex_int16_t const   )27, 
            (flex_int16_t const   )28,        (flex_int16_t const   )29,        (flex_int16_t const   )30,        (flex_int16_t const   )31, 
            (flex_int16_t const   )29,        (flex_int16_t const   )32,        (flex_int16_t const   )33,        (flex_int16_t const   )34, 
            (flex_int16_t const   )35,        (flex_int16_t const   )35,        (flex_int16_t const   )36,        (flex_int16_t const   )37, 
            (flex_int16_t const   )38}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )26,        (flex_int16_t const   )26,        (flex_int16_t const   )27, 
            (flex_int16_t const   )28,        (flex_int16_t const   )29,        (flex_int16_t const   )30,        (flex_int16_t const   )31, 
            (flex_int16_t const   )29,        (flex_int16_t const   )32,        (flex_int16_t const   )33,        (flex_int16_t const   )34, 
            (flex_int16_t const   )35,        (flex_int16_t const   )35,        (flex_int16_t const   )36,        (flex_int16_t const   )37, 
            (flex_int16_t const   )38}, 
   {        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-13,        (flex_int16_t const   )39,        (flex_int16_t const   )40, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )41,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )44,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )-19, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-20,        (flex_int16_t const   )46,        (flex_int16_t const   )47, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )48,        (flex_int16_t const   )-21,        (flex_int16_t const   )-21, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )50, 
            (flex_int16_t const   )49,        (flex_int16_t const   )-22,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )-22,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )-22, 
            (flex_int16_t const   )49}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )52, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )53,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )-30, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )55, 
            (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )-31}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )56, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )57, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )58, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )59}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-39,        (flex_int16_t const   )39,        (flex_int16_t const   )40, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )41,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44,        (flex_int16_t const   )44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )-45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-46,        (flex_int16_t const   )46,        (flex_int16_t const   )47, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )48,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )50, 
            (flex_int16_t const   )49,        (flex_int16_t const   )-49,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )-49,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )-49, 
            (flex_int16_t const   )49}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )52, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )-54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )60, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )57, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )57, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60}};
#line 662
static yy_state_type yy_get_previous_state(void) ;
#line 663
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 664
static int yy_get_next_buffer(void) ;
#line 665
static void yy_fatal_error(char const   *msg ) ;
#line 686 "scripts/kconfig/lex.zconf.c"
static flex_int16_t const   yy_accept[61]  = 
#line 686
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )34, 
        (flex_int16_t const   )5,      (flex_int16_t const   )4,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )32, 
        (flex_int16_t const   )29,      (flex_int16_t const   )31,      (flex_int16_t const   )24,      (flex_int16_t const   )28, 
        (flex_int16_t const   )27,      (flex_int16_t const   )26,      (flex_int16_t const   )22,      (flex_int16_t const   )17, 
        (flex_int16_t const   )13,      (flex_int16_t const   )16,      (flex_int16_t const   )20,      (flex_int16_t const   )22, 
        (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )14,      (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )4, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )1, 
        (flex_int16_t const   )6,      (flex_int16_t const   )32,      (flex_int16_t const   )29,      (flex_int16_t const   )31, 
        (flex_int16_t const   )30,      (flex_int16_t const   )24,      (flex_int16_t const   )23,      (flex_int16_t const   )26, 
        (flex_int16_t const   )25,      (flex_int16_t const   )15,      (flex_int16_t const   )20,      (flex_int16_t const   )9, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )21,      (flex_int16_t const   )10, 
        (flex_int16_t const   )18};
#line 696 "scripts/kconfig/lex.zconf.c"
static flex_int32_t const   yy_ec[256]  = 
#line 696
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )14,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )15,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )13, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )16,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 728
int zconf_flex_debug ;
#line 729 "scripts/kconfig/lex.zconf.c"
int zconf_flex_debug  =    0;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756 "scripts/kconfig/lex.zconf.c"
static struct __anonstruct_current_pos_30 current_pos  ;
#line 761 "scripts/kconfig/lex.zconf.c"
static char *text  ;
#line 762 "scripts/kconfig/lex.zconf.c"
static int text_size  ;
#line 762 "scripts/kconfig/lex.zconf.c"
static int text_asize  ;
#line 769 "scripts/kconfig/lex.zconf.c"
struct buffer *current_buf  ;
#line 771 "scripts/kconfig/lex.zconf.c"
static int last_ts  ;
#line 771 "scripts/kconfig/lex.zconf.c"
static int first_ts  ;
#line 773
static void zconf_endhelp(void) ;
#line 774
static void zconf_endfile(void) ;
#line 776 "scripts/kconfig/lex.zconf.c"
void new_string(void) 
{ 
  void *tmp ;

  {
  {
#line 778
  tmp = malloc((size_t )16);
#line 778
  text = (char *)tmp;
#line 779
  text_asize = 16;
#line 780
  text_size = 0;
#line 781
  *text = (char)0;
  }
#line 782
  return;
}
}
#line 784 "scripts/kconfig/lex.zconf.c"
void append_string(char const   *str , int size ) 
{ 
  int new_size ;
  void *tmp ;

  {
#line 786
  new_size = (text_size + size) + 1;
#line 787
  if (size > 70) {
    {
#line 788
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d error: Overlong line\n",
            current_file->name, current_file->lineno);
    }
  }
#line 792
  if (new_size > text_asize) {
    {
#line 793
    new_size += 15;
#line 794
    new_size &= -16;
#line 795
    tmp = realloc((void *)text, (size_t )new_size);
#line 795
    text = (char *)tmp;
#line 796
    text_asize = new_size;
    }
  }
  {
#line 798
  memcpy((void */* __restrict  */)(text + text_size), (void const   */* __restrict  */)str,
         (size_t )size);
#line 799
  text_size += size;
#line 800
  *(text + text_size) = (char)0;
  }
#line 801
  return;
}
}
#line 803 "scripts/kconfig/lex.zconf.c"
void alloc_string(char const   *str , int size ) 
{ 
  void *tmp ;

  {
  {
#line 805
  tmp = malloc((size_t )(size + 1));
#line 805
  text = (char *)tmp;
#line 806
  memcpy((void */* __restrict  */)text, (void const   */* __restrict  */)str, (size_t )size);
#line 807
  *(text + size) = (char)0;
  }
#line 808
  return;
}
}
#line 840
static void yyunput(int c , char *yy_bp ) ;
#line 944 "scripts/kconfig/lex.zconf.c"
int zconflex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  int str ;
  int ts ;
  int i ;
  YY_BUFFER_STATE tmp ;
  struct kconf_id *id ;
  struct kconf_id *tmp___0 ;
  struct kconf_id *id___0 ;
  struct kconf_id *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;

  {
#line 950
  str = 0;
#line 953
  if (yy_init) {
#line 955
    yy_init = 0;
#line 961
    if (! yy_start) {
#line 962
      yy_start = 1;
    }
#line 964
    if (! zconfin) {
#line 965
      zconfin = stdin;
    }
#line 967
    if (! zconfout) {
#line 968
      zconfout = stdout;
    }
#line 970
    if (yy_buffer_stack) {
#line 970
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 970
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 970
    if (! tmp) {
      {
#line 971
      zconfensure_buffer_stack();
#line 972
      *(yy_buffer_stack + yy_buffer_stack_top) = zconf_create_buffer(zconfin, 16384);
      }
    }
    {
#line 976
    zconf_load_buffer_state();
    }
  }
  {
#line 979
  while (1) {
    while_continue: /* CIL Label */ ;
#line 981
    yy_cp = yy_c_buf_p;
#line 984
    *yy_cp = yy_hold_char;
#line 989
    yy_bp = yy_cp;
#line 991
    yy_current_state = yy_start;
    yy_match: 
    {
#line 993
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 993
      yy_current_state = (yy_state_type )yy_nxt[yy_current_state][yy_ec[(unsigned int )((unsigned char )*yy_cp)]];
#line 993
      if (! (yy_current_state > 0)) {
#line 993
        goto while_break___0;
      }
#line 994
      yy_cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 996
    yy_current_state = - yy_current_state;
    yy_find_action: 
#line 999
    yy_act = (int )yy_accept[yy_current_state];
#line 1001
    zconftext = yy_bp;
#line 1001
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1001
    yy_hold_char = *yy_cp;
#line 1001
    *yy_cp = (char )'\000';
#line 1001
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1009
    if (yy_act == 2) {
#line 1009
      goto case_2;
    }
#line 1009
    if (yy_act == 1) {
#line 1009
      goto case_2;
    }
#line 1017
    if (yy_act == 3) {
#line 1017
      goto case_3;
    }
#line 1021
    if (yy_act == 4) {
#line 1021
      goto case_4;
    }
#line 1027
    if (yy_act == 5) {
#line 1027
      goto case_5;
    }
#line 1035
    if (yy_act == 6) {
#line 1035
      goto case_6;
    }
#line 1051
    if (yy_act == 7) {
#line 1051
      goto case_7;
    }
#line 1055
    if (yy_act == 8) {
#line 1055
      goto case_8;
    }
#line 1065
    if (yy_act == 9) {
#line 1065
      goto case_9;
    }
#line 1069
    if (yy_act == 10) {
#line 1069
      goto case_10;
    }
#line 1073
    if (yy_act == 11) {
#line 1073
      goto case_11;
    }
#line 1077
    if (yy_act == 12) {
#line 1077
      goto case_12;
    }
#line 1081
    if (yy_act == 13) {
#line 1081
      goto case_13;
    }
#line 1085
    if (yy_act == 14) {
#line 1085
      goto case_14;
    }
#line 1089
    if (yy_act == 15) {
#line 1089
      goto case_15;
    }
#line 1093
    if (yy_act == 16) {
#line 1093
      goto case_16;
    }
#line 1101
    if (yy_act == 17) {
#line 1101
      goto case_17;
    }
#line 1106
    if (yy_act == 18) {
#line 1106
      goto case_18;
    }
#line 1110
    if (yy_act == 19) {
#line 1110
      goto case_19;
    }
#line 1123
    if (yy_act == 20) {
#line 1123
      goto case_20;
    }
#line 1127
    if (yy_act == 21) {
#line 1127
      goto case_21;
    }
#line 1132
    if (yy_act == 22) {
#line 1132
      goto case_22;
    }
#line 1136
    if (yy_act == 39) {
#line 1136
      goto case_39;
    }
#line 1142
    if (yy_act == 23) {
#line 1142
      goto case_23;
    }
#line 1154
    if (yy_act == 24) {
#line 1154
      goto case_24;
    }
#line 1160
    if (yy_act == 25) {
#line 1160
      goto case_25;
    }
#line 1172
    if (yy_act == 26) {
#line 1172
      goto case_26;
    }
#line 1178
    if (yy_act == 27) {
#line 1178
      goto case_27;
    }
#line 1189
    if (yy_act == 28) {
#line 1189
      goto case_28;
    }
#line 1199
    if (yy_act == 38) {
#line 1199
      goto case_38;
    }
#line 1205
    if (yy_act == 29) {
#line 1205
      goto case_29;
    }
#line 1230
    if (yy_act == 30) {
#line 1230
      goto case_30;
    }
#line 1242
    if (yy_act == 31) {
#line 1242
      goto case_31;
    }
#line 1250
    if (yy_act == 32) {
#line 1250
      goto case_32;
    }
#line 1258
    if (yy_act == 37) {
#line 1258
      goto case_37;
    }
#line 1266
    if (yy_act == 36) {
#line 1266
      goto case_36;
    }
#line 1266
    if (yy_act == 35) {
#line 1266
      goto case_36;
    }
#line 1276
    if (yy_act == 33) {
#line 1276
      goto case_33;
    }
#line 1281
    if (yy_act == 34) {
#line 1281
      goto case_34;
    }
#line 1403
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1013
    (current_file->lineno) ++;
#line 1014
    return (285);
#line 1016
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1020
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1024
    yy_start = 3;
#line 1026
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1030
    yyunput((int )*(zconftext + 0), zconftext);
#line 1031
    yy_start = 3;
    }
#line 1033
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1038
    tmp___0 = kconf_id_lookup((char const   *)zconftext, (unsigned int )zconfleng);
#line 1038
    id = tmp___0;
#line 1039
    yy_start = 9;
#line 1040
    current_pos.file = current_file;
#line 1041
    current_pos.lineno = current_file->lineno;
    }
#line 1042
    if (id) {
#line 1042
      if (id->flags & 1U) {
#line 1043
        zconflval.id = id;
#line 1044
        return (id->token);
      }
    }
    {
#line 1046
    alloc_string((char const   *)zconftext, zconfleng);
#line 1047
    zconflval.string = text;
    }
#line 1048
    return (280);
#line 1050
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1054
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1059
    yy_start = 1;
#line 1060
    (current_file->lineno) ++;
#line 1061
    return (285);
#line 1063
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1067
    return (287);
#line 1068
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1071
    return (286);
#line 1072
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1075
    return (284);
#line 1076
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1079
    return (283);
#line 1080
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1083
    return (289);
#line 1084
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1087
    return (288);
#line 1088
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1091
    return (282);
#line 1092
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 1096
    str = (int )*(zconftext + 0);
#line 1097
    new_string();
#line 1098
    yy_start = 7;
    }
#line 1100
    goto switch_break;
    case_17: /* CIL Label */ 
#line 1104
    yy_start = 1;
#line 1104
    (current_file->lineno) ++;
#line 1104
    return (285);
#line 1105
    goto switch_break;
    case_18: /* CIL Label */ 
#line 1109
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 1113
    tmp___1 = kconf_id_lookup((char const   *)zconftext, (unsigned int )zconfleng);
#line 1113
    id___0 = tmp___1;
    }
#line 1114
    if (id___0) {
#line 1114
      if (id___0->flags & 2U) {
#line 1115
        zconflval.id = id___0;
#line 1116
        return (id___0->token);
      }
    }
    {
#line 1118
    alloc_string((char const   *)zconftext, zconfleng);
#line 1119
    zconflval.string = text;
    }
#line 1120
    return (280);
#line 1122
    goto switch_break;
    case_20: /* CIL Label */ 
#line 1126
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1130
    (current_file->lineno) ++;
#line 1131
    goto switch_break;
    case_22: /* CIL Label */ 
#line 1135
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1138
    yy_start = 1;
#line 1140
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 1144
    *yy_cp = yy_hold_char;
#line 1145
    yy_cp --;
#line 1145
    yy_c_buf_p = yy_cp;
#line 1146
    zconftext = yy_bp;
#line 1146
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1146
    yy_hold_char = *yy_cp;
#line 1146
    *yy_cp = (char )'\000';
#line 1146
    yy_c_buf_p = yy_cp;
#line 1149
    append_string((char const   *)zconftext, zconfleng);
#line 1150
    zconflval.string = text;
    }
#line 1151
    return (281);
#line 1153
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 1157
    append_string((char const   *)zconftext, zconfleng);
    }
#line 1159
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 1162
    *yy_cp = yy_hold_char;
#line 1163
    yy_cp --;
#line 1163
    yy_c_buf_p = yy_cp;
#line 1164
    zconftext = yy_bp;
#line 1164
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1164
    yy_hold_char = *yy_cp;
#line 1164
    *yy_cp = (char )'\000';
#line 1164
    yy_c_buf_p = yy_cp;
#line 1167
    append_string((char const   *)(zconftext + 1), zconfleng - 1);
#line 1168
    zconflval.string = text;
    }
#line 1169
    return (281);
#line 1171
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 1175
    append_string((char const   *)(zconftext + 1), zconfleng - 1);
    }
#line 1177
    goto switch_break;
    case_27: /* CIL Label */ 
#line 1181
    if (str == (int )*(zconftext + 0)) {
#line 1182
      yy_start = 9;
#line 1183
      zconflval.string = text;
#line 1184
      return (281);
    } else {
      {
#line 1186
      append_string((char const   *)zconftext, 1);
      }
    }
#line 1188
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 1193
    tmp___2 = zconf_lineno();
#line 1193
    tmp___3 = zconf_curname();
#line 1193
    printf((char const   */* __restrict  */)"%s:%d:warning: multi-line strings not supported\n",
           tmp___3, tmp___2);
#line 1194
    (current_file->lineno) ++;
#line 1195
    yy_start = 1;
    }
#line 1196
    return (285);
#line 1198
    goto switch_break;
    case_38: /* CIL Label */ 
#line 1201
    yy_start = 1;
#line 1203
    goto switch_break;
    case_29: /* CIL Label */ 
#line 1208
    ts = 0;
#line 1209
    i = 0;
    {
#line 1209
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1209
      if (! (i < zconfleng)) {
#line 1209
        goto while_break___1;
      }
#line 1210
      if ((int )*(zconftext + i) == 9) {
#line 1211
        ts = (ts & -8) + 8;
      } else {
#line 1213
        ts ++;
      }
#line 1209
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1215
    last_ts = ts;
#line 1216
    if (first_ts) {
#line 1217
      if (ts < first_ts) {
        {
#line 1218
        zconf_endhelp();
        }
#line 1219
        return (268);
      }
#line 1221
      ts -= first_ts;
      {
#line 1222
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1222
        if (! (ts > 8)) {
#line 1222
          goto while_break___2;
        }
        {
#line 1223
        append_string("        ", 8);
#line 1224
        ts -= 8;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1226
      append_string("        ", ts);
      }
    }
#line 1229
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 1232
    *yy_cp = yy_hold_char;
#line 1233
    yy_cp --;
#line 1233
    yy_c_buf_p = yy_cp;
#line 1234
    zconftext = yy_bp;
#line 1234
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1234
    yy_hold_char = *yy_cp;
#line 1234
    *yy_cp = (char )'\000';
#line 1234
    yy_c_buf_p = yy_cp;
#line 1237
    (current_file->lineno) ++;
#line 1238
    zconf_endhelp();
    }
#line 1239
    return (268);
#line 1241
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 1246
    (current_file->lineno) ++;
#line 1247
    append_string("\n", 1);
    }
#line 1249
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 1253
    append_string((char const   *)zconftext, zconfleng);
    }
#line 1254
    if (! first_ts) {
#line 1255
      first_ts = last_ts;
    }
#line 1257
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 1260
    zconf_endhelp();
    }
#line 1261
    return (268);
#line 1263
    goto switch_break;
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 1268
    if (current_file) {
      {
#line 1269
      zconf_endfile();
      }
#line 1270
      return (285);
    }
    {
#line 1272
    fclose(zconfin);
    }
#line 1273
    return (0);
#line 1275
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 1278
    yy_fatal_error("flex scanner jammed");
    }
#line 1279
    goto switch_break;
    case_34: /* CIL Label */ 
#line 1284
    yy_amount_of_matched_text = (int )(yy_cp - zconftext) - 1;
#line 1287
    *yy_cp = yy_hold_char;
#line 1290
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1301
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1302
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = zconfin;
#line 1303
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1313
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1317
      yy_c_buf_p = zconftext + yy_amount_of_matched_text;
#line 1319
      yy_current_state = yy_get_previous_state();
#line 1330
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1332
      yy_bp = zconftext + 0;
      }
#line 1334
      if (yy_next_state) {
#line 1337
        yy_c_buf_p ++;
#line 1337
        yy_cp = yy_c_buf_p;
#line 1338
        yy_current_state = yy_next_state;
#line 1339
        goto yy_match;
      } else {
#line 1344
        yy_cp = yy_c_buf_p;
#line 1345
        goto yy_find_action;
      }
    } else {
      {
#line 1349
      tmp___4 = yy_get_next_buffer();
      }
      {
#line 1351
      if (tmp___4 == 1) {
#line 1351
        goto case_1___0;
      }
#line 1380
      if (tmp___4 == 0) {
#line 1380
        goto case_0;
      }
#line 1390
      if (tmp___4 == 2) {
#line 1390
        goto case_2___0;
      }
#line 1349
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1353
      yy_did_buffer_switch_on_eof = 0;
#line 1366
      yy_c_buf_p = zconftext + 0;
#line 1368
      yy_act = (34 + (yy_start - 1) / 2) + 1;
#line 1369
      goto do_action;
#line 1377
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 1381
      yy_c_buf_p = zconftext + yy_amount_of_matched_text;
#line 1384
      yy_current_state = yy_get_previous_state();
#line 1386
      yy_cp = yy_c_buf_p;
#line 1387
      yy_bp = zconftext + 0;
      }
#line 1388
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1391
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1394
      yy_current_state = yy_get_previous_state();
#line 1396
      yy_cp = yy_c_buf_p;
#line 1397
      yy_bp = zconftext + 0;
      }
#line 1398
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1400
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1404
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1417 "scripts/kconfig/lex.zconf.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  size_t num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
#line 1419
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1420
  source = zconftext;
#line 1424
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1425
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1428
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1430
    if (yy_c_buf_p - zconftext == 1L) {
#line 1435
      return (1);
    } else {
#line 1443
      return (2);
    }
  }
#line 1450
  number_to_move = (int )(yy_c_buf_p - zconftext) - 1;
#line 1452
  i = 0;
  {
#line 1452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1452
    if (! (i < number_to_move)) {
#line 1452
      goto while_break;
    }
#line 1453
    tmp = dest;
#line 1453
    dest ++;
#line 1453
    tmp___0 = source;
#line 1453
    source ++;
#line 1453
    *tmp = *tmp___0;
#line 1452
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1455
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1459
    yy_n_chars = 0;
#line 1459
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1463
    num_to_read = (size_t )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1466
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1466
      if (! (num_to_read <= 0UL)) {
#line 1466
        goto while_break___0;
      }
#line 1470
      if (yy_buffer_stack) {
#line 1470
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1470
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1470
      b = tmp___1;
#line 1472
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1475
      if (b->yy_is_our_buffer) {
#line 1477
        new_size = (int )(b->yy_buf_size * 2U);
#line 1479
        if (new_size <= 0) {
#line 1480
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1482
          b->yy_buf_size *= 2U;
        }
        {
#line 1484
        tmp___2 = zconfrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1484
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1490
        b->yy_ch_buf = (char *)0;
      }
#line 1492
      if (! b->yy_ch_buf) {
        {
#line 1493
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1496
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1498
      num_to_read = (size_t )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1503
    if (num_to_read > 8192UL) {
#line 1504
      num_to_read = (size_t )8192;
    }
    {
#line 1507
    tmp___3 = __errno_location();
#line 1507
    *tmp___3 = 0;
    }
    {
#line 1507
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1507
      tmp___6 = fileno(zconfin);
#line 1507
      tmp___7 = read(tmp___6, (void *)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                     num_to_read);
#line 1507
      yy_n_chars = (int )tmp___7;
      }
#line 1507
      if (! (yy_n_chars < 0)) {
#line 1507
        goto while_break___1;
      }
      {
#line 1507
      tmp___4 = __errno_location();
      }
#line 1507
      if (*tmp___4 != 4) {
        {
#line 1507
        yy_fatal_error("input in flex scanner failed");
        }
#line 1507
        goto while_break___1;
      }
      {
#line 1507
      tmp___5 = __errno_location();
#line 1507
      *tmp___5 = 0;
#line 1507
      clearerr(zconfin);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1510
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1513
  if (yy_n_chars == 0) {
#line 1515
    if (number_to_move == 0) {
      {
#line 1517
      ret_val = 1;
#line 1518
      zconfrestart(zconfin);
      }
    } else {
#line 1523
      ret_val = 2;
#line 1524
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1530
    ret_val = 0;
  }
#line 1532
  yy_n_chars += number_to_move;
#line 1533
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1534
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1536
  zconftext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1538
  return (ret_val);
}
}
#line 1543 "scripts/kconfig/lex.zconf.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  flex_int32_t tmp ;

  {
#line 1548
  yy_current_state = yy_start;
#line 1550
  yy_cp = zconftext + 0;
  {
#line 1550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1550
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1550
      goto while_break;
    }
#line 1552
    if (*yy_cp) {
#line 1552
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1552
      tmp = (flex_int32_t const   )1;
    }
#line 1552
    yy_current_state = (yy_state_type )yy_nxt[yy_current_state][tmp];
#line 1550
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1555
  return (yy_current_state);
}
}
#line 1563 "scripts/kconfig/lex.zconf.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  int tmp ;

  {
#line 1567
  yy_current_state = (yy_state_type )yy_nxt[yy_current_state][1];
#line 1568
  yy_is_jam = yy_current_state <= 0;
#line 1570
  if (yy_is_jam) {
#line 1570
    tmp = 0;
  } else {
#line 1570
    tmp = yy_current_state;
  }
#line 1570
  return (tmp);
}
}
#line 1573 "scripts/kconfig/lex.zconf.c"
static void yyunput(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register int number_to_move ;
  register char *dest ;
  register char *source ;

  {
#line 1577
  yy_cp = yy_c_buf_p;
#line 1580
  *yy_cp = yy_hold_char;
#line 1582
  if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
#line 1585
    number_to_move = yy_n_chars + 2;
#line 1586
    dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size + 2U);
#line 1588
    source = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move;
    {
#line 1591
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1591
      if (! ((unsigned long )source > (unsigned long )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf)) {
#line 1591
        goto while_break;
      }
#line 1592
      dest --;
#line 1592
      source --;
#line 1592
      *dest = *source;
    }
    while_break: /* CIL Label */ ;
    }
#line 1594
    yy_cp += (int )(dest - source);
#line 1595
    yy_bp += (int )(dest - source);
#line 1596
    yy_n_chars = (int )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size;
#line 1596
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
#line 1599
    if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
      {
#line 1600
      yy_fatal_error("flex scanner push-back overflow");
      }
    }
  }
#line 1603
  yy_cp --;
#line 1603
  *yy_cp = (char )c;
#line 1605
  zconftext = yy_bp;
#line 1606
  yy_hold_char = *yy_cp;
#line 1607
  yy_c_buf_p = yy_cp;
#line 1608
  return;
}
}
#line 1689 "scripts/kconfig/lex.zconf.c"
void zconfrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1692
  if (yy_buffer_stack) {
#line 1692
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1692
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1692
  if (! tmp) {
    {
#line 1693
    zconfensure_buffer_stack();
#line 1694
    *(yy_buffer_stack + yy_buffer_stack_top) = zconf_create_buffer(zconfin, 16384);
    }
  }
#line 1698
  if (yy_buffer_stack) {
#line 1698
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1698
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1698
  zconf_init_buffer(tmp___0, input_file);
#line 1699
  zconf_load_buffer_state();
  }
#line 1700
  return;
}
}
#line 1706 "scripts/kconfig/lex.zconf.c"
void zconf_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1714
  zconfensure_buffer_stack();
  }
#line 1715
  if (yy_buffer_stack) {
#line 1715
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1715
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1715
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1716
    return;
  }
#line 1718
  if (yy_buffer_stack) {
#line 1718
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1718
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1718
  if (tmp___0) {
#line 1721
    *yy_c_buf_p = yy_hold_char;
#line 1722
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1723
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1726
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1727
  zconf_load_buffer_state();
#line 1734
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1735
  return;
}
}
#line 1737 "scripts/kconfig/lex.zconf.c"
static void zconf_load_buffer_state(void) 
{ 


  {
#line 1739
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1740
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1740
  zconftext = yy_c_buf_p;
#line 1741
  zconfin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1742
  yy_hold_char = *yy_c_buf_p;
#line 1743
  return;
}
}
#line 1751 "scripts/kconfig/lex.zconf.c"
YY_BUFFER_STATE zconf_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1755
  tmp = zconfalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1755
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1756
  if (! b) {
    {
#line 1757
    yy_fatal_error("out of dynamic memory in zconf_create_buffer()");
    }
  }
  {
#line 1759
  b->yy_buf_size = (yy_size_t )size;
#line 1764
  tmp___0 = zconfalloc(b->yy_buf_size + 2U);
#line 1764
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1765
  if (! b->yy_ch_buf) {
    {
#line 1766
    yy_fatal_error("out of dynamic memory in zconf_create_buffer()");
    }
  }
  {
#line 1768
  b->yy_is_our_buffer = 1;
#line 1770
  zconf_init_buffer(b, file);
  }
#line 1772
  return (b);
}
}
#line 1779 "scripts/kconfig/lex.zconf.c"
void zconf_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1782
  if (! b) {
#line 1783
    return;
  }
#line 1785
  if (yy_buffer_stack) {
#line 1785
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1785
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1785
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1786
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1788
  if (b->yy_is_our_buffer) {
    {
#line 1789
    zconffree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1791
  zconffree((void *)b);
  }
#line 1792
  return;
}
}
#line 1798 "scripts/kconfig/lex.zconf.c"
static void zconf_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1801
  tmp = __errno_location();
#line 1801
  oerrno = *tmp;
#line 1803
  zconf_flush_buffer(b);
#line 1805
  b->yy_input_file = file;
#line 1806
  b->yy_fill_buffer = 1;
  }
#line 1812
  if (yy_buffer_stack) {
#line 1812
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1812
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1812
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1813
    b->yy_bs_lineno = 1;
#line 1814
    b->yy_bs_column = 0;
  }
  {
#line 1817
  b->yy_is_interactive = 0;
#line 1819
  tmp___1 = __errno_location();
#line 1819
  *tmp___1 = oerrno;
  }
#line 1820
  return;
}
}
#line 1826 "scripts/kconfig/lex.zconf.c"
void zconf_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1828
  if (! b) {
#line 1829
    return;
  }
#line 1831
  b->yy_n_chars = 0;
#line 1837
  *(b->yy_ch_buf + 0) = (char)0;
#line 1838
  *(b->yy_ch_buf + 1) = (char)0;
#line 1840
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1842
  b->yy_at_bol = 1;
#line 1843
  b->yy_buffer_status = 0;
#line 1845
  if (yy_buffer_stack) {
#line 1845
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1845
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1845
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1846
    zconf_load_buffer_state();
    }
  }
#line 1847
  return;
}
}
#line 1855 "scripts/kconfig/lex.zconf.c"
void zconfpush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1857
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1858
    return;
  }
  {
#line 1860
  zconfensure_buffer_stack();
  }
#line 1863
  if (yy_buffer_stack) {
#line 1863
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1863
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1863
  if (tmp) {
#line 1866
    *yy_c_buf_p = yy_hold_char;
#line 1867
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1868
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1872
  if (yy_buffer_stack) {
#line 1872
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1872
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1872
  if (tmp___0) {
#line 1873
    yy_buffer_stack_top ++;
  }
  {
#line 1874
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1877
  zconf_load_buffer_state();
#line 1878
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1879
  return;
}
}
#line 1885 "scripts/kconfig/lex.zconf.c"
void zconfpop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1887
  if (yy_buffer_stack) {
#line 1887
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1887
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1887
  if (! tmp) {
#line 1888
    return;
  }
#line 1890
  if (yy_buffer_stack) {
#line 1890
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1890
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1890
  zconf_delete_buffer(tmp___0);
#line 1891
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1892
  if (yy_buffer_stack_top > 0UL) {
#line 1893
    yy_buffer_stack_top --;
  }
#line 1895
  if (yy_buffer_stack) {
#line 1895
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1895
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1895
  if (tmp___1) {
    {
#line 1896
    zconf_load_buffer_state();
#line 1897
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1899
  return;
}
}
#line 1904 "scripts/kconfig/lex.zconf.c"
static void zconfensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1908
  if (! yy_buffer_stack) {
    {
#line 1914
    num_to_alloc = 1;
#line 1915
    tmp = zconfalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1915
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
#line 1919
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1921
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1922
    yy_buffer_stack_top = (size_t )0;
    }
#line 1923
    return;
  }
#line 1926
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 1929
    grow_size = 8;
#line 1931
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1932
    tmp___0 = zconfrealloc((void *)yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1932
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
#line 1938
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 1939
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1941
  return;
}
}
#line 1949 "scripts/kconfig/lex.zconf.c"
YY_BUFFER_STATE zconf_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1953
  if (size < 2U) {
#line 1957
    return ((YY_BUFFER_STATE )0);
  } else
#line 1953
  if ((int )*(base + (size - 2U)) != 0) {
#line 1957
    return ((YY_BUFFER_STATE )0);
  } else
#line 1953
  if ((int )*(base + (size - 1U)) != 0) {
#line 1957
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1959
  tmp = zconfalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1959
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1960
  if (! b) {
    {
#line 1961
    yy_fatal_error("out of dynamic memory in zconf_scan_buffer()");
    }
  }
  {
#line 1963
  b->yy_buf_size = size - 2U;
#line 1964
  tmp___0 = base;
#line 1964
  b->yy_ch_buf = tmp___0;
#line 1964
  b->yy_buf_pos = tmp___0;
#line 1965
  b->yy_is_our_buffer = 0;
#line 1966
  b->yy_input_file = (FILE *)0;
#line 1967
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1968
  b->yy_is_interactive = 0;
#line 1969
  b->yy_at_bol = 1;
#line 1970
  b->yy_fill_buffer = 0;
#line 1971
  b->yy_buffer_status = 0;
#line 1973
  zconf_switch_to_buffer(b);
  }
#line 1975
  return (b);
}
}
#line 1986 "scripts/kconfig/lex.zconf.c"
YY_BUFFER_STATE zconf_scan_string(char const   *yy_str ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1989
  tmp = strlen(yy_str);
#line 1989
  tmp___0 = zconf_scan_bytes(yy_str, (int )tmp);
  }
#line 1989
  return (tmp___0);
}
}
#line 1999 "scripts/kconfig/lex.zconf.c"
YY_BUFFER_STATE zconf_scan_bytes(char const   *bytes , int len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2007
  n = (yy_size_t )(len + 2);
#line 2008
  tmp = zconfalloc(n);
#line 2008
  buf = (char *)tmp;
  }
#line 2009
  if (! buf) {
    {
#line 2010
    yy_fatal_error("out of dynamic memory in zconf_scan_bytes()");
    }
  }
#line 2012
  i = 0;
  {
#line 2012
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2012
    if (! (i < len)) {
#line 2012
      goto while_break;
    }
#line 2013
    *(buf + i) = (char )*(bytes + i);
#line 2012
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2015
  tmp___0 = (char)0;
#line 2015
  *(buf + (len + 1)) = tmp___0;
#line 2015
  *(buf + len) = tmp___0;
#line 2017
  b = zconf_scan_buffer(buf, n);
  }
#line 2018
  if (! b) {
    {
#line 2019
    yy_fatal_error("bad buffer in zconf_scan_bytes()");
    }
  }
#line 2024
  b->yy_is_our_buffer = 1;
#line 2026
  return (b);
}
}
#line 2033 "scripts/kconfig/lex.zconf.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 2035
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2036
  exit(2);
  }
}
}
#line 2061 "scripts/kconfig/lex.zconf.c"
int zconfget_lineno(void) 
{ 


  {
#line 2064
  return (zconflineno);
}
}
#line 2070 "scripts/kconfig/lex.zconf.c"
FILE *zconfget_in(void) 
{ 


  {
#line 2072
  return (zconfin);
}
}
#line 2078 "scripts/kconfig/lex.zconf.c"
FILE *zconfget_out(void) 
{ 


  {
#line 2080
  return (zconfout);
}
}
#line 2086 "scripts/kconfig/lex.zconf.c"
int zconfget_leng(void) 
{ 


  {
#line 2088
  return (zconfleng);
}
}
#line 2095 "scripts/kconfig/lex.zconf.c"
char *zconfget_text(void) 
{ 


  {
#line 2097
  return (zconftext);
}
}
#line 2104 "scripts/kconfig/lex.zconf.c"
void zconfset_lineno(int line_number ) 
{ 


  {
#line 2107
  zconflineno = line_number;
#line 2108
  return;
}
}
#line 2116 "scripts/kconfig/lex.zconf.c"
void zconfset_in(FILE *in_str ) 
{ 


  {
#line 2118
  zconfin = in_str;
#line 2119
  return;
}
}
#line 2121 "scripts/kconfig/lex.zconf.c"
void zconfset_out(FILE *out_str ) 
{ 


  {
#line 2123
  zconfout = out_str;
#line 2124
  return;
}
}
#line 2126 "scripts/kconfig/lex.zconf.c"
int zconfget_debug(void) 
{ 


  {
#line 2128
  return (zconf_flex_debug);
}
}
#line 2131 "scripts/kconfig/lex.zconf.c"
void zconfset_debug(int bdebug ) 
{ 


  {
#line 2133
  zconf_flex_debug = bdebug;
#line 2134
  return;
}
}
#line 2137 "scripts/kconfig/lex.zconf.c"
int zconflex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2141
    if (yy_buffer_stack) {
#line 2141
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2141
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2141
    if (! tmp___0) {
#line 2141
      goto while_break;
    }
#line 2142
    if (yy_buffer_stack) {
#line 2142
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2142
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2142
    zconf_delete_buffer(tmp);
#line 2143
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2144
    zconfpop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2148
  zconffree((void *)yy_buffer_stack);
#line 2149
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
  }
#line 2151
  return (0);
}
}
#line 2178 "scripts/kconfig/lex.zconf.c"
void *zconfalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2180
  tmp = malloc((size_t )size);
  }
#line 2180
  return (tmp);
}
}
#line 2183 "scripts/kconfig/lex.zconf.c"
void *zconfrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2192
  tmp = realloc((void *)((char *)ptr), (size_t )size);
  }
#line 2192
  return (tmp);
}
}
#line 2195 "scripts/kconfig/lex.zconf.c"
void zconffree(void *ptr ) 
{ 


  {
  {
#line 2197
  free((void *)((char *)ptr));
  }
#line 2198
  return;
}
}
#line 2215 "scripts/kconfig/lex.zconf.c"
void zconf_starthelp(void) 
{ 


  {
  {
#line 2217
  new_string();
#line 2218
  first_ts = 0;
#line 2218
  last_ts = first_ts;
#line 2219
  yy_start = 5;
  }
#line 2220
  return;
}
}
#line 2222 "scripts/kconfig/lex.zconf.c"
static void zconf_endhelp(void) 
{ 


  {
#line 2224
  zconflval.string = text;
#line 2225
  yy_start = 1;
#line 2226
  return;
}
}
#line 2236 "scripts/kconfig/lex.zconf.c"
FILE *zconf_fopen(char const   *name ) 
{ 
  char *env ;
  FILE *f ;
  char *fullname___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 2241
  f = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 2242
  if (! f) {
#line 2242
    if ((int const   )*(name + 0) != 47) {
      {
#line 2243
      env = getenv("srctree");
      }
#line 2244
      if (env) {
        {
#line 2245
        tmp = strlen((char const   *)env);
#line 2245
        tmp___0 = strlen(name);
#line 2245
        tmp___1 = __builtin_alloca((tmp + tmp___0) + 2UL);
#line 2245
        fullname___0 = (char *)tmp___1;
#line 2246
        sprintf((char */* __restrict  */)fullname___0, (char const   */* __restrict  */)"%s/%s",
                env, name);
#line 2247
        f = fopen((char const   */* __restrict  */)fullname___0, (char const   */* __restrict  */)"r");
        }
      }
    }
  }
#line 2250
  return (f);
}
}
#line 2253 "scripts/kconfig/lex.zconf.c"
void zconf_initscan(char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 2255
  zconfin = zconf_fopen(name);
  }
#line 2256
  if (! zconfin) {
    {
#line 2257
    printf((char const   */* __restrict  */)"can\'t find file %s\n", name);
#line 2258
    exit(1);
    }
  }
  {
#line 2261
  tmp = malloc(sizeof(*current_buf));
#line 2261
  current_buf = (struct buffer *)tmp;
#line 2262
  memset((void *)current_buf, 0, sizeof(*current_buf));
#line 2264
  current_file = file_lookup(name);
#line 2265
  current_file->lineno = 1;
#line 2266
  current_file->flags = 1;
  }
#line 2267
  return;
}
}
#line 2269 "scripts/kconfig/lex.zconf.c"
void zconf_nextfile(char const   *name ) 
{ 
  struct file *file ;
  struct file *tmp ;
  struct buffer *buf ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  YY_BUFFER_STATE tmp___3 ;

  {
  {
#line 2271
  tmp = file_lookup(name);
#line 2271
  file = tmp;
#line 2272
  tmp___0 = malloc(sizeof(*buf));
#line 2272
  buf = (struct buffer *)tmp___0;
#line 2273
  memset((void *)buf, 0, sizeof(*buf));
  }
#line 2275
  if (yy_buffer_stack) {
#line 2275
    current_buf->state = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2275
    current_buf->state = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2276
  zconfin = zconf_fopen(name);
  }
#line 2277
  if (! zconfin) {
    {
#line 2278
    tmp___1 = zconf_lineno();
#line 2278
    tmp___2 = zconf_curname();
#line 2278
    printf((char const   */* __restrict  */)"%s:%d: can\'t open file \"%s\"\n", tmp___2,
           tmp___1, name);
#line 2279
    exit(1);
    }
  }
  {
#line 2281
  tmp___3 = zconf_create_buffer(zconfin, 16384);
#line 2281
  zconf_switch_to_buffer(tmp___3);
#line 2282
  buf->parent = current_buf;
#line 2283
  current_buf = buf;
  }
#line 2285
  if (file->flags & 1) {
    {
#line 2286
    printf((char const   */* __restrict  */)"recursive scan (%s)?\n", name);
#line 2287
    exit(1);
    }
  }
#line 2289
  if (file->flags & 2) {
    {
#line 2290
    printf((char const   */* __restrict  */)"file %s already scanned?\n", name);
#line 2291
    exit(1);
    }
  }
#line 2293
  file->flags |= 1;
#line 2294
  file->lineno = 1;
#line 2295
  file->parent = current_file;
#line 2296
  current_file = file;
#line 2297
  return;
}
}
#line 2299 "scripts/kconfig/lex.zconf.c"
static void zconf_endfile(void) 
{ 
  struct buffer *parent ;
  YY_BUFFER_STATE tmp ;

  {
#line 2303
  current_file->flags |= 2;
#line 2304
  current_file->flags &= -2;
#line 2305
  current_file = current_file->parent;
#line 2307
  parent = current_buf->parent;
#line 2308
  if (parent) {
    {
#line 2309
    fclose(zconfin);
    }
#line 2310
    if (yy_buffer_stack) {
#line 2310
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2310
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2310
    zconf_delete_buffer(tmp);
#line 2311
    zconf_switch_to_buffer(parent->state);
    }
  }
  {
#line 2313
  free((void *)current_buf);
#line 2314
  current_buf = parent;
  }
#line 2315
  return;
}
}
#line 2317 "scripts/kconfig/lex.zconf.c"
int zconf_lineno(void) 
{ 


  {
#line 2319
  return (current_pos.lineno);
}
}
#line 2322 "scripts/kconfig/lex.zconf.c"
char *zconf_curname(void) 
{ 
  char const   *tmp ;

  {
#line 2324
  if (current_pos.file) {
#line 2324
    tmp = (char const   *)(current_pos.file)->name;
  } else {
#line 2324
    tmp = "<none>";
  }
#line 2324
  return ((char *)tmp);
}
}
#line 12 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/util.c"
struct file *file_lookup(char const   *name ) 
{ 
  struct file *file ;
  int tmp ;
  void *tmp___0 ;

  {
#line 16
  file = file_list;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! file) {
#line 16
      goto while_break;
    }
    {
#line 17
    tmp = strcmp(name, (char const   *)file->name);
    }
#line 17
    if (! tmp) {
#line 18
      return (file);
    }
#line 16
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 21
  tmp___0 = malloc(sizeof(*file));
#line 21
  file = (struct file *)tmp___0;
#line 22
  memset((void *)file, 0, sizeof(*file));
#line 23
  file->name = strdup(name);
#line 24
  file->next = file_list;
#line 25
  file_list = file;
  }
#line 26
  return (file);
}
}
#line 30 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/util.c"
int file_write_dep(char const   *name ) 
{ 
  struct file *file ;
  FILE *out ;

  {
#line 35
  if (! name) {
#line 36
    name = ".kconfig.d";
  }
  {
#line 37
  out = fopen((char const   */* __restrict  */)"..config.tmp", (char const   */* __restrict  */)"w");
  }
#line 38
  if (! out) {
#line 39
    return (1);
  }
  {
#line 40
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"deps_config := \\\n");
#line 41
  file = file_list;
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! file) {
#line 41
      goto while_break;
    }
#line 42
    if (file->next) {
      {
#line 43
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%s \\\n",
              file->name);
      }
    } else {
      {
#line 45
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%s\n",
              file->name);
      }
    }
#line 41
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n.config include/autoconf.h: $(deps_config)\n\ninclude/autoconf.h: .config\n\n$(deps_config):\n");
#line 54
  fclose(out);
#line 55
  rename("..config.tmp", name);
  }
#line 56
  return (0);
}
}
#line 61 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/util.c"
struct gstr str_new(void) 
{ 
  struct gstr gs ;
  void *tmp ;

  {
  {
#line 64
  tmp = malloc(sizeof(char ) * 64UL);
#line 64
  gs.s = (char *)tmp;
#line 65
  gs.len = (size_t )16;
#line 66
  strcpy((char */* __restrict  */)gs.s, (char const   */* __restrict  */)"\000");
  }
#line 67
  return (gs);
}
}
#line 71 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/util.c"
struct gstr str_assign(char const   *s ) 
{ 
  struct gstr gs ;
  size_t tmp ;

  {
  {
#line 74
  gs.s = strdup(s);
#line 75
  tmp = strlen(s);
#line 75
  gs.len = tmp + 1UL;
  }
#line 76
  return (gs);
}
}
#line 80 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/util.c"
void str_free(struct gstr *gs ) 
{ 


  {
#line 82
  if (gs->s) {
    {
#line 83
    free((void *)gs->s);
    }
  }
#line 84
  gs->s = (char *)((void *)0);
#line 85
  gs->len = (size_t )0;
#line 86
  return;
}
}
#line 89 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/util.c"
void str_append(struct gstr *gs , char const   *s ) 
{ 
  size_t l ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 91
  tmp = strlen((char const   *)gs->s);
#line 91
  tmp___0 = strlen(s);
#line 91
  l = (tmp + tmp___0) + 1UL;
  }
#line 92
  if (l > gs->len) {
    {
#line 93
    tmp___1 = realloc((void *)gs->s, l);
#line 93
    gs->s = (char *)tmp___1;
#line 94
    gs->len = l;
    }
  }
  {
#line 96
  strcat((char */* __restrict  */)gs->s, (char const   */* __restrict  */)s);
  }
#line 97
  return;
}
}
#line 100 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/util.c"
void str_printf(struct gstr *gs , char const   *fmt  , ...) 
{ 
  va_list ap ;
  char s[10000] ;

  {
  {
#line 104
  __builtin_va_start(ap, fmt);
#line 105
  vsnprintf((char */* __restrict  */)(s), sizeof(s), (char const   */* __restrict  */)fmt,
            ap);
#line 106
  str_append(gs, (char const   *)(s));
#line 107
  __builtin_va_end(ap);
  }
#line 108
  return;
}
}
#line 111 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/util.c"
char const   *str_get(struct gstr *gs ) 
{ 


  {
#line 113
  return ((char const   *)gs->s);
}
}
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 17 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_warning)(char const   *fmt  , ...) ;
#line 20 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
static char const   *conf_filename  ;
#line 21 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
static int conf_lineno  ;
#line 21 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
static int conf_warnings  ;
#line 21 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
static int conf_unsaved  ;
#line 23 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
char const   conf_def_filename[8]  = 
#line 23
  {      (char const   )'.',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'f',      (char const   )'i',      (char const   )'g',      (char const   )'\000'};
#line 25 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
char const   conf_defname[10]  = 
#line 25
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'n',      (char const   )'u',      (char const   )'l', 
        (char const   )'l',      (char const   )'\000'};
#line 27 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
char const   *conf_confnames[3]  = {      conf_def_filename,      conf_defname,      (char const   *)((void *)0)};
#line 33 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_warning)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 36
  __builtin_va_start(ap, fmt);
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          conf_filename, conf_lineno);
#line 38
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 40
  __builtin_va_end(ap);
#line 41
  conf_warnings ++;
  }
#line 42
  return;
}
}
#line 48 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
static char res_value[256]  ;
#line 44 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
static char *conf_expand_value(char const   *in ) 
{ 
  struct symbol *sym ;
  char const   *src ;
  char *dst ;
  char name[256] ;
  char *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 51
  res_value[0] = (char)0;
#line 52
  dst = name;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 53
    tmp___3 = strchr(in, '$');
#line 53
    src = (char const   *)tmp___3;
    }
#line 53
    if (! src) {
#line 53
      goto while_break;
    }
    {
#line 54
    strncat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)in,
            (size_t )(src - in));
#line 55
    src ++;
#line 56
    dst = name;
    }
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 57
      tmp___1 = __ctype_b_loc();
      }
#line 57
      if (! ((int const   )*(*tmp___1 + (int )*src) & 8)) {
#line 57
        if (! ((int const   )*src == 95)) {
#line 57
          goto while_break___0;
        }
      }
#line 58
      tmp = dst;
#line 58
      dst ++;
#line 58
      tmp___0 = src;
#line 58
      src ++;
#line 58
      *tmp = (char )*tmp___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 59
    *dst = (char)0;
#line 60
    sym = sym_lookup((char const   *)(name), 0);
#line 61
    sym_calc_value(sym);
#line 62
    tmp___2 = sym_get_string_value(sym);
#line 62
    strcat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)tmp___2);
#line 63
    in = src;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  strcat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)in);
  }
#line 67
  return (res_value);
}
}
#line 73 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
static char *fullname  =    (char *)((void *)0);
#line 70 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
char *conf_get_default_confname(void) 
{ 
  struct stat buf ;
  char *env ;
  char *name ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 76
  name = conf_expand_value(conf_defname);
#line 77
  env = getenv("srctree");
  }
#line 78
  if (env) {
    {
#line 79
    tmp = strlen((char const   *)env);
#line 79
    tmp___0 = strlen((char const   *)name);
#line 79
    tmp___1 = realloc((void *)fullname, (tmp + tmp___0) + 2UL);
#line 79
    fullname = (char *)tmp___1;
#line 80
    sprintf((char */* __restrict  */)fullname, (char const   */* __restrict  */)"%s/%s",
            env, name);
#line 81
    tmp___2 = stat((char const   */* __restrict  */)fullname, (struct stat */* __restrict  */)(& buf));
    }
#line 81
    if (! tmp___2) {
#line 82
      return (fullname);
    }
  }
#line 84
  return (name);
}
}
#line 87 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
int conf_read_simple(char const   *name ) 
{ 
  FILE *in ;
  char line___0[1024] ;
  char *p ;
  char *p2 ;
  struct symbol *sym ;
  int i ;
  char const   **names ;
  char *tmp ;
  char *tmp___0 ;
  char const   **tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  _Bool tmp___11 ;
  struct symbol *cs ;
  struct property *tmp___12 ;
  struct symbol *tmp___13 ;
  _Bool tmp___14 ;
  char *tmp___15 ;

  {
#line 89
  in = (FILE *)((void *)0);
#line 95
  if (name) {
    {
#line 96
    in = zconf_fopen(name);
    }
  } else {
#line 98
    names = conf_confnames;
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;
#line 99
      tmp___1 = names;
#line 99
      names ++;
#line 99
      name = *tmp___1;
#line 99
      if (! name) {
#line 99
        goto while_break;
      }
      {
#line 100
      tmp = conf_expand_value(name);
#line 100
      name = (char const   *)tmp;
#line 101
      in = zconf_fopen(name);
      }
#line 102
      if (in) {
        {
#line 103
        tmp___0 = gettext("#\n# using defaults found in %s\n#\n");
#line 103
        printf((char const   */* __restrict  */)tmp___0, name);
        }
#line 106
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 110
  if (! in) {
#line 111
    return (1);
  }
#line 113
  conf_filename = name;
#line 114
  conf_lineno = 0;
#line 115
  conf_warnings = 0;
#line 116
  conf_unsaved = 0;
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! (i < 257)) {
#line 118
      goto while_break___0;
    }
#line 118
    sym = symbol_hash[i];
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! sym) {
#line 118
        goto while_break___1;
      }
#line 118
      if ((unsigned int )sym->type != 6U) {
        {
#line 119
        sym->flags |= 3072;
#line 120
        tmp___2 = sym_is_choice(sym);
        }
#line 120
        if (tmp___2) {
#line 121
          sym->flags &= -2049;
        }
#line 122
        sym->flags &= -129;
        {
#line 126
        if ((unsigned int )sym->type == 5U) {
#line 126
          goto case_5;
        }
#line 126
        if ((unsigned int )sym->type == 4U) {
#line 126
          goto case_5;
        }
#line 126
        if ((unsigned int )sym->type == 3U) {
#line 126
          goto case_5;
        }
#line 129
        goto switch_default;
        case_5: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
#line 127
        if (sym->user.val) {
          {
#line 128
          free(sym->user.val);
          }
        }
        switch_default: /* CIL Label */ 
#line 130
        sym->user.val = (void *)0;
#line 131
        sym->user.tri = (tristate )0;
        switch_break: /* CIL Label */ ;
        }
      }
#line 118
      sym = sym->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 118
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 135
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 135
    tmp___15 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                     (FILE */* __restrict  */)in);
    }
#line 135
    if (! tmp___15) {
#line 135
      goto while_break___2;
    }
#line 136
    conf_lineno ++;
#line 137
    sym = (struct symbol *)((void *)0);
    {
#line 139
    if ((int )line___0[0] == 35) {
#line 139
      goto case_35;
    }
#line 166
    if ((int )line___0[0] == 67) {
#line 166
      goto case_67;
    }
#line 235
    if ((int )line___0[0] == 10) {
#line 235
      goto case_10;
    }
#line 237
    goto switch_default___2;
    case_35: /* CIL Label */ 
    {
#line 140
    tmp___3 = memcmp((void const   *)(line___0 + 2), (void const   *)"CONFIG_", (size_t )7);
    }
#line 140
    if (tmp___3) {
#line 141
      goto while_continue___2;
    }
    {
#line 142
    p = strchr((char const   *)(line___0 + 9), ' ');
    }
#line 143
    if (! p) {
#line 144
      goto while_continue___2;
    }
    {
#line 145
    tmp___4 = p;
#line 145
    p ++;
#line 145
    *tmp___4 = (char)0;
#line 146
    tmp___5 = strncmp((char const   *)p, "is not set", (size_t )10);
    }
#line 146
    if (tmp___5) {
#line 147
      goto while_continue___2;
    }
    {
#line 148
    sym = sym_find((char const   *)(line___0 + 9));
    }
#line 149
    if (! sym) {
      {
#line 150
      conf_warning("trying to assign nonexistent symbol %s", line___0 + 9);
      }
#line 151
      goto switch_break___0;
    } else
#line 152
    if (! (sym->flags & 2048)) {
      {
#line 153
      conf_warning("trying to reassign symbol %s", sym->name);
      }
#line 154
      goto switch_break___0;
    }
    {
#line 158
    if ((unsigned int )sym->type == 2U) {
#line 158
      goto case_2;
    }
#line 158
    if ((unsigned int )sym->type == 1U) {
#line 158
      goto case_2;
    }
#line 162
    goto switch_default___0;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 159
    sym->user.tri = (tristate )0;
#line 160
    sym->flags &= -2049;
#line 161
    goto switch_break___1;
    switch_default___0: /* CIL Label */ ;
    switch_break___1: /* CIL Label */ ;
    }
#line 165
    goto switch_break___0;
    case_67: /* CIL Label */ 
    {
#line 167
    tmp___6 = memcmp((void const   *)(line___0), (void const   *)"CONFIG_", (size_t )7);
    }
#line 167
    if (tmp___6) {
      {
#line 168
      conf_warning("unexpected data");
      }
#line 169
      goto while_continue___2;
    }
    {
#line 171
    p = strchr((char const   *)(line___0 + 7), '=');
    }
#line 172
    if (! p) {
#line 173
      goto while_continue___2;
    }
    {
#line 174
    tmp___7 = p;
#line 174
    p ++;
#line 174
    *tmp___7 = (char)0;
#line 175
    p2 = strchr((char const   *)p, '\n');
    }
#line 176
    if (p2) {
#line 177
      *p2 = (char)0;
    }
    {
#line 178
    sym = sym_find((char const   *)(line___0 + 7));
    }
#line 179
    if (! sym) {
      {
#line 180
      conf_warning("trying to assign nonexistent symbol %s", line___0 + 7);
      }
#line 181
      goto switch_break___0;
    } else
#line 182
    if (! (sym->flags & 2048)) {
      {
#line 183
      conf_warning("trying to reassign symbol %s", sym->name);
      }
#line 184
      goto switch_break___0;
    }
    {
#line 187
    if ((unsigned int )sym->type == 2U) {
#line 187
      goto case_2___0;
    }
#line 193
    if ((unsigned int )sym->type == 1U) {
#line 193
      goto case_1___0;
    }
#line 206
    if ((unsigned int )sym->type == 5U) {
#line 206
      goto case_5___0;
    }
#line 221
    if ((unsigned int )sym->type == 4U) {
#line 221
      goto case_4___0;
    }
#line 221
    if ((unsigned int )sym->type == 3U) {
#line 221
      goto case_4___0;
    }
#line 231
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 188
    if ((int )*(p + 0) == 109) {
#line 189
      sym->user.tri = (tristate )1;
#line 190
      sym->flags &= -2049;
#line 191
      goto switch_break___2;
    }
    case_1___0: /* CIL Label */ 
#line 194
    if ((int )*(p + 0) == 121) {
#line 195
      sym->user.tri = (tristate )2;
#line 196
      sym->flags &= -2049;
#line 197
      goto switch_break___2;
    }
#line 199
    if ((int )*(p + 0) == 110) {
#line 200
      sym->user.tri = (tristate )0;
#line 201
      sym->flags &= -2049;
#line 202
      goto switch_break___2;
    }
    {
#line 204
    conf_warning("symbol value \'%s\' invalid for %s", p, sym->name);
    }
#line 205
    goto switch_break___2;
    case_5___0: /* CIL Label */ 
#line 207
    tmp___8 = p;
#line 207
    p ++;
#line 207
    if ((int )*tmp___8 != 34) {
#line 208
      goto switch_break___2;
    }
#line 209
    p2 = p;
    {
#line 209
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 209
      p2 = strpbrk((char const   *)p2, "\"\\");
      }
#line 209
      if (! p2) {
#line 209
        goto while_break___3;
      }
#line 210
      if ((int )*p2 == 34) {
#line 211
        *p2 = (char)0;
#line 212
        goto while_break___3;
      }
      {
#line 214
      tmp___9 = strlen((char const   *)p2);
#line 214
      memmove((void *)p2, (void const   *)(p2 + 1), tmp___9);
#line 209
      p2 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 216
    if (! p2) {
      {
#line 217
      conf_warning("invalid string found");
      }
#line 218
      goto while_continue___2;
    }
    case_4___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    {
#line 222
    tmp___11 = sym_string_valid(sym, (char const   *)p);
    }
#line 222
    if (tmp___11) {
      {
#line 223
      tmp___10 = strdup((char const   *)p);
#line 223
      sym->user.val = (void *)tmp___10;
#line 224
      sym->flags &= -2049;
      }
    } else {
#line 226
      if (*(p + 0)) {
        {
#line 227
        conf_warning("symbol value \'%s\' invalid for %s", p, sym->name);
        }
      }
#line 228
      goto while_continue___2;
    }
#line 230
    goto switch_break___2;
    switch_default___1: /* CIL Label */ ;
    switch_break___2: /* CIL Label */ ;
    }
#line 234
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 236
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
    {
#line 238
    conf_warning("unexpected data");
    }
#line 239
    goto while_continue___2;
    switch_break___0: /* CIL Label */ ;
    }
#line 241
    if (sym) {
      {
#line 241
      tmp___14 = sym_is_choice_value(sym);
      }
#line 241
      if (tmp___14) {
        {
#line 242
        tmp___12 = sym_get_choice_prop(sym);
#line 242
        tmp___13 = prop_get_symbol(tmp___12);
#line 242
        cs = tmp___13;
        }
        {
#line 244
        if ((unsigned int )sym->user.tri == 0U) {
#line 244
          goto case_0;
        }
#line 246
        if ((unsigned int )sym->user.tri == 1U) {
#line 246
          goto case_1___1;
        }
#line 252
        if ((unsigned int )sym->user.tri == 2U) {
#line 252
          goto case_2___1;
        }
#line 243
        goto switch_break___3;
        case_0: /* CIL Label */ 
#line 245
        goto switch_break___3;
        case_1___1: /* CIL Label */ 
#line 247
        if ((unsigned int )cs->user.tri == 2U) {
          {
#line 248
          conf_warning("%s creates inconsistent choice state", sym->name);
#line 249
          cs->flags |= 2048;
          }
        }
#line 251
        goto switch_break___3;
        case_2___1: /* CIL Label */ 
#line 253
        if ((unsigned int )cs->user.tri != 0U) {
          {
#line 254
          conf_warning("%s creates inconsistent choice state", sym->name);
#line 255
          cs->flags |= 2048;
          }
        } else {
#line 257
          cs->user.val = (void *)sym;
        }
#line 258
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
#line 260
        if ((unsigned int )cs->user.tri > (unsigned int )sym->user.tri) {
#line 260
          cs->user.tri = cs->user.tri;
        } else {
#line 260
          cs->user.tri = sym->user.tri;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 263
  fclose(in);
  }
#line 265
  if (modules_sym) {
    {
#line 266
    sym_calc_value(modules_sym);
    }
  }
#line 267
  return (0);
}
}
#line 270 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
int conf_read(char const   *name ) 
{ 
  struct symbol *sym ;
  struct property *prop ;
  struct expr *e ;
  int i ;
  int tmp ;
  _Bool tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;

  {
  {
#line 277
  tmp = conf_read_simple(name);
  }
#line 277
  if (tmp) {
#line 278
    return (1);
  }
#line 280
  i = 0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i < 257)) {
#line 280
      goto while_break;
    }
#line 280
    sym = symbol_hash[i];
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 280
      if (! sym) {
#line 280
        goto while_break___0;
      }
#line 280
      if ((unsigned int )sym->type != 6U) {
        {
#line 281
        sym_calc_value(sym);
#line 282
        tmp___0 = sym_is_choice(sym);
        }
#line 282
        if (tmp___0) {
#line 283
          goto sym_ok;
        } else
#line 282
        if (sym->flags & 4096) {
#line 283
          goto sym_ok;
        }
        {
#line 284
        tmp___5 = sym_has_value(sym);
        }
#line 284
        if (tmp___5) {
#line 284
          if (sym->flags & 512) {
            {
#line 288
            if ((unsigned int )sym->type == 2U) {
#line 288
              goto case_2;
            }
#line 288
            if ((unsigned int )sym->type == 1U) {
#line 288
              goto case_2;
            }
#line 293
            goto switch_default;
            case_2: /* CIL Label */ 
            case_1: /* CIL Label */ 
            {
#line 289
            tmp___1 = sym_get_tristate_value(sym);
            }
#line 289
            if ((unsigned int )sym->user.tri != (unsigned int )tmp___1) {
#line 290
              goto switch_break;
            }
            {
#line 291
            tmp___2 = sym_is_choice(sym);
            }
#line 291
            if (! tmp___2) {
#line 292
              goto sym_ok;
            }
            switch_default: /* CIL Label */ 
            {
#line 294
            tmp___3 = strcmp((char const   *)sym->curr.val, (char const   *)sym->user.val);
            }
#line 294
            if (! tmp___3) {
#line 295
              goto sym_ok;
            }
#line 296
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          } else {
#line 284
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 298
          tmp___4 = sym_has_value(sym);
          }
#line 298
          if (! tmp___4) {
#line 298
            if (! (sym->flags & 512)) {
#line 300
              goto sym_ok;
            }
          }
        }
#line 301
        conf_unsaved ++;
        sym_ok: 
        {
#line 304
        tmp___7 = sym_has_value(sym);
        }
#line 304
        if (tmp___7) {
          {
#line 304
          tmp___8 = sym_is_choice_value(sym);
          }
#line 304
          if (! tmp___8) {
#line 305
            if ((unsigned int )sym->visible == 0U) {
#line 306
              sym->flags |= 2048;
            }
            {
#line 310
            if ((unsigned int )sym->type == 4U) {
#line 310
              goto case_4;
            }
#line 310
            if ((unsigned int )sym->type == 3U) {
#line 310
              goto case_4;
            }
#line 310
            if ((unsigned int )sym->type == 5U) {
#line 310
              goto case_4;
            }
#line 315
            goto switch_default___0;
            case_4: /* CIL Label */ 
            case_3: /* CIL Label */ 
            case_5: /* CIL Label */ 
            {
#line 311
            tmp___6 = sym_string_within_range(sym, (char const   *)sym->user.val);
            }
#line 311
            if (! tmp___6) {
#line 312
              sym->flags |= 2048;
#line 313
              sym->flags &= -129;
            }
            switch_default___0: /* CIL Label */ 
#line 316
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        }
        {
#line 319
        tmp___9 = sym_is_choice(sym);
        }
#line 319
        if (! tmp___9) {
#line 320
          goto __Cont;
        }
        {
#line 321
        prop = sym_get_choice_prop(sym);
#line 322
        e = prop->expr;
        }
        {
#line 322
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 322
          if (! e) {
#line 322
            goto while_break___1;
          }
#line 323
          if ((unsigned int )(e->right.sym)->visible != 0U) {
#line 324
            sym->flags |= (e->right.sym)->flags & 2048;
          }
#line 322
          e = e->left.expr;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ 
#line 280
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  if (conf_warnings) {
#line 327
    tmp___10 = 1;
  } else
#line 327
  if (conf_unsaved) {
#line 327
    tmp___10 = 1;
  } else {
#line 327
    tmp___10 = 0;
  }
#line 327
  sym_change_count = tmp___10;
#line 329
  return (0);
}
}
#line 332 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/confdata.c"
int conf_write(char const   *name ) 
{ 
  FILE *out ;
  FILE *out_h ;
  struct symbol *sym ;
  struct menu *menu ;
  char const   *basename ;
  char dirname[128] ;
  char tmpname[128] ;
  char newname[128] ;
  int type ;
  int l ;
  char const   *str ;
  time_t now ;
  int use_timestamp ;
  char *env ;
  struct stat st ;
  char *slash ;
  int size ;
  int tmp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char buf[sizeof("#define AUTOCONF_TIMESTAMP \"YYYY-MM-DD HH:MM:SS some_timezone\"\n")] ;
  size_t ret ;
  struct tm *tmp___6 ;
  size_t tmp___7 ;
  struct tm *tmp___8 ;
  char const   *tmp___9 ;
  _Bool tmp___10 ;
  tristate tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;

  {
#line 342
  use_timestamp = 1;
#line 345
  dirname[0] = (char)0;
#line 346
  if (name) {
#line 346
    if (*(name + 0)) {
      {
#line 350
      tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
      }
#line 350
      if (tmp) {
        _L: /* CIL Label */ 
        {
#line 354
        slash = strrchr(name, '/');
        }
#line 354
        if (slash) {
          {
#line 355
          size = (int )((slash - (char *)name) + 1L);
#line 356
          memcpy((void */* __restrict  */)(dirname), (void const   */* __restrict  */)name,
                 (size_t )size);
#line 357
          dirname[size] = (char)0;
          }
#line 358
          if (*(slash + 1)) {
#line 359
            basename = (char const   *)(slash + 1);
          } else {
#line 361
            basename = conf_def_filename;
          }
        } else {
#line 363
          basename = name;
        }
      } else
#line 350
      if ((st.st_mode & 61440U) == 16384U) {
        {
#line 351
        strcpy((char */* __restrict  */)(dirname), (char const   */* __restrict  */)name);
#line 352
        strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)"/");
#line 353
        basename = conf_def_filename;
        }
      } else {
#line 350
        goto _L;
      }
    } else {
#line 365
      basename = conf_def_filename;
    }
  } else {
#line 365
    basename = conf_def_filename;
  }
  {
#line 367
  tmp___0 = getpid();
#line 367
  sprintf((char */* __restrict  */)(newname), (char const   */* __restrict  */)"%s.tmpconfig.%d",
          dirname, tmp___0);
#line 368
  out = fopen((char const   */* __restrict  */)(newname), (char const   */* __restrict  */)"w");
  }
#line 369
  if (! out) {
#line 370
    return (1);
  }
#line 371
  out_h = (FILE *)((void *)0);
#line 372
  if (! name) {
    {
#line 373
    out_h = fopen((char const   */* __restrict  */)".tmpconfig.h", (char const   */* __restrict  */)"w");
    }
#line 374
    if (! out_h) {
#line 375
      return (1);
    }
    {
#line 376
    file_write_dep((char const   *)((void *)0));
    }
  }
  {
#line 378
  sym = sym_lookup("KERNELVERSION", 0);
#line 379
  sym_calc_value(sym);
#line 380
  time(& now);
#line 381
  env = getenv("KCONFIG_NOTIMESTAMP");
  }
#line 382
  if (env) {
#line 382
    if (*env) {
#line 383
      use_timestamp = 0;
    }
  }
#line 385
  if (use_timestamp) {
    {
#line 385
    tmp___1 = ctime((time_t const   *)(& now));
#line 385
    tmp___2 = (char const   *)tmp___1;
    }
  } else {
#line 385
    tmp___2 = "";
  }
#line 385
  if (use_timestamp) {
#line 385
    tmp___3 = "# ";
  } else {
#line 385
    tmp___3 = "";
  }
  {
#line 385
  tmp___4 = sym_get_string_value(sym);
#line 385
  tmp___5 = gettext("#\n# Automatically generated make config: don\'t edit\n# Busybox version: %s\n%s%s#\n");
#line 385
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___5,
          tmp___4, tmp___3, tmp___2);
  }
#line 393
  if (out_h) {
#line 396
    buf[0] = (char )'\000';
#line 397
    if (use_timestamp) {
      {
#line 398
      tmp___6 = localtime((time_t const   *)(& now));
#line 398
      tmp___7 = strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"#define AUTOCONF_TIMESTAMP \"%Y-%m-%d %H:%M:%S %Z\"\n",
                         (struct tm  const  */* __restrict  */)tmp___6);
#line 398
      ret = tmp___7;
      }
#line 405
      if (ret == 0UL) {
        {
#line 406
        tmp___8 = localtime((time_t const   *)(& now));
#line 406
        strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"#define AUTOCONF_TIMESTAMP \"%Y-%m-%d %H:%M:%S\"\n",
                 (struct tm  const  */* __restrict  */)tmp___8);
        }
      }
    } else {
      {
#line 409
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"#define AUTOCONF_TIMESTAMP \"\"\n");
      }
    }
    {
#line 411
    tmp___9 = sym_get_string_value(sym);
#line 411
    fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"/*\n * Automatically generated C config: don\'t edit\n * Busybox version: %s\n */\n%s\n",
            tmp___9, buf);
    }
  }
#line 420
  if (! sym_change_count) {
    {
#line 421
    sym_clear_all_valid();
    }
  }
#line 423
  menu = rootmenu.list;
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    if (! menu) {
#line 424
      goto while_break;
    }
#line 425
    sym = menu->sym;
#line 426
    if (! sym) {
      {
#line 427
      tmp___10 = menu_is_visible(menu);
      }
#line 427
      if (! tmp___10) {
#line 428
        goto next;
      }
      {
#line 429
      str = menu_get_prompt(menu);
#line 430
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n#\n# %s\n#\n",
              str);
      }
#line 434
      if (out_h) {
        {
#line 435
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"\n/*\n * %s\n */\n",
                str);
        }
      }
    } else
#line 439
    if (! (sym->flags & 16)) {
      {
#line 440
      sym_calc_value(sym);
#line 445
      sym->flags &= -513;
#line 446
      type = (int )sym->type;
      }
#line 447
      if (type == 2) {
        {
#line 448
        sym_calc_value(modules_sym);
        }
#line 449
        if ((unsigned int )modules_sym->curr.tri == 0U) {
#line 450
          type = 1;
        }
      }
      {
#line 454
      if (type == 2) {
#line 454
        goto case_2;
      }
#line 454
      if (type == 1) {
#line 454
        goto case_2;
      }
#line 483
      if (type == 5) {
#line 483
        goto case_5;
      }
#line 513
      if (type == 4) {
#line 513
        goto case_4;
      }
#line 526
      if (type == 3) {
#line 526
        goto case_3;
      }
#line 452
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      {
#line 455
      tmp___11 = sym_get_tristate_value(sym);
      }
      {
#line 456
      if ((unsigned int )tmp___11 == 0U) {
#line 456
        goto case_0;
      }
#line 466
      if ((unsigned int )tmp___11 == 1U) {
#line 466
        goto case_1___0;
      }
#line 471
      if ((unsigned int )tmp___11 == 2U) {
#line 471
        goto case_2___0;
      }
#line 455
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 457
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"# CONFIG_%s is not set\n",
              sym->name);
      }
#line 458
      if (out_h) {
        {
#line 459
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#undef CONFIG_%s\n",
                sym->name);
#line 461
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define ENABLE_%s 0\n",
                sym->name);
#line 462
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_%s(...)\n",
                sym->name);
#line 463
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_NOT_%s(...) __VA_ARGS__\n",
                sym->name);
        }
      }
#line 465
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 467
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"CONFIG_%s=m\n",
              sym->name);
      }
#line 468
      if (out_h) {
        {
#line 469
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define CONFIG_%s_MODULE 1\n",
                sym->name);
        }
      }
#line 470
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 472
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"CONFIG_%s=y\n",
              sym->name);
      }
#line 473
      if (out_h) {
        {
#line 474
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define CONFIG_%s 1\n",
                sym->name);
#line 476
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define ENABLE_%s 1\n",
                sym->name);
#line 477
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_%s(...) __VA_ARGS__\n",
                sym->name);
#line 478
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_NOT_%s(...)\n",
                sym->name);
        }
      }
#line 480
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 482
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 485
      str = sym_get_string_value(sym);
#line 486
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"CONFIG_%s=\"",
              sym->name);
      }
#line 487
      if (out_h) {
        {
#line 488
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define CONFIG_%s \"",
                sym->name);
        }
      }
      {
#line 489
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 490
        tmp___12 = strcspn(str, "\"\\");
#line 490
        l = (int )tmp___12;
        }
#line 491
        if (l) {
          {
#line 492
          fwrite((void const   */* __restrict  */)str, (size_t )l, (size_t )1, (FILE */* __restrict  */)out);
          }
#line 493
          if (out_h) {
            {
#line 494
            fwrite((void const   */* __restrict  */)str, (size_t )l, (size_t )1, (FILE */* __restrict  */)out_h);
            }
          }
        }
#line 496
        str += l;
        {
#line 497
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 497
          if (! ((int const   )*str == 92)) {
#line 497
            if (! ((int const   )*str == 34)) {
#line 497
              goto while_break___1;
            }
          }
          {
#line 498
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\%c",
                  (int const   )*str);
          }
#line 499
          if (out_h) {
            {
#line 500
            fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"\\%c",
                    (int const   )*str);
            }
          }
#line 501
          str ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 489
        if (! *str) {
#line 489
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 504
      fputs((char const   */* __restrict  */)"\"\n", (FILE */* __restrict  */)out);
      }
#line 505
      if (out_h) {
        {
#line 506
        fputs((char const   */* __restrict  */)"\"\n", (FILE */* __restrict  */)out_h);
#line 508
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define ENABLE_%s 1\n",
                sym->name);
#line 509
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_%s(...) __VA_ARGS__\n",
                sym->name);
#line 510
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_NOT_%s(...)\n",
                sym->name);
        }
      }
#line 512
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 514
      str = sym_get_string_value(sym);
      }
#line 515
      if ((int const   )*(str + 0) != 48) {
#line 515
        goto _L___0;
      } else
#line 515
      if ((int const   )*(str + 1) != 120) {
#line 515
        if ((int const   )*(str + 1) != 88) {
          _L___0: /* CIL Label */ 
          {
#line 516
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"CONFIG_%s=%s\n",
                  sym->name, str);
          }
#line 517
          if (out_h) {
            {
#line 518
            fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define CONFIG_%s 0x%s\n",
                    sym->name, str);
#line 520
            fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define ENABLE_%s 1\n",
                    sym->name);
#line 521
            fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_%s(...) __VA_ARGS__\n",
                    sym->name);
#line 522
            fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_NOT_%s(...)\n",
                    sym->name);
            }
          }
#line 524
          goto switch_break;
        }
      }
      case_3: /* CIL Label */ 
      {
#line 527
      str = sym_get_string_value(sym);
      }
#line 528
      if (! *(str + 0)) {
#line 529
        str = "0";
      }
      {
#line 530
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"CONFIG_%s=%s\n",
              sym->name, str);
      }
#line 531
      if (out_h) {
        {
#line 532
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define CONFIG_%s %s\n",
                sym->name, str);
#line 534
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define ENABLE_%s 1\n",
                sym->name);
#line 535
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_%s(...) __VA_ARGS__\n",
                sym->name);
#line 536
        fprintf((FILE */* __restrict  */)out_h, (char const   */* __restrict  */)"#define IF_NOT_%s(...)\n",
                sym->name);
        }
      }
#line 538
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    next: 
#line 543
    if (menu->list) {
#line 544
      menu = menu->list;
#line 545
      goto while_continue;
    }
#line 547
    if (menu->next) {
#line 548
      menu = menu->next;
    } else {
      {
#line 549
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 549
        menu = menu->parent;
#line 549
        if (! menu) {
#line 549
          goto while_break___2;
        }
#line 550
        if (menu->next) {
#line 551
          menu = menu->next;
#line 552
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 556
  fclose(out);
  }
#line 557
  if (out_h) {
    {
#line 558
    fclose(out_h);
#line 559
    rename(".tmpconfig.h", "include/autoconf.h");
    }
  }
#line 561
  if (! name) {
#line 561
    goto _L___1;
  } else
#line 561
  if ((unsigned long )basename != (unsigned long )(conf_def_filename)) {
    _L___1: /* CIL Label */ 
#line 562
    if (! name) {
#line 563
      name = conf_def_filename;
    }
    {
#line 564
    sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.old",
            name);
#line 565
    rename(name, (char const   *)(tmpname));
    }
  }
  {
#line 567
  sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s%s",
          dirname, basename);
#line 568
  tmp___13 = rename((char const   *)(newname), (char const   *)(tmpname));
  }
#line 568
  if (tmp___13) {
#line 569
    return (1);
  }
#line 571
  sym_change_count = 0;
#line 573
  return (0);
}
}
#line 15 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_symbol(struct symbol *sym ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 17
  tmp = malloc(sizeof(*e));
#line 17
  e = (struct expr *)tmp;
#line 18
  memset((void *)e, 0, sizeof(*e));
#line 19
  e->type = (enum expr_type )7;
#line 20
  e->left.sym = sym;
  }
#line 21
  return (e);
}
}
#line 24 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_one(enum expr_type type , struct expr *ce ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 26
  tmp = malloc(sizeof(*e));
#line 26
  e = (struct expr *)tmp;
#line 27
  memset((void *)e, 0, sizeof(*e));
#line 28
  e->type = type;
#line 29
  e->left.expr = ce;
  }
#line 30
  return (e);
}
}
#line 33 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_two(enum expr_type type , struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 35
  tmp = malloc(sizeof(*e));
#line 35
  e = (struct expr *)tmp;
#line 36
  memset((void *)e, 0, sizeof(*e));
#line 37
  e->type = type;
#line 38
  e->left.expr = e1;
#line 39
  e->right.expr = e2;
  }
#line 40
  return (e);
}
}
#line 43 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_comp(enum expr_type type , struct symbol *s1 , struct symbol *s2 ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 45
  tmp = malloc(sizeof(*e));
#line 45
  e = (struct expr *)tmp;
#line 46
  memset((void *)e, 0, sizeof(*e));
#line 47
  e->type = type;
#line 48
  e->left.sym = s1;
#line 49
  e->right.sym = s2;
  }
#line 50
  return (e);
}
}
#line 53 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_and(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 55
  if (! e1) {
#line 56
    return (e2);
  }
#line 57
  if (e2) {
    {
#line 57
    tmp = expr_alloc_two((enum expr_type )2, e1, e2);
#line 57
    tmp___0 = tmp;
    }
  } else {
#line 57
    tmp___0 = e1;
  }
#line 57
  return (tmp___0);
}
}
#line 60 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_or(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 62
  if (! e1) {
#line 63
    return (e2);
  }
#line 64
  if (e2) {
    {
#line 64
    tmp = expr_alloc_two((enum expr_type )1, e1, e2);
#line 64
    tmp___0 = tmp;
    }
  } else {
#line 64
    tmp___0 = e1;
  }
#line 64
  return (tmp___0);
}
}
#line 67 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_copy(struct expr *org ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
#line 71
  if (! org) {
#line 72
    return ((struct expr *)((void *)0));
  }
  {
#line 74
  tmp = malloc(sizeof(*org));
#line 74
  e = (struct expr *)tmp;
#line 75
  memcpy((void */* __restrict  */)e, (void const   */* __restrict  */)org, sizeof(*org));
  }
  {
#line 77
  if ((unsigned int )org->type == 7U) {
#line 77
    goto case_7;
  }
#line 80
  if ((unsigned int )org->type == 3U) {
#line 80
    goto case_3;
  }
#line 84
  if ((unsigned int )org->type == 5U) {
#line 84
    goto case_5;
  }
#line 84
  if ((unsigned int )org->type == 4U) {
#line 84
    goto case_5;
  }
#line 90
  if ((unsigned int )org->type == 6U) {
#line 90
    goto case_6;
  }
#line 90
  if ((unsigned int )org->type == 1U) {
#line 90
    goto case_6;
  }
#line 90
  if ((unsigned int )org->type == 2U) {
#line 90
    goto case_6;
  }
#line 94
  goto switch_default;
  case_7: /* CIL Label */ 
#line 78
  e->left = org->left;
#line 79
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 81
  e->left.expr = expr_copy(org->left.expr);
  }
#line 82
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 85
  e->left.sym = org->left.sym;
#line 86
  e->right.sym = org->right.sym;
#line 87
  goto switch_break;
  case_6: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 91
  e->left.expr = expr_copy(org->left.expr);
#line 92
  e->right.expr = expr_copy(org->right.expr);
  }
#line 93
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 95
  printf((char const   */* __restrict  */)"can\'t copy type %d\n", (unsigned int )e->type);
#line 96
  free((void *)e);
#line 97
  e = (struct expr *)((void *)0);
  }
#line 98
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 101
  return (e);
}
}
#line 104 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
void expr_free(struct expr *e ) 
{ 


  {
#line 106
  if (! e) {
#line 107
    return;
  }
  {
#line 110
  if ((unsigned int )e->type == 7U) {
#line 110
    goto case_7;
  }
#line 112
  if ((unsigned int )e->type == 3U) {
#line 112
    goto case_3;
  }
#line 116
  if ((unsigned int )e->type == 5U) {
#line 116
    goto case_5;
  }
#line 116
  if ((unsigned int )e->type == 4U) {
#line 116
    goto case_5;
  }
#line 119
  if ((unsigned int )e->type == 2U) {
#line 119
    goto case_2;
  }
#line 119
  if ((unsigned int )e->type == 1U) {
#line 119
    goto case_2;
  }
#line 123
  goto switch_default;
  case_7: /* CIL Label */ 
#line 111
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 113
  expr_free(e->left.expr);
  }
#line 114
  return;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 117
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 120
  expr_free(e->left.expr);
#line 121
  expr_free(e->right.expr);
  }
#line 122
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 124
  printf((char const   */* __restrict  */)"how to free type %d?\n", (unsigned int )e->type);
  }
#line 125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 127
  free((void *)e);
  }
#line 128
  return;
}
}
#line 130 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
static int trans_count  ;
#line 135 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
static void __expr_eliminate_eq(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  int tmp ;

  {
#line 137
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 138
    __expr_eliminate_eq(type, & (*ep1)->left.expr, ep2);
#line 139
    __expr_eliminate_eq(type, & (*ep1)->right.expr, ep2);
    }
#line 140
    return;
  }
#line 142
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 143
    __expr_eliminate_eq(type, ep1, & (*ep2)->left.expr);
#line 144
    __expr_eliminate_eq(type, ep1, & (*ep2)->right.expr);
    }
#line 145
    return;
  }
#line 147
  if ((unsigned int )(*ep1)->type == 7U) {
#line 147
    if ((unsigned int )(*ep2)->type == 7U) {
#line 147
      if ((unsigned long )(*ep1)->left.sym == (unsigned long )(*ep2)->left.sym) {
#line 147
        if (((*ep1)->left.sym)->flags & 5) {
#line 149
          return;
        }
      }
    }
  }
  {
#line 150
  tmp = expr_eq(*ep1, *ep2);
  }
#line 150
  if (! tmp) {
#line 151
    return;
  }
  {
#line 152
  trans_count ++;
#line 153
  expr_free(*ep1);
#line 153
  expr_free(*ep2);
  }
  {
#line 155
  if ((unsigned int )type == 1U) {
#line 155
    goto case_1;
  }
#line 159
  if ((unsigned int )type == 2U) {
#line 159
    goto case_2;
  }
#line 163
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 156
  *ep1 = expr_alloc_symbol(& symbol_no);
#line 157
  *ep2 = expr_alloc_symbol(& symbol_no);
  }
#line 158
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 160
  *ep1 = expr_alloc_symbol(& symbol_yes);
#line 161
  *ep2 = expr_alloc_symbol(& symbol_yes);
  }
#line 162
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 168 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
void expr_eliminate_eq(struct expr **ep1 , struct expr **ep2 ) 
{ 


  {
#line 170
  if (! *ep1) {
#line 171
    return;
  } else
#line 170
  if (! *ep2) {
#line 171
    return;
  }
  {
#line 174
  if ((unsigned int )(*ep1)->type == 2U) {
#line 174
    goto case_2;
  }
#line 174
  if ((unsigned int )(*ep1)->type == 1U) {
#line 174
    goto case_2;
  }
#line 176
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 175
  __expr_eliminate_eq((*ep1)->type, ep1, ep2);
  }
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 179
  if ((unsigned int )(*ep1)->type != (unsigned int )(*ep2)->type) {
    {
#line 181
    if ((unsigned int )(*ep2)->type == 2U) {
#line 181
      goto case_2___0;
    }
#line 181
    if ((unsigned int )(*ep2)->type == 1U) {
#line 181
      goto case_2___0;
    }
#line 183
    goto switch_default___0;
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    {
#line 182
    __expr_eliminate_eq((*ep2)->type, ep1, ep2);
    }
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 186
  *ep1 = expr_eliminate_yn(*ep1);
#line 187
  *ep2 = expr_eliminate_yn(*ep2);
  }
#line 188
  return;
}
}
#line 193 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
int expr_eq(struct expr *e1 , struct expr *e2 ) 
{ 
  int res ;
  int old_count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 197
  if ((unsigned int )e1->type != (unsigned int )e2->type) {
#line 198
    return (0);
  }
  {
#line 201
  if ((unsigned int )e1->type == 5U) {
#line 201
    goto case_5;
  }
#line 201
  if ((unsigned int )e1->type == 4U) {
#line 201
    goto case_5;
  }
#line 203
  if ((unsigned int )e1->type == 7U) {
#line 203
    goto case_7;
  }
#line 205
  if ((unsigned int )e1->type == 3U) {
#line 205
    goto case_3;
  }
#line 208
  if ((unsigned int )e1->type == 1U) {
#line 208
    goto case_1;
  }
#line 208
  if ((unsigned int )e1->type == 2U) {
#line 208
    goto case_1;
  }
#line 221
  if ((unsigned int )e1->type == 0U) {
#line 221
    goto case_0;
  }
#line 221
  if ((unsigned int )e1->type == 8U) {
#line 221
    goto case_0;
  }
#line 221
  if ((unsigned int )e1->type == 6U) {
#line 221
    goto case_0;
  }
#line 199
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 202
  if ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym) {
#line 202
    if ((unsigned long )e1->right.sym == (unsigned long )e2->right.sym) {
#line 202
      tmp = 1;
    } else {
#line 202
      tmp = 0;
    }
  } else {
#line 202
    tmp = 0;
  }
#line 202
  return (tmp);
  case_7: /* CIL Label */ 
#line 204
  return ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym);
  case_3: /* CIL Label */ 
  {
#line 206
  tmp___0 = expr_eq(e1->left.expr, e2->left.expr);
  }
#line 206
  return (tmp___0);
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 209
  e1 = expr_copy(e1);
#line 210
  e2 = expr_copy(e2);
#line 211
  old_count = trans_count;
#line 212
  expr_eliminate_eq(& e1, & e2);
  }
#line 213
  if ((unsigned int )e1->type == 7U) {
#line 213
    if ((unsigned int )e2->type == 7U) {
#line 213
      if ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym) {
#line 213
        tmp___1 = 1;
      } else {
#line 213
        tmp___1 = 0;
      }
    } else {
#line 213
      tmp___1 = 0;
    }
  } else {
#line 213
    tmp___1 = 0;
  }
  {
#line 213
  res = tmp___1;
#line 215
  expr_free(e1);
#line 216
  expr_free(e2);
#line 217
  trans_count = old_count;
  }
#line 218
  return (res);
  case_0: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 232
  return (0);
}
}
#line 235 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_eliminate_yn(struct expr *e ) 
{ 
  struct expr *tmp ;

  {
#line 239
  if (e) {
    {
#line 240
    if ((unsigned int )e->type == 2U) {
#line 240
      goto case_2;
    }
#line 276
    if ((unsigned int )e->type == 1U) {
#line 276
      goto case_1;
    }
#line 312
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 241
    e->left.expr = expr_eliminate_yn(e->left.expr);
#line 242
    e->right.expr = expr_eliminate_yn(e->right.expr);
    }
#line 243
    if ((unsigned int )(e->left.expr)->type == 7U) {
#line 244
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 245
        expr_free(e->left.expr);
#line 246
        expr_free(e->right.expr);
#line 247
        e->type = (enum expr_type )7;
#line 248
        e->left.sym = & symbol_no;
#line 249
        e->right.expr = (struct expr *)((void *)0);
        }
#line 250
        return (e);
      } else
#line 251
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 252
        free((void *)e->left.expr);
#line 253
        tmp = e->right.expr;
#line 254
        *e = *(e->right.expr);
#line 255
        free((void *)tmp);
        }
#line 256
        return (e);
      }
    }
#line 259
    if ((unsigned int )(e->right.expr)->type == 7U) {
#line 260
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 261
        expr_free(e->left.expr);
#line 262
        expr_free(e->right.expr);
#line 263
        e->type = (enum expr_type )7;
#line 264
        e->left.sym = & symbol_no;
#line 265
        e->right.expr = (struct expr *)((void *)0);
        }
#line 266
        return (e);
      } else
#line 267
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 268
        free((void *)e->right.expr);
#line 269
        tmp = e->left.expr;
#line 270
        *e = *(e->left.expr);
#line 271
        free((void *)tmp);
        }
#line 272
        return (e);
      }
    }
#line 275
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 277
    e->left.expr = expr_eliminate_yn(e->left.expr);
#line 278
    e->right.expr = expr_eliminate_yn(e->right.expr);
    }
#line 279
    if ((unsigned int )(e->left.expr)->type == 7U) {
#line 280
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 281
        free((void *)e->left.expr);
#line 282
        tmp = e->right.expr;
#line 283
        *e = *(e->right.expr);
#line 284
        free((void *)tmp);
        }
#line 285
        return (e);
      } else
#line 286
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 287
        expr_free(e->left.expr);
#line 288
        expr_free(e->right.expr);
#line 289
        e->type = (enum expr_type )7;
#line 290
        e->left.sym = & symbol_yes;
#line 291
        e->right.expr = (struct expr *)((void *)0);
        }
#line 292
        return (e);
      }
    }
#line 295
    if ((unsigned int )(e->right.expr)->type == 7U) {
#line 296
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 297
        free((void *)e->right.expr);
#line 298
        tmp = e->left.expr;
#line 299
        *e = *(e->left.expr);
#line 300
        free((void *)tmp);
        }
#line 301
        return (e);
      } else
#line 302
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 303
        expr_free(e->left.expr);
#line 304
        expr_free(e->right.expr);
#line 305
        e->type = (enum expr_type )7;
#line 306
        e->left.sym = & symbol_yes;
#line 307
        e->right.expr = (struct expr *)((void *)0);
        }
#line 308
        return (e);
      }
    }
#line 311
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 315
  return (e);
}
}
#line 321 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_trans_bool(struct expr *e ) 
{ 


  {
#line 323
  if (! e) {
#line 324
    return ((struct expr *)((void *)0));
  }
  {
#line 328
  if ((unsigned int )e->type == 3U) {
#line 328
    goto case_3;
  }
#line 328
  if ((unsigned int )e->type == 1U) {
#line 328
    goto case_3;
  }
#line 328
  if ((unsigned int )e->type == 2U) {
#line 328
    goto case_3;
  }
#line 332
  if ((unsigned int )e->type == 5U) {
#line 332
    goto case_5;
  }
#line 341
  goto switch_default;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 329
  e->left.expr = expr_trans_bool(e->left.expr);
#line 330
  e->right.expr = expr_trans_bool(e->right.expr);
  }
#line 331
  goto switch_break;
  case_5: /* CIL Label */ 
#line 334
  if ((unsigned int )(e->left.sym)->type == 2U) {
#line 335
    if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
#line 336
      e->type = (enum expr_type )7;
#line 337
      e->right.sym = (struct symbol *)((void *)0);
    }
  }
#line 340
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 344
  return (e);
}
}
#line 350 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_join_or(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct symbol *sym1 ;
  struct symbol *sym2 ;
  struct expr *tmp___0 ;
  int tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;

  {
  {
#line 355
  tmp___1 = expr_eq(e1, e2);
  }
#line 355
  if (tmp___1) {
    {
#line 356
    tmp___0 = expr_copy(e1);
    }
#line 356
    return (tmp___0);
  }
#line 357
  if ((unsigned int )e1->type != 4U) {
#line 357
    if ((unsigned int )e1->type != 5U) {
#line 357
      if ((unsigned int )e1->type != 7U) {
#line 357
        if ((unsigned int )e1->type != 3U) {
#line 358
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 359
  if ((unsigned int )e2->type != 4U) {
#line 359
    if ((unsigned int )e2->type != 5U) {
#line 359
      if ((unsigned int )e2->type != 7U) {
#line 359
        if ((unsigned int )e2->type != 3U) {
#line 360
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 361
  if ((unsigned int )e1->type == 3U) {
#line 362
    tmp = e1->left.expr;
#line 363
    if ((unsigned int )tmp->type != 4U) {
#line 363
      if ((unsigned int )tmp->type != 5U) {
#line 363
        if ((unsigned int )tmp->type != 7U) {
#line 364
          return ((struct expr *)((void *)0));
        }
      }
    }
#line 365
    sym1 = tmp->left.sym;
  } else {
#line 367
    sym1 = e1->left.sym;
  }
#line 368
  if ((unsigned int )e2->type == 3U) {
#line 369
    if ((unsigned int )(e2->left.expr)->type != 7U) {
#line 370
      return ((struct expr *)((void *)0));
    }
#line 371
    sym2 = (e2->left.expr)->left.sym;
  } else {
#line 373
    sym2 = e2->left.sym;
  }
#line 374
  if ((unsigned long )sym1 != (unsigned long )sym2) {
#line 375
    return ((struct expr *)((void *)0));
  }
#line 376
  if ((unsigned int )sym1->type != 1U) {
#line 376
    if ((unsigned int )sym1->type != 2U) {
#line 377
      return ((struct expr *)((void *)0));
    }
  }
#line 378
  if ((unsigned int )sym1->type == 2U) {
#line 379
    if ((unsigned int )e1->type == 4U) {
#line 379
      if ((unsigned int )e2->type == 4U) {
#line 379
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 379
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 383
            tmp___2 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_no);
            }
#line 383
            return (tmp___2);
          } else {
#line 379
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 379
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 379
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 383
            tmp___2 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_no);
            }
#line 383
            return (tmp___2);
          }
        }
      }
    }
#line 385
    if ((unsigned int )e1->type == 4U) {
#line 385
      if ((unsigned int )e2->type == 4U) {
#line 385
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 385
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 389
            tmp___3 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_mod);
            }
#line 389
            return (tmp___3);
          } else {
#line 385
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 385
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 385
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 389
            tmp___3 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_mod);
            }
#line 389
            return (tmp___3);
          }
        }
      }
    }
#line 391
    if ((unsigned int )e1->type == 4U) {
#line 391
      if ((unsigned int )e2->type == 4U) {
#line 391
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 391
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 395
            tmp___4 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_yes);
            }
#line 395
            return (tmp___4);
          } else {
#line 391
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 391
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 391
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 395
            tmp___4 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_yes);
            }
#line 395
            return (tmp___4);
          }
        }
      }
    }
  }
#line 398
  if ((unsigned int )sym1->type == 1U) {
#line 398
    if ((unsigned long )sym1 == (unsigned long )sym2) {
#line 399
      if ((unsigned int )e1->type == 3U) {
#line 399
        if ((unsigned int )(e1->left.expr)->type == 7U) {
#line 399
          if ((unsigned int )e2->type == 7U) {
            {
#line 401
            tmp___5 = expr_alloc_symbol(& symbol_yes);
            }
#line 401
            return (tmp___5);
          } else {
#line 399
            goto _L___3;
          }
        } else {
#line 399
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 399
      if ((unsigned int )e2->type == 3U) {
#line 399
        if ((unsigned int )(e2->left.expr)->type == 7U) {
#line 399
          if ((unsigned int )e1->type == 7U) {
            {
#line 401
            tmp___5 = expr_alloc_symbol(& symbol_yes);
            }
#line 401
            return (tmp___5);
          }
        }
      }
    }
  }
#line 411
  return ((struct expr *)((void *)0));
}
}
#line 414 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_join_and(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct symbol *sym1 ;
  struct symbol *sym2 ;
  struct expr *tmp___0 ;
  int tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  struct expr *tmp___7 ;
  struct expr *tmp___8 ;
  struct expr *tmp___9 ;
  struct expr *tmp___10 ;
  struct expr *tmp___11 ;
  struct expr *tmp___12 ;
  struct expr *tmp___13 ;

  {
  {
#line 419
  tmp___1 = expr_eq(e1, e2);
  }
#line 419
  if (tmp___1) {
    {
#line 420
    tmp___0 = expr_copy(e1);
    }
#line 420
    return (tmp___0);
  }
#line 421
  if ((unsigned int )e1->type != 4U) {
#line 421
    if ((unsigned int )e1->type != 5U) {
#line 421
      if ((unsigned int )e1->type != 7U) {
#line 421
        if ((unsigned int )e1->type != 3U) {
#line 422
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 423
  if ((unsigned int )e2->type != 4U) {
#line 423
    if ((unsigned int )e2->type != 5U) {
#line 423
      if ((unsigned int )e2->type != 7U) {
#line 423
        if ((unsigned int )e2->type != 3U) {
#line 424
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 425
  if ((unsigned int )e1->type == 3U) {
#line 426
    tmp = e1->left.expr;
#line 427
    if ((unsigned int )tmp->type != 4U) {
#line 427
      if ((unsigned int )tmp->type != 5U) {
#line 427
        if ((unsigned int )tmp->type != 7U) {
#line 428
          return ((struct expr *)((void *)0));
        }
      }
    }
#line 429
    sym1 = tmp->left.sym;
  } else {
#line 431
    sym1 = e1->left.sym;
  }
#line 432
  if ((unsigned int )e2->type == 3U) {
#line 433
    if ((unsigned int )(e2->left.expr)->type != 7U) {
#line 434
      return ((struct expr *)((void *)0));
    }
#line 435
    sym2 = (e2->left.expr)->left.sym;
  } else {
#line 437
    sym2 = e2->left.sym;
  }
#line 438
  if ((unsigned long )sym1 != (unsigned long )sym2) {
#line 439
    return ((struct expr *)((void *)0));
  }
#line 440
  if ((unsigned int )sym1->type != 1U) {
#line 440
    if ((unsigned int )sym1->type != 2U) {
#line 441
      return ((struct expr *)((void *)0));
    }
  }
#line 443
  if ((unsigned int )e1->type == 7U) {
#line 443
    if ((unsigned int )e2->type == 4U) {
#line 443
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
        {
#line 446
        tmp___2 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 446
        return (tmp___2);
      } else {
#line 443
        goto _L___0;
      }
    } else {
#line 443
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 443
  if ((unsigned int )e2->type == 7U) {
#line 443
    if ((unsigned int )e1->type == 4U) {
#line 443
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
        {
#line 446
        tmp___2 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 446
        return (tmp___2);
      }
    }
  }
#line 448
  if ((unsigned int )e1->type == 7U) {
#line 448
    if ((unsigned int )e2->type == 5U) {
#line 448
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
        {
#line 451
        tmp___3 = expr_alloc_symbol(sym1);
        }
#line 451
        return (tmp___3);
      } else {
#line 448
        goto _L___2;
      }
    } else {
#line 448
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 448
  if ((unsigned int )e2->type == 7U) {
#line 448
    if ((unsigned int )e1->type == 5U) {
#line 448
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
        {
#line 451
        tmp___3 = expr_alloc_symbol(sym1);
        }
#line 451
        return (tmp___3);
      }
    }
  }
#line 453
  if ((unsigned int )e1->type == 7U) {
#line 453
    if ((unsigned int )e2->type == 5U) {
#line 453
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
        {
#line 456
        tmp___4 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 456
        return (tmp___4);
      } else {
#line 453
        goto _L___4;
      }
    } else {
#line 453
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 453
  if ((unsigned int )e2->type == 7U) {
#line 453
    if ((unsigned int )e1->type == 5U) {
#line 453
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
        {
#line 456
        tmp___4 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 456
        return (tmp___4);
      }
    }
  }
#line 458
  if ((unsigned int )sym1->type == 2U) {
#line 459
    if ((unsigned int )e1->type == 4U) {
#line 459
      if ((unsigned int )e2->type == 5U) {
#line 461
        sym2 = e1->right.sym;
#line 462
        if ((e2->right.sym)->flags & 7) {
#line 462
          if (sym2->flags & 7) {
#line 463
            if ((unsigned long )sym2 != (unsigned long )e2->right.sym) {
              {
#line 463
              tmp___5 = expr_alloc_comp((enum expr_type )4, sym1, sym2);
#line 463
              tmp___7 = tmp___5;
              }
            } else {
              {
#line 463
              tmp___6 = expr_alloc_symbol(& symbol_no);
#line 463
              tmp___7 = tmp___6;
              }
            }
#line 463
            return (tmp___7);
          }
        }
      }
    }
#line 466
    if ((unsigned int )e1->type == 5U) {
#line 466
      if ((unsigned int )e2->type == 4U) {
#line 468
        sym2 = e2->right.sym;
#line 469
        if ((e1->right.sym)->flags & 7) {
#line 469
          if (sym2->flags & 7) {
#line 470
            if ((unsigned long )sym2 != (unsigned long )e1->right.sym) {
              {
#line 470
              tmp___8 = expr_alloc_comp((enum expr_type )4, sym1, sym2);
#line 470
              tmp___10 = tmp___8;
              }
            } else {
              {
#line 470
              tmp___9 = expr_alloc_symbol(& symbol_no);
#line 470
              tmp___10 = tmp___9;
              }
            }
#line 470
            return (tmp___10);
          }
        }
      }
    }
#line 473
    if ((unsigned int )e1->type == 5U) {
#line 473
      if ((unsigned int )e2->type == 5U) {
#line 473
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 473
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 477
            tmp___11 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_mod);
            }
#line 477
            return (tmp___11);
          } else {
#line 473
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 473
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 473
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 477
            tmp___11 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_mod);
            }
#line 477
            return (tmp___11);
          }
        }
      }
    }
#line 479
    if ((unsigned int )e1->type == 5U) {
#line 479
      if ((unsigned int )e2->type == 5U) {
#line 479
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 479
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 483
            tmp___12 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_no);
            }
#line 483
            return (tmp___12);
          } else {
#line 479
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 479
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 479
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 483
            tmp___12 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_no);
            }
#line 483
            return (tmp___12);
          }
        }
      }
    }
#line 485
    if ((unsigned int )e1->type == 5U) {
#line 485
      if ((unsigned int )e2->type == 5U) {
#line 485
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 485
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 489
            tmp___13 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
            }
#line 489
            return (tmp___13);
          } else {
#line 485
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 485
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 485
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 489
            tmp___13 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
            }
#line 489
            return (tmp___13);
          }
        }
      }
    }
#line 491
    if ((unsigned int )e1->type == 7U) {
#line 491
      if ((unsigned int )e2->type == 4U) {
#line 491
        if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
#line 495
          return ((struct expr *)((void *)0));
        } else {
#line 491
          goto _L___13;
        }
      } else {
#line 491
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 491
    if ((unsigned int )e2->type == 7U) {
#line 491
      if ((unsigned int )e1->type == 4U) {
#line 491
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 495
          return ((struct expr *)((void *)0));
        } else {
#line 491
          goto _L___11;
        }
      } else {
#line 491
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 491
    if ((unsigned int )e1->type == 7U) {
#line 491
      if ((unsigned int )e2->type == 5U) {
#line 491
        if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
#line 495
          return ((struct expr *)((void *)0));
        } else {
#line 491
          goto _L___9;
        }
      } else {
#line 491
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 491
    if ((unsigned int )e2->type == 7U) {
#line 491
      if ((unsigned int )e1->type == 5U) {
#line 491
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 495
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 505
  return ((struct expr *)((void *)0));
}
}
#line 508 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
static void expr_eliminate_dups1(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
#line 514
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 515
    expr_eliminate_dups1(type, & (*ep1)->left.expr, ep2);
#line 516
    expr_eliminate_dups1(type, & (*ep1)->right.expr, ep2);
    }
#line 517
    return;
  }
#line 519
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 520
    expr_eliminate_dups1(type, ep1, & (*ep2)->left.expr);
#line 521
    expr_eliminate_dups1(type, ep1, & (*ep2)->right.expr);
    }
#line 522
    return;
  }
#line 524
  if ((unsigned long )*ep1 == (unsigned long )*ep2) {
#line 525
    return;
  }
  {
#line 528
  if ((unsigned int )(*ep1)->type == 2U) {
#line 528
    goto case_2;
  }
#line 528
  if ((unsigned int )(*ep1)->type == 1U) {
#line 528
    goto case_2;
  }
#line 530
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 529
  expr_eliminate_dups1((*ep1)->type, ep1, ep1);
  }
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 535
  if ((unsigned int )type == 1U) {
#line 535
    goto case_1___0;
  }
#line 544
  if ((unsigned int )type == 2U) {
#line 544
    goto case_2___0;
  }
#line 553
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 536
  tmp = expr_join_or(*ep1, *ep2);
  }
#line 537
  if (tmp) {
    {
#line 538
    expr_free(*ep1);
#line 538
    expr_free(*ep2);
#line 539
    *ep1 = expr_alloc_symbol(& symbol_no);
#line 540
    *ep2 = tmp;
#line 541
    trans_count ++;
    }
  }
#line 543
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 545
  tmp = expr_join_and(*ep1, *ep2);
  }
#line 546
  if (tmp) {
    {
#line 547
    expr_free(*ep1);
#line 547
    expr_free(*ep2);
#line 548
    *ep1 = expr_alloc_symbol(& symbol_yes);
#line 549
    *ep2 = tmp;
#line 550
    trans_count ++;
    }
  }
#line 552
  goto switch_break___0;
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
#line 558
  return;
}
}
#line 560 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
static void expr_eliminate_dups2(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp1 ;
  struct expr *tmp2 ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  int tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  int tmp___5 ;

  {
#line 566
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 567
    expr_eliminate_dups2(type, & (*ep1)->left.expr, ep2);
#line 568
    expr_eliminate_dups2(type, & (*ep1)->right.expr, ep2);
    }
#line 569
    return;
  }
#line 571
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 572
    expr_eliminate_dups2(type, ep1, & (*ep2)->left.expr);
#line 573
    expr_eliminate_dups2(type, ep1, & (*ep2)->right.expr);
    }
  }
#line 575
  if ((unsigned long )*ep1 == (unsigned long )*ep2) {
#line 576
    return;
  }
  {
#line 579
  if ((unsigned int )(*ep1)->type == 1U) {
#line 579
    goto case_1;
  }
#line 594
  if ((unsigned int )(*ep1)->type == 2U) {
#line 594
    goto case_2;
  }
#line 609
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 580
  expr_eliminate_dups2((*ep1)->type, ep1, ep1);
#line 582
  tmp___0 = expr_copy(*ep1);
#line 582
  tmp___1 = expr_alloc_one((enum expr_type )3, tmp___0);
#line 582
  tmp1 = expr_transform(tmp___1);
#line 583
  tmp2 = expr_copy(*ep2);
#line 584
  tmp = expr_extract_eq_and(& tmp1, & tmp2);
#line 585
  tmp___2 = expr_is_yes(tmp1);
  }
#line 585
  if (tmp___2) {
    {
#line 586
    expr_free(*ep1);
#line 587
    *ep1 = expr_alloc_symbol(& symbol_no);
#line 588
    trans_count ++;
    }
  }
  {
#line 590
  expr_free(tmp2);
#line 591
  expr_free(tmp1);
#line 592
  expr_free(tmp);
  }
#line 593
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 595
  expr_eliminate_dups2((*ep1)->type, ep1, ep1);
#line 597
  tmp___3 = expr_copy(*ep1);
#line 597
  tmp___4 = expr_alloc_one((enum expr_type )3, tmp___3);
#line 597
  tmp1 = expr_transform(tmp___4);
#line 598
  tmp2 = expr_copy(*ep2);
#line 599
  tmp = expr_extract_eq_or(& tmp1, & tmp2);
#line 600
  tmp___5 = expr_is_no(tmp1);
  }
#line 600
  if (tmp___5) {
    {
#line 601
    expr_free(*ep1);
#line 602
    *ep1 = expr_alloc_symbol(& symbol_yes);
#line 603
    trans_count ++;
    }
  }
  {
#line 605
  expr_free(tmp2);
#line 606
  expr_free(tmp1);
#line 607
  expr_free(tmp);
  }
#line 608
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 614
  return;
}
}
#line 616 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_eliminate_dups(struct expr *e ) 
{ 
  int oldcount ;

  {
#line 619
  if (! e) {
#line 620
    return (e);
  }
#line 622
  oldcount = trans_count;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    trans_count = 0;
    {
#line 626
    if ((unsigned int )e->type == 2U) {
#line 626
      goto case_2;
    }
#line 626
    if ((unsigned int )e->type == 1U) {
#line 626
      goto case_2;
    }
#line 629
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 627
    expr_eliminate_dups1(e->type, & e, & e);
#line 628
    expr_eliminate_dups2(e->type, & e, & e);
    }
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 632
    if (! trans_count) {
#line 633
      goto while_break;
    }
    {
#line 634
    e = expr_eliminate_yn(e);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  trans_count = oldcount;
#line 637
  return (e);
}
}
#line 640 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_transform(struct expr *e ) 
{ 
  struct expr *tmp ;

  {
#line 644
  if (! e) {
#line 645
    return ((struct expr *)((void *)0));
  }
  {
#line 650
  if ((unsigned int )e->type == 6U) {
#line 650
    goto case_6;
  }
#line 650
  if ((unsigned int )e->type == 7U) {
#line 650
    goto case_6;
  }
#line 650
  if ((unsigned int )e->type == 5U) {
#line 650
    goto case_6;
  }
#line 650
  if ((unsigned int )e->type == 4U) {
#line 650
    goto case_6;
  }
#line 652
  goto switch_default;
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 651
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 653
  e->left.expr = expr_transform(e->left.expr);
#line 654
  e->right.expr = expr_transform(e->right.expr);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 658
  if ((unsigned int )e->type == 4U) {
#line 658
    goto case_4___0;
  }
#line 680
  if ((unsigned int )e->type == 5U) {
#line 680
    goto case_5___0;
  }
#line 702
  if ((unsigned int )e->type == 3U) {
#line 702
    goto case_3;
  }
#line 771
  goto switch_default___1;
  case_4___0: /* CIL Label */ 
#line 659
  if ((unsigned int )(e->left.sym)->type != 1U) {
#line 660
    goto switch_break___0;
  }
#line 661
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
    {
#line 662
    e->type = (enum expr_type )3;
#line 663
    e->left.expr = expr_alloc_symbol(e->left.sym);
#line 664
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 665
    goto switch_break___0;
  }
#line 667
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_mod)) {
    {
#line 668
    printf((char const   */* __restrict  */)"boolean symbol %s tested for \'m\'? test forced to \'n\'\n",
           (e->left.sym)->name);
#line 669
    e->type = (enum expr_type )7;
#line 670
    e->left.sym = & symbol_no;
#line 671
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 672
    goto switch_break___0;
  }
#line 674
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_yes)) {
#line 675
    e->type = (enum expr_type )7;
#line 676
    e->right.sym = (struct symbol *)((void *)0);
#line 677
    goto switch_break___0;
  }
#line 679
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
#line 681
  if ((unsigned int )(e->left.sym)->type != 1U) {
#line 682
    goto switch_break___0;
  }
#line 683
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
#line 684
    e->type = (enum expr_type )7;
#line 685
    e->right.sym = (struct symbol *)((void *)0);
#line 686
    goto switch_break___0;
  }
#line 688
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_mod)) {
    {
#line 689
    printf((char const   */* __restrict  */)"boolean symbol %s tested for \'m\'? test forced to \'y\'\n",
           (e->left.sym)->name);
#line 690
    e->type = (enum expr_type )7;
#line 691
    e->left.sym = & symbol_yes;
#line 692
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 693
    goto switch_break___0;
  }
#line 695
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_yes)) {
    {
#line 696
    e->type = (enum expr_type )3;
#line 697
    e->left.expr = expr_alloc_symbol(e->left.sym);
#line 698
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 699
    goto switch_break___0;
  }
#line 701
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 704
  if ((unsigned int )(e->left.expr)->type == 3U) {
#line 704
    goto case_3___0;
  }
#line 713
  if ((unsigned int )(e->left.expr)->type == 5U) {
#line 713
    goto case_5___1;
  }
#line 713
  if ((unsigned int )(e->left.expr)->type == 4U) {
#line 713
    goto case_5___1;
  }
#line 720
  if ((unsigned int )(e->left.expr)->type == 1U) {
#line 720
    goto case_1;
  }
#line 729
  if ((unsigned int )(e->left.expr)->type == 2U) {
#line 729
    goto case_2;
  }
#line 738
  if ((unsigned int )(e->left.expr)->type == 7U) {
#line 738
    goto case_7___0;
  }
#line 767
  goto switch_default___0;
  case_3___0: /* CIL Label */ 
  {
#line 706
  tmp = (e->left.expr)->left.expr;
#line 707
  free((void *)e->left.expr);
#line 708
  free((void *)e);
#line 709
  e = tmp;
#line 710
  e = expr_transform(e);
  }
#line 711
  goto switch_break___1;
  case_5___1: /* CIL Label */ 
  case_4___1: /* CIL Label */ 
  {
#line 715
  tmp = e->left.expr;
#line 716
  free((void *)e);
#line 717
  e = tmp;
  }
#line 718
  if ((unsigned int )e->type == 4U) {
#line 718
    e->type = (enum expr_type )5;
  } else {
#line 718
    e->type = (enum expr_type )4;
  }
#line 719
  goto switch_break___1;
  case_1: /* CIL Label */ 
  {
#line 722
  tmp = e->left.expr;
#line 723
  e->type = (enum expr_type )2;
#line 724
  e->right.expr = expr_alloc_one((enum expr_type )3, tmp->right.expr);
#line 725
  tmp->type = (enum expr_type )3;
#line 726
  tmp->right.expr = (struct expr *)((void *)0);
#line 727
  e = expr_transform(e);
  }
#line 728
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 731
  tmp = e->left.expr;
#line 732
  e->type = (enum expr_type )1;
#line 733
  e->right.expr = expr_alloc_one((enum expr_type )3, tmp->right.expr);
#line 734
  tmp->type = (enum expr_type )3;
#line 735
  tmp->right.expr = (struct expr *)((void *)0);
#line 736
  e = expr_transform(e);
  }
#line 737
  goto switch_break___1;
  case_7___0: /* CIL Label */ 
#line 739
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
    {
#line 741
    tmp = e->left.expr;
#line 742
    free((void *)e);
#line 743
    e = tmp;
#line 744
    e->type = (enum expr_type )7;
#line 745
    e->left.sym = & symbol_no;
    }
#line 746
    goto switch_break___1;
  }
#line 748
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_mod)) {
    {
#line 750
    tmp = e->left.expr;
#line 751
    free((void *)e);
#line 752
    e = tmp;
#line 753
    e->type = (enum expr_type )7;
#line 754
    e->left.sym = & symbol_mod;
    }
#line 755
    goto switch_break___1;
  }
#line 757
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
    {
#line 759
    tmp = e->left.expr;
#line 760
    free((void *)e);
#line 761
    e = tmp;
#line 762
    e->type = (enum expr_type )7;
#line 763
    e->left.sym = & symbol_yes;
    }
#line 764
    goto switch_break___1;
  }
#line 766
  goto switch_break___1;
  switch_default___0: /* CIL Label */ ;
  switch_break___1: /* CIL Label */ ;
  }
#line 770
  goto switch_break___0;
  switch_default___1: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
#line 774
  return (e);
}
}
#line 777 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
int expr_contains_symbol(struct expr *dep , struct symbol *sym ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 779
  if (! dep) {
#line 780
    return (0);
  }
  {
#line 784
  if ((unsigned int )dep->type == 1U) {
#line 784
    goto case_1;
  }
#line 784
  if ((unsigned int )dep->type == 2U) {
#line 784
    goto case_1;
  }
#line 787
  if ((unsigned int )dep->type == 7U) {
#line 787
    goto case_7;
  }
#line 790
  if ((unsigned int )dep->type == 5U) {
#line 790
    goto case_5;
  }
#line 790
  if ((unsigned int )dep->type == 4U) {
#line 790
    goto case_5;
  }
#line 793
  if ((unsigned int )dep->type == 3U) {
#line 793
    goto case_3;
  }
#line 795
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 785
  tmp = expr_contains_symbol(dep->left.expr, sym);
  }
#line 785
  if (tmp) {
#line 785
    tmp___1 = 1;
  } else {
    {
#line 785
    tmp___0 = expr_contains_symbol(dep->right.expr, sym);
    }
#line 785
    if (tmp___0) {
#line 785
      tmp___1 = 1;
    } else {
#line 785
      tmp___1 = 0;
    }
  }
#line 785
  return (tmp___1);
  case_7: /* CIL Label */ 
#line 788
  return ((unsigned long )dep->left.sym == (unsigned long )sym);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 791
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 791
    tmp___2 = 1;
  } else
#line 791
  if ((unsigned long )dep->right.sym == (unsigned long )sym) {
#line 791
    tmp___2 = 1;
  } else {
#line 791
    tmp___2 = 0;
  }
#line 791
  return (tmp___2);
  case_3: /* CIL Label */ 
  {
#line 794
  tmp___3 = expr_contains_symbol(dep->left.expr, sym);
  }
#line 794
  return (tmp___3);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 798
  return (0);
}
}
#line 801 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
_Bool expr_depends_symbol(struct expr *dep , struct symbol *sym ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 803
  if (! dep) {
#line 804
    return ((_Bool)0);
  }
  {
#line 807
  if ((unsigned int )dep->type == 2U) {
#line 807
    goto case_2;
  }
#line 810
  if ((unsigned int )dep->type == 7U) {
#line 810
    goto case_7;
  }
#line 812
  if ((unsigned int )dep->type == 4U) {
#line 812
    goto case_4;
  }
#line 818
  if ((unsigned int )dep->type == 5U) {
#line 818
    goto case_5;
  }
#line 824
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 808
  tmp = expr_depends_symbol(dep->left.expr, sym);
  }
#line 808
  if (tmp) {
#line 808
    tmp___1 = 1;
  } else {
    {
#line 808
    tmp___0 = expr_depends_symbol(dep->right.expr, sym);
    }
#line 808
    if (tmp___0) {
#line 808
      tmp___1 = 1;
    } else {
#line 808
      tmp___1 = 0;
    }
  }
#line 808
  return ((_Bool )tmp___1);
  case_7: /* CIL Label */ 
#line 811
  return ((_Bool )((unsigned long )dep->left.sym == (unsigned long )sym));
  case_4: /* CIL Label */ 
#line 813
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 814
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_yes)) {
#line 815
      return ((_Bool)1);
    } else
#line 814
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_mod)) {
#line 815
      return ((_Bool)1);
    }
  }
#line 817
  goto switch_break;
  case_5: /* CIL Label */ 
#line 819
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 820
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_no)) {
#line 821
      return ((_Bool)1);
    }
  }
#line 823
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 827
  return ((_Bool)0);
}
}
#line 830 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_extract_eq_and(struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
  {
#line 832
  tmp = (struct expr *)((void *)0);
#line 833
  expr_extract_eq((enum expr_type )2, & tmp, ep1, ep2);
  }
#line 834
  if (tmp) {
    {
#line 835
    *ep1 = expr_eliminate_yn(*ep1);
#line 836
    *ep2 = expr_eliminate_yn(*ep2);
    }
  }
#line 838
  return (tmp);
}
}
#line 841 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_extract_eq_or(struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
  {
#line 843
  tmp = (struct expr *)((void *)0);
#line 844
  expr_extract_eq((enum expr_type )1, & tmp, ep1, ep2);
  }
#line 845
  if (tmp) {
    {
#line 846
    *ep1 = expr_eliminate_yn(*ep1);
#line 847
    *ep2 = expr_eliminate_yn(*ep2);
    }
  }
#line 849
  return (tmp);
}
}
#line 852 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
void expr_extract_eq(enum expr_type type , struct expr **ep , struct expr **ep1 ,
                     struct expr **ep2 ) 
{ 
  struct expr *tmp ;
  int tmp___0 ;

  {
#line 856
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 857
    expr_extract_eq(type, ep, & (*ep1)->left.expr, ep2);
#line 858
    expr_extract_eq(type, ep, & (*ep1)->right.expr, ep2);
    }
#line 859
    return;
  }
#line 861
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 862
    expr_extract_eq(type, ep, ep1, & (*ep2)->left.expr);
#line 863
    expr_extract_eq(type, ep, ep1, & (*ep2)->right.expr);
    }
#line 864
    return;
  }
  {
#line 866
  tmp___0 = expr_eq(*ep1, *ep2);
  }
#line 866
  if (tmp___0) {
#line 867
    if (*ep) {
      {
#line 867
      tmp = expr_alloc_two(type, *ep, *ep1);
#line 867
      *ep = tmp;
      }
    } else {
#line 867
      *ep = *ep1;
    }
    {
#line 868
    expr_free(*ep2);
    }
#line 869
    if ((unsigned int )type == 2U) {
      {
#line 870
      *ep1 = expr_alloc_symbol(& symbol_yes);
#line 871
      *ep2 = expr_alloc_symbol(& symbol_yes);
      }
    } else
#line 872
    if ((unsigned int )type == 1U) {
      {
#line 873
      *ep1 = expr_alloc_symbol(& symbol_no);
#line 874
      *ep2 = expr_alloc_symbol(& symbol_no);
      }
    }
  }
#line 879
  return;
}
}
#line 881 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
struct expr *expr_trans_compare(struct expr *e , enum expr_type type , struct symbol *sym ) 
{ 
  struct expr *e1 ;
  struct expr *e2 ;
  int tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  struct expr *tmp___7 ;
  struct expr *tmp___8 ;
  struct expr *tmp___9 ;

  {
#line 885
  if (! e) {
    {
#line 886
    e = expr_alloc_symbol(sym);
    }
#line 887
    if ((unsigned int )type == 5U) {
      {
#line 888
      e = expr_alloc_one((enum expr_type )3, e);
      }
    }
#line 889
    return (e);
  }
  {
#line 892
  if ((unsigned int )e->type == 2U) {
#line 892
    goto case_2;
  }
#line 902
  if ((unsigned int )e->type == 1U) {
#line 902
    goto case_1;
  }
#line 912
  if ((unsigned int )e->type == 3U) {
#line 912
    goto case_3;
  }
#line 915
  if ((unsigned int )e->type == 4U) {
#line 915
    goto case_4;
  }
#line 915
  if ((unsigned int )e->type == 5U) {
#line 915
    goto case_4;
  }
#line 932
  if ((unsigned int )e->type == 7U) {
#line 932
    goto case_7;
  }
#line 936
  if ((unsigned int )e->type == 0U) {
#line 936
    goto case_0;
  }
#line 936
  if ((unsigned int )e->type == 8U) {
#line 936
    goto case_0;
  }
#line 936
  if ((unsigned int )e->type == 6U) {
#line 936
    goto case_0;
  }
#line 891
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 893
  e1 = expr_trans_compare(e->left.expr, (enum expr_type )4, sym);
#line 894
  e2 = expr_trans_compare(e->right.expr, (enum expr_type )4, sym);
  }
#line 895
  if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
    {
#line 896
    e = expr_alloc_two((enum expr_type )2, e1, e2);
    }
  }
#line 897
  if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
    {
#line 898
    e = expr_alloc_two((enum expr_type )1, e1, e2);
    }
  }
#line 899
  if ((unsigned int )type == 5U) {
    {
#line 900
    e = expr_alloc_one((enum expr_type )3, e);
    }
  }
#line 901
  return (e);
  case_1: /* CIL Label */ 
  {
#line 903
  e1 = expr_trans_compare(e->left.expr, (enum expr_type )4, sym);
#line 904
  e2 = expr_trans_compare(e->right.expr, (enum expr_type )4, sym);
  }
#line 905
  if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
    {
#line 906
    e = expr_alloc_two((enum expr_type )1, e1, e2);
    }
  }
#line 907
  if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
    {
#line 908
    e = expr_alloc_two((enum expr_type )2, e1, e2);
    }
  }
#line 909
  if ((unsigned int )type == 5U) {
    {
#line 910
    e = expr_alloc_one((enum expr_type )3, e);
    }
  }
#line 911
  return (e);
  case_3: /* CIL Label */ 
#line 913
  if ((unsigned int )type == 4U) {
#line 913
    tmp = 5;
  } else {
#line 913
    tmp = 4;
  }
  {
#line 913
  tmp___0 = expr_trans_compare(e->left.expr, (enum expr_type )tmp, sym);
  }
#line 913
  return (tmp___0);
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 916
  if ((unsigned int )type == 4U) {
#line 917
    if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
      {
#line 918
      tmp___1 = expr_copy(e);
      }
#line 918
      return (tmp___1);
    }
#line 919
    if ((unsigned long )sym == (unsigned long )(& symbol_mod)) {
      {
#line 920
      tmp___2 = expr_alloc_symbol(& symbol_no);
      }
#line 920
      return (tmp___2);
    }
#line 921
    if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
      {
#line 922
      tmp___3 = expr_copy(e);
#line 922
      tmp___4 = expr_alloc_one((enum expr_type )3, tmp___3);
      }
#line 922
      return (tmp___4);
    }
  } else {
#line 924
    if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
      {
#line 925
      tmp___5 = expr_copy(e);
#line 925
      tmp___6 = expr_alloc_one((enum expr_type )3, tmp___5);
      }
#line 925
      return (tmp___6);
    }
#line 926
    if ((unsigned long )sym == (unsigned long )(& symbol_mod)) {
      {
#line 927
      tmp___7 = expr_alloc_symbol(& symbol_yes);
      }
#line 927
      return (tmp___7);
    }
#line 928
    if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
      {
#line 929
      tmp___8 = expr_copy(e);
      }
#line 929
      return (tmp___8);
    }
  }
#line 931
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 933
  tmp___9 = expr_alloc_comp(type, e->left.sym, sym);
  }
#line 933
  return (tmp___9);
  case_0: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 939
  return ((struct expr *)((void *)0));
}
}
#line 942 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
tristate expr_calc_value(struct expr *e ) 
{ 
  tristate val1 ;
  tristate val2 ;
  char const   *str1 ;
  char const   *str2 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 947
  if (! e) {
#line 948
    return ((tristate )2);
  }
  {
#line 951
  if ((unsigned int )e->type == 7U) {
#line 951
    goto case_7;
  }
#line 954
  if ((unsigned int )e->type == 2U) {
#line 954
    goto case_2;
  }
#line 958
  if ((unsigned int )e->type == 1U) {
#line 958
    goto case_1;
  }
#line 962
  if ((unsigned int )e->type == 3U) {
#line 962
    goto case_3;
  }
#line 965
  if ((unsigned int )e->type == 4U) {
#line 965
    goto case_4;
  }
#line 971
  if ((unsigned int )e->type == 5U) {
#line 971
    goto case_5;
  }
#line 977
  goto switch_default;
  case_7: /* CIL Label */ 
  {
#line 952
  sym_calc_value(e->left.sym);
  }
#line 953
  return ((e->left.sym)->curr.tri);
  case_2: /* CIL Label */ 
  {
#line 955
  val1 = expr_calc_value(e->left.expr);
#line 956
  val2 = expr_calc_value(e->right.expr);
  }
#line 957
  if ((unsigned int )val1 < (unsigned int )val2) {
#line 957
    tmp = (unsigned int )val1;
  } else {
#line 957
    tmp = (unsigned int )val2;
  }
#line 957
  return ((tristate )tmp);
  case_1: /* CIL Label */ 
  {
#line 959
  val1 = expr_calc_value(e->left.expr);
#line 960
  val2 = expr_calc_value(e->right.expr);
  }
#line 961
  if ((unsigned int )val1 > (unsigned int )val2) {
#line 961
    tmp___0 = (unsigned int )val1;
  } else {
#line 961
    tmp___0 = (unsigned int )val2;
  }
#line 961
  return ((tristate )tmp___0);
  case_3: /* CIL Label */ 
  {
#line 963
  val1 = expr_calc_value(e->left.expr);
  }
#line 964
  return ((tristate )(2U - (unsigned int )val1));
  case_4: /* CIL Label */ 
  {
#line 966
  sym_calc_value(e->left.sym);
#line 967
  sym_calc_value(e->right.sym);
#line 968
  str1 = sym_get_string_value(e->left.sym);
#line 969
  str2 = sym_get_string_value(e->right.sym);
#line 970
  tmp___3 = strcmp(str1, str2);
  }
#line 970
  if (tmp___3) {
#line 970
    tmp___2 = 0;
  } else {
#line 970
    tmp___2 = 2;
  }
#line 970
  return ((tristate )tmp___2);
  case_5: /* CIL Label */ 
  {
#line 972
  sym_calc_value(e->left.sym);
#line 973
  sym_calc_value(e->right.sym);
#line 974
  str1 = sym_get_string_value(e->left.sym);
#line 975
  str2 = sym_get_string_value(e->right.sym);
#line 976
  tmp___6 = strcmp(str1, str2);
  }
#line 976
  if (tmp___6) {
#line 976
    tmp___5 = 2;
  } else {
#line 976
    tmp___5 = 0;
  }
#line 976
  return ((tristate )tmp___5);
  switch_default: /* CIL Label */ 
  {
#line 978
  printf((char const   */* __restrict  */)"expr_calc_value: %d?\n", (unsigned int )e->type);
  }
#line 979
  return ((tristate )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 983 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
int expr_compare_type(enum expr_type t1 , enum expr_type t2 ) 
{ 


  {
#line 988
  if ((unsigned int )t1 == (unsigned int )t2) {
#line 989
    return (0);
  }
  {
#line 992
  if ((unsigned int )t1 == 5U) {
#line 992
    goto case_5;
  }
#line 992
  if ((unsigned int )t1 == 4U) {
#line 992
    goto case_5;
  }
#line 995
  if ((unsigned int )t1 == 3U) {
#line 995
    goto case_3;
  }
#line 998
  if ((unsigned int )t1 == 2U) {
#line 998
    goto case_2;
  }
#line 1001
  if ((unsigned int )t1 == 1U) {
#line 1001
    goto case_1;
  }
#line 1004
  if ((unsigned int )t1 == 6U) {
#line 1004
    goto case_6;
  }
#line 1007
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 993
  if ((unsigned int )t2 == 3U) {
#line 994
    return (1);
  }
  case_3: /* CIL Label */ 
#line 996
  if ((unsigned int )t2 == 2U) {
#line 997
    return (1);
  }
  case_2: /* CIL Label */ 
#line 999
  if ((unsigned int )t2 == 1U) {
#line 1000
    return (1);
  }
  case_1: /* CIL Label */ 
#line 1002
  if ((unsigned int )t2 == 6U) {
#line 1003
    return (1);
  }
  case_6: /* CIL Label */ 
#line 1005
  if ((unsigned int )t2 == 0U) {
#line 1006
    return (1);
  }
  switch_default: /* CIL Label */ 
#line 1008
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1010
  printf((char const   */* __restrict  */)"[%dgt%d?]", (unsigned int )t1, (unsigned int )t2);
  }
#line 1011
  return (0);
}
}
#line 1015 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
void expr_print(struct expr *e , void (*fn)(void * , char const   * ) , void *data ,
                int prevtoken ) 
{ 
  int tmp ;
  char buf[32] ;
  int tmp___0 ;

  {
#line 1017
  if (! e) {
    {
#line 1018
    (*fn)(data, "y");
    }
#line 1019
    return;
  }
  {
#line 1022
  tmp = expr_compare_type((enum expr_type )prevtoken, e->type);
  }
#line 1022
  if (tmp > 0) {
    {
#line 1023
    (*fn)(data, "(");
    }
  }
  {
#line 1025
  if ((unsigned int )e->type == 7U) {
#line 1025
    goto case_7;
  }
#line 1031
  if ((unsigned int )e->type == 3U) {
#line 1031
    goto case_3;
  }
#line 1035
  if ((unsigned int )e->type == 4U) {
#line 1035
    goto case_4;
  }
#line 1040
  if ((unsigned int )e->type == 5U) {
#line 1040
    goto case_5;
  }
#line 1045
  if ((unsigned int )e->type == 1U) {
#line 1045
    goto case_1;
  }
#line 1050
  if ((unsigned int )e->type == 2U) {
#line 1050
    goto case_2;
  }
#line 1055
  if ((unsigned int )e->type == 6U) {
#line 1055
    goto case_6;
  }
#line 1062
  if ((unsigned int )e->type == 8U) {
#line 1062
    goto case_8;
  }
#line 1069
  goto switch_default;
  case_7: /* CIL Label */ 
#line 1026
  if ((e->left.sym)->name) {
    {
#line 1027
    (*fn)(data, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1029
    (*fn)(data, "<choice>");
    }
  }
#line 1030
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1032
  (*fn)(data, "!");
#line 1033
  expr_print(e->left.expr, fn, data, 3);
  }
#line 1034
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1036
  (*fn)(data, (char const   *)(e->left.sym)->name);
#line 1037
  (*fn)(data, "=");
#line 1038
  (*fn)(data, (char const   *)(e->right.sym)->name);
  }
#line 1039
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1041
  (*fn)(data, (char const   *)(e->left.sym)->name);
#line 1042
  (*fn)(data, "!=");
#line 1043
  (*fn)(data, (char const   *)(e->right.sym)->name);
  }
#line 1044
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1046
  expr_print(e->left.expr, fn, data, 1);
#line 1047
  (*fn)(data, " || ");
#line 1048
  expr_print(e->right.expr, fn, data, 1);
  }
#line 1049
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1051
  expr_print(e->left.expr, fn, data, 2);
#line 1052
  (*fn)(data, " && ");
#line 1053
  expr_print(e->right.expr, fn, data, 2);
  }
#line 1054
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1056
  (*fn)(data, (char const   *)(e->right.sym)->name);
  }
#line 1057
  if (e->left.expr) {
    {
#line 1058
    (*fn)(data, " ^ ");
#line 1059
    expr_print(e->left.expr, fn, data, 6);
    }
  }
#line 1061
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1063
  (*fn)(data, "[");
#line 1064
  (*fn)(data, (char const   *)(e->left.sym)->name);
#line 1065
  (*fn)(data, " ");
#line 1066
  (*fn)(data, (char const   *)(e->right.sym)->name);
#line 1067
  (*fn)(data, "]");
  }
#line 1068
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1072
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"<unknown type %d>",
          (unsigned int )e->type);
#line 1073
  (*fn)(data, (char const   *)(buf));
  }
#line 1074
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1077
  tmp___0 = expr_compare_type((enum expr_type )prevtoken, e->type);
  }
#line 1077
  if (tmp___0 > 0) {
    {
#line 1078
    (*fn)(data, ")");
    }
  }
#line 1079
  return;
}
}
#line 1081 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
static void expr_print_file_helper(void *data , char const   *str ) 
{ 
  size_t tmp ;

  {
  {
#line 1083
  tmp = strlen(str);
#line 1083
  fwrite((void const   */* __restrict  */)str, tmp, (size_t )1, (FILE */* __restrict  */)data);
  }
#line 1084
  return;
}
}
#line 1086 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
void expr_fprint(struct expr *e , FILE *out ) 
{ 


  {
  {
#line 1088
  expr_print(e, & expr_print_file_helper, (void *)out, 0);
  }
#line 1089
  return;
}
}
#line 1091 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
static void expr_print_gstr_helper(void *data , char const   *str ) 
{ 


  {
  {
#line 1093
  str_append((struct gstr *)data, str);
  }
#line 1094
  return;
}
}
#line 1096 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/expr.c"
void expr_gstr_print(struct expr *e , struct gstr *gs ) 
{ 


  {
  {
#line 1098
  expr_print(e, & expr_print_gstr_helper, (void *)gs, 0);
  }
#line 1099
  return;
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 15 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct symbol symbol_yes  = 
#line 15 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
     {(struct symbol *)0, (char *)"y", (char *)0, 0U, {(void *)"y", (tristate )2}, {(void *)0,
                                                                                  0U},
    0U, 129, (struct property *)0, (struct expr *)0, (struct expr *)0, {(struct expr *)0,
                                                                        0U}};
#line 15 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct symbol symbol_mod  = 
#line 15
     {(struct symbol *)0, (char *)"m", (char *)0, 0U, {(void *)"m", (tristate )1}, {(void *)0,
                                                                                  0U},
    0U, 130, (struct property *)0, (struct expr *)0, (struct expr *)0, {(struct expr *)0,
                                                                        0U}};
#line 15 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct symbol symbol_no  = 
#line 15
     {(struct symbol *)0, (char *)"n", (char *)0, 0U, {(void *)"n", (tristate )0}, {(void *)0,
                                                                                  0U},
    0U, 132, (struct property *)0, (struct expr *)0, (struct expr *)0, {(struct expr *)0,
                                                                        0U}};
#line 15 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct symbol symbol_empty  = 
#line 15
     {(struct symbol *)0, (char *)"", (char *)0, 0U, {(void *)"", (tristate )0}, {(void *)0,
                                                                                0U},
    0U, 128, (struct property *)0, (struct expr *)0, (struct expr *)0, {(struct expr *)0,
                                                                        0U}};
#line 35 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
tristate modules_val  ;
#line 37 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
void sym_add_default(struct symbol *sym , char const   *def ) 
{ 
  struct property *prop ;
  struct property *tmp ;
  struct symbol *tmp___0 ;

  {
  {
#line 39
  tmp = prop_alloc((enum prop_type )4, sym);
#line 39
  prop = tmp;
#line 41
  tmp___0 = sym_lookup(def, 1);
#line 41
  prop->expr = expr_alloc_symbol(tmp___0);
  }
#line 42
  return;
}
}
#line 49 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
static _Bool inited  =    (_Bool)0;
#line 44 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
void sym_init(void) 
{ 
  struct symbol *sym ;
  struct utsname uts ;
  char *p ;

  {
#line 51
  if (inited) {
#line 52
    return;
  }
  {
#line 53
  inited = (_Bool)1;
#line 55
  uname(& uts);
#line 57
  sym = sym_lookup("ARCH", 0);
#line 58
  sym->type = (enum symbol_type )5;
#line 59
  sym->flags |= 4096;
#line 60
  p = getenv("ARCH");
  }
#line 61
  if (p) {
    {
#line 62
    sym_add_default(sym, (char const   *)p);
    }
  }
  {
#line 64
  sym = sym_lookup("KERNELVERSION", 0);
#line 65
  sym->type = (enum symbol_type )5;
#line 66
  sym->flags |= 4096;
#line 67
  p = getenv("KERNELVERSION");
  }
#line 68
  if (p) {
    {
#line 69
    sym_add_default(sym, (char const   *)p);
    }
  }
  {
#line 71
  sym = sym_lookup("UNAME_RELEASE", 0);
#line 72
  sym->type = (enum symbol_type )5;
#line 73
  sym->flags |= 4096;
#line 74
  sym_add_default(sym, (char const   *)(uts.release));
  }
#line 75
  return;
}
}
#line 77 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
enum symbol_type sym_get_type(struct symbol *sym ) 
{ 
  enum symbol_type type ;
  _Bool tmp ;

  {
#line 79
  type = sym->type;
#line 81
  if ((unsigned int )type == 2U) {
    {
#line 82
    tmp = sym_is_choice_value(sym);
    }
#line 82
    if (tmp) {
#line 82
      if ((unsigned int )sym->visible == 2U) {
#line 83
        type = (enum symbol_type )1;
      } else {
#line 82
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 84
    if ((unsigned int )modules_val == 0U) {
#line 85
      type = (enum symbol_type )1;
    }
  }
#line 87
  return (type);
}
}
#line 90 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
char const   *sym_type_name(enum symbol_type type ) 
{ 


  {
  {
#line 93
  if ((unsigned int )type == 1U) {
#line 93
    goto case_1;
  }
#line 95
  if ((unsigned int )type == 2U) {
#line 95
    goto case_2;
  }
#line 97
  if ((unsigned int )type == 3U) {
#line 97
    goto case_3;
  }
#line 99
  if ((unsigned int )type == 4U) {
#line 99
    goto case_4;
  }
#line 101
  if ((unsigned int )type == 5U) {
#line 101
    goto case_5;
  }
#line 103
  if ((unsigned int )type == 0U) {
#line 103
    goto case_0;
  }
#line 105
  if ((unsigned int )type == 6U) {
#line 105
    goto case_6;
  }
#line 92
  goto switch_break;
  case_1: /* CIL Label */ 
#line 94
  return ("boolean");
  case_2: /* CIL Label */ 
#line 96
  return ("tristate");
  case_3: /* CIL Label */ 
#line 98
  return ("integer");
  case_4: /* CIL Label */ 
#line 100
  return ("hex");
  case_5: /* CIL Label */ 
#line 102
  return ("string");
  case_0: /* CIL Label */ 
#line 104
  return ("unknown");
  case_6: /* CIL Label */ 
#line 106
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 108
  return ("???");
}
}
#line 111 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct property *sym_get_choice_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 115
  prop = sym->prop;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! prop) {
#line 115
      goto while_break;
    }
#line 115
    if ((unsigned int )prop->type == 5U) {
#line 116
      return (prop);
    }
#line 115
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return ((struct property *)((void *)0));
}
}
#line 120 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct property *sym_get_default_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 124
  prop = sym->prop;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! prop) {
#line 124
      goto while_break;
    }
#line 124
    if ((unsigned int )prop->type == 4U) {
      {
#line 125
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 126
      if ((unsigned int )prop->visible.tri != 0U) {
#line 127
        return (prop);
      }
    }
#line 124
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return ((struct property *)((void *)0));
}
}
#line 132 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct property *sym_get_range_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 136
  prop = sym->prop;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! prop) {
#line 136
      goto while_break;
    }
#line 136
    if ((unsigned int )prop->type == 7U) {
      {
#line 137
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 138
      if ((unsigned int )prop->visible.tri != 0U) {
#line 139
        return (prop);
      }
    }
#line 136
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return ((struct property *)((void *)0));
}
}
#line 144 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
static int sym_get_range_val(struct symbol *sym , int base ) 
{ 
  long tmp ;

  {
  {
#line 146
  sym_calc_value(sym);
  }
  {
#line 148
  if ((unsigned int )sym->type == 3U) {
#line 148
    goto case_3;
  }
#line 151
  if ((unsigned int )sym->type == 4U) {
#line 151
    goto case_4;
  }
#line 154
  goto switch_default;
  case_3: /* CIL Label */ 
#line 149
  base = 10;
#line 150
  goto switch_break;
  case_4: /* CIL Label */ 
#line 152
  base = 16;
#line 153
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 155
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 157
  tmp = strtol((char const   */* __restrict  */)sym->curr.val, (char **/* __restrict  */)((void *)0),
               base);
  }
#line 157
  return ((int )tmp);
}
}
#line 160 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
static void sym_validate_range(struct symbol *sym ) 
{ 
  struct property *prop ;
  int base ;
  int val ;
  int val2 ;
  char str[64] ;
  long tmp ;
  char *tmp___0 ;

  {
  {
#line 167
  if ((unsigned int )sym->type == 3U) {
#line 167
    goto case_3;
  }
#line 170
  if ((unsigned int )sym->type == 4U) {
#line 170
    goto case_4;
  }
#line 173
  goto switch_default;
  case_3: /* CIL Label */ 
#line 168
  base = 10;
#line 169
  goto switch_break;
  case_4: /* CIL Label */ 
#line 171
  base = 16;
#line 172
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 174
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 176
  prop = sym_get_range_prop(sym);
  }
#line 177
  if (! prop) {
#line 178
    return;
  }
  {
#line 179
  tmp = strtol((char const   */* __restrict  */)sym->curr.val, (char **/* __restrict  */)((void *)0),
               base);
#line 179
  val = (int )tmp;
#line 180
  val2 = sym_get_range_val((prop->expr)->left.sym, base);
  }
#line 181
  if (val >= val2) {
    {
#line 182
    val2 = sym_get_range_val((prop->expr)->right.sym, base);
    }
#line 183
    if (val <= val2) {
#line 184
      return;
    }
  }
#line 186
  if ((unsigned int )sym->type == 3U) {
    {
#line 187
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%d",
            val2);
    }
  } else {
    {
#line 189
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"0x%x",
            val2);
    }
  }
  {
#line 190
  tmp___0 = strdup((char const   *)(str));
#line 190
  sym->curr.val = (void *)tmp___0;
  }
#line 191
  return;
}
}
#line 193 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
static void sym_calc_visibility(struct symbol *sym ) 
{ 
  struct property *prop ;
  tristate tri ;
  _Bool tmp ;
  enum symbol_type tmp___0 ;

  {
#line 199
  tri = (tristate )0;
#line 200
  prop = sym->prop;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! prop) {
#line 200
      goto while_break;
    }
#line 200
    if (prop->text) {
      {
#line 201
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 202
      if ((unsigned int )tri > (unsigned int )prop->visible.tri) {
#line 202
        tri = tri;
      } else {
#line 202
        tri = prop->visible.tri;
      }
    }
#line 200
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if ((unsigned int )tri == 1U) {
#line 204
    if ((unsigned int )sym->type != 2U) {
#line 205
      tri = (tristate )2;
    } else
#line 204
    if ((unsigned int )modules_val == 0U) {
#line 205
      tri = (tristate )2;
    }
  }
#line 206
  if ((unsigned int )sym->visible != (unsigned int )tri) {
    {
#line 207
    sym->visible = tri;
#line 208
    sym_set_changed(sym);
    }
  }
  {
#line 210
  tmp = sym_is_choice_value(sym);
  }
#line 210
  if (tmp) {
#line 211
    return;
  }
#line 212
  tri = (tristate )0;
#line 213
  if (sym->rev_dep.expr) {
    {
#line 214
    tri = expr_calc_value(sym->rev_dep.expr);
    }
  }
#line 215
  if ((unsigned int )tri == 1U) {
    {
#line 215
    tmp___0 = sym_get_type(sym);
    }
#line 215
    if ((unsigned int )tmp___0 == 1U) {
#line 216
      tri = (tristate )2;
    }
  }
#line 217
  if ((unsigned int )sym->rev_dep.tri != (unsigned int )tri) {
    {
#line 218
    sym->rev_dep.tri = tri;
#line 219
    sym_set_changed(sym);
    }
  }
#line 221
  return;
}
}
#line 223 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
static struct symbol *sym_calc_choice(struct symbol *sym ) 
{ 
  struct symbol *def_sym ;
  struct property *prop ;
  struct expr *e ;

  {
#line 230
  def_sym = (struct symbol *)sym->user.val;
#line 231
  if (def_sym) {
    {
#line 232
    sym_calc_visibility(def_sym);
    }
#line 233
    if ((unsigned int )def_sym->visible != 0U) {
#line 234
      return (def_sym);
    }
  }
#line 238
  prop = sym->prop;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! prop) {
#line 238
      goto while_break;
    }
#line 238
    if ((unsigned int )prop->type == 4U) {
      {
#line 239
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 240
      if ((unsigned int )prop->visible.tri == 0U) {
#line 241
        goto __Cont;
      }
      {
#line 242
      def_sym = prop_get_symbol(prop);
#line 243
      sym_calc_visibility(def_sym);
      }
#line 244
      if ((unsigned int )def_sym->visible != 0U) {
#line 245
        return (def_sym);
      }
    }
    __Cont: /* CIL Label */ 
#line 238
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  prop = sym_get_choice_prop(sym);
#line 250
  e = prop->expr;
  }
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 250
    if (! e) {
#line 250
      goto while_break___0;
    }
    {
#line 251
    def_sym = e->right.sym;
#line 252
    sym_calc_visibility(def_sym);
    }
#line 253
    if ((unsigned int )def_sym->visible != 0U) {
#line 254
      return (def_sym);
    }
#line 250
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 258
  sym->curr.tri = (tristate )0;
#line 259
  return ((struct symbol *)((void *)0));
}
}
#line 262 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
void sym_calc_value(struct symbol *sym ) 
{ 
  struct symbol_value newval ;
  struct symbol_value oldval ;
  struct property *prop ;
  struct expr *e ;
  _Bool tmp ;
  enum symbol_type tmp___0 ;
  struct symbol *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  _Bool tmp___8 ;
  unsigned int tmp___9 ;
  _Bool tmp___10 ;
  enum symbol_type tmp___11 ;
  _Bool tmp___12 ;
  struct symbol *ds ;
  struct symbol *tmp___13 ;
  struct symbol *tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  int flags ;
  _Bool tmp___17 ;

  {
#line 268
  if (! sym) {
#line 269
    return;
  }
#line 271
  if (sym->flags & 128) {
#line 272
    return;
  }
#line 273
  sym->flags |= 128;
#line 275
  oldval = sym->curr;
  {
#line 280
  if ((unsigned int )sym->type == 5U) {
#line 280
    goto case_5;
  }
#line 280
  if ((unsigned int )sym->type == 4U) {
#line 280
    goto case_5;
  }
#line 280
  if ((unsigned int )sym->type == 3U) {
#line 280
    goto case_5;
  }
#line 284
  if ((unsigned int )sym->type == 2U) {
#line 284
    goto case_2;
  }
#line 284
  if ((unsigned int )sym->type == 1U) {
#line 284
    goto case_2;
  }
#line 287
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 281
  newval = symbol_empty.curr;
#line 282
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 285
  newval = symbol_no.curr;
#line 286
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 288
  sym->curr.val = (void *)sym->name;
#line 289
  sym->curr.tri = (tristate )0;
#line 290
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 292
  tmp = sym_is_choice_value(sym);
  }
#line 292
  if (! tmp) {
#line 293
    sym->flags &= -513;
  }
  {
#line 295
  sym_calc_visibility(sym);
#line 298
  sym->curr = newval;
#line 300
  tmp___0 = sym_get_type(sym);
  }
  {
#line 302
  if ((unsigned int )tmp___0 == 2U) {
#line 302
    goto case_2___0;
  }
#line 302
  if ((unsigned int )tmp___0 == 1U) {
#line 302
    goto case_2___0;
  }
#line 328
  if ((unsigned int )tmp___0 == 3U) {
#line 328
    goto case_3___0;
  }
#line 328
  if ((unsigned int )tmp___0 == 4U) {
#line 328
    goto case_3___0;
  }
#line 328
  if ((unsigned int )tmp___0 == 5U) {
#line 328
    goto case_3___0;
  }
#line 346
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  {
#line 303
  tmp___10 = sym_is_choice_value(sym);
  }
#line 303
  if (tmp___10) {
#line 303
    if ((unsigned int )sym->visible == 2U) {
      {
#line 304
      prop = sym_get_choice_prop(sym);
#line 305
      tmp___2 = prop_get_symbol(prop);
      }
#line 305
      if ((unsigned long )tmp___2->curr.val == (unsigned long )sym) {
#line 305
        newval.tri = (tristate )2;
      } else {
#line 305
        newval.tri = (tristate )0;
      }
    } else {
#line 303
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 306
    if ((unsigned int )sym->visible > (unsigned int )sym->rev_dep.tri) {
#line 306
      tmp___9 = (unsigned int )sym->visible;
    } else {
#line 306
      tmp___9 = (unsigned int )sym->rev_dep.tri;
    }
#line 306
    if (tmp___9 != 0U) {
      {
#line 307
      sym->flags |= 512;
#line 308
      tmp___4 = sym_has_value(sym);
      }
#line 308
      if (tmp___4) {
#line 309
        newval.tri = sym->user.tri;
      } else {
        {
#line 310
        tmp___3 = sym_is_choice(sym);
        }
#line 310
        if (! tmp___3) {
          {
#line 311
          prop = sym_get_default_prop(sym);
          }
#line 312
          if (prop) {
            {
#line 313
            newval.tri = expr_calc_value(prop->expr);
            }
          }
        }
      }
#line 315
      if ((unsigned int )newval.tri < (unsigned int )sym->visible) {
#line 315
        tmp___7 = (unsigned int )newval.tri;
      } else {
#line 315
        tmp___7 = (unsigned int )sym->visible;
      }
#line 315
      if (tmp___7 > (unsigned int )sym->rev_dep.tri) {
#line 315
        if ((unsigned int )newval.tri < (unsigned int )sym->visible) {
#line 315
          tmp___6 = (unsigned int )newval.tri;
        } else {
#line 315
          tmp___6 = (unsigned int )sym->visible;
        }
#line 315
        newval.tri = (tristate )tmp___6;
      } else {
#line 315
        newval.tri = sym->rev_dep.tri;
      }
    } else {
      {
#line 316
      tmp___8 = sym_is_choice(sym);
      }
#line 316
      if (! tmp___8) {
        {
#line 317
        prop = sym_get_default_prop(sym);
        }
#line 318
        if (prop) {
          {
#line 319
          sym->flags |= 512;
#line 320
          newval.tri = expr_calc_value(prop->expr);
          }
        }
      }
    }
  }
#line 323
  if ((unsigned int )newval.tri == 1U) {
    {
#line 323
    tmp___11 = sym_get_type(sym);
    }
#line 323
    if ((unsigned int )tmp___11 == 1U) {
#line 324
      newval.tri = (tristate )2;
    }
  }
#line 325
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
#line 329
  if ((unsigned int )sym->visible != 0U) {
    {
#line 330
    sym->flags |= 512;
#line 331
    tmp___12 = sym_has_value(sym);
    }
#line 331
    if (tmp___12) {
#line 332
      newval.val = sym->user.val;
#line 333
      goto switch_break___0;
    }
  }
  {
#line 336
  prop = sym_get_default_prop(sym);
  }
#line 337
  if (prop) {
    {
#line 338
    tmp___13 = prop_get_symbol(prop);
#line 338
    ds = tmp___13;
    }
#line 339
    if (ds) {
      {
#line 340
      sym->flags |= 512;
#line 341
      sym_calc_value(ds);
#line 342
      newval.val = ds->curr.val;
      }
    }
  }
#line 345
  goto switch_break___0;
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 350
  sym->curr = newval;
#line 351
  tmp___15 = sym_is_choice(sym);
  }
#line 351
  if (tmp___15) {
#line 351
    if ((unsigned int )newval.tri == 2U) {
      {
#line 352
      tmp___14 = sym_calc_choice(sym);
#line 352
      sym->curr.val = (void *)tmp___14;
      }
    }
  }
  {
#line 353
  sym_validate_range(sym);
#line 355
  tmp___16 = memcmp((void const   *)(& oldval), (void const   *)(& sym->curr), sizeof(oldval));
  }
#line 355
  if (tmp___16) {
    {
#line 356
    sym_set_changed(sym);
    }
  }
#line 357
  if ((unsigned long )modules_sym == (unsigned long )sym) {
#line 358
    modules_val = modules_sym->curr.tri;
  }
  {
#line 360
  tmp___17 = sym_is_choice(sym);
  }
#line 360
  if (tmp___17) {
    {
#line 361
    flags = sym->flags & 1536;
#line 362
    prop = sym_get_choice_prop(sym);
#line 363
    e = prop->expr;
    }
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
#line 363
      if (! e) {
#line 363
        goto while_break;
      }
#line 364
      (e->right.sym)->flags |= flags;
#line 365
      if (flags & 1024) {
        {
#line 366
        sym_set_changed(e->right.sym);
        }
      }
#line 363
      e = e->left.expr;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 369
  return;
}
}
#line 371 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
void sym_clear_all_valid(void) 
{ 
  struct symbol *sym ;
  int i ;

  {
#line 376
  i = 0;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < 257)) {
#line 376
      goto while_break;
    }
#line 376
    sym = symbol_hash[i];
    {
#line 376
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 376
      if (! sym) {
#line 376
        goto while_break___0;
      }
#line 376
      if ((unsigned int )sym->type != 6U) {
#line 377
        sym->flags &= -129;
      }
#line 376
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 376
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  sym_change_count ++;
#line 379
  if (modules_sym) {
    {
#line 380
    sym_calc_value(modules_sym);
    }
  }
#line 381
  return;
}
}
#line 383 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
void sym_set_changed(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 387
  sym->flags |= 1024;
#line 388
  prop = sym->prop;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! prop) {
#line 388
      goto while_break;
    }
#line 389
    if (prop->menu) {
#line 390
      (prop->menu)->flags |= 1U;
    }
#line 388
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 394 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
void sym_set_all_changed(void) 
{ 
  struct symbol *sym ;
  int i ;

  {
#line 399
  i = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (i < 257)) {
#line 399
      goto while_break;
    }
#line 399
    sym = symbol_hash[i];
    {
#line 399
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 399
      if (! sym) {
#line 399
        goto while_break___0;
      }
#line 399
      if ((unsigned int )sym->type != 6U) {
        {
#line 400
        sym_set_changed(sym);
        }
      }
#line 399
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 399
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return;
}
}
#line 403 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
_Bool sym_tristate_within_range(struct symbol *sym , tristate val ) 
{ 
  int type ;
  enum symbol_type tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 405
  tmp = sym_get_type(sym);
#line 405
  type = (int )tmp;
  }
#line 407
  if ((unsigned int )sym->visible == 0U) {
#line 408
    return ((_Bool)0);
  }
#line 410
  if (type != 1) {
#line 410
    if (type != 2) {
#line 411
      return ((_Bool)0);
    }
  }
#line 413
  if (type == 1) {
#line 413
    if ((unsigned int )val == 1U) {
#line 414
      return ((_Bool)0);
    }
  }
#line 415
  if ((unsigned int )sym->visible <= (unsigned int )sym->rev_dep.tri) {
#line 416
    return ((_Bool)0);
  }
  {
#line 417
  tmp___0 = sym_is_choice_value(sym);
  }
#line 417
  if (tmp___0) {
#line 417
    if ((unsigned int )sym->visible == 2U) {
#line 418
      return ((_Bool )((unsigned int )val == 2U));
    }
  }
#line 419
  if ((unsigned int )val >= (unsigned int )sym->rev_dep.tri) {
#line 419
    if ((unsigned int )val <= (unsigned int )sym->visible) {
#line 419
      tmp___1 = 1;
    } else {
#line 419
      tmp___1 = 0;
    }
  } else {
#line 419
    tmp___1 = 0;
  }
#line 419
  return ((_Bool )tmp___1);
}
}
#line 422 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
_Bool sym_set_tristate_value(struct symbol *sym , tristate val ) 
{ 
  tristate oldval ;
  tristate tmp ;
  _Bool tmp___0 ;
  struct symbol *cs ;
  struct property *tmp___1 ;
  struct symbol *tmp___2 ;
  struct property *prop ;
  struct expr *e ;
  _Bool tmp___3 ;

  {
  {
#line 424
  tmp = sym_get_tristate_value(sym);
#line 424
  oldval = tmp;
  }
#line 426
  if ((unsigned int )oldval != (unsigned int )val) {
    {
#line 426
    tmp___0 = sym_tristate_within_range(sym, val);
    }
#line 426
    if (! tmp___0) {
#line 427
      return ((_Bool)0);
    }
  }
#line 429
  if (sym->flags & 2048) {
    {
#line 430
    sym->flags &= -2049;
#line 431
    sym_set_changed(sym);
    }
  }
  {
#line 437
  tmp___3 = sym_is_choice_value(sym);
  }
#line 437
  if (tmp___3) {
#line 437
    if ((unsigned int )val == 2U) {
      {
#line 438
      tmp___1 = sym_get_choice_prop(sym);
#line 438
      tmp___2 = prop_get_symbol(tmp___1);
#line 438
      cs = tmp___2;
#line 442
      cs->user.val = (void *)sym;
#line 443
      cs->flags &= -2049;
#line 444
      prop = sym_get_choice_prop(cs);
#line 445
      e = prop->expr;
      }
      {
#line 445
      while (1) {
        while_continue: /* CIL Label */ ;
#line 445
        if (! e) {
#line 445
          goto while_break;
        }
#line 446
        if ((unsigned int )(e->right.sym)->visible != 0U) {
#line 447
          (e->right.sym)->flags &= -2049;
        }
#line 445
        e = e->left.expr;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 451
  sym->user.tri = val;
#line 452
  if ((unsigned int )oldval != (unsigned int )val) {
    {
#line 453
    sym_clear_all_valid();
    }
#line 454
    if ((unsigned long )sym == (unsigned long )modules_sym) {
      {
#line 455
      sym_set_all_changed();
      }
    }
  }
#line 458
  return ((_Bool)1);
}
}
#line 461 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
tristate sym_toggle_tristate_value(struct symbol *sym ) 
{ 
  tristate oldval ;
  tristate newval ;
  _Bool tmp ;

  {
  {
#line 465
  newval = sym_get_tristate_value(sym);
#line 465
  oldval = newval;
  }
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 468
    if ((unsigned int )newval == 0U) {
#line 468
      goto case_0;
    }
#line 471
    if ((unsigned int )newval == 1U) {
#line 471
      goto case_1;
    }
#line 474
    if ((unsigned int )newval == 2U) {
#line 474
      goto case_2;
    }
#line 467
    goto switch_break;
    case_0: /* CIL Label */ 
#line 469
    newval = (tristate )1;
#line 470
    goto switch_break;
    case_1: /* CIL Label */ 
#line 472
    newval = (tristate )2;
#line 473
    goto switch_break;
    case_2: /* CIL Label */ 
#line 475
    newval = (tristate )0;
#line 476
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 478
    tmp = sym_set_tristate_value(sym, newval);
    }
#line 478
    if (tmp) {
#line 479
      goto while_break;
    }
#line 466
    if (! ((unsigned int )oldval != (unsigned int )newval)) {
#line 466
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  return (newval);
}
}
#line 484 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
_Bool sym_string_valid(struct symbol *sym , char const   *str ) 
{ 
  signed char ch ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 489
  if ((unsigned int )sym->type == 5U) {
#line 489
    goto case_5;
  }
#line 491
  if ((unsigned int )sym->type == 3U) {
#line 491
    goto case_3;
  }
#line 504
  if ((unsigned int )sym->type == 4U) {
#line 504
    goto case_4;
  }
#line 514
  if ((unsigned int )sym->type == 2U) {
#line 514
    goto case_2;
  }
#line 514
  if ((unsigned int )sym->type == 1U) {
#line 514
    goto case_2;
  }
#line 522
  goto switch_default;
  case_5: /* CIL Label */ 
#line 490
  return ((_Bool)1);
  case_3: /* CIL Label */ 
#line 492
  tmp = str;
#line 492
  str ++;
#line 492
  ch = (signed char )*tmp;
#line 493
  if ((int )ch == 45) {
#line 494
    tmp___0 = str;
#line 494
    str ++;
#line 494
    ch = (signed char )*tmp___0;
  }
  {
#line 495
  tmp___1 = __ctype_b_loc();
  }
#line 495
  if (! ((int const   )*(*tmp___1 + (int )ch) & 2048)) {
#line 496
    return ((_Bool)0);
  }
#line 497
  if ((int )ch == 48) {
#line 497
    if ((int const   )*str != 0) {
#line 498
      return ((_Bool)0);
    }
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    tmp___3 = str;
#line 499
    str ++;
#line 499
    ch = (signed char )*tmp___3;
#line 499
    if (! ch) {
#line 499
      goto while_break;
    }
    {
#line 500
    tmp___2 = __ctype_b_loc();
    }
#line 500
    if (! ((int const   )*(*tmp___2 + (int )ch) & 2048)) {
#line 501
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  return ((_Bool)1);
  case_4: /* CIL Label */ 
#line 505
  if ((int const   )*(str + 0) == 48) {
#line 505
    if ((int const   )*(str + 1) == 120) {
#line 506
      str += 2;
    } else
#line 505
    if ((int const   )*(str + 1) == 88) {
#line 506
      str += 2;
    }
  }
#line 507
  tmp___4 = str;
#line 507
  str ++;
#line 507
  ch = (signed char )*tmp___4;
  {
#line 508
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 509
    tmp___5 = __ctype_b_loc();
    }
#line 509
    if (! ((int const   )*(*tmp___5 + (int )ch) & 4096)) {
#line 510
      return ((_Bool)0);
    }
#line 508
    tmp___6 = str;
#line 508
    str ++;
#line 508
    ch = (signed char )*tmp___6;
#line 508
    if (! ch) {
#line 508
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 512
  return ((_Bool)1);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 518
  if ((int const   )*(str + 0) == 78) {
#line 518
    goto case_78;
  }
#line 518
  if ((int const   )*(str + 0) == 110) {
#line 518
    goto case_78;
  }
#line 518
  if ((int const   )*(str + 0) == 77) {
#line 518
    goto case_78;
  }
#line 518
  if ((int const   )*(str + 0) == 109) {
#line 518
    goto case_78;
  }
#line 518
  if ((int const   )*(str + 0) == 89) {
#line 518
    goto case_78;
  }
#line 518
  if ((int const   )*(str + 0) == 121) {
#line 518
    goto case_78;
  }
#line 515
  goto switch_break___0;
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
#line 519
  return ((_Bool)1);
  switch_break___0: /* CIL Label */ ;
  }
#line 521
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 523
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 527 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
_Bool sym_string_within_range(struct symbol *sym , char const   *str ) 
{ 
  struct property *prop ;
  int val ;
  _Bool tmp ;
  _Bool tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;

  {
  {
#line 533
  if ((unsigned int )sym->type == 5U) {
#line 533
    goto case_5;
  }
#line 535
  if ((unsigned int )sym->type == 3U) {
#line 535
    goto case_3;
  }
#line 544
  if ((unsigned int )sym->type == 4U) {
#line 544
    goto case_4;
  }
#line 554
  if ((unsigned int )sym->type == 2U) {
#line 554
    goto case_2;
  }
#line 554
  if ((unsigned int )sym->type == 1U) {
#line 554
    goto case_2;
  }
#line 564
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 534
  tmp = sym_string_valid(sym, str);
  }
#line 534
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 536
  tmp___0 = sym_string_valid(sym, str);
  }
#line 536
  if (! tmp___0) {
#line 537
    return ((_Bool)0);
  }
  {
#line 538
  prop = sym_get_range_prop(sym);
  }
#line 539
  if (! prop) {
#line 540
    return ((_Bool)1);
  }
  {
#line 541
  tmp___1 = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
                   10);
#line 541
  val = (int )tmp___1;
#line 542
  tmp___2 = sym_get_range_val((prop->expr)->left.sym, 10);
  }
#line 542
  if (val >= tmp___2) {
    {
#line 542
    tmp___3 = sym_get_range_val((prop->expr)->right.sym, 10);
    }
#line 542
    if (val <= tmp___3) {
#line 542
      tmp___4 = 1;
    } else {
#line 542
      tmp___4 = 0;
    }
  } else {
#line 542
    tmp___4 = 0;
  }
#line 542
  return ((_Bool )tmp___4);
  case_4: /* CIL Label */ 
  {
#line 545
  tmp___5 = sym_string_valid(sym, str);
  }
#line 545
  if (! tmp___5) {
#line 546
    return ((_Bool)0);
  }
  {
#line 547
  prop = sym_get_range_prop(sym);
  }
#line 548
  if (! prop) {
#line 549
    return ((_Bool)1);
  }
  {
#line 550
  tmp___6 = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
                   16);
#line 550
  val = (int )tmp___6;
#line 551
  tmp___7 = sym_get_range_val((prop->expr)->left.sym, 16);
  }
#line 551
  if (val >= tmp___7) {
    {
#line 551
    tmp___8 = sym_get_range_val((prop->expr)->right.sym, 16);
    }
#line 551
    if (val <= tmp___8) {
#line 551
      tmp___9 = 1;
    } else {
#line 551
      tmp___9 = 0;
    }
  } else {
#line 551
    tmp___9 = 0;
  }
#line 551
  return ((_Bool )tmp___9);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 556
  if ((int const   )*(str + 0) == 89) {
#line 556
    goto case_89;
  }
#line 556
  if ((int const   )*(str + 0) == 121) {
#line 556
    goto case_89;
  }
#line 558
  if ((int const   )*(str + 0) == 77) {
#line 558
    goto case_77;
  }
#line 558
  if ((int const   )*(str + 0) == 109) {
#line 558
    goto case_77;
  }
#line 560
  if ((int const   )*(str + 0) == 78) {
#line 560
    goto case_78;
  }
#line 560
  if ((int const   )*(str + 0) == 110) {
#line 560
    goto case_78;
  }
#line 555
  goto switch_break___0;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
#line 557
  tmp___10 = sym_tristate_within_range(sym, (tristate )2);
  }
#line 557
  return (tmp___10);
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  {
#line 559
  tmp___11 = sym_tristate_within_range(sym, (tristate )1);
  }
#line 559
  return (tmp___11);
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 561
  tmp___12 = sym_tristate_within_range(sym, (tristate )0);
  }
#line 561
  return (tmp___12);
  switch_break___0: /* CIL Label */ ;
  }
#line 563
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 565
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 569 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
_Bool sym_set_string_value(struct symbol *sym , char const   *newval ) 
{ 
  char const   *oldval ;
  char *val ;
  int size ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 577
  if ((unsigned int )sym->type == 2U) {
#line 577
    goto case_2;
  }
#line 577
  if ((unsigned int )sym->type == 1U) {
#line 577
    goto case_2;
  }
#line 587
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 579
  if ((int const   )*(newval + 0) == 89) {
#line 579
    goto case_89;
  }
#line 579
  if ((int const   )*(newval + 0) == 121) {
#line 579
    goto case_89;
  }
#line 581
  if ((int const   )*(newval + 0) == 77) {
#line 581
    goto case_77;
  }
#line 581
  if ((int const   )*(newval + 0) == 109) {
#line 581
    goto case_77;
  }
#line 583
  if ((int const   )*(newval + 0) == 78) {
#line 583
    goto case_78;
  }
#line 583
  if ((int const   )*(newval + 0) == 110) {
#line 583
    goto case_78;
  }
#line 578
  goto switch_break___0;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
#line 580
  tmp = sym_set_tristate_value(sym, (tristate )2);
  }
#line 580
  return (tmp);
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  {
#line 582
  tmp___0 = sym_set_tristate_value(sym, (tristate )1);
  }
#line 582
  return (tmp___0);
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 584
  tmp___1 = sym_set_tristate_value(sym, (tristate )0);
  }
#line 584
  return (tmp___1);
  switch_break___0: /* CIL Label */ ;
  }
#line 586
  return ((_Bool)0);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 591
  tmp___2 = sym_string_within_range(sym, newval);
  }
#line 591
  if (! tmp___2) {
#line 592
    return ((_Bool)0);
  }
#line 594
  if (sym->flags & 2048) {
    {
#line 595
    sym->flags &= -2049;
#line 596
    sym_set_changed(sym);
    }
  }
  {
#line 599
  oldval = (char const   *)sym->user.val;
#line 600
  tmp___3 = strlen(newval);
#line 600
  size = (int )(tmp___3 + 1UL);
  }
#line 601
  if ((unsigned int )sym->type == 4U) {
#line 601
    if ((int const   )*(newval + 0) != 48) {
#line 601
      goto _L___0;
    } else
#line 601
    if ((int const   )*(newval + 1) != 120) {
#line 601
      if ((int const   )*(newval + 1) != 88) {
        _L___0: /* CIL Label */ 
        {
#line 602
        size += 2;
#line 603
        tmp___4 = malloc((size_t )size);
#line 603
        val = (char *)tmp___4;
#line 603
        sym->user.val = (void *)val;
#line 604
        tmp___5 = val;
#line 604
        val ++;
#line 604
        *tmp___5 = (char )'0';
#line 605
        tmp___6 = val;
#line 605
        val ++;
#line 605
        *tmp___6 = (char )'x';
        }
      } else {
#line 601
        goto _L;
      }
    } else {
#line 601
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 606
  if (! oldval) {
    {
#line 607
    tmp___7 = malloc((size_t )size);
#line 607
    val = (char *)tmp___7;
#line 607
    sym->user.val = (void *)val;
    }
  } else {
    {
#line 606
    tmp___8 = strcmp(oldval, newval);
    }
#line 606
    if (tmp___8) {
      {
#line 607
      tmp___7 = malloc((size_t )size);
#line 607
      val = (char *)tmp___7;
#line 607
      sym->user.val = (void *)val;
      }
    } else {
#line 609
      return ((_Bool)1);
    }
  }
  {
#line 611
  strcpy((char */* __restrict  */)val, (char const   */* __restrict  */)newval);
#line 612
  free((void *)oldval);
#line 613
  sym_clear_all_valid();
  }
#line 615
  return ((_Bool)1);
}
}
#line 618 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
char const   *sym_get_string_value(struct symbol *sym ) 
{ 
  tristate val ;

  {
  {
#line 624
  if ((unsigned int )sym->type == 2U) {
#line 624
    goto case_2;
  }
#line 624
  if ((unsigned int )sym->type == 1U) {
#line 624
    goto case_2;
  }
#line 635
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 625
  val = sym_get_tristate_value(sym);
  }
  {
#line 627
  if ((unsigned int )val == 0U) {
#line 627
    goto case_0;
  }
#line 629
  if ((unsigned int )val == 1U) {
#line 629
    goto case_1___0;
  }
#line 631
  if ((unsigned int )val == 2U) {
#line 631
    goto case_2___0;
  }
#line 626
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 628
  return ("n");
  case_1___0: /* CIL Label */ 
#line 630
  return ("m");
  case_2___0: /* CIL Label */ 
#line 632
  return ("y");
  switch_break___0: /* CIL Label */ ;
  }
#line 634
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 638
  return ((char const   *)sym->curr.val);
}
}
#line 641 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
_Bool sym_is_changable(struct symbol *sym ) 
{ 


  {
#line 643
  return ((_Bool )((unsigned int )sym->visible > (unsigned int )sym->rev_dep.tri));
}
}
#line 646 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct symbol *sym_lookup(char const   *name , int isconst ) 
{ 
  struct symbol *symbol ;
  char const   *ptr ;
  char *new_name ;
  int hash ;
  int tmp ;
  void *tmp___0 ;

  {
#line 651
  hash = 0;
#line 653
  if (name) {
#line 654
    if (*(name + 0)) {
#line 654
      if (! *(name + 1)) {
        {
#line 656
        if ((int const   )*(name + 0) == 121) {
#line 656
          goto case_121;
        }
#line 657
        if ((int const   )*(name + 0) == 109) {
#line 657
          goto case_109;
        }
#line 658
        if ((int const   )*(name + 0) == 110) {
#line 658
          goto case_110;
        }
#line 655
        goto switch_break;
        case_121: /* CIL Label */ 
#line 656
        return (& symbol_yes);
        case_109: /* CIL Label */ 
#line 657
        return (& symbol_mod);
        case_110: /* CIL Label */ 
#line 658
        return (& symbol_no);
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 661
    ptr = name;
    {
#line 661
    while (1) {
      while_continue: /* CIL Label */ ;
#line 661
      if (! *ptr) {
#line 661
        goto while_break;
      }
#line 662
      hash += (int )*ptr;
#line 661
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 663
    hash &= 255;
#line 665
    symbol = symbol_hash[hash];
    {
#line 665
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 665
      if (! symbol) {
#line 665
        goto while_break___0;
      }
      {
#line 666
      tmp = strcmp((char const   *)symbol->name, name);
      }
#line 666
      if (! tmp) {
#line 667
        if (isconst) {
#line 667
          if (symbol->flags & 7) {
#line 669
            return (symbol);
          } else {
#line 667
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 667
        if (! isconst) {
#line 667
          if (! (symbol->flags & 7)) {
#line 669
            return (symbol);
          }
        }
      }
#line 665
      symbol = symbol->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 672
    new_name = strdup(name);
    }
  } else {
#line 674
    new_name = (char *)((void *)0);
#line 675
    hash = 256;
  }
  {
#line 678
  tmp___0 = malloc(sizeof(*symbol));
#line 678
  symbol = (struct symbol *)tmp___0;
#line 679
  memset((void *)symbol, 0, sizeof(*symbol));
#line 680
  symbol->name = new_name;
#line 681
  symbol->type = (enum symbol_type )0;
#line 682
  symbol->flags = 2048;
  }
#line 683
  if (isconst) {
#line 684
    symbol->flags |= 7;
  }
#line 686
  symbol->next = symbol_hash[hash];
#line 687
  symbol_hash[hash] = symbol;
#line 689
  return (symbol);
}
}
#line 692 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct symbol *sym_find(char const   *name ) 
{ 
  struct symbol *symbol ;
  char const   *ptr ;
  int hash ;
  int tmp ;

  {
#line 694
  symbol = (struct symbol *)((void *)0);
#line 696
  hash = 0;
#line 698
  if (! name) {
#line 699
    return ((struct symbol *)((void *)0));
  }
#line 701
  if (*(name + 0)) {
#line 701
    if (! *(name + 1)) {
      {
#line 703
      if ((int const   )*(name + 0) == 121) {
#line 703
        goto case_121;
      }
#line 704
      if ((int const   )*(name + 0) == 109) {
#line 704
        goto case_109;
      }
#line 705
      if ((int const   )*(name + 0) == 110) {
#line 705
        goto case_110;
      }
#line 702
      goto switch_break;
      case_121: /* CIL Label */ 
#line 703
      return (& symbol_yes);
      case_109: /* CIL Label */ 
#line 704
      return (& symbol_mod);
      case_110: /* CIL Label */ 
#line 705
      return (& symbol_no);
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 708
  ptr = name;
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! *ptr) {
#line 708
      goto while_break;
    }
#line 709
    hash += (int )*ptr;
#line 708
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  hash &= 255;
#line 712
  symbol = symbol_hash[hash];
  {
#line 712
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 712
    if (! symbol) {
#line 712
      goto while_break___0;
    }
    {
#line 713
    tmp = strcmp((char const   *)symbol->name, name);
    }
#line 713
    if (! tmp) {
#line 713
      if (! (symbol->flags & 7)) {
#line 715
        goto while_break___0;
      }
    }
#line 712
    symbol = symbol->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 718
  return (symbol);
}
}
#line 721 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct symbol **sym_re_search(char const   *pattern ) 
{ 
  struct symbol *sym ;
  struct symbol **sym_arr ;
  int i ;
  int cnt ;
  int size ;
  regex_t re ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 723
  sym_arr = (struct symbol **)((void *)0);
#line 727
  size = 0;
#line 727
  cnt = size;
#line 729
  tmp = strlen(pattern);
  }
#line 729
  if (tmp == 0UL) {
#line 730
    return ((struct symbol **)((void *)0));
  }
  {
#line 731
  tmp___0 = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)pattern,
                    (1 | (((1 << 1) << 1) << 1)) | (1 << 1));
  }
#line 731
  if (tmp___0) {
#line 732
    return ((struct symbol **)((void *)0));
  }
#line 734
  i = 0;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! (i < 257)) {
#line 734
      goto while_break;
    }
#line 734
    sym = symbol_hash[i];
    {
#line 734
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 734
      if (! sym) {
#line 734
        goto while_break___0;
      }
#line 734
      if ((unsigned int )sym->type != 6U) {
#line 735
        if (sym->flags & 7) {
#line 736
          goto __Cont;
        } else
#line 735
        if (! sym->name) {
#line 736
          goto __Cont;
        }
        {
#line 737
        tmp___1 = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)sym->name,
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
        }
#line 737
        if (tmp___1) {
#line 738
          goto __Cont;
        }
#line 739
        if (cnt + 1 >= size) {
          {
#line 740
          tmp___2 = (void *)sym_arr;
#line 741
          size += 16;
#line 742
          tmp___3 = realloc((void *)sym_arr, (unsigned long )size * sizeof(struct symbol *));
#line 742
          sym_arr = (struct symbol **)tmp___3;
          }
#line 743
          if (! sym_arr) {
            {
#line 744
            free(tmp___2);
            }
#line 745
            return ((struct symbol **)((void *)0));
          }
        }
#line 748
        tmp___4 = cnt;
#line 748
        cnt ++;
#line 748
        *(sym_arr + tmp___4) = sym;
      }
      __Cont: /* CIL Label */ 
#line 734
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 734
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 750
  if (sym_arr) {
#line 751
    *(sym_arr + cnt) = (struct symbol *)((void *)0);
  }
  {
#line 752
  regfree(& re);
  }
#line 754
  return (sym_arr);
}
}
#line 760 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_expr_deps(struct expr *e ) 
{ 
  struct symbol *sym ;
  struct symbol *tmp ;
  struct symbol *tmp___0 ;
  struct symbol *tmp___1 ;
  struct symbol *tmp___2 ;

  {
#line 764
  if (! e) {
#line 765
    return ((struct symbol *)((void *)0));
  }
  {
#line 768
  if ((unsigned int )e->type == 2U) {
#line 768
    goto case_2;
  }
#line 768
  if ((unsigned int )e->type == 1U) {
#line 768
    goto case_2;
  }
#line 773
  if ((unsigned int )e->type == 3U) {
#line 773
    goto case_3;
  }
#line 776
  if ((unsigned int )e->type == 5U) {
#line 776
    goto case_5;
  }
#line 776
  if ((unsigned int )e->type == 4U) {
#line 776
    goto case_5;
  }
#line 781
  if ((unsigned int )e->type == 7U) {
#line 781
    goto case_7;
  }
#line 783
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 769
  sym = sym_check_expr_deps(e->left.expr);
  }
#line 770
  if (sym) {
#line 771
    return (sym);
  }
  {
#line 772
  tmp = sym_check_expr_deps(e->right.expr);
  }
#line 772
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 774
  tmp___0 = sym_check_expr_deps(e->left.expr);
  }
#line 774
  return (tmp___0);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 777
  sym = sym_check_deps(e->left.sym);
  }
#line 778
  if (sym) {
#line 779
    return (sym);
  }
  {
#line 780
  tmp___1 = sym_check_deps(e->right.sym);
  }
#line 780
  return (tmp___1);
  case_7: /* CIL Label */ 
  {
#line 782
  tmp___2 = sym_check_deps(e->left.sym);
  }
#line 782
  return (tmp___2);
  switch_default: /* CIL Label */ 
#line 784
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 786
  printf((char const   */* __restrict  */)"Oops! How to check %d?\n", (unsigned int )e->type);
  }
#line 787
  return ((struct symbol *)((void *)0));
}
}
#line 790 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct symbol *sym_check_deps(struct symbol *sym ) 
{ 
  struct symbol *sym2 ;
  struct property *prop ;
  _Bool tmp ;

  {
#line 795
  if (sym->flags & 8) {
    {
#line 796
    printf((char const   */* __restrict  */)"Warning! Found recursive dependency: %s",
           sym->name);
    }
#line 797
    return (sym);
  }
#line 799
  if (sym->flags & 8192) {
#line 800
    return ((struct symbol *)((void *)0));
  }
  {
#line 802
  sym->flags |= 8200;
#line 803
  sym2 = sym_check_expr_deps(sym->rev_dep.expr);
  }
#line 804
  if (sym2) {
#line 805
    goto out;
  }
#line 807
  prop = sym->prop;
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 807
    if (! prop) {
#line 807
      goto while_break;
    }
#line 808
    if ((unsigned int )prop->type == 5U) {
#line 809
      goto __Cont;
    } else
#line 808
    if ((unsigned int )prop->type == 6U) {
#line 809
      goto __Cont;
    }
    {
#line 810
    sym2 = sym_check_expr_deps(prop->visible.expr);
    }
#line 811
    if (sym2) {
#line 812
      goto out;
    }
#line 813
    if ((unsigned int )prop->type != 4U) {
#line 814
      goto __Cont;
    } else {
      {
#line 813
      tmp = sym_is_choice(sym);
      }
#line 813
      if (tmp) {
#line 814
        goto __Cont;
      }
    }
    {
#line 815
    sym2 = sym_check_expr_deps(prop->expr);
    }
#line 816
    if (sym2) {
#line 817
      goto out;
    }
    __Cont: /* CIL Label */ 
#line 807
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 820
  if (sym2) {
    {
#line 821
    printf((char const   */* __restrict  */)" %s", sym->name);
    }
#line 822
    if ((unsigned long )sym2 == (unsigned long )sym) {
      {
#line 823
      printf((char const   */* __restrict  */)"\n");
#line 824
      sym2 = (struct symbol *)((void *)0);
      }
    }
  }
#line 827
  sym->flags &= -9;
#line 828
  return (sym2);
}
}
#line 831 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct property *prop_alloc(enum prop_type type , struct symbol *sym ) 
{ 
  struct property *prop ;
  struct property **propp ;
  void *tmp ;

  {
  {
#line 836
  tmp = malloc(sizeof(*prop));
#line 836
  prop = (struct property *)tmp;
#line 837
  memset((void *)prop, 0, sizeof(*prop));
#line 838
  prop->type = type;
#line 839
  prop->sym = sym;
#line 840
  prop->file = current_file;
#line 841
  prop->lineno = zconf_lineno();
  }
#line 844
  if (sym) {
#line 845
    propp = & sym->prop;
    {
#line 845
    while (1) {
      while_continue: /* CIL Label */ ;
#line 845
      if (! *propp) {
#line 845
        goto while_break;
      }
#line 845
      propp = & (*propp)->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 847
    *propp = prop;
  }
#line 850
  return (prop);
}
}
#line 853 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
struct symbol *prop_get_symbol(struct property *prop ) 
{ 


  {
#line 855
  if (prop->expr) {
#line 855
    if ((unsigned int )(prop->expr)->type == 7U) {
#line 857
      return ((prop->expr)->left.sym);
    } else
#line 855
    if ((unsigned int )(prop->expr)->type == 6U) {
#line 857
      return ((prop->expr)->left.sym);
    }
  }
#line 858
  return ((struct symbol *)((void *)0));
}
}
#line 861 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/symbol.c"
char const   *prop_get_type_name(enum prop_type type ) 
{ 


  {
  {
#line 864
  if ((unsigned int )type == 1U) {
#line 864
    goto case_1;
  }
#line 866
  if ((unsigned int )type == 2U) {
#line 866
    goto case_2;
  }
#line 868
  if ((unsigned int )type == 3U) {
#line 868
    goto case_3;
  }
#line 870
  if ((unsigned int )type == 4U) {
#line 870
    goto case_4;
  }
#line 872
  if ((unsigned int )type == 5U) {
#line 872
    goto case_5;
  }
#line 874
  if ((unsigned int )type == 6U) {
#line 874
    goto case_6;
  }
#line 876
  if ((unsigned int )type == 7U) {
#line 876
    goto case_7;
  }
#line 878
  if ((unsigned int )type == 0U) {
#line 878
    goto case_0;
  }
#line 863
  goto switch_break;
  case_1: /* CIL Label */ 
#line 865
  return ("prompt");
  case_2: /* CIL Label */ 
#line 867
  return ("comment");
  case_3: /* CIL Label */ 
#line 869
  return ("menu");
  case_4: /* CIL Label */ 
#line 871
  return ("default");
  case_5: /* CIL Label */ 
#line 873
  return ("choice");
  case_6: /* CIL Label */ 
#line 875
  return ("select");
  case_7: /* CIL Label */ 
#line 877
  return ("range");
  case_0: /* CIL Label */ 
#line 879
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 881
  return ("unknown");
}
}
#line 13 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
static struct menu **last_entry_ptr  ;
#line 18 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
static void menu_warn(struct menu *menu , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 21
  __builtin_va_start(ap, fmt);
#line 22
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          (menu->file)->name, menu->lineno);
#line 23
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 24
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 25
  __builtin_va_end(ap);
  }
#line 26
  return;
}
}
#line 28 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
static void prop_warn(struct property *prop , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 31
  __builtin_va_start(ap, fmt);
#line 32
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          (prop->file)->name, prop->lineno);
#line 33
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 34
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 35
  __builtin_va_end(ap);
  }
#line 36
  return;
}
}
#line 38 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void menu_init(void) 
{ 


  {
#line 40
  current_menu = & rootmenu;
#line 40
  current_entry = current_menu;
#line 41
  last_entry_ptr = & rootmenu.list;
#line 42
  return;
}
}
#line 44 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void menu_add_entry(struct symbol *sym ) 
{ 
  struct menu *menu ;
  void *tmp ;

  {
  {
#line 48
  tmp = malloc(sizeof(*menu));
#line 48
  menu = (struct menu *)tmp;
#line 49
  memset((void *)menu, 0, sizeof(*menu));
#line 50
  menu->sym = sym;
#line 51
  menu->parent = current_menu;
#line 52
  menu->file = current_file;
#line 53
  menu->lineno = zconf_lineno();
#line 55
  *last_entry_ptr = menu;
#line 56
  last_entry_ptr = & menu->next;
#line 57
  current_entry = menu;
  }
#line 58
  return;
}
}
#line 60 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void menu_end_entry(void) 
{ 


  {
#line 62
  return;
}
}
#line 64 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
struct menu *menu_add_menu(void) 
{ 


  {
  {
#line 66
  menu_end_entry();
#line 67
  last_entry_ptr = & current_entry->list;
#line 68
  current_menu = current_entry;
  }
#line 68
  return (current_menu);
}
}
#line 71 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void menu_end_menu(void) 
{ 


  {
#line 73
  last_entry_ptr = & current_menu->next;
#line 74
  current_menu = current_menu->parent;
#line 75
  return;
}
}
#line 77 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
struct expr *menu_check_dep(struct expr *e ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 79
  if (! e) {
#line 80
    return (e);
  }
  {
#line 83
  if ((unsigned int )e->type == 3U) {
#line 83
    goto case_3;
  }
#line 87
  if ((unsigned int )e->type == 2U) {
#line 87
    goto case_2;
  }
#line 87
  if ((unsigned int )e->type == 1U) {
#line 87
    goto case_2;
  }
#line 91
  if ((unsigned int )e->type == 7U) {
#line 91
    goto case_7;
  }
#line 96
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 84
  e->left.expr = menu_check_dep(e->left.expr);
  }
#line 85
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 88
  e->left.expr = menu_check_dep(e->left.expr);
#line 89
  e->right.expr = menu_check_dep(e->right.expr);
  }
#line 90
  goto switch_break;
  case_7: /* CIL Label */ 
#line 93
  if ((unsigned long )e->left.sym == (unsigned long )(& symbol_mod)) {
    {
#line 94
    tmp = expr_alloc_symbol(modules_sym);
#line 94
    tmp___0 = expr_alloc_and(e, tmp);
    }
#line 94
    return (tmp___0);
  }
#line 95
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 97
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 99
  return (e);
}
}
#line 102 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void menu_add_dep(struct expr *dep ) 
{ 
  struct expr *tmp ;

  {
  {
#line 104
  tmp = menu_check_dep(dep);
#line 104
  current_entry->dep = expr_alloc_and(current_entry->dep, tmp);
  }
#line 105
  return;
}
}
#line 107 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void menu_set_type(int type ) 
{ 
  struct symbol *sym ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 109
  sym = current_entry->sym;
#line 111
  if ((unsigned int )sym->type == (unsigned int )type) {
#line 112
    return;
  }
#line 113
  if ((unsigned int )sym->type == 0U) {
#line 114
    sym->type = (enum symbol_type )type;
#line 115
    return;
  }
  {
#line 117
  tmp = sym_type_name((enum symbol_type )type);
#line 117
  tmp___0 = sym_type_name(sym->type);
  }
#line 117
  if (sym->name) {
#line 117
    tmp___1 = (char const   *)sym->name;
  } else {
#line 117
    tmp___1 = "<choice>";
  }
  {
#line 117
  menu_warn(current_entry, "type of \'%s\' redefined from \'%s\' to \'%s\'\n", tmp___1,
            tmp___0, tmp);
  }
#line 120
  return;
}
}
#line 122 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
struct property *menu_add_prop(enum prop_type type , char *prompt , struct expr *expr ,
                               struct expr *dep ) 
{ 
  struct property *prop ;
  struct property *tmp ;

  {
  {
#line 124
  tmp = prop_alloc(type, current_entry->sym);
#line 124
  prop = tmp;
#line 126
  prop->menu = current_entry;
#line 127
  prop->text = (char const   *)prompt;
#line 128
  prop->expr = expr;
#line 129
  prop->visible.expr = menu_check_dep(dep);
  }
#line 131
  if (prompt) {
#line 132
    if (current_entry->prompt) {
      {
#line 133
      menu_warn(current_entry, "prompt redefined\n");
      }
    }
#line 134
    current_entry->prompt = prop;
  }
#line 137
  return (prop);
}
}
#line 140 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
struct property *menu_add_prompt(enum prop_type type , char *prompt , struct expr *dep ) 
{ 
  struct property *tmp ;

  {
  {
#line 142
  tmp = menu_add_prop(type, prompt, (struct expr *)((void *)0), dep);
  }
#line 142
  return (tmp);
}
}
#line 145 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void menu_add_expr(enum prop_type type , struct expr *expr , struct expr *dep ) 
{ 


  {
  {
#line 147
  menu_add_prop(type, (char *)((void *)0), expr, dep);
  }
#line 148
  return;
}
}
#line 150 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void menu_add_symbol(enum prop_type type , struct symbol *sym , struct expr *dep ) 
{ 
  struct expr *tmp ;

  {
  {
#line 152
  tmp = expr_alloc_symbol(sym);
#line 152
  menu_add_prop(type, (char *)((void *)0), tmp, dep);
  }
#line 153
  return;
}
}
#line 155 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
static int menu_range_valid_sym(struct symbol *sym , struct symbol *sym2 ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 157
  if ((unsigned int )sym2->type == 3U) {
#line 157
    tmp___0 = 1;
  } else
#line 157
  if ((unsigned int )sym2->type == 4U) {
#line 157
    tmp___0 = 1;
  } else
#line 157
  if ((unsigned int )sym2->type == 0U) {
    {
#line 157
    tmp = sym_string_valid(sym, (char const   *)sym2->name);
    }
#line 157
    if (tmp) {
#line 157
      tmp___0 = 1;
    } else {
#line 157
      tmp___0 = 0;
    }
  } else {
#line 157
    tmp___0 = 0;
  }
#line 157
  return (tmp___0);
}
}
#line 161 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void sym_check_prop(struct symbol *sym ) 
{ 
  struct property *prop ;
  struct symbol *sym2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 165
  prop = sym->prop;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! prop) {
#line 165
      goto while_break;
    }
    {
#line 167
    if ((unsigned int )prop->type == 4U) {
#line 167
      goto case_4;
    }
#line 174
    if ((unsigned int )prop->type == 6U) {
#line 174
      goto case_6;
    }
#line 191
    if ((unsigned int )prop->type == 7U) {
#line 191
      goto case_7;
    }
#line 199
    goto switch_default;
    case_4: /* CIL Label */ 
#line 168
    if ((unsigned int )sym->type == 5U) {
#line 168
      goto _L;
    } else
#line 168
    if ((unsigned int )sym->type == 3U) {
#line 168
      goto _L;
    } else
#line 168
    if ((unsigned int )sym->type == 4U) {
      _L: /* CIL Label */ 
#line 168
      if ((unsigned int )(prop->expr)->type != 7U) {
        {
#line 170
        prop_warn(prop, "default for config symbol \'%\' must be a single symbol",
                  sym->name);
        }
      }
    }
#line 173
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 175
    sym2 = prop_get_symbol(prop);
    }
#line 176
    if ((unsigned int )sym->type != 1U) {
#line 176
      if ((unsigned int )sym->type != 2U) {
        {
#line 177
        prop_warn(prop, "config symbol \'%s\' uses select, but is not boolean or tristate",
                  sym->name);
        }
      } else {
#line 176
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 180
    if ((unsigned int )sym2->type == 0U) {
      {
#line 181
      prop_warn(prop, "\'select\' used by config symbol \'%s\' refer to undefined symbol \'%s\'",
                sym->name, sym2->name);
      }
    } else
#line 185
    if ((unsigned int )sym2->type != 1U) {
#line 185
      if ((unsigned int )sym2->type != 2U) {
        {
#line 186
        prop_warn(prop, "\'%s\' has wrong type. \'select\' only accept arguments of boolean and tristate type",
                  sym2->name);
        }
      }
    }
#line 190
    goto switch_break;
    case_7: /* CIL Label */ 
#line 192
    if ((unsigned int )sym->type != 3U) {
#line 192
      if ((unsigned int )sym->type != 4U) {
        {
#line 193
        prop_warn(prop, "range is only allowed for int or hex symbols");
        }
      }
    }
    {
#line 195
    tmp = menu_range_valid_sym(sym, (prop->expr)->left.sym);
    }
#line 195
    if (tmp) {
      {
#line 195
      tmp___0 = menu_range_valid_sym(sym, (prop->expr)->right.sym);
      }
#line 195
      if (! tmp___0) {
        {
#line 197
        prop_warn(prop, "range is invalid");
        }
      }
    } else {
      {
#line 197
      prop_warn(prop, "range is invalid");
      }
    }
#line 198
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 165
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 205 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
void menu_finalize(struct menu *parent ) 
{ 
  struct menu *menu ;
  struct menu *last_menu ;
  struct symbol *sym ;
  struct property *prop ;
  struct expr *parentdep ;
  struct expr *basedep ;
  struct expr *dep ;
  struct expr *dep2 ;
  struct expr **ep ;
  _Bool tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct symbol *es ;
  struct symbol *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  struct expr *tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  struct expr *tmp___13 ;
  struct expr *tmp___14 ;
  _Bool tmp___15 ;

  {
#line 212
  sym = parent->sym;
#line 213
  if (parent->list) {
#line 214
    if (sym) {
      {
#line 214
      tmp = sym_is_choice(sym);
      }
#line 214
      if (tmp) {
#line 216
        menu = parent->list;
        {
#line 216
        while (1) {
          while_continue: /* CIL Label */ ;
#line 216
          if (! menu) {
#line 216
            goto while_break;
          }
#line 217
          if (menu->sym) {
            {
#line 218
            current_entry = parent;
#line 219
            menu_set_type((int )(menu->sym)->type);
#line 220
            current_entry = menu;
#line 221
            menu_set_type((int )sym->type);
            }
#line 222
            goto while_break;
          }
#line 216
          menu = menu->next;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 225
        parentdep = expr_alloc_symbol(sym);
        }
      } else {
#line 214
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 226
    if (parent->prompt) {
#line 227
      parentdep = (parent->prompt)->visible.expr;
    } else {
#line 229
      parentdep = parent->dep;
    }
#line 231
    menu = parent->list;
    {
#line 231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 231
      if (! menu) {
#line 231
        goto while_break___0;
      }
      {
#line 232
      basedep = expr_transform(menu->dep);
#line 233
      tmp___0 = expr_copy(parentdep);
#line 233
      basedep = expr_alloc_and(tmp___0, basedep);
#line 234
      basedep = expr_eliminate_dups(basedep);
#line 235
      menu->dep = basedep;
      }
#line 236
      if (menu->sym) {
#line 237
        prop = (menu->sym)->prop;
      } else {
#line 239
        prop = menu->prompt;
      }
      {
#line 240
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 240
        if (! prop) {
#line 240
          goto while_break___1;
        }
#line 241
        if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 242
          goto __Cont;
        }
        {
#line 243
        dep = expr_transform(prop->visible.expr);
#line 244
        tmp___1 = expr_copy(basedep);
#line 244
        dep = expr_alloc_and(tmp___1, dep);
#line 245
        dep = expr_eliminate_dups(dep);
        }
#line 246
        if (menu->sym) {
#line 246
          if ((unsigned int )(menu->sym)->type != 2U) {
            {
#line 247
            dep = expr_trans_bool(dep);
            }
          }
        }
#line 248
        prop->visible.expr = dep;
#line 249
        if ((unsigned int )prop->type == 6U) {
          {
#line 250
          tmp___2 = prop_get_symbol(prop);
#line 250
          es = tmp___2;
#line 251
          tmp___3 = expr_copy(dep);
#line 251
          tmp___4 = expr_alloc_symbol(menu->sym);
#line 251
          tmp___5 = expr_alloc_and(tmp___4, tmp___3);
#line 251
          es->rev_dep.expr = expr_alloc_or(es->rev_dep.expr, tmp___5);
          }
        }
        __Cont: /* CIL Label */ 
#line 240
        prop = prop->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 231
      menu = menu->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    menu = parent->list;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (! menu) {
#line 256
        goto while_break___2;
      }
      {
#line 257
      menu_finalize(menu);
#line 256
      menu = menu->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 258
  if (sym) {
#line 259
    if (parent->prompt) {
#line 259
      basedep = (parent->prompt)->visible.expr;
    } else {
#line 259
      basedep = (struct expr *)((void *)0);
    }
    {
#line 260
    basedep = expr_trans_compare(basedep, (enum expr_type )5, & symbol_no);
#line 261
    tmp___6 = expr_transform(basedep);
#line 261
    basedep = expr_eliminate_dups(tmp___6);
#line 262
    last_menu = (struct menu *)((void *)0);
#line 263
    menu = parent->next;
    }
    {
#line 263
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 263
      if (! menu) {
#line 263
        goto while_break___3;
      }
#line 264
      if (menu->prompt) {
#line 264
        dep = (menu->prompt)->visible.expr;
      } else {
#line 264
        dep = menu->dep;
      }
      {
#line 265
      tmp___7 = expr_contains_symbol(dep, sym);
      }
#line 265
      if (! tmp___7) {
#line 266
        goto while_break___3;
      }
      {
#line 267
      tmp___8 = expr_depends_symbol(dep, sym);
      }
#line 267
      if (tmp___8) {
#line 268
        goto next;
      }
      {
#line 269
      dep = expr_trans_compare(dep, (enum expr_type )5, & symbol_no);
#line 270
      tmp___9 = expr_transform(dep);
#line 270
      dep = expr_eliminate_dups(tmp___9);
#line 271
      dep2 = expr_copy(basedep);
#line 272
      expr_eliminate_eq(& dep, & dep2);
#line 273
      expr_free(dep);
#line 274
      tmp___10 = expr_is_yes(dep2);
      }
#line 274
      if (! tmp___10) {
        {
#line 275
        expr_free(dep2);
        }
#line 276
        goto while_break___3;
      }
      {
#line 278
      expr_free(dep2);
      }
      next: 
      {
#line 280
      menu_finalize(menu);
#line 281
      menu->parent = parent;
#line 282
      last_menu = menu;
#line 263
      menu = menu->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 284
    if (last_menu) {
#line 285
      parent->list = parent->next;
#line 286
      parent->next = last_menu->next;
#line 287
      last_menu->next = (struct menu *)((void *)0);
    }
  }
#line 290
  menu = parent->list;
  {
#line 290
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 290
    if (! menu) {
#line 290
      goto while_break___4;
    }
#line 291
    if (sym) {
      {
#line 291
      tmp___11 = sym_is_choice(sym);
      }
#line 291
      if (tmp___11) {
#line 291
        if (menu->sym) {
#line 292
          (menu->sym)->flags |= 32;
#line 293
          if (! menu->prompt) {
            {
#line 294
            menu_warn(menu, "choice value must have a prompt");
            }
          }
#line 295
          prop = (menu->sym)->prop;
          {
#line 295
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 295
            if (! prop) {
#line 295
              goto while_break___5;
            }
#line 296
            if ((unsigned int )prop->type == 1U) {
#line 296
              if ((unsigned long )prop->menu != (unsigned long )menu) {
                {
#line 297
                prop_warn(prop, "choice values currently only support a single prompt");
                }
              }
            }
#line 301
            if ((unsigned int )prop->type == 4U) {
              {
#line 302
              prop_warn(prop, "defaults for choice values not supported");
              }
            }
#line 295
            prop = prop->next;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 305
          current_entry = menu;
#line 306
          menu_set_type((int )sym->type);
#line 307
          menu_add_symbol((enum prop_type )5, sym, (struct expr *)((void *)0));
#line 308
          prop = sym_get_choice_prop(sym);
#line 309
          ep = & prop->expr;
          }
          {
#line 309
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 309
            if (! *ep) {
#line 309
              goto while_break___6;
            }
#line 309
            ep = & (*ep)->left.expr;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 311
          *ep = expr_alloc_one((enum expr_type )6, (struct expr *)((void *)0));
#line 312
          (*ep)->right.sym = menu->sym;
          }
        }
      }
    }
#line 314
    if (menu->list) {
#line 314
      if (! menu->prompt) {
#line 314
        goto _L___0;
      } else
#line 314
      if (! (menu->prompt)->text) {
        _L___0: /* CIL Label */ 
#line 315
        last_menu = menu->list;
        {
#line 315
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 316
          last_menu->parent = parent;
#line 317
          if (! last_menu->next) {
#line 318
            goto while_break___7;
          }
#line 315
          last_menu = last_menu->next;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 320
        last_menu->next = menu->next;
#line 321
        menu->next = menu->list;
#line 322
        menu->list = (struct menu *)((void *)0);
      }
    }
#line 290
    menu = menu->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 326
  if (sym) {
#line 326
    if (! (sym->flags & 32768)) {
#line 327
      if ((unsigned int )sym->type == 0U) {
        {
#line 328
        menu_warn(parent, "config symbol defined without type\n");
        }
      }
      {
#line 331
      tmp___12 = sym_is_choice(sym);
      }
#line 331
      if (tmp___12) {
#line 331
        if (! parent->prompt) {
          {
#line 332
          menu_warn(parent, "choice must have a prompt\n");
          }
        }
      }
      {
#line 335
      sym_check_prop(sym);
#line 336
      sym->flags |= 32768;
      }
    }
  }
#line 339
  if (sym) {
    {
#line 339
    tmp___15 = sym_is_optional(sym);
    }
#line 339
    if (! tmp___15) {
#line 339
      if (parent->prompt) {
        {
#line 340
        tmp___13 = expr_alloc_symbol(& symbol_mod);
#line 340
        tmp___14 = expr_alloc_and((parent->prompt)->visible.expr, tmp___13);
#line 340
        sym->rev_dep.expr = expr_alloc_or(sym->rev_dep.expr, tmp___14);
        }
      }
    }
  }
#line 344
  return;
}
}
#line 346 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
_Bool menu_is_visible(struct menu *menu ) 
{ 
  struct menu *child ;
  struct symbol *sym ;
  tristate visible ;
  tristate tmp ;
  tristate tmp___0 ;
  _Bool tmp___1 ;

  {
#line 352
  if (! menu->prompt) {
#line 353
    return ((_Bool)0);
  }
#line 354
  sym = menu->sym;
#line 355
  if (sym) {
    {
#line 356
    sym_calc_value(sym);
#line 357
    visible = (menu->prompt)->visible.tri;
    }
  } else {
    {
#line 359
    tmp = expr_calc_value((menu->prompt)->visible.expr);
#line 359
    (menu->prompt)->visible.tri = tmp;
#line 359
    visible = tmp;
    }
  }
#line 361
  if ((unsigned int )visible != 0U) {
#line 362
    return ((_Bool)1);
  }
#line 363
  if (! sym) {
#line 364
    return ((_Bool)0);
  } else {
    {
#line 363
    tmp___0 = sym_get_tristate_value(menu->sym);
    }
#line 363
    if ((unsigned int )tmp___0 == 0U) {
#line 364
      return ((_Bool)0);
    }
  }
#line 366
  child = menu->list;
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! child) {
#line 366
      goto while_break;
    }
    {
#line 367
    tmp___1 = menu_is_visible(child);
    }
#line 367
    if (tmp___1) {
#line 368
      return ((_Bool)1);
    }
#line 366
    child = child->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return ((_Bool)0);
}
}
#line 372 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
char const   *menu_get_prompt(struct menu *menu ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 374
  if (menu->prompt) {
    {
#line 375
    tmp = gettext((menu->prompt)->text);
    }
#line 375
    return ((char const   *)tmp);
  } else
#line 376
  if (menu->sym) {
    {
#line 377
    tmp___0 = gettext((char const   *)(menu->sym)->name);
    }
#line 377
    return ((char const   *)tmp___0);
  }
#line 378
  return ((char const   *)((void *)0));
}
}
#line 381 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
struct menu *menu_get_root_menu(struct menu *menu ) 
{ 


  {
#line 383
  return (& rootmenu);
}
}
#line 386 "/home/june/collector/temp/busybox-1.21.0/scripts/kconfig/menu.c"
struct menu *menu_get_parent_menu(struct menu *menu ) 
{ 
  enum prop_type type ;

  {
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! ((unsigned long )menu != (unsigned long )(& rootmenu))) {
#line 390
      goto while_break;
    }
#line 391
    if (menu->prompt) {
#line 391
      type = (menu->prompt)->type;
    } else {
#line 391
      type = (enum prop_type )0;
    }
#line 392
    if ((unsigned int )type == 3U) {
#line 393
      goto while_break;
    }
#line 390
    menu = menu->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return (menu);
}
}
