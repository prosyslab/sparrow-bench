/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.h"
struct buffer {
   char *x ;
   unsigned int p ;
   unsigned int n ;
   int fd ;
   int (*op)() ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.h"
typedef struct buffer buffer;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/seek.h"
typedef unsigned long seek_pos;
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/uint32.h"
typedef unsigned int uint32;
#line 11 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.h"
struct cdb_hp {
   uint32 h ;
   uint32 p ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.h"
struct cdb_hplist {
   struct cdb_hp hp[1000] ;
   struct cdb_hplist *next ;
   int num ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.h"
struct cdb_make {
   char bspace[8192] ;
   char final[2048] ;
   uint32 count[256] ;
   uint32 start[256] ;
   struct cdb_hplist *head ;
   struct cdb_hp *split ;
   struct cdb_hp *hash ;
   uint32 numentries ;
   buffer b ;
   uint32 pos ;
   int fd ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/strerr.h"
struct strerr {
   struct strerr *who ;
   char const   *x ;
   char const   *y ;
   char const   *z ;
};
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.h"
struct cdb {
   char *map ;
   int fd ;
   uint32 size ;
   uint32 loop ;
   uint32 khash ;
   uint32 kpos ;
   uint32 hpos ;
   uint32 hslots ;
   uint32 dpos ;
   uint32 dlen ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 10 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
union __anonunion_aligned_21 {
   char irrelevant[16] ;
   double d ;
};
#line 10 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
typedef union __anonunion_aligned_21 aligned;
#line 20 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.h"
int buffer_flush(buffer *s ) ;
#line 52
int buffer_unixread(int fd , char *buf___0 , unsigned int len ) ;
#line 55
buffer *buffer_0 ;
#line 57
buffer *buffer_1 ;
#line 5 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_0.c"
int buffer_0_read(int fd , char *buf___0 , int len ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 7
  tmp___0 = buffer_flush(buffer_1);
  }
#line 7
  if (tmp___0 == -1) {
#line 7
    return (-1);
  }
  {
#line 8
  tmp___1 = buffer_unixread(fd, buf___0, (unsigned int )len);
  }
#line 8
  return (tmp___1);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_0.c"
char buffer_0_space[8192]  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_0.c"
static buffer it  =    {buffer_0_space, 0U, (unsigned int )sizeof(buffer_0_space), 0, (int (*)())(& buffer_0_read)};
#line 13 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_0.c"
buffer *buffer_0  =    & it;
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_0.c"
static buffer it___0  =    {buffer_0_space, 0U, (unsigned int )sizeof(buffer_0_space), 0, (int (*)())(& buffer_0_read)};
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/seek.h"
extern int seek_set(int  , seek_pos  ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.h"
int error_nomem ;
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.h"
char *alloc(unsigned int n ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/uint32.h"
extern void uint32_pack(char * , uint32  ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.h"
uint32 cdb_hash(char *buf___0 , unsigned int len ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.h"
void buffer_init(buffer *s , int (*op)() , int fd , char *buf___0 , unsigned int len ) ;
#line 22
int buffer_putalign(buffer *s , char const   *buf___0 , unsigned int len ) ;
#line 23
int buffer_putflush(buffer *s , char const   *buf___0 , unsigned int len ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.h"
int cdb_make_start(struct cdb_make *c___2 , int fd ) ;
#line 34
int cdb_make_addbegin(struct cdb_make *c___2 , unsigned int keylen , unsigned int datalen ) ;
#line 35
int cdb_make_addend(struct cdb_make *c___2 , unsigned int keylen , unsigned int datalen ,
                    uint32 h ) ;
#line 36
int cdb_make_add(struct cdb_make *c___2 , char *key , unsigned int keylen , char *data ,
                 unsigned int datalen ) ;
#line 37
int cdb_make_finish(struct cdb_make *c___2 ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.c"
int cdb_make_start(struct cdb_make *c___2 , int fd ) 
{ 
  int tmp___0 ;

  {
  {
#line 12
  c___2->head = (struct cdb_hplist *)0;
#line 13
  c___2->split = (struct cdb_hp *)0;
#line 14
  c___2->hash = (struct cdb_hp *)0;
#line 15
  c___2->numentries = (uint32 )0;
#line 16
  c___2->fd = fd;
#line 17
  c___2->pos = (uint32 )sizeof(c___2->final);
#line 18
  buffer_init(& c___2->b, (int (*)())(& write), fd, c___2->bspace, (unsigned int )sizeof(c___2->bspace));
#line 19
  tmp___0 = seek_set(fd, (seek_pos )c___2->pos);
  }
#line 19
  return (tmp___0);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.c"
static int posplus(struct cdb_make *c___2 , uint32 len ) 
{ 
  uint32 newpos ;
  int *tmp___0 ;

  {
#line 24
  newpos = c___2->pos + len;
#line 25
  if (newpos < len) {
    {
#line 25
    tmp___0 = __errno_location();
#line 25
    *tmp___0 = error_nomem;
    }
#line 25
    return (-1);
  }
#line 26
  c___2->pos = newpos;
#line 27
  return (0);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.c"
int cdb_make_addend(struct cdb_make *c___2 , unsigned int keylen , unsigned int datalen ,
                    uint32 h ) 
{ 
  struct cdb_hplist *head ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 34
  head = c___2->head;
#line 35
  if (! head) {
#line 35
    goto _L;
  } else
#line 35
  if (head->num >= 1000) {
    _L: /* CIL Label */ 
    {
#line 36
    tmp___0 = alloc(sizeof(struct cdb_hplist ));
#line 36
    head = (struct cdb_hplist *)tmp___0;
    }
#line 37
    if (! head) {
#line 37
      return (-1);
    }
#line 38
    head->num = 0;
#line 39
    head->next = c___2->head;
#line 40
    c___2->head = head;
  }
  {
#line 42
  head->hp[head->num].h = h;
#line 43
  head->hp[head->num].p = c___2->pos;
#line 44
  (head->num) ++;
#line 45
  (c___2->numentries) ++;
#line 46
  tmp___1 = posplus(c___2, (uint32 )8);
  }
#line 46
  if (tmp___1 == -1) {
#line 46
    return (-1);
  }
  {
#line 47
  tmp___2 = posplus(c___2, keylen);
  }
#line 47
  if (tmp___2 == -1) {
#line 47
    return (-1);
  }
  {
#line 48
  tmp___3 = posplus(c___2, datalen);
  }
#line 48
  if (tmp___3 == -1) {
#line 48
    return (-1);
  }
#line 49
  return (0);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.c"
int cdb_make_addbegin(struct cdb_make *c___2 , unsigned int keylen , unsigned int datalen ) 
{ 
  char buf___0[8] ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 56
  if (keylen > 4294967295U) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = error_nomem;
    }
#line 56
    return (-1);
  }
#line 57
  if (datalen > 4294967295U) {
    {
#line 57
    tmp___1 = __errno_location();
#line 57
    *tmp___1 = error_nomem;
    }
#line 57
    return (-1);
  }
  {
#line 59
  uint32_pack(buf___0, keylen);
#line 60
  uint32_pack(buf___0 + 4, datalen);
#line 61
  tmp___2 = buffer_putalign(& c___2->b, (char const   *)(buf___0), 8U);
  }
#line 61
  if (tmp___2 == -1) {
#line 61
    return (-1);
  }
#line 62
  return (0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.c"
int cdb_make_add(struct cdb_make *c___2 , char *key , unsigned int keylen , char *data ,
                 unsigned int datalen ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32 tmp___3 ;
  int tmp___4 ;

  {
  {
#line 67
  tmp___0 = cdb_make_addbegin(c___2, keylen, datalen);
  }
#line 67
  if (tmp___0 == -1) {
#line 67
    return (-1);
  }
  {
#line 68
  tmp___1 = buffer_putalign(& c___2->b, (char const   *)key, keylen);
  }
#line 68
  if (tmp___1 == -1) {
#line 68
    return (-1);
  }
  {
#line 69
  tmp___2 = buffer_putalign(& c___2->b, (char const   *)data, datalen);
  }
#line 69
  if (tmp___2 == -1) {
#line 69
    return (-1);
  }
  {
#line 70
  tmp___3 = cdb_hash(key, keylen);
#line 70
  tmp___4 = cdb_make_addend(c___2, keylen, datalen, tmp___3);
  }
#line 70
  return (tmp___4);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.c"
int cdb_make_finish(struct cdb_make *c___2 ) 
{ 
  char buf___0[8] ;
  int i ;
  uint32 len ;
  uint32 u ;
  uint32 memsize ;
  uint32 count ;
  uint32 where ;
  struct cdb_hplist *x ;
  struct cdb_hp *hp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  uint32 tmp___4 ;
  struct cdb_hp *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 85
  i = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < 256)) {
#line 85
      goto while_break;
    }
#line 86
    c___2->count[i] = (uint32 )0;
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  x = c___2->head;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! x) {
#line 88
      goto while_break___0;
    }
#line 89
    i = x->num;
    {
#line 90
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 90
      tmp___0 = i;
#line 90
      i --;
#line 90
      if (! tmp___0) {
#line 90
        goto while_break___1;
      }
#line 91
      (c___2->count[255U & x->hp[i].h]) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 88
    x = x->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  memsize = (uint32 )1;
#line 95
  i = 0;
  {
#line 95
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 95
    if (! (i < 256)) {
#line 95
      goto while_break___2;
    }
#line 96
    u = c___2->count[i] * 2U;
#line 97
    if (u > memsize) {
#line 98
      memsize = u;
    }
#line 95
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 101
  memsize += c___2->numentries;
#line 102
  u = 4294967295U;
#line 103
  u = (uint32 )((unsigned long )u / sizeof(struct cdb_hp ));
#line 104
  if (memsize > u) {
    {
#line 104
    tmp___1 = __errno_location();
#line 104
    *tmp___1 = error_nomem;
    }
#line 104
    return (-1);
  }
  {
#line 106
  tmp___2 = alloc((unsigned long )memsize * sizeof(struct cdb_hp ));
#line 106
  c___2->split = (struct cdb_hp *)tmp___2;
  }
#line 107
  if (! c___2->split) {
#line 107
    return (-1);
  }
#line 109
  c___2->hash = c___2->split + c___2->numentries;
#line 111
  u = (uint32 )0;
#line 112
  i = 0;
  {
#line 112
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 112
    if (! (i < 256)) {
#line 112
      goto while_break___3;
    }
#line 113
    u += c___2->count[i];
#line 114
    c___2->start[i] = u;
#line 112
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 117
  x = c___2->head;
  {
#line 117
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 117
    if (! x) {
#line 117
      goto while_break___4;
    }
#line 118
    i = x->num;
    {
#line 119
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 119
      tmp___3 = i;
#line 119
      i --;
#line 119
      if (! tmp___3) {
#line 119
        goto while_break___5;
      }
#line 120
      (c___2->start[255U & x->hp[i].h]) --;
#line 120
      *(c___2->split + c___2->start[255U & x->hp[i].h]) = x->hp[i];
    }
    while_break___5: /* CIL Label */ ;
    }
#line 117
    x = x->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 123
    if (! (i < 256)) {
#line 123
      goto while_break___6;
    }
    {
#line 124
    count = c___2->count[i];
#line 126
    len = count + count;
#line 127
    uint32_pack(c___2->final + 8 * i, c___2->pos);
#line 128
    uint32_pack((c___2->final + 8 * i) + 4, len);
#line 130
    u = (uint32 )0;
    }
    {
#line 130
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 130
      if (! (u < len)) {
#line 130
        goto while_break___7;
      }
#line 131
      tmp___4 = (uint32 )0;
#line 131
      (c___2->hash + u)->p = tmp___4;
#line 131
      (c___2->hash + u)->h = tmp___4;
#line 130
      u ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 133
    hp = c___2->split + c___2->start[i];
#line 134
    u = (uint32 )0;
    {
#line 134
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 134
      if (! (u < count)) {
#line 134
        goto while_break___8;
      }
#line 135
      where = (hp->h >> 8) % len;
      {
#line 136
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 136
        if (! (c___2->hash + where)->p) {
#line 136
          goto while_break___9;
        }
#line 137
        where ++;
#line 137
        if (where == len) {
#line 138
          where = (uint32 )0;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 139
      tmp___5 = hp;
#line 139
      hp ++;
#line 139
      *(c___2->hash + where) = *tmp___5;
#line 134
      u ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 142
    u = (uint32 )0;
    {
#line 142
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 142
      if (! (u < len)) {
#line 142
        goto while_break___10;
      }
      {
#line 143
      uint32_pack(buf___0, (c___2->hash + u)->h);
#line 144
      uint32_pack(buf___0 + 4, (c___2->hash + u)->p);
#line 145
      tmp___6 = buffer_putalign(& c___2->b, (char const   *)(buf___0), 8U);
      }
#line 145
      if (tmp___6 == -1) {
#line 145
        return (-1);
      }
      {
#line 146
      tmp___7 = posplus(c___2, (uint32 )8);
      }
#line 146
      if (tmp___7 == -1) {
#line 146
        return (-1);
      }
#line 142
      u ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 123
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 150
  tmp___8 = buffer_flush(& c___2->b);
  }
#line 150
  if (tmp___8 == -1) {
#line 150
    return (-1);
  }
  {
#line 151
  tmp___9 = seek_set(c___2->fd, (seek_pos )0);
  }
#line 151
  if (tmp___9 == -1) {
#line 151
    return (-1);
  }
  {
#line 152
  tmp___10 = buffer_putflush(& c___2->b, (char const   *)(c___2->final), (unsigned int )sizeof(c___2->final));
  }
#line 152
  return (tmp___10);
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/byte.h"
void byte_copyr(char *to , unsigned int n , char *from ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/byte_cr.c"
void byte_copyr(char *to , unsigned int n , char *from ) 
{ 


  {
#line 10
  to += n;
#line 11
  from += n;
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! n) {
#line 13
      return;
    }
#line 13
    to --;
#line 13
    from --;
#line 13
    *to = *from;
#line 13
    n --;
#line 14
    if (! n) {
#line 14
      return;
    }
#line 14
    to --;
#line 14
    from --;
#line 14
    *to = *from;
#line 14
    n --;
#line 15
    if (! n) {
#line 15
      return;
    }
#line 15
    to --;
#line 15
    from --;
#line 15
    *to = *from;
#line 15
    n --;
#line 16
    if (! n) {
#line 16
      return;
    }
#line 16
    to --;
#line 16
    from --;
#line 16
    *to = *from;
#line 16
    n --;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.h"
int buffer_put(buffer *s , char const   *buf___0 , unsigned int len ) ;
#line 24
int buffer_puts(buffer *s , char const   *buf___0 ) ;
#line 25
int buffer_putsalign(buffer *s , char const   *buf___0 ) ;
#line 26
int buffer_putsflush(buffer *s , char const   *buf___0 ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/str.h"
extern unsigned int str_len(char const   * ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/byte.h"
void byte_copy(char *to , unsigned int n , char *from ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.h"
int error_intr ;
#line 8 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
static int allwrite(int (*op)() , int fd , char const   *buf___0 , unsigned int len ) 
{ 
  int w ;
  int *tmp___0 ;

  {
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! len) {
#line 12
      goto while_break;
    }
    {
#line 13
    w = (*op)(fd, buf___0, len);
    }
#line 14
    if (w == -1) {
      {
#line 15
      tmp___0 = __errno_location();
      }
#line 15
      if (*tmp___0 == error_intr) {
#line 15
        goto while_continue;
      }
#line 16
      return (-1);
    }
#line 19
    buf___0 += w;
#line 20
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  return (0);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
int buffer_flush(buffer *s ) 
{ 
  int p ;
  int tmp___0 ;

  {
#line 29
  p = (int )s->p;
#line 30
  if (! p) {
#line 30
    return (0);
  }
  {
#line 31
  s->p = 0U;
#line 32
  tmp___0 = allwrite(s->op, s->fd, (char const   *)s->x, (unsigned int )p);
  }
#line 32
  return (tmp___0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
int buffer_putalign(buffer *s , char const   *buf___0 , unsigned int len ) 
{ 
  unsigned int n ;
  int tmp___0 ;

  {
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    n = s->n - s->p;
#line 39
    if (! (len > n)) {
#line 39
      goto while_break;
    }
    {
#line 40
    byte_copy(s->x + s->p, n, buf___0);
#line 40
    s->p += n;
#line 40
    buf___0 += n;
#line 40
    len -= n;
#line 41
    tmp___0 = buffer_flush(s);
    }
#line 41
    if (tmp___0 == -1) {
#line 41
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  byte_copy(s->x + s->p, len, buf___0);
#line 45
  s->p += len;
  }
#line 46
  return (0);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
int buffer_put(buffer *s , char const   *buf___0 , unsigned int len ) 
{ 
  unsigned int n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 53
  n = s->n;
#line 54
  if (len > n - s->p) {
    {
#line 55
    tmp___0 = buffer_flush(s);
    }
#line 55
    if (tmp___0 == -1) {
#line 55
      return (-1);
    }
#line 57
    if (n < 8192U) {
#line 57
      n = 8192U;
    }
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! (len > s->n)) {
#line 58
        goto while_break;
      }
#line 59
      if (n > len) {
#line 59
        n = len;
      }
      {
#line 60
      tmp___1 = allwrite(s->op, s->fd, buf___0, n);
      }
#line 60
      if (tmp___1 == -1) {
#line 60
        return (-1);
      }
#line 61
      buf___0 += n;
#line 62
      len -= n;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 66
  byte_copy(s->x + s->p, len, buf___0);
#line 67
  s->p += len;
  }
#line 68
  return (0);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
int buffer_putflush(buffer *s , char const   *buf___0 , unsigned int len ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 73
  tmp___0 = buffer_flush(s);
  }
#line 73
  if (tmp___0 == -1) {
#line 73
    return (-1);
  }
  {
#line 74
  tmp___1 = allwrite(s->op, s->fd, buf___0, len);
  }
#line 74
  return (tmp___1);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
int buffer_putsalign(buffer *s , char const   *buf___0 ) 
{ 
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 79
  tmp___0 = str_len(buf___0);
#line 79
  tmp___1 = buffer_putalign(s, buf___0, tmp___0);
  }
#line 79
  return (tmp___1);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
int buffer_puts(buffer *s , char const   *buf___0 ) 
{ 
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___0 = str_len(buf___0);
#line 84
  tmp___1 = buffer_put(s, buf___0, tmp___0);
  }
#line 84
  return (tmp___1);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
int buffer_putsflush(buffer *s , char const   *buf___0 ) 
{ 
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 89
  tmp___0 = str_len(buf___0);
#line 89
  tmp___1 = buffer_putflush(s, buf___0, tmp___0);
  }
#line 89
  return (tmp___1);
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/strerr.h"
extern struct strerr strerr_sys ;
#line 18
extern void strerr_die(int  , char const   * , char const   * , char const   * , char const   * ,
                       char const   * , char const   * , struct strerr  const  * ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/uint32.h"
extern void uint32_unpack(char const   * , uint32 * ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.h"
void cdb_init(struct cdb *c___2 , int fd ) ;
#line 30
void cdb_findstart(struct cdb *c___2 ) ;
#line 31
int cdb_findnext(struct cdb *c___2 , char *key , unsigned int len ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.h"
int buffer_get(buffer *s , char *buf___0 , unsigned int len ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/fmt.h"
extern unsigned int fmt_ulong(char * , unsigned long  ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbstats.c"
char const   *progname  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbstats.c"
static struct cdb c  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbstats.c"
char buf[1024]  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbstats.c"
void usage(void) 
{ 


  {
  {
#line 18
  strerr_die(100, "usage: ", progname, "", "\n", (char const   *)0, (char const   *)0,
             (struct strerr  const  *)0);
  }
#line 18
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbstats.c"
void getb(char *b , unsigned int len ) 
{ 
  unsigned int l ;
  int tmp___0 ;

  {
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! len) {
#line 23
      goto while_break;
    }
    {
#line 24
    tmp___0 = buffer_get(buffer_0, b, len);
#line 24
    l = (unsigned int )tmp___0;
    }
    {
#line 25
    if (l == 0U) {
#line 25
      goto case_0;
    }
#line 26
    if (l == 4294967295U) {
#line 26
      goto case_4294967295;
    }
#line 24
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 25
    strerr_die(111, "cdbstats: fatal: ", "unable to read input: truncated file", (char const   *)0,
               (char const   *)0, (char const   *)0, (char const   *)0, (struct strerr  const  *)0);
    }
    case_4294967295: /* CIL Label */ 
    {
#line 26
    strerr_die(111, "cdbstats: fatal: ", "unable to read input: ", (char const   *)0,
               (char const   *)0, (char const   *)0, (char const   *)0, (struct strerr  const  *)(& strerr_sys));
    }
    switch_break: /* CIL Label */ ;
    }
#line 28
    len -= l;
#line 28
    b += l;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbstats.c"
void put1(char *s , unsigned int l ) 
{ 
  int tmp___0 ;

  {
  {
#line 32
  tmp___0 = buffer_put(buffer_1, (char const   *)s, l);
  }
#line 32
  if (tmp___0 == -1) {
    {
#line 33
    strerr_die(111, "cdbstats: fatal: ", "unable to write output: ", (char const   *)0,
               (char const   *)0, (char const   *)0, (char const   *)0, (struct strerr  const  *)(& strerr_sys));
    }
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbstats.c"
int main(int argc , char **argv ) 
{ 
  uint32 pos ;
  uint32 eodata ;
  uint32 keylen ;
  uint32 datalen ;
  char num[40] ;
  unsigned long records ;
  unsigned long distance[11] ;
  off_t rest ;
  int i ;
  int j ;
  char **tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  uint32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  uint32 tmp___8 ;
  uint32 tmp___9 ;
  uint32 tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;

  {
#line 47
  tmp___0 = argv;
#line 47
  argv ++;
#line 47
  progname = (char const   *)*tmp___0;
#line 48
  if (*argv) {
    {
#line 48
    usage();
    }
  }
#line 49
  pos = (uint32 )0;
#line 50
  records = 0UL;
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < 11)) {
#line 51
      goto while_break;
    }
#line 51
    distance[i] = 0UL;
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  cdb_init(& c, 0);
#line 56
  getb(buf, 4U);
#line 57
  pos += 4U;
#line 58
  uint32_unpack((char const   *)(buf), & eodata);
  }
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 60
    if (! (pos < 2048U)) {
#line 60
      goto while_break___0;
    }
#line 61
    if (2048U - pos < 1024U) {
#line 61
      tmp___1 = 2048U - pos;
    } else {
#line 61
      tmp___1 = (uint32 )1024;
    }
    {
#line 61
    getb(buf, tmp___1);
    }
#line 62
    if (2048U - pos < 1024U) {
#line 62
      tmp___2 = 2048U - pos;
    } else {
#line 62
      tmp___2 = (uint32 )1024;
    }
#line 62
    pos += tmp___2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 64
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 64
    if (! (pos < eodata)) {
#line 64
      goto while_break___1;
    }
    {
#line 66
    getb(buf, 4U);
#line 67
    pos += 4U;
#line 68
    uint32_unpack((char const   *)(buf), & keylen);
#line 70
    getb(buf, 4U);
#line 71
    pos += 4U;
#line 72
    uint32_unpack((char const   *)(buf), & datalen);
    }
#line 75
    if (keylen > 1024U) {
      {
#line 76
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 76
        if (! keylen) {
#line 76
          goto while_break___2;
        }
#line 77
        if (keylen < 1024U) {
#line 77
          tmp___3 = keylen;
        } else {
#line 77
          tmp___3 = (uint32 )1024;
        }
        {
#line 77
        getb(buf, tmp___3);
        }
#line 78
        if (keylen < 1024U) {
#line 78
          tmp___4 = keylen;
        } else {
#line 78
          tmp___4 = (uint32 )1024;
        }
#line 78
        pos += tmp___4;
#line 79
        if (keylen < 1024U) {
#line 79
          tmp___5 = keylen;
        } else {
#line 79
          tmp___5 = (uint32 )1024;
        }
#line 79
        keylen -= tmp___5;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 85
      getb(buf, keylen);
#line 86
      pos += keylen;
#line 88
      rest = lseek(0, (off_t )0, 1);
#line 90
      cdb_findstart(& c);
      }
      {
#line 91
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 92
        tmp___6 = cdb_findnext(& c, buf, keylen);
        }
        {
#line 93
        if (tmp___6 == -1) {
#line 93
          goto case_neg_1;
        }
#line 94
        if (tmp___6 == 0) {
#line 94
          goto case_0;
        }
#line 92
        goto switch_break;
        case_neg_1: /* CIL Label */ 
        {
#line 93
        strerr_die(111, "cdbstats: fatal: ", "unable to read input: ", (char const   *)0,
                   (char const   *)0, (char const   *)0, (char const   *)0, (struct strerr  const  *)(& strerr_sys));
        }
        case_0: /* CIL Label */ 
        {
#line 94
        strerr_die(111, "cdbstats: fatal: ", "unable to read input: truncated file",
                   (char const   *)0, (char const   *)0, (char const   *)0, (char const   *)0,
                   (struct strerr  const  *)0);
        }
        switch_break: /* CIL Label */ ;
        }
#line 91
        if (! (c.dpos != pos)) {
#line 91
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 97
      if (! c.loop) {
        {
#line 98
        strerr_die(111, "cdbstats: fatal: ", "unable to read input: truncated file",
                   (char const   *)0, (char const   *)0, (char const   *)0, (char const   *)0,
                   (struct strerr  const  *)0);
        }
      }
#line 100
      records ++;
#line 102
      if (c.loop > 10U) {
#line 102
        (distance[10]) ++;
      } else {
#line 102
        (distance[c.loop - 1U]) ++;
      }
      {
#line 104
      tmp___7 = seek_set(0, (seek_pos )rest);
      }
#line 104
      if (tmp___7 == -1) {
        {
#line 105
        strerr_die(111, "cdbstats: fatal: ", "unable to read input: ", (char const   *)0,
                   (char const   *)0, (char const   *)0, (char const   *)0, (struct strerr  const  *)(& strerr_sys));
        }
      }
    }
    {
#line 108
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 108
      if (! datalen) {
#line 108
        goto while_break___4;
      }
#line 109
      if (datalen < 1024U) {
#line 109
        tmp___8 = datalen;
      } else {
#line 109
        tmp___8 = (uint32 )1024;
      }
      {
#line 109
      getb(buf, tmp___8);
      }
#line 110
      if (datalen < 1024U) {
#line 110
        tmp___9 = datalen;
      } else {
#line 110
        tmp___9 = (uint32 )1024;
      }
#line 110
      pos += tmp___9;
#line 111
      if (datalen < 1024U) {
#line 111
        tmp___10 = datalen;
      } else {
#line 111
        tmp___10 = (uint32 )1024;
      }
#line 111
      datalen -= tmp___10;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 115
  put1((char *)"records ", 8U);
#line 116
  tmp___11 = fmt_ulong((char *)0, records);
#line 116
  i = (int )tmp___11;
  }
  {
#line 116
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 116
    if (! (i < 10)) {
#line 116
      goto while_break___5;
    }
    {
#line 117
    put1((char *)" ", 1U);
#line 116
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 118
  tmp___12 = fmt_ulong(num, records);
#line 118
  put1(num, tmp___12);
#line 119
  put1((char *)"\n", 1U);
#line 120
  j = 0;
  }
  {
#line 120
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 120
    if (! (j < 10)) {
#line 120
      goto while_break___6;
    }
    {
#line 121
    put1((char *)"d", 1U);
#line 122
    tmp___13 = fmt_ulong(num, (unsigned long )j);
#line 122
    put1(num, tmp___13);
#line 123
    put1((char *)"      ", 6U);
#line 124
    tmp___14 = fmt_ulong((char *)0, distance[j]);
#line 124
    i = (int )tmp___14;
    }
    {
#line 124
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 124
      if (! (i < 10)) {
#line 124
        goto while_break___7;
      }
      {
#line 125
      put1((char *)" ", 1U);
#line 124
      i ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 126
    tmp___15 = fmt_ulong(num, distance[j]);
#line 126
    put1(num, tmp___15);
#line 127
    put1((char *)"\n", 1U);
#line 120
    j ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 129
  put1((char *)">9      ", 8U);
#line 130
  tmp___16 = fmt_ulong((char *)0, distance[j]);
#line 130
  i = (int )tmp___16;
  }
  {
#line 130
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 130
    if (! (i < 10)) {
#line 130
      goto while_break___8;
    }
    {
#line 131
    put1((char *)" ", 1U);
#line 130
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 132
  tmp___17 = fmt_ulong(num, distance[j]);
#line 132
  put1(num, tmp___17);
#line 133
  put1((char *)"\n", 1U);
#line 134
  tmp___18 = buffer_flush(buffer_1);
  }
#line 134
  if (tmp___18 == -1) {
    {
#line 135
    strerr_die(111, "cdbstats: fatal: ", "unable to flush output: ", (char const   *)0,
               (char const   *)0, (char const   *)0, (char const   *)0, (struct strerr  const  *)(& strerr_sys));
    }
  }
  {
#line 136
  _exit(0);
  }
}
}
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.h"
int error_proto ;
#line 10 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/byte.h"
int byte_diff(char *s , unsigned int n , char *t ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.h"
void cdb_free(struct cdb *c___2 ) ;
#line 28
int cdb_read(struct cdb *c___2 , char *buf___0 , unsigned int len , uint32 pos ) ;
#line 32
int cdb_find(struct cdb *c___2 , char *key , unsigned int len ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
void cdb_free(struct cdb *c___2 ) 
{ 


  {
#line 14
  if (c___2->map) {
    {
#line 15
    munmap((void *)c___2->map, (size_t )c___2->size);
#line 16
    c___2->map = (char *)0;
    }
  }
#line 18
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
void cdb_findstart(struct cdb *c___2 ) 
{ 


  {
#line 22
  c___2->loop = (uint32 )0;
#line 23
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
void cdb_init(struct cdb *c___2 , int fd ) 
{ 
  struct stat st ;
  char *x ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 30
  cdb_free(c___2);
#line 31
  cdb_findstart(c___2);
#line 32
  c___2->fd = fd;
#line 34
  tmp___1 = fstat(fd, & st);
  }
#line 34
  if (tmp___1 == 0) {
#line 35
    if (st.st_size <= 4294967295L) {
      {
#line 36
      tmp___0 = mmap((void *)0, (size_t )st.st_size, 1, 1, fd, (__off_t )0);
#line 36
      x = (char *)tmp___0;
      }
#line 37
      if (x + 1) {
#line 38
        c___2->size = (uint32 )st.st_size;
#line 39
        c___2->map = x;
      }
    }
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
int cdb_read(struct cdb *c___2 , char *buf___0 , unsigned int len , uint32 pos ) 
{ 
  int tmp___0 ;
  int r ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 46
  if (c___2->map) {
#line 47
    if (pos > c___2->size) {
#line 47
      goto FORMAT;
    } else
#line 47
    if (c___2->size - pos < len) {
#line 47
      goto FORMAT;
    }
    {
#line 48
    byte_copy(buf___0, len, c___2->map + pos);
    }
  } else {
    {
#line 51
    tmp___0 = seek_set(c___2->fd, (seek_pos )pos);
    }
#line 51
    if (tmp___0 == -1) {
#line 51
      return (-1);
    }
    {
#line 52
    while (1) {
      while_continue: /* CIL Label */ ;
#line 52
      if (! (len > 0U)) {
#line 52
        goto while_break;
      }
      {
#line 54
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 55
        tmp___1 = read(c___2->fd, (void *)buf___0, (size_t )len);
#line 55
        r = (int )tmp___1;
        }
#line 54
        if (r == -1) {
          {
#line 54
          tmp___2 = __errno_location();
          }
#line 54
          if (! (*tmp___2 == error_intr)) {
#line 54
            goto while_break___0;
          }
        } else {
#line 54
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 57
      if (r == -1) {
#line 57
        return (-1);
      }
#line 58
      if (r == 0) {
#line 58
        goto FORMAT;
      }
#line 59
      buf___0 += r;
#line 60
      len -= (unsigned int )r;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 63
  return (0);
  FORMAT: 
  {
#line 66
  tmp___3 = __errno_location();
#line 66
  *tmp___3 = error_proto;
  }
#line 67
  return (-1);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
static int match(struct cdb *c___2 , char *key , unsigned int len , uint32 pos ) 
{ 
  char buf___0[32] ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (len > 0U)) {
#line 75
      goto while_break;
    }
#line 76
    n = (int )sizeof(buf___0);
#line 77
    if ((unsigned int )n > len) {
#line 77
      n = (int )len;
    }
    {
#line 78
    tmp___0 = cdb_read(c___2, buf___0, (unsigned int )n, pos);
    }
#line 78
    if (tmp___0 == -1) {
#line 78
      return (-1);
    }
    {
#line 79
    tmp___1 = byte_diff(buf___0, n, key);
    }
#line 79
    if (tmp___1) {
#line 79
      return (0);
    }
#line 80
    pos += (uint32 )n;
#line 81
    key += n;
#line 82
    len -= (unsigned int )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (1);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
int cdb_findnext(struct cdb *c___2 , char *key , unsigned int len ) 
{ 
  char buf___0[8] ;
  uint32 pos ;
  uint32 u ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 93
  if (! c___2->loop) {
    {
#line 94
    u = cdb_hash(key, len);
#line 95
    tmp___0 = cdb_read(c___2, buf___0, 8U, (u << 3) & 2047U);
    }
#line 95
    if (tmp___0 == -1) {
#line 95
      return (-1);
    }
    {
#line 96
    uint32_unpack((char const   *)(buf___0 + 4), & c___2->hslots);
    }
#line 97
    if (! c___2->hslots) {
#line 97
      return (0);
    }
    {
#line 98
    uint32_unpack((char const   *)(buf___0), & c___2->hpos);
#line 99
    c___2->khash = u;
#line 100
    u >>= 8;
#line 101
    u %= c___2->hslots;
#line 102
    u <<= 3;
#line 103
    c___2->kpos = c___2->hpos + u;
    }
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (c___2->loop < c___2->hslots)) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp___1 = cdb_read(c___2, buf___0, 8U, c___2->kpos);
    }
#line 107
    if (tmp___1 == -1) {
#line 107
      return (-1);
    }
    {
#line 108
    uint32_unpack((char const   *)(buf___0 + 4), & pos);
    }
#line 109
    if (! pos) {
#line 109
      return (0);
    }
#line 110
    (c___2->loop) ++;
#line 111
    c___2->kpos += 8U;
#line 112
    if (c___2->kpos == c___2->hpos + (c___2->hslots << 3)) {
#line 112
      c___2->kpos = c___2->hpos;
    }
    {
#line 113
    uint32_unpack((char const   *)(buf___0), & u);
    }
#line 114
    if (u == c___2->khash) {
      {
#line 115
      tmp___2 = cdb_read(c___2, buf___0, 8U, pos);
      }
#line 115
      if (tmp___2 == -1) {
#line 115
        return (-1);
      }
      {
#line 116
      uint32_unpack((char const   *)(buf___0), & u);
      }
#line 117
      if (u == len) {
        {
#line 118
        tmp___3 = match(c___2, key, len, pos + 8U);
        }
        {
#line 119
        if (tmp___3 == -1) {
#line 119
          goto case_neg_1;
        }
#line 121
        if (tmp___3 == 1) {
#line 121
          goto case_1;
        }
#line 118
        goto switch_break;
        case_neg_1: /* CIL Label */ 
#line 120
        return (-1);
        case_1: /* CIL Label */ 
        {
#line 122
        uint32_unpack((char const   *)(buf___0 + 4), & c___2->dlen);
#line 123
        c___2->dpos = (pos + 8U) + len;
        }
#line 124
        return (1);
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
int cdb_find(struct cdb *c___2 , char *key , unsigned int len ) 
{ 
  int tmp___0 ;

  {
  {
#line 134
  cdb_findstart(c___2);
#line 135
  tmp___0 = cdb_findnext(c___2, key, len);
  }
#line 135
  return (tmp___0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.h"
int buffer_unixwrite(int fd , char const   *buf___0 , unsigned int len ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_1.c"
char buffer_1_space[8192]  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_1.c"
static buffer it___1  =    {buffer_1_space, 0U, (unsigned int )sizeof(buffer_1_space), 1, (int (*)())(& buffer_unixwrite)};
#line 7 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_1.c"
buffer *buffer_1  =    & it___1;
#line 9 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.h"
uint32 cdb_hashadd(uint32 h , unsigned char c___2 ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_hash.c"
uint32 cdb_hashadd(uint32 h , unsigned char c___2 ) 
{ 


  {
#line 7
  h += h << 5;
#line 8
  return (h ^ (unsigned int )c___2);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_hash.c"
uint32 cdb_hash(char *buf___0 , unsigned int len ) 
{ 
  uint32 h ;
  char *tmp___0 ;

  {
#line 15
  h = (uint32 )5381;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! len) {
#line 16
      goto while_break;
    }
    {
#line 17
    tmp___0 = buf___0;
#line 17
    buf___0 ++;
#line 17
    h = cdb_hashadd(h, (unsigned char )*tmp___0);
#line 18
    len --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return (h);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/byte_diff.c"
int byte_diff(char *s , unsigned int n , char *t ) 
{ 


  {
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11
    if (! n) {
#line 11
      return (0);
    }
#line 11
    if ((int )*s != (int )*t) {
#line 11
      goto while_break;
    }
#line 11
    s ++;
#line 11
    t ++;
#line 11
    n --;
#line 12
    if (! n) {
#line 12
      return (0);
    }
#line 12
    if ((int )*s != (int )*t) {
#line 12
      goto while_break;
    }
#line 12
    s ++;
#line 12
    t ++;
#line 12
    n --;
#line 13
    if (! n) {
#line 13
      return (0);
    }
#line 13
    if ((int )*s != (int )*t) {
#line 13
      goto while_break;
    }
#line 13
    s ++;
#line 13
    t ++;
#line 13
    n --;
#line 14
    if (! n) {
#line 14
      return (0);
    }
#line 14
    if ((int )*s != (int )*t) {
#line 14
      goto while_break;
    }
#line 14
    s ++;
#line 14
    t ++;
#line 14
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 16
  return ((int )((unsigned int )((unsigned char )*s)) - (int )((unsigned int )((unsigned char )*t)));
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_read.c"
int buffer_unixread(int fd , char *buf___0 , unsigned int len ) 
{ 
  ssize_t tmp___0 ;

  {
  {
#line 8
  tmp___0 = read(fd, (void *)buf___0, (size_t )len);
  }
#line 8
  return ((int )tmp___0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.h"
int buffer_bget(buffer *s , char *buf___0 , unsigned int len ) ;
#line 36
int buffer_feed(buffer *s ) ;
#line 38
char *buffer_peek(buffer *s ) ;
#line 39
void buffer_seek(buffer *s , unsigned int len ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
static int oneread(int (*op)() , int fd , char *buf___0 , unsigned int len ) 
{ 
  int r ;
  int *tmp___0 ;

  {
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 12
    r = (*op)(fd, buf___0, len);
    }
#line 13
    if (r == -1) {
      {
#line 13
      tmp___0 = __errno_location();
      }
#line 13
      if (*tmp___0 == error_intr) {
#line 13
        goto __Cont;
      }
    }
#line 14
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
static int getthis(buffer *s , char *buf___0 , unsigned int len ) 
{ 


  {
#line 20
  if (len > s->p) {
#line 20
    len = s->p;
  }
  {
#line 21
  s->p -= len;
#line 22
  byte_copy(buf___0, len, s->x + s->n);
#line 23
  s->n += len;
  }
#line 24
  return ((int )len);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
int buffer_feed(buffer *s ) 
{ 
  int r ;

  {
#line 31
  if (s->p) {
#line 31
    return ((int )s->p);
  }
  {
#line 32
  r = oneread(s->op, s->fd, s->x, s->n);
  }
#line 33
  if (r <= 0) {
#line 33
    return (r);
  }
#line 34
  s->p = (unsigned int )r;
#line 35
  s->n -= (unsigned int )r;
#line 36
  if (s->n > 0U) {
    {
#line 36
    byte_copyr(s->x + s->n, r, s->x);
    }
  }
#line 37
  return (r);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
int buffer_bget(buffer *s , char *buf___0 , unsigned int len ) 
{ 
  int r ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 44
  if (s->p > 0U) {
    {
#line 44
    tmp___0 = getthis(s, buf___0, len);
    }
#line 44
    return (tmp___0);
  }
#line 45
  if (s->n <= len) {
    {
#line 45
    tmp___1 = oneread(s->op, s->fd, buf___0, s->n);
    }
#line 45
    return (tmp___1);
  }
  {
#line 46
  r = buffer_feed(s);
  }
#line 46
  if (r <= 0) {
#line 46
    return (r);
  }
  {
#line 47
  tmp___2 = getthis(s, buf___0, len);
  }
#line 47
  return (tmp___2);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
int buffer_get(buffer *s , char *buf___0 , unsigned int len ) 
{ 
  int r ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 54
  if (s->p > 0U) {
    {
#line 54
    tmp___0 = getthis(s, buf___0, len);
    }
#line 54
    return (tmp___0);
  }
#line 55
  if (s->n <= len) {
    {
#line 55
    tmp___1 = oneread(s->op, s->fd, buf___0, len);
    }
#line 55
    return (tmp___1);
  }
  {
#line 56
  r = buffer_feed(s);
  }
#line 56
  if (r <= 0) {
#line 56
    return (r);
  }
  {
#line 57
  tmp___2 = getthis(s, buf___0, len);
  }
#line 57
  return (tmp___2);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
char *buffer_peek(buffer *s ) 
{ 


  {
#line 62
  return (s->x + s->n);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
void buffer_seek(buffer *s , unsigned int len ) 
{ 


  {
#line 67
  s->n += len;
#line 68
  s->p -= len;
#line 69
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_write.c"
int buffer_unixwrite(int fd , char const   *buf___0 , unsigned int len ) 
{ 
  ssize_t tmp___0 ;

  {
  {
#line 8
  tmp___0 = write(fd, (void const   *)buf___0, (size_t )len);
  }
#line 8
  return ((int )tmp___0);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.c"
void buffer_init(buffer *s , int (*op)() , int fd , char *buf___0 , unsigned int len ) 
{ 


  {
#line 7
  s->x = buf___0;
#line 8
  s->fd = fd;
#line 9
  s->op = op;
#line 10
  s->p = 0U;
#line 11
  s->n = len;
#line 12
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.h"
int error_noent ;
#line 14
int error_txtbsy ;
#line 15
int error_io ;
#line 16
int error_exist ;
#line 17
int error_timeout ;
#line 18
int error_inprogress ;
#line 19
int error_wouldblock ;
#line 20
int error_again ;
#line 21
int error_pipe ;
#line 22
int error_perm ;
#line 23
int error_acces ;
#line 24
int error_nodevice ;
#line 26
int error_isdir ;
#line 27
int error_connrefused ;
#line 28
int error_notdir ;
#line 8 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_intr  =    4;
#line 15 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_nomem  =    12;
#line 22 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_noent  =    2;
#line 29 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_txtbsy  =    26;
#line 36 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_io  =    5;
#line 43 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_exist  =    17;
#line 50 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_timeout  =    110;
#line 57 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_inprogress  =    115;
#line 64 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_wouldblock  =    11;
#line 71 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_again  =    11;
#line 78 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_pipe  =    32;
#line 85 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_perm  =    1;
#line 92 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_acces  =    13;
#line 99 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_nodevice  =    6;
#line 106 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_proto  =    71;
#line 113 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_isdir  =    21;
#line 120 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_connrefused  =    111;
#line 127 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.c"
int error_notdir  =    20;
#line 5 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/byte_copy.c"
void byte_copy(char *to , unsigned int n , char *from ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11
    if (! n) {
#line 11
      return;
    }
#line 11
    tmp___0 = to;
#line 11
    to ++;
#line 11
    tmp___1 = from;
#line 11
    from ++;
#line 11
    *tmp___0 = *tmp___1;
#line 11
    n --;
#line 12
    if (! n) {
#line 12
      return;
    }
#line 12
    tmp___2 = to;
#line 12
    to ++;
#line 12
    tmp___3 = from;
#line 12
    from ++;
#line 12
    *tmp___2 = *tmp___3;
#line 12
    n --;
#line 13
    if (! n) {
#line 13
      return;
    }
#line 13
    tmp___4 = to;
#line 13
    to ++;
#line 13
    tmp___5 = from;
#line 13
    from ++;
#line 13
    *tmp___4 = *tmp___5;
#line 13
    n --;
#line 14
    if (! n) {
#line 14
      return;
    }
#line 14
    tmp___6 = to;
#line 14
    to ++;
#line 14
    tmp___7 = from;
#line 14
    from ++;
#line 14
    *tmp___6 = *tmp___7;
#line 14
    n --;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer.h"
buffer *buffer_2 ;
#line 5 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_2.c"
char buffer_2_space[256]  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_2.c"
static buffer it___2  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, (int (*)())(& buffer_unixwrite)};
#line 7 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_2.c"
buffer *buffer_2  =    & it___2;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.h"
void alloc_free(char *x ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
static aligned realspace[128]  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
static unsigned int avail  =    2048U;
#line 15 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
char *alloc(unsigned int n ) 
{ 
  char *x ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
#line 19
  n = (16U + n) - (n & 15U);
#line 20
  if (n <= avail) {
#line 20
    avail -= n;
#line 20
    return ((char *)(realspace) + avail);
  }
  {
#line 21
  tmp___0 = malloc((size_t )n);
#line 21
  x = (char *)tmp___0;
  }
#line 22
  if (! x) {
    {
#line 22
    tmp___1 = __errno_location();
#line 22
    *tmp___1 = error_nomem;
    }
  }
#line 23
  return (x);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
void alloc_free(char *x ) 
{ 


  {
#line 29
  if ((unsigned long )x >= (unsigned long )((char *)(realspace))) {
#line 30
    if ((unsigned long )x < (unsigned long )((char *)(realspace) + 2048)) {
#line 31
      return;
    }
  }
  {
#line 32
  free((void *)x);
  }
#line 33
  return;
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_0.c"
static buffer it___3  =    {buffer_0_space, 0U, (unsigned int )sizeof(buffer_0_space), 0, (int (*)())(& buffer_0_read)};
#line 22 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.c"
static int posplus___0(struct cdb_make *c___2 , uint32 len ) 
{ 
  uint32 newpos ;
  int *tmp___0 ;

  {
#line 24
  newpos = c___2->pos + len;
#line 25
  if (newpos < len) {
    {
#line 25
    tmp___0 = __errno_location();
#line 25
    *tmp___0 = error_nomem;
    }
#line 25
    return (-1);
  }
#line 26
  c___2->pos = newpos;
#line 27
  return (0);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
static int allwrite___0(int (*op)() , int fd , char const   *buf___0 , unsigned int len ) 
{ 
  int w ;
  int *tmp___0 ;

  {
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! len) {
#line 12
      goto while_break;
    }
    {
#line 13
    w = (*op)(fd, buf___0, len);
    }
#line 14
    if (w == -1) {
      {
#line 15
      tmp___0 = __errno_location();
      }
#line 15
      if (*tmp___0 == error_intr) {
#line 15
        goto while_continue;
      }
#line 16
      return (-1);
    }
#line 19
    buf___0 += w;
#line 20
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  return (0);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/scan.h"
extern unsigned int scan_ulong(char const   * , unsigned long * ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbget.c"
static struct cdb c___0  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
static int match___0(struct cdb *c___2 , char *key , unsigned int len , uint32 pos ) 
{ 
  char buf___0[32] ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (len > 0U)) {
#line 75
      goto while_break;
    }
#line 76
    n = (int )sizeof(buf___0);
#line 77
    if ((unsigned int )n > len) {
#line 77
      n = (int )len;
    }
    {
#line 78
    tmp___0 = cdb_read(c___2, buf___0, (unsigned int )n, pos);
    }
#line 78
    if (tmp___0 == -1) {
#line 78
      return (-1);
    }
    {
#line 79
    tmp___1 = byte_diff(buf___0, n, key);
    }
#line 79
    if (tmp___1) {
#line 79
      return (0);
    }
#line 80
    pos += (uint32 )n;
#line 81
    key += n;
#line 82
    len -= (unsigned int )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (1);
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_1.c"
static buffer it___4  =    {buffer_1_space, 0U, (unsigned int )sizeof(buffer_1_space), 1, (int (*)())(& buffer_unixwrite)};
#line 7 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
static int oneread___0(int (*op)() , int fd , char *buf___0 , unsigned int len ) 
{ 
  int r ;
  int *tmp___0 ;

  {
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 12
    r = (*op)(fd, buf___0, len);
    }
#line 13
    if (r == -1) {
      {
#line 13
      tmp___0 = __errno_location();
      }
#line 13
      if (*tmp___0 == error_intr) {
#line 13
        goto __Cont;
      }
    }
#line 14
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
static int getthis___0(buffer *s , char *buf___0 , unsigned int len ) 
{ 


  {
#line 20
  if (len > s->p) {
#line 20
    len = s->p;
  }
  {
#line 21
  s->p -= len;
#line 22
  byte_copy(buf___0, len, s->x + s->n);
#line 23
  s->n += len;
  }
#line 24
  return ((int )len);
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_2.c"
static buffer it___5  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, (int (*)())(& buffer_unixwrite)};
#line 11 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
static aligned realspace___0[128]  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
static unsigned int avail___0  =    2048U;
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_0.c"
static buffer it___6  =    {buffer_0_space, 0U, (unsigned int )sizeof(buffer_0_space), 0, (int (*)())(& buffer_0_read)};
#line 22 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.c"
static int posplus___1(struct cdb_make *c___2 , uint32 len ) 
{ 
  uint32 newpos ;
  int *tmp___0 ;

  {
#line 24
  newpos = c___2->pos + len;
#line 25
  if (newpos < len) {
    {
#line 25
    tmp___0 = __errno_location();
#line 25
    *tmp___0 = error_nomem;
    }
#line 25
    return (-1);
  }
#line 26
  c___2->pos = newpos;
#line 27
  return (0);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
static int allwrite___1(int (*op)() , int fd , char const   *buf___0 , unsigned int len ) 
{ 
  int w ;
  int *tmp___0 ;

  {
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! len) {
#line 12
      goto while_break;
    }
    {
#line 13
    w = (*op)(fd, buf___0, len);
    }
#line 14
    if (w == -1) {
      {
#line 15
      tmp___0 = __errno_location();
      }
#line 15
      if (*tmp___0 == error_intr) {
#line 15
        goto while_continue;
      }
#line 16
      return (-1);
    }
#line 19
    buf___0 += w;
#line 20
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  return (0);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
static int match___1(struct cdb *c___2 , char *key , unsigned int len , uint32 pos ) 
{ 
  char buf___0[32] ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (len > 0U)) {
#line 75
      goto while_break;
    }
#line 76
    n = (int )sizeof(buf___0);
#line 77
    if ((unsigned int )n > len) {
#line 77
      n = (int )len;
    }
    {
#line 78
    tmp___0 = cdb_read(c___2, buf___0, (unsigned int )n, pos);
    }
#line 78
    if (tmp___0 == -1) {
#line 78
      return (-1);
    }
    {
#line 79
    tmp___1 = byte_diff(buf___0, n, key);
    }
#line 79
    if (tmp___1) {
#line 79
      return (0);
    }
#line 80
    pos += (uint32 )n;
#line 81
    key += n;
#line 82
    len -= (unsigned int )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (1);
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_1.c"
static buffer it___7  =    {buffer_1_space, 0U, (unsigned int )sizeof(buffer_1_space), 1, (int (*)())(& buffer_unixwrite)};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 956
extern int fsync(int __fd ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/error.h"
extern char const   *error_str(int  ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/open.h"
extern int open_trunc(char const   * ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbmake.c"
static struct cdb_make c___1  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbmake.c"
char *cdb  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbmake.c"
char *tmp  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbmake.c"
int entry  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbmake.c"
char ch  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbmake.c"
void die_write(void) 
{ 


  {
  {
#line 22
  strerr_die(111, "cdbmake: fatal: ", "unable to create ", (char const   *)tmp, ": ",
             (char const   *)0, (char const   *)0, (struct strerr  const  *)(& strerr_sys));
  }
#line 22
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbmake.c"
void die_read(char const   *e ) 
{ 
  char s[40] ;
  unsigned int tmp___0 ;

  {
  {
#line 26
  tmp___0 = fmt_ulong(s, (unsigned long )entry);
#line 26
  s[tmp___0] = (char)0;
#line 27
  strerr_die(111, "cdbmake: fatal: ", "unable to read input: entry ", (char const   *)(s),
             ": ", e, (char const   *)0, (struct strerr  const  *)0);
  }
#line 28
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbmake.c"
__inline void getch(void) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 31
  if (buffer_0->p > 0U) {
#line 31
    ch = *(buffer_0->x + buffer_0->n);
#line 31
    (buffer_0->p) --;
#line 31
    (buffer_0->n) ++;
#line 31
    tmp___1 = 1;
  } else {
    {
#line 31
    tmp___0 = buffer_get(buffer_0, & ch, 1U);
#line 31
    tmp___1 = tmp___0;
    }
  }
  {
#line 32
  if (tmp___1 == 0) {
#line 32
    goto case_0;
  }
#line 33
  if (tmp___1 == -1) {
#line 33
    goto case_neg_1;
  }
#line 31
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 32
  die_read("unexpected end if input");
  }
  case_neg_1: /* CIL Label */ 
  {
#line 33
  tmp___2 = __errno_location();
#line 33
  tmp___3 = error_str(*tmp___2);
#line 33
  die_read(tmp___3);
  }
  switch_break: /* CIL Label */ ;
  }
#line 35
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
static int oneread___1(int (*op)() , int fd , char *buf___0 , unsigned int len ) 
{ 
  int r ;
  int *tmp___0 ;

  {
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 12
    r = (*op)(fd, buf___0, len);
    }
#line 13
    if (r == -1) {
      {
#line 13
      tmp___0 = __errno_location();
      }
#line 13
      if (*tmp___0 == error_intr) {
#line 13
        goto __Cont;
      }
    }
#line 14
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
static int getthis___1(buffer *s , char *buf___0 , unsigned int len ) 
{ 


  {
#line 20
  if (len > s->p) {
#line 20
    len = s->p;
  }
  {
#line 21
  s->p -= len;
#line 22
  byte_copy(buf___0, len, s->x + s->n);
#line 23
  s->n += len;
  }
#line 24
  return ((int )len);
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_2.c"
static buffer it___8  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, (int (*)())(& buffer_unixwrite)};
#line 11 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
static aligned realspace___1[128]  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
static unsigned int avail___1  =    2048U;
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_0.c"
static buffer it___9  =    {buffer_0_space, 0U, (unsigned int )sizeof(buffer_0_space), 0, (int (*)())(& buffer_0_read)};
#line 12 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_0.c"
static buffer it___10  =    {buffer_0_space, 0U, (unsigned int )sizeof(buffer_0_space), 0, (int (*)())(& buffer_0_read)};
#line 22 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb_make.c"
static int posplus___2(struct cdb_make *c___2 , uint32 len ) 
{ 
  uint32 newpos ;
  int *tmp___0 ;

  {
#line 24
  newpos = c___2->pos + len;
#line 25
  if (newpos < len) {
    {
#line 25
    tmp___0 = __errno_location();
#line 25
    *tmp___0 = error_nomem;
    }
#line 25
    return (-1);
  }
#line 26
  c___2->pos = newpos;
#line 27
  return (0);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_put.c"
static int allwrite___2(int (*op)() , int fd , char const   *buf___0 , unsigned int len ) 
{ 
  int w ;
  int *tmp___0 ;

  {
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! len) {
#line 12
      goto while_break;
    }
    {
#line 13
    w = (*op)(fd, buf___0, len);
    }
#line 14
    if (w == -1) {
      {
#line 15
      tmp___0 = __errno_location();
      }
#line 15
      if (*tmp___0 == error_intr) {
#line 15
        goto while_continue;
      }
#line 16
      return (-1);
    }
#line 19
    buf___0 += w;
#line 20
    len -= (unsigned int )w;
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  return (0);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdb.c"
static int match___2(struct cdb *c___2 , char *key , unsigned int len , uint32 pos ) 
{ 
  char buf___0[32] ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (len > 0U)) {
#line 75
      goto while_break;
    }
#line 76
    n = (int )sizeof(buf___0);
#line 77
    if ((unsigned int )n > len) {
#line 77
      n = (int )len;
    }
    {
#line 78
    tmp___0 = cdb_read(c___2, buf___0, (unsigned int )n, pos);
    }
#line 78
    if (tmp___0 == -1) {
#line 78
      return (-1);
    }
    {
#line 79
    tmp___1 = byte_diff(buf___0, n, key);
    }
#line 79
    if (tmp___1) {
#line 79
      return (0);
    }
#line 80
    pos += (uint32 )n;
#line 81
    key += n;
#line 82
    len -= (unsigned int )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (1);
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_1.c"
static buffer it___11  =    {buffer_1_space, 0U, (unsigned int )sizeof(buffer_1_space), 1, (int (*)())(& buffer_unixwrite)};
#line 34 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/cdbdump.c"
void copyb(uint32 len ) 
{ 
  uint32 l ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! len) {
#line 37
      goto while_break;
    }
#line 38
    if (len < 1024U) {
#line 38
      l = len;
    } else {
#line 38
      l = (uint32 )1024;
    }
    {
#line 39
    getb(buf, l);
#line 40
    put1(buf, l);
#line 41
    len -= l;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
static int oneread___2(int (*op)() , int fd , char *buf___0 , unsigned int len ) 
{ 
  int r ;
  int *tmp___0 ;

  {
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 12
    r = (*op)(fd, buf___0, len);
    }
#line 13
    if (r == -1) {
      {
#line 13
      tmp___0 = __errno_location();
      }
#line 13
      if (*tmp___0 == error_intr) {
#line 13
        goto __Cont;
      }
    }
#line 14
    return (r);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_get.c"
static int getthis___2(buffer *s , char *buf___0 , unsigned int len ) 
{ 


  {
#line 20
  if (len > s->p) {
#line 20
    len = s->p;
  }
  {
#line 21
  s->p -= len;
#line 22
  byte_copy(buf___0, len, s->x + s->n);
#line 23
  s->n += len;
  }
#line 24
  return ((int )len);
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/buffer_2.c"
static buffer it___12  =    {buffer_2_space, 0U, (unsigned int )sizeof(buffer_2_space), 2, (int (*)())(& buffer_unixwrite)};
#line 11 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
static aligned realspace___2[128]  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/freecdb-0.75build3/alloc.c"
static unsigned int avail___2  =    2048U;
