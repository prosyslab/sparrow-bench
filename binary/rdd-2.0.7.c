/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 40 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd.h"
typedef uint32_t RDD_UINT32;
#line 76 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/msgprinter.h"
enum _rdd_message_t {
    RDD_MSG_INFO = 1,
    RDD_MSG_ERROR = 2,
    RDD_MSG_DEBUG = 4,
    RDD_MSG_WARN = 8
} ;
#line 76 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/msgprinter.h"
typedef enum _rdd_message_t rdd_message_t;
#line 96
struct _RDD_MSGPRINTER;
#line 107 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/msgprinter.h"
struct _RDD_MSGPRINTER_OPS {
   void (*print)(struct _RDD_MSGPRINTER *printer , rdd_message_t type , int errcode ,
                 char const   *msg ) ;
   int (*close)(struct _RDD_MSGPRINTER *printer , unsigned int flags ) ;
};
#line 107 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/msgprinter.h"
typedef struct _RDD_MSGPRINTER_OPS RDD_MSGPRINTER_OPS;
#line 116 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/msgprinter.h"
struct _RDD_MSGPRINTER {
   char printbuf[1024] ;
   RDD_MSGPRINTER_OPS *ops ;
   void *state ;
   RDD_UINT32 mask ;
};
#line 116 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/msgprinter.h"
typedef struct _RDD_MSGPRINTER RDD_MSGPRINTER;
#line 43 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/bcastprinter.c"
struct _RDD_BCAST_MSGPRINTER {
   unsigned int nprinter ;
   RDD_MSGPRINTER **printers ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/bcastprinter.c"
typedef struct _RDD_BCAST_MSGPRINTER RDD_BCAST_MSGPRINTER;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
struct _RDD_WRITER;
#line 68
struct _RDD_WRITE_OPS;
#line 88 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
struct _RDD_WRITE_OPS {
   int (*write)(struct _RDD_WRITER *w , unsigned char const   *buf , unsigned int nbyte ) ;
   int (*close)(struct _RDD_WRITER *w ) ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
typedef struct _RDD_WRITE_OPS RDD_WRITE_OPS;
#line 96 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
struct _RDD_WRITER {
   void *state ;
   RDD_WRITE_OPS *ops ;
};
#line 96 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
typedef struct _RDD_WRITER RDD_WRITER;
#line 53 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdwriter.c"
struct _RDD_FD_WRITER {
   int fd ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdwriter.c"
typedef struct _RDD_FD_WRITER RDD_FD_WRITER;
#line 53 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.h"
struct _RDD_FILTER;
#line 54
struct _RDD_FILTER_OPS;
#line 68 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.h"
struct _RDD_FILTER_OPS {
   int (*input)(struct _RDD_FILTER *f , unsigned char const   *buf , unsigned int nbyte ) ;
   int (*block)(struct _RDD_FILTER *f , unsigned int nbyte ) ;
   int (*close)(struct _RDD_FILTER *f ) ;
   int (*get_result)(struct _RDD_FILTER *f , unsigned char *buf , unsigned int pos ) ;
   int (*free)(struct _RDD_FILTER *f ) ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.h"
typedef struct _RDD_FILTER_OPS RDD_FILTER_OPS;
#line 76 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.h"
struct _RDD_FILTER {
   void *state ;
   RDD_FILTER_OPS *ops ;
   unsigned int blocksize ;
   unsigned int pos ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.h"
typedef struct _RDD_FILTER RDD_FILTER;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
enum _rdd_write_mode_t {
    RDD_NO_OVERWRITE = 0,
    RDD_OVERWRITE = 1,
    RDD_OVERWRITE_ASK = 2
} ;
#line 73 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
typedef enum _rdd_write_mode_t rdd_write_mode_t;
#line 64 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/safewriter.c"
struct _RDD_SAFE_WRITER {
   char *path ;
   RDD_WRITER *parent ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/safewriter.c"
typedef struct _RDD_SAFE_WRITER RDD_SAFE_WRITER;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.h"
struct _RDD_OPTION {
   char *short_name ;
   char *long_name ;
   char *arg_descr ;
   unsigned int valid_modes ;
   char *description ;
   unsigned int count ;
   char *arg_value ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.h"
typedef struct _RDD_OPTION RDD_OPTION;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 40 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd.h"
typedef uint64_t RDD_UINT64;
#line 42 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd.h"
typedef RDD_UINT64 rdd_count_t;
#line 46 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/reader.h"
struct _RDD_READER;
#line 47
struct _RDD_READ_OPS;
#line 63 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/reader.h"
struct _RDD_READ_OPS {
   int (*read)(struct _RDD_READER *r , unsigned char *buf , unsigned int nbyte , unsigned int *nread ) ;
   int (*tell)(struct _RDD_READER *r , rdd_count_t *pos ) ;
   int (*seek)(struct _RDD_READER *r , rdd_count_t pos ) ;
   int (*close)(struct _RDD_READER *r , int recurse ) ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/reader.h"
typedef struct _RDD_READ_OPS RDD_READ_OPS;
#line 73 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/reader.h"
struct _RDD_READER {
   void *state ;
   RDD_READ_OPS *ops ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/reader.h"
typedef struct _RDD_READER RDD_READER;
#line 49 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filterset.h"
struct _RDD_FSET_NODE {
   char *name ;
   RDD_FILTER *filter ;
   struct _RDD_FSET_NODE *next ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filterset.h"
typedef struct _RDD_FSET_NODE RDD_FSET_NODE;
#line 61 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filterset.h"
struct _RDD_FILTERSET {
   RDD_FSET_NODE *head ;
   RDD_FSET_NODE **tail ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filterset.h"
typedef struct _RDD_FILTERSET RDD_FILTERSET;
#line 43 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
struct _RDD_COPIER;
#line 44
struct _RDD_COPY_OPS;
#line 46 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
struct _RDD_COPIER {
   struct _RDD_COPY_OPS *ops ;
   void *state ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
typedef struct _RDD_COPIER RDD_COPIER;
#line 51 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
struct _RDD_COPIER_RETURN {
   rdd_count_t nbyte ;
   rdd_count_t nlost ;
   rdd_count_t nread_err ;
   rdd_count_t nsubst ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
typedef struct _RDD_COPIER_RETURN RDD_COPIER_RETURN;
#line 68 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
struct _RDD_COPY_OPS {
   int (*exec)(RDD_COPIER *c , RDD_READER *reader , RDD_FILTERSET *fset , RDD_COPIER_RETURN *ret ) ;
   int (*free)(RDD_COPIER *c ) ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
typedef struct _RDD_COPY_OPS RDD_COPY_OPS;
#line 37 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/numparser.h"
enum _rdd_num_flags_t {
    RDD_POSITIVE = 1,
    RDD_POWER2 = 2
} ;
#line 37 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/numparser.h"
typedef enum _rdd_num_flags_t rdd_num_flags_t;
#line 87 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
struct _RDD_SIMPLE_PARAMS {
   int (*progressfun)(rdd_count_t ncopied , void *env ) ;
   void *progressenv ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
typedef struct _RDD_SIMPLE_PARAMS RDD_SIMPLE_PARAMS;
#line 94 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
struct _RDD_ROBUST_PARAMS {
   unsigned int minblocklen ;
   unsigned int maxblocklen ;
   unsigned int nretry ;
   unsigned int maxsubst ;
   void (*readerrfun)(rdd_count_t offset , unsigned int nbyte , void *env ) ;
   void *readerrenv ;
   void (*substfun)(rdd_count_t offset , unsigned int nbyte , void *env ) ;
   void *substenv ;
   int (*progressfun)(rdd_count_t ncopied , void *env ) ;
   void *progressenv ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
typedef struct _RDD_ROBUST_PARAMS RDD_ROBUST_PARAMS;
#line 40 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/progress.h"
struct _RDD_PROGRESS {
   double period ;
   rdd_count_t input_size ;
   double start_time ;
   double last_time ;
   rdd_count_t poll_delta ;
   rdd_count_t curpos ;
   rdd_count_t last_pos ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/progress.h"
typedef struct _RDD_PROGRESS RDD_PROGRESS;
#line 50 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/progress.h"
struct _RDD_PROGRESS_INFO {
   rdd_count_t pos ;
   double speed ;
   double fraction ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/progress.h"
typedef struct _RDD_PROGRESS_INFO RDD_PROGRESS_INFO;
#line 115 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
struct _rdd_copy_opts {
   int compress ;
   int quiet ;
   char *infile ;
   char *logfile ;
   char *outpath ;
   char *simfile ;
   char *crc32file ;
   char *adler32file ;
   char *histfile ;
   char *blockmd5file ;
   int verbose ;
   int raw ;
   unsigned int mode ;
   int inetd ;
   char *server_host ;
   unsigned int server_port ;
   int force_overwrite ;
   int md5 ;
   int sha1 ;
   unsigned int nretry ;
   rdd_count_t blocklen ;
   rdd_count_t adler32len ;
   rdd_count_t crc32len ;
   rdd_count_t histblocklen ;
   rdd_count_t blockmd5len ;
   rdd_count_t minblocklen ;
   rdd_count_t offset ;
   rdd_count_t count ;
   rdd_count_t splitlen ;
   rdd_count_t progresslen ;
   rdd_count_t max_read_err ;
};
#line 115 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
typedef struct _rdd_copy_opts rdd_copy_opts;
#line 52 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/atomicreader.c"
struct _RDD_ATOMIC_READER {
   RDD_READER *parent ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/atomicreader.c"
typedef struct _RDD_ATOMIC_READER RDD_ATOMIC_READER;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 51 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdreader.c"
struct _RDD_FD_READER {
   int fd ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdreader.c"
typedef struct _RDD_FD_READER RDD_FD_READER;
#line 63 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __mode_t mode_t;
#line 44 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fileprinter.c"
struct _RDD_FILE_MSGPRINTER {
   char *path ;
   FILE *stream ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fileprinter.c"
typedef struct _RDD_FILE_MSGPRINTER RDD_FILE_MSGPRINTER;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef long ptrdiff_t;
#line 49 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedbuf.h"
struct RDD_ALIGNEDBUF {
   unsigned char *unaligned ;
   unsigned char *aligned ;
   unsigned int asize ;
   unsigned int align ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedbuf.h"
typedef struct RDD_ALIGNEDBUF RDD_ALIGNEDBUF;
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 370 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned int uInt;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 40 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd.h"
typedef uint16_t RDD_UINT16;
#line 47 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd.h"
typedef RDD_UINT32 rdd_checksum_t;
#line 49
enum __anonenum_rdd_checksum_algorithm_t_30 {
    RDD_ADLER32 = 1,
    RDD_CRC32 = 2
} ;
#line 49 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd.h"
typedef enum __anonenum_rdd_checksum_algorithm_t_30 rdd_checksum_algorithm_t;
#line 54 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd.h"
struct _RDD_CHECKSUM_FILE_HEADER {
   RDD_UINT16 magic ;
   RDD_UINT16 version ;
   RDD_UINT16 flags ;
   RDD_UINT16 reserved ;
   RDD_UINT32 blocksize ;
   off_t offset ;
   off_t imagesize ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd.h"
typedef struct _RDD_CHECKSUM_FILE_HEADER RDD_CHECKSUM_FILE_HEADER;
#line 64 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
struct _RDD_CHECKSUM_BLOCKFILTER {
   char *path ;
   FILE *fp ;
   rdd_checksum_t checksum ;
   rdd_checksum_algorithm_t algorithm ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
typedef struct _RDD_CHECKSUM_BLOCKFILTER RDD_CHECKSUM_BLOCKFILTER;
#line 54 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
typedef unsigned short rngstate_t[3];
#line 55 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
typedef unsigned long seed_t;
#line 57 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
struct _RDDFAULT {
   rdd_count_t meanpos ;
   rdd_count_t sigmapos ;
   rngstate_t rngpos ;
   seed_t pos_seed ;
   double errprob ;
   rngstate_t rngerr ;
   seed_t err_seed ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
typedef struct _RDDFAULT RDDFAULT;
#line 67 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
struct _RDD_FAULTY_READER {
   RDD_READER *parent ;
   RDDFAULT faults[8] ;
   unsigned int nfault ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
typedef struct _RDD_FAULTY_READER RDD_FAULTY_READER;
#line 57 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c"
struct _RDD_ALIGNED_READER {
   RDD_READER *parent ;
   unsigned int align ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c"
typedef struct _RDD_ALIGNED_READER RDD_ALIGNED_READER;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/msgprinter.h"
extern int rdd_mp_open_printer(RDD_MSGPRINTER **printer , RDD_MSGPRINTER_OPS *ops ,
                               unsigned int statesize ) ;
#line 146
int rdd_mp_open_bcast_printer(RDD_MSGPRINTER **printer , unsigned int nprinter , RDD_MSGPRINTER **printers ) ;
#line 167
extern int rdd_mp_close(RDD_MSGPRINTER *printer , unsigned int flags ) ;
#line 189
extern void rdd_mp_message(RDD_MSGPRINTER *printer , rdd_message_t type , char const   *fmt 
                           , ...) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/bcastprinter.c"
static void bcast_print(RDD_MSGPRINTER *printer , rdd_message_t type , int errcode ,
                        char const   *msg ) ;
#line 50
static int bcast_close(RDD_MSGPRINTER *printer , unsigned int flags ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/bcastprinter.c"
static RDD_MSGPRINTER_OPS bcast_ops  =    {& bcast_print, & bcast_close};
#line 57 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/bcastprinter.c"
int rdd_mp_open_bcast_printer(RDD_MSGPRINTER **printer , unsigned int nprinter , RDD_MSGPRINTER **printers ) 
{ 
  RDD_BCAST_MSGPRINTER *bcast ;
  RDD_MSGPRINTER **printertab ;
  RDD_MSGPRINTER *p ;
  int rc ;
  unsigned int i ;
  void *tmp ;

  {
  {
#line 61
  bcast = (RDD_BCAST_MSGPRINTER *)0;
#line 62
  printertab = (RDD_MSGPRINTER **)0;
#line 63
  p = (RDD_MSGPRINTER *)0;
#line 64
  rc = 0;
#line 67
  *printer = (RDD_MSGPRINTER *)0;
#line 69
  tmp = malloc((unsigned long )nprinter * sizeof(RDD_MSGPRINTER *));
#line 69
  printertab = (RDD_MSGPRINTER **)tmp;
  }
#line 70
  if ((unsigned long )printertab == (unsigned long )((RDD_MSGPRINTER **)0)) {
#line 71
    rc = 1;
#line 72
    goto error;
  }
#line 74
  i = 0U;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < nprinter)) {
#line 74
      goto while_break;
    }
#line 75
    *(printertab + i) = *(printers + i);
#line 74
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  rc = rdd_mp_open_printer(& p, & bcast_ops, (unsigned int )sizeof(RDD_BCAST_MSGPRINTER ));
  }
#line 79
  if (rc != 0) {
#line 80
    goto error;
  }
#line 83
  bcast = (RDD_BCAST_MSGPRINTER *)p->state;
#line 84
  bcast->nprinter = nprinter;
#line 85
  bcast->printers = printertab;
#line 87
  *printer = p;
#line 88
  return (0);
  error: 
#line 91
  *printer = (RDD_MSGPRINTER *)0;
#line 92
  if ((unsigned long )printertab != (unsigned long )((RDD_MSGPRINTER **)0)) {
    {
#line 92
    free((void *)printertab);
    }
  }
#line 93
  return (rc);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/bcastprinter.c"
static void bcast_print(RDD_MSGPRINTER *printer , rdd_message_t type , int errcode ,
                        char const   *msg ) 
{ 
  RDD_BCAST_MSGPRINTER *bcast ;
  unsigned int i ;

  {
#line 100
  bcast = (RDD_BCAST_MSGPRINTER *)printer->state;
#line 103
  i = 0U;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < bcast->nprinter)) {
#line 103
      goto while_break;
    }
    {
#line 104
    rdd_mp_message(*(bcast->printers + i), type, "%s", msg);
#line 103
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/bcastprinter.c"
static int bcast_close(RDD_MSGPRINTER *printer , unsigned int flags ) 
{ 
  RDD_BCAST_MSGPRINTER *bcast ;
  unsigned int i ;
  int rc ;

  {
#line 111
  bcast = (RDD_BCAST_MSGPRINTER *)printer->state;
#line 115
  if ((flags & 1U) != 0U) {
#line 116
    i = 0U;
    {
#line 116
    while (1) {
      while_continue: /* CIL Label */ ;
#line 116
      if (! (i < bcast->nprinter)) {
#line 116
        goto while_break;
      }
      {
#line 117
      rc = rdd_mp_close(*(bcast->printers + i), flags);
      }
#line 118
      if (rc != 0) {
#line 119
        return (rc);
      }
#line 116
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 124
  free((void *)bcast->printers);
#line 125
  memset((void *)bcast, 0, sizeof(*bcast));
  }
#line 126
  return (0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
extern int rdd_new_writer(RDD_WRITER **w , RDD_WRITE_OPS *ops , unsigned int statesize ) ;
#line 135
int rdd_open_fd_writer(RDD_WRITER **self , int fd ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdwriter.c"
static int fd_write(RDD_WRITER *w , unsigned char const   *buf , unsigned int nbyte ) ;
#line 46
static int fd_close(RDD_WRITER *self ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdwriter.c"
static RDD_WRITE_OPS fd_write_ops  =    {& fd_write, & fd_close};
#line 57 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdwriter.c"
int rdd_open_fd_writer(RDD_WRITER **self , int fd ) 
{ 
  RDD_WRITER *w ;
  RDD_FD_WRITER *state ;
  int rc ;

  {
  {
#line 60
  w = (RDD_WRITER *)0;
#line 61
  state = (RDD_FD_WRITER *)0;
#line 62
  rc = 0;
#line 64
  rc = rdd_new_writer(& w, & fd_write_ops, (unsigned int )sizeof(RDD_FD_WRITER ));
  }
#line 65
  if (rc != 0) {
#line 66
    return (rc);
  }
#line 68
  state = (RDD_FD_WRITER *)w->state;
#line 69
  state->fd = fd;
#line 71
  *self = w;
#line 72
  return (0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdwriter.c"
static int fd_write(RDD_WRITER *w , unsigned char const   *buf , unsigned int nbyte ) 
{ 
  RDD_FD_WRITER *state ;
  int n ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 80
  state = (RDD_FD_WRITER *)w->state;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (nbyte > 0U)) {
#line 83
      goto while_break;
    }
    {
#line 84
    tmp___0 = write(state->fd, (void const   *)buf, (size_t )nbyte);
#line 84
    n = (int )tmp___0;
    }
#line 84
    if (n < 0) {
      {
#line 88
      tmp = __errno_location();
      }
#line 88
      if (*tmp == 28) {
#line 89
        return (12);
      } else {
#line 91
        return (4);
      }
    }
#line 94
    buf += n;
#line 95
    nbyte -= (unsigned int )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (0);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdwriter.c"
static int fd_close(RDD_WRITER *self ) 
{ 
  RDD_FD_WRITER *state ;
  int rc ;

  {
  {
#line 104
  state = (RDD_FD_WRITER *)self->state;
#line 107
  rc = close(state->fd);
  }
#line 107
  if (rc < 0) {
#line 108
    return (5);
  }
#line 111
  return (0);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.h"
int rdd_new_filter(RDD_FILTER **new , RDD_FILTER_OPS *ops , unsigned int statesize ,
                   unsigned int blocksize ) ;
#line 128
int rdd_filter_push(RDD_FILTER *f , unsigned char const   *buf , unsigned int nbyte ) ;
#line 137
int rdd_filter_close(RDD_FILTER *f ) ;
#line 149
int rdd_filter_get_result(RDD_FILTER *f , unsigned char *buf , unsigned int nbyte ) ;
#line 158
int rdd_filter_free(RDD_FILTER *f ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.c"
int rdd_new_filter(RDD_FILTER **new , RDD_FILTER_OPS *ops , unsigned int statesize ,
                   unsigned int blocksize ) 
{ 
  RDD_FILTER *f ;
  unsigned char *state ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 60
  f = (RDD_FILTER *)0;
#line 61
  state = (unsigned char *)0;
#line 62
  rc = 0;
#line 64
  if ((unsigned long )new == (unsigned long )((RDD_FILTER **)0)) {
#line 64
    return (2);
  } else
#line 64
  if ((unsigned long )ops == (unsigned long )((RDD_FILTER_OPS *)0)) {
#line 64
    return (2);
  }
#line 66
  if ((unsigned long )ops->block != (unsigned long )((int (*)(struct _RDD_FILTER *f ,
                                                              unsigned int nbyte ))0)) {
#line 66
    if (blocksize == 0U) {
#line 66
      return (2);
    }
  }
  {
#line 68
  tmp = calloc((size_t )1, sizeof(RDD_FILTER ));
#line 68
  f = (RDD_FILTER *)tmp;
  }
#line 68
  if ((unsigned long )f == (unsigned long )((RDD_FILTER *)0)) {
#line 69
    rc = 1;
#line 70
    goto error;
  }
  {
#line 73
  tmp___0 = calloc((size_t )1, (size_t )statesize);
#line 73
  state = (unsigned char *)tmp___0;
  }
#line 73
  if ((unsigned long )state == (unsigned long )((unsigned char *)0)) {
#line 74
    rc = 1;
#line 75
    goto error;
  }
#line 78
  f->ops = ops;
#line 79
  f->state = (void *)state;
#line 80
  f->pos = 0U;
#line 81
  f->blocksize = blocksize;
#line 83
  *new = f;
#line 84
  return (0);
  error: 
#line 87
  *new = (RDD_FILTER *)0;
#line 88
  if ((unsigned long )state != (unsigned long )((unsigned char *)0)) {
    {
#line 88
    free((void *)state);
    }
  }
#line 89
  if ((unsigned long )f != (unsigned long )((RDD_FILTER *)0)) {
    {
#line 89
    free((void *)f);
    }
  }
#line 90
  return (rc);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.c"
static int stream_filter_push(RDD_FILTER *f , unsigned char const   *buf , unsigned int nbyte ) 
{ 
  RDD_FILTER_OPS *ops ;
  int tmp ;

  {
  {
#line 96
  ops = f->ops;
#line 98
  tmp = (*(ops->input))(f, buf, nbyte);
  }
#line 98
  return (tmp);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.c"
static int block_filter_push(RDD_FILTER *f , unsigned char const   *buf , unsigned int nbyte ) 
{ 
  RDD_FILTER_OPS *ops ;
  unsigned int todo ;
  int rc ;

  {
#line 104
  ops = f->ops;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (nbyte > 0U)) {
#line 108
      goto while_break;
    }
#line 109
    if (f->pos + nbyte > f->blocksize) {
#line 110
      todo = f->blocksize - f->pos;
    } else {
#line 112
      todo = nbyte;
    }
    {
#line 115
    rc = (*(ops->input))(f, buf, todo);
    }
#line 116
    if (rc != 0) {
#line 117
      return (rc);
    }
#line 120
    buf += todo;
#line 121
    nbyte -= todo;
#line 122
    f->pos += todo;
#line 123
    if (f->pos >= f->blocksize) {
      {
#line 126
      rc = (*(ops->block))(f, f->pos);
      }
#line 127
      if (rc != 0) {
#line 128
        return (rc);
      }
#line 130
      f->pos = 0U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.c"
int rdd_filter_push(RDD_FILTER *f , unsigned char const   *buf , unsigned int nbyte ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 147
  if ((unsigned long )(f->ops)->block == (unsigned long )((int (*)(struct _RDD_FILTER *f ,
                                                                   unsigned int nbyte ))0)) {
    {
#line 148
    tmp = stream_filter_push(f, buf, nbyte);
    }
#line 148
    return (tmp);
  } else {
    {
#line 150
    tmp___0 = block_filter_push(f, buf, nbyte);
    }
#line 150
    return (tmp___0);
  }
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.c"
int rdd_filter_close(RDD_FILTER *f ) 
{ 
  RDD_FILTER_OPS *ops ;
  int rc ;
  int tmp ;

  {
#line 157
  ops = f->ops;
#line 160
  if ((unsigned long )(f->ops)->block != (unsigned long )((int (*)(struct _RDD_FILTER *f ,
                                                                   unsigned int nbyte ))0)) {
#line 160
    if (f->pos > 0U) {
      {
#line 161
      rc = (*(ops->block))(f, f->pos);
      }
#line 162
      if (rc != 0) {
#line 163
        return (rc);
      }
#line 165
      f->pos = 0U;
    }
  }
#line 168
  if ((unsigned long )ops->close != (unsigned long )((int (*)(struct _RDD_FILTER *f ))0)) {
    {
#line 169
    tmp = (*(ops->close))(f);
    }
#line 169
    return (tmp);
  }
#line 172
  return (0);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.c"
int rdd_filter_get_result(RDD_FILTER *f , unsigned char *buf , unsigned int nbyte ) 
{ 
  RDD_FILTER_OPS *ops ;
  int tmp ;

  {
#line 178
  ops = f->ops;
#line 180
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0)) {
#line 180
    return (2);
  }
#line 182
  if ((unsigned long )ops->get_result == (unsigned long )((int (*)(struct _RDD_FILTER *f ,
                                                                   unsigned char *buf ,
                                                                   unsigned int pos ))0)) {
#line 182
    return (16);
  }
  {
#line 184
  tmp = (*(ops->get_result))(f, buf, nbyte);
  }
#line 184
  return (tmp);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.c"
int rdd_filter_free(RDD_FILTER *f ) 
{ 
  RDD_FILTER_OPS *ops ;
  int rc ;

  {
#line 190
  ops = f->ops;
#line 193
  if ((unsigned long )ops->free != (unsigned long )((int (*)(struct _RDD_FILTER *f ))0)) {
    {
#line 194
    rc = (*(ops->free))(f);
    }
#line 195
    if (rc != 0) {
#line 196
      return (rc);
    }
  }
  {
#line 200
  free(f->state);
#line 201
  f->state = (void *)0;
#line 202
  free((void *)f);
  }
#line 204
  return (0);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
int rdd_open_file_writer(RDD_WRITER **w , char const   *path ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filewriter.c"
int rdd_open_file_writer(RDD_WRITER **w , char const   *path ) 
{ 
  int fd ;
  int tmp ;

  {
  {
#line 57
  fd = -1;
#line 59
  fd = open(path, 577, 384);
  }
#line 59
  if (fd < 0) {
#line 60
    return (7);
  }
  {
#line 63
  tmp = rdd_open_fd_writer(w, fd);
  }
#line 63
  return (tmp);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 174 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
int rdd_open_safe_writer(RDD_WRITER **self , char const   *path , rdd_write_mode_t wmode ) ;
#line 218
extern int rdd_writer_write(RDD_WRITER *w , unsigned char const   *buf , unsigned int nbyte ) ;
#line 229
extern int rdd_writer_close(RDD_WRITER *w ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/safewriter.c"
static int safe_write(RDD_WRITER *w , unsigned char const   *buf , unsigned int nbyte ) ;
#line 57
static int safe_close(RDD_WRITER *self ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/safewriter.c"
static RDD_WRITE_OPS safe_write_ops  =    {& safe_write, & safe_close};
#line 72 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/safewriter.c"
static int path_exists(char const   *path , struct stat *info ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 75
  tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)info);
  }
#line 75
  if (tmp != -1) {
#line 75
    tmp___1 = 1;
  } else {
    {
#line 75
    tmp___0 = __errno_location();
    }
#line 75
    if (*tmp___0 != 2) {
#line 75
      tmp___1 = 1;
    } else {
#line 75
      tmp___1 = 0;
    }
  }
#line 75
  return (tmp___1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/safewriter.c"
int rdd_open_safe_writer(RDD_WRITER **self , char const   *path , rdd_write_mode_t wmode ) 
{ 
  RDD_WRITER *w ;
  RDD_SAFE_WRITER *state ;
  struct stat statinfo ;
  int rc ;
  char *pathcopy ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 82
  w = (RDD_WRITER *)0;
#line 83
  state = (RDD_SAFE_WRITER *)0;
#line 85
  rc = 0;
#line 86
  pathcopy = (char *)0;
#line 88
  if ((unsigned int )wmode == 0U) {
    {
#line 88
    tmp = path_exists(path, & statinfo);
    }
#line 88
    if (tmp) {
#line 89
      rc = 6;
#line 90
      goto error;
    }
  }
  {
#line 93
  rc = rdd_new_writer(& w, & safe_write_ops, (unsigned int )sizeof(RDD_SAFE_WRITER ));
  }
#line 94
  if (rc != 0) {
#line 95
    goto error;
  }
  {
#line 97
  state = (RDD_SAFE_WRITER *)w->state;
#line 99
  tmp___0 = strlen(path);
#line 99
  tmp___1 = malloc(tmp___0 + 1UL);
#line 99
  pathcopy = (char *)tmp___1;
  }
#line 99
  if ((unsigned long )pathcopy == (unsigned long )((char *)0)) {
#line 100
    rc = 1;
#line 101
    goto error;
  }
  {
#line 103
  strcpy((char */* __restrict  */)pathcopy, (char const   */* __restrict  */)path);
#line 104
  state->path = pathcopy;
#line 106
  rc = rdd_open_file_writer(& state->parent, path);
  }
#line 107
  if (rc != 0) {
#line 108
    goto error;
  }
#line 111
  *self = w;
#line 112
  return (0);
  error: 
#line 115
  *self = (RDD_WRITER *)0;
#line 116
  if ((unsigned long )pathcopy != (unsigned long )((char *)0)) {
    {
#line 116
    free((void *)pathcopy);
    }
  }
#line 117
  if ((unsigned long )state != (unsigned long )((RDD_SAFE_WRITER *)0)) {
    {
#line 117
    free((void *)state);
    }
  }
#line 118
  if ((unsigned long )w != (unsigned long )((RDD_WRITER *)0)) {
    {
#line 118
    free((void *)w);
    }
  }
#line 119
  return (rc);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/safewriter.c"
static int safe_write(RDD_WRITER *w , unsigned char const   *buf , unsigned int nbyte ) 
{ 
  RDD_SAFE_WRITER *state ;
  int tmp ;

  {
  {
#line 125
  state = (RDD_SAFE_WRITER *)w->state;
#line 127
  tmp = rdd_writer_write(state->parent, buf, nbyte);
  }
#line 127
  return (tmp);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/safewriter.c"
static int safe_close(RDD_WRITER *self ) 
{ 
  RDD_SAFE_WRITER *state ;
  struct stat statinfo ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 133
  state = (RDD_SAFE_WRITER *)self->state;
#line 137
  rc = rdd_writer_close(state->parent);
  }
#line 137
  if (rc != 0) {
#line 138
    return (rc);
  }
  {
#line 141
  tmp = stat((char const   */* __restrict  */)state->path, (struct stat */* __restrict  */)(& statinfo));
  }
#line 141
  if (tmp < 0) {
#line 142
    return (5);
  }
#line 145
  if ((statinfo.st_mode & 61440U) == 32768U) {
    {
#line 145
    tmp___0 = chmod((char const   *)state->path, (__mode_t )((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
    }
#line 145
    if (tmp___0 < 0) {
#line 145
      tmp___1 = 1;
    } else {
#line 145
      tmp___1 = 0;
    }
  } else {
#line 145
    tmp___1 = 0;
  }
  {
#line 152
  free((void *)state->path);
#line 153
  state->path = (char *)0;
  }
#line 155
  return (0);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.h"
void bug(char *fmt  , ...) ;
#line 80
void error(char *fmt  , ...) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.h"
void rdd_opt_init(RDD_OPTION *tab , char const   *usage_msg ) ;
#line 54
RDD_OPTION *rdd_get_opt_with_arg(char **argv , int argc , unsigned int *i , char **opt ,
                                 char **arg ) ;
#line 57
int rdd_opt_set_arg(char *longname , char **argp ) ;
#line 59
int rdd_opt_set(char *longname ) ;
#line 61
void rdd_opt_usage(void) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.c"
static RDD_OPTION *opttab  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.c"
static char const   *usage_message  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.c"
void rdd_opt_init(RDD_OPTION *tab , char const   *usage_msg ) 
{ 


  {
#line 64
  opttab = tab;
#line 65
  usage_message = usage_msg;
#line 66
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.c"
RDD_OPTION *rdd_get_opt_with_arg(char **argv , int argc , unsigned int *i , char **opt ,
                                 char **arg ) 
{ 
  RDD_OPTION *od ;
  char *optname ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 77
  optname = *(argv + *i);
#line 78
  od = opttab + 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! ((unsigned long )od->short_name != (unsigned long )((char *)0))) {
#line 78
      goto while_break;
    }
    {
#line 79
    tmp = strcmp((char const   *)od->short_name, (char const   *)optname);
    }
#line 79
    if (! (tmp == 0)) {
#line 79
      if ((unsigned long )od->long_name == (unsigned long )((char *)0)) {
#line 81
        goto __Cont;
      } else {
        {
#line 79
        tmp___0 = strcmp((char const   *)od->long_name, (char const   *)optname);
        }
#line 79
        if (! (tmp___0 == 0)) {
#line 81
          goto __Cont;
        }
      }
    }
#line 84
    (od->count) ++;
#line 84
    if (od->count > 1U) {
      {
#line 85
      error((char *)"option %s specified multiple times", optname);
      }
    }
#line 88
    *opt = optname;
#line 89
    if ((unsigned long )od->arg_descr == (unsigned long )((char *)0)) {
#line 90
      *arg = (char *)0;
    } else {
#line 92
      (*i) ++;
#line 93
      if (*i >= (unsigned int )argc) {
        {
#line 94
        error((char *)"option %s requires an argument", optname);
        }
      }
#line 96
      tmp___1 = *(argv + *i);
#line 96
      *arg = tmp___1;
#line 96
      od->arg_value = tmp___1;
    }
#line 99
    return (od);
    __Cont: /* CIL Label */ 
#line 78
    od ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return ((RDD_OPTION *)0);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.c"
int rdd_opt_set_arg(char *longname , char **argp ) 
{ 
  RDD_OPTION *od ;
  int tmp ;

  {
#line 109
  od = opttab + 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )od->short_name != (unsigned long )((char *)0))) {
#line 109
      goto while_break;
    }
    {
#line 110
    tmp = strcmp((char const   *)(od->long_name + 2), (char const   *)longname);
    }
#line 110
    if (tmp == 0) {
#line 111
      if (od->count == 0U) {
#line 112
        return (0);
      }
#line 114
      if ((unsigned long )argp != (unsigned long )((char **)0)) {
#line 115
        *argp = od->arg_value;
      }
#line 117
      return (1);
    }
#line 109
    od ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  bug((char *)"opt_set_arg: %s is not a known option", longname);
  }
#line 121
  return (0);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.c"
int rdd_opt_set(char *longname ) 
{ 
  int tmp ;

  {
  {
#line 127
  tmp = rdd_opt_set_arg(longname, (char **)0);
  }
#line 127
  return (tmp);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/commandline.c"
void rdd_opt_usage(void) 
{ 
  RDD_OPTION *od ;
  char optnames[80] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 136
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s",
          usage_message);
#line 137
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
#line 138
  od = opttab + 0;
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! ((unsigned long )od->short_name != (unsigned long )((char *)0))) {
#line 138
      goto while_break;
    }
#line 139
    if ((unsigned long )od->long_name != (unsigned long )((char *)0)) {
#line 140
      if ((unsigned long )od->arg_descr == (unsigned long )((char *)0)) {
#line 140
        tmp = "";
      } else {
#line 140
        tmp = (char const   *)od->arg_descr;
      }
      {
#line 140
      snprintf((char */* __restrict  */)(optnames), sizeof(optnames), (char const   */* __restrict  */)"%s, %s %s",
               od->short_name, od->long_name, tmp);
      }
    } else {
#line 144
      if ((unsigned long )od->arg_descr == (unsigned long )((char *)0)) {
#line 144
        tmp___0 = "";
      } else {
#line 144
        tmp___0 = (char const   *)od->arg_descr;
      }
      {
#line 144
      snprintf((char */* __restrict  */)(optnames), sizeof(optnames), (char const   */* __restrict  */)"%s %s",
               od->short_name, tmp___0);
      }
    }
    {
#line 147
    optnames[sizeof(optnames) - 1UL] = (char )'\000';
#line 149
    tmp___1 = strlen((char const   *)(optnames));
    }
#line 149
    if (tmp___1 <= 32UL) {
      {
#line 150
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-32.32s %s\n",
              optnames, od->description);
      }
    } else {
      {
#line 153
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              optnames);
#line 154
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-32.32s %s\n",
              "", od->description);
      }
    }
#line 138
    od ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  exit(1);
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd_internals.h"
extern char *rdd_ctime(void) ;
#line 74
void rdd_cons_vprintf(char *fmt , va_list ap ) ;
#line 84
extern int rdd_strerror(int rc , char *buf , unsigned int bufsize ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.h"
void set_progname(char *name ) ;
#line 60
void set_logfile(FILE *fp ) ;
#line 89
void warn(char *fmt  , ...) ;
#line 100
void unix_error(char *fmt  , ...) ;
#line 112
void unix_warn(char *fmt  , ...) ;
#line 116
void errlog(char *fmt  , ...) ;
#line 120
void errlognl(char *fmt  , ...) ;
#line 132
void rdd_error(int errcode , char *fmt  , ...) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
static char *progname  =    (char *)"<unknown program>";
#line 56 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
static char *email_addr  =    (char *)"rdd@holmes.nl";
#line 58 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
static char *bug_message_fmt  =    (char *)"Rdd has crashed.  Please do the following:\n  1. Write down the time of day reported by your computer.\n  2. If rdd dumped core, save a copy of the core file.\n  3. Save a copy of /var/log/messages.\n  4. Save a copy of your rdd binary.\n  4. Report this problem to %s.\n";
#line 66 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
static FILE *logfp  =    (FILE *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
static int new_line  =    1;
#line 78 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
static void log_vprintf(int console , char *fmt , va_list ap ) 
{ 


  {
#line 81
  if (console) {
    {
#line 83
    rdd_cons_vprintf(fmt, ap);
    }
  }
#line 91
  if ((unsigned long )logfp != (unsigned long )((void *)0)) {
    {
#line 95
    vfprintf((FILE */* __restrict  */)logfp, (char const   */* __restrict  */)fmt,
             ap);
    }
  } else
#line 96
  if (! console) {
    {
#line 103
    rdd_cons_vprintf(fmt, ap);
    }
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
static void log_printf(int console , char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 117
  __builtin_va_start(ap, fmt);
#line 118
  log_vprintf(console, fmt, ap);
#line 119
  __builtin_va_end(ap);
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
static void log_flush(void) 
{ 


  {
#line 125
  if ((unsigned long )logfp != (unsigned long )((void *)0)) {
    {
#line 125
    fflush(logfp);
    }
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void set_progname(char *name ) 
{ 


  {
#line 131
  progname = name;
#line 132
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void set_logfile(FILE *fp ) 
{ 


  {
#line 137
  if ((unsigned long )logfp != (unsigned long )((void *)0)) {
    {
#line 138
    fflush(logfp);
    }
  }
#line 140
  logfp = fp;
#line 141
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void bug(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 148
  __builtin_va_start(ap, fmt);
#line 149
  log_printf(1, (char *)"%s: bug: ", progname);
#line 150
  log_vprintf(1, fmt, ap);
#line 151
  log_printf(1, (char *)"\n\n");
#line 152
  log_printf(1, bug_message_fmt, email_addr);
#line 153
  log_flush();
#line 154
  __builtin_va_end(ap);
#line 155
  abort();
  }
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void error(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 163
  __builtin_va_start(ap, fmt);
#line 164
  log_printf(1, (char *)"%s: ", progname);
#line 165
  log_vprintf(1, fmt, ap);
#line 166
  log_printf(1, (char *)"\n");
#line 167
  log_flush();
#line 168
  __builtin_va_end(ap);
#line 169
  exit(1);
  }
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void warn(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 177
  __builtin_va_start(ap, fmt);
#line 178
  log_printf(1, (char *)"(warning) %s: ", progname);
#line 179
  log_vprintf(1, fmt, ap);
#line 180
  log_printf(1, (char *)"\n");
#line 181
  log_flush();
#line 182
  __builtin_va_end(ap);
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void unix_warn(char *fmt  , ...) 
{ 
  va_list ap ;
  int err ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 189
  tmp = __errno_location();
#line 189
  err = *tmp;
#line 191
  __builtin_va_start(ap, fmt);
#line 192
  log_printf(1, (char *)"%s: ", progname);
#line 193
  log_vprintf(1, fmt, ap);
#line 194
  tmp___0 = strerror(err);
#line 194
  log_printf(1, (char *)": %s\n", tmp___0);
#line 195
  log_flush();
#line 196
  __builtin_va_end(ap);
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void unix_error(char *fmt  , ...) 
{ 
  va_list ap ;
  int err ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 203
  tmp = __errno_location();
#line 203
  err = *tmp;
#line 205
  __builtin_va_start(ap, fmt);
#line 206
  log_printf(1, (char *)"%s: ", progname);
#line 207
  log_vprintf(1, fmt, ap);
#line 208
  tmp___0 = strerror(err);
#line 208
  log_printf(1, (char *)": %s\n", tmp___0);
#line 209
  log_flush();
#line 210
  __builtin_va_end(ap);
#line 211
  exit(1);
  }
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void errlog(char *fmt  , ...) 
{ 
  va_list ap ;
  char *tmp ;

  {
#line 219
  if (new_line) {
    {
#line 219
    tmp = rdd_ctime();
#line 219
    log_printf(1, (char *)"%s: ", tmp);
    }
  }
  {
#line 221
  __builtin_va_start(ap, fmt);
#line 222
  log_vprintf(1, fmt, ap);
#line 223
  __builtin_va_end(ap);
#line 225
  new_line = 0;
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void errlognl(char *fmt  , ...) 
{ 
  va_list ap ;
  char *tmp ;

  {
#line 233
  if (new_line) {
    {
#line 233
    tmp = rdd_ctime();
#line 233
    log_printf(1, (char *)"%s: ", tmp);
    }
  }
  {
#line 235
  __builtin_va_start(ap, fmt);
#line 236
  log_vprintf(1, fmt, ap);
#line 237
  log_printf(1, (char *)"\n");
#line 238
  log_flush();
#line 239
  __builtin_va_end(ap);
#line 241
  new_line = 1;
  }
#line 242
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/error.c"
void rdd_error(int errcode , char *fmt  , ...) 
{ 
  char msg[1024] ;
  va_list ap ;
  int rc ;

  {
  {
#line 251
  __builtin_va_start(ap, fmt);
#line 252
  log_printf(1, (char *)"%s: ", progname);
#line 253
  log_vprintf(1, fmt, ap);
#line 254
  __builtin_va_end(ap);
#line 256
  log_printf(1, (char *)": ");
#line 257
  rc = rdd_strerror(errcode, msg, (unsigned int )sizeof(msg));
  }
#line 258
  if (rc == 1) {
    {
#line 259
    log_printf(1, (char *)"<error message too long>");
    }
  } else
#line 260
  if (rc == 0) {
    {
#line 261
    log_printf(1, msg);
    }
  } else {
    {
#line 263
    log_printf(1, (char *)"internal error: unknown error code [%d]\n", errcode);
#line 265
    abort();
    }
  }
  {
#line 268
  log_printf(1, (char *)"\n");
#line 270
  log_flush();
#line 271
  exit(1);
  }
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
int rdd_new_copier(RDD_COPIER **self , RDD_COPY_OPS *ops , unsigned int statesize ) ;
#line 185
int rdd_copy_exec(RDD_COPIER *c , RDD_READER *r , RDD_FILTERSET *fset , RDD_COPIER_RETURN *ret ) ;
#line 192
int rdd_copy_free(RDD_COPIER *c ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.c"
int rdd_new_copier(RDD_COPIER **self , RDD_COPY_OPS *ops , unsigned int statesize ) 
{ 
  RDD_COPIER *c ;
  unsigned char *state ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 51
  c = (RDD_COPIER *)0;
#line 52
  state = (unsigned char *)0;
#line 55
  if ((unsigned long )self == (unsigned long )((RDD_COPIER **)0)) {
#line 55
    return (2);
  } else
#line 55
  if ((unsigned long )ops == (unsigned long )((RDD_COPY_OPS *)0)) {
#line 55
    return (2);
  }
  {
#line 57
  tmp = calloc((size_t )1, sizeof(RDD_COPIER ));
#line 57
  c = (RDD_COPIER *)tmp;
  }
#line 57
  if ((unsigned long )c == (unsigned long )((RDD_COPIER *)0)) {
#line 58
    rc = 1;
#line 59
    goto error;
  }
  {
#line 61
  tmp___0 = calloc((size_t )1, (size_t )statesize);
#line 61
  state = (unsigned char *)tmp___0;
  }
#line 61
  if ((unsigned long )state == (unsigned long )((unsigned char *)0)) {
#line 62
    rc = 1;
#line 63
    goto error;
  }
#line 65
  c->state = (void *)state;
#line 66
  c->ops = ops;
#line 68
  *self = c;
#line 69
  return (0);
  error: 
#line 72
  *self = (RDD_COPIER *)0;
#line 73
  if ((unsigned long )state != (unsigned long )((unsigned char *)0)) {
    {
#line 73
    free((void *)state);
    }
  }
#line 74
  if ((unsigned long )c != (unsigned long )((RDD_COPIER *)0)) {
    {
#line 74
    free((void *)c);
    }
  }
#line 75
  return (rc);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.c"
int rdd_copy_exec(RDD_COPIER *c , RDD_READER *r , RDD_FILTERSET *fset , RDD_COPIER_RETURN *ret ) 
{ 
  RDD_COPY_OPS *ops ;
  int tmp ;

  {
  {
#line 82
  ops = c->ops;
#line 84
  tmp = (*(ops->exec))(c, r, fset, ret);
  }
#line 84
  return (tmp);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.c"
int rdd_copy_free(RDD_COPIER *c ) 
{ 
  RDD_COPY_OPS *ops ;
  int rc ;

  {
#line 90
  ops = c->ops;
#line 93
  if ((unsigned long )ops->free != (unsigned long )((int (*)(RDD_COPIER *c ))0)) {
    {
#line 94
    rc = (*(ops->free))(c);
    }
#line 95
    if (rc != 0) {
#line 96
      return (rc);
    }
  }
  {
#line 100
  free(c->state);
#line 101
  c->state = (void *)0;
#line 102
  free((void *)c);
  }
#line 104
  return (0);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd_internals.h"
extern void rdd_init(void) ;
#line 58
void rdd_set_quiet(int q ) ;
#line 60
extern void *rdd_malloc(size_t sz ) ;
#line 64
extern int rdd_buf2hex(unsigned char const   *buf , unsigned int bufsize , char *hexbuf ,
                       unsigned int hexbuflen ) ;
#line 69
extern double rdd_gettime(void) ;
#line 71
void rdd_cons_open(void) ;
#line 72
void rdd_cons_close(void) ;
#line 76
void rdd_quit_if(int quit_answer , char *fmt  , ...) ;
#line 78
extern char *rdd_strsize(rdd_count_t sz ) ;
#line 80
extern void rdd_catch_signals(void) ;
#line 82
extern int rdd_device_size(char const   *path , rdd_count_t *size ) ;
#line 216 "/usr/include/zlib.h"
extern char const   *zlibVersion(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/numparser.h"
extern int rdd_parse_bignum(char const   *str , rdd_num_flags_t flags , rdd_count_t *result ) ;
#line 45
extern int rdd_parse_uint(char const   *str , unsigned int *result ) ;
#line 47
extern int rdd_parse_tcp_port(char const   *str , unsigned int *result ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/reader.h"
int rdd_open_fd_reader(RDD_READER **self , int fd ) ;
#line 127
int rdd_open_aligned_reader(RDD_READER **self , RDD_READER *parent , unsigned int align ) ;
#line 137
int rdd_open_file_reader(RDD_READER **r , char const   *path , int raw ) ;
#line 164
extern int rdd_open_zlib_reader(RDD_READER **r , RDD_READER *p ) ;
#line 174
int rdd_open_faulty_reader(RDD_READER **self , RDD_READER *parent , char *path ) ;
#line 214
extern int rdd_reader_seek(RDD_READER *r , rdd_count_t pos ) ;
#line 234
extern int rdd_reader_close(RDD_READER *r , int recurse ) ;
#line 128 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/writer.h"
extern int rdd_open_zlib_writer(RDD_WRITER **w , RDD_WRITER *parent ) ;
#line 161
extern int rdd_open_tcp_writer(RDD_WRITER **w , char const   *host , unsigned int port ) ;
#line 195
extern int rdd_open_part_writer(RDD_WRITER **w , char const   *basepath , rdd_count_t maxlen ,
                                rdd_count_t splitlen , rdd_write_mode_t overwrite ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filter.h"
extern int rdd_new_md5_streamfilter(RDD_FILTER **f ) ;
#line 94
extern int rdd_new_sha1_streamfilter(RDD_FILTER **f ) ;
#line 96
extern int rdd_new_write_streamfilter(RDD_FILTER **f , RDD_WRITER *writer ) ;
#line 98
extern int rdd_new_md5_blockfilter(RDD_FILTER **f , unsigned int blocksize , char const   *outpath ,
                                   int overwrite ) ;
#line 101
extern int rdd_new_stats_blockfilter(RDD_FILTER **f , unsigned int blocksize , char const   *outpath ,
                                     int overwrite ) ;
#line 104
int rdd_new_adler32_blockfilter(RDD_FILTER **f , unsigned int blocksize , char const   *outpath ,
                                int overwrite ) ;
#line 107
int rdd_new_crc32_blockfilter(RDD_FILTER **f , unsigned int blocksize , char const   *outpath ,
                              int overwrite ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filterset.h"
extern int rdd_fset_init(RDD_FILTERSET *fset ) ;
#line 91
extern int rdd_fset_add(RDD_FILTERSET *fset , char const   *name , RDD_FILTER *f ) ;
#line 101
extern int rdd_fset_get(RDD_FILTERSET *fset , char const   *name , RDD_FILTER **f ) ;
#line 158
extern int rdd_fset_clear(RDD_FILTERSET *fset ) ;
#line 140 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/copier.h"
extern int rdd_new_simple_copier(RDD_COPIER **c , RDD_SIMPLE_PARAMS *params ) ;
#line 164
extern int rdd_new_robust_copier(RDD_COPIER **c , rdd_count_t offset , rdd_count_t count ,
                                 RDD_ROBUST_PARAMS *params ) ;
#line 152 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/msgprinter.h"
extern int rdd_mp_open_stdio_printer(RDD_MSGPRINTER **printer , FILE *stream ) ;
#line 158
extern int rdd_mp_open_log_printer(RDD_MSGPRINTER **printer , RDD_MSGPRINTER *next ) ;
#line 163
int rdd_mp_open_file_printer(RDD_MSGPRINTER **printer , char const   *path ) ;
#line 184
extern void rdd_mp_vmessage(RDD_MSGPRINTER *printer , rdd_message_t type , char const   *fmt ,
                            va_list ap ) ;
#line 207
extern void rdd_mp_vrddmsg(RDD_MSGPRINTER *printer , rdd_message_t type , int rdd_errno ,
                           char const   *fmt , va_list ap ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/netio.h"
extern int rdd_init_server(RDD_MSGPRINTER *printer , unsigned int port , int *server_sock ) ;
#line 45
extern int rdd_await_connection(RDD_MSGPRINTER *printer , int server_sock , int *client_sock ) ;
#line 48
extern int rdd_recv_info(RDD_READER *reader , char **filename , rdd_count_t *file_size ,
                         rdd_count_t *block_size , rdd_count_t *split_size , unsigned int *flags ) ;
#line 52
extern int rdd_send_info(RDD_WRITER *writer , char *file_name , rdd_count_t file_size ,
                         rdd_count_t block_size , rdd_count_t split_size , unsigned int flags ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/progress.h"
extern int rdd_progress_init(RDD_PROGRESS *p , rdd_count_t size , unsigned int secs ) ;
#line 72
extern int rdd_progress_update(RDD_PROGRESS *p , rdd_count_t pos ) ;
#line 91
extern int rdd_progress_poll(RDD_PROGRESS *p , RDD_PROGRESS_INFO *info ) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static rdd_copy_opts opts  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static char *usage_message___0  =    (char *)"\n\trdd-copy [local options] infile [outfile]\n\trdd-copy -C [client options] <local file> <remote file>\n\trdd-copy -S [server options]\n";
#line 156 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static RDD_OPTION opttab___0[32]  = 
#line 156
  {      {(char *)"-?", (char *)"--help", (char *)0, 7U, (char *)"Print this message",
      0U, (char *)0}, 
        {(char *)"-C", (char *)"--client", (char *)0, 0U, (char *)"Run rdd as a network client",
      0U, (char *)0}, 
        {(char *)"-F", (char *)"--fault-simulation", (char *)"<file>", 3U, (char *)"simulate read errors specified in <file>",
      0U, (char *)0}, 
        {(char *)"-M", (char *)"--max-read-err", (char *)"<count>", 3U, (char *)"Give up after <count> read errors",
      0U, (char *)0}, 
        {(char *)"-P", (char *)"--progress", (char *)"<sec>", 7U, (char *)"Report progress every <sec> seconds",
      0U, (char *)0}, 
        {(char *)"-S", (char *)"--server", (char *)0, 0U, (char *)"Run rdd as a network server",
      0U, (char *)0}, 
        {(char *)"-V", (char *)"--version", (char *)0, 7U, (char *)"Report version number and exit",
      0U, (char *)0}, 
        {(char *)"-b", (char *)"--block-size", (char *)"<count>[kKmMgG]", 3U, (char *)"Read blocks of <count> [KMG]byte at a time",
      0U, (char *)0}, 
        {(char *)"-c", (char *)"--count", (char *)"<count>[kKmMgG]", 7U, (char *)"Read at most <count> [KMG]bytes",
      0U, (char *)0}, 
        {(char *)"-f", (char *)"--force", (char *)0, 5U, (char *)"Ruthlessly overwrite existing files",
      0U, (char *)0}, 
        {(char *)"-i", (char *)"--inetd", (char *)0, 4U, (char *)"rdd is started by (x)inetd",
      0U, (char *)0}, 
        {(char *)"-l", (char *)"--log-file", (char *)"<file>", 7U, (char *)"Log messages in <file>",
      0U, (char *)0}, 
        {(char *)"-m", (char *)"--min-block-size", (char *)"<count>[kKmMgK]", 3U, (char *)"Minimum read-block size is <count> [KMG]byte",
      0U, (char *)0}, 
        {(char *)"-n", (char *)"--nretry", (char *)"<count>", 3U, (char *)"Retry failed reads <count> times",
      0U, (char *)0}, 
        {(char *)"-o", (char *)"--offset", (char *)"<count>[kKmMgG]", 7U, (char *)"Skip <count> [KMG] input bytes",
      0U, (char *)0}, 
        {(char *)"-p", (char *)"--port", (char *)"<portnum>", 6U, (char *)"Set server port to <port>",
      0U, (char *)0}, 
        {(char *)"-q", (char *)"--quiet", (char *)0, 7U, (char *)"Do not ask questions",
      0U, (char *)0}, 
        {(char *)"-r", (char *)"--raw", (char *)0, 3U, (char *)"Read from a raw device (/dev/raw/raw[0-9])",
      0U, (char *)0}, 
        {(char *)"-s", (char *)"--split", (char *)"<count>[kKmMgG]", 3U, (char *)"Split output, all files < <count> [KMG]bytes",
      0U, (char *)0}, 
        {(char *)"-v", (char *)"--verbose", (char *)0, 7U, (char *)"Be verbose", 0U,
      (char *)0}, 
        {(char *)"-z", (char *)"--compress", (char *)0, 2U, (char *)"Compress data sent across the network",
      0U, (char *)0}, 
        {(char *)"-H", (char *)"--histogram", (char *)"<file>", 7U, (char *)"Store histogram-derived stats in <file>",
      0U, (char *)0}, 
        {(char *)"-h", (char *)"--histogram-block-size", (char *)"<size>", 7U, (char *)"Histogramming block size",
      0U, (char *)0}, 
        {(char *)"--checksum", (char *)"--adler32", (char *)"<file>", 7U, (char *)"Compute and store Adler32 checksums in <file>",
      0U, (char *)0}, 
        {(char *)"--checksum-block-size", (char *)"--adler32-block-size", (char *)"<size>",
      7U, (char *)"Adler32 uses <size>-byte blocks", 0U, (char *)0}, 
        {(char *)"--crc32", (char *)"--crc32", (char *)"<file>", 7U, (char *)"Compute and store CRC32 checksums in <file>",
      0U, (char *)0}, 
        {(char *)"--crc32-block-size", (char *)"--crc32-block-size", (char *)"<size>",
      7U, (char *)"CRC32 uses <size>-byte blocks", 0U, (char *)0}, 
        {(char *)"--md5", (char *)"--md5", (char *)0, 7U, (char *)"Compute and print MD5 hash",
      0U, (char *)0}, 
        {(char *)"--sha", (char *)"--sha1", (char *)0, 7U, (char *)"Compute and print SHA1 hash",
      0U, (char *)0}, 
        {(char *)"--block-md5-size", (char *)"--block-md5-size", (char *)"<size>", 7U,
      (char *)"block-wise MD5 block size", 0U, (char *)0}, 
        {(char *)"--block-md5", (char *)"--block-md5", (char *)"<file>", 7U, (char *)"Store block-wise MD5 hash values in <file>",
      0U, (char *)0}, 
        {(char *)0, (char *)0, (char *)0, 0U, (char *)0, 0U, (char *)0}};
#line 222 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static RDD_MSGPRINTER *the_printer  ;
#line 224 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void fatal_rdd_error(int rdd_errno , char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 229
  __builtin_va_start(ap, fmt);
#line 230
  rdd_mp_vrddmsg(the_printer, (rdd_message_t )2, rdd_errno, (char const   *)fmt, ap);
#line 231
  __builtin_va_end(ap);
#line 232
  exit(1);
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void logmsg(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 240
  __builtin_va_start(ap, fmt);
#line 241
  rdd_mp_vmessage(the_printer, (rdd_message_t )1, fmt, ap);
#line 242
  __builtin_va_end(ap);
  }
#line 243
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static rdd_count_t scan_size(char *str , unsigned int flags ) 
{ 
  rdd_count_t sz ;
  int rc ;

  {
  {
#line 253
  rc = rdd_parse_bignum((char const   *)str, (rdd_num_flags_t )flags, & sz);
  }
#line 253
  if (rc != 0) {
    {
#line 254
    fatal_rdd_error(rc, (char *)"bad number %s", str);
    }
  }
#line 256
  return (sz);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static unsigned int scan_uint(char *str ) 
{ 
  unsigned int n ;
  int rc ;

  {
  {
#line 265
  rc = rdd_parse_uint((char const   *)str, & n);
  }
#line 265
  if (rc != 0) {
    {
#line 266
    fatal_rdd_error(rc, (char *)"%s", str);
    }
  }
#line 268
  return (n);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static unsigned int scan_tcp_port(char *str ) 
{ 
  unsigned int port ;
  int rc ;

  {
  {
#line 277
  rc = rdd_parse_tcp_port((char const   *)str, & port);
  }
#line 277
  if (rc != 0) {
    {
#line 278
    fatal_rdd_error(rc, (char *)"%s", str);
    }
  }
#line 280
  return (port);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void init_options(void) 
{ 


  {
  {
#line 286
  memset((void *)(& opts), 0, sizeof(opts));
#line 288
  opts.mode = 1U;
#line 289
  opts.server_port = 4832U;
#line 290
  opts.nretry = 1U;
#line 291
  opts.max_read_err = (rdd_count_t )0;
#line 292
  opts.blocklen = (rdd_count_t )262144;
#line 293
  opts.minblocklen = (rdd_count_t )32768;
#line 294
  opts.histblocklen = (rdd_count_t )262144;
#line 295
  opts.adler32len = (rdd_count_t )32768;
#line 296
  opts.crc32len = (rdd_count_t )32768;
#line 297
  opts.blockmd5len = (rdd_count_t )4096;
  }
#line 298
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void split_host_file(char const   *host_file , char **host , char **file ) 
{ 
  char *p ;
  char const   *h ;
  char const   *f ;
  int hlen ;
  int flen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 311
  p = strchr(host_file, ':');
  }
#line 312
  if ((unsigned long )p == (unsigned long )((char *)0)) {
    {
#line 313
    h = "localhost";
#line 314
    tmp = strlen(h);
#line 314
    hlen = (int )tmp;
#line 315
    f = host_file;
#line 316
    tmp___0 = strlen(f);
#line 316
    flen = (int )tmp___0;
    }
  } else
#line 318
  if ((unsigned long )p == (unsigned long )host_file) {
    {
#line 319
    h = "localhost";
#line 320
    tmp___1 = strlen(h);
#line 320
    hlen = (int )tmp___1;
#line 321
    f = (char const   *)(p + 1);
#line 322
    tmp___2 = strlen(f);
#line 322
    flen = (int )tmp___2;
    }
  } else {
    {
#line 324
    h = host_file;
#line 325
    hlen = (int )(p - (char *)host_file);
#line 326
    f = (char const   *)(p + 1);
#line 327
    tmp___3 = strlen(f);
#line 327
    flen = (int )tmp___3;
    }
  }
#line 329
  if (flen == 0) {
    {
#line 330
    error((char *)"missing file name in target %s", host_file);
    }
  }
  {
#line 333
  tmp___4 = rdd_malloc((size_t )(hlen + 1));
#line 333
  *host = (char *)tmp___4;
#line 334
  memcpy((void */* __restrict  */)*host, (void const   */* __restrict  */)h, (size_t )hlen);
#line 335
  *(*host + hlen) = (char )'\000';
#line 337
  tmp___5 = rdd_malloc((size_t )(flen + 1));
#line 337
  *file = (char *)tmp___5;
#line 338
  memcpy((void */* __restrict  */)*file, (void const   */* __restrict  */)f, (size_t )flen);
#line 339
  *(*file + flen) = (char )'\000';
  }
#line 340
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void process_options(void) 
{ 
  char *arg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
  {
#line 347
  tmp = rdd_opt_set((char *)"help");
  }
#line 347
  if (tmp) {
    {
#line 347
    rdd_opt_usage();
    }
  }
  {
#line 349
  tmp___0 = rdd_opt_set((char *)"version");
  }
#line 349
  if (tmp___0) {
    {
#line 350
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s version %s\n",
            "rdd", "2.0.7");
#line 351
    exit(0);
    }
  }
  {
#line 354
  opts.compress = rdd_opt_set((char *)"compress");
#line 355
  opts.quiet = rdd_opt_set((char *)"quiet");
#line 356
  rdd_set_quiet(opts.quiet);
#line 361
  opts.raw = rdd_opt_set((char *)"raw");
  }
#line 363
  if (opts.raw) {
    {
#line 364
    error((char *)"rdd not configured with raw-device support");
    }
  }
  {
#line 367
  opts.inetd = rdd_opt_set((char *)"inetd");
#line 368
  opts.verbose = rdd_opt_set((char *)"verbose");
#line 370
  opts.raw = rdd_opt_set((char *)"raw");
  }
#line 371
  if (opts.raw) {
#line 371
    if (opts.mode == 4U) {
      {
#line 372
      error((char *)"raw-device input cannot be used in server mode");
      }
    }
  }
  {
#line 375
  opts.md5 = rdd_opt_set((char *)"md5");
#line 376
  opts.sha1 = rdd_opt_set((char *)"sha1");
#line 378
  opts.force_overwrite = rdd_opt_set((char *)"force");
#line 380
  tmp___1 = rdd_opt_set_arg((char *)"fault-simulation", & arg);
  }
#line 380
  if (tmp___1) {
#line 381
    opts.simfile = arg;
  }
  {
#line 383
  tmp___2 = rdd_opt_set_arg((char *)"log-file", & arg);
  }
#line 383
  if (tmp___2) {
#line 384
    opts.logfile = arg;
  }
  {
#line 386
  tmp___3 = rdd_opt_set_arg((char *)"adler32", & arg);
  }
#line 386
  if (tmp___3) {
#line 387
    opts.adler32file = arg;
  }
  {
#line 389
  tmp___4 = rdd_opt_set_arg((char *)"adler32-block-size", & arg);
  }
#line 389
  if (tmp___4) {
    {
#line 390
    opts.adler32len = scan_size(arg, 1U);
    }
#line 391
    if ((unsigned long )opts.adler32file == (unsigned long )((char *)0)) {
      {
#line 392
      error((char *)"missing Adler-32 output file name (use --adler32)");
      }
    }
  }
  {
#line 396
  tmp___5 = rdd_opt_set_arg((char *)"crc32", & arg);
  }
#line 396
  if (tmp___5) {
#line 397
    opts.crc32file = arg;
  }
  {
#line 399
  tmp___6 = rdd_opt_set_arg((char *)"crc32-block-size", & arg);
  }
#line 399
  if (tmp___6) {
    {
#line 400
    opts.crc32len = scan_size(arg, 1U);
    }
#line 401
    if ((unsigned long )opts.crc32file == (unsigned long )((char *)0)) {
      {
#line 402
      error((char *)"missing CRC-32 output file name (use --crc32)");
      }
    }
  }
  {
#line 406
  tmp___7 = rdd_opt_set_arg((char *)"histogram", & arg);
  }
#line 406
  if (tmp___7) {
#line 407
    opts.histfile = arg;
  }
  {
#line 409
  tmp___8 = rdd_opt_set_arg((char *)"histogram-block-size", & arg);
  }
#line 409
  if (tmp___8) {
    {
#line 410
    opts.histblocklen = scan_size(arg, 1U);
    }
#line 411
    if ((unsigned long )opts.histfile == (unsigned long )((char *)0)) {
      {
#line 412
      error((char *)"missing histogram output file name (use --histogram)");
      }
    }
  }
  {
#line 416
  tmp___9 = rdd_opt_set_arg((char *)"block-md5", & arg);
  }
#line 416
  if (tmp___9) {
#line 417
    opts.blockmd5file = arg;
  }
  {
#line 419
  tmp___10 = rdd_opt_set_arg((char *)"block-md5-size", & arg);
  }
#line 419
  if (tmp___10) {
    {
#line 420
    opts.blockmd5len = scan_size(arg, 1U);
    }
#line 421
    if ((unsigned long )opts.blockmd5file == (unsigned long )((char *)0)) {
      {
#line 422
      error((char *)"missing block-MD5 output file name (use --block-md5)");
      }
    }
  }
  {
#line 426
  tmp___12 = rdd_opt_set_arg((char *)"progress", & arg);
  }
#line 426
  if (tmp___12) {
    {
#line 427
    tmp___11 = scan_uint(arg);
#line 427
    opts.progresslen = (rdd_count_t )tmp___11;
    }
  }
  {
#line 429
  tmp___13 = rdd_opt_set_arg((char *)"nretry", & arg);
  }
#line 429
  if (tmp___13) {
    {
#line 430
    opts.nretry = scan_uint(arg);
    }
  }
  {
#line 432
  tmp___14 = rdd_opt_set_arg((char *)"block-size", & arg);
  }
#line 432
  if (tmp___14) {
    {
#line 433
    opts.blocklen = scan_size(arg, 1U);
    }
  }
  {
#line 435
  tmp___15 = rdd_opt_set_arg((char *)"min-block-size", & arg);
  }
#line 435
  if (tmp___15) {
    {
#line 436
    opts.minblocklen = scan_size(arg, 1U);
    }
  }
  {
#line 438
  tmp___16 = rdd_opt_set_arg((char *)"offset", & arg);
  }
#line 438
  if (tmp___16) {
    {
#line 439
    opts.offset = scan_size(arg, 0U);
    }
  }
  {
#line 441
  tmp___17 = rdd_opt_set_arg((char *)"count", & arg);
  }
#line 441
  if (tmp___17) {
    {
#line 442
    opts.count = scan_size(arg, 1U);
    }
  }
  {
#line 444
  tmp___19 = rdd_opt_set_arg((char *)"max-read-err", & arg);
  }
#line 444
  if (tmp___19) {
    {
#line 445
    tmp___18 = scan_uint(arg);
#line 445
    opts.max_read_err = (rdd_count_t )tmp___18;
    }
  }
  {
#line 447
  tmp___20 = rdd_opt_set_arg((char *)"split", & arg);
  }
#line 447
  if (tmp___20) {
    {
#line 448
    opts.splitlen = scan_size(arg, 0U);
    }
  }
  {
#line 450
  tmp___21 = rdd_opt_set_arg((char *)"port", & arg);
  }
#line 450
  if (tmp___21) {
    {
#line 451
    opts.server_port = scan_tcp_port(arg);
    }
  }
#line 453
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void command_line(int argc , char **argv ) 
{ 
  RDD_OPTION *od ;
  unsigned int i ;
  char *opt ;
  char *arg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 466
  i = 1U;
#line 467
  opts.mode = 1U;
#line 468
  if (argc > 1) {
    {
#line 469
    tmp___1 = strcmp((char const   *)*(argv + i), "-C");
    }
#line 469
    if (tmp___1 == 0) {
#line 470
      opts.mode = 2U;
#line 471
      i ++;
    } else {
      {
#line 469
      tmp___2 = strcmp((char const   *)*(argv + i), "--client");
      }
#line 469
      if (tmp___2 == 0) {
#line 470
        opts.mode = 2U;
#line 471
        i ++;
      } else {
        {
#line 472
        tmp = strcmp((char const   *)*(argv + i), "-S");
        }
#line 472
        if (tmp == 0) {
#line 473
          opts.mode = 4U;
#line 474
          i ++;
        } else {
          {
#line 472
          tmp___0 = strcmp((char const   *)*(argv + i), "--server");
          }
#line 472
          if (tmp___0 == 0) {
#line 473
            opts.mode = 4U;
#line 474
            i ++;
          }
        }
      }
    }
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (i < (unsigned int )argc)) {
#line 480
      goto while_break;
    }
    {
#line 481
    od = rdd_get_opt_with_arg(argv, argc, & i, & opt, & arg);
    }
#line 481
    if ((unsigned long )od == (unsigned long )((RDD_OPTION *)0)) {
#line 482
      goto while_break;
    }
#line 487
    if (! ((od->valid_modes & opts.mode) != 0U)) {
#line 488
      if (opts.mode == 1U) {
#line 488
        tmp___5 = "local";
      } else {
#line 488
        if (opts.mode == 2U) {
#line 488
          tmp___4 = "client";
        } else {
#line 488
          if (opts.mode == 4U) {
#line 488
            tmp___3 = "server";
          } else {
#line 488
            tmp___3 = "unknown";
          }
#line 488
          tmp___4 = tmp___3;
        }
#line 488
        tmp___5 = tmp___4;
      }
      {
#line 488
      error((char *)"option %s not valid in %s mode", opt, tmp___5);
      }
    }
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 495
  process_options();
  }
  {
#line 500
  if (opts.mode == 1U) {
#line 500
    goto case_1;
  }
#line 510
  if (opts.mode == 2U) {
#line 510
    goto case_2;
  }
#line 520
  if (opts.mode == 4U) {
#line 520
    goto case_4;
  }
#line 499
  goto switch_break;
  case_1: /* CIL Label */ 
#line 501
  if ((unsigned int )argc - i == 1U) {
#line 502
    tmp___6 = i;
#line 502
    i ++;
#line 502
    opts.infile = *(argv + tmp___6);
  } else
#line 503
  if ((unsigned int )argc - i == 2U) {
#line 504
    tmp___7 = i;
#line 504
    i ++;
#line 504
    opts.infile = *(argv + tmp___7);
#line 505
    tmp___8 = i;
#line 505
    i ++;
#line 505
    opts.outpath = *(argv + tmp___8);
  } else {
    {
#line 507
    rdd_opt_usage();
    }
  }
#line 509
  goto switch_break;
  case_2: /* CIL Label */ 
#line 511
  if ((unsigned int )argc - i == 2U) {
    {
#line 512
    tmp___9 = i;
#line 512
    i ++;
#line 512
    opts.infile = *(argv + tmp___9);
#line 513
    tmp___10 = i;
#line 513
    i ++;
#line 513
    split_host_file((char const   *)*(argv + tmp___10), & opts.server_host, & opts.outpath);
    }
  } else {
    {
#line 517
    rdd_opt_usage();
    }
  }
#line 519
  goto switch_break;
  case_4: /* CIL Label */ 
#line 521
  if ((unsigned int )argc - i != 0U) {
    {
#line 522
    rdd_opt_usage();
    }
  }
#line 524
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 530
  tmp___11 = rdd_opt_set((char *)"block-size");
  }
#line 530
  if (tmp___11) {
    {
#line 530
    tmp___12 = rdd_opt_set((char *)"min-block-size");
    }
#line 530
    if (! tmp___12) {
#line 530
      if (opts.blocklen < opts.minblocklen) {
#line 533
        opts.minblocklen = opts.blocklen;
      }
    }
  }
#line 539
  if (opts.blocklen >= 2147483647UL) {
    {
#line 540
    error((char *)"block size (%llu) too large (larger than INT_MAX)", opts.blocklen);
    }
  }
#line 543
  if (opts.minblocklen > opts.blocklen) {
    {
#line 544
    error((char *)"minimum block length (%llu) cannot exceed block length (%llu)",
          opts.minblocklen, opts.blocklen);
    }
  }
#line 548
  if (opts.splitlen > 0UL) {
#line 548
    if (opts.splitlen < opts.blocklen) {
      {
#line 549
      error((char *)"split size (%llu) must be larger than or equal to block size (%llu)",
            opts.splitlen, opts.blocklen);
      }
    }
  }
#line 553
  if (opts.splitlen > 0UL) {
#line 553
    if ((unsigned long )opts.outpath == (unsigned long )((char *)0)) {
      {
#line 554
      error((char *)"--split requires an output file name");
      }
    }
  }
#line 556
  return;
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static RDD_READER *open_disk_input(rdd_count_t *inputlen ) 
{ 
  RDD_READER *reader ;
  int rc ;

  {
  {
#line 561
  reader = (RDD_READER *)0;
#line 564
  rc = rdd_open_file_reader(& reader, (char const   *)opts.infile, opts.raw);
  }
#line 565
  if (rc != 0) {
    {
#line 566
    fatal_rdd_error(rc, (char *)"cannot open %s", opts.infile);
    }
  }
  {
#line 568
  rc = rdd_reader_seek(reader, (rdd_count_t )0);
  }
#line 568
  if (rc != 0) {
    {
#line 569
    fatal_rdd_error(rc, (char *)"cannot seek on %s", opts.infile);
    }
  }
#line 572
  if (opts.raw) {
    {
#line 573
    rc = rdd_open_aligned_reader(& reader, reader, 512U);
    }
#line 574
    if (rc != 0) {
      {
#line 575
      fatal_rdd_error(rc, (char *)"cannot open %s for aligned access", opts.infile);
      }
    }
  }
  {
#line 580
  *inputlen = (rdd_count_t )(~ 0ULL);
#line 581
  rc = rdd_device_size((char const   *)opts.infile, inputlen);
  }
#line 581
  if (rc != 0) {
    {
#line 582
    fatal_rdd_error(rc, (char *)"%s: cannot determine device size", opts.infile);
    }
  }
#line 585
  if ((unsigned long )opts.simfile != (unsigned long )((char *)0)) {
    {
#line 586
    rc = rdd_open_faulty_reader(& reader, reader, opts.simfile);
    }
#line 587
    if (rc != 0) {
      {
#line 588
      fatal_rdd_error(rc, (char *)"cannot initialize fault simulator");
      }
    }
  }
#line 592
  return (reader);
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static RDD_READER *open_net_input(rdd_count_t *inputlen ) 
{ 
  RDD_READER *reader ;
  int server_sock ;
  unsigned int flags ;
  int fd ;
  int rc ;
  char *tmp ;

  {
#line 598
  reader = (RDD_READER *)0;
#line 599
  server_sock = -1;
#line 601
  fd = -1;
#line 604
  *inputlen = (rdd_count_t )(~ 0ULL);
#line 607
  if (opts.inetd) {
#line 609
    fd = 0;
  } else {
    {
#line 611
    rc = rdd_init_server(the_printer, opts.server_port, & server_sock);
    }
#line 613
    if (rc != 0) {
      {
#line 614
      fatal_rdd_error(rc, (char *)"cannot start rdd-copy server");
      }
    }
    {
#line 617
    rc = rdd_await_connection(the_printer, server_sock, & fd);
    }
#line 618
    if (rc != 0) {
      {
#line 619
      fatal_rdd_error(rc, (char *)"no connection");
      }
    }
  }
  {
#line 623
  rc = rdd_open_fd_reader(& reader, fd);
  }
#line 624
  if (rc != 0) {
    {
#line 625
    fatal_rdd_error(rc, (char *)"cannot open reader on server socket");
    }
  }
  {
#line 628
  rc = rdd_recv_info(reader, & opts.outpath, inputlen, & opts.blocklen, & opts.splitlen,
                     & flags);
  }
#line 630
  if (rc != 0) {
    {
#line 631
    fatal_rdd_error(rc, (char *)"bad client request");
    }
  }
#line 634
  if (opts.verbose) {
    {
#line 635
    logmsg("Received rdd request:");
#line 636
    logmsg("\tfile name:   %s", opts.outpath);
#line 637
    tmp = rdd_strsize(*inputlen);
#line 637
    logmsg("\tfile size:   %s", tmp);
#line 638
    logmsg("\tblock size:  %llu", opts.blocklen);
#line 639
    logmsg("\tsplit size:  %llu", opts.splitlen);
    }
  }
#line 647
  if ((flags & 1U) != 0U) {
    {
#line 648
    rc = rdd_open_zlib_reader(& reader, reader);
    }
#line 648
    if (rc != 0) {
      {
#line 649
      fatal_rdd_error(rc, (char *)"cannot open zlib reader");
      }
    }
  }
#line 653
  return (reader);
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static RDD_READER *open_input(rdd_count_t *inputlen ) 
{ 
  RDD_READER *tmp ;
  RDD_READER *tmp___0 ;

  {
#line 661
  if (opts.mode == 4U) {
    {
#line 662
    tmp = open_net_input(inputlen);
    }
#line 662
    return (tmp);
  } else {
    {
#line 664
    tmp___0 = open_disk_input(inputlen);
    }
#line 664
    return (tmp___0);
  }
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static RDD_WRITER *open_disk_output(rdd_count_t outputsize ) 
{ 
  RDD_WRITER *writer ;
  rdd_write_mode_t wrmode ;
  int rc ;
  int tmp ;

  {
#line 671
  writer = (RDD_WRITER *)0;
#line 675
  if ((unsigned long )opts.outpath == (unsigned long )((char *)0)) {
#line 675
    return ((RDD_WRITER *)0);
  }
#line 677
  if (opts.force_overwrite) {
#line 677
    wrmode = (rdd_write_mode_t )2;
  } else {
#line 677
    wrmode = (rdd_write_mode_t )0;
  }
  {
#line 679
  tmp = strcmp((char const   *)opts.outpath, "-");
  }
#line 679
  if (tmp == 0) {
#line 680
    if (opts.splitlen > 0UL) {
      {
#line 681
      error((char *)"cannot split standard output stream");
      }
    }
    {
#line 683
    rc = rdd_open_fd_writer(& writer, 1);
    }
#line 684
    if (rc != 0) {
      {
#line 685
      fatal_rdd_error(rc, (char *)"cannot write to standard output?");
      }
    }
  } else
#line 687
  if (opts.splitlen > 0UL) {
    {
#line 688
    rc = rdd_open_part_writer(& writer, (char const   *)opts.outpath, outputsize,
                              opts.splitlen, wrmode);
    }
#line 690
    if (rc != 0) {
      {
#line 691
      fatal_rdd_error(rc, (char *)"cannot open multipart output file");
      }
    }
  } else {
    {
#line 694
    rc = rdd_open_safe_writer(& writer, (char const   *)opts.outpath, wrmode);
    }
#line 695
    if (rc != 0) {
      {
#line 696
      fatal_rdd_error(rc, (char *)"cannot open output file %s", opts.outpath);
      }
    }
  }
#line 701
  return (writer);
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static RDD_WRITER *open_net_output(rdd_count_t outputsize ) 
{ 
  RDD_WRITER *writer ;
  unsigned int flags ;
  int rc ;
  char *server ;
  unsigned int port ;

  {
#line 707
  writer = (RDD_WRITER *)0;
#line 708
  flags = 0U;
#line 710
  server = opts.server_host;
#line 711
  port = opts.server_port;
#line 713
  if (! ((unsigned long )opts.outpath != (unsigned long )((char *)0))) {
    {
#line 713
    __assert_fail("opts.outpath != 0", "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c",
                  713U, "open_net_output");
    }
  }
  {
#line 715
  rc = rdd_open_tcp_writer(& writer, (char const   *)server, port);
  }
#line 716
  if (rc != 0) {
    {
#line 717
    fatal_rdd_error(rc, (char *)"cannot connect to %s:%u", server, port);
    }
  }
#line 720
  if (opts.compress) {
#line 720
    flags = 1U;
  } else {
#line 720
    flags = 0U;
  }
  {
#line 721
  rc = rdd_send_info(writer, opts.outpath, outputsize, opts.blocklen, opts.splitlen,
                     flags);
  }
#line 723
  if (rc != 0) {
    {
#line 724
    fatal_rdd_error(rc, (char *)"cannot send header to %s:%u", server, port);
    }
  }
#line 727
  if (opts.compress) {
    {
#line 730
    rc = rdd_open_zlib_writer(& writer, writer);
    }
#line 731
    if (rc != 0) {
      {
#line 732
      fatal_rdd_error(rc, (char *)"cannot compress network traffic to %s:%u", server,
                      port);
      }
    }
  }
#line 737
  return (writer);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static RDD_WRITER *open_output(rdd_count_t outputsize ) 
{ 
  RDD_WRITER *tmp ;
  RDD_WRITER *tmp___0 ;

  {
#line 746
  if (opts.mode == 2U) {
    {
#line 747
    tmp = open_net_output(outputsize);
    }
#line 747
    return (tmp);
  } else {
    {
#line 749
    tmp___0 = open_disk_output(outputsize);
    }
#line 749
    return (tmp___0);
  }
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void open_logfile(void) 
{ 
  RDD_MSGPRINTER *log_printer ;
  RDD_MSGPRINTER *bcast_printer ;
  RDD_MSGPRINTER *printers[2] ;
  unsigned int nprinter ;
  int rc ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 756
  log_printer = (RDD_MSGPRINTER *)0;
#line 757
  bcast_printer = (RDD_MSGPRINTER *)0;
#line 759
  nprinter = 0U;
#line 760
  rc = 0;
#line 766
  if ((unsigned long )the_printer != (unsigned long )((RDD_MSGPRINTER *)0)) {
#line 766
    if (opts.verbose) {
#line 767
      tmp = nprinter;
#line 767
      nprinter ++;
#line 767
      printers[tmp] = the_printer;
    } else
#line 766
    if ((unsigned long )opts.logfile == (unsigned long )((char *)0)) {
#line 767
      tmp = nprinter;
#line 767
      nprinter ++;
#line 767
      printers[tmp] = the_printer;
    }
  }
#line 773
  if ((unsigned long )opts.logfile != (unsigned long )((char *)0)) {
    {
#line 774
    rc = rdd_mp_open_file_printer(& log_printer, (char const   *)opts.logfile);
    }
#line 775
    if (rc != 0) {
      {
#line 776
      fatal_rdd_error(rc, (char *)"cannot open log file (%s)", opts.logfile);
      }
    }
    {
#line 780
    rc = rdd_mp_open_log_printer(& log_printer, log_printer);
    }
#line 781
    if (rc != 0) {
      {
#line 782
      fatal_rdd_error(rc, (char *)"cannot stack log printer");
      }
    }
#line 785
    tmp___0 = nprinter;
#line 785
    nprinter ++;
#line 785
    printers[tmp___0] = log_printer;
  }
  {
#line 790
  rc = rdd_mp_open_bcast_printer(& bcast_printer, nprinter, printers);
  }
#line 791
  if (rc != 0) {
    {
#line 792
    fatal_rdd_error(rc, (char *)"cannot open bcast printer");
    }
  }
#line 794
  the_printer = bcast_printer;
#line 795
  return;
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void close_printer(void) 
{ 
  int rc ;

  {
#line 802
  if ((unsigned long )the_printer == (unsigned long )((RDD_MSGPRINTER *)0)) {
#line 802
    return;
  }
  {
#line 804
  rc = rdd_mp_close(the_printer, 3U);
  }
#line 805
  if (rc != 0) {
    {
#line 808
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot close message printer\n");
#line 809
    exit(1);
    }
  }
#line 812
  the_printer = (RDD_MSGPRINTER *)0;
#line 813
  return;
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void log_header(char **argv , int argc ) 
{ 
  char cmdline[1024] ;
  char *p ;
  int i ;
  char *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 825
  logmsg("");
#line 826
  tmp = rdd_ctime();
#line 826
  logmsg("%s", tmp);
#line 827
  logmsg("%s version %s", "rdd", "2.0.7");
#line 828
  logmsg("Copyright (c) 2002 Nederlands Forensisch Instituut");
#line 836
  tmp___0 = zlibVersion();
#line 836
  logmsg("zlib version %s", tmp___0);
#line 837
  logmsg("Copyright (c) 1995-2002 Jean-loup Gailly and Mark Adler");
#line 843
  logmsg("NOT using openssl");
#line 846
  p = cmdline;
#line 847
  snprintf((char */* __restrict  */)p, sizeof(cmdline), (char const   */* __restrict  */)"%s",
           *(argv + 0));
#line 848
  cmdline[sizeof(cmdline) - 1UL] = (char )'\000';
#line 849
  tmp___1 = strlen((char const   *)*(argv + 0));
#line 849
  p += tmp___1;
#line 850
  i = 1;
  }
  {
#line 850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 850
    if (! (i < argc)) {
#line 850
      goto while_break;
    }
    {
#line 851
    snprintf((char */* __restrict  */)p, sizeof(cmdline) - (unsigned long )(p - cmdline),
             (char const   */* __restrict  */)" %s", *(argv + i));
#line 852
    cmdline[sizeof(cmdline) - 1UL] = (char )'\000';
#line 853
    tmp___2 = strlen((char const   *)*(argv + i));
#line 853
    p += 1UL + tmp___2;
#line 850
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 855
  logmsg("%s", cmdline);
  }
#line 856
  return;
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void log_params(rdd_copy_opts *opts___0 ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;

  {
  {
#line 861
  logmsg("========== Parameter settings ==========");
  }
#line 862
  if (opts___0->mode == 1U) {
#line 862
    tmp___0 = "local";
  } else {
#line 862
    if (opts___0->mode == 2U) {
#line 862
      tmp = "client";
    } else {
#line 862
      tmp = "server";
    }
#line 862
    tmp___0 = tmp;
  }
  {
#line 862
  logmsg("mode: %s", tmp___0);
  }
#line 866
  if (opts___0->verbose) {
#line 866
    tmp___1 = "yes";
  } else {
#line 866
    tmp___1 = "no";
  }
  {
#line 866
  logmsg("verbose: %s", tmp___1);
  }
#line 867
  if (opts___0->quiet) {
#line 867
    tmp___2 = "yes";
  } else {
#line 867
    tmp___2 = "no";
  }
  {
#line 867
  logmsg("quiet: %s", tmp___2);
  }
#line 868
  if ((unsigned long )opts___0->server_host == (unsigned long )((char *)0)) {
#line 868
    tmp___3 = "<none>";
  } else {
#line 868
    tmp___3 = (char const   *)opts___0->server_host;
  }
  {
#line 868
  logmsg("server host: %s", tmp___3);
#line 869
  logmsg("server port: %u", opts___0->server_port);
  }
#line 870
  if ((unsigned long )opts___0->infile == (unsigned long )((char *)0)) {
#line 870
    tmp___4 = "<none>";
  } else {
#line 870
    tmp___4 = (char const   *)opts___0->infile;
  }
  {
#line 870
  logmsg("input file: %s", tmp___4);
  }
#line 871
  if ((unsigned long )opts___0->logfile == (unsigned long )((char *)0)) {
#line 871
    tmp___5 = "<none>";
  } else {
#line 871
    tmp___5 = (char const   *)opts___0->logfile;
  }
  {
#line 871
  logmsg("log file: %s", tmp___5);
  }
#line 872
  if ((unsigned long )opts___0->outpath == (unsigned long )((char *)0)) {
#line 872
    tmp___6 = "<none>";
  } else {
#line 872
    tmp___6 = (char const   *)opts___0->outpath;
  }
  {
#line 872
  logmsg("output file: %s", tmp___6);
  }
#line 873
  if ((unsigned long )opts___0->crc32file == (unsigned long )((char *)0)) {
#line 873
    tmp___7 = "<none>";
  } else {
#line 873
    tmp___7 = (char const   *)opts___0->crc32file;
  }
  {
#line 873
  logmsg("CRC32 file: %s", tmp___7);
  }
#line 874
  if ((unsigned long )opts___0->adler32file == (unsigned long )((char *)0)) {
#line 874
    tmp___8 = "<none>";
  } else {
#line 874
    tmp___8 = (char const   *)opts___0->adler32file;
  }
  {
#line 874
  logmsg("Adler32 file: %s", tmp___8);
  }
#line 875
  if ((unsigned long )opts___0->histfile == (unsigned long )((char *)0)) {
#line 875
    tmp___9 = "<none>";
  } else {
#line 875
    tmp___9 = (char const   *)opts___0->histfile;
  }
  {
#line 875
  logmsg("Statistics file: %s", tmp___9);
  }
#line 876
  if ((unsigned long )opts___0->blockmd5file == (unsigned long )((char *)0)) {
#line 876
    tmp___10 = "<none>";
  } else {
#line 876
    tmp___10 = (char const   *)opts___0->blockmd5file;
  }
  {
#line 876
  logmsg("Block MD5 file: %s", tmp___10);
  }
#line 877
  if (opts___0->raw) {
#line 877
    tmp___11 = "yes";
  } else {
#line 877
    tmp___11 = "no";
  }
  {
#line 877
  logmsg("raw-device input: %s", tmp___11);
  }
#line 878
  if (opts___0->compress) {
#line 878
    tmp___12 = "yes";
  } else {
#line 878
    tmp___12 = "no";
  }
  {
#line 878
  logmsg("compress network data: %s", tmp___12);
  }
#line 879
  if (opts___0->inetd) {
#line 879
    tmp___13 = "yes";
  } else {
#line 879
    tmp___13 = "no";
  }
  {
#line 879
  logmsg("use (x)inetd: %s", tmp___13);
  }
#line 880
  if (opts___0->force_overwrite) {
#line 880
    tmp___14 = "yes";
  } else {
#line 880
    tmp___14 = "no";
  }
  {
#line 880
  logmsg("force overwrite: %s", tmp___14);
  }
#line 881
  if (opts___0->md5) {
#line 881
    tmp___15 = "yes";
  } else {
#line 881
    tmp___15 = "no";
  }
  {
#line 881
  logmsg("compute MD5: %s", tmp___15);
  }
#line 882
  if (opts___0->sha1) {
#line 882
    tmp___16 = "yes";
  } else {
#line 882
    tmp___16 = "no";
  }
  {
#line 882
  logmsg("compute SHA1: %s", tmp___16);
#line 883
  logmsg("max #retries: %u", opts___0->nretry);
#line 884
  logmsg("block size: %llu", opts___0->blocklen);
#line 885
  logmsg("minimum block size: %llu", opts___0->minblocklen);
#line 886
  logmsg("Adler32 block size: %llu", opts___0->adler32len);
#line 887
  logmsg("CRC32 block size: %llu", opts___0->crc32len);
#line 888
  logmsg("statistics block size: %llu", opts___0->histblocklen);
#line 889
  logmsg("MD5 block size: %llu", opts___0->blockmd5len);
#line 890
  logmsg("input offset: %llu", opts___0->offset);
#line 891
  logmsg("input count: %llu", opts___0->count);
#line 892
  logmsg("segment size: %llu", opts___0->splitlen);
#line 893
  logmsg("progress reporting interval: %llu", opts___0->progresslen);
#line 894
  logmsg("max #errors to tolerate: %llu", opts___0->max_read_err);
#line 895
  logmsg("========================================");
#line 896
  logmsg("");
  }
#line 897
  return;
}
}
#line 899 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void handle_read_error(rdd_count_t offset , unsigned int nbyte , void *env ) 
{ 


  {
  {
#line 902
  logmsg("read error: offset %llu bytes, count %u bytes", offset, nbyte);
  }
#line 904
  return;
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void handle_substitution(rdd_count_t offset , unsigned int nbyte , void *env ) 
{ 


  {
  {
#line 909
  logmsg("input dropped: offset %llu bytes, count %u bytes", offset, nbyte);
  }
#line 911
  return;
}
}
#line 913 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static int handle_progress(rdd_count_t pos , void *env ) 
{ 
  RDD_PROGRESS *p ;
  RDD_PROGRESS_INFO info ;
  double megabytes_per_sec ;
  double gigabytes_done ;
  double perc_done ;
  int rc ;

  {
  {
#line 916
  p = (RDD_PROGRESS *)env;
#line 926
  rc = rdd_progress_update(p, pos);
  }
#line 926
  if (rc != 0) {
    {
#line 927
    fatal_rdd_error(rc, (char *)"cannot update progress object");
    }
  }
  {
#line 930
  rc = rdd_progress_poll(p, & info);
  }
#line 931
  if (rc == 15) {
#line 932
    return (0);
  } else
#line 933
  if (rc != 0) {
    {
#line 934
    fatal_rdd_error(rc, (char *)"cannot obtain progress information");
    }
  }
#line 939
  gigabytes_done = (double )info.pos / (double )(1 << 30);
#line 940
  megabytes_per_sec = info.speed / (double )(1 << 20);
#line 942
  if (info.fraction >= 0.0) {
    {
#line 946
    perc_done = 100.0 * info.fraction;
#line 950
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%.3f GB done (%6.2f%%), average speed %.3f MB/s \n",
            gigabytes_done, perc_done, megabytes_per_sec);
    }
  } else {
    {
#line 965
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%.3f GB done, average speed %.3f MB/s\n",
            gigabytes_done, megabytes_per_sec);
    }
  }
#line 969
  return (0);
}
}
#line 972 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void add_filter(RDD_FILTERSET *fset , char const   *name , RDD_FILTER *f ) 
{ 
  int rc ;

  {
  {
#line 977
  rc = rdd_fset_add(fset, name, f);
  }
#line 977
  if (rc != 0) {
    {
#line 978
    fatal_rdd_error(rc, (char *)"cannot install %s filter", name);
    }
  }
#line 980
  return;
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void install_filters(RDD_FILTERSET *fset , RDD_WRITER *writer ) 
{ 
  RDD_FILTER *f ;
  int rc ;

  {
  {
#line 985
  f = (RDD_FILTER *)0;
#line 988
  rc = rdd_fset_init(fset);
  }
#line 988
  if (rc != 0) {
    {
#line 989
    fatal_rdd_error(rc, (char *)"cannot create filter fset");
    }
  }
#line 992
  if ((unsigned long )writer != (unsigned long )((RDD_WRITER *)0)) {
    {
#line 993
    rc = rdd_new_write_streamfilter(& f, writer);
    }
#line 994
    if (rc != 0) {
      {
#line 995
      fatal_rdd_error(rc, (char *)"cannot create write filter");
      }
    }
    {
#line 997
    add_filter(fset, "write", f);
    }
  }
#line 1000
  if (opts.md5) {
    {
#line 1001
    rc = rdd_new_md5_streamfilter(& f);
    }
#line 1002
    if (rc != 0) {
      {
#line 1003
      fatal_rdd_error(rc, (char *)"cannot create MD5 filter");
      }
    }
    {
#line 1005
    add_filter(fset, "MD5 stream", f);
    }
  }
#line 1008
  if (opts.sha1) {
    {
#line 1009
    rc = rdd_new_sha1_streamfilter(& f);
    }
#line 1010
    if (rc != 0) {
      {
#line 1011
      fatal_rdd_error(rc, (char *)"cannot create SHA-1 filter");
      }
    }
    {
#line 1013
    add_filter(fset, "SHA-1 stream", f);
    }
  }
#line 1016
  if ((unsigned long )opts.blockmd5file != (unsigned long )((char *)0)) {
    {
#line 1017
    rc = rdd_new_md5_blockfilter(& f, (unsigned int )opts.blockmd5len, (char const   *)opts.blockmd5file,
                                 opts.force_overwrite);
    }
#line 1020
    if (rc != 0) {
      {
#line 1021
      fatal_rdd_error(rc, (char *)"cannot create MD5 block filter");
      }
    }
    {
#line 1023
    add_filter(fset, "MD5 block", f);
    }
  }
#line 1026
  if ((unsigned long )opts.histfile != (unsigned long )((char *)0)) {
    {
#line 1027
    rc = rdd_new_stats_blockfilter(& f, (unsigned int )opts.histblocklen, (char const   *)opts.histfile,
                                   opts.force_overwrite);
    }
#line 1030
    if (rc != 0) {
      {
#line 1031
      fatal_rdd_error(rc, (char *)"cannot create statistics filter");
      }
    }
    {
#line 1033
    add_filter(fset, "statistical block", f);
    }
  }
#line 1036
  if ((unsigned long )opts.adler32file != (unsigned long )((char *)0)) {
    {
#line 1037
    rc = rdd_new_adler32_blockfilter(& f, (unsigned int )opts.adler32len, (char const   *)opts.adler32file,
                                     opts.force_overwrite);
    }
#line 1040
    if (rc != 0) {
      {
#line 1041
      fatal_rdd_error(rc, (char *)"cannot create Adler32 filter");
      }
    }
    {
#line 1043
    add_filter(fset, "Adler32 block", f);
    }
  }
#line 1046
  if ((unsigned long )opts.crc32file != (unsigned long )((char *)0)) {
    {
#line 1047
    rc = rdd_new_crc32_blockfilter(& f, (unsigned int )opts.crc32len, (char const   *)opts.crc32file,
                                   opts.force_overwrite);
    }
#line 1050
    if (rc != 0) {
      {
#line 1051
      fatal_rdd_error(rc, (char *)"cannot create CRC-32 filter");
      }
    }
    {
#line 1053
    add_filter(fset, "CRC-32 block", f);
    }
  }
#line 1055
  return;
}
}
#line 1057 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static RDD_COPIER *create_copier(rdd_count_t input_size , RDD_PROGRESS *progress ) 
{ 
  RDD_COPIER *copier ;
  rdd_count_t count ;
  int rc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  RDD_SIMPLE_PARAMS p ;
  RDD_ROBUST_PARAMS p___0 ;

  {
#line 1060
  copier = (RDD_COPIER *)0;
#line 1061
  count = (rdd_count_t )0;
#line 1066
  if (opts.offset > input_size) {
    {
#line 1067
    tmp = rdd_strsize(input_size);
#line 1067
    error((char *)"offset %llu larger than input file size (%s)", opts.offset, tmp);
    }
  }
#line 1073
  if (input_size == 0xffffffffffffffffUL) {
#line 1074
    count = (rdd_count_t )(~ 0ULL);
  } else {
#line 1076
    count = input_size - opts.offset;
  }
#line 1078
  if (opts.count > 0UL) {
#line 1079
    if (opts.count <= count) {
#line 1080
      count = opts.count;
    } else {
      {
#line 1082
      logmsg("User count (%llu) too large; ignored", opts.count);
      }
    }
  }
#line 1085
  if (opts.verbose) {
    {
#line 1086
    tmp___0 = rdd_strsize(input_size);
#line 1086
    logmsg("input size: %s", tmp___0);
#line 1087
    tmp___1 = rdd_strsize(count);
#line 1087
    logmsg("read size: %s", tmp___1);
    }
  }
#line 1091
  if (opts.mode == 4U) {
    {
#line 1094
    memset((void *)(& p), 0, sizeof(p));
    }
#line 1095
    if ((unsigned long )progress != (unsigned long )((RDD_PROGRESS *)0)) {
#line 1096
      p.progressfun = & handle_progress;
#line 1097
      p.progressenv = (void *)progress;
    }
    {
#line 1100
    rc = rdd_new_simple_copier(& copier, & p);
    }
#line 1101
    if (rc != 0) {
      {
#line 1102
      fatal_rdd_error(rc, (char *)"cannot create simple copier");
      }
    }
  } else {
    {
#line 1107
    memset((void *)(& p___0), 0, sizeof(p___0));
#line 1108
    p___0.minblocklen = (unsigned int )opts.minblocklen;
#line 1109
    p___0.maxblocklen = (unsigned int )opts.blocklen;
#line 1110
    p___0.nretry = opts.nretry;
#line 1111
    p___0.maxsubst = (unsigned int )opts.max_read_err;
#line 1112
    p___0.readerrfun = & handle_read_error;
#line 1113
    p___0.substfun = & handle_substitution;
    }
#line 1114
    if ((unsigned long )progress != (unsigned long )((RDD_PROGRESS *)0)) {
#line 1115
      p___0.progressfun = & handle_progress;
#line 1116
      p___0.progressenv = (void *)progress;
    }
    {
#line 1119
    rc = rdd_new_robust_copier(& copier, opts.offset, count, & p___0);
    }
#line 1121
    if (rc != 0) {
      {
#line 1122
      fatal_rdd_error(rc, (char *)"cannot create robust copier");
      }
    }
  }
#line 1126
  return (copier);
}
}
#line 1129 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
static void log_hash_result(RDD_FILTERSET *fset , char const   *hash_name , char const   *filter_name ,
                            unsigned int mdsize ) 
{ 
  unsigned char md[20] ;
  char hexdigest[41] ;
  RDD_FILTER *f ;
  int rc ;

  {
  {
#line 1135
  f = (RDD_FILTER *)0;
#line 1138
  memset((void *)(md), 0, (size_t )mdsize);
  }
#line 1140
  if ((unsigned long )mdsize > sizeof(md)) {
    {
#line 1141
    fatal_rdd_error(12, (char *)"digest size exceeds buffer size");
    }
  }
  {
#line 1144
  rc = rdd_fset_get(fset, filter_name, & f);
  }
#line 1144
  if (rc != 0) {
    {
#line 1145
    fatal_rdd_error(rc, (char *)"cannot find %s filter", filter_name);
    }
  }
  {
#line 1148
  rc = rdd_filter_get_result(f, md, mdsize);
  }
#line 1148
  if (rc != 0) {
    {
#line 1149
    fatal_rdd_error(rc, (char *)"cannot get result for %s filter", filter_name);
    }
  }
  {
#line 1153
  rc = rdd_buf2hex((unsigned char const   *)(md), mdsize, hexdigest, (unsigned int )sizeof(hexdigest));
  }
#line 1154
  if (rc != 0) {
    {
#line 1155
    fatal_rdd_error(rc, (char *)"cannot convert binary digest");
    }
  }
  {
#line 1158
  logmsg("%s: %s", hash_name, hexdigest);
  }
#line 1159
  return;
}
}
#line 1161 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rddcopy.c"
int main(int argc , char **argv ) 
{ 
  double start ;
  double end ;
  RDD_READER *reader ;
  RDD_WRITER *writer ;
  RDD_PROGRESS progress ;
  RDD_COPIER_RETURN copier_ret ;
  RDD_COPIER *copier ;
  RDD_FILTERSET filterset ;
  RDD_MSGPRINTER *printer ;
  rdd_count_t input_size ;
  int rc ;

  {
  {
#line 1171
  printer = (RDD_MSGPRINTER *)0;
#line 1175
  set_progname(*(argv + 0));
#line 1176
  rdd_cons_open();
#line 1177
  rdd_init();
#line 1181
  rc = rdd_mp_open_stdio_printer(& printer, stderr);
  }
#line 1182
  if (rc != 0) {
    {
#line 1183
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot open stderr message printer\n");
#line 1184
    exit(1);
    }
  }
  {
#line 1192
  the_printer = printer;
#line 1194
  init_options();
#line 1195
  rdd_opt_init(opttab___0, (char const   *)usage_message___0);
#line 1196
  command_line(argc, argv);
#line 1198
  open_logfile();
#line 1200
  rdd_catch_signals();
#line 1202
  log_header(argv, argc);
#line 1203
  log_params(& opts);
  }
#line 1205
  if (! opts.md5) {
#line 1205
    if (! opts.sha1) {
      {
#line 1206
      rdd_quit_if(0, (char *)"Continue without hashing (yes/no)?");
      }
    }
  }
#line 1208
  if ((unsigned long )opts.logfile == (unsigned long )((char *)0)) {
    {
#line 1209
    rdd_quit_if(0, (char *)"Continue without logging (yes/no)?");
    }
  }
  {
#line 1212
  reader = open_input(& input_size);
#line 1213
  writer = open_output((rdd_count_t )(~ 0ULL));
#line 1214
  install_filters(& filterset, writer);
  }
#line 1216
  if (opts.progresslen > 0UL) {
    {
#line 1217
    rc = rdd_progress_init(& progress, input_size, (unsigned int )opts.progresslen);
    }
#line 1218
    if (rc != 0) {
      {
#line 1219
      fatal_rdd_error(rc, (char *)"cannot initialize progress object");
      }
    }
    {
#line 1221
    copier = create_copier(input_size, & progress);
    }
  } else {
    {
#line 1223
    copier = create_copier(input_size, (RDD_PROGRESS *)0);
    }
  }
  {
#line 1226
  start = rdd_gettime();
#line 1227
  rc = rdd_copy_exec(copier, reader, & filterset, & copier_ret);
  }
#line 1228
  if (rc != 0) {
    {
#line 1229
    fatal_rdd_error(rc, (char *)"copy failed");
    }
  }
  {
#line 1231
  end = rdd_gettime();
#line 1233
  rdd_mp_message(the_printer, (rdd_message_t )1, "=== done ***");
#line 1234
  rdd_mp_message(the_printer, (rdd_message_t )1, "seconds: %.3f", end - start);
#line 1235
  rdd_mp_message(the_printer, (rdd_message_t )1, "bytes written: %llu", copier_ret.nbyte);
#line 1237
  rdd_mp_message(the_printer, (rdd_message_t )1, "bytes lost: %llu", copier_ret.nlost);
#line 1239
  rdd_mp_message(the_printer, (rdd_message_t )1, "read errors: %lu", copier_ret.nread_err);
#line 1241
  rdd_mp_message(the_printer, (rdd_message_t )1, "zero-block substitutions: %lu",
                 copier_ret.nsubst);
  }
#line 1244
  if (opts.md5) {
    {
#line 1245
    log_hash_result(& filterset, "MD5", "MD5 stream", 16U);
    }
  } else {
    {
#line 1247
    logmsg("MD5: <none>");
    }
  }
#line 1249
  if (opts.sha1) {
    {
#line 1250
    log_hash_result(& filterset, "SHA-1", "SHA-1 stream", 20U);
    }
  } else {
    {
#line 1252
    logmsg("SHA1: <none>");
    }
  }
  {
#line 1255
  rc = rdd_copy_free(copier);
  }
#line 1255
  if (rc != 0) {
    {
#line 1256
    fatal_rdd_error(rc, (char *)"cannot clean up copier");
    }
  }
  {
#line 1258
  rc = rdd_fset_clear(& filterset);
  }
#line 1258
  if (rc != 0) {
    {
#line 1259
    fatal_rdd_error(rc, (char *)"cannot clean up filters");
    }
  }
#line 1262
  if ((unsigned long )writer != (unsigned long )((RDD_WRITER *)0)) {
    {
#line 1263
    rc = rdd_writer_close(writer);
    }
#line 1263
    if (rc != 0) {
      {
#line 1264
      fatal_rdd_error(rc, (char *)"cannot clean up writer");
      }
    }
  }
  {
#line 1268
  rc = rdd_reader_close(reader, 1);
  }
#line 1268
  if (rc != 0) {
    {
#line 1269
    fatal_rdd_error(rc, (char *)"cannot clean up reader");
    }
  }
  {
#line 1272
  close_printer();
  }
#line 1274
  if (copier_ret.nread_err > 0UL) {
    {
#line 1275
    logmsg("%u read errors occurred", copier_ret.nread_err);
#line 1276
    exit(1);
    }
  }
  {
#line 1279
  logmsg("no read errors");
#line 1282
  rdd_cons_close();
  }
#line 1284
  return (0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/reader.h"
extern int rdd_new_reader(RDD_READER **r , RDD_READ_OPS *ops , unsigned int statesize ) ;
#line 153
int rdd_open_atomic_reader(RDD_READER **self , RDD_READER *p ) ;
#line 196
extern int rdd_reader_read(RDD_READER *r , unsigned char *buf , unsigned int nbyte ,
                           unsigned int *nread ) ;
#line 205
extern int rdd_reader_tell(RDD_READER *r , rdd_count_t *pos ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/atomicreader.c"
static int rdd_atomic_read(RDD_READER *self , unsigned char *buf , unsigned int nbyte ,
                           unsigned int *nread ) ;
#line 61
static int rdd_atomic_tell(RDD_READER *self , rdd_count_t *pos ) ;
#line 62
static int rdd_atomic_seek(RDD_READER *self , rdd_count_t pos ) ;
#line 63
static int rdd_atomic_close(RDD_READER *self , int recurse ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/atomicreader.c"
static RDD_READ_OPS atomic_read_ops  =    {& rdd_atomic_read, & rdd_atomic_tell, & rdd_atomic_seek, & rdd_atomic_close};
#line 72 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/atomicreader.c"
int rdd_open_atomic_reader(RDD_READER **self , RDD_READER *p ) 
{ 
  RDD_READER *r ;
  RDD_ATOMIC_READER *state ;
  int rc ;

  {
  {
#line 75
  r = (RDD_READER *)0;
#line 76
  state = (RDD_ATOMIC_READER *)0;
#line 79
  rc = rdd_new_reader(& r, & atomic_read_ops, (unsigned int )sizeof(RDD_ATOMIC_READER ));
  }
#line 80
  if (rc != 0) {
#line 81
    *self = (RDD_READER *)0;
#line 82
    return (rc);
  }
#line 84
  state = (RDD_ATOMIC_READER *)r->state;
#line 85
  state->parent = p;
#line 87
  *self = r;
#line 88
  return (0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/atomicreader.c"
static int rdd_atomic_read(RDD_READER *self , unsigned char *buf , unsigned int nbyte ,
                           unsigned int *nread ) 
{ 
  RDD_ATOMIC_READER *state ;
  rdd_count_t pos ;
  int rc1 ;
  int rc2 ;

  {
  {
#line 95
  state = (RDD_ATOMIC_READER *)self->state;
#line 102
  rc1 = rdd_reader_tell(state->parent, & pos);
  }
#line 102
  if (rc1 != 0) {
#line 103
    return (rc1);
  }
  {
#line 106
  rc2 = rdd_reader_read(state->parent, buf, nbyte, nread);
  }
#line 107
  if (rc2 == 0) {
#line 108
    return (0);
  }
  {
#line 113
  rc1 = rdd_reader_seek(state->parent, pos);
  }
#line 113
  if (rc1 != 0) {
#line 114
    return (rc1);
  }
#line 117
  return (rc2);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/atomicreader.c"
static int rdd_atomic_tell(RDD_READER *self , rdd_count_t *pos ) 
{ 
  RDD_ATOMIC_READER *state ;
  int tmp ;

  {
  {
#line 123
  state = (RDD_ATOMIC_READER *)self->state;
#line 125
  tmp = rdd_reader_tell(state->parent, pos);
  }
#line 125
  return (tmp);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/atomicreader.c"
static int rdd_atomic_seek(RDD_READER *self , rdd_count_t pos ) 
{ 
  RDD_ATOMIC_READER *state ;
  int tmp ;

  {
  {
#line 131
  state = (RDD_ATOMIC_READER *)self->state;
#line 133
  tmp = rdd_reader_seek(state->parent, pos);
  }
#line 133
  return (tmp);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/atomicreader.c"
static int rdd_atomic_close(RDD_READER *self , int recurse ) 
{ 
  RDD_ATOMIC_READER *state ;
  int tmp ;

  {
#line 139
  state = (RDD_ATOMIC_READER *)self->state;
#line 141
  if (recurse) {
    {
#line 142
    tmp = rdd_reader_close(state->parent, 1);
    }
#line 142
    return (tmp);
  } else {
#line 144
    return (0);
  }
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/reader.h"
extern int rdd_open_raw_reader(RDD_READER **r , int fd ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/filereader.c"
int rdd_open_file_reader(RDD_READER **r , char const   *path , int raw ) 
{ 
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 52
  fd = -1;
#line 54
  fd = open(path, 0);
  }
#line 54
  if (fd < 0) {
#line 55
    return (7);
  }
#line 58
  if (raw) {
    {
#line 59
    tmp = rdd_open_raw_reader(r, fd);
    }
#line 59
    return (tmp);
  } else {
    {
#line 61
    tmp___0 = rdd_open_fd_reader(r, fd);
    }
#line 61
    return (tmp___0);
  }
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdreader.c"
static int rdd_fd_read(RDD_READER *self , unsigned char *buf , unsigned int nbyte ,
                       unsigned int *nread ) ;
#line 60
static int rdd_fd_tell(RDD_READER *self , rdd_count_t *pos ) ;
#line 61
static int rdd_fd_seek(RDD_READER *self , rdd_count_t pos ) ;
#line 62
static int rdd_fd_close(RDD_READER *self , int recurse ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdreader.c"
static RDD_READ_OPS fd_read_ops  =    {& rdd_fd_read, & rdd_fd_tell, & rdd_fd_seek, & rdd_fd_close};
#line 71 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdreader.c"
int rdd_open_fd_reader(RDD_READER **self , int fd ) 
{ 
  RDD_READER *r ;
  RDD_FD_READER *state ;
  int rc ;

  {
  {
#line 74
  r = (RDD_READER *)0;
#line 75
  state = (RDD_FD_READER *)0;
#line 76
  rc = 0;
#line 78
  rc = rdd_new_reader(& r, & fd_read_ops, (unsigned int )sizeof(RDD_FD_READER ));
  }
#line 79
  if (rc != 0) {
#line 80
    return (rc);
  }
#line 83
  state = (RDD_FD_READER *)r->state;
#line 84
  state->fd = fd;
#line 86
  *self = r;
#line 87
  return (0);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdreader.c"
static int rdd_fd_read(RDD_READER *self , unsigned char *buf , unsigned int nbyte ,
                       unsigned int *nread ) 
{ 
  RDD_FD_READER *state ;
  unsigned char *next ;
  int n ;
  ssize_t tmp ;

  {
#line 94
  state = (RDD_FD_READER *)self->state;
#line 95
  next = buf;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (nbyte > 0U)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = read(state->fd, (void *)next, (size_t )nbyte);
#line 99
    n = (int )tmp;
    }
#line 100
    if (n < 0) {
#line 104
      return (11);
    } else
#line 105
    if (n == 0) {
#line 106
      goto while_break;
    }
#line 108
    nbyte -= (unsigned int )n;
#line 109
    next += n;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  *nread = (unsigned int )(next - buf);
#line 113
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdreader.c"
static int rdd_fd_tell(RDD_READER *self , rdd_count_t *pos ) 
{ 
  RDD_FD_READER *state ;
  off_t offset ;

  {
  {
#line 119
  state = (RDD_FD_READER *)self->state;
#line 122
  offset = lseek(state->fd, (off_t )0, 1);
  }
#line 122
  if (offset == -1L) {
#line 123
    return (9);
  }
#line 126
  *pos = (rdd_count_t )offset;
#line 127
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdreader.c"
static int rdd_fd_seek(RDD_READER *self , rdd_count_t pos ) 
{ 
  RDD_FD_READER *state ;
  __off_t tmp ;

  {
  {
#line 133
  state = (RDD_FD_READER *)self->state;
#line 135
  tmp = lseek(state->fd, (off_t )pos, 0);
  }
#line 135
  if (tmp == -1L) {
#line 136
    return (10);
  }
#line 138
  return (0);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fdreader.c"
static int rdd_fd_close(RDD_READER *self , int recurse ) 
{ 
  RDD_FD_READER *state ;
  int tmp ;

  {
  {
#line 144
  state = (RDD_FD_READER *)self->state;
#line 146
  tmp = close(state->fd);
  }
#line 146
  if (tmp < 0) {
#line 147
    return (5);
  }
#line 150
  return (0);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/rdd_internals.h"
void rdd_cons_printf(char *fmt  , ...) ;
#line 75
int rdd_ask(char *fmt  , ...) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
static int console_fd  =    -1;
#line 51 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
static int quiet  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
void rdd_set_quiet(int q ) 
{ 


  {
#line 56
  quiet = q;
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
static void cons_write(char *buf , unsigned int buf_size ) 
{ 
  int n ;
  ssize_t tmp ;

  {
#line 66
  if (console_fd < 0) {
#line 66
    return;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (buf_size > 0U)) {
#line 68
      goto while_break;
    }
    {
#line 69
    tmp = write(console_fd, (void const   *)buf, (size_t )buf_size);
#line 69
    n = (int )tmp;
    }
#line 69
    if (n < 0) {
      {
#line 70
      close(console_fd);
#line 71
      console_fd = -1;
#line 72
      unix_error((char *)"cannot write to tty");
      }
    }
#line 74
    buf += n;
#line 75
    buf_size -= (unsigned int )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
void rdd_cons_open(void) 
{ 


  {
  {
#line 84
  console_fd = open("/dev/tty", 2);
  }
#line 84
  if (console_fd < 0) {
    {
#line 85
    unix_error((char *)"cannot open terminal");
    }
  }
#line 88
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
void rdd_cons_close(void) 
{ 


  {
#line 94
  if (console_fd < 0) {
#line 94
    return;
  }
  {
#line 96
  close(console_fd);
#line 97
  console_fd = -1;
  }
#line 99
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
static int rdd_vask(char *fmt , va_list ap ) 
{ 
  char line[80] ;
  int answer ;
  ssize_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 108
  answer = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 112
    rdd_cons_vprintf(fmt, ap);
#line 113
    rdd_cons_printf((char *)"  ");
#line 115
    n = read(console_fd, (void *)(line), sizeof(line));
    }
#line 116
    if (n < 0L) {
      {
#line 117
      unix_error((char *)"cannot read from terminal");
      }
    } else
#line 118
    if (n == 0L) {
      {
#line 119
      error((char *)"terminal closed?");
      }
    }
#line 122
    if ((int )line[n - 1L] != 10) {
      {
#line 123
      error((char *)"line too long");
      }
    }
    {
#line 125
    line[n - 1L] = (char )'\000';
#line 127
    tmp = strcmp((char const   *)(line), "yes");
    }
#line 127
    if (tmp == 0) {
#line 128
      answer = 1;
#line 129
      goto while_break;
    } else {
      {
#line 127
      tmp___0 = strcmp((char const   *)(line), "YES");
      }
#line 127
      if (tmp___0 == 0) {
#line 128
        answer = 1;
#line 129
        goto while_break;
      }
    }
    {
#line 131
    tmp___1 = strcmp((char const   *)(line), "no");
    }
#line 131
    if (tmp___1 == 0) {
#line 132
      answer = 0;
#line 133
      goto while_break;
    } else {
      {
#line 131
      tmp___2 = strcmp((char const   *)(line), "NO");
      }
#line 131
      if (tmp___2 == 0) {
#line 132
        answer = 0;
#line 133
        goto while_break;
      }
    }
    {
#line 135
    rdd_cons_printf((char *)"Please answer yes or no.\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return (answer);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
int rdd_ask(char *fmt  , ...) 
{ 
  va_list ap ;
  int rc ;

  {
  {
#line 147
  __builtin_va_start(ap, fmt);
#line 148
  rc = rdd_vask(fmt, ap);
#line 149
  __builtin_va_end(ap);
  }
#line 150
  return (rc);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
void rdd_quit_if(int quit_answer , char *fmt  , ...) 
{ 
  va_list ap ;
  int tmp ;

  {
  {
#line 158
  __builtin_va_start(ap, fmt);
  }
#line 159
  if (! quiet) {
    {
#line 159
    tmp = rdd_vask(fmt, ap);
    }
#line 159
    if (tmp == quit_answer) {
      {
#line 160
      exit(1);
      }
    }
  }
  {
#line 162
  __builtin_va_end(ap);
  }
#line 163
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
void rdd_cons_vprintf(char *fmt , va_list ap ) 
{ 
  char promptbuf[257] ;
  size_t tmp ;

  {
#line 174
  if (console_fd < 0) {
#line 175
    return;
  }
  {
#line 178
  vsnprintf((char */* __restrict  */)(promptbuf), (size_t )256, (char const   */* __restrict  */)fmt,
            ap);
#line 179
  promptbuf[256] = (char )'\000';
#line 180
  tmp = strlen((char const   *)(promptbuf));
#line 180
  cons_write(promptbuf, (unsigned int )tmp);
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/console.c"
void rdd_cons_printf(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 190
  __builtin_va_start(ap, fmt);
#line 191
  rdd_cons_vprintf(fmt, ap);
#line 192
  __builtin_va_end(ap);
  }
#line 194
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fileprinter.c"
static void file_print(RDD_MSGPRINTER *printer , rdd_message_t type , int errcode ,
                       char const   *msg ) ;
#line 51
static int file_close(RDD_MSGPRINTER *printer , unsigned int flags ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fileprinter.c"
static RDD_MSGPRINTER_OPS file_ops  =    {& file_print, & file_close};
#line 58 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fileprinter.c"
int rdd_mp_open_file_printer(RDD_MSGPRINTER **printer , char const   *path ) 
{ 
  RDD_FILE_MSGPRINTER *file ;
  RDD_MSGPRINTER *p ;
  char *path_copy ;
  int rc ;
  FILE *fp ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 61
  file = (RDD_FILE_MSGPRINTER *)0;
#line 62
  p = (RDD_MSGPRINTER *)0;
#line 63
  path_copy = (char *)0;
#line 64
  rc = 0;
#line 65
  fp = (FILE *)((void *)0);
#line 67
  rc = rdd_mp_open_printer(& p, & file_ops, (unsigned int )sizeof(RDD_FILE_MSGPRINTER ));
  }
#line 68
  if (rc != 0) {
#line 69
    goto error;
  }
  {
#line 72
  tmp = strlen(path);
#line 72
  tmp___0 = malloc(tmp + 1UL);
#line 72
  path_copy = (char *)tmp___0;
  }
#line 72
  if ((unsigned long )path_copy == (unsigned long )((char *)0)) {
#line 73
    rc = 1;
#line 74
    goto error;
  }
  {
#line 76
  strcpy((char */* __restrict  */)path_copy, (char const   */* __restrict  */)path);
#line 78
  file = (RDD_FILE_MSGPRINTER *)p->state;
#line 80
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"rb");
  }
#line 80
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 81
    rc = 6;
#line 82
    goto error;
  }
  {
#line 84
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"w");
  }
#line 84
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 85
    rc = 7;
#line 86
    goto error;
  }
#line 89
  file->stream = fp;
#line 90
  file->path = path_copy;
#line 92
  *printer = p;
#line 93
  return (0);
  error: 
#line 96
  *printer = (RDD_MSGPRINTER *)0;
#line 97
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 97
    fclose(fp);
    }
  }
#line 98
  if ((unsigned long )path_copy != (unsigned long )((char *)0)) {
    {
#line 98
    free((void *)path_copy);
    }
  }
#line 99
  if ((unsigned long )file != (unsigned long )((RDD_FILE_MSGPRINTER *)0)) {
    {
#line 99
    free((void *)file);
    }
  }
#line 100
  return (rc);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fileprinter.c"
static void file_print(RDD_MSGPRINTER *printer , rdd_message_t type , int errcode ,
                       char const   *msg ) 
{ 
  RDD_FILE_MSGPRINTER *file ;

  {
  {
#line 107
  file = (RDD_FILE_MSGPRINTER *)printer->state;
#line 109
  fprintf((FILE */* __restrict  */)file->stream, (char const   */* __restrict  */)"%s\n",
          msg);
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/fileprinter.c"
static int file_close(RDD_MSGPRINTER *printer , unsigned int flags ) 
{ 
  RDD_FILE_MSGPRINTER *file ;
  struct stat fileinfo ;
  mode_t ro_mode ;
  int tmp ;
  int tmp___0 ;

  {
#line 115
  file = (RDD_FILE_MSGPRINTER *)printer->state;
#line 119
  if ((unsigned long )file->stream != (unsigned long )((void *)0)) {
    {
#line 119
    fclose(file->stream);
    }
  }
#line 121
  if ((unsigned long )file->path != (unsigned long )((char *)0)) {
#line 122
    if ((flags & 2U) != 0U) {
      {
#line 125
      memset((void *)(& fileinfo), 0, sizeof(fileinfo));
#line 126
      tmp = stat((char const   */* __restrict  */)file->path, (struct stat */* __restrict  */)(& fileinfo));
      }
#line 126
      if (tmp < 0) {
#line 127
        return (5);
      }
      {
#line 134
      ro_mode = fileinfo.st_mode;
#line 135
      ro_mode &= (unsigned int )(~ ((61568 | (128 >> 3)) | ((128 >> 3) >> 3)));
#line 137
      tmp___0 = chmod((char const   *)file->path, ro_mode);
      }
#line 137
      if (tmp___0 < 0) {
#line 138
        return (5);
      }
    }
    {
#line 142
    free((void *)file->path);
    }
  }
  {
#line 145
  memset((void *)file, 0, sizeof(*file));
  }
#line 146
  return (0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedbuf.h"
int rdd_new_alignedbuf(RDD_ALIGNEDBUF *buf , unsigned int bufsize , unsigned int align ) ;
#line 79
int rdd_free_alignedbuf(RDD_ALIGNEDBUF *buf ) ;
#line 88
unsigned int rdd_abuf_get_size(RDD_ALIGNEDBUF *buf ) ;
#line 97
unsigned int rdd_abuf_get_alignment(RDD_ALIGNEDBUF *buf ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedbuf.c"
int rdd_new_alignedbuf(RDD_ALIGNEDBUF *buf , unsigned int bufsize , unsigned int align ) 
{ 
  ptrdiff_t unaligned ;
  ptrdiff_t aligned ;
  unsigned char *tmp ;
  void *tmp___0 ;

  {
#line 56
  if (align <= 0U) {
#line 56
    return (2);
  }
  {
#line 58
  bufsize += align;
#line 59
  bufsize += align;
#line 61
  memset((void *)buf, 0, sizeof(*buf));
#line 63
  tmp___0 = malloc((size_t )bufsize);
#line 63
  tmp = (unsigned char *)tmp___0;
#line 63
  buf->unaligned = tmp;
  }
#line 63
  if ((unsigned long )tmp == (unsigned long )((unsigned char *)0)) {
#line 64
    return (1);
  }
#line 67
  unaligned = buf->unaligned - (unsigned char *)0;
#line 69
  if (unaligned % (long )align == 0L) {
#line 70
    aligned = unaligned;
  } else {
#line 72
    aligned = (unaligned + (ptrdiff_t )align) - unaligned % (long )align;
  }
#line 75
  buf->aligned = (unsigned char *)aligned;
#line 76
  buf->align = align;
#line 77
  buf->asize = (unsigned int )((ptrdiff_t )bufsize - (aligned - unaligned));
#line 79
  return (0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedbuf.c"
int rdd_free_alignedbuf(RDD_ALIGNEDBUF *buf ) 
{ 


  {
  {
#line 85
  free((void *)buf->unaligned);
#line 86
  memset((void *)buf, 0, sizeof(*buf));
  }
#line 88
  return (0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedbuf.c"
unsigned int rdd_abuf_get_size(RDD_ALIGNEDBUF *buf ) 
{ 


  {
#line 94
  return (buf->asize);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedbuf.c"
unsigned int rdd_abuf_get_alignment(RDD_ALIGNEDBUF *buf ) 
{ 


  {
#line 100
  return (buf->align);
}
}
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 1569 "/usr/include/zlib.h"
extern uLong adler32(uLong adler , Bytef const   *buf , uInt len ) ;
#line 1600
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/outfile.h"
extern int outfile_fopen(FILE **fp , char const   *path , int force_overwrite ) ;
#line 42
extern void outfile_fclose(FILE *fp , char *path ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
static int checksum_input(RDD_FILTER *f , unsigned char const   *buf , unsigned int nbyte ) ;
#line 75
static int checksum_block(RDD_FILTER *f , unsigned int pos ) ;
#line 76
static int checksum_close(RDD_FILTER *f ) ;
#line 77
static int checksum_free(RDD_FILTER *f ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
static RDD_FILTER_OPS checksum_ops  =    {& checksum_input, & checksum_block, & checksum_close, (int (*)(struct _RDD_FILTER *f ,
                                                                   unsigned char *buf ,
                                                                   unsigned int pos ))0,
    & checksum_free};
#line 87 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
static void reset_checksum(RDD_CHECKSUM_BLOCKFILTER *state ) 
{ 
  uLong tmp ;
  uLong tmp___0 ;

  {
  {
#line 91
  if ((unsigned int )state->algorithm == 1U) {
#line 91
    goto case_1;
  }
#line 94
  if ((unsigned int )state->algorithm == 2U) {
#line 94
    goto case_2;
  }
#line 90
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 92
  tmp = adler32((uLong )0, (Bytef const   *)((void *)0), (uInt )0);
#line 92
  state->checksum = (rdd_checksum_t )tmp;
  }
#line 93
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 95
  tmp___0 = crc32((uLong )0, (Bytef const   *)((void *)0), (uInt )0);
#line 95
  state->checksum = (rdd_checksum_t )tmp___0;
  }
#line 96
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
static void init_header(RDD_CHECKSUM_FILE_HEADER *rec , int type , size_t blocksize ,
                        off_t offset , off_t imgsize ) 
{ 


  {
  {
#line 105
  memset((void *)rec, '\000', sizeof(RDD_CHECKSUM_FILE_HEADER ));
#line 106
  rec->magic = (RDD_UINT16 )57085;
#line 107
  rec->version = (RDD_UINT16 )256;
#line 108
  rec->flags = (RDD_UINT16 )((int )rec->flags | type);
#line 109
  rec->blocksize = (RDD_UINT32 )blocksize;
#line 110
  rec->offset = offset;
#line 111
  rec->reserved = (RDD_UINT16 )0;
#line 112
  rec->imagesize = imgsize;
  }
#line 113
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
static int checksum_input(RDD_FILTER *f , unsigned char const   *buf , unsigned int nbyte ) 
{ 
  RDD_CHECKSUM_BLOCKFILTER *state ;
  uLong tmp ;
  uLong tmp___0 ;

  {
#line 118
  state = (RDD_CHECKSUM_BLOCKFILTER *)f->state;
  {
#line 121
  if ((unsigned int )state->algorithm == 1U) {
#line 121
    goto case_1;
  }
#line 124
  if ((unsigned int )state->algorithm == 2U) {
#line 124
    goto case_2;
  }
#line 120
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 122
  tmp = adler32((uLong )state->checksum, buf, nbyte);
#line 122
  state->checksum = (rdd_checksum_t )tmp;
  }
#line 123
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 125
  tmp___0 = crc32((uLong )state->checksum, buf, nbyte);
#line 125
  state->checksum = (rdd_checksum_t )tmp___0;
  }
#line 126
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 129
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
static int checksum_block(RDD_FILTER *f , unsigned int pos ) 
{ 
  RDD_CHECKSUM_BLOCKFILTER *state ;
  rdd_checksum_t checksum ;
  size_t tmp ;

  {
  {
#line 135
  state = (RDD_CHECKSUM_BLOCKFILTER *)f->state;
#line 136
  checksum = state->checksum;
#line 138
  tmp = fwrite((void const   */* __restrict  */)(& checksum), sizeof(checksum), (size_t )1,
               (FILE */* __restrict  */)state->fp);
  }
#line 138
  if (tmp < 1UL) {
#line 139
    return (4);
  }
  {
#line 141
  reset_checksum(state);
  }
#line 143
  return (0);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
static int checksum_close(RDD_FILTER *f ) 
{ 
  RDD_CHECKSUM_BLOCKFILTER *state ;

  {
  {
#line 149
  state = (RDD_CHECKSUM_BLOCKFILTER *)f->state;
#line 151
  outfile_fclose(state->fp, state->path);
#line 152
  state->fp = (FILE *)((void *)0);
  }
#line 154
  return (0);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
static int checksum_free(RDD_FILTER *f ) 
{ 
  RDD_CHECKSUM_BLOCKFILTER *state ;

  {
  {
#line 160
  state = (RDD_CHECKSUM_BLOCKFILTER *)f->state;
#line 162
  free((void *)state->path);
#line 163
  state->path = (char *)0;
  }
#line 165
  return (0);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
static int new_checksum_blockfilter(RDD_FILTER **self , rdd_checksum_algorithm_t alg ,
                                    unsigned int blocksize , char const   *outpath ,
                                    int overwrite ) 
{ 
  RDD_FILTER *f ;
  RDD_CHECKSUM_BLOCKFILTER *state ;
  RDD_CHECKSUM_FILE_HEADER header ;
  char *path ;
  FILE *fp ;
  int rc ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 172
  f = (RDD_FILTER *)0;
#line 173
  state = (RDD_CHECKSUM_BLOCKFILTER *)0;
#line 175
  path = (char *)0;
#line 176
  fp = (FILE *)((void *)0);
#line 177
  rc = 0;
#line 179
  if (blocksize <= 0U) {
#line 179
    return (2);
  }
#line 180
  if ((unsigned int )alg != 1U) {
#line 180
    if ((unsigned int )alg != 2U) {
#line 180
      return (2);
    }
  }
  {
#line 182
  rc = rdd_new_filter(& f, & checksum_ops, (unsigned int )sizeof(RDD_CHECKSUM_BLOCKFILTER ),
                      blocksize);
  }
#line 184
  if (rc != 0) {
#line 185
    goto error;
  }
  {
#line 187
  state = (RDD_CHECKSUM_BLOCKFILTER *)f->state;
#line 189
  tmp = strlen(outpath);
#line 189
  tmp___0 = malloc(tmp + 1UL);
#line 189
  path = (char *)tmp___0;
  }
#line 189
  if ((unsigned long )path == (unsigned long )((char *)0)) {
#line 190
    rc = 1;
#line 191
    goto error;
  }
  {
#line 193
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)outpath);
#line 195
  rc = outfile_fopen(& fp, outpath, overwrite);
  }
#line 195
  if (rc != 0) {
#line 196
    goto error;
  }
  {
#line 199
  state->path = path;
#line 200
  state->fp = fp;
#line 201
  state->algorithm = alg;
#line 202
  reset_checksum(state);
#line 204
  init_header(& header, (int )alg, (size_t )blocksize, (off_t )0, (off_t )0);
#line 205
  tmp___1 = fwrite((void const   */* __restrict  */)((void const   *)(& header)),
                   sizeof(header), (size_t )1, (FILE */* __restrict  */)state->fp);
  }
#line 205
  if (tmp___1 < 1UL) {
#line 206
    rc = 4;
#line 207
    goto error;
  }
#line 210
  *self = f;
#line 211
  return (0);
  error: 
#line 214
  *self = (RDD_FILTER *)0;
#line 215
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 215
    fclose(fp);
    }
  }
#line 216
  if ((unsigned long )path != (unsigned long )((char *)0)) {
    {
#line 216
    free((void *)path);
    }
  }
#line 217
  if ((unsigned long )state != (unsigned long )((RDD_CHECKSUM_BLOCKFILTER *)0)) {
    {
#line 217
    free((void *)state);
    }
  }
#line 218
  if ((unsigned long )f != (unsigned long )((RDD_FILTER *)0)) {
    {
#line 218
    free((void *)f);
    }
  }
#line 219
  return (rc);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
int rdd_new_adler32_blockfilter(RDD_FILTER **f , unsigned int blocksize , char const   *outpath ,
                                int overwrite ) 
{ 
  int tmp ;

  {
  {
#line 226
  tmp = new_checksum_blockfilter(f, (rdd_checksum_algorithm_t )1, blocksize, outpath,
                                 overwrite);
  }
#line 226
  return (tmp);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/checksumblockfilter.c"
int rdd_new_crc32_blockfilter(RDD_FILTER **f , unsigned int blocksize , char const   *outpath ,
                              int overwrite ) 
{ 
  int tmp ;

  {
  {
#line 234
  tmp = new_checksum_blockfilter(f, (rdd_checksum_algorithm_t )2, blocksize, outpath,
                                 overwrite);
  }
#line 234
  return (tmp);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static int rdd_faulty_read(RDD_READER *self , unsigned char *buf , unsigned int nbyte ,
                           unsigned int *nread ) ;
#line 77
static int rdd_faulty_tell(RDD_READER *self , rdd_count_t *pos ) ;
#line 78
static int rdd_faulty_seek(RDD_READER *self , rdd_count_t pos ) ;
#line 79
static int rdd_faulty_close(RDD_READER *self , int recurse ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static RDD_READ_OPS faulty_read_ops  =    {& rdd_faulty_read, & rdd_faulty_tell, & rdd_faulty_seek, & rdd_faulty_close};
#line 90 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static double uniform_random(unsigned short *state ) 
{ 


  {
#line 93
  return (0.0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static int fault_compare(void const   *p1 , void const   *p2 ) 
{ 
  RDDFAULT const   *f1 ;
  RDDFAULT const   *f2 ;

  {
#line 110
  f1 = (RDDFAULT const   *)p1;
#line 111
  f2 = (RDDFAULT const   *)p2;
#line 113
  if (f1->meanpos < f2->meanpos) {
#line 114
    return (-1);
  } else
#line 115
  if (f1->meanpos > f2->meanpos) {
#line 116
    return (1);
  } else {
#line 118
    return (0);
  }
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static void fault_init(RDDFAULT *f , rdd_count_t meanpos , rdd_count_t sigmapos ,
                       seed_t pos_seed , double errprob , seed_t err_seed ) 
{ 


  {
  {
#line 127
  memset((void *)f, '\000', sizeof(*f));
#line 128
  f->meanpos = meanpos;
#line 129
  f->sigmapos = sigmapos;
#line 130
  f->pos_seed = pos_seed;
#line 131
  f->errprob = errprob;
#line 132
  f->err_seed = err_seed;
  }
#line 133
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static int read_faults(FILE *fp , RDD_FAULTY_READER *state ) 
{ 
  char line[128] ;
  unsigned int lineno ;
  rdd_count_t pos ;
  double probability ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 145
  lineno = 1U;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    tmp___1 = fgets((char */* __restrict  */)(line), 128, (FILE */* __restrict  */)fp);
    }
#line 145
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 145
      goto while_break;
    }
    {
#line 146
    tmp = strlen((char const   *)(line));
    }
#line 146
    if (tmp >= 127UL) {
#line 147
      return (13);
    }
    {
#line 149
    tmp___0 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%llu %lf",
                     & pos, & probability);
    }
#line 149
    if (tmp___0 != 2) {
#line 150
      return (13);
    }
#line 153
    if (state->nfault >= 8U) {
#line 154
      return (12);
    }
    {
#line 156
    fault_init(& state->faults[state->nfault], pos, (rdd_count_t )0, (seed_t )0, probability,
               (seed_t )0);
#line 158
    (state->nfault) ++;
#line 145
    lineno ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  tmp___2 = feof(fp);
  }
#line 160
  if (! tmp___2) {
#line 161
    return (13);
  }
#line 164
  return (0);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
int rdd_open_faulty_reader(RDD_READER **self , RDD_READER *parent , char *path ) 
{ 
  RDD_READER *r ;
  RDD_FAULTY_READER *state ;
  FILE *fp ;
  int rc ;
  int tmp ;

  {
  {
#line 172
  r = (RDD_READER *)0;
#line 173
  state = (RDD_FAULTY_READER *)0;
#line 174
  fp = (FILE *)0;
#line 175
  rc = 0;
#line 177
  rc = rdd_new_reader(& r, & faulty_read_ops, (unsigned int )sizeof(RDD_FAULTY_READER ));
  }
#line 178
  if (rc != 0) {
#line 179
    goto error;
  }
  {
#line 182
  state = (RDD_FAULTY_READER *)r->state;
#line 184
  state->parent = parent;
#line 186
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 186
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 187
    rc = 7;
#line 188
    goto error;
  }
  {
#line 190
  rc = read_faults(fp, state);
  }
#line 190
  if (rc != 0) {
#line 191
    goto error;
  }
  {
#line 193
  tmp = fclose(fp);
  }
#line 193
  if (tmp == -1) {
#line 194
    rc = 5;
#line 195
    goto error;
  }
  {
#line 200
  qsort((void *)(state->faults), (size_t )state->nfault, sizeof(RDDFAULT ), & fault_compare);
#line 202
  *self = r;
  }
#line 203
  return (0);
  error: 
#line 206
  *self = (RDD_READER *)0;
#line 207
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 207
    fclose(fp);
    }
  }
#line 208
  if ((unsigned long )state != (unsigned long )((RDD_FAULTY_READER *)0)) {
    {
#line 208
    free((void *)state);
    }
  }
#line 209
  if ((unsigned long )r != (unsigned long )((RDD_READER *)0)) {
    {
#line 209
    free((void *)r);
    }
  }
#line 210
  return (rc);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static int rdd_faulty_read(RDD_READER *self , unsigned char *buf , unsigned int nbyte ,
                           unsigned int *nread ) 
{ 
  RDD_FAULTY_READER *state ;
  rdd_count_t pos ;
  RDDFAULT *f ;
  unsigned int i ;
  int rc ;
  double tmp ;
  int tmp___0 ;

  {
  {
#line 233
  state = (RDD_FAULTY_READER *)self->state;
#line 239
  rc = rdd_reader_tell(state->parent, & pos);
  }
#line 239
  if (rc != 0) {
#line 240
    return (rc);
  }
#line 243
  i = 0U;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (i < state->nfault)) {
#line 243
      goto while_break;
    }
#line 244
    f = & state->faults[i];
#line 246
    if (f->meanpos >= pos) {
#line 246
      if (f->meanpos < pos + (rdd_count_t )nbyte) {
        {
#line 246
        tmp = uniform_random((unsigned short *)(f->rngerr));
        }
#line 246
        if (tmp < f->errprob) {
          {
#line 251
          rc = rdd_reader_read(state->parent, buf, nbyte, nread);
          }
#line 252
          if (rc != 0) {
#line 253
            return (rc);
          }
#line 256
          if (f->meanpos < pos + (rdd_count_t )*nread) {
#line 258
            return (11);
          } else {
#line 260
            return (0);
          }
        }
      }
    }
#line 243
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  tmp___0 = rdd_reader_read(state->parent, buf, nbyte, nread);
  }
#line 267
  return (tmp___0);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static int rdd_faulty_tell(RDD_READER *self , rdd_count_t *pos ) 
{ 
  RDD_FAULTY_READER *state ;
  int tmp ;

  {
  {
#line 273
  state = (RDD_FAULTY_READER *)self->state;
#line 275
  tmp = rdd_reader_tell(state->parent, pos);
  }
#line 275
  return (tmp);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static int rdd_faulty_seek(RDD_READER *self , rdd_count_t pos ) 
{ 
  RDD_FAULTY_READER *state ;
  int tmp ;

  {
  {
#line 281
  state = (RDD_FAULTY_READER *)self->state;
#line 283
  tmp = rdd_reader_seek(state->parent, pos);
  }
#line 283
  return (tmp);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/faultyreader.c"
static int rdd_faulty_close(RDD_READER *self , int recurse ) 
{ 
  RDD_FAULTY_READER *state ;
  int tmp ;

  {
#line 289
  state = (RDD_FAULTY_READER *)self->state;
#line 291
  if (recurse) {
    {
#line 292
    tmp = rdd_reader_close(state->parent, 1);
    }
#line 292
    return (tmp);
  } else {
#line 294
    return (0);
  }
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c"
static int rdd_aligned_read(RDD_READER *self , unsigned char *buf , unsigned int nbyte ,
                            unsigned int *nread ) ;
#line 67
static int rdd_aligned_tell(RDD_READER *self , rdd_count_t *pos ) ;
#line 68
static int rdd_aligned_seek(RDD_READER *self , rdd_count_t pos ) ;
#line 69
static int rdd_aligned_close(RDD_READER *self , int recurse ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c"
static RDD_READ_OPS aligned_read_ops  =    {& rdd_aligned_read, & rdd_aligned_tell, & rdd_aligned_seek, & rdd_aligned_close};
#line 78 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c"
int rdd_open_aligned_reader(RDD_READER **self , RDD_READER *parent , unsigned int align ) 
{ 
  RDD_READER *r ;
  RDD_ALIGNED_READER *state ;
  int rc ;

  {
  {
#line 81
  r = (RDD_READER *)0;
#line 82
  state = (RDD_ALIGNED_READER *)0;
#line 83
  rc = 0;
#line 85
  rc = rdd_new_reader(& r, & aligned_read_ops, (unsigned int )sizeof(RDD_ALIGNED_READER ));
  }
#line 86
  if (rc != 0) {
#line 87
    return (rc);
  }
#line 90
  state = (RDD_ALIGNED_READER *)r->state;
#line 91
  state->parent = parent;
#line 92
  state->align = align;
#line 94
  *self = r;
#line 95
  return (0);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c"
static int rdd_aligned_read(RDD_READER *self , unsigned char *buf , unsigned int nbyte ,
                            unsigned int *nread ) 
{ 
  RDD_ALIGNED_READER *state ;
  unsigned char *p ;
  rdd_count_t start_pos ;
  rdd_count_t file_pos ;
  unsigned int sector_offset ;
  unsigned int sector_extra ;
  unsigned int done ;
  int rc ;
  int all_aligned ;
  unsigned int nparentread ;
  unsigned char *alignedbuf ;
  RDD_ALIGNEDBUF abuf ;
  int todo ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 102
  state = (RDD_ALIGNED_READER *)self->state;
#line 103
  p = (unsigned char *)0;
#line 104
  start_pos = (rdd_count_t )0;
#line 105
  file_pos = (rdd_count_t )0;
#line 109
  rc = 0;
#line 110
  all_aligned = 0;
#line 111
  nparentread = 0U;
#line 112
  alignedbuf = (unsigned char *)0;
#line 118
  rc = rdd_aligned_tell(self, & start_pos);
  }
#line 118
  if (rc != 0) {
#line 119
    return (rc);
  }
#line 121
  file_pos = start_pos;
#line 123
  if ((unsigned int )buf % state->align == 0U) {
#line 123
    if (nbyte % state->align == 0U) {
#line 123
      if (start_pos % (unsigned long )state->align == 0UL) {
#line 123
        tmp = 1;
      } else {
#line 123
        tmp = 0;
      }
    } else {
#line 123
      tmp = 0;
    }
  } else {
#line 123
    tmp = 0;
  }
#line 123
  all_aligned = tmp;
#line 126
  if (all_aligned) {
#line 127
    alignedbuf = buf;
  } else {
    {
#line 129
    rc = rdd_new_alignedbuf(& abuf, nbyte, state->align);
    }
#line 130
    if (rc != 0) {
#line 131
      return (rc);
    }
#line 133
    alignedbuf = abuf.aligned;
#line 134
    return (2);
  }
#line 137
  todo = (int )nbyte;
#line 141
  sector_offset = (unsigned int )(file_pos % (unsigned long )state->align);
#line 141
  if (sector_offset > 0U) {
    {
#line 142
    file_pos -= (rdd_count_t )sector_offset;
#line 143
    todo = (int )((unsigned int )todo + sector_offset);
#line 144
    tmp___0 = rdd_aligned_seek(self, file_pos);
    }
#line 144
    if (tmp___0 != 0) {
#line 145
      return (10);
    }
  }
#line 152
  sector_extra = (unsigned int )todo % state->align;
#line 152
  if (sector_extra > 0U) {
#line 153
    todo = (int )((unsigned int )todo + (512U - sector_extra));
  }
#line 155
  if (! (todo >= (int )sector_offset)) {
    {
#line 155
    __assert_fail("todo >= (signed) sector_offset", "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c",
                  155U, "rdd_aligned_read");
    }
  }
#line 159
  done = 0U;
#line 160
  p = buf;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (todo > 0)) {
#line 161
      goto while_break;
    }
#line 162
    if (! ((unsigned int )todo % state->align == 0U)) {
      {
#line 162
      __assert_fail("((todo) % ((state)->align)) == 0", "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c",
                    162U, "rdd_aligned_read");
      }
    }
#line 163
    if (! ((unsigned int )p % state->align == 0U)) {
      {
#line 163
      __assert_fail("(((unsigned) (p)) % ((state)->align)) == 0", "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c",
                    163U, "rdd_aligned_read");
      }
    }
    {
#line 165
    rc = rdd_reader_read(state->parent, p, (unsigned int )todo, & nparentread);
    }
#line 166
    if (rc == 15) {
#line 167
      goto while_continue;
    } else
#line 168
    if (rc != 0) {
#line 169
      return (rc);
    }
#line 172
    if (nparentread == 0U) {
#line 173
      goto while_break;
    }
#line 176
    if (nparentread % state->align != 0U) {
#line 180
      return (11);
    }
#line 183
    done += nparentread;
#line 184
    todo = (int )((unsigned int )todo - nparentread);
#line 185
    p += nparentread;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  file_pos += (rdd_count_t )done;
#line 194
  if (file_pos < start_pos) {
#line 198
    return (11);
  }
#line 201
  if (file_pos > start_pos + (rdd_count_t )nbyte) {
    {
#line 206
    file_pos = start_pos + (rdd_count_t )nbyte;
#line 207
    rc = rdd_aligned_seek(self, file_pos);
    }
#line 207
    if (rc != 0) {
#line 208
      return (rc);
    }
  }
#line 212
  *nread = (unsigned int )(file_pos - start_pos);
#line 214
  if ((unsigned long )alignedbuf != (unsigned long )buf) {
    {
#line 215
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)alignedbuf,
           (size_t )*nread);
#line 216
    rdd_free_alignedbuf(& abuf);
    }
  }
#line 219
  return (0);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c"
static int rdd_aligned_tell(RDD_READER *self , rdd_count_t *pos ) 
{ 
  RDD_ALIGNED_READER *state ;
  int tmp ;

  {
  {
#line 225
  state = (RDD_ALIGNED_READER *)self->state;
#line 227
  tmp = rdd_reader_tell(state->parent, pos);
  }
#line 227
  return (tmp);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c"
static int rdd_aligned_seek(RDD_READER *self , rdd_count_t pos ) 
{ 
  RDD_ALIGNED_READER *state ;
  int tmp ;

  {
  {
#line 233
  state = (RDD_ALIGNED_READER *)self->state;
#line 235
  tmp = rdd_reader_seek(state->parent, pos);
  }
#line 235
  return (tmp);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/rdd-2.0.7/src/alignedreader.c"
static int rdd_aligned_close(RDD_READER *self , int recurse ) 
{ 
  RDD_ALIGNED_READER *state ;
  int rc ;

  {
#line 241
  state = (RDD_ALIGNED_READER *)self->state;
#line 242
  rc = 0;
#line 244
  if (recurse) {
    {
#line 245
    rc = rdd_reader_close(state->parent, recurse);
    }
#line 246
    if (rc != 0) {
#line 247
      return (rc);
    }
  }
#line 251
  return (0);
}
}
