/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 50 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.h"
struct datatype {
   struct datatype *next ;
   int offset ;
   int length ;
   char *magic ;
   char *mask ;
   int action ;
   char *command ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 226 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 226 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 226 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 254 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
typedef void datafunc(FILE * );
#line 26 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.h"
enum actions {
    ACT_CAT = 0,
    ACT_DROP = 1,
    ACT_REJECT = 2,
    ACT_FILTER = 3,
    ACT_PIPETHRU = 4,
    ACT_ADDCR = 5,
    ACT_PS = 6,
    ACT_FFILTER = 7,
    ACT_FPIPE = 8,
    ACT_ERR = -1
} ;
#line 26 "/home/wheatley/newnew/temp/magicfilter-1.2/parseconfig.c"
enum __anonenum_state_26 {
    st_start = 0,
    st_zero = 1,
    st_oct = 2,
    st_dec = 3,
    st_hex = 4,
    st_done = 5
} ;
#line 184
enum __anonenum_state_27 {
    st_def = 0,
    st_backsl = 1,
    st_oct___0 = 2,
    st_hex___0 = 3,
    st_done___0 = 4
} ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 76 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.h"
struct datatype *load_config(char *file , int *in_block_size ) ;
#line 78
int getmagic(char *p , char **endpos , char *magic , char *mask ) ;
#line 83
int debug_flag ;
#line 84
char NO_WILD[1] ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 31 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
char *inblock  ;
#line 32 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
int inblock_size  ;
#line 33 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
int inblock_len  ;
#line 34 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
int done  =    0;
#line 35 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
char *program  ;
#line 36 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
char *config_file  =    (char *)((void *)0);
#line 37 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
int debug_flag  =    0;
#line 65 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
char const   *mailheader  =    "To: %s\nSubject: Rejected print job\n\nYour print job was automatically rejected as an invalid data type.\n\n";
#line 156 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void run(char *command ) 
{ 


  {
  {
#line 158
  execl("/bin/sh", "/bin/sh", "-c", command, (char *)((void *)0));
#line 159
  exit(255);
  }
}
}
#line 203 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
int fork_daemon(void) 
{ 
  pid_t pid ;
  int status ;
  int *tmp ;
  int *tmp___0 ;
  union __anonunion_54 __constr_expr_1 ;
  union __anonunion_55 __constr_expr_2 ;

  {
  {
#line 208
  pid = fork();
  }
#line 209
  if (pid < 0) {
#line 210
    return (-1);
  } else
#line 211
  if (pid == 0) {
    {
#line 213
    pid = fork();
    }
#line 214
    if (pid < 0) {
      {
#line 215
      tmp = __errno_location();
#line 215
      _exit(*tmp);
      }
    } else
#line 216
    if (pid == 0) {
#line 217
      return (0);
    } else {
      {
#line 219
      _exit(0);
      }
    }
  } else {
    {
#line 223
    waitpid(pid, & status, 0);
    }
#line 224
    if (status) {
      {
#line 226
      tmp___0 = __errno_location();
#line 226
      __constr_expr_2.__in = status;
      }
#line 226
      if ((__constr_expr_2.__i & 127) == 0) {
#line 226
        __constr_expr_1.__in = status;
#line 226
        *tmp___0 = (__constr_expr_1.__i & 65280) >> 8;
      } else {
#line 226
        *tmp___0 = 4;
      }
#line 227
      return (-1);
    }
#line 229
    return (1);
  }
}
}
#line 243 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void cat(FILE *f ) 
{ 
  size_t tmp ;

  {
#line 245
  if (inblock_len > 0) {
    {
#line 246
    fwrite((void const   */* __restrict  */)inblock, (size_t )1, (size_t )inblock_len,
           (FILE */* __restrict  */)f);
    }
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 248
    tmp = fread((void */* __restrict  */)inblock, (size_t )1, (size_t )inblock_size,
                (FILE */* __restrict  */)stdin);
#line 248
    inblock_len = (int )tmp;
    }
#line 248
    if (! (inblock_len > 0)) {
#line 248
      goto while_break;
    }
    {
#line 250
    fwrite((void const   */* __restrict  */)inblock, (size_t )1, (size_t )inblock_len,
           (FILE */* __restrict  */)f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 255 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void do_prefix_suffix(char *opt_str , datafunc *convfunc , FILE *f ) 
{ 
  char *p ;
  char *prefix ;
  char *suffix ;
  int n ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 257
  suffix = (char *)((void *)0);
#line 260
  n = getmagic(opt_str, & p, (char *)((void *)0), NO_WILD);
  }
#line 260
  if (n >= 0) {
#line 262
    if (n > 0) {
      {
#line 264
      tmp___0 = malloc((size_t )n);
#line 264
      prefix = (char *)tmp___0;
      }
#line 264
      if (! prefix) {
#line 266
        if (config_file) {
#line 266
          tmp = config_file;
        } else {
#line 266
          tmp = program;
        }
        {
#line 266
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Out of memory\n",
                tmp);
#line 267
        exit(1);
        }
      }
      {
#line 269
      getmagic(opt_str, & p, prefix, NO_WILD);
#line 270
      fwrite((void const   */* __restrict  */)prefix, (size_t )1, (size_t )n, (FILE */* __restrict  */)f);
#line 271
      free((void *)prefix);
      }
    }
    {
#line 273
    n = getmagic(p, (char **)((void *)0), (char *)((void *)0), NO_WILD);
    }
#line 273
    if (n > 0) {
      {
#line 275
      tmp___2 = malloc((size_t )n);
#line 275
      suffix = (char *)tmp___2;
      }
#line 275
      if (! suffix) {
#line 277
        if (config_file) {
#line 277
          tmp___1 = config_file;
        } else {
#line 277
          tmp___1 = program;
        }
        {
#line 277
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Out of memory\n",
                tmp___1);
#line 278
        exit(1);
        }
      }
      {
#line 280
      getmagic(p, (char **)((void *)0), suffix, NO_WILD);
      }
    }
  }
  {
#line 284
  (*convfunc)(f);
  }
#line 286
  if (suffix) {
    {
#line 288
    fwrite((void const   */* __restrict  */)suffix, (size_t )1, (size_t )n, (FILE */* __restrict  */)f);
#line 289
    free((void *)suffix);
    }
  }
#line 291
  return;
}
}
#line 293 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void act_cat(char *opt_str ) 
{ 


  {
#line 295
  if (debug_flag) {
    {
#line 296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cat %s\n",
            opt_str);
    }
  }
  {
#line 298
  do_prefix_suffix(opt_str, & cat, stdout);
#line 299
  done = 1;
  }
#line 300
  return;
}
}
#line 316 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void addcr(FILE *f ) 
{ 
  char *p ;
  int i ;
  size_t tmp ;

  {
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    i = inblock_len;
#line 323
    p = inblock;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 323
      if (! i) {
#line 323
        goto while_break___0;
      }
      {
#line 328
      if ((int )*p == 12) {
#line 328
        goto case_12;
      }
#line 328
      if ((int )*p == 10) {
#line 328
        goto case_12;
      }
#line 332
      goto switch_default;
      case_12: /* CIL Label */ 
      case_10: /* CIL Label */ 
      {
#line 329
      _IO_putc('\r', f);
      }
      switch_default: /* CIL Label */ 
      {
#line 333
      _IO_putc((int )*p, f);
      }
#line 334
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 323
      i --;
#line 323
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 338
    tmp = fread((void */* __restrict  */)inblock, (size_t )1, (size_t )inblock_size,
                (FILE */* __restrict  */)stdin);
#line 338
    inblock_len = (int )tmp;
    }
#line 321
    if (! (inblock_len > 0)) {
#line 321
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  _IO_putc('\r', f);
#line 343
  _IO_putc('\f', f);
  }
#line 344
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void act_addcr(char *opt_str ) 
{ 


  {
#line 349
  if (debug_flag) {
    {
#line 350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"text %s\n",
            opt_str);
    }
  }
  {
#line 352
  do_prefix_suffix(opt_str, & addcr, stdout);
#line 353
  done = 1;
  }
#line 354
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void act_ps(void) 
{ 


  {
#line 366
  if (debug_flag) {
    {
#line 367
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"postscript\n");
    }
  }
  {
#line 369
  addcr(stdout);
#line 370
  putchar('\004');
#line 371
  done = 1;
  }
#line 372
  return;
}
}
#line 381 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void act_drop(void) 
{ 


  {
#line 383
  if (debug_flag) {
    {
#line 384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ignore\n");
    }
  }
#line 386
  done = 1;
#line 387
  return;
}
}
#line 398 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void act_reject(char *message , char *user , char *host ) 
{ 
  int fildes[2] ;
  pid_t pid ;
  FILE *msg ;
  char address[8192] ;
  int status ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 406
  if (debug_flag) {
    {
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reject %s\n",
            message);
    }
  }
  {
#line 412
  sprintf((char */* __restrict  */)(address), (char const   */* __restrict  */)"%s@%s",
          user, host);
#line 415
  tmp___0 = pipe((int *)(fildes));
  }
#line 415
  if (tmp___0) {
#line 417
    if (config_file) {
#line 417
      tmp = config_file;
    } else {
#line 417
      tmp = program;
    }
    {
#line 417
    perror((char const   *)tmp);
#line 418
    exit(1);
    }
  }
  {
#line 421
  pid = fork();
  }
#line 423
  if (pid < 0) {
#line 425
    if (config_file) {
#line 425
      tmp___1 = config_file;
    } else {
#line 425
      tmp___1 = program;
    }
    {
#line 425
    perror((char const   *)tmp___1);
#line 426
    exit(1);
    }
  } else
#line 428
  if (pid == 0) {
    {
#line 430
    close(fildes[1]);
#line 431
    tmp___2 = fileno(stdin);
#line 431
    dup2(fildes[0], tmp___2);
#line 432
    execl("/usr/sbin/sendmail", "/usr/sbin/sendmail", address, (char *)((void *)0));
#line 433
    exit(255);
    }
  } else {
    {
#line 437
    close(fildes[0]);
#line 438
    msg = fdopen(fildes[1], "wb");
#line 440
    fprintf((FILE */* __restrict  */)msg, (char const   */* __restrict  */)mailheader,
            address);
#line 441
    fprintf((FILE */* __restrict  */)msg, (char const   */* __restrict  */)"%s\n",
            message);
#line 442
    fclose(msg);
#line 444
    waitpid(pid, & status, 0);
    }
#line 446
    if (status) {
#line 448
      if (config_file) {
#line 448
        tmp___3 = config_file;
      } else {
#line 448
        tmp___3 = program;
      }
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s failed\n",
              tmp___3, "/usr/sbin/sendmail");
      }
    }
  }
#line 452
  done = 1;
#line 453
  return;
}
}
#line 466 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void act_filter(char *command ) 
{ 
  int fildes[2] ;
  FILE *out ;
  pid_t pid ;
  int status ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 473
  if (debug_flag) {
    {
#line 474
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filter %s\n",
            command);
    }
  }
  {
#line 476
  tmp___0 = pipe((int *)(fildes));
  }
#line 476
  if (tmp___0) {
#line 478
    if (config_file) {
#line 478
      tmp = config_file;
    } else {
#line 478
      tmp = program;
    }
    {
#line 478
    perror((char const   *)tmp);
#line 479
    exit(1);
    }
  }
  {
#line 482
  pid = fork();
  }
#line 484
  if (pid < 0) {
#line 486
    if (config_file) {
#line 486
      tmp___1 = config_file;
    } else {
#line 486
      tmp___1 = program;
    }
    {
#line 486
    perror((char const   *)tmp___1);
#line 487
    exit(1);
    }
  } else
#line 489
  if (pid == 0) {
    {
#line 491
    close(fildes[1]);
#line 492
    tmp___2 = fileno(stdin);
#line 492
    dup2(fildes[0], tmp___2);
#line 493
    run(command);
    }
  } else {
    {
#line 497
    close(fildes[0]);
#line 498
    out = fdopen(fildes[1], "wb");
#line 499
    cat(out);
#line 500
    fclose(out);
#line 502
    waitpid(pid, & status, 0);
    }
#line 504
    if (status) {
#line 506
      if (config_file) {
#line 506
        tmp___3 = config_file;
      } else {
#line 506
        tmp___3 = program;
      }
      {
#line 506
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s failed\n",
              tmp___3, command);
#line 507
      exit(255);
      }
    }
  }
#line 511
  done = 1;
#line 512
  return;
}
}
#line 523
void act_ffilter(char *command ) ;
#line 523 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
static char tmpbuf[33]  = 
#line 523
  {      (char )'F',      (char )'I',      (char )'L',      (char )'E', 
        (char )'=',      (char )'/',      (char )'t',      (char )'m', 
        (char )'p',      (char )'/',      (char )'m',      (char )'f', 
        (char )'i',      (char )'l',      (char )'t',      (char )'e', 
        (char )'r',      (char )'.',      (char )'N',      (char )'N', 
        (char )'N',      (char )'N',      (char )'N',      (char )'N', 
        (char )'N',      (char )'.',      (char )'X',      (char )'X', 
        (char )'X',      (char )'X',      (char )'X',      (char )'X', 
        (char )'\000'};
#line 521 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void act_ffilter(char *command ) 
{ 
  FILE *out ;
  int outfd ;
  pid_t pid ;
  int status ;
  int fd ;
  __pid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 530
  if (debug_flag) {
    {
#line 531
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ffilter %s\n",
            command);
    }
  }
  {
#line 533
  tmp = getpid();
#line 533
  sprintf((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"FILE=/tmp/mfilter.%d.XXXXXX",
          tmp);
#line 535
  fd = mkstemp(tmpbuf + 5);
  }
#line 535
  if (fd == -1) {
#line 535
    goto _L;
  } else {
    {
#line 535
    out = fdopen(fd, "wb");
    }
#line 535
    if (! out) {
      _L: /* CIL Label */ 
#line 537
      if (config_file) {
#line 537
        tmp___0 = config_file;
      } else {
#line 537
        tmp___0 = program;
      }
      {
#line 537
      perror((char const   *)tmp___0);
#line 538
      exit(1);
      }
    }
  }
  {
#line 541
  cat(out);
#line 542
  fclose(out);
#line 544
  pid = fork();
  }
#line 546
  if (pid < 0) {
#line 548
    if (config_file) {
#line 548
      tmp___1 = config_file;
    } else {
#line 548
      tmp___1 = program;
    }
    {
#line 548
    perror((char const   *)tmp___1);
#line 549
    exit(1);
    }
  } else
#line 551
  if (pid == 0) {
    {
#line 553
    putenv(tmpbuf);
#line 554
    outfd = open((char const   *)(tmpbuf + 5), 0);
#line 555
    tmp___2 = fileno(stdin);
#line 555
    dup2(outfd, tmp___2);
#line 556
    run(command);
    }
  } else {
    {
#line 560
    waitpid(pid, & status, 0);
    }
#line 562
    if (status) {
#line 564
      if (config_file) {
#line 564
        tmp___3 = config_file;
      } else {
#line 564
        tmp___3 = program;
      }
      {
#line 564
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s failed\n",
              tmp___3, command);
      }
    }
    {
#line 567
    unlink((char const   *)(tmpbuf + 5));
    }
#line 569
    if (status) {
      {
#line 570
      exit(255);
      }
    }
  }
#line 573
  done = 1;
#line 574
  return;
}
}
#line 587 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void act_pipethru(char *command ) 
{ 
  int inpipefd[2] ;
  int outpipefd[2] ;
  FILE *out ;
  pid_t pid ;
  pid_t xpid ;
  int null ;
  int status ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __pid_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;

  {
#line 596
  if (debug_flag) {
    {
#line 597
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pipe %s\n",
            command);
    }
  }
  {
#line 599
  tmp___0 = pipe((int *)(inpipefd));
  }
#line 599
  if (tmp___0) {
#line 599
    goto _L;
  } else {
    {
#line 599
    tmp___1 = pipe((int *)(outpipefd));
    }
#line 599
    if (tmp___1) {
      _L: /* CIL Label */ 
#line 601
      if (config_file) {
#line 601
        tmp = config_file;
      } else {
#line 601
        tmp = program;
      }
      {
#line 601
      perror((char const   *)tmp);
#line 602
      exit(1);
      }
    }
  }
  {
#line 605
  xpid = fork_daemon();
  }
#line 607
  if (xpid < 0) {
#line 609
    if (config_file) {
#line 609
      tmp___2 = config_file;
    } else {
#line 609
      tmp___2 = program;
    }
    {
#line 609
    perror((char const   *)tmp___2);
#line 610
    exit(1);
    }
  } else
#line 612
  if (xpid == 0) {
    {
#line 614
    close(outpipefd[0]);
#line 616
    pid = fork();
    }
#line 618
    if (pid < 0) {
#line 620
      if (config_file) {
#line 620
        tmp___3 = config_file;
      } else {
#line 620
        tmp___3 = program;
      }
      {
#line 620
      perror((char const   *)tmp___3);
#line 621
      exit(1);
      }
    } else
#line 623
    if (pid == 0) {
      {
#line 625
      close(inpipefd[1]);
#line 626
      tmp___4 = fileno(stdin);
#line 626
      dup2(inpipefd[0], tmp___4);
#line 627
      tmp___5 = fileno(stdout);
#line 627
      dup2(outpipefd[1], tmp___5);
#line 628
      run(command);
      }
    } else {
      {
#line 634
      close(inpipefd[0]);
#line 635
      close(outpipefd[1]);
#line 637
      out = fdopen(inpipefd[1], "wb");
#line 638
      cat(out);
#line 639
      fclose(out);
#line 643
      tmp___6 = waitpid(pid, & status, 0);
      }
#line 643
      if (tmp___6 < 0) {
        {
#line 644
        perror("waitpid");
        }
      }
#line 648
      if (status > 0) {
        {
#line 649
        exit(255);
        }
      }
      {
#line 651
      exit(0);
      }
    }
  } else {
    {
#line 658
    close(inpipefd[0]);
#line 659
    close(outpipefd[1]);
#line 660
    close(inpipefd[1]);
#line 663
    null = open("/dev/null", 0);
#line 664
    tmp___7 = fileno(stdin);
#line 664
    dup2(null, tmp___7);
#line 665
    close(null);
    }
    {
#line 666
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 666
      tmp___8 = fread((void */* __restrict  */)inblock, (size_t )1, (size_t )inblock_size,
                      (FILE */* __restrict  */)stdin);
      }
#line 666
      if (! (tmp___8 > 0UL)) {
#line 666
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 668
    tmp___9 = fileno(stdin);
#line 668
    tmp___10 = dup2(outpipefd[0], tmp___9);
    }
#line 668
    if (tmp___10 < 0) {
      {
#line 670
      perror("dup2");
#line 671
      exit(1);
      }
    }
    {
#line 674
    close(outpipefd[0]);
#line 676
    rewind(stdin);
#line 677
    tmp___11 = fread((void */* __restrict  */)inblock, (size_t )1, (size_t )inblock_size,
                     (FILE */* __restrict  */)stdin);
#line 677
    inblock_len = (int )tmp___11;
    }
  }
#line 679
  return;
}
}
#line 691
void act_fpipe(char *command ) ;
#line 691 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
static char tmpbuf___0[33]  = 
#line 691
  {      (char )'F',      (char )'I',      (char )'L',      (char )'E', 
        (char )'=',      (char )'/',      (char )'t',      (char )'m', 
        (char )'p',      (char )'/',      (char )'m',      (char )'f', 
        (char )'i',      (char )'l',      (char )'t',      (char )'e', 
        (char )'r',      (char )'.',      (char )'N',      (char )'N', 
        (char )'N',      (char )'N',      (char )'N',      (char )'N', 
        (char )'N',      (char )'.',      (char )'X',      (char )'X', 
        (char )'X',      (char )'X',      (char )'X',      (char )'X', 
        (char )'\000'};
#line 689 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void act_fpipe(char *command ) 
{ 
  int outpipefd[2] ;
  FILE *out ;
  int outfd ;
  pid_t pid ;
  pid_t xpid ;
  int null ;
  int status ;
  int fd ;
  __pid_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __pid_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;

  {
#line 700
  if (debug_flag) {
    {
#line 701
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fpipe %s\n",
            command);
    }
  }
  {
#line 703
  tmp = getpid();
#line 703
  sprintf((char */* __restrict  */)(tmpbuf___0), (char const   */* __restrict  */)"FILE=/tmp/mfilter.%d.XXXXXX",
          tmp);
#line 705
  fd = mkstemp(tmpbuf___0 + 5);
  }
#line 705
  if (fd == -1) {
#line 705
    goto _L;
  } else {
    {
#line 705
    out = fdopen(fd, "w+b");
    }
#line 705
    if (out) {
      {
#line 705
      tmp___1 = pipe((int *)(outpipefd));
      }
#line 705
      if (tmp___1) {
        _L: /* CIL Label */ 
#line 710
        if (config_file) {
#line 710
          tmp___0 = config_file;
        } else {
#line 710
          tmp___0 = program;
        }
        {
#line 710
        perror((char const   *)tmp___0);
#line 711
        exit(1);
        }
      }
    } else {
#line 705
      goto _L;
    }
  }
  {
#line 714
  cat(out);
#line 715
  fclose(out);
#line 717
  xpid = fork_daemon();
  }
#line 719
  if (xpid < 0) {
#line 721
    if (config_file) {
#line 721
      tmp___2 = config_file;
    } else {
#line 721
      tmp___2 = program;
    }
    {
#line 721
    perror((char const   *)tmp___2);
#line 722
    exit(1);
    }
  } else
#line 724
  if (xpid == 0) {
    {
#line 726
    close(outpipefd[0]);
#line 728
    pid = fork();
    }
#line 730
    if (pid < 0) {
#line 732
      if (config_file) {
#line 732
        tmp___3 = config_file;
      } else {
#line 732
        tmp___3 = program;
      }
      {
#line 732
      perror((char const   *)tmp___3);
#line 733
      exit(1);
      }
    } else
#line 735
    if (pid == 0) {
      {
#line 737
      putenv(tmpbuf___0);
#line 738
      outfd = open((char const   *)(tmpbuf___0 + 5), 0);
#line 739
      tmp___4 = fileno(stdin);
#line 739
      dup2(outfd, tmp___4);
#line 740
      tmp___5 = fileno(stdout);
#line 740
      dup2(outpipefd[1], tmp___5);
#line 741
      run(command);
      }
    } else {
      {
#line 745
      close(outpipefd[1]);
#line 749
      tmp___6 = waitpid(pid, & status, 0);
      }
#line 749
      if (tmp___6 < 0) {
        {
#line 750
        perror("waitpid");
        }
      }
      {
#line 755
      unlink((char const   *)(tmpbuf___0 + 5));
      }
#line 757
      if (status) {
        {
#line 758
        exit(255);
        }
      } else {
        {
#line 760
        exit(0);
        }
      }
    }
  } else {
    {
#line 765
    close(outpipefd[1]);
#line 770
    null = open("/dev/null", 0);
#line 771
    tmp___7 = fileno(stdin);
#line 771
    dup2(null, tmp___7);
#line 772
    close(null);
    }
    {
#line 773
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 773
      tmp___8 = fread((void */* __restrict  */)inblock, (size_t )1, (size_t )inblock_size,
                      (FILE */* __restrict  */)stdin);
      }
#line 773
      if (! (tmp___8 > 0UL)) {
#line 773
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 775
    tmp___9 = fileno(stdin);
#line 775
    tmp___10 = dup2(outpipefd[0], tmp___9);
    }
#line 775
    if (tmp___10 < 0) {
      {
#line 777
      perror("dup2");
#line 778
      exit(1);
      }
    }
    {
#line 781
    close(outpipefd[0]);
#line 783
    rewind(stdin);
#line 784
    tmp___11 = fread((void */* __restrict  */)inblock, (size_t )1, (size_t )inblock_size,
                     (FILE */* __restrict  */)stdin);
#line 784
    inblock_len = (int )tmp___11;
    }
  }
#line 786
  return;
}
}
#line 795 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
int matches(char *block , char *pattern , char *mask , int length ) 
{ 
  int i ;
  char *p ;
  char *q ;
  char *m ;

  {
#line 800
  q = block;
#line 801
  p = pattern;
#line 802
  m = mask;
#line 804
  i = length;
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 804
    if (! i) {
#line 804
      goto while_break;
    }
#line 806
    if (((int )*p ^ (int )*q) & (int )*m) {
#line 807
      return (0);
    }
#line 808
    q ++;
#line 808
    p ++;
#line 808
    m ++;
#line 804
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  return (1);
}
}
#line 837 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
void envset(char *var , char *value ) 
{ 
  char *buf ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 841
  tmp___0 = strlen((char const   *)var);
#line 841
  tmp___1 = strlen((char const   *)value);
#line 841
  tmp___2 = malloc((tmp___0 + tmp___1) + 2UL);
#line 841
  buf = (char *)tmp___2;
  }
#line 841
  if (! buf) {
#line 843
    if (config_file) {
#line 843
      tmp = config_file;
    } else {
#line 843
      tmp = program;
    }
    {
#line 843
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory\n",
            tmp);
#line 844
    exit(1);
    }
  }
  {
#line 846
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s=%s",
          var, value);
#line 847
  tmp___4 = putenv(buf);
  }
#line 847
  if (tmp___4) {
#line 849
    if (config_file) {
#line 849
      tmp___3 = config_file;
    } else {
#line 849
      tmp___3 = program;
    }
    {
#line 849
    perror((char const   *)tmp___3);
#line 850
    exit(1);
    }
  }
#line 852
  if (debug_flag) {
    {
#line 853
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            buf);
    }
  }
#line 854
  return;
}
}
#line 862 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.c"
int main(int argc , char **argv ) 
{ 
  int do_cat ;
  int i ;
  struct datatype  const  *dtab ;
  struct datatype  const  *dt ;
  char *user ;
  char *host ;
  struct passwd *pwptr ;
  char *realname ;
  size_t l ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  struct datatype *tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;

  {
#line 864
  do_cat = 0;
#line 866
  dtab = (struct datatype  const  *)((void *)0);
#line 867
  dt = (struct datatype  const  *)((void *)0);
#line 868
  user = (char *)"unknown";
#line 869
  host = (char *)"unknown";
#line 871
  program = *(argv + 0);
#line 873
  if (argc < 2) {
    {
#line 875
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No configuration file specified\n",
            program);
#line 876
    exit(1);
    }
  }
  {
#line 897
  putenv((char *)"LPUSER=");
#line 898
  putenv((char *)"LPUSERNAME=");
#line 899
  putenv((char *)"LPHOST=");
#line 900
  putenv((char *)"LPJOB=");
#line 901
  putenv((char *)"FILE=");
#line 902
  putenv((char *)"PRINTER=");
#line 903
  putenv((char *)"LPFORMAT=");
#line 904
  putenv((char *)"LPCLASS=");
#line 905
  putenv((char *)"LPACCT=");
#line 906
  putenv((char *)"LPCOPIES=");
#line 907
  putenv((char *)"LPQUEUE=");
#line 908
  putenv((char *)"ZOPT=");
#line 909
  putenv((char *)"BANNERNAME=");
#line 911
  putenv((char *)"LPINDENT=0");
#line 913
  i = 1;
  }
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! (i < argc)) {
#line 913
      goto while_break;
    }
#line 915
    if ((int )*(*(argv + i) + 0) == 45) {
      {
#line 917
      tmp___13 = strcmp((char const   *)*(argv + i), "-c");
      }
#line 917
      if (tmp___13 == 0) {
#line 918
        do_cat = 1;
      } else {
        {
#line 919
        tmp___12 = strncmp((char const   *)*(argv + i), "-n", (size_t )2);
        }
#line 919
        if (tmp___12 == 0) {
#line 923
          if (*(*(argv + i) + 2)) {
#line 923
            user = *(argv + i) + 2;
          } else
#line 923
          if (i == argc - 1) {
#line 923
            user = *(argv + i) + 2;
          } else {
#line 923
            i ++;
#line 923
            user = *(argv + i);
          }
          {
#line 924
          envset((char *)"LPUSER", user);
#line 926
          pwptr = getpwnam((char const   *)user);
          }
#line 927
          if ((unsigned long )pwptr != (unsigned long )((void *)0)) {
            {
#line 932
            realname = strtok((char */* __restrict  */)pwptr->pw_gecos, (char const   */* __restrict  */)",[");
            }
#line 934
            if ((unsigned long )realname != (unsigned long )((void *)0)) {
              {
#line 938
              tmp = strlen((char const   *)realname);
#line 938
              l = tmp - 1UL;
              }
              {
#line 939
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 939
                if (! ((int )*(realname + l) == 32)) {
#line 939
                  goto while_break___0;
                }
#line 939
                *(realname + l) = (char )'\000';
#line 939
                l --;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 941
              envset((char *)"LPUSERNAME", realname);
              }
            }
          }
        } else {
          {
#line 945
          tmp___11 = strncmp((char const   *)*(argv + i), "-h", (size_t )2);
          }
#line 945
          if (tmp___11 == 0) {
#line 947
            if (*(*(argv + i) + 2)) {
#line 947
              host = *(argv + i) + 2;
            } else
#line 947
            if (i == argc - 1) {
#line 947
              host = *(argv + i) + 2;
            } else {
#line 947
              i ++;
#line 947
              host = *(argv + i);
            }
            {
#line 948
            envset((char *)"LPHOST", host);
            }
          } else {
            {
#line 950
            tmp___10 = strncmp((char const   *)*(argv + i), "-i", (size_t )2);
            }
#line 950
            if (tmp___10 == 0) {
              {
#line 951
              envset((char *)"LPINDENT", *(argv + i) + 2);
              }
            } else {
              {
#line 952
              tmp___9 = strncmp((char const   *)*(argv + i), "-C", (size_t )2);
              }
#line 952
              if (tmp___9 == 0) {
                {
#line 953
                envset((char *)"LPCLASS", *(argv + i) + 2);
                }
              } else {
                {
#line 954
                tmp___8 = strncmp((char const   *)*(argv + i), "-F", (size_t )2);
                }
#line 954
                if (tmp___8 == 0) {
                  {
#line 955
                  envset((char *)"LPFORMAT", *(argv + i) + 2);
                  }
                } else {
                  {
#line 956
                  tmp___7 = strncmp((char const   *)*(argv + i), "-J", (size_t )2);
                  }
#line 956
                  if (tmp___7 == 0) {
                    {
#line 957
                    envset((char *)"LPJOB", *(argv + i) + 2);
                    }
                  } else {
                    {
#line 958
                    tmp___6 = strncmp((char const   *)*(argv + i), "-K", (size_t )2);
                    }
#line 958
                    if (tmp___6 == 0) {
                      {
#line 959
                      envset((char *)"LPCOPIES", *(argv + i) + 2);
                      }
                    } else {
                      {
#line 960
                      tmp___5 = strncmp((char const   *)*(argv + i), "-L", (size_t )2);
                      }
#line 960
                      if (tmp___5 == 0) {
                        {
#line 961
                        envset((char *)"BANNERNAME", *(argv + i) + 2);
                        }
                      } else {
                        {
#line 962
                        tmp___4 = strncmp((char const   *)*(argv + i), "-P", (size_t )2);
                        }
#line 962
                        if (tmp___4 == 0) {
                          {
#line 963
                          envset((char *)"PRINTER", *(argv + i) + 2);
                          }
                        } else {
                          {
#line 964
                          tmp___3 = strncmp((char const   *)*(argv + i), "-Q", (size_t )2);
                          }
#line 964
                          if (tmp___3 == 0) {
                            {
#line 965
                            envset((char *)"LPQUEUE", *(argv + i) + 2);
                            }
                          } else {
                            {
#line 966
                            tmp___2 = strncmp((char const   *)*(argv + i), "-R", (size_t )2);
                            }
#line 966
                            if (tmp___2 == 0) {
                              {
#line 967
                              envset((char *)"LPACCT", *(argv + i) + 2);
                              }
                            } else {
                              {
#line 968
                              tmp___1 = strncmp((char const   *)*(argv + i), "-Z",
                                                (size_t )2);
                              }
#line 968
                              if (tmp___1 == 0) {
                                {
#line 969
                                envset((char *)"ZOPT", *(argv + i) + 2);
                                }
                              } else {
                                {
#line 970
                                tmp___0 = strcmp((char const   *)*(argv + i), "--debug");
                                }
#line 970
                                if (tmp___0 == 0) {
#line 971
                                  debug_flag = 1;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else
#line 974
    if (! config_file) {
#line 975
      config_file = *(argv + i);
    }
#line 913
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 978
  umask((__mode_t )63);
  }
#line 980
  if (do_cat) {
#line 982
    if (debug_flag) {
      {
#line 983
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(literal)\n");
      }
    }
#line 984
    inblock_size = 8192;
  } else {
    {
#line 988
    tmp___14 = load_config(config_file, & i);
#line 988
    dtab = (struct datatype  const  *)tmp___14;
    }
#line 989
    if (! dtab) {
      {
#line 989
      exit(1);
      }
    }
#line 991
    inblock_size = (((i + 8192) - 1) / 8192) * 8192;
  }
  {
#line 994
  tmp___16 = malloc((size_t )inblock_size);
#line 994
  inblock = (char *)tmp___16;
  }
#line 994
  if (! inblock) {
#line 996
    if (config_file) {
#line 996
      tmp___15 = config_file;
    } else {
#line 996
      tmp___15 = program;
    }
    {
#line 996
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Out of memory\n",
            tmp___15);
#line 997
    exit(1);
    }
  }
  {
#line 1000
  tmp___17 = fread((void */* __restrict  */)inblock, (size_t )1, (size_t )inblock_size,
                   (FILE */* __restrict  */)stdin);
#line 1000
  inblock_len = (int )tmp___17;
  }
#line 1002
  if (do_cat) {
    {
#line 1004
    cat(stdout);
#line 1005
    done = 1;
    }
  } else {
    {
#line 1009
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1009
      if (! done) {
#line 1009
        if (! (inblock_len > 0)) {
#line 1009
          goto while_break___1;
        }
      } else {
#line 1009
        goto while_break___1;
      }
#line 1011
      dt = dtab;
      {
#line 1012
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1012
        if (! dt) {
#line 1012
          goto while_break___2;
        }
#line 1014
        if (dt->length < 1) {
#line 1016
          goto while_break___2;
        } else {
          {
#line 1014
          tmp___18 = matches(inblock + dt->offset, (char *)dt->magic, (char *)dt->mask,
                             (int )dt->length);
          }
#line 1014
          if (tmp___18) {
#line 1016
            goto while_break___2;
          }
        }
#line 1018
        dt = (struct datatype  const  *)dt->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1021
      if (! dt) {
#line 1023
        if (config_file) {
#line 1023
          tmp___19 = config_file;
        } else {
#line 1023
          tmp___19 = program;
        }
        {
#line 1023
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown type data and no default; job sent by %s@%s)\n",
                tmp___19, user, host);
#line 1025
        exit(1);
        }
      }
      {
#line 1032
      if (dt->action == 0) {
#line 1032
        goto case_0;
      }
#line 1036
      if (dt->action == 1) {
#line 1036
        goto case_1;
      }
#line 1040
      if (dt->action == 2) {
#line 1040
        goto case_2;
      }
#line 1044
      if (dt->action == 3) {
#line 1044
        goto case_3;
      }
#line 1048
      if (dt->action == 4) {
#line 1048
        goto case_4;
      }
#line 1052
      if (dt->action == 5) {
#line 1052
        goto case_5;
      }
#line 1056
      if (dt->action == 6) {
#line 1056
        goto case_6;
      }
#line 1060
      if (dt->action == 7) {
#line 1060
        goto case_7;
      }
#line 1064
      if (dt->action == 8) {
#line 1064
        goto case_8;
      }
#line 1068
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 1033
      act_cat((char *)dt->command);
      }
#line 1034
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 1037
      act_drop();
      }
#line 1038
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1041
      act_reject((char *)dt->command, user, host);
      }
#line 1042
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 1045
      act_filter((char *)dt->command);
      }
#line 1046
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 1049
      act_pipethru((char *)dt->command);
      }
#line 1050
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 1053
      act_addcr((char *)dt->command);
      }
#line 1054
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 1057
      act_ps();
      }
#line 1058
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 1061
      act_ffilter((char *)dt->command);
      }
#line 1062
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 1065
      act_fpipe((char *)dt->command);
      }
#line 1066
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1069
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(%s): Internal error - invalid parse\nPlease mail your configuration file to <Peter.Anvin@linux.org>\n",
              program, config_file);
      }
#line 1072
      return (1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1087
  return (0);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 77 "/home/wheatley/newnew/temp/magicfilter-1.2/magicfilter.h"
int getoffset(char *p , char **endpos ) ;
#line 79
enum actions getaction(char *pos , char **cmd ) ;
#line 24 "/home/wheatley/newnew/temp/magicfilter-1.2/loadconfig.c"
static char *magic_getline(FILE *f , char *file , int *line ) 
{ 
  char *buf ;
  char *p ;
  int buflen ;
  int spc ;
  int ch ;
  int bslash ;
  int lineno ;
  void *tmp ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 28
  lineno = *line;
#line 30
  tmp = malloc((size_t )8192);
#line 30
  p = (char *)tmp;
#line 30
  buf = p;
  }
#line 31
  if (! buf) {
    {
#line 31
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 31
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
              file, lineno, "Out of memory");
#line 31
      fclose(f);
      }
#line 31
      return ((char *)((void *)0));
#line 31
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 32
  spc = 8192;
#line 32
  buflen = spc;
#line 34
  bslash = 0;
  {
#line 36
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 38
    if (! spc) {
      {
#line 40
      spc = (int )(p - buf);
#line 41
      buflen += 8192;
#line 41
      tmp___0 = realloc((void *)buf, (size_t )buflen);
#line 41
      buf = (char *)tmp___0;
      }
#line 41
      if (! buf) {
        {
#line 42
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 42
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                  file, lineno, "Out of memory");
#line 42
          fclose(f);
          }
#line 42
          return ((char *)((void *)0));
#line 42
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 43
      p = buf + spc;
#line 44
      spc = 8192;
    }
    {
#line 47
    ch = _IO_getc(f);
    }
#line 49
    if (ch == -1) {
#line 51
      if ((unsigned long )p == (unsigned long )buf) {
        {
#line 53
        free((void *)buf);
        }
#line 54
        return ((char *)((void *)0));
      } else {
#line 58
        bslash = 0;
#line 59
        ch = '\n';
      }
    }
#line 63
    if (ch == 10) {
#line 65
      lineno ++;
#line 67
      if (bslash) {
#line 69
        p --;
#line 70
        spc ++;
        {
#line 71
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 71
          tmp___1 = __ctype_b_loc();
#line 71
          ch = _IO_getc(f);
          }
#line 71
          if (! ((int const   )*(*tmp___1 + ch) & 8192)) {
#line 71
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 72
        ungetc(ch, f);
        }
      } else {
#line 76
        *p = (char )'\000';
#line 77
        *line = lineno;
#line 78
        return (buf);
      }
    } else {
#line 83
      bslash = ch == 92;
#line 84
      tmp___2 = p;
#line 84
      p ++;
#line 84
      *tmp___2 = (char )ch;
#line 85
      spc --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 101 "/home/wheatley/newnew/temp/magicfilter-1.2/loadconfig.c"
struct datatype *load_config(char *file , int *in_block_size ) 
{ 
  FILE *f ;
  struct datatype *head ;
  struct datatype **next ;
  struct datatype *new ;
  char *line ;
  char *p ;
  int lineno ;
  int bytes_needed ;
  int offset ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  enum actions tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 104
  head = (struct datatype *)((void *)0);
#line 105
  next = & head;
#line 108
  lineno = 0;
#line 109
  bytes_needed = 0;
#line 113
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 114
  if (! f) {
    {
#line 116
    perror((char const   *)file);
    }
#line 117
    return ((struct datatype *)((void *)0));
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    line = magic_getline(f, file, & lineno);
    }
#line 120
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 120
      goto while_break;
    }
    {
#line 122
    offset = getoffset(line, & p);
    }
#line 124
    if (offset == -1) {
      {
#line 124
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 124
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                file, lineno, "Syntax error");
#line 124
        fclose(f);
        }
#line 124
        return ((struct datatype *)((void *)0));
#line 124
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 126
    if (offset != -2) {
      {
#line 128
      tmp = malloc(sizeof(struct datatype ));
#line 128
      new = (struct datatype *)tmp;
      }
#line 129
      if (! new) {
        {
#line 129
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 129
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                  file, lineno, "Out of memory");
#line 129
          fclose(f);
          }
#line 129
          return ((struct datatype *)((void *)0));
#line 129
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 131
      if (offset == -3) {
#line 133
        tmp___0 = 0;
#line 133
        new->length = tmp___0;
#line 133
        new->offset = tmp___0;
#line 134
        tmp___1 = (char *)"";
#line 134
        new->mask = tmp___1;
#line 134
        new->magic = tmp___1;
      } else {
        {
#line 138
        i = getmagic(p, (char **)((void *)0), (char *)((void *)0), (char *)((void *)0));
        }
#line 139
        if (i < 0) {
          {
#line 139
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 139
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                    file, lineno, "Syntax error");
#line 139
            fclose(f);
            }
#line 139
            return ((struct datatype *)((void *)0));
#line 139
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 140
        new->offset = offset;
#line 141
        new->length = i;
#line 142
        tmp___2 = malloc((size_t )i);
#line 142
        new->magic = (char *)tmp___2;
#line 143
        tmp___3 = malloc((size_t )i);
#line 143
        new->mask = (char *)tmp___3;
        }
#line 144
        if (new->magic) {
#line 144
          if (! new->mask) {
#line 144
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 144
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 144
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                    file, lineno, "Out of memory");
#line 144
            fclose(f);
            }
#line 144
            return ((struct datatype *)((void *)0));
#line 144
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 145
        if (offset + i > bytes_needed) {
#line 146
          bytes_needed = offset + i;
        }
        {
#line 150
        getmagic(p, & p, new->magic, new->mask);
        }
      }
      {
#line 153
      tmp___5 = getaction(p, & p);
#line 153
      tmp___4 = (int )tmp___5;
#line 153
      new->action = tmp___4;
      }
#line 153
      if (tmp___4 < 0) {
        {
#line 154
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 154
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                  file, lineno, "Invalid action");
#line 154
          fclose(f);
          }
#line 154
          return ((struct datatype *)((void *)0));
#line 154
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 156
      tmp___8 = strlen((char const   *)p);
#line 156
      i = (int )tmp___8;
      }
#line 156
      if (i > 0) {
        {
#line 158
        tmp___7 = malloc((size_t )(i + 1));
#line 158
        tmp___6 = (char *)tmp___7;
#line 158
        new->command = tmp___6;
        }
#line 158
        if (! tmp___6) {
          {
#line 159
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 159
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                    file, lineno, "Out of memory");
#line 159
            fclose(f);
            }
#line 159
            return ((struct datatype *)((void *)0));
#line 159
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
        {
#line 160
        strcpy((char */* __restrict  */)new->command, (char const   */* __restrict  */)p);
        }
      } else {
#line 163
        new->command = (char *)"";
      }
#line 166
      new->next = (struct datatype *)((void *)0);
#line 167
      *next = new;
#line 168
      next = & new->next;
    }
    {
#line 188
    free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  fclose(f);
  }
#line 193
  if (in_block_size) {
#line 193
    *in_block_size = bytes_needed;
  }
#line 195
  return (head);
}
}
#line 23 "/home/wheatley/newnew/temp/magicfilter-1.2/parseconfig.c"
int getoffset(char *p , char **endpos ) 
{ 
  int offset ;
  enum __anonenum_state_26 state ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 25
  offset = 0;
#line 26
  state = (enum __anonenum_state_26 )0;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 32
    tmp = __ctype_b_loc();
    }
#line 32
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 32
      goto while_break;
    }
#line 32
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 34
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 34
    if (! ((unsigned int )state != 5U)) {
#line 34
      goto while_break___0;
    }
    {
#line 38
    if ((unsigned int )state == 0U) {
#line 38
      goto case_0;
    }
#line 96
    if ((unsigned int )state == 1U) {
#line 96
      goto case_1;
    }
#line 105
    if ((unsigned int )state == 2U) {
#line 105
      goto case_2;
    }
#line 117
    if ((unsigned int )state == 3U) {
#line 117
      goto case_3;
    }
#line 129
    if ((unsigned int )state == 4U) {
#line 129
      goto case_4;
    }
#line 149
    if ((unsigned int )state == 5U) {
#line 149
      goto case_5;
    }
#line 36
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 47
    if ((int )*p == 32) {
#line 47
      goto case_32;
    }
#line 47
    if ((int )*p == 13) {
#line 47
      goto case_32;
    }
#line 47
    if ((int )*p == 12) {
#line 47
      goto case_32;
    }
#line 47
    if ((int )*p == 11) {
#line 47
      goto case_32;
    }
#line 47
    if ((int )*p == 10) {
#line 47
      goto case_32;
    }
#line 47
    if ((int )*p == 9) {
#line 47
      goto case_32;
    }
#line 47
    if ((int )*p == 8) {
#line 47
      goto case_32;
    }
#line 52
    if ((int )*p == 0) {
#line 52
      goto case_0___0;
    }
#line 52
    if ((int )*p == 35) {
#line 52
      goto case_0___0;
    }
#line 57
    if ((int )*p == 48) {
#line 57
      goto case_48;
    }
#line 70
    if ((int )*p == 57) {
#line 70
      goto case_57;
    }
#line 70
    if ((int )*p == 56) {
#line 70
      goto case_57;
    }
#line 70
    if ((int )*p == 55) {
#line 70
      goto case_57;
    }
#line 70
    if ((int )*p == 54) {
#line 70
      goto case_57;
    }
#line 70
    if ((int )*p == 53) {
#line 70
      goto case_57;
    }
#line 70
    if ((int )*p == 52) {
#line 70
      goto case_57;
    }
#line 70
    if ((int )*p == 51) {
#line 70
      goto case_57;
    }
#line 70
    if ((int )*p == 50) {
#line 70
      goto case_57;
    }
#line 70
    if ((int )*p == 49) {
#line 70
      goto case_57;
    }
#line 76
    if ((int )*p == 100) {
#line 76
      goto case_100;
    }
#line 89
    goto switch_default;
    case_32: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 48
    p ++;
#line 49
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 53
    offset = -2;
#line 54
    state = (enum __anonenum_state_26 )5;
#line 55
    goto switch_break___0;
    case_48: /* CIL Label */ 
#line 58
    state = (enum __anonenum_state_26 )1;
#line 59
    p ++;
#line 60
    goto switch_break___0;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 71
    offset = (int )*p - 48;
#line 72
    state = (enum __anonenum_state_26 )3;
#line 73
    p ++;
#line 74
    goto switch_break___0;
    case_100: /* CIL Label */ 
    {
#line 77
    tmp___0 = strncmp((char const   *)p, "default", (size_t )7);
    }
#line 77
    if (tmp___0) {
#line 79
      offset = -1;
    } else {
#line 83
      p += 7;
#line 84
      offset = -3;
    }
#line 86
    state = (enum __anonenum_state_26 )5;
#line 87
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 90
    offset = -1;
#line 91
    state = (enum __anonenum_state_26 )5;
#line 92
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 94
    goto switch_break;
    case_1: /* CIL Label */ 
#line 97
    if ((int )*p == 120) {
#line 99
      state = (enum __anonenum_state_26 )4;
#line 100
      p ++;
#line 101
      goto switch_break;
    } else
#line 97
    if ((int )*p == 88) {
#line 99
      state = (enum __anonenum_state_26 )4;
#line 100
      p ++;
#line 101
      goto switch_break;
    }
    case_2: /* CIL Label */ 
#line 106
    if ((int )*p < 48) {
#line 108
      state = (enum __anonenum_state_26 )5;
    } else
#line 106
    if ((int )*p > 55) {
#line 108
      state = (enum __anonenum_state_26 )5;
    } else {
#line 112
      offset <<= 3;
#line 113
      tmp___1 = p;
#line 113
      p ++;
#line 113
      offset += (int )*tmp___1 - 48;
    }
#line 115
    goto switch_break;
    case_3: /* CIL Label */ 
#line 118
    if ((int )*p < 48) {
#line 120
      state = (enum __anonenum_state_26 )5;
    } else
#line 118
    if ((int )*p > 57) {
#line 120
      state = (enum __anonenum_state_26 )5;
    } else {
#line 124
      offset *= 10;
#line 125
      tmp___2 = p;
#line 125
      p ++;
#line 125
      offset += (int )*tmp___2 - 48;
    }
#line 127
    goto switch_break;
    case_4: /* CIL Label */ 
#line 130
    if ((int )*p >= 48) {
#line 130
      if ((int )*p <= 57) {
#line 132
        offset <<= 4;
#line 133
        tmp___3 = p;
#line 133
        p ++;
#line 133
        offset += (int )*tmp___3 - 48;
      } else {
#line 130
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 135
    if ((int )*p >= 65) {
#line 135
      if ((int )*p <= 70) {
#line 137
        offset <<= 4;
#line 138
        tmp___4 = p;
#line 138
        p ++;
#line 138
        offset += ((int )*tmp___4 - 65) + 10;
      } else {
#line 135
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 140
    if ((int )*p >= 97) {
#line 140
      if ((int )*p <= 102) {
#line 142
        offset <<= 4;
#line 143
        tmp___5 = p;
#line 143
        p ++;
#line 143
        offset += ((int )*tmp___5 - 97) + 10;
      } else {
#line 147
        state = (enum __anonenum_state_26 )5;
      }
    } else {
#line 147
      state = (enum __anonenum_state_26 )5;
    }
    case_5: /* CIL Label */ 
#line 150
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 154
  if (endpos) {
#line 155
    *endpos = p;
  }
#line 157
  return (offset);
}
}
#line 176 "/home/wheatley/newnew/temp/magicfilter-1.2/parseconfig.c"
char NO_WILD[1]  = {      (char )'\000'};
#line 178 "/home/wheatley/newnew/temp/magicfilter-1.2/parseconfig.c"
int getmagic(char *p , char **endpos , char *magic , char *mask ) 
{ 
  int count ;
  int quote ;
  int ch ;
  int wildcards ;
  enum __anonenum_state_27 state ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 180
  count = 0;
#line 181
  quote = 0;
#line 182
  ch = '\000';
#line 183
  wildcards = 1;
#line 184
  state = (enum __anonenum_state_27 )0;
#line 190
  if ((unsigned long )mask == (unsigned long )(NO_WILD)) {
#line 192
    mask = (char *)((void *)0);
#line 193
    wildcards = 0;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    tmp = __ctype_b_loc();
    }
#line 196
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 196
      goto while_break;
    }
#line 196
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! ((unsigned int )state != 4U)) {
#line 198
      goto while_break___0;
    }
    {
#line 202
    if ((unsigned int )state == 0U) {
#line 202
      goto case_0;
    }
#line 243
    if ((unsigned int )state == 1U) {
#line 243
      goto case_1;
    }
#line 313
    if ((unsigned int )state == 2U) {
#line 313
      goto case_2;
    }
#line 328
    if ((unsigned int )state == 3U) {
#line 328
      goto case_3;
    }
#line 352
    if ((unsigned int )state == 4U) {
#line 352
      goto case_4;
    }
#line 200
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 208
    if ((int )*p == 0) {
#line 208
      goto case_0___0;
    }
#line 208
    if ((int )*p == 12) {
#line 208
      goto case_0___0;
    }
#line 208
    if ((int )*p == 13) {
#line 208
      goto case_0___0;
    }
#line 208
    if ((int )*p == 10) {
#line 208
      goto case_0___0;
    }
#line 214
    if ((int )*p == 92) {
#line 214
      goto case_92;
    }
#line 219
    if ((int )*p == 34) {
#line 219
      goto case_34;
    }
#line 227
    if ((int )*p == 32) {
#line 227
      goto case_32;
    }
#line 227
    if ((int )*p == 11) {
#line 227
      goto case_32;
    }
#line 227
    if ((int )*p == 9) {
#line 227
      goto case_32;
    }
#line 227
    if ((int )*p == 8) {
#line 227
      goto case_32;
    }
#line 235
    goto switch_default;
    case_0___0: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 209
    if (quote) {
#line 210
      count = -1;
    }
#line 211
    state = (enum __anonenum_state_27 )4;
#line 212
    goto switch_break___0;
    case_92: /* CIL Label */ 
#line 215
    p ++;
#line 216
    state = (enum __anonenum_state_27 )1;
#line 217
    goto switch_break___0;
    case_34: /* CIL Label */ 
#line 220
    p ++;
#line 221
    quote = ! quote;
#line 222
    goto switch_break___0;
    case_32: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 228
    if (! quote) {
#line 230
      state = (enum __anonenum_state_27 )4;
#line 231
      goto switch_break___0;
    }
    switch_default: /* CIL Label */ 
#line 236
    if (magic) {
#line 236
      tmp___0 = magic;
#line 236
      magic ++;
#line 236
      *tmp___0 = *p;
    }
#line 237
    if (mask) {
#line 237
      tmp___1 = mask;
#line 237
      mask ++;
#line 237
      *tmp___1 = (char)-1;
    }
#line 238
    p ++;
#line 238
    count ++;
#line 239
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 241
    goto switch_break;
    case_1: /* CIL Label */ 
#line 244
    ch = -1;
    {
#line 247
    if ((int )*p == 97) {
#line 247
      goto case_97;
    }
#line 250
    if ((int )*p == 98) {
#line 250
      goto case_98;
    }
#line 253
    if ((int )*p == 101) {
#line 253
      goto case_101;
    }
#line 256
    if ((int )*p == 102) {
#line 256
      goto case_102;
    }
#line 259
    if ((int )*p == 110) {
#line 259
      goto case_110;
    }
#line 262
    if ((int )*p == 114) {
#line 262
      goto case_114;
    }
#line 265
    if ((int )*p == 116) {
#line 265
      goto case_116;
    }
#line 268
    if ((int )*p == 118) {
#line 268
      goto case_118;
    }
#line 272
    if ((int )*p == 88) {
#line 272
      goto case_88;
    }
#line 272
    if ((int )*p == 120) {
#line 272
      goto case_88;
    }
#line 283
    if ((int )*p == 55) {
#line 283
      goto case_55;
    }
#line 283
    if ((int )*p == 54) {
#line 283
      goto case_55;
    }
#line 283
    if ((int )*p == 53) {
#line 283
      goto case_55;
    }
#line 283
    if ((int )*p == 52) {
#line 283
      goto case_55;
    }
#line 283
    if ((int )*p == 51) {
#line 283
      goto case_55;
    }
#line 283
    if ((int )*p == 50) {
#line 283
      goto case_55;
    }
#line 283
    if ((int )*p == 49) {
#line 283
      goto case_55;
    }
#line 283
    if ((int )*p == 48) {
#line 283
      goto case_55;
    }
#line 287
    if ((int )*p == 63) {
#line 287
      goto case_63;
    }
#line 297
    goto switch_default___0;
    case_97: /* CIL Label */ 
#line 248
    ch = 7;
#line 249
    goto switch_break___1;
    case_98: /* CIL Label */ 
#line 251
    ch = '\b';
#line 252
    goto switch_break___1;
    case_101: /* CIL Label */ 
#line 254
    ch = 27;
#line 255
    goto switch_break___1;
    case_102: /* CIL Label */ 
#line 257
    ch = '\f';
#line 258
    goto switch_break___1;
    case_110: /* CIL Label */ 
#line 260
    ch = '\n';
#line 261
    goto switch_break___1;
    case_114: /* CIL Label */ 
#line 263
    ch = '\r';
#line 264
    goto switch_break___1;
    case_116: /* CIL Label */ 
#line 266
    ch = '\t';
#line 267
    goto switch_break___1;
    case_118: /* CIL Label */ 
#line 269
    ch = '\v';
#line 270
    goto switch_break___1;
    case_88: /* CIL Label */ 
    case_120: /* CIL Label */ 
#line 273
    state = (enum __anonenum_state_27 )3;
#line 274
    ch = 0;
#line 275
    goto switch_break___1;
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 284
    state = (enum __anonenum_state_27 )2;
#line 285
    ch = (int )*p - 48;
#line 286
    goto switch_break___1;
    case_63: /* CIL Label */ 
#line 288
    if (wildcards) {
#line 290
      if (magic) {
#line 290
        tmp___2 = magic;
#line 290
        magic ++;
#line 290
        *tmp___2 = (char)0;
      }
#line 291
      if (mask) {
#line 291
        tmp___3 = mask;
#line 291
        mask ++;
#line 291
        *tmp___3 = (char)0;
      }
#line 292
      count ++;
#line 293
      state = (enum __anonenum_state_27 )0;
#line 294
      goto switch_break___1;
    }
    switch_default___0: /* CIL Label */ 
#line 298
    ch = (int )*p;
#line 299
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 302
    p ++;
#line 304
    if ((unsigned int )state == 1U) {
#line 306
      if (magic) {
#line 306
        tmp___4 = magic;
#line 306
        magic ++;
#line 306
        *tmp___4 = (char )ch;
      }
#line 307
      if (mask) {
#line 307
        tmp___5 = mask;
#line 307
        mask ++;
#line 307
        *tmp___5 = (char)-1;
      }
#line 308
      count ++;
#line 309
      state = (enum __anonenum_state_27 )0;
    }
#line 311
    goto switch_break;
    case_2: /* CIL Label */ 
#line 314
    if ((int )*p >= 48) {
#line 314
      if ((int )*p <= 55) {
#line 316
        ch <<= 3;
#line 317
        tmp___6 = p;
#line 317
        p ++;
#line 317
        ch += (int )*tmp___6 - 48;
      } else {
#line 314
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 321
      if (magic) {
#line 321
        tmp___7 = magic;
#line 321
        magic ++;
#line 321
        *tmp___7 = (char )ch;
      }
#line 322
      if (mask) {
#line 322
        tmp___8 = mask;
#line 322
        mask ++;
#line 322
        *tmp___8 = (char)-1;
      }
#line 323
      count ++;
#line 324
      state = (enum __anonenum_state_27 )0;
    }
#line 326
    goto switch_break;
    case_3: /* CIL Label */ 
#line 329
    if ((int )*p >= 48) {
#line 329
      if ((int )*p <= 57) {
#line 331
        ch <<= 4;
#line 332
        tmp___9 = p;
#line 332
        p ++;
#line 332
        ch += (int )*tmp___9 - 48;
      } else {
#line 329
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 334
    if ((int )*p >= 65) {
#line 334
      if ((int )*p <= 70) {
#line 336
        ch <<= 4;
#line 337
        tmp___10 = p;
#line 337
        p ++;
#line 337
        ch += ((int )*tmp___10 - 65) + 10;
      } else {
#line 334
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 339
    if ((int )*p >= 97) {
#line 339
      if ((int )*p <= 102) {
#line 341
        ch <<= 4;
#line 342
        tmp___11 = p;
#line 342
        p ++;
#line 342
        ch += ((int )*tmp___11 - 97) + 10;
      } else {
#line 339
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 346
      if (magic) {
#line 346
        tmp___12 = magic;
#line 346
        magic ++;
#line 346
        *tmp___12 = (char )ch;
      }
#line 347
      if (mask) {
#line 347
        tmp___13 = mask;
#line 347
        mask ++;
#line 347
        *tmp___13 = (char)-1;
      }
#line 348
      count ++;
#line 349
      state = (enum __anonenum_state_27 )0;
    }
#line 351
    goto switch_break;
    case_4: /* CIL Label */ 
#line 353
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 357
  if (endpos) {
#line 357
    *endpos = p;
  }
#line 358
  return (count);
}
}
#line 386 "/home/wheatley/newnew/temp/magicfilter-1.2/parseconfig.c"
static char *act_strs[10]  = 
#line 386
  {      (char *)"cat",      (char *)"ignore",      (char *)"reject",      (char *)"filter", 
        (char *)"pipe",      (char *)"text",      (char *)"postscript",      (char *)"ffilter", 
        (char *)"fpipe",      (char *)((void *)0)};
#line 383 "/home/wheatley/newnew/temp/magicfilter-1.2/parseconfig.c"
enum actions getaction(char *pos , char **cmd ) 
{ 
  enum actions act ;
  char **act_str ;
  int i ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 396
    tmp = __ctype_b_loc();
    }
#line 396
    if (! ((int const   )*(*tmp + (int )*pos) & 8192)) {
#line 396
      goto while_break;
    }
#line 396
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  if (! *pos) {
#line 399
    return ((enum actions )-1);
  }
#line 401
  act = (enum actions )0;
#line 401
  act_str = act_strs;
  {
#line 401
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 401
    if (! *act_str) {
#line 401
      goto while_break___0;
    }
    {
#line 402
    tmp___0 = strlen((char const   *)*act_str);
#line 402
    i = (int )tmp___0;
#line 402
    tmp___1 = strncmp((char const   *)pos, (char const   *)*act_str, (size_t )i);
    }
#line 402
    if (tmp___1 == 0) {
#line 404
      pos += i;
#line 405
      goto while_break___0;
    }
#line 401
    act = (enum actions )((int )act + 1);
#line 401
    act_str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 408
  if (! *act_str) {
#line 413
    return ((enum actions )-1);
  }
#line 416
  if (*pos) {
    {
#line 416
    tmp___2 = __ctype_b_loc();
    }
#line 416
    if (! ((int const   )*(*tmp___2 + (int )*pos) & 8192)) {
#line 421
      return ((enum actions )-1);
    }
  }
#line 424
  if (cmd) {
    {
#line 426
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 426
      tmp___3 = __ctype_b_loc();
      }
#line 426
      if (! ((int const   )*(*tmp___3 + (int )*pos) & 8192)) {
#line 426
        goto while_break___1;
      }
#line 426
      pos ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 427
    *cmd = pos;
  }
#line 430
  return (act);
}
}
