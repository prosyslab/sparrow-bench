/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.h"
enum ap_Has_arg {
    ap_no = 0,
    ap_yes = 1,
    ap_maybe = 2
} ;
#line 59 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.h"
struct ap_Option {
   int code ;
   char const   *name ;
   enum ap_Has_arg has_arg ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.h"
struct ap_Record {
   int code ;
   char *argument ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.h"
struct Arg_parser {
   struct ap_Record *data ;
   char *error ;
   int data_size ;
   int error_size ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
enum Bool {
    false = 0,
    true = 1
} ;
#line 23 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
typedef enum Bool bool;
#line 36 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
struct line {
   struct line *q_forw ;
   struct line *q_back ;
   long pos ;
   int len ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
typedef struct line line_t;
#line 46
enum __anonenum_type_29 {
    UADD = 0,
    UDEL = 1,
    UMOV = 2,
    VMOV = 3
} ;
#line 46 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
struct __anonstruct_undo_t_28 {
   enum __anonenum_type_29 type ;
   line_t *head ;
   line_t *tail ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
typedef struct __anonstruct_undo_t_28 undo_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_3 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_3 __sigset_t;
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 360 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
enum Sflags {
    SGG = 1,
    SGP = 2,
    SGR = 4,
    SGF = 8
} ;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_15 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_15 regmatch_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 49 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_6 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_7 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_8 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_9 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_10 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_11 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_12 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_5 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_6 _kill ;
   struct __anonstruct__timer_7 _timer ;
   struct __anonstruct__rt_8 _rt ;
   struct __anonstruct__sigchld_9 _sigchld ;
   struct __anonstruct__sigfault_10 _sigfault ;
   struct __anonstruct__sigpoll_11 _sigpoll ;
   struct __anonstruct__sigsys_12 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_4 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_5 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_4 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_24 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_24 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.h"
char ap_init(struct Arg_parser * const  ap , int const   argc , char const   * const  *argv ,
             struct ap_Option  const  *options , char const   in_order ) ;
#line 87
void ap_free(struct Arg_parser * const  ap ) ;
#line 89
char const   *ap_error(struct Arg_parser  const  * const  ap ) ;
#line 92
int ap_arguments(struct Arg_parser  const  * const  ap ) ;
#line 96
int ap_code(struct Arg_parser  const  * const  ap , int const   i ) ;
#line 98
char const   *ap_argument(struct Arg_parser  const  * const  ap , int const   i ) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
bool init_buffers(void) ;
#line 109
int read_file(char const   * const  filename , int const   addr ) ;
#line 114
bool is_regular_file(int const   fd ) ;
#line 115
bool may_access_filename(char const   * const  name ) ;
#line 116
bool restricted(void) ;
#line 117
bool scripted(void) ;
#line 118
void show_strerror(char const   * const  filename , int const   errcode ) ;
#line 119
bool traditional(void) ;
#line 122
int main_loop(bool const   loose ) ;
#line 123
void set_def_filename(char const   * const  s ) ;
#line 124
void set_error_msg(char const   *msg ) ;
#line 125
void set_prompt(char const   * const  s ) ;
#line 126
void set_verbose(void) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static char const   * const  Program_name  =    (char const   */* const  */)"GNU Ed";
#line 47 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static char const   * const  program_name  =    (char const   */* const  */)"ed";
#line 48 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static char const   * const  program_year  =    (char const   */* const  */)"2013";
#line 49 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static char const   *invocation_name  =    (char const   *)0;
#line 51 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static bool restricted_  =    (bool )0;
#line 52 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static bool scripted_  =    (bool )0;
#line 53 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static bool traditional_  =    (bool )0;
#line 56 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
bool restricted(void) 
{ 


  {
#line 56
  return (restricted_);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
bool scripted(void) 
{ 


  {
#line 57
  return (scripted_);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
bool traditional(void) 
{ 


  {
#line 58
  return (traditional_);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static void show_help(void) 
{ 


  {
  {
#line 63
  printf((char const   */* __restrict  */)"%s - The GNU line editor.\n", Program_name);
#line 64
  printf((char const   */* __restrict  */)"\nUsage: %s [options] [file]\n", invocation_name);
#line 65
  printf((char const   */* __restrict  */)"\nOptions:\n  -h, --help                 display this help and exit\n  -V, --version              output version information and exit\n  -G, --traditional          run in compatibility mode\n  -l, --loose-exit-status    exit with 0 status even if a command fails\n  -p, --prompt=STRING        use STRING as an interactive prompt\n  -r, --restricted           run in restricted mode\n  -s, --quiet, --silent      suppress diagnostics\n  -v, --verbose              be verbose\nStart edit by reading in \'file\' if given.\nIf \'file\' begins with a \'!\', read output of shell command.\n\nExit status: 0 for a normal exit, 1 for environmental problems (file\nnot found, invalid flags, I/O errors, etc), 2 to indicate a corrupt or\ninvalid input file, 3 for an internal consistency error (eg, bug) which\ncaused ed to panic.\n\nReport bugs to <bug-ed@gnu.org>.\nEd home page: http://www.gnu.org/software/ed/ed.html\nGeneral help using GNU software: http://www.gnu.org/gethelp\n");
  }
#line 83
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static void show_version(void) 
{ 


  {
  {
#line 88
  printf((char const   */* __restrict  */)"%s %s\n", Program_name, "1.9");
#line 89
  printf((char const   */* __restrict  */)"Copyright (C) 1994 Andrew L. Moore.\nCopyright (C) %s Free Software Foundation, Inc.\n",
         program_year);
#line 91
  printf((char const   */* __restrict  */)"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n");
  }
#line 94
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
void show_strerror(char const   * const  filename , int const   errcode ) 
{ 
  char *tmp ;

  {
#line 99
  if (! scripted_) {
#line 101
    if (filename) {
#line 101
      if ((int const   )*(filename + 0) != 0) {
        {
#line 102
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                filename);
        }
      }
    }
    {
#line 103
    tmp = strerror((int )errcode);
#line 103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            tmp);
    }
  }
#line 105
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
static void show_error(char const   * const  msg , int const   errcode , bool const   help ) 
{ 
  char *tmp ;

  {
#line 110
  if (msg) {
#line 110
    if (*(msg + 0)) {
      {
#line 112
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s",
              program_name, msg);
      }
#line 113
      if (errcode > 0) {
        {
#line 113
        tmp = strerror((int )errcode);
#line 113
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
                tmp);
        }
      }
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 116
  if (help) {
    {
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
            invocation_name);
    }
  }
#line 119
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
bool is_regular_file(int const   fd ) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 126
  tmp = fstat((int )fd, & st);
  }
#line 126
  if (tmp != 0) {
#line 126
    tmp___0 = 1;
  } else
#line 126
  if ((st.st_mode & 61440U) == 32768U) {
#line 126
    tmp___0 = 1;
  } else {
#line 126
    tmp___0 = 0;
  }
#line 126
  return ((bool )tmp___0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
bool may_access_filename(char const   * const  name ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 132
  if (restricted_) {
#line 132
    if ((int const   )*name == 33) {
      {
#line 135
      set_error_msg("Shell access restricted");
      }
#line 136
      return ((bool )0);
    } else {
      {
#line 132
      tmp = strcmp((char const   *)name, "..");
      }
#line 132
      if (tmp) {
        {
#line 132
        tmp___0 = strchr((char const   *)name, '/');
        }
#line 132
        if (tmp___0) {
          {
#line 135
          set_error_msg("Shell access restricted");
          }
#line 136
          return ((bool )0);
        }
      } else {
        {
#line 135
        set_error_msg("Shell access restricted");
        }
#line 136
        return ((bool )0);
      }
    }
  }
#line 138
  return ((bool )1);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main.c"
int main(int const   argc , char const   * const  *argv ) 
{ 
  int argind ;
  bool loose ;
  struct ap_Option options[10] ;
  struct Arg_parser parser ;
  char tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int code ;
  int tmp___2 ;
  char const   *arg ;
  char const   *tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  char const   *arg___0 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 145
  loose = (bool )0;
#line 146
  options[0].code = 'G';
#line 146
  options[0].name = "traditional";
#line 146
  options[0].has_arg = (enum ap_Has_arg )0;
#line 146
  options[1].code = 'h';
#line 146
  options[1].name = "help";
#line 146
  options[1].has_arg = (enum ap_Has_arg )0;
#line 146
  options[2].code = 'l';
#line 146
  options[2].name = "loose-exit-status";
#line 146
  options[2].has_arg = (enum ap_Has_arg )0;
#line 146
  options[3].code = 'p';
#line 146
  options[3].name = "prompt";
#line 146
  options[3].has_arg = (enum ap_Has_arg )1;
#line 146
  options[4].code = 'r';
#line 146
  options[4].name = "restricted";
#line 146
  options[4].has_arg = (enum ap_Has_arg )0;
#line 146
  options[5].code = 's';
#line 146
  options[5].name = "quiet";
#line 146
  options[5].has_arg = (enum ap_Has_arg )0;
#line 146
  options[6].code = 's';
#line 146
  options[6].name = "silent";
#line 146
  options[6].has_arg = (enum ap_Has_arg )0;
#line 146
  options[7].code = 'v';
#line 146
  options[7].name = "verbose";
#line 146
  options[7].has_arg = (enum ap_Has_arg )0;
#line 146
  options[8].code = 'V';
#line 146
  options[8].name = "version";
#line 146
  options[8].has_arg = (enum ap_Has_arg )0;
#line 146
  options[9].code = 0;
#line 146
  options[9].name = (char const   *)0;
#line 146
  options[9].has_arg = (enum ap_Has_arg )0;
#line 160
  invocation_name = (char const   *)*(argv + 0);
#line 162
  tmp = ap_init((struct Arg_parser */* const  */)(& parser), argc, argv, (struct ap_Option  const  *)(options),
                (char const   )0);
  }
#line 162
  if (! tmp) {
    {
#line 163
    show_error((char const   */* const  */)"Memory exhausted.", (int const   )0, (bool const   )0);
    }
#line 163
    return (1);
  }
  {
#line 164
  tmp___1 = ap_error((struct Arg_parser  const  */* const  */)(& parser));
  }
#line 164
  if (tmp___1) {
    {
#line 165
    tmp___0 = ap_error((struct Arg_parser  const  */* const  */)(& parser));
#line 165
    show_error((char const   */* const  */)tmp___0, (int const   )0, (bool const   )1);
    }
#line 165
    return (1);
  }
#line 167
  argind = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    tmp___4 = ap_arguments((struct Arg_parser  const  */* const  */)(& parser));
    }
#line 167
    if (! (argind < tmp___4)) {
#line 167
      goto while_break;
    }
    {
#line 169
    tmp___2 = ap_code((struct Arg_parser  const  */* const  */)(& parser), (int const   )argind);
#line 169
    code = tmp___2;
#line 170
    tmp___3 = ap_argument((struct Arg_parser  const  */* const  */)(& parser), (int const   )argind);
#line 170
    arg = tmp___3;
    }
#line 171
    if (! code) {
#line 171
      goto while_break;
    }
    {
#line 174
    if (code == 71) {
#line 174
      goto case_71;
    }
#line 175
    if (code == 104) {
#line 175
      goto case_104;
    }
#line 176
    if (code == 108) {
#line 176
      goto case_108;
    }
#line 177
    if (code == 112) {
#line 177
      goto case_112;
    }
#line 178
    if (code == 114) {
#line 178
      goto case_114;
    }
#line 179
    if (code == 115) {
#line 179
      goto case_115;
    }
#line 180
    if (code == 118) {
#line 180
      goto case_118;
    }
#line 181
    if (code == 86) {
#line 181
      goto case_86;
    }
#line 182
    goto switch_default;
    case_71: /* CIL Label */ 
#line 174
    traditional_ = (bool )1;
#line 174
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 175
    show_help();
    }
#line 175
    return (0);
    case_108: /* CIL Label */ 
#line 176
    loose = (bool )1;
#line 176
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 177
    set_prompt((char const   */* const  */)arg);
    }
#line 177
    goto switch_break;
    case_114: /* CIL Label */ 
#line 178
    restricted_ = (bool )1;
#line 178
    goto switch_break;
    case_115: /* CIL Label */ 
#line 179
    scripted_ = (bool )1;
#line 179
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 180
    set_verbose();
    }
#line 180
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 181
    show_version();
    }
#line 181
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 182
    show_error((char const   */* const  */)"internal error: uncaught option.", (int const   )0,
               (bool const   )0);
    }
#line 183
    return (3);
    switch_break: /* CIL Label */ ;
    }
#line 167
    argind ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  setlocale(6, "");
#line 187
  tmp___5 = init_buffers();
  }
#line 187
  if (! tmp___5) {
#line 187
    return (1);
  }
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 189
    tmp___12 = ap_arguments((struct Arg_parser  const  */* const  */)(& parser));
    }
#line 189
    if (! (argind < tmp___12)) {
#line 189
      goto while_break___0;
    }
    {
#line 191
    tmp___6 = ap_argument((struct Arg_parser  const  */* const  */)(& parser), (int const   )argind);
#line 191
    arg___0 = tmp___6;
#line 192
    tmp___7 = strcmp(arg___0, "-");
    }
#line 192
    if (! tmp___7) {
#line 192
      scripted_ = (bool )1;
#line 192
      argind ++;
#line 192
      goto while_continue___0;
    }
    {
#line 193
    tmp___11 = may_access_filename((char const   */* const  */)arg___0);
    }
#line 193
    if (tmp___11) {
      {
#line 195
      tmp___8 = read_file((char const   */* const  */)arg___0, (int const   )0);
      }
#line 195
      if (tmp___8 < 0) {
        {
#line 195
        tmp___9 = is_regular_file((int const   )0);
        }
#line 195
        if (tmp___9) {
#line 196
          return (2);
        } else {
#line 195
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 197
      if ((int const   )*(arg___0 + 0) != 33) {
        {
#line 197
        set_def_filename((char const   */* const  */)arg___0);
        }
      }
    } else {
      {
#line 201
      fputs((char const   */* __restrict  */)"?\n", (FILE */* __restrict  */)stderr);
      }
#line 202
      if (*(arg___0 + 0)) {
        {
#line 202
        set_error_msg("Invalid filename");
        }
      }
      {
#line 203
      tmp___10 = is_regular_file((int const   )0);
      }
#line 203
      if (tmp___10) {
#line 203
        return (2);
      }
    }
#line 205
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 207
  ap_free((struct Arg_parser */* const  */)(& parser));
#line 209
  tmp___13 = main_loop((bool const   )loose);
  }
#line 209
  return (tmp___13);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 195
extern FILE *tmpfile(void) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 612 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                                                int __name ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
bool append_lines(char const   ** const  ibufpp , int const   addr , bool const   isglobal ) ;
#line 65
bool close_sbuf(void) ;
#line 66
bool copy_lines(int const   first_addr___0 , int const   second_addr___0 , int const   addr ) ;
#line 67
int current_addr(void) ;
#line 68
int dec_addr(int addr ) ;
#line 69
bool delete_lines(int const   from , int const   to , bool const   isglobal ) ;
#line 70
int get_line_node_addr(line_t const   * const  lp___0 ) ;
#line 71
char *get_sbuf_line(line_t const   * const  lp___0 ) ;
#line 72
int inc_addr(int addr ) ;
#line 73
int inc_current_addr(void) ;
#line 75
bool isbinary(void) ;
#line 76
bool join_lines(int const   from , int const   to , bool const   isglobal ) ;
#line 77
int last_addr(void) ;
#line 78
bool modified(void) ;
#line 79
bool move_lines(int const   first_addr___0 , int const   second_addr___0 , int const   addr ,
                bool const   isglobal ) ;
#line 81
bool newline_added(void) ;
#line 82
bool open_sbuf(void) ;
#line 83
int path_max(char const   *filename ) ;
#line 84
bool put_lines(int const   addr ) ;
#line 85
char const   *put_sbuf_line(char const   * const  buf___9 , int const   size , int const   addr ) ;
#line 87
line_t *search_line_node(int const   addr ) ;
#line 88
void set_binary(void) ;
#line 89
void set_current_addr(int const   addr ) ;
#line 90
void set_modified(bool const   m ) ;
#line 91
void set_newline_added(void) ;
#line 92
bool yank_lines(int const   from , int const   to ) ;
#line 93
void clear_undo_stack(void) ;
#line 94
undo_t *push_undo_atom(int const   type , int const   from , int const   to ) ;
#line 95
void reset_undo_state(void) ;
#line 96
bool undo(bool const   isglobal ) ;
#line 99
void clear_active_list(void) ;
#line 102
void unset_active_nodes(line_t const   *bp , line_t const   * const  ep ) ;
#line 108
char const   *get_tty_line(int * const  sizep ) ;
#line 127
void unmark_line_node(line_t const   * const  lp___0 ) ;
#line 141
void disable_interrupts(void) ;
#line 142
void enable_interrupts(void) ;
#line 144
bool resize_buffer(char ** const  buf___9 , int * const  size , int const   min_size ) ;
#line 147
bool resize_undo_buffer(undo_t ** const  buf___9 , int * const  size , int const   min_size ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static int current_addr_  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static int last_addr_  =    0;
#line 35 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static bool isbinary_  =    (bool )0;
#line 36 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static bool modified_  =    (bool )0;
#line 37 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static bool newline_added_  =    (bool )0;
#line 39 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static bool seek_write  =    (bool )0;
#line 40 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static FILE *sfp  =    (FILE *)0;
#line 41 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static long sfpos  =    0L;
#line 42 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static line_t buffer_head  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static line_t yank_buffer_head  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
int current_addr(void) 
{ 


  {
#line 46
  return (current_addr_);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
int inc_current_addr(void) 
{ 


  {
#line 48
  current_addr_ ++;
#line 48
  if (current_addr_ > last_addr_) {
#line 48
    current_addr_ = last_addr_;
  }
#line 49
  return (current_addr_);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
void set_current_addr(int const   addr ) 
{ 


  {
#line 50
  current_addr_ = (int )addr;
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
int last_addr(void) 
{ 


  {
#line 52
  return (last_addr_);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool isbinary(void) 
{ 


  {
#line 54
  return (isbinary_);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
void set_binary(void) 
{ 


  {
#line 55
  isbinary_ = (bool )1;
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool modified(void) 
{ 


  {
#line 57
  return (modified_);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
void set_modified(bool const   m ) 
{ 


  {
#line 58
  modified_ = (bool )m;
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool newline_added(void) 
{ 


  {
#line 60
  return (newline_added_);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
void set_newline_added(void) 
{ 


  {
#line 61
  newline_added_ = (bool )1;
#line 61
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
int inc_addr(int addr ) 
{ 


  {
#line 65
  addr ++;
#line 65
  if (addr > last_addr_) {
#line 65
    addr = 0;
  }
#line 65
  return (addr);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
int dec_addr(int addr ) 
{ 


  {
#line 68
  addr --;
#line 68
  if (addr < 0) {
#line 68
    addr = last_addr_;
  }
#line 68
  return (addr);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static void link_nodes(line_t * const  prev , line_t * const  next ) 
{ 


  {
#line 73
  prev->q_forw = (struct line *)next;
#line 73
  next->q_back = (struct line *)prev;
#line 73
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static void insert_node(line_t * const  lp___0 , line_t * const  prev ) 
{ 


  {
  {
#line 79
  link_nodes(lp___0, (line_t */* const  */)prev->q_forw);
#line 80
  link_nodes(prev, lp___0);
  }
#line 81
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static void add_line_node(line_t * const  lp___0 , int const   addr ) 
{ 
  line_t *prev ;
  line_t *tmp ;

  {
  {
#line 87
  tmp = search_line_node(addr);
#line 87
  prev = tmp;
#line 88
  insert_node(lp___0, (line_t */* const  */)prev);
#line 89
  last_addr_ ++;
  }
#line 90
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static line_t *dup_line_node(line_t * const  lp___0 ) 
{ 
  line_t *p ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 96
  tmp = malloc(sizeof(line_t ));
#line 96
  p = (line_t *)tmp;
  }
#line 97
  if (! p) {
    {
#line 99
    tmp___0 = __errno_location();
#line 99
    show_strerror((char const   */* const  */)0, (int const   )*tmp___0);
#line 100
    set_error_msg("Memory exhausted");
    }
#line 101
    return ((line_t *)0);
  }
#line 103
  if (lp___0) {
#line 103
    p->pos = lp___0->pos;
#line 103
    p->len = lp___0->len;
  }
#line 104
  return (p);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool append_lines(char const   ** const  ibufpp , int const   addr , bool const   isglobal ) 
{ 
  int size ;
  undo_t *up ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 114
  size = 0;
#line 115
  up = (undo_t *)0;
#line 116
  current_addr_ = (int )addr;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! isglobal) {
      {
#line 122
      *ibufpp = get_tty_line((int */* const  */)(& size));
      }
#line 123
      if (! *ibufpp) {
#line 123
        return ((bool )0);
      }
#line 124
      if (size == 0) {
        {
#line 125
        clearerr(stdin);
        }
#line 125
        return ((bool )(size == 0));
      } else
#line 124
      if ((int const   )*(*ibufpp + (size - 1)) != 10) {
        {
#line 125
        clearerr(stdin);
        }
#line 125
        return ((bool )(size == 0));
      }
    } else {
#line 129
      if (! *(*ibufpp)) {
#line 129
        return ((bool )1);
      }
#line 130
      size = 0;
      {
#line 130
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 130
        tmp = size;
#line 130
        size ++;
#line 130
        if (! ((int const   )*(*ibufpp + tmp) != 10)) {
#line 130
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 132
    if (size == 2) {
#line 132
      if ((int const   )*(*ibufpp) == 46) {
#line 132
        *ibufpp += size;
#line 132
        return ((bool )1);
      }
    }
    {
#line 133
    disable_interrupts();
#line 134
    tmp___0 = put_sbuf_line((char const   */* const  */)*ibufpp, (int const   )size,
                            (int const   )current_addr_);
    }
#line 134
    if (! tmp___0) {
      {
#line 135
      enable_interrupts();
      }
#line 135
      return ((bool )0);
    }
#line 136
    if (up) {
      {
#line 136
      up->tail = search_line_node((int const   )current_addr_);
      }
    } else {
      {
#line 139
      up = push_undo_atom((int const   )0, (int const   )current_addr_, (int const   )current_addr_);
      }
#line 140
      if (! up) {
        {
#line 140
        enable_interrupts();
        }
#line 140
        return ((bool )0);
      }
    }
    {
#line 142
    *ibufpp += size;
#line 143
    modified_ = (bool )1;
#line 144
    enable_interrupts();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static void clear_yank_buffer(void) 
{ 
  line_t *lp___0 ;
  line_t *p ;

  {
  {
#line 151
  lp___0 = yank_buffer_head.q_forw;
#line 153
  disable_interrupts();
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )lp___0 != (unsigned long )(& yank_buffer_head))) {
#line 154
      goto while_break;
    }
    {
#line 156
    p = lp___0->q_forw;
#line 157
    link_nodes((line_t */* const  */)lp___0->q_back, (line_t */* const  */)lp___0->q_forw);
#line 158
    free((void *)lp___0);
#line 159
    lp___0 = p;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  enable_interrupts();
  }
#line 162
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool close_sbuf(void) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 168
  clear_yank_buffer();
#line 169
  clear_undo_stack();
  }
#line 170
  if (sfp) {
    {
#line 172
    tmp___0 = fclose(sfp);
    }
#line 172
    if (tmp___0 != 0) {
      {
#line 174
      tmp = __errno_location();
#line 174
      show_strerror((char const   */* const  */)0, (int const   )*tmp);
#line 175
      set_error_msg("Cannot close temp file");
      }
#line 176
      return ((bool )0);
    }
#line 178
    sfp = (FILE *)0;
  }
#line 180
  sfpos = 0L;
#line 181
  seek_write = (bool )0;
#line 182
  return ((bool )1);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool copy_lines(int const   first_addr___0 , int const   second_addr___0 , int const   addr ) 
{ 
  line_t *lp___0 ;
  line_t *np ;
  line_t *tmp ;
  undo_t *up ;
  int n ;
  int m ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 189
  tmp = search_line_node(first_addr___0);
#line 189
  np = tmp;
#line 190
  up = (undo_t *)0;
#line 191
  n = (int )((second_addr___0 - first_addr___0) + 1);
#line 192
  m = 0;
#line 194
  current_addr_ = (int )addr;
  }
#line 195
  if (addr >= first_addr___0) {
#line 195
    if (addr < second_addr___0) {
#line 197
      n = (int )((addr - first_addr___0) + 1);
#line 198
      m = (int )(second_addr___0 - addr);
    }
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (n > 0)) {
#line 200
      goto while_break;
    }
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      tmp___1 = n;
#line 201
      n --;
#line 201
      if (! (tmp___1 > 0)) {
#line 201
        goto while_break___0;
      }
      {
#line 203
      disable_interrupts();
#line 204
      lp___0 = dup_line_node((line_t */* const  */)np);
      }
#line 205
      if (! lp___0) {
        {
#line 205
        enable_interrupts();
        }
#line 205
        return ((bool )0);
      }
      {
#line 206
      tmp___0 = current_addr_;
#line 206
      current_addr_ ++;
#line 206
      add_line_node((line_t */* const  */)lp___0, (int const   )tmp___0);
      }
#line 207
      if (up) {
#line 207
        up->tail = lp___0;
      } else {
        {
#line 210
        up = push_undo_atom((int const   )0, (int const   )current_addr_, (int const   )current_addr_);
        }
#line 211
        if (! up) {
          {
#line 211
          enable_interrupts();
          }
#line 211
          return ((bool )0);
        }
      }
      {
#line 213
      modified_ = (bool )1;
#line 214
      enable_interrupts();
#line 201
      np = np->q_forw;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 200
    n = m;
#line 200
    m = 0;
#line 200
    np = search_line_node((int const   )(current_addr_ + 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return ((bool )1);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool delete_lines(int const   from , int const   to , bool const   isglobal ) 
{ 
  line_t *n ;
  line_t *p ;
  bool tmp ;
  undo_t *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 225
  tmp = yank_lines(from, to);
  }
#line 225
  if (! tmp) {
#line 225
    return ((bool )0);
  }
  {
#line 226
  disable_interrupts();
#line 227
  tmp___0 = push_undo_atom((int const   )1, from, to);
  }
#line 227
  if (! tmp___0) {
    {
#line 228
    enable_interrupts();
    }
#line 228
    return ((bool )0);
  }
  {
#line 229
  tmp___1 = inc_addr((int )to);
#line 229
  n = search_line_node((int const   )tmp___1);
#line 230
  p = search_line_node(from - 1);
  }
#line 231
  if (isglobal) {
    {
#line 231
    unset_active_nodes((line_t const   *)p->q_forw, (line_t const   */* const  */)n);
    }
  }
  {
#line 232
  link_nodes((line_t */* const  */)p, (line_t */* const  */)n);
#line 233
  last_addr_ -= (int )((to - from) + 1);
#line 234
  current_addr_ = (int )(from - 1);
#line 235
  modified_ = (bool )1;
#line 236
  enable_interrupts();
  }
#line 237
  return ((bool )1);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
int get_line_node_addr(line_t const   * const  lp___0 ) 
{ 
  line_t const   *p ;
  int addr ;

  {
#line 244
  p = (line_t const   *)(& buffer_head);
#line 245
  addr = 0;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )p != (unsigned long )lp___0) {
#line 247
      p = (line_t const   *)p->q_forw;
#line 247
      if (! ((unsigned long )p != (unsigned long )(& buffer_head))) {
#line 247
        goto while_break;
      }
    } else {
#line 247
      goto while_break;
    }
#line 247
    addr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  if (addr) {
#line 248
    if ((unsigned long )p == (unsigned long )(& buffer_head)) {
      {
#line 249
      set_error_msg("Invalid address");
      }
#line 249
      return (-1);
    }
  }
#line 250
  return (addr);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static char *buf  =    (char *)0;
#line 258 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static int bufsz  =    0;
#line 255 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
char *get_sbuf_line(line_t const   * const  lp___0 ) 
{ 
  int len ;
  int *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;

  {
#line 261
  if ((unsigned long )lp___0 == (unsigned long )(& buffer_head)) {
#line 261
    return ((char *)0);
  }
#line 262
  seek_write = (bool )1;
#line 264
  if (sfpos != (long )lp___0->pos) {
    {
#line 266
    sfpos = (long )lp___0->pos;
#line 267
    tmp___0 = fseek(sfp, sfpos, 0);
    }
#line 267
    if (tmp___0 != 0) {
      {
#line 269
      tmp = __errno_location();
#line 269
      show_strerror((char const   */* const  */)0, (int const   )*tmp);
#line 270
      set_error_msg("Cannot seek temp file");
      }
#line 271
      return ((char *)0);
    }
  }
  {
#line 274
  len = (int )lp___0->len;
#line 275
  tmp___1 = resize_buffer((char **/* const  */)(& buf), (int */* const  */)(& bufsz),
                          (int const   )(len + 1));
  }
#line 275
  if (! tmp___1) {
#line 275
    return ((char *)0);
  }
  {
#line 276
  tmp___3 = fread((void */* __restrict  */)buf, (size_t )1, (size_t )len, (FILE */* __restrict  */)sfp);
  }
#line 276
  if ((int )tmp___3 != len) {
    {
#line 278
    tmp___2 = __errno_location();
#line 278
    show_strerror((char const   */* const  */)0, (int const   )*tmp___2);
#line 279
    set_error_msg("Cannot read temp file");
    }
#line 280
    return ((char *)0);
  }
#line 282
  sfpos += (long )len;
#line 283
  *(buf + len) = (char)0;
#line 284
  return (buf);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool init_buffers(void) 
{ 
  bool tmp ;

  {
  {
#line 297
  setvbuf((FILE */* __restrict  */)stdin, (char */* __restrict  */)0, 2, (size_t )0);
#line 298
  tmp = open_sbuf();
  }
#line 298
  if (! tmp) {
#line 298
    return ((bool )0);
  }
  {
#line 299
  link_nodes((line_t */* const  */)(& buffer_head), (line_t */* const  */)(& buffer_head));
#line 300
  link_nodes((line_t */* const  */)(& yank_buffer_head), (line_t */* const  */)(& yank_buffer_head));
  }
#line 301
  return ((bool )1);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static char *buf___0  =    (char *)0;
#line 309 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static int bufsz___0  =    0;
#line 306 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool join_lines(int const   from , int const   to , bool const   isglobal ) 
{ 
  int size ;
  line_t *ep ;
  int tmp ;
  line_t *tmp___0 ;
  line_t *bp ;
  line_t *tmp___1 ;
  char const   *s ;
  char *tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  char const   *tmp___6 ;
  undo_t *tmp___7 ;

  {
  {
#line 310
  size = 0;
#line 311
  tmp = inc_addr((int )to);
#line 311
  tmp___0 = search_line_node((int const   )tmp);
#line 311
  ep = tmp___0;
#line 312
  tmp___1 = search_line_node(from);
#line 312
  bp = tmp___1;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! ((unsigned long )bp != (unsigned long )ep)) {
#line 314
      goto while_break;
    }
    {
#line 316
    tmp___2 = get_sbuf_line((line_t const   */* const  */)bp);
#line 316
    s = (char const   *)tmp___2;
    }
#line 317
    if (! s) {
#line 317
      return ((bool )0);
    } else {
      {
#line 317
      tmp___3 = resize_buffer((char **/* const  */)(& buf___0), (int */* const  */)(& bufsz___0),
                              (int const   )(size + bp->len));
      }
#line 317
      if (! tmp___3) {
#line 317
        return ((bool )0);
      }
    }
    {
#line 318
    memcpy((void */* __restrict  */)(buf___0 + size), (void const   */* __restrict  */)s,
           (size_t )bp->len);
#line 319
    size += bp->len;
#line 320
    bp = bp->q_forw;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 322
  tmp___4 = resize_buffer((char **/* const  */)(& buf___0), (int */* const  */)(& bufsz___0),
                          (int const   )(size + 2));
  }
#line 322
  if (! tmp___4) {
#line 322
    return ((bool )0);
  }
  {
#line 323
  memcpy((void */* __restrict  */)(buf___0 + size), (void const   */* __restrict  */)"\n",
         (size_t )2);
#line 324
  size += 2;
#line 325
  tmp___5 = delete_lines(from, to, isglobal);
  }
#line 325
  if (! tmp___5) {
#line 325
    return ((bool )0);
  }
  {
#line 326
  current_addr_ = (int )(from - 1);
#line 327
  disable_interrupts();
#line 328
  tmp___6 = put_sbuf_line((char const   */* const  */)buf___0, (int const   )size,
                          (int const   )current_addr_);
  }
#line 328
  if (tmp___6) {
    {
#line 328
    tmp___7 = push_undo_atom((int const   )0, (int const   )current_addr_, (int const   )current_addr_);
    }
#line 328
    if (! tmp___7) {
      {
#line 330
      enable_interrupts();
      }
#line 330
      return ((bool )0);
    }
  } else {
    {
#line 330
    enable_interrupts();
    }
#line 330
    return ((bool )0);
  }
  {
#line 331
  modified_ = (bool )1;
#line 332
  enable_interrupts();
  }
#line 333
  return ((bool )1);
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool move_lines(int const   first_addr___0 , int const   second_addr___0 , int const   addr ,
                bool const   isglobal ) 
{ 
  line_t *b1 ;
  line_t *a1 ;
  line_t *b2 ;
  line_t *a2 ;
  int n ;
  int tmp ;
  int p ;
  int tmp___0 ;
  undo_t *tmp___1 ;
  int tmp___2 ;
  undo_t *tmp___3 ;

  {
  {
#line 342
  tmp = inc_addr((int )second_addr___0);
#line 342
  n = tmp;
#line 343
  p = (int )(first_addr___0 - 1);
#line 345
  disable_interrupts();
  }
#line 346
  if (addr == first_addr___0 - 1) {
    {
#line 348
    a2 = search_line_node((int const   )n);
#line 349
    b2 = search_line_node((int const   )p);
#line 350
    current_addr_ = (int )second_addr___0;
    }
  } else
#line 346
  if (addr == second_addr___0) {
    {
#line 348
    a2 = search_line_node((int const   )n);
#line 349
    b2 = search_line_node((int const   )p);
#line 350
    current_addr_ = (int )second_addr___0;
    }
  } else {
    {
#line 352
    tmp___1 = push_undo_atom((int const   )2, (int const   )p, (int const   )n);
    }
#line 352
    if (tmp___1) {
      {
#line 352
      tmp___2 = inc_addr((int )addr);
#line 352
      tmp___3 = push_undo_atom((int const   )2, addr, (int const   )tmp___2);
      }
#line 352
      if (tmp___3) {
        {
#line 357
        a1 = search_line_node((int const   )n);
        }
#line 358
        if (addr < first_addr___0) {
          {
#line 360
          b1 = search_line_node((int const   )p);
#line 361
          b2 = search_line_node(addr);
          }
        } else {
          {
#line 365
          b2 = search_line_node(addr);
#line 366
          b1 = search_line_node((int const   )p);
          }
        }
        {
#line 368
        a2 = b2->q_forw;
#line 369
        link_nodes((line_t */* const  */)b2, (line_t */* const  */)b1->q_forw);
#line 370
        link_nodes((line_t */* const  */)a1->q_back, (line_t */* const  */)a2);
#line 371
        link_nodes((line_t */* const  */)b1, (line_t */* const  */)a1);
        }
#line 372
        if (addr < first_addr___0) {
#line 372
          tmp___0 = (second_addr___0 - first_addr___0) + 1;
        } else {
#line 372
          tmp___0 = (int const   )0;
        }
#line 372
        current_addr_ = (int )(addr + tmp___0);
      } else {
        {
#line 354
        enable_interrupts();
        }
#line 354
        return ((bool )0);
      }
    } else {
      {
#line 354
      enable_interrupts();
      }
#line 354
      return ((bool )0);
    }
  }
#line 375
  if (isglobal) {
    {
#line 375
    unset_active_nodes((line_t const   *)b2->q_forw, (line_t const   */* const  */)a2);
    }
  }
  {
#line 376
  modified_ = (bool )1;
#line 377
  enable_interrupts();
  }
#line 378
  return ((bool )1);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool open_sbuf(void) 
{ 
  int *tmp ;

  {
  {
#line 385
  newline_added_ = (bool )0;
#line 385
  isbinary_ = newline_added_;
#line 386
  sfp = tmpfile();
  }
#line 387
  if (! sfp) {
    {
#line 389
    tmp = __errno_location();
#line 389
    show_strerror((char const   */* const  */)0, (int const   )*tmp);
#line 390
    set_error_msg("Cannot open temp file");
    }
#line 391
    return ((bool )0);
  }
#line 393
  return ((bool )1);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
int path_max(char const   *filename ) 
{ 
  long result ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 400
  if (! filename) {
#line 400
    filename = "/";
  }
  {
#line 401
  tmp = __errno_location();
#line 401
  *tmp = 0;
#line 402
  result = pathconf(filename, 4);
  }
#line 403
  if (result < 0L) {
    {
#line 403
    tmp___0 = __errno_location();
    }
#line 403
    if (*tmp___0) {
#line 403
      result = 256L;
    } else {
#line 403
      result = 1024L;
    }
  } else
#line 404
  if (result < 256L) {
#line 404
    result = 256L;
  }
#line 405
  return ((int )result);
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool put_lines(int const   addr ) 
{ 
  undo_t *up ;
  line_t *p ;
  line_t *lp___0 ;
  int tmp ;

  {
#line 412
  up = (undo_t *)0;
#line 413
  lp___0 = yank_buffer_head.q_forw;
#line 415
  if ((unsigned long )lp___0 == (unsigned long )(& yank_buffer_head)) {
    {
#line 416
    set_error_msg("Nothing to put");
    }
#line 416
    return ((bool )0);
  }
#line 417
  current_addr_ = (int )addr;
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! ((unsigned long )lp___0 != (unsigned long )(& yank_buffer_head))) {
#line 418
      goto while_break;
    }
    {
#line 420
    disable_interrupts();
#line 421
    p = dup_line_node((line_t */* const  */)lp___0);
    }
#line 422
    if (! p) {
      {
#line 422
      enable_interrupts();
      }
#line 422
      return ((bool )0);
    }
    {
#line 423
    tmp = current_addr_;
#line 423
    current_addr_ ++;
#line 423
    add_line_node((line_t */* const  */)p, (int const   )tmp);
    }
#line 424
    if (up) {
#line 424
      up->tail = p;
    } else {
      {
#line 427
      up = push_undo_atom((int const   )0, (int const   )current_addr_, (int const   )current_addr_);
      }
#line 428
      if (! up) {
        {
#line 428
        enable_interrupts();
        }
#line 428
        return ((bool )0);
      }
    }
    {
#line 430
    modified_ = (bool )1;
#line 431
    lp___0 = lp___0->q_forw;
#line 432
    enable_interrupts();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return ((bool )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
char const   *put_sbuf_line(char const   * const  buf___9 , int const   size , int const   addr ) 
{ 
  line_t *lp___0 ;
  line_t *tmp ;
  char const   *p ;
  void *tmp___0 ;
  int len ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 443
  tmp = dup_line_node((line_t */* const  */)0);
#line 443
  lp___0 = tmp;
#line 444
  tmp___0 = memchr((void const   *)buf___9, '\n', (size_t )size);
#line 444
  p = (char const   *)tmp___0;
  }
#line 447
  if (! lp___0) {
#line 447
    return ((char const   *)0);
  }
#line 448
  if (! p) {
    {
#line 448
    set_error_msg("Line too long");
    }
#line 448
    return ((char const   *)0);
  }
#line 449
  len = (int )(p - (char const   *)buf___9);
#line 451
  if (seek_write) {
    {
#line 453
    tmp___2 = fseek(sfp, 0L, 2);
    }
#line 453
    if (tmp___2 != 0) {
      {
#line 455
      tmp___1 = __errno_location();
#line 455
      show_strerror((char const   */* const  */)0, (int const   )*tmp___1);
#line 456
      set_error_msg("Cannot seek temp file");
      }
#line 457
      return ((char const   *)0);
    }
    {
#line 459
    sfpos = ftell(sfp);
#line 460
    seek_write = (bool )0;
    }
  }
  {
#line 462
  tmp___4 = fwrite((void const   */* __restrict  */)buf___9, (size_t )1, (size_t )len,
                   (FILE */* __restrict  */)sfp);
  }
#line 462
  if ((int )tmp___4 != len) {
    {
#line 464
    sfpos = -1L;
#line 465
    tmp___3 = __errno_location();
#line 465
    show_strerror((char const   */* const  */)0, (int const   )*tmp___3);
#line 466
    set_error_msg("Cannot write temp file");
    }
#line 467
    return ((char const   *)0);
  }
  {
#line 469
  lp___0->pos = sfpos;
#line 469
  lp___0->len = len;
#line 470
  add_line_node((line_t */* const  */)lp___0, addr);
#line 471
  current_addr_ ++;
#line 472
  sfpos += (long )len;
  }
#line 473
  return (p + 1);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static line_t *lp  =    & buffer_head;
#line 481 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static int o_addr  =    0;
#line 478 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
line_t *search_line_node(int const   addr ) 
{ 


  {
  {
#line 483
  disable_interrupts();
  }
#line 484
  if (o_addr < (int )addr) {
#line 486
    if (o_addr + last_addr_ >= 2 * (int )addr) {
      {
#line 487
      while (1) {
        while_continue: /* CIL Label */ ;
#line 487
        if (! (o_addr < (int )addr)) {
#line 487
          goto while_break;
        }
#line 487
        o_addr ++;
#line 487
        lp = lp->q_forw;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 490
      lp = buffer_head.q_back;
#line 490
      o_addr = last_addr_;
      {
#line 491
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 491
        if (! (o_addr > (int )addr)) {
#line 491
          goto while_break___0;
        }
#line 491
        o_addr --;
#line 491
        lp = lp->q_back;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 494
  if (o_addr <= 2 * (int )addr) {
    {
#line 495
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 495
      if (! (o_addr > (int )addr)) {
#line 495
        goto while_break___1;
      }
#line 495
      o_addr --;
#line 495
      lp = lp->q_back;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 497
    lp = & buffer_head;
#line 497
    o_addr = 0;
    {
#line 498
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 498
      if (! (o_addr < (int )addr)) {
#line 498
        goto while_break___2;
      }
#line 498
      o_addr ++;
#line 498
      lp = lp->q_forw;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 499
  enable_interrupts();
  }
#line 500
  return (lp);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool yank_lines(int const   from , int const   to ) 
{ 
  line_t *ep ;
  int tmp ;
  line_t *tmp___0 ;
  line_t *bp ;
  line_t *tmp___1 ;
  line_t *lp___0 ;
  line_t *p ;

  {
  {
#line 507
  tmp = inc_addr((int )to);
#line 507
  tmp___0 = search_line_node((int const   )tmp);
#line 507
  ep = tmp___0;
#line 508
  tmp___1 = search_line_node(from);
#line 508
  bp = tmp___1;
#line 509
  lp___0 = & yank_buffer_head;
#line 512
  clear_yank_buffer();
  }
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! ((unsigned long )bp != (unsigned long )ep)) {
#line 513
      goto while_break;
    }
    {
#line 515
    disable_interrupts();
#line 516
    p = dup_line_node((line_t */* const  */)bp);
    }
#line 517
    if (! p) {
      {
#line 517
      enable_interrupts();
      }
#line 517
      return ((bool )0);
    }
    {
#line 518
    insert_node((line_t */* const  */)p, (line_t */* const  */)lp___0);
#line 519
    bp = bp->q_forw;
#line 519
    lp___0 = p;
#line 520
    enable_interrupts();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((bool )1);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static undo_t *ustack  =    (undo_t *)0;
#line 527 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static int usize  =    0;
#line 528 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static int u_ptr  =    0;
#line 529 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static int u_current_addr  =    -1;
#line 530 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static int u_last_addr  =    -1;
#line 531 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
static bool u_modified  =    (bool )0;
#line 534 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
void clear_undo_stack(void) 
{ 
  line_t *ep ;
  line_t *bp ;
  line_t *lp___0 ;
  int tmp ;

  {
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    tmp = u_ptr;
#line 536
    u_ptr --;
#line 536
    if (! tmp) {
#line 536
      goto while_break;
    }
#line 537
    if ((unsigned int )(ustack + u_ptr)->type == 1U) {
#line 539
      ep = ((ustack + u_ptr)->tail)->q_forw;
#line 540
      bp = (ustack + u_ptr)->head;
      {
#line 541
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 541
        if (! ((unsigned long )bp != (unsigned long )ep)) {
#line 541
          goto while_break___0;
        }
        {
#line 543
        lp___0 = bp->q_forw;
#line 544
        unmark_line_node((line_t const   */* const  */)bp);
#line 545
        free((void *)bp);
#line 546
        bp = lp___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  u_ptr = 0;
#line 550
  u_current_addr = current_addr_;
#line 551
  u_last_addr = last_addr_;
#line 552
  u_modified = modified_;
#line 553
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
void reset_undo_state(void) 
{ 


  {
  {
#line 558
  clear_undo_stack();
#line 559
  u_last_addr = -1;
#line 559
  u_current_addr = u_last_addr;
#line 560
  u_modified = (bool )0;
  }
#line 561
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
undo_t *push_undo_atom(int const   type , int const   from , int const   to ) 
{ 
  int *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 567
  disable_interrupts();
#line 568
  tmp___0 = resize_undo_buffer((undo_t **/* const  */)(& ustack), (int */* const  */)(& usize),
                               (int const   )((unsigned long )(u_ptr + 1) * sizeof(undo_t )));
  }
#line 568
  if (! tmp___0) {
    {
#line 570
    tmp = __errno_location();
#line 570
    show_strerror((char const   */* const  */)0, (int const   )*tmp);
#line 571
    set_error_msg("Memory exhausted");
    }
#line 572
    if (ustack) {
      {
#line 574
      clear_undo_stack();
#line 575
      free((void *)ustack);
#line 576
      ustack = (undo_t *)0;
#line 577
      u_ptr = 0;
#line 577
      usize = u_ptr;
#line 578
      u_last_addr = -1;
#line 578
      u_current_addr = u_last_addr;
      }
    }
    {
#line 580
    enable_interrupts();
    }
#line 581
    return ((undo_t *)0);
  }
  {
#line 583
  enable_interrupts();
#line 584
  (ustack + u_ptr)->type = (enum __anonenum_type_29 )type;
#line 585
  (ustack + u_ptr)->tail = search_line_node(to);
#line 586
  (ustack + u_ptr)->head = search_line_node(from);
#line 587
  tmp___1 = u_ptr;
#line 587
  u_ptr ++;
  }
#line 587
  return (ustack + tmp___1);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/ed-1.9/buffer.c"
bool undo(bool const   isglobal ) 
{ 
  int n ;
  int o_current_addr ;
  int o_last_addr ;
  bool o_modified ;
  undo_t tmp ;

  {
#line 595
  o_current_addr = current_addr_;
#line 596
  o_last_addr = last_addr_;
#line 597
  o_modified = modified_;
#line 599
  if (u_ptr <= 0) {
    {
#line 600
    set_error_msg("Nothing to undo");
    }
#line 600
    return ((bool )0);
  } else
#line 599
  if (u_current_addr < 0) {
    {
#line 600
    set_error_msg("Nothing to undo");
    }
#line 600
    return ((bool )0);
  } else
#line 599
  if (u_last_addr < 0) {
    {
#line 600
    set_error_msg("Nothing to undo");
    }
#line 600
    return ((bool )0);
  }
  {
#line 601
  search_line_node((int const   )0);
#line 602
  disable_interrupts();
#line 603
  n = u_ptr - 1;
  }
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (n >= 0)) {
#line 603
      goto while_break;
    }
    {
#line 607
    if ((unsigned int )(ustack + n)->type == 0U) {
#line 607
      goto case_0;
    }
#line 609
    if ((unsigned int )(ustack + n)->type == 1U) {
#line 609
      goto case_1;
    }
#line 613
    if ((unsigned int )(ustack + n)->type == 3U) {
#line 613
      goto case_3;
    }
#line 613
    if ((unsigned int )(ustack + n)->type == 2U) {
#line 613
      goto case_3;
    }
#line 605
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 607
    link_nodes((line_t */* const  */)((ustack + n)->head)->q_back, (line_t */* const  */)((ustack + n)->tail)->q_forw);
    }
#line 608
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 609
    link_nodes((line_t */* const  */)((ustack + n)->head)->q_back, (line_t */* const  */)(ustack + n)->head);
#line 610
    link_nodes((line_t */* const  */)(ustack + n)->tail, (line_t */* const  */)((ustack + n)->tail)->q_forw);
    }
#line 611
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 613
    link_nodes((line_t */* const  */)(ustack + (n - 1))->head, (line_t */* const  */)((ustack + n)->head)->q_forw);
#line 614
    link_nodes((line_t */* const  */)((ustack + n)->tail)->q_back, (line_t */* const  */)(ustack + (n - 1))->tail);
#line 615
    link_nodes((line_t */* const  */)(ustack + n)->head, (line_t */* const  */)(ustack + n)->tail);
#line 615
    n --;
    }
#line 616
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 618
    (ustack + n)->type = (enum __anonenum_type_29 )((unsigned int )(ustack + n)->type ^ 1U);
#line 603
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  n = 0;
  {
#line 621
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 621
    if (! (2 * n < u_ptr - 1)) {
#line 621
      goto while_break___0;
    }
#line 623
    tmp = *(ustack + n);
#line 624
    *(ustack + n) = *(ustack + ((u_ptr - 1) - n));
#line 624
    *(ustack + ((u_ptr - 1) - n)) = tmp;
#line 621
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 626
  if (isglobal) {
    {
#line 626
    clear_active_list();
    }
  }
  {
#line 627
  current_addr_ = u_current_addr;
#line 627
  u_current_addr = o_current_addr;
#line 628
  last_addr_ = u_last_addr;
#line 628
  u_last_addr = o_last_addr;
#line 629
  modified_ = u_modified;
#line 629
  u_modified = o_modified;
#line 630
  enable_interrupts();
  }
#line 631
  return ((bool )1);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
static void *ap_resize_buffer(void *buf___9 , int const   min_size ) 
{ 


  {
#line 38
  if (buf___9) {
    {
#line 38
    buf___9 = realloc(buf___9, (size_t )min_size);
    }
  } else {
    {
#line 39
    buf___9 = malloc((size_t )min_size);
    }
  }
#line 40
  return (buf___9);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
static char push_back_record(struct Arg_parser * const  ap , int const   code , char const   * const  argument ) 
{ 
  int len ;
  size_t tmp ;
  struct ap_Record *p ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 47
  tmp = strlen((char const   *)argument);
#line 47
  len = (int )tmp;
#line 49
  tmp___1 = ap_resize_buffer((void *)ap->data, (int const   )((unsigned long )(ap->data_size + 1) * sizeof(struct ap_Record )));
#line 49
  tmp___0 = tmp___1;
  }
#line 51
  if (! tmp___0) {
#line 51
    return ((char)0);
  }
  {
#line 52
  ap->data = (struct ap_Record *)tmp___0;
#line 53
  p = ap->data + ap->data_size;
#line 54
  p->code = (int )code;
#line 55
  p->argument = (char *)0;
#line 56
  tmp___0 = ap_resize_buffer((void *)p->argument, (int const   )(len + 1));
  }
#line 57
  if (! tmp___0) {
#line 57
    return ((char)0);
  }
  {
#line 58
  p->argument = (char *)tmp___0;
#line 59
  strncpy((char */* __restrict  */)p->argument, (char const   */* __restrict  */)argument,
          (size_t )(len + 1));
#line 60
  (ap->data_size) ++;
  }
#line 61
  return ((char)1);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
static char add_error(struct Arg_parser * const  ap , char const   * const  msg ) 
{ 
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 67
  tmp = strlen((char const   *)msg);
#line 67
  len = (int )tmp;
#line 68
  tmp___1 = ap_resize_buffer((void *)ap->error, (int const   )((ap->error_size + len) + 1));
#line 68
  tmp___0 = tmp___1;
  }
#line 69
  if (! tmp___0) {
#line 69
    return ((char)0);
  }
  {
#line 70
  ap->error = (char *)tmp___0;
#line 71
  strncpy((char */* __restrict  */)(ap->error + ap->error_size), (char const   */* __restrict  */)msg,
          (size_t )(len + 1));
#line 72
  ap->error_size += len;
  }
#line 73
  return ((char)1);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
static void free_data(struct Arg_parser * const  ap ) 
{ 
  int i ;

  {
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < ap->data_size)) {
#line 80
      goto while_break;
    }
    {
#line 80
    free((void *)(ap->data + i)->argument);
#line 80
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (ap->data) {
    {
#line 81
    free((void *)ap->data);
#line 81
    ap->data = (struct ap_Record *)0;
    }
  }
#line 82
  ap->data_size = 0;
#line 83
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
static char parse_long_option(struct Arg_parser * const  ap , char const   * const  opt ,
                              char const   * const  arg , struct ap_Option  const  *options ,
                              int * const  argindp ) 
{ 
  unsigned int len ;
  int index___0 ;
  int i ;
  char exact ;
  char ambig ;
  size_t tmp ;
  int tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;

  {
#line 92
  index___0 = -1;
#line 93
  exact = (char)0;
#line 93
  ambig = (char)0;
#line 95
  len = 0U;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (*(opt + (len + 2U))) {
#line 95
      if (! ((int const   )*(opt + (len + 2U)) != 61)) {
#line 95
        goto while_break;
      }
    } else {
#line 95
      goto while_break;
    }
#line 95
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 98
    if (! ((options + i)->code != 0)) {
#line 98
      goto while_break___0;
    }
#line 99
    if ((options + i)->name) {
      {
#line 99
      tmp___0 = strncmp((char const   *)(options + i)->name, opt + 2, (size_t )len);
      }
#line 99
      if (tmp___0 == 0) {
        {
#line 101
        tmp = strlen((char const   *)(options + i)->name);
        }
#line 101
        if (tmp == (size_t )len) {
#line 102
          index___0 = i;
#line 102
          exact = (char)1;
#line 102
          goto while_break___0;
        } else
#line 103
        if (index___0 < 0) {
#line 103
          index___0 = i;
        } else
#line 104
        if ((options + index___0)->code != (options + i)->code) {
#line 106
          ambig = (char)1;
        } else
#line 104
        if ((unsigned int const   )(options + index___0)->has_arg != (unsigned int const   )(options + i)->has_arg) {
#line 106
          ambig = (char)1;
        }
      }
    }
#line 98
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ambig) {
#line 109
    if (! exact) {
      {
#line 111
      add_error(ap, (char const   */* const  */)"option \'");
#line 111
      add_error(ap, opt);
#line 112
      add_error(ap, (char const   */* const  */)"\' is ambiguous");
      }
#line 113
      return ((char)1);
    }
  }
#line 116
  if (index___0 < 0) {
    {
#line 118
    add_error(ap, (char const   */* const  */)"unrecognized option \'");
#line 118
    add_error(ap, opt);
#line 119
    add_error(ap, (char const   */* const  */)"\'");
    }
#line 120
    return ((char)1);
  }
#line 123
  (*argindp) ++;
#line 125
  if (*(opt + (len + 2U))) {
#line 127
    if ((unsigned int const   )(options + index___0)->has_arg == 0U) {
      {
#line 129
      add_error(ap, (char const   */* const  */)"option \'--");
#line 129
      add_error(ap, (options + index___0)->name);
#line 130
      add_error(ap, (char const   */* const  */)"\' doesn\'t allow an argument");
      }
#line 131
      return ((char)1);
    }
#line 133
    if ((unsigned int const   )(options + index___0)->has_arg == 1U) {
#line 133
      if (! *(opt + (len + 3U))) {
        {
#line 135
        add_error(ap, (char const   */* const  */)"option \'--");
#line 135
        add_error(ap, (options + index___0)->name);
#line 136
        add_error(ap, (char const   */* const  */)"\' requires an argument");
        }
#line 137
        return ((char)1);
      }
    }
    {
#line 139
    tmp___1 = push_back_record(ap, (options + index___0)->code, (char const   */* const  */)(opt + (len + 3U)));
    }
#line 139
    return (tmp___1);
  }
#line 142
  if ((unsigned int const   )(options + index___0)->has_arg == 1U) {
#line 144
    if (! arg) {
      {
#line 146
      add_error(ap, (char const   */* const  */)"option \'--");
#line 146
      add_error(ap, (options + index___0)->name);
#line 147
      add_error(ap, (char const   */* const  */)"\' requires an argument");
      }
#line 148
      return ((char)1);
    } else
#line 144
    if (! *(arg + 0)) {
      {
#line 146
      add_error(ap, (char const   */* const  */)"option \'--");
#line 146
      add_error(ap, (options + index___0)->name);
#line 147
      add_error(ap, (char const   */* const  */)"\' requires an argument");
      }
#line 148
      return ((char)1);
    }
    {
#line 150
    (*argindp) ++;
#line 151
    tmp___2 = push_back_record(ap, (options + index___0)->code, arg);
    }
#line 151
    return (tmp___2);
  }
  {
#line 154
  tmp___3 = push_back_record(ap, (options + index___0)->code, (char const   */* const  */)"");
  }
#line 154
  return (tmp___3);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
static char parse_short_option(struct Arg_parser * const  ap , char const   * const  opt ,
                               char const   * const  arg , struct ap_Option  const  *options ,
                               int * const  argindp ) 
{ 
  int cind ;
  int index___0 ;
  int i ;
  unsigned char code ;
  char code_str[2] ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;

  {
#line 163
  cind = 1;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (cind > 0)) {
#line 165
      goto while_break;
    }
#line 167
    index___0 = -1;
#line 168
    code = (unsigned char )*(opt + cind);
#line 170
    code_str[0] = (char )code;
#line 170
    code_str[1] = (char)0;
#line 172
    if ((int )code != 0) {
#line 173
      i = 0;
      {
#line 173
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 173
        if (! (options + i)->code) {
#line 173
          goto while_break___0;
        }
#line 174
        if ((int )code == (int )(options + i)->code) {
#line 175
          index___0 = i;
#line 175
          goto while_break___0;
        }
#line 173
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 177
    if (index___0 < 0) {
      {
#line 179
      add_error(ap, (char const   */* const  */)"invalid option -- ");
#line 179
      add_error(ap, (char const   */* const  */)(code_str));
      }
#line 180
      return ((char)1);
    }
#line 183
    cind ++;
#line 183
    if ((int const   )*(opt + cind) == 0) {
#line 183
      (*argindp) ++;
#line 183
      cind = 0;
    }
#line 185
    if ((unsigned int const   )(options + index___0)->has_arg != 0U) {
#line 185
      if (cind > 0) {
#line 185
        if (*(opt + cind)) {
          {
#line 187
          tmp = push_back_record(ap, (int const   )code, (char const   */* const  */)(opt + cind));
          }
#line 187
          if (! tmp) {
#line 187
            return ((char)0);
          }
#line 188
          (*argindp) ++;
#line 188
          cind = 0;
        } else {
#line 185
          goto _L___0;
        }
      } else {
#line 185
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 190
    if ((unsigned int const   )(options + index___0)->has_arg == 1U) {
#line 192
      if (! arg) {
        {
#line 194
        add_error(ap, (char const   */* const  */)"option requires an argument -- ");
#line 195
        add_error(ap, (char const   */* const  */)(code_str));
        }
#line 196
        return ((char)1);
      } else
#line 192
      if (! *(arg + 0)) {
        {
#line 194
        add_error(ap, (char const   */* const  */)"option requires an argument -- ");
#line 195
        add_error(ap, (char const   */* const  */)(code_str));
        }
#line 196
        return ((char)1);
      }
      {
#line 198
      (*argindp) ++;
#line 198
      cind = 0;
#line 199
      tmp___0 = push_back_record(ap, (int const   )code, arg);
      }
#line 199
      if (! tmp___0) {
#line 199
        return ((char)0);
      }
    } else {
      {
#line 201
      tmp___1 = push_back_record(ap, (int const   )code, (char const   */* const  */)"");
      }
#line 201
      if (! tmp___1) {
#line 201
        return ((char)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return ((char)1);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
char ap_init(struct Arg_parser * const  ap , int const   argc , char const   * const  *argv ,
             struct ap_Option  const  *options , char const   in_order ) 
{ 
  char const   **non_options ;
  int non_options_size ;
  int argind ;
  int i ;
  unsigned char ch1 ;
  unsigned char ch2 ;
  int tmp ;
  char const   *opt ;
  char const   *arg ;
  char const   *tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char tmp___8 ;
  char tmp___9 ;
  int tmp___10 ;
  char tmp___11 ;

  {
#line 211
  non_options = (char const   **)0;
#line 212
  non_options_size = 0;
#line 213
  argind = 1;
#line 216
  ap->data = (struct ap_Record *)0;
#line 217
  ap->error = (char *)0;
#line 218
  ap->data_size = 0;
#line 219
  ap->error_size = 0;
#line 220
  if (argc < 2) {
#line 220
    return ((char)1);
  } else
#line 220
  if (! argv) {
#line 220
    return ((char)1);
  } else
#line 220
  if (! options) {
#line 220
    return ((char)1);
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (argind < (int )argc)) {
#line 222
      goto while_break;
    }
#line 224
    ch1 = (unsigned char )*(*(argv + argind) + 0);
#line 225
    if (ch1) {
#line 225
      tmp = (int const   )*(*(argv + argind) + 1);
    } else {
#line 225
      tmp = (int const   )0;
    }
#line 225
    ch2 = (unsigned char )tmp;
#line 227
    if ((int )ch1 == 45) {
#line 227
      if (ch2) {
#line 229
        opt = (char const   *)*(argv + argind);
#line 230
        if (argind + 1 < (int )argc) {
#line 230
          tmp___0 = *(argv + (argind + 1));
        } else {
#line 230
          tmp___0 = (char const   */* const  */)0;
        }
#line 230
        arg = (char const   *)tmp___0;
#line 231
        if ((int )ch2 == 45) {
#line 233
          if (! *(*(argv + argind) + 2)) {
#line 233
            argind ++;
#line 233
            goto while_break;
          } else {
            {
#line 234
            tmp___1 = parse_long_option(ap, (char const   */* const  */)opt, (char const   */* const  */)arg,
                                        options, (int */* const  */)(& argind));
            }
#line 234
            if (! tmp___1) {
#line 234
              return ((char)0);
            }
          }
        } else {
          {
#line 236
          tmp___2 = parse_short_option(ap, (char const   */* const  */)opt, (char const   */* const  */)arg,
                                       options, (int */* const  */)(& argind));
          }
#line 236
          if (! tmp___2) {
#line 236
            return ((char)0);
          }
        }
#line 237
        if (ap->error) {
#line 237
          goto while_break;
        }
      } else {
#line 227
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 241
    if (! in_order) {
      {
#line 243
      tmp___4 = ap_resize_buffer((void *)non_options, (int const   )((unsigned long )(non_options_size + 1) * sizeof(*non_options)));
#line 243
      tmp___3 = tmp___4;
      }
#line 245
      if (! tmp___3) {
#line 245
        return ((char)0);
      }
#line 246
      non_options = (char const   **)tmp___3;
#line 247
      tmp___5 = non_options_size;
#line 247
      non_options_size ++;
#line 247
      tmp___6 = argind;
#line 247
      argind ++;
#line 247
      *(non_options + tmp___5) = (char const   *)*(argv + tmp___6);
    } else {
      {
#line 249
      tmp___7 = argind;
#line 249
      argind ++;
#line 249
      tmp___8 = push_back_record(ap, (int const   )0, *(argv + tmp___7));
      }
#line 249
      if (! tmp___8) {
#line 249
        return ((char)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  if (ap->error) {
    {
#line 252
    free_data(ap);
    }
  } else {
#line 255
    i = 0;
    {
#line 255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 255
      if (! (i < non_options_size)) {
#line 255
        goto while_break___0;
      }
      {
#line 256
      tmp___9 = push_back_record(ap, (int const   )0, (char const   */* const  */)*(non_options + i));
      }
#line 256
      if (! tmp___9) {
#line 256
        return ((char)0);
      }
#line 255
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 257
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 257
      if (! (argind < (int )argc)) {
#line 257
        goto while_break___1;
      }
      {
#line 258
      tmp___10 = argind;
#line 258
      argind ++;
#line 258
      tmp___11 = push_back_record(ap, (int const   )0, *(argv + tmp___10));
      }
#line 258
      if (! tmp___11) {
#line 258
        return ((char)0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 260
  if (non_options) {
    {
#line 260
    free((void *)non_options);
    }
  }
#line 261
  return ((char)1);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
void ap_free(struct Arg_parser * const  ap ) 
{ 


  {
  {
#line 267
  free_data(ap);
  }
#line 268
  if (ap->error) {
    {
#line 268
    free((void *)ap->error);
#line 268
    ap->error = (char *)0;
    }
  }
#line 269
  ap->error_size = 0;
#line 270
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
char const   *ap_error(struct Arg_parser  const  * const  ap ) 
{ 


  {
#line 274
  return ((char const   *)ap->error);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
int ap_arguments(struct Arg_parser  const  * const  ap ) 
{ 


  {
#line 278
  return ((int )ap->data_size);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
int ap_code(struct Arg_parser  const  * const  ap , int const   i ) 
{ 
  int tmp ;

  {
#line 283
  if (i >= 0) {
    {
#line 283
    tmp = ap_arguments(ap);
    }
#line 283
    if (i < (int const   )tmp) {
#line 283
      return ((ap->data + i)->code);
    } else {
#line 284
      return (0);
    }
  } else {
#line 284
    return (0);
  }
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/ed-1.9/carg_parser.c"
char const   *ap_argument(struct Arg_parser  const  * const  ap , int const   i ) 
{ 
  int tmp ;

  {
#line 290
  if (i >= 0) {
    {
#line 290
    tmp = ap_arguments(ap);
    }
#line 290
    if (i < (int const   )tmp) {
#line 290
      return ((char const   *)(ap->data + i)->argument);
    } else {
#line 291
      return ("");
    }
  } else {
#line 291
    return ("");
  }
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
line_t const   *next_active_node(void) ;
#line 105
bool display_lines(int from , int const   to , int const   gflags___0 ) ;
#line 106
bool get_extended_line(char const   ** const  ibufpp , int * const  lenp , bool const   strip_escaped_newlines ) ;
#line 110
int write_file(char const   * const  filename , char const   * const  mode , int const   from ,
               int const   to ) ;
#line 130
bool build_active_list(char const   ** const  ibufpp , int const   first_addr___0 ,
                       int const   second_addr___0 , bool const   match ) ;
#line 132
bool extract_subst_tail(char const   ** const  ibufpp , int * const  gflagsp , int * const  snump ,
                        bool const   isglobal ) ;
#line 134
int next_matching_node_addr(char const   ** const  ibufpp , bool const   forward ) ;
#line 135
bool new_compiled_pattern(char const   ** const  ibufpp ) ;
#line 136
bool prev_pattern(void) ;
#line 137
bool search_and_replace(int const   first_addr___0 , int const   second_addr___0 ,
                        int const   gflags___0 , int const   snum___0 , bool const   isglobal ) ;
#line 143
bool parse_int(int * const  i , char const   * const  str , char const   ** const  tail ) ;
#line 149
void set_signals(void) ;
#line 150
void set_window_lines(int const   lines ) ;
#line 151
char const   *strip_escapes(char const   *p ) ;
#line 153
int window_lines(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char def_filename[1024]  = {      (char )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char errmsg[80]  = {      (char )'\000'};
#line 33 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char prompt_str[80]  = {      (char )'*',      (char )'\000'};
#line 34 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int first_addr  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int second_addr  =    0;
#line 35 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool prompt_on  =    (bool )0;
#line 36 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool verbose  =    (bool )0;
#line 39 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
void set_def_filename(char const   * const  s ) 
{ 


  {
  {
#line 41
  strncpy((char */* __restrict  */)(def_filename), (char const   */* __restrict  */)s,
          sizeof(def_filename));
#line 42
  def_filename[sizeof(def_filename) - 1UL] = (char)0;
  }
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
void set_error_msg(char const   *msg ) 
{ 


  {
#line 47
  if (! msg) {
#line 47
    msg = "";
  }
  {
#line 48
  strncpy((char */* __restrict  */)(errmsg), (char const   */* __restrict  */)msg,
          sizeof(errmsg));
#line 49
  errmsg[sizeof(errmsg) - 1UL] = (char)0;
  }
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
void set_prompt(char const   * const  s ) 
{ 


  {
  {
#line 54
  prompt_on = (bool )1;
#line 55
  strncpy((char */* __restrict  */)(prompt_str), (char const   */* __restrict  */)s,
          sizeof(prompt_str));
#line 56
  prompt_str[sizeof(prompt_str) - 1UL] = (char)0;
  }
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
void set_verbose(void) 
{ 


  {
#line 59
  verbose = (bool )1;
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static line_t const   *mark[26]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int markno  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool mark_line_node(line_t const   * const  lp___0 , int c ) 
{ 


  {
#line 67
  c -= 97;
#line 68
  if (c < 0) {
    {
#line 69
    set_error_msg("Invalid mark character");
    }
#line 69
    return ((bool )0);
  } else
#line 68
  if (c >= 26) {
    {
#line 69
    set_error_msg("Invalid mark character");
    }
#line 69
    return ((bool )0);
  }
#line 70
  if (! mark[c]) {
#line 70
    markno ++;
  }
#line 71
  mark[c] = (line_t const   *)lp___0;
#line 72
  return ((bool )1);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
void unmark_line_node(line_t const   * const  lp___0 ) 
{ 
  int i ;

  {
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (markno) {
#line 79
      if (! (i < 26)) {
#line 79
        goto while_break;
      }
    } else {
#line 79
      goto while_break;
    }
#line 80
    if ((unsigned long )mark[i] == (unsigned long )lp___0) {
#line 81
      mark[i] = (line_t const   *)0;
#line 81
      markno --;
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int get_marked_node_addr(int c ) 
{ 
  int tmp ;

  {
#line 88
  c -= 97;
#line 89
  if (c < 0) {
    {
#line 90
    set_error_msg("Invalid mark character");
    }
#line 90
    return (-1);
  } else
#line 89
  if (c >= 26) {
    {
#line 90
    set_error_msg("Invalid mark character");
    }
#line 90
    return (-1);
  }
  {
#line 91
  tmp = get_line_node_addr((line_t const   */* const  */)mark[c]);
  }
#line 91
  return (tmp);
}
}
#line 98
static char const   *get_shell_command(char const   ** const  ibufpp ) ;
#line 98 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char *buf___1  =    (char *)0;
#line 99 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int bufsz___1  =    0;
#line 100 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char *shcmd  =    (char *)0;
#line 101 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int shcmdsz  =    0;
#line 102 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int shcmdlen  =    0;
#line 96 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char const   *get_shell_command(char const   ** const  ibufpp ) 
{ 
  char const   *p ;
  int i ;
  int len ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  bool tmp___10 ;
  size_t tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  bool tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  bool tmp___22 ;

  {
  {
#line 104
  i = 0;
#line 106
  tmp = restricted();
  }
#line 106
  if (tmp) {
    {
#line 106
    set_error_msg("Shell access restricted");
    }
#line 106
    return ((char const   *)0);
  }
  {
#line 107
  tmp___0 = get_extended_line(ibufpp, (int */* const  */)(& len), (bool const   )1);
  }
#line 107
  if (! tmp___0) {
#line 107
    return ((char const   *)0);
  }
  {
#line 108
  p = *ibufpp;
#line 109
  tmp___1 = resize_buffer((char **/* const  */)(& buf___1), (int */* const  */)(& bufsz___1),
                          (int const   )(len + 1));
  }
#line 109
  if (! tmp___1) {
#line 109
    return ((char const   *)0);
  }
#line 110
  tmp___2 = i;
#line 110
  i ++;
#line 110
  *(buf___1 + tmp___2) = (char )'!';
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((int const   )*(*ibufpp) != 10)) {
#line 111
      goto while_break;
    }
#line 113
    if ((int const   )*(*ibufpp) == 33) {
#line 115
      if ((unsigned long )p != (unsigned long )*ibufpp) {
        {
#line 117
        tmp___3 = resize_buffer((char **/* const  */)(& buf___1), (int */* const  */)(& bufsz___1),
                                (int const   )(i + 1));
        }
#line 117
        if (! tmp___3) {
#line 117
          return ((char const   *)0);
        }
#line 118
        tmp___4 = i;
#line 118
        i ++;
#line 118
        tmp___5 = *ibufpp;
#line 118
        (*ibufpp) ++;
#line 118
        *(buf___1 + tmp___4) = (char )*tmp___5;
      } else
#line 120
      if (! shcmd) {
        {
#line 121
        set_error_msg("No previous command");
        }
#line 121
        return ((char const   *)0);
      } else {
        {
#line 120
        tmp___10 = traditional();
        }
#line 120
        if (tmp___10) {
#line 120
          if (! *(shcmd + 1)) {
            {
#line 121
            set_error_msg("No previous command");
            }
#line 121
            return ((char const   *)0);
          } else {
#line 120
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 124
          tmp___6 = resize_buffer((char **/* const  */)(& buf___1), (int */* const  */)(& bufsz___1),
                                  (int const   )(i + shcmdlen));
          }
#line 124
          if (! tmp___6) {
#line 124
            return ((char const   *)0);
          }
#line 125
          p = (char const   *)(shcmd + 1);
          {
#line 125
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 125
            if (! ((unsigned long )p < (unsigned long )(shcmd + shcmdlen))) {
#line 125
              goto while_break___0;
            }
#line 125
            tmp___7 = i;
#line 125
            i ++;
#line 125
            tmp___8 = p;
#line 125
            p ++;
#line 125
            *(buf___1 + tmp___7) = (char )*tmp___8;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 126
          tmp___9 = *ibufpp;
#line 126
          (*ibufpp) ++;
#line 126
          p = tmp___9;
        }
      }
    } else
#line 129
    if ((int const   )*(*ibufpp) == 37) {
#line 131
      if (! def_filename[0]) {
        {
#line 132
        set_error_msg("No current filename");
        }
#line 132
        return ((char const   *)0);
      }
      {
#line 133
      p = strip_escapes((char const   *)(def_filename));
#line 134
      tmp___11 = strlen(p);
#line 134
      len = (int )tmp___11;
#line 135
      tmp___12 = resize_buffer((char **/* const  */)(& buf___1), (int */* const  */)(& bufsz___1),
                               (int const   )(i + len));
      }
#line 135
      if (! tmp___12) {
#line 135
        return ((char const   *)0);
      }
      {
#line 136
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 136
        tmp___15 = len;
#line 136
        len --;
#line 136
        if (! tmp___15) {
#line 136
          goto while_break___1;
        }
#line 136
        tmp___13 = i;
#line 136
        i ++;
#line 136
        tmp___14 = p;
#line 136
        p ++;
#line 136
        *(buf___1 + tmp___13) = (char )*tmp___14;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 137
      tmp___16 = *ibufpp;
#line 137
      (*ibufpp) ++;
#line 137
      p = tmp___16;
    } else {
      {
#line 141
      tmp___17 = resize_buffer((char **/* const  */)(& buf___1), (int */* const  */)(& bufsz___1),
                               (int const   )(i + 2));
      }
#line 141
      if (! tmp___17) {
#line 141
        return ((char const   *)0);
      }
#line 142
      tmp___18 = i;
#line 142
      i ++;
#line 142
      *(buf___1 + tmp___18) = (char )*(*ibufpp);
#line 143
      tmp___21 = *ibufpp;
#line 143
      (*ibufpp) ++;
#line 143
      if ((int const   )*tmp___21 == 92) {
#line 143
        tmp___19 = i;
#line 143
        i ++;
#line 143
        tmp___20 = *ibufpp;
#line 143
        (*ibufpp) ++;
#line 143
        *(buf___1 + tmp___19) = (char )*tmp___20;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 146
    if (! ((int const   )*(*ibufpp) == 10)) {
#line 146
      goto while_break___2;
    }
#line 146
    (*ibufpp) ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 147
  tmp___22 = resize_buffer((char **/* const  */)(& shcmd), (int */* const  */)(& shcmdsz),
                           (int const   )(i + 1));
  }
#line 147
  if (! tmp___22) {
#line 147
    return ((char const   *)0);
  }
  {
#line 148
  memcpy((void */* __restrict  */)shcmd, (void const   */* __restrict  */)buf___1,
         (size_t )i);
#line 149
  shcmdlen = i;
#line 149
  *(shcmd + i) = (char)0;
  }
#line 150
  if ((int const   )*p == 33) {
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", shcmd + 1);
    }
  } else
#line 150
  if ((int const   )*p == 37) {
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", shcmd + 1);
    }
  }
#line 151
  return ((char const   *)shcmd);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char const   *skip_blanks(char const   *p ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    tmp = __ctype_b_loc();
    }
#line 157
    if ((int const   )*(*tmp + (int )((unsigned char )*p)) & 8192) {
#line 157
      if (! ((int const   )*p != 10)) {
#line 157
        goto while_break;
      }
    } else {
#line 157
      goto while_break;
    }
#line 157
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (p);
}
}
#line 165
static char const   *get_filename(char const   ** const  ibufpp ) ;
#line 165 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char *buf___2  =    (char *)0;
#line 166 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int bufsz___2  =    0;
#line 163 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char const   *get_filename(char const   ** const  ibufpp ) 
{ 
  int pmax ;
  int tmp ;
  int n ;
  int size ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  char *tmp___5 ;
  bool tmp___6 ;

  {
  {
#line 167
  tmp = path_max((char const   *)0);
#line 167
  pmax = tmp;
#line 170
  *ibufpp = skip_blanks(*ibufpp);
  }
#line 171
  if ((int const   )*(*ibufpp) != 10) {
    {
#line 173
    size = 0;
#line 174
    tmp___0 = get_extended_line(ibufpp, (int */* const  */)(& size), (bool const   )1);
    }
#line 174
    if (! tmp___0) {
#line 174
      return ((char const   *)0);
    }
#line 175
    if ((int const   )*(*ibufpp) == 33) {
      {
#line 177
      (*ibufpp) ++;
#line 178
      tmp___1 = get_shell_command(ibufpp);
      }
#line 178
      return (tmp___1);
    } else
#line 180
    if (size > pmax) {
      {
#line 181
      set_error_msg("Filename too long");
      }
#line 181
      return ((char const   *)0);
    }
  } else {
    {
#line 183
    tmp___2 = traditional();
    }
#line 183
    if (! tmp___2) {
#line 183
      if (! def_filename[0]) {
        {
#line 184
        set_error_msg("No current filename");
        }
#line 184
        return ((char const   *)0);
      }
    }
  }
  {
#line 185
  tmp___3 = resize_buffer((char **/* const  */)(& buf___2), (int */* const  */)(& bufsz___2),
                          (int const   )(pmax + 1));
  }
#line 185
  if (! tmp___3) {
#line 185
    return ((char const   *)0);
  }
#line 186
  n = 0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! ((int const   )*(*ibufpp) != 10)) {
#line 186
      goto while_break;
    }
#line 186
    *(buf___2 + n) = (char )*(*ibufpp);
#line 186
    n ++;
#line 186
    (*ibufpp) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  *(buf___2 + n) = (char)0;
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 188
    if (! ((int const   )*(*ibufpp) == 10)) {
#line 188
      goto while_break___0;
    }
#line 188
    (*ibufpp) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 189
  tmp___6 = may_access_filename((char const   */* const  */)buf___2);
  }
#line 189
  if (tmp___6) {
#line 189
    tmp___5 = buf___2;
  } else {
#line 189
    tmp___5 = (char *)0;
  }
#line 189
  return ((char const   *)tmp___5);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static void invalid_address(void) 
{ 


  {
  {
#line 193
  set_error_msg("Invalid address");
  }
#line 193
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int next_addr(char const   ** const  ibufpp , int * const  addr_cnt ) 
{ 
  char const   *s ;
  char const   *tmp ;
  int addr ;
  int tmp___0 ;
  bool first ;
  int n ;
  unsigned char ch ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;

  {
  {
#line 199
  tmp = skip_blanks(*ibufpp);
#line 199
  *ibufpp = tmp;
#line 199
  s = tmp;
#line 200
  tmp___0 = current_addr();
#line 200
  addr = tmp___0;
#line 201
  first = (bool )1;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    ch = (unsigned char )*(*ibufpp);
#line 207
    tmp___10 = __ctype_b_loc();
    }
#line 207
    if ((int const   )*(*tmp___10 + (int )ch) & 2048) {
#line 209
      if (! first) {
        {
#line 209
        invalid_address();
        }
#line 209
        return (-2);
      }
      {
#line 210
      tmp___1 = parse_int((int */* const  */)(& addr), (char const   */* const  */)*ibufpp,
                          ibufpp);
      }
#line 210
      if (! tmp___1) {
#line 210
        return (-2);
      }
    } else {
      {
#line 217
      if ((int )ch == 45) {
#line 217
        goto case_45;
      }
#line 217
      if ((int )ch == 32) {
#line 217
        goto case_45;
      }
#line 217
      if ((int )ch == 9) {
#line 217
        goto case_45;
      }
#line 217
      if ((int )ch == 43) {
#line 217
        goto case_45;
      }
#line 227
      if ((int )ch == 36) {
#line 227
        goto case_36;
      }
#line 227
      if ((int )ch == 46) {
#line 227
        goto case_36;
      }
#line 232
      if ((int )ch == 63) {
#line 232
        goto case_63;
      }
#line 232
      if ((int )ch == 47) {
#line 232
        goto case_63;
      }
#line 237
      if ((int )ch == 39) {
#line 237
        goto case_39;
      }
#line 244
      if ((int )ch == 59) {
#line 244
        goto case_59;
      }
#line 244
      if ((int )ch == 44) {
#line 244
        goto case_59;
      }
#line 244
      if ((int )ch == 37) {
#line 244
        goto case_59;
      }
#line 251
      goto switch_default;
      case_45: /* CIL Label */ 
      case_32: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_43: /* CIL Label */ 
      {
#line 217
      (*ibufpp) ++;
#line 217
      *ibufpp = skip_blanks(*ibufpp);
#line 218
      tmp___4 = __ctype_b_loc();
      }
#line 218
      if ((int const   )*(*tmp___4 + (int )((unsigned char )*(*ibufpp))) & 2048) {
        {
#line 220
        tmp___2 = parse_int((int */* const  */)(& n), (char const   */* const  */)*ibufpp,
                            ibufpp);
        }
#line 220
        if (! tmp___2) {
#line 220
          return (-2);
        }
#line 221
        if ((int )ch == 45) {
#line 221
          tmp___3 = - n;
        } else {
#line 221
          tmp___3 = n;
        }
#line 221
        addr += tmp___3;
      } else
#line 223
      if ((int )ch == 43) {
#line 223
        addr ++;
      } else
#line 224
      if ((int )ch == 45) {
#line 224
        addr --;
      }
#line 225
      goto switch_break;
      case_36: /* CIL Label */ 
      case_46: /* CIL Label */ 
#line 227
      if (! first) {
        {
#line 227
        invalid_address();
        }
#line 227
        return (-2);
      }
#line 228
      (*ibufpp) ++;
#line 229
      if ((int )ch == 46) {
        {
#line 229
        tmp___5 = current_addr();
#line 229
        addr = tmp___5;
        }
      } else {
        {
#line 229
        tmp___6 = last_addr();
#line 229
        addr = tmp___6;
        }
      }
#line 230
      goto switch_break;
      case_63: /* CIL Label */ 
      case_47: /* CIL Label */ 
#line 232
      if (! first) {
        {
#line 232
        invalid_address();
        }
#line 232
        return (-2);
      }
      {
#line 233
      addr = next_matching_node_addr(ibufpp, (bool const   )((int )ch == 47));
      }
#line 234
      if (addr < 0) {
#line 234
        return (-2);
      }
#line 235
      if ((int )ch == (int )*(*ibufpp)) {
#line 235
        (*ibufpp) ++;
      }
#line 236
      goto switch_break;
      case_39: /* CIL Label */ 
#line 237
      if (! first) {
        {
#line 237
        invalid_address();
        }
#line 237
        return (-2);
      }
      {
#line 238
      (*ibufpp) ++;
#line 239
      tmp___7 = *ibufpp;
#line 239
      (*ibufpp) ++;
#line 239
      addr = get_marked_node_addr((int )*tmp___7);
      }
#line 240
      if (addr < 0) {
#line 240
        return (-2);
      }
#line 241
      goto switch_break;
      case_59: /* CIL Label */ 
      case_44: /* CIL Label */ 
      case_37: /* CIL Label */ 
#line 244
      if (first) {
#line 246
        (*ibufpp) ++;
#line 246
        (*addr_cnt) ++;
#line 247
        if ((int )ch == 59) {
          {
#line 247
          tmp___8 = current_addr();
#line 247
          second_addr = tmp___8;
          }
        } else {
#line 247
          second_addr = 1;
        }
        {
#line 248
        addr = last_addr();
        }
#line 249
        goto switch_break;
      }
      switch_default: /* CIL Label */ 
#line 251
      if ((unsigned long )*ibufpp == (unsigned long )s) {
#line 251
        return (-1);
      }
#line 252
      if (addr < 0) {
        {
#line 253
        invalid_address();
        }
#line 253
        return (-2);
      } else {
        {
#line 252
        tmp___9 = last_addr();
        }
#line 252
        if (addr > tmp___9) {
          {
#line 253
          invalid_address();
          }
#line 253
          return (-2);
        }
      }
#line 254
      (*addr_cnt) ++;
#line 254
      return (addr);
      switch_break: /* CIL Label */ ;
      }
    }
#line 256
    first = (bool )0;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int extract_addr_range(char const   ** const  ibufpp ) 
{ 
  int addr ;
  int addr_cnt ;
  int tmp ;

  {
  {
#line 266
  addr_cnt = 0;
#line 268
  second_addr = current_addr();
#line 268
  first_addr = second_addr;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 271
    addr = next_addr(ibufpp, (int */* const  */)(& addr_cnt));
    }
#line 272
    if (addr < 0) {
#line 272
      goto while_break;
    }
#line 273
    first_addr = second_addr;
#line 273
    second_addr = addr;
#line 274
    if ((int const   )*(*ibufpp) != 44) {
#line 274
      if ((int const   )*(*ibufpp) != 59) {
#line 274
        goto while_break;
      }
    }
#line 275
    if ((int const   )*(*ibufpp) == 59) {
      {
#line 275
      set_current_addr((int const   )addr);
      }
    }
#line 276
    (*ibufpp) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  if (addr_cnt == 1) {
#line 278
    first_addr = second_addr;
  } else
#line 278
  if (second_addr != addr) {
#line 278
    first_addr = second_addr;
  }
#line 279
  if (addr != -2) {
#line 279
    tmp = addr_cnt;
  } else {
#line 279
    tmp = -1;
  }
#line 279
  return (tmp);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool get_third_addr(char const   ** const  ibufpp , int * const  addr ) 
{ 
  int old1 ;
  int old2 ;
  int addr_cnt ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 286
  old1 = first_addr;
#line 287
  old2 = second_addr;
#line 288
  tmp = extract_addr_range(ibufpp);
#line 288
  addr_cnt = tmp;
  }
#line 290
  if (addr_cnt < 0) {
#line 290
    return ((bool )0);
  }
  {
#line 291
  tmp___0 = traditional();
  }
#line 291
  if (tmp___0) {
#line 291
    if (addr_cnt == 0) {
      {
#line 292
      set_error_msg("Destination expected");
      }
#line 292
      return ((bool )0);
    }
  }
#line 293
  if (second_addr < 0) {
    {
#line 294
    invalid_address();
    }
#line 294
    return ((bool )0);
  } else {
    {
#line 293
    tmp___1 = last_addr();
    }
#line 293
    if (second_addr > tmp___1) {
      {
#line 294
      invalid_address();
      }
#line 294
      return ((bool )0);
    }
  }
#line 295
  *addr = second_addr;
#line 296
  first_addr = old1;
#line 296
  second_addr = old2;
#line 297
  return ((bool )1);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool check_addr_range(int const   n , int const   m , int const   addr_cnt ) 
{ 
  int tmp ;

  {
#line 304
  if (addr_cnt == 0) {
#line 306
    first_addr = (int )n;
#line 307
    second_addr = (int )m;
  }
#line 309
  if (first_addr < 1) {
    {
#line 310
    invalid_address();
    }
#line 310
    return ((bool )0);
  } else
#line 309
  if (first_addr > second_addr) {
    {
#line 310
    invalid_address();
    }
#line 310
    return ((bool )0);
  } else {
    {
#line 309
    tmp = last_addr();
    }
#line 309
    if (second_addr > tmp) {
      {
#line 310
      invalid_address();
      }
#line 310
      return ((bool )0);
    }
  }
#line 311
  return ((bool )1);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool check_current_addr(int const   addr_cnt ) 
{ 
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 318
  tmp = current_addr();
#line 318
  tmp___0 = current_addr();
#line 318
  tmp___1 = check_addr_range((int const   )tmp___0, (int const   )tmp, addr_cnt);
  }
#line 318
  return (tmp___1);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool get_command_suffix(char const   ** const  ibufpp , int * const  gflagsp ) 
{ 
  char ch ;
  char const   *tmp ;

  {
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    ch = (char )*(*ibufpp);
#line 329
    if ((int )ch == 108) {
#line 329
      *gflagsp |= 2;
    } else
#line 330
    if ((int )ch == 110) {
#line 330
      *gflagsp |= 4;
    } else
#line 331
    if ((int )ch == 112) {
#line 331
      *gflagsp |= 8;
    } else {
#line 332
      goto while_break;
    }
#line 333
    (*ibufpp) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  tmp = *ibufpp;
#line 335
  (*ibufpp) ++;
#line 335
  if ((int const   )*tmp != 10) {
    {
#line 336
    set_error_msg("Invalid command suffix");
    }
#line 336
    return ((bool )0);
  }
#line 337
  return ((bool )1);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool unexpected_address(int const   addr_cnt ) 
{ 


  {
#line 343
  if (addr_cnt > 0) {
    {
#line 343
    set_error_msg("Unexpected address");
    }
#line 343
    return ((bool )1);
  }
#line 344
  return ((bool )0);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool unexpected_command_suffix(unsigned char const   ch ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 349
  tmp = __ctype_b_loc();
  }
#line 349
  if (! ((int const   )*(*tmp + (int )ch) & 8192)) {
    {
#line 350
    set_error_msg("Unexpected command suffix");
    }
#line 350
    return ((bool )1);
  }
#line 351
  return ((bool )0);
}
}
#line 358
static bool command_s(char const   ** const  ibufpp , int * const  gflagsp , int const   addr_cnt ,
                      bool const   isglobal ) ;
#line 358 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int gflags  =    0;
#line 359 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int snum  =    0;
#line 355 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool command_s(char const   ** const  ibufpp , int * const  gflagsp , int const   addr_cnt ,
                      bool const   isglobal ) 
{ 
  enum Sflags sflags ;
  bool tmp ;
  unsigned short const   **tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;

  {
#line 360
  sflags = (enum Sflags )0;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    tmp___0 = __ctype_b_loc();
    }
#line 368
    if ((int const   )*(*tmp___0 + (int )((unsigned char )*(*ibufpp))) & 2048) {
      {
#line 370
      tmp = parse_int((int */* const  */)(& snum), (char const   */* const  */)*ibufpp,
                      ibufpp);
      }
#line 370
      if (! tmp) {
#line 370
        return ((bool )0);
      }
#line 371
      sflags = (enum Sflags )((unsigned int )sflags | 8U);
#line 371
      gflags &= -17;
    } else {
      {
#line 375
      if ((int const   )*(*ibufpp) == 10) {
#line 375
        goto case_10;
      }
#line 376
      if ((int const   )*(*ibufpp) == 103) {
#line 376
        goto case_103;
      }
#line 377
      if ((int const   )*(*ibufpp) == 112) {
#line 377
        goto case_112;
      }
#line 378
      if ((int const   )*(*ibufpp) == 114) {
#line 378
        goto case_114;
      }
#line 379
      goto switch_default;
      case_10: /* CIL Label */ 
#line 375
      sflags = (enum Sflags )((unsigned int )sflags | 8U);
#line 375
      goto switch_break;
      case_103: /* CIL Label */ 
#line 376
      sflags = (enum Sflags )((unsigned int )sflags | 1U);
#line 376
      (*ibufpp) ++;
#line 376
      goto switch_break;
      case_112: /* CIL Label */ 
#line 377
      sflags = (enum Sflags )((unsigned int )sflags | 2U);
#line 377
      (*ibufpp) ++;
#line 377
      goto switch_break;
      case_114: /* CIL Label */ 
#line 378
      sflags = (enum Sflags )((unsigned int )sflags | 4U);
#line 378
      (*ibufpp) ++;
#line 378
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 379
      if (sflags) {
        {
#line 380
        set_error_msg("Invalid command suffix");
        }
#line 380
        return ((bool )0);
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 367
    if (sflags) {
#line 367
      if (! ((int const   )*(*ibufpp) != 10)) {
#line 367
        goto while_break;
      }
    } else {
#line 367
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  if (sflags) {
    {
#line 384
    tmp___1 = prev_pattern();
    }
#line 384
    if (! tmp___1) {
      {
#line 385
      set_error_msg("No previous substitution");
      }
#line 385
      return ((bool )0);
    }
  }
#line 386
  if ((unsigned int )sflags & 1U) {
#line 386
    snum = 0;
  }
#line 387
  if ((int const   )*(*ibufpp) != 10) {
#line 387
    if ((int const   )*(*ibufpp + 1) == 10) {
      {
#line 388
      set_error_msg("Invalid pattern delimiter");
      }
#line 388
      return ((bool )0);
    }
  }
#line 389
  if (! sflags) {
#line 389
    goto _L;
  } else
#line 389
  if ((unsigned int )sflags & 4U) {
    _L: /* CIL Label */ 
    {
#line 389
    tmp___2 = new_compiled_pattern(ibufpp);
    }
#line 389
    if (! tmp___2) {
#line 390
      return ((bool )0);
    }
  }
#line 391
  if (! sflags) {
    {
#line 391
    tmp___3 = extract_subst_tail(ibufpp, (int */* const  */)(& gflags), (int */* const  */)(& snum),
                                 isglobal);
    }
#line 391
    if (! tmp___3) {
#line 392
      return ((bool )0);
    }
  }
#line 393
  if (isglobal) {
#line 393
    gflags |= 1;
  } else {
#line 394
    gflags &= -2;
  }
#line 395
  if ((unsigned int )sflags & 1U) {
#line 395
    gflags ^= 16;
  }
#line 396
  if ((unsigned int )sflags & 2U) {
#line 396
    gflags ^= 8;
#line 396
    gflags &= -7;
  }
  {
#line 399
  if ((int const   )*(*ibufpp) == 108) {
#line 399
    goto case_108;
  }
#line 400
  if ((int const   )*(*ibufpp) == 110) {
#line 400
    goto case_110;
  }
#line 401
  if ((int const   )*(*ibufpp) == 112) {
#line 401
    goto case_112___0;
  }
#line 397
  goto switch_break___0;
  case_108: /* CIL Label */ 
#line 399
  gflags |= 2;
#line 399
  (*ibufpp) ++;
#line 399
  goto switch_break___0;
  case_110: /* CIL Label */ 
#line 400
  gflags |= 4;
#line 400
  (*ibufpp) ++;
#line 400
  goto switch_break___0;
  case_112___0: /* CIL Label */ 
#line 401
  gflags |= 8;
#line 401
  (*ibufpp) ++;
#line 401
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 403
  tmp___4 = check_current_addr(addr_cnt);
  }
#line 403
  if (tmp___4) {
    {
#line 403
    tmp___5 = get_command_suffix(ibufpp, gflagsp);
    }
#line 403
    if (! tmp___5) {
#line 404
      return ((bool )0);
    }
  } else {
#line 404
    return ((bool )0);
  }
#line 405
  if (! isglobal) {
    {
#line 405
    clear_undo_stack();
    }
  }
  {
#line 406
  tmp___6 = search_and_replace((int const   )first_addr, (int const   )second_addr,
                               (int const   )gflags, (int const   )snum, isglobal);
  }
#line 406
  if (! tmp___6) {
#line 407
    return ((bool )0);
  }
#line 408
  if (gflags & 14) {
    {
#line 408
    tmp___7 = current_addr();
#line 408
    tmp___8 = current_addr();
#line 408
    tmp___9 = display_lines(tmp___8, (int const   )tmp___7, (int const   )gflags);
    }
#line 408
    if (! tmp___9) {
#line 410
      return ((bool )0);
    }
  }
#line 411
  return ((bool )1);
}
}
#line 415
static bool exec_global(char const   ** const  ibufpp , int const   gflags___0 , bool const   interactive ) ;
#line 419 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int exec_command(char const   ** const  ibufpp , int const   prev_status ,
                        bool const   isglobal ) 
{ 
  char const   *fnp ;
  int gflags___0 ;
  int addr ;
  int c ;
  int n ;
  int addr_cnt ;
  int tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  bool tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  bool tmp___22 ;
  bool tmp___23 ;
  char const   *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  bool tmp___27 ;
  bool tmp___28 ;
  int tmp___29 ;
  bool tmp___30 ;
  bool tmp___31 ;
  bool tmp___32 ;
  bool tmp___33 ;
  bool tmp___34 ;
  bool tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  bool tmp___38 ;
  bool tmp___39 ;
  bool tmp___40 ;
  char const   *tmp___41 ;
  bool tmp___42 ;
  line_t *tmp___43 ;
  bool tmp___44 ;
  bool tmp___45 ;
  bool tmp___46 ;
  bool tmp___47 ;
  bool tmp___48 ;
  bool tmp___49 ;
  bool tmp___50 ;
  bool tmp___51 ;
  bool tmp___52 ;
  bool tmp___53 ;
  bool tmp___54 ;
  bool tmp___55 ;
  bool tmp___56 ;
  bool tmp___57 ;
  char const   *tmp___58 ;
  bool tmp___59 ;
  bool tmp___60 ;
  bool tmp___61 ;
  bool tmp___62 ;
  bool tmp___63 ;
  bool tmp___64 ;
  bool tmp___65 ;
  bool tmp___66 ;
  bool tmp___67 ;
  int tmp___68 ;
  bool tmp___69 ;
  int tmp___70 ;
  bool tmp___71 ;
  char const   *tmp___72 ;
  char const   *tmp___73 ;
  bool tmp___74 ;
  bool tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  bool tmp___78 ;
  bool tmp___79 ;
  bool tmp___80 ;
  bool tmp___81 ;
  bool tmp___82 ;
  int tmp___83 ;
  bool tmp___84 ;
  int tmp___85 ;
  bool tmp___86 ;
  bool tmp___87 ;
  bool tmp___88 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  bool tmp___96 ;
  bool tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  bool tmp___100 ;
  int tmp___101 ;
  bool tmp___102 ;
  int tmp___103 ;
  bool tmp___104 ;
  int tmp___105 ;
  bool tmp___106 ;
  bool tmp___107 ;
  char const   *tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  bool tmp___111 ;

  {
  {
#line 423
  gflags___0 = 0;
#line 425
  tmp = extract_addr_range(ibufpp);
#line 425
  addr_cnt = tmp;
  }
#line 427
  if (addr_cnt < 0) {
#line 427
    return (-2);
  }
  {
#line 428
  *ibufpp = skip_blanks(*ibufpp);
#line 429
  tmp___0 = *ibufpp;
#line 429
  (*ibufpp) ++;
#line 429
  c = (int )*tmp___0;
  }
  {
#line 432
  if (c == 97) {
#line 432
    goto case_97;
  }
#line 436
  if (c == 99) {
#line 436
    goto case_99;
  }
#line 444
  if (c == 100) {
#line 444
    goto case_100;
  }
#line 450
  if (c == 101) {
#line 450
    goto case_101;
  }
#line 452
  if (c == 69) {
#line 452
    goto case_69;
  }
#line 465
  if (c == 102) {
#line 465
    goto case_102;
  }
#line 477
  if (c == 86) {
#line 477
    goto case_86;
  }
#line 477
  if (c == 71) {
#line 477
    goto case_86;
  }
#line 477
  if (c == 118) {
#line 477
    goto case_86;
  }
#line 477
  if (c == 103) {
#line 477
    goto case_86;
  }
#line 489
  if (c == 72) {
#line 489
    goto case_72;
  }
#line 489
  if (c == 104) {
#line 489
    goto case_72;
  }
#line 495
  if (c == 105) {
#line 495
    goto case_105;
  }
#line 501
  if (c == 106) {
#line 501
    goto case_106;
  }
#line 507
  if (c == 107) {
#line 507
    goto case_107;
  }
#line 515
  if (c == 112) {
#line 515
    goto case_112;
  }
#line 515
  if (c == 110) {
#line 515
    goto case_112;
  }
#line 515
  if (c == 108) {
#line 515
    goto case_112;
  }
#line 522
  if (c == 109) {
#line 522
    goto case_109;
  }
#line 533
  if (c == 81) {
#line 533
    goto case_81;
  }
#line 533
  if (c == 113) {
#line 533
    goto case_81;
  }
#line 533
  if (c == 80) {
#line 533
    goto case_81;
  }
#line 540
  if (c == 114) {
#line 540
    goto case_114;
  }
#line 552
  if (c == 115) {
#line 552
    goto case_115;
  }
#line 555
  if (c == 116) {
#line 555
    goto case_116;
  }
#line 561
  if (c == 117) {
#line 561
    goto case_117;
  }
#line 566
  if (c == 87) {
#line 566
    goto case_87;
  }
#line 566
  if (c == 119) {
#line 566
    goto case_87;
  }
#line 586
  if (c == 120) {
#line 586
    goto case_120;
  }
#line 592
  if (c == 121) {
#line 592
    goto case_121;
  }
#line 596
  if (c == 122) {
#line 596
    goto case_122;
  }
#line 609
  if (c == 61) {
#line 609
    goto case_61;
  }
#line 612
  if (c == 33) {
#line 612
    goto case_33;
  }
#line 619
  if (c == 10) {
#line 619
    goto case_10;
  }
#line 625
  if (c == 35) {
#line 625
    goto case_35;
  }
#line 627
  goto switch_default;
  case_97: /* CIL Label */ 
  {
#line 432
  tmp___1 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
  }
#line 432
  if (! tmp___1) {
#line 432
    return (-2);
  }
#line 433
  if (! isglobal) {
    {
#line 433
    clear_undo_stack();
    }
  }
  {
#line 434
  tmp___2 = append_lines(ibufpp, (int const   )second_addr, isglobal);
  }
#line 434
  if (! tmp___2) {
#line 434
    return (-2);
  }
#line 435
  goto switch_break;
  case_99: /* CIL Label */ 
#line 436
  if (first_addr == 0) {
#line 436
    first_addr = 1;
  }
#line 437
  if (second_addr == 0) {
#line 437
    second_addr = 1;
  }
  {
#line 438
  tmp___3 = check_current_addr((int const   )addr_cnt);
  }
#line 438
  if (tmp___3) {
    {
#line 438
    tmp___4 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
    }
#line 438
    if (! tmp___4) {
#line 439
      return (-2);
    }
  } else {
#line 439
    return (-2);
  }
#line 440
  if (! isglobal) {
    {
#line 440
    clear_undo_stack();
    }
  }
  {
#line 441
  tmp___5 = delete_lines((int const   )first_addr, (int const   )second_addr, isglobal);
  }
#line 441
  if (tmp___5) {
    {
#line 441
    tmp___6 = current_addr();
#line 441
    tmp___7 = append_lines(ibufpp, (int const   )tmp___6, isglobal);
    }
#line 441
    if (! tmp___7) {
#line 442
      return (-2);
    }
  } else {
#line 442
    return (-2);
  }
#line 443
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 444
  tmp___8 = check_current_addr((int const   )addr_cnt);
  }
#line 444
  if (tmp___8) {
    {
#line 444
    tmp___9 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
    }
#line 444
    if (! tmp___9) {
#line 445
      return (-2);
    }
  } else {
#line 445
    return (-2);
  }
#line 446
  if (! isglobal) {
    {
#line 446
    clear_undo_stack();
    }
  }
  {
#line 447
  tmp___10 = delete_lines((int const   )first_addr, (int const   )second_addr, isglobal);
  }
#line 447
  if (! tmp___10) {
#line 447
    return (-2);
  }
  {
#line 448
  inc_current_addr();
  }
#line 449
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 450
  tmp___11 = modified();
  }
#line 450
  if (tmp___11) {
    {
#line 450
    tmp___12 = scripted();
    }
#line 450
    if (! tmp___12) {
#line 450
      if (prev_status != -3) {
#line 451
        return (-3);
      }
    }
  }
  case_69: /* CIL Label */ 
  {
#line 452
  tmp___13 = unexpected_address((int const   )addr_cnt);
  }
#line 452
  if (tmp___13) {
#line 453
    return (-2);
  } else {
    {
#line 452
    tmp___14 = unexpected_command_suffix((unsigned char const   )*(*ibufpp));
    }
#line 452
    if (tmp___14) {
#line 453
      return (-2);
    }
  }
  {
#line 454
  fnp = get_filename(ibufpp);
  }
#line 455
  if (! fnp) {
#line 456
    return (-2);
  } else {
    {
#line 455
    tmp___15 = last_addr();
#line 455
    tmp___16 = delete_lines((int const   )1, (int const   )tmp___15, isglobal);
    }
#line 455
    if (tmp___16) {
      {
#line 455
      tmp___17 = close_sbuf();
      }
#line 455
      if (! tmp___17) {
#line 456
        return (-2);
      }
    } else {
#line 456
      return (-2);
    }
  }
  {
#line 457
  tmp___18 = open_sbuf();
  }
#line 457
  if (! tmp___18) {
#line 457
    return (-4);
  }
#line 458
  if (*(fnp + 0)) {
#line 458
    if ((int const   )*(fnp + 0) != 33) {
      {
#line 458
      set_def_filename((char const   */* const  */)fnp);
      }
    }
  }
  {
#line 459
  tmp___19 = traditional();
  }
#line 459
  if (tmp___19) {
#line 459
    if (! *(fnp + 0)) {
#line 459
      if (! def_filename[0]) {
        {
#line 460
        set_error_msg("No current filename");
        }
#line 460
        return (-2);
      }
    }
  }
#line 461
  if (*(fnp + 0)) {
#line 461
    tmp___20 = fnp;
  } else {
#line 461
    tmp___20 = (char const   *)(def_filename);
  }
  {
#line 461
  tmp___21 = read_file((char const   */* const  */)tmp___20, (int const   )0);
  }
#line 461
  if (tmp___21 < 0) {
#line 462
    return (-2);
  }
  {
#line 463
  reset_undo_state();
#line 463
  set_modified((bool const   )0);
  }
#line 464
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 465
  tmp___22 = unexpected_address((int const   )addr_cnt);
  }
#line 465
  if (tmp___22) {
#line 466
    return (-2);
  } else {
    {
#line 465
    tmp___23 = unexpected_command_suffix((unsigned char const   )*(*ibufpp));
    }
#line 465
    if (tmp___23) {
#line 466
      return (-2);
    }
  }
  {
#line 467
  fnp = get_filename(ibufpp);
  }
#line 468
  if (! fnp) {
#line 468
    return (-2);
  }
#line 469
  if ((int const   )*(fnp + 0) == 33) {
    {
#line 470
    set_error_msg("Invalid redirection");
    }
#line 470
    return (-2);
  }
#line 471
  if (*(fnp + 0)) {
    {
#line 471
    set_def_filename((char const   */* const  */)fnp);
    }
  }
  {
#line 472
  tmp___24 = strip_escapes((char const   *)(def_filename));
#line 472
  printf((char const   */* __restrict  */)"%s\n", tmp___24);
  }
#line 473
  goto switch_break;
  case_86: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_103: /* CIL Label */ 
#line 477
  if (isglobal) {
    {
#line 478
    set_error_msg("Cannot nest global commands");
    }
#line 478
    return (-2);
  }
#line 479
  if (c == 103) {
#line 479
    tmp___25 = 1;
  } else
#line 479
  if (c == 71) {
#line 479
    tmp___25 = 1;
  } else {
#line 479
    tmp___25 = 0;
  }
  {
#line 479
  n = tmp___25;
#line 480
  tmp___26 = last_addr();
#line 480
  tmp___27 = check_addr_range((int const   )1, (int const   )tmp___26, (int const   )addr_cnt);
  }
#line 480
  if (tmp___27) {
    {
#line 480
    tmp___28 = build_active_list(ibufpp, (int const   )first_addr, (int const   )second_addr,
                                 (bool const   )n);
    }
#line 480
    if (! tmp___28) {
#line 482
      return (-2);
    }
  } else {
#line 482
    return (-2);
  }
#line 483
  if (c == 71) {
#line 483
    tmp___29 = 1;
  } else
#line 483
  if (c == 86) {
#line 483
    tmp___29 = 1;
  } else {
#line 483
    tmp___29 = 0;
  }
#line 483
  n = tmp___29;
#line 484
  if (n) {
    {
#line 484
    tmp___30 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
    }
#line 484
    if (tmp___30) {
#line 484
      goto _L;
    } else {
#line 486
      return (-2);
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 484
    tmp___31 = exec_global(ibufpp, (int const   )gflags___0, (bool const   )n);
    }
#line 484
    if (! tmp___31) {
#line 486
      return (-2);
    }
  }
#line 487
  goto switch_break;
  case_72: /* CIL Label */ 
  case_104: /* CIL Label */ 
  {
#line 489
  tmp___32 = unexpected_address((int const   )addr_cnt);
  }
#line 489
  if (tmp___32) {
#line 490
    return (-2);
  } else {
    {
#line 489
    tmp___33 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
    }
#line 489
    if (! tmp___33) {
#line 490
      return (-2);
    }
  }
#line 491
  if (c == 72) {
#line 491
    verbose = (bool )(! verbose);
  }
#line 492
  if (c == 104) {
#line 492
    goto _L___0;
  } else
#line 492
  if (verbose) {
    _L___0: /* CIL Label */ 
#line 492
    if (errmsg[0]) {
      {
#line 493
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              errmsg);
      }
    }
  }
#line 494
  goto switch_break;
  case_105: /* CIL Label */ 
#line 495
  if (second_addr == 0) {
#line 495
    second_addr = 1;
  }
  {
#line 496
  tmp___34 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
  }
#line 496
  if (! tmp___34) {
#line 496
    return (-2);
  }
#line 497
  if (! isglobal) {
    {
#line 497
    clear_undo_stack();
    }
  }
  {
#line 498
  tmp___35 = append_lines(ibufpp, (int const   )(second_addr - 1), isglobal);
  }
#line 498
  if (! tmp___35) {
#line 499
    return (-2);
  }
#line 500
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 501
  tmp___36 = current_addr();
#line 501
  tmp___37 = current_addr();
#line 501
  tmp___38 = check_addr_range((int const   )tmp___37, (int const   )(tmp___36 + 1),
                              (int const   )addr_cnt);
  }
#line 501
  if (tmp___38) {
    {
#line 501
    tmp___39 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
    }
#line 501
    if (! tmp___39) {
#line 502
      return (-2);
    }
  } else {
#line 502
    return (-2);
  }
#line 503
  if (! isglobal) {
    {
#line 503
    clear_undo_stack();
    }
  }
#line 504
  if (first_addr != second_addr) {
    {
#line 504
    tmp___40 = join_lines((int const   )first_addr, (int const   )second_addr, isglobal);
    }
#line 504
    if (! tmp___40) {
#line 505
      return (-2);
    }
  }
#line 506
  goto switch_break;
  case_107: /* CIL Label */ 
#line 507
  tmp___41 = *ibufpp;
#line 507
  (*ibufpp) ++;
#line 507
  n = (int )*tmp___41;
#line 508
  if (second_addr == 0) {
    {
#line 508
    invalid_address();
    }
#line 508
    return (-2);
  }
  {
#line 509
  tmp___42 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
  }
#line 509
  if (tmp___42) {
    {
#line 509
    tmp___43 = search_line_node((int const   )second_addr);
#line 509
    tmp___44 = mark_line_node((line_t const   */* const  */)tmp___43, n);
    }
#line 509
    if (! tmp___44) {
#line 511
      return (-2);
    }
  } else {
#line 511
    return (-2);
  }
#line 512
  goto switch_break;
  case_112: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_108: /* CIL Label */ 
#line 515
  if (c == 108) {
#line 515
    n = 2;
  } else
#line 515
  if (c == 110) {
#line 515
    n = 4;
  } else {
#line 515
    n = 8;
  }
  {
#line 516
  tmp___45 = check_current_addr((int const   )addr_cnt);
  }
#line 516
  if (tmp___45) {
    {
#line 516
    tmp___46 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
    }
#line 516
    if (tmp___46) {
      {
#line 516
      tmp___47 = display_lines(first_addr, (int const   )second_addr, (int const   )(gflags___0 | n));
      }
#line 516
      if (! tmp___47) {
#line 519
        return (-2);
      }
    } else {
#line 519
      return (-2);
    }
  } else {
#line 519
    return (-2);
  }
#line 520
  gflags___0 = 0;
#line 521
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 522
  tmp___48 = check_current_addr((int const   )addr_cnt);
  }
#line 522
  if (tmp___48) {
    {
#line 522
    tmp___49 = get_third_addr(ibufpp, (int */* const  */)(& addr));
    }
#line 522
    if (! tmp___49) {
#line 523
      return (-2);
    }
  } else {
#line 523
    return (-2);
  }
#line 524
  if (addr >= first_addr) {
#line 524
    if (addr < second_addr) {
      {
#line 525
      set_error_msg("Invalid destination");
      }
#line 525
      return (-2);
    }
  }
  {
#line 526
  tmp___50 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
  }
#line 526
  if (! tmp___50) {
#line 526
    return (-2);
  }
#line 527
  if (! isglobal) {
    {
#line 527
    clear_undo_stack();
    }
  }
  {
#line 528
  tmp___51 = move_lines((int const   )first_addr, (int const   )second_addr, (int const   )addr,
                        isglobal);
  }
#line 528
  if (! tmp___51) {
#line 529
    return (-2);
  }
#line 530
  goto switch_break;
  case_81: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_80: /* CIL Label */ 
  {
#line 533
  tmp___52 = unexpected_address((int const   )addr_cnt);
  }
#line 533
  if (tmp___52) {
#line 534
    return (-2);
  } else {
    {
#line 533
    tmp___53 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
    }
#line 533
    if (! tmp___53) {
#line 534
      return (-2);
    }
  }
#line 535
  if (c == 80) {
#line 535
    prompt_on = (bool )(! prompt_on);
  } else {
    {
#line 536
    tmp___54 = modified();
    }
#line 536
    if (tmp___54) {
      {
#line 536
      tmp___55 = scripted();
      }
#line 536
      if (tmp___55) {
#line 538
        return (-1);
      } else
#line 536
      if (c == 113) {
#line 536
        if (prev_status != -3) {
#line 537
          return (-3);
        } else {
#line 538
          return (-1);
        }
      } else {
#line 538
        return (-1);
      }
    } else {
#line 538
      return (-1);
    }
  }
#line 539
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 540
  tmp___56 = unexpected_command_suffix((unsigned char const   )*(*ibufpp));
  }
#line 540
  if (tmp___56) {
#line 540
    return (-2);
  }
#line 541
  if (addr_cnt == 0) {
    {
#line 541
    second_addr = last_addr();
    }
  }
  {
#line 542
  fnp = get_filename(ibufpp);
  }
#line 543
  if (! fnp) {
#line 543
    return (-2);
  }
#line 544
  if (! isglobal) {
    {
#line 544
    clear_undo_stack();
    }
  }
#line 545
  if (! def_filename[0]) {
#line 545
    if ((int const   )*(fnp + 0) != 33) {
      {
#line 545
      set_def_filename((char const   */* const  */)fnp);
      }
    }
  }
  {
#line 546
  tmp___57 = traditional();
  }
#line 546
  if (tmp___57) {
#line 546
    if (! *(fnp + 0)) {
#line 546
      if (! def_filename[0]) {
        {
#line 547
        set_error_msg("No current filename");
        }
#line 547
        return (-2);
      }
    }
  }
#line 548
  if (*(fnp + 0)) {
#line 548
    tmp___58 = fnp;
  } else {
#line 548
    tmp___58 = (char const   *)(def_filename);
  }
  {
#line 548
  addr = read_file((char const   */* const  */)tmp___58, (int const   )second_addr);
  }
#line 549
  if (addr < 0) {
#line 549
    return (-2);
  }
#line 550
  if (addr) {
    {
#line 550
    set_modified((bool const   )1);
    }
  }
#line 551
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 552
  tmp___59 = command_s(ibufpp, (int */* const  */)(& gflags___0), (int const   )addr_cnt,
                       isglobal);
  }
#line 552
  if (! tmp___59) {
#line 553
    return (-2);
  }
#line 554
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 555
  tmp___60 = check_current_addr((int const   )addr_cnt);
  }
#line 555
  if (tmp___60) {
    {
#line 555
    tmp___61 = get_third_addr(ibufpp, (int */* const  */)(& addr));
    }
#line 555
    if (tmp___61) {
      {
#line 555
      tmp___62 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
      }
#line 555
      if (! tmp___62) {
#line 557
        return (-2);
      }
    } else {
#line 557
      return (-2);
    }
  } else {
#line 557
    return (-2);
  }
#line 558
  if (! isglobal) {
    {
#line 558
    clear_undo_stack();
    }
  }
  {
#line 559
  tmp___63 = copy_lines((int const   )first_addr, (int const   )second_addr, (int const   )addr);
  }
#line 559
  if (! tmp___63) {
#line 559
    return (-2);
  }
#line 560
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 561
  tmp___64 = unexpected_address((int const   )addr_cnt);
  }
#line 561
  if (tmp___64) {
#line 563
    return (-2);
  } else {
    {
#line 561
    tmp___65 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
    }
#line 561
    if (tmp___65) {
      {
#line 561
      tmp___66 = undo(isglobal);
      }
#line 561
      if (! tmp___66) {
#line 563
        return (-2);
      }
    } else {
#line 563
      return (-2);
    }
  }
#line 564
  goto switch_break;
  case_87: /* CIL Label */ 
  case_119: /* CIL Label */ 
#line 566
  n = (int )*(*ibufpp);
#line 567
  if (n == 113) {
#line 567
    (*ibufpp) ++;
  } else
#line 567
  if (n == 81) {
#line 567
    (*ibufpp) ++;
  }
  {
#line 568
  tmp___67 = unexpected_command_suffix((unsigned char const   )*(*ibufpp));
  }
#line 568
  if (tmp___67) {
#line 568
    return (-2);
  }
  {
#line 569
  fnp = get_filename(ibufpp);
  }
#line 570
  if (! fnp) {
#line 570
    return (-2);
  }
#line 571
  if (addr_cnt == 0) {
    {
#line 571
    tmp___70 = last_addr();
    }
#line 571
    if (tmp___70 == 0) {
#line 572
      second_addr = 0;
#line 572
      first_addr = second_addr;
    } else {
#line 571
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 573
    tmp___68 = last_addr();
#line 573
    tmp___69 = check_addr_range((int const   )1, (int const   )tmp___68, (int const   )addr_cnt);
    }
#line 573
    if (! tmp___69) {
#line 574
      return (-2);
    }
  }
#line 575
  if (! def_filename[0]) {
#line 575
    if ((int const   )*(fnp + 0) != 33) {
      {
#line 575
      set_def_filename((char const   */* const  */)fnp);
      }
    }
  }
  {
#line 576
  tmp___71 = traditional();
  }
#line 576
  if (tmp___71) {
#line 576
    if (! *(fnp + 0)) {
#line 576
      if (! def_filename[0]) {
        {
#line 577
        set_error_msg("No current filename");
        }
#line 577
        return (-2);
      }
    }
  }
#line 578
  if (c == 87) {
#line 578
    tmp___72 = "a";
  } else {
#line 578
    tmp___72 = "w";
  }
#line 578
  if (*(fnp + 0)) {
#line 578
    tmp___73 = fnp;
  } else {
#line 578
    tmp___73 = (char const   *)(def_filename);
  }
  {
#line 578
  addr = write_file((char const   */* const  */)tmp___73, (char const   */* const  */)tmp___72,
                    (int const   )first_addr, (int const   )second_addr);
  }
#line 580
  if (addr < 0) {
#line 580
    return (-2);
  }
  {
#line 581
  tmp___76 = last_addr();
  }
#line 581
  if (addr == tmp___76) {
    {
#line 581
    set_modified((bool const   )0);
    }
  } else {
    {
#line 582
    tmp___74 = modified();
    }
#line 582
    if (tmp___74) {
      {
#line 582
      tmp___75 = scripted();
      }
#line 582
      if (! tmp___75) {
#line 582
        if (n == 113) {
#line 582
          if (prev_status != -3) {
#line 583
            return (-3);
          }
        }
      }
    }
  }
#line 584
  if (n == 113) {
#line 584
    return (-1);
  } else
#line 584
  if (n == 81) {
#line 584
    return (-1);
  }
#line 585
  goto switch_break;
  case_120: /* CIL Label */ 
#line 586
  if (second_addr < 0) {
    {
#line 587
    invalid_address();
    }
#line 587
    return (-2);
  } else {
    {
#line 586
    tmp___77 = last_addr();
    }
#line 586
    if (tmp___77 < second_addr) {
      {
#line 587
      invalid_address();
      }
#line 587
      return (-2);
    }
  }
  {
#line 588
  tmp___78 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
  }
#line 588
  if (! tmp___78) {
#line 588
    return (-2);
  }
#line 589
  if (! isglobal) {
    {
#line 589
    clear_undo_stack();
    }
  }
  {
#line 590
  tmp___79 = put_lines((int const   )second_addr);
  }
#line 590
  if (! tmp___79) {
#line 590
    return (-2);
  }
#line 591
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 592
  tmp___80 = check_current_addr((int const   )addr_cnt);
  }
#line 592
  if (tmp___80) {
    {
#line 592
    tmp___81 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
    }
#line 592
    if (tmp___81) {
      {
#line 592
      tmp___82 = yank_lines((int const   )first_addr, (int const   )second_addr);
      }
#line 592
      if (! tmp___82) {
#line 594
        return (-2);
      }
    } else {
#line 594
      return (-2);
    }
  } else {
#line 594
    return (-2);
  }
#line 595
  goto switch_break;
  case_122: /* CIL Label */ 
  {
#line 596
  first_addr = 1;
#line 597
  tmp___83 = current_addr();
#line 597
  tmp___84 = traditional();
  }
#line 597
  if (tmp___84) {
#line 597
    tmp___85 = 1;
  } else
#line 597
  if (! isglobal) {
#line 597
    tmp___85 = 1;
  } else {
#line 597
    tmp___85 = 0;
  }
  {
#line 597
  tmp___86 = check_addr_range((int const   )first_addr, (int const   )(tmp___83 + tmp___85),
                              (int const   )addr_cnt);
  }
#line 597
  if (! tmp___86) {
#line 599
    return (-2);
  }
#line 600
  if ((int const   )*(*ibufpp) > 48) {
#line 600
    if ((int const   )*(*ibufpp) <= 57) {
      {
#line 601
      tmp___87 = parse_int((int */* const  */)(& n), (char const   */* const  */)*ibufpp,
                           ibufpp);
      }
#line 601
      if (tmp___87) {
        {
#line 601
        set_window_lines((int const   )n);
        }
      } else {
#line 602
        return (-2);
      }
    }
  }
  {
#line 603
  tmp___88 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
  }
#line 603
  if (tmp___88) {
    {
#line 603
    tmp___94 = last_addr();
#line 603
    tmp___95 = window_lines();
    }
#line 603
    if (tmp___94 < second_addr + tmp___95) {
      {
#line 603
      tmp___91 = last_addr();
#line 603
      tmp___93 = tmp___91;
      }
    } else {
      {
#line 603
      tmp___92 = window_lines();
#line 603
      tmp___93 = second_addr + tmp___92;
      }
    }
    {
#line 603
    tmp___96 = display_lines(second_addr, (int const   )tmp___93, (int const   )gflags___0);
    }
#line 603
    if (! tmp___96) {
#line 606
      return (-2);
    }
  } else {
#line 606
    return (-2);
  }
#line 607
  gflags___0 = 0;
#line 608
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 609
  tmp___97 = get_command_suffix(ibufpp, (int */* const  */)(& gflags___0));
  }
#line 609
  if (! tmp___97) {
#line 609
    return (-2);
  }
#line 610
  if (addr_cnt) {
#line 610
    tmp___99 = second_addr;
  } else {
    {
#line 610
    tmp___98 = last_addr();
#line 610
    tmp___99 = tmp___98;
    }
  }
  {
#line 610
  printf((char const   */* __restrict  */)"%d\n", tmp___99);
  }
#line 611
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 612
  tmp___100 = unexpected_address((int const   )addr_cnt);
  }
#line 612
  if (tmp___100) {
#line 612
    return (-2);
  }
  {
#line 613
  fnp = get_shell_command(ibufpp);
  }
#line 614
  if (! fnp) {
#line 614
    return (-2);
  }
  {
#line 615
  tmp___101 = system(fnp + 1);
  }
#line 615
  if (tmp___101 < 0) {
    {
#line 616
    set_error_msg("Can\'t create shell process");
    }
#line 616
    return (-2);
  }
  {
#line 617
  tmp___102 = scripted();
  }
#line 617
  if (! tmp___102) {
    {
#line 617
    printf((char const   */* __restrict  */)"!\n");
    }
  }
#line 618
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 619
  first_addr = 1;
#line 620
  tmp___103 = current_addr();
#line 620
  tmp___104 = traditional();
  }
#line 620
  if (tmp___104) {
#line 620
    tmp___105 = 1;
  } else
#line 620
  if (! isglobal) {
#line 620
    tmp___105 = 1;
  } else {
#line 620
    tmp___105 = 0;
  }
  {
#line 620
  tmp___106 = check_addr_range((int const   )first_addr, (int const   )(tmp___103 + tmp___105),
                               (int const   )addr_cnt);
  }
#line 620
  if (tmp___106) {
    {
#line 620
    tmp___107 = display_lines(second_addr, (int const   )second_addr, (int const   )0);
    }
#line 620
    if (! tmp___107) {
#line 623
      return (-2);
    }
  } else {
#line 623
    return (-2);
  }
#line 624
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 625
    tmp___108 = *ibufpp;
#line 625
    (*ibufpp) ++;
#line 625
    if (! ((int const   )*tmp___108 != 10)) {
#line 625
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 626
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 627
  set_error_msg("Unknown command");
  }
#line 627
  return (-2);
  switch_break: /* CIL Label */ ;
  }
#line 629
  if (gflags___0) {
    {
#line 629
    tmp___109 = current_addr();
#line 629
    tmp___110 = current_addr();
#line 629
    tmp___111 = display_lines(tmp___110, (int const   )tmp___109, (int const   )gflags___0);
    }
#line 629
    if (! tmp___111) {
#line 630
      return (-2);
    }
  }
#line 631
  return (0);
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static char *buf___3  =    (char *)0;
#line 641 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static int bufsz___3  =    0;
#line 637 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
static bool exec_global(char const   ** const  ibufpp , int const   gflags___0 , bool const   interactive ) 
{ 
  char const   *cmd ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  line_t const   *lp___0 ;
  line_t const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int len ;
  int tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 642
  cmd = (char const   *)0;
#line 644
  if (! interactive) {
    {
#line 646
    tmp___0 = traditional();
    }
#line 646
    if (tmp___0) {
      {
#line 646
      tmp___1 = strcmp(*ibufpp, "\n");
      }
#line 646
      if (tmp___1) {
#line 646
        goto _L;
      } else {
#line 647
        cmd = "p\n";
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 650
      tmp = get_extended_line(ibufpp, (int */* const  */)0, (bool const   )0);
      }
#line 650
      if (! tmp) {
#line 650
        return ((bool )0);
      }
#line 651
      cmd = *ibufpp;
    }
  }
  {
#line 654
  clear_undo_stack();
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 657
    tmp___2 = next_active_node();
#line 657
    lp___0 = tmp___2;
    }
#line 658
    if (! lp___0) {
#line 658
      goto while_break;
    }
    {
#line 659
    tmp___3 = get_line_node_addr((line_t const   */* const  */)lp___0);
#line 659
    set_current_addr((int const   )tmp___3);
#line 660
    tmp___4 = current_addr();
    }
#line 660
    if (tmp___4 < 0) {
#line 660
      return ((bool )0);
    }
#line 661
    if (interactive) {
      {
#line 665
      tmp___5 = current_addr();
#line 665
      tmp___6 = current_addr();
#line 665
      tmp___7 = display_lines(tmp___6, (int const   )tmp___5, gflags___0);
      }
#line 665
      if (! tmp___7) {
#line 666
        return ((bool )0);
      }
      {
#line 667
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 667
        *ibufpp = get_tty_line((int */* const  */)(& len));
        }
#line 667
        if (*ibufpp) {
#line 667
          if (len > 0) {
#line 667
            if (! ((int const   )*(*ibufpp + (len - 1)) != 10)) {
#line 667
              goto while_break___0;
            }
          } else {
#line 667
            goto while_break___0;
          }
        } else {
#line 667
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 669
      if (! *ibufpp) {
#line 669
        return ((bool )0);
      }
#line 670
      if (len == 0) {
        {
#line 671
        set_error_msg("Unexpected end-of-file");
        }
#line 671
        return ((bool )0);
      }
#line 672
      if (len == 1) {
        {
#line 672
        tmp___8 = strcmp(*ibufpp, "\n");
        }
#line 672
        if (! tmp___8) {
#line 672
          goto while_continue;
        }
      }
#line 673
      if (len == 2) {
        {
#line 673
        tmp___11 = strcmp(*ibufpp, "&\n");
        }
#line 673
        if (tmp___11) {
#line 673
          goto _L___0;
        } else
#line 674
        if (! cmd) {
          {
#line 674
          set_error_msg("No previous command");
          }
#line 674
          return ((bool )0);
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 677
        tmp___9 = get_extended_line(ibufpp, (int */* const  */)(& len), (bool const   )0);
        }
#line 677
        if (tmp___9) {
          {
#line 677
          tmp___10 = resize_buffer((char **/* const  */)(& buf___3), (int */* const  */)(& bufsz___3),
                                   (int const   )(len + 1));
          }
#line 677
          if (! tmp___10) {
#line 678
            return ((bool )0);
          }
        } else {
#line 678
          return ((bool )0);
        }
        {
#line 679
        memcpy((void */* __restrict  */)buf___3, (void const   */* __restrict  */)*ibufpp,
               (size_t )(len + 1));
#line 680
        cmd = (char const   *)buf___3;
        }
      }
    }
#line 683
    *ibufpp = cmd;
    {
#line 684
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 684
      if (! *(*ibufpp)) {
#line 684
        goto while_break___1;
      }
      {
#line 684
      tmp___12 = exec_command(ibufpp, (int const   )0, (bool const   )1);
      }
#line 684
      if (tmp___12 < 0) {
#line 684
        return ((bool )0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  return ((bool )1);
}
}
#line 692
jmp_buf jmp_state ;
#line 690 "/home/june/repo/benchmarks/collector/temp/ed-1.9/main_loop.c"
int main_loop(bool const   loose ) 
{ 
  char const   *ibufp ;
  int volatile   err_status ;
  int volatile   linenum ;
  int len ;
  int status ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
  {
#line 694
  err_status = (int volatile   )0;
#line 695
  linenum = (int volatile   )0;
#line 698
  disable_interrupts();
#line 699
  set_signals();
#line 700
  status = _setjmp((struct __jmp_buf_tag *)(jmp_state));
  }
#line 701
  if (! status) {
    {
#line 701
    enable_interrupts();
    }
  } else {
    {
#line 702
    status = -1;
#line 702
    fputs((char const   */* __restrict  */)"\n?\n", (FILE */* __restrict  */)stderr);
#line 702
    set_error_msg("Interrupt");
    }
  }
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 706
    fflush(stdout);
    }
#line 707
    if (status < 0) {
#line 707
      if (verbose) {
        {
#line 708
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                errmsg);
#line 708
        fflush(stderr);
        }
      }
    }
#line 709
    if (prompt_on) {
      {
#line 709
      printf((char const   */* __restrict  */)"%s", prompt_str);
#line 709
      fflush(stdout);
      }
    }
    {
#line 710
    ibufp = get_tty_line((int */* const  */)(& len));
    }
#line 711
    if (! ibufp) {
#line 711
      return ((int )err_status);
    }
#line 712
    if (! len) {
      {
#line 714
      tmp = modified();
      }
#line 714
      if (tmp) {
        {
#line 714
        tmp___0 = scripted();
        }
#line 714
        if (tmp___0) {
#line 714
          return ((int )err_status);
        }
      } else {
#line 714
        return ((int )err_status);
      }
      {
#line 715
      fputs((char const   */* __restrict  */)"?\n", (FILE */* __restrict  */)stderr);
#line 715
      set_error_msg("Warning: buffer modified");
#line 716
      tmp___1 = is_regular_file((int const   )0);
      }
#line 716
      if (tmp___1) {
#line 718
        if (verbose) {
          {
#line 718
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"script, line %d: %s\n",
                  linenum, errmsg);
          }
        }
#line 719
        return (2);
      }
      {
#line 721
      set_modified((bool const   )0);
#line 721
      status = -3;
      }
#line 721
      goto while_continue;
    } else
#line 723
    if ((int const   )*(ibufp + (len - 1)) != 10) {
      {
#line 724
      set_error_msg("Unexpected end-of-file");
#line 724
      status = -2;
      }
#line 724
      goto while_continue;
    } else {
#line 725
      linenum += (int volatile   )1;
    }
    {
#line 726
    status = exec_command((char const   **/* const  */)(& ibufp), (int const   )status,
                          (bool const   )0);
    }
#line 727
    if (status == 0) {
#line 727
      goto while_continue;
    }
#line 728
    if (status == -1) {
#line 728
      return ((int )err_status);
    }
#line 729
    if (status == -3) {
      {
#line 731
      fputs((char const   */* __restrict  */)"?\n", (FILE */* __restrict  */)stderr);
#line 732
      set_error_msg("Warning: buffer modified");
#line 733
      tmp___2 = is_regular_file((int const   )0);
      }
#line 733
      if (tmp___2) {
#line 735
        if (verbose) {
          {
#line 736
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"script, line %d: %s\n",
                  linenum, errmsg);
          }
        }
#line 737
        return (1);
      }
    } else
#line 740
    if (status == -4) {
#line 742
      if (verbose) {
        {
#line 744
        tmp___3 = is_regular_file((int const   )0);
        }
#line 744
        if (tmp___3) {
          {
#line 745
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"script, line %d: %s\n",
                  linenum, errmsg);
          }
        } else {
          {
#line 746
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                  errmsg);
          }
        }
      }
#line 748
      return (1);
    } else {
      {
#line 752
      fputs((char const   */* __restrict  */)"?\n", (FILE */* __restrict  */)stderr);
#line 753
      tmp___4 = is_regular_file((int const   )0);
      }
#line 753
      if (tmp___4) {
#line 755
        if (verbose) {
          {
#line 756
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"script, line %d: %s\n",
                  linenum, errmsg);
          }
        }
#line 757
        return (1);
      }
    }
#line 760
    if (! loose) {
#line 760
      err_status = (int volatile   )1;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
bool set_active_node(line_t const   * const  lp___0 ) ;
#line 145
bool resize_line_buffer(line_t const   *** const  buf___9 , int * const  size , int const   min_size ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/ed-1.9/global.c"
static line_t const   **active_list  =    (line_t const   **)0;
#line 30 "/home/june/repo/benchmarks/collector/temp/ed-1.9/global.c"
static int active_size  =    0;
#line 31 "/home/june/repo/benchmarks/collector/temp/ed-1.9/global.c"
static int active_len  =    0;
#line 32 "/home/june/repo/benchmarks/collector/temp/ed-1.9/global.c"
static int active_ptr  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/ed-1.9/global.c"
static int active_ndx  =    0;
#line 37 "/home/june/repo/benchmarks/collector/temp/ed-1.9/global.c"
void clear_active_list(void) 
{ 


  {
  {
#line 39
  disable_interrupts();
  }
#line 40
  if (active_list) {
    {
#line 40
    free((void *)active_list);
    }
  }
  {
#line 41
  active_list = (line_t const   **)0;
#line 42
  active_ndx = 0;
#line 42
  active_ptr = active_ndx;
#line 42
  active_len = active_ptr;
#line 42
  active_size = active_len;
#line 43
  enable_interrupts();
  }
#line 44
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/ed-1.9/global.c"
line_t const   *next_active_node(void) 
{ 
  int tmp ;
  line_t const   *tmp___0 ;

  {
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (active_ptr < active_len) {
#line 50
      if (! (! *(active_list + active_ptr))) {
#line 50
        goto while_break;
      }
    } else {
#line 50
      goto while_break;
    }
#line 51
    active_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (active_ptr < active_len) {
#line 52
    tmp = active_ptr;
#line 52
    active_ptr ++;
#line 52
    tmp___0 = *(active_list + tmp);
  } else {
#line 52
    tmp___0 = (line_t const   *)0;
  }
#line 52
  return (tmp___0);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/ed-1.9/global.c"
bool set_active_node(line_t const   * const  lp___0 ) 
{ 
  int *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 59
  disable_interrupts();
#line 60
  tmp___0 = resize_line_buffer((line_t const   ***/* const  */)(& active_list), (int */* const  */)(& active_size),
                               (int const   )((unsigned long )(active_len + 1) * sizeof(line_t **)));
  }
#line 60
  if (! tmp___0) {
    {
#line 63
    tmp = __errno_location();
#line 63
    show_strerror((char const   */* const  */)0, (int const   )*tmp);
#line 63
    set_error_msg("Memory exhausted");
#line 64
    enable_interrupts();
    }
#line 65
    return ((bool )0);
  }
  {
#line 67
  enable_interrupts();
#line 68
  tmp___1 = active_len;
#line 68
  active_len ++;
#line 68
  *(active_list + tmp___1) = (line_t const   *)lp___0;
  }
#line 69
  return ((bool )1);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/ed-1.9/global.c"
void unset_active_nodes(line_t const   *bp , line_t const   * const  ep ) 
{ 
  int i ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )bp != (unsigned long )ep)) {
#line 76
      goto while_break;
    }
#line 79
    i = 0;
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 79
      if (! (i < active_len)) {
#line 79
        goto while_break___0;
      }
#line 81
      active_ndx ++;
#line 81
      if (active_ndx >= active_len) {
#line 81
        active_ndx = 0;
      }
#line 82
      if ((unsigned long )*(active_list + active_ndx) == (unsigned long )bp) {
#line 83
        *(active_list + active_ndx) = (line_t const   *)0;
#line 83
        goto while_break___0;
      }
#line 79
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 85
    bp = (line_t const   *)bp->q_forw;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static regex_t *global_pat  =    (regex_t *)0;
#line 33 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static bool patlock  =    (bool )0;
#line 35 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static char *stbuf  =    (char *)0;
#line 36 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static int stbufsz  =    0;
#line 37 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static int stlen  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static char *rbuf  =    (char *)0;
#line 40 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static int rbufsz  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
bool prev_pattern(void) 
{ 


  {
#line 43
  return ((bool )((unsigned long )global_pat != (unsigned long )((regex_t *)0)));
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static void translit_text(char *p , int len , char const   from , char const   to ) 
{ 


  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    len --;
#line 49
    if (! (len >= 0)) {
#line 49
      goto while_break;
    }
#line 51
    if ((int )*p == (int )from) {
#line 51
      *p = (char )to;
    }
#line 52
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static void newline_to_nul(char * const  s , int const   len ) 
{ 


  {
  {
#line 59
  translit_text((char *)s, (int )len, (char const   )'\n', (char const   )'\000');
  }
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static void nul_to_newline(char * const  s , int const   len ) 
{ 


  {
  {
#line 63
  translit_text((char *)s, (int )len, (char const   )'\000', (char const   )'\n');
  }
#line 63
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static char const   *parse_char_class(char const   *p ) 
{ 
  char c ;
  char d ;
  char const   *tmp ;

  {
#line 71
  if ((int const   )*p == 94) {
#line 71
    p ++;
  }
#line 72
  if ((int const   )*p == 93) {
#line 72
    p ++;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if ((int const   )*p != 93) {
#line 73
      if (! ((int const   )*p != 10)) {
#line 73
        goto while_break;
      }
    } else {
#line 73
      goto while_break;
    }
#line 74
    if ((int const   )*p == 91) {
#line 74
      d = (char )*(p + 1);
#line 74
      if ((int )d == 46) {
#line 74
        goto _L;
      } else
#line 74
      if ((int )d == 58) {
#line 74
        goto _L;
      } else
#line 74
      if ((int )d == 61) {
        _L: /* CIL Label */ 
#line 75
        p ++;
#line 75
        p ++;
#line 75
        c = (char )*p;
        {
#line 75
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 75
          if (! ((int const   )*p != 93)) {
#line 75
            if (! ((int )c != (int )d)) {
#line 75
              goto while_break___0;
            }
          }
#line 76
          c = (char )*p;
#line 76
          if ((int )c == 10) {
#line 77
            return ((char const   *)0);
          }
#line 75
          p ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 73
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  if ((int const   )*p == 93) {
#line 78
    tmp = p;
  } else {
#line 78
    tmp = (char const   *)0;
  }
#line 78
  return (tmp);
}
}
#line 85
static char *extract_pattern(char const   ** const  ibufpp , char const   delimiter ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static char *buf___4  =    (char *)0;
#line 86 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static int bufsz___4  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static char *extract_pattern(char const   ** const  ibufpp , char const   delimiter ) 
{ 
  char const   *nd ;
  int len ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 87
  nd = *ibufpp;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if ((int const   )*nd != (int const   )delimiter) {
#line 90
      if (! ((int const   )*nd != 10)) {
#line 90
        goto while_break;
      }
    } else {
#line 90
      goto while_break;
    }
#line 92
    if ((int const   )*nd == 91) {
      {
#line 94
      nd ++;
#line 94
      nd = parse_char_class(nd);
      }
#line 95
      if (! nd) {
        {
#line 95
        set_error_msg("Unbalanced brackets ([])");
        }
#line 95
        return ((char *)0);
      }
    } else
#line 97
    if ((int const   )*nd == 92) {
#line 97
      nd ++;
#line 97
      if ((int const   )*nd == 10) {
        {
#line 98
        set_error_msg("Trailing backslash (\\)");
        }
#line 98
        return ((char *)0);
      }
    }
#line 99
    nd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  len = (int )(nd - *ibufpp);
#line 102
  tmp = resize_buffer((char **/* const  */)(& buf___4), (int */* const  */)(& bufsz___4),
                      (int const   )(len + 1));
  }
#line 102
  if (! tmp) {
#line 102
    return ((char *)0);
  }
  {
#line 103
  memcpy((void */* __restrict  */)buf___4, (void const   */* __restrict  */)*ibufpp,
         (size_t )len);
#line 104
  *(buf___4 + len) = (char)0;
#line 105
  *ibufpp = nd;
#line 106
  tmp___0 = isbinary();
  }
#line 106
  if (tmp___0) {
    {
#line 106
    nul_to_newline((char */* const  */)buf___4, (int const   )len);
    }
  }
#line 107
  return (buf___4);
}
}
#line 114
static regex_t *get_compiled_pattern(char const   ** const  ibufpp ) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static regex_t *exp  =    (regex_t *)0;
#line 112 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static regex_t *get_compiled_pattern(char const   ** const  ibufpp ) 
{ 
  char const   *exps ;
  char delimiter ;
  int n ;
  char *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char buf___9[80] ;

  {
#line 116
  delimiter = (char )*(*ibufpp);
#line 119
  if ((int )delimiter == 32) {
    {
#line 120
    set_error_msg("Invalid pattern delimiter");
    }
#line 120
    return ((regex_t *)0);
  }
#line 121
  if ((int )delimiter == 10) {
#line 121
    goto _L;
  } else {
#line 121
    (*ibufpp) ++;
#line 121
    if ((int const   )*(*ibufpp) == 10) {
#line 121
      goto _L;
    } else
#line 121
    if ((int const   )*(*ibufpp) == (int const   )delimiter) {
      _L: /* CIL Label */ 
#line 123
      if (! exp) {
        {
#line 123
        set_error_msg("No previous pattern");
        }
      }
#line 124
      return (exp);
    }
  }
  {
#line 126
  tmp = extract_pattern(ibufpp, (char const   )delimiter);
#line 126
  exps = (char const   *)tmp;
  }
#line 127
  if (! exps) {
#line 127
    return ((regex_t *)0);
  }
#line 129
  if (exp) {
#line 129
    if (! patlock) {
      {
#line 129
      regfree(exp);
      }
    } else {
#line 129
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 132
    tmp___0 = malloc(sizeof(regex_t ));
#line 132
    exp = (regex_t *)tmp___0;
    }
#line 133
    if (! exp) {
      {
#line 135
      tmp___1 = __errno_location();
#line 135
      show_strerror((char const   */* const  */)0, (int const   )*tmp___1);
#line 136
      set_error_msg("Memory exhausted");
      }
#line 137
      return ((regex_t *)0);
    }
  }
  {
#line 140
  patlock = (bool )0;
#line 141
  n = regcomp((regex_t */* __restrict  */)exp, (char const   */* __restrict  */)exps,
              0);
  }
#line 142
  if (n) {
    {
#line 145
    regerror(n, (regex_t const   */* __restrict  */)exp, (char */* __restrict  */)(buf___9),
             sizeof(buf___9));
#line 146
    set_error_msg((char const   *)(buf___9));
#line 147
    free((void *)exp);
#line 148
    exp = (regex_t *)0;
    }
  }
#line 150
  return (exp);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
bool build_active_list(char const   ** const  ibufpp , int const   first_addr___0 ,
                       int const   second_addr___0 , bool const   match ) 
{ 
  regex_t const   *pat ;
  line_t const   *lp___0 ;
  int addr ;
  char delimiter ;
  regex_t *tmp ;
  line_t *tmp___0 ;
  char *s ;
  char *tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;

  {
#line 161
  delimiter = (char )*(*ibufpp);
#line 163
  if ((int )delimiter == 32) {
    {
#line 164
    set_error_msg("Invalid pattern delimiter");
    }
#line 164
    return ((bool )0);
  } else
#line 163
  if ((int )delimiter == 10) {
    {
#line 164
    set_error_msg("Invalid pattern delimiter");
    }
#line 164
    return ((bool )0);
  }
  {
#line 165
  tmp = get_compiled_pattern(ibufpp);
#line 165
  pat = (regex_t const   *)tmp;
  }
#line 166
  if (! pat) {
#line 166
    return ((bool )0);
  }
#line 167
  if ((int const   )*(*ibufpp) == (int const   )delimiter) {
#line 167
    (*ibufpp) ++;
  }
  {
#line 168
  clear_active_list();
#line 169
  tmp___0 = search_line_node(first_addr___0);
#line 169
  lp___0 = (line_t const   *)tmp___0;
#line 170
  addr = (int )first_addr___0;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (addr <= (int )second_addr___0)) {
#line 170
      goto while_break;
    }
    {
#line 172
    tmp___1 = get_sbuf_line((line_t const   */* const  */)lp___0);
#line 172
    s = tmp___1;
    }
#line 173
    if (! s) {
#line 173
      return ((bool )0);
    }
    {
#line 174
    tmp___2 = isbinary();
    }
#line 174
    if (tmp___2) {
      {
#line 174
      nul_to_newline((char */* const  */)s, lp___0->len);
      }
    }
    {
#line 175
    tmp___3 = regexec((regex_t const   */* __restrict  */)pat, (char const   */* __restrict  */)s,
                      (size_t )0, (regmatch_t */* __restrict  */)0, 0);
    }
#line 175
    if (tmp___3) {
#line 175
      tmp___4 = 0;
    } else {
#line 175
      tmp___4 = 1;
    }
#line 175
    if ((unsigned int const   )tmp___4 == (unsigned int const   )match) {
      {
#line 175
      tmp___5 = set_active_node((line_t const   */* const  */)lp___0);
      }
#line 175
      if (! tmp___5) {
#line 176
        return ((bool )0);
      }
    }
#line 170
    addr ++;
#line 170
    lp___0 = (line_t const   *)lp___0->q_forw;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return ((bool )1);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static char *extract_subst_template(char const   ** const  ibufpp , bool const   isglobal ) 
{ 
  int i ;
  int n ;
  char c ;
  char delimiter ;
  bool tmp ;
  int tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char tmp___5 ;
  char const   *tmp___6 ;
  bool tmp___7 ;

  {
#line 186
  i = 0;
#line 186
  n = 0;
#line 188
  delimiter = (char )*(*ibufpp);
#line 190
  (*ibufpp) ++;
#line 191
  if ((int const   )*(*ibufpp) == 37) {
#line 191
    if ((int const   )*(*ibufpp + 1) == (int const   )delimiter) {
#line 193
      (*ibufpp) ++;
#line 194
      if (! stbuf) {
        {
#line 194
        set_error_msg("No previous substitution");
        }
      }
#line 195
      return (stbuf);
    }
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! ((int const   )*(*ibufpp) != (int const   )delimiter)) {
#line 197
      goto while_break;
    }
    {
#line 199
    tmp = resize_buffer((char **/* const  */)(& stbuf), (int */* const  */)(& stbufsz),
                        (int const   )(i + 2));
    }
#line 199
    if (! tmp) {
#line 199
      return ((char *)0);
    }
#line 200
    tmp___0 = i;
#line 200
    i ++;
#line 200
    tmp___2 = *ibufpp;
#line 200
    (*ibufpp) ++;
#line 200
    tmp___1 = (char )*tmp___2;
#line 200
    *(stbuf + tmp___0) = tmp___1;
#line 200
    c = tmp___1;
#line 201
    if ((int )c == 10) {
#line 201
      if ((int const   )*(*ibufpp) == 0) {
#line 201
        i --;
#line 201
        (*ibufpp) --;
#line 201
        goto while_break;
      }
    }
#line 202
    if ((int )c == 92) {
#line 202
      tmp___4 = i;
#line 202
      i ++;
#line 202
      tmp___6 = *ibufpp;
#line 202
      (*ibufpp) ++;
#line 202
      tmp___5 = (char )*tmp___6;
#line 202
      *(stbuf + tmp___4) = tmp___5;
#line 202
      if ((int )tmp___5 == 10) {
#line 202
        if (! isglobal) {
          {
#line 204
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 204
            tmp___3 = get_tty_line((int */* const  */)(& n));
#line 204
            *ibufpp = tmp___3;
            }
#line 204
            if (tmp___3) {
#line 204
              if (! (n == 0)) {
#line 204
                if (n > 0) {
#line 204
                  if (! ((int const   )*(*ibufpp + (n - 1)) != 10)) {
#line 204
                    goto while_break___0;
                  }
                } else {
#line 204
                  goto while_break___0;
                }
              }
            } else {
#line 204
              goto while_break___0;
            }
            {
#line 206
            clearerr(stdin);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 207
          if (! *ibufpp) {
#line 207
            return ((char *)0);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  tmp___7 = resize_buffer((char **/* const  */)(& stbuf), (int */* const  */)(& stbufsz),
                          (int const   )(i + 1));
  }
#line 210
  if (! tmp___7) {
#line 210
    return ((char *)0);
  }
#line 211
  stlen = i;
#line 211
  *(stbuf + stlen) = (char)0;
#line 212
  return (stbuf);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
bool extract_subst_tail(char const   ** const  ibufpp , int * const  gflagsp , int * const  snump ,
                        bool const   isglobal ) 
{ 
  char delimiter ;
  int tmp ;
  char *tmp___0 ;
  bool tmp___1 ;

  {
#line 220
  delimiter = (char )*(*ibufpp);
#line 222
  tmp = 0;
#line 222
  *snump = tmp;
#line 222
  *gflagsp = tmp;
#line 223
  if ((int )delimiter == 10) {
#line 223
    stlen = 0;
#line 223
    *gflagsp = 8;
#line 223
    return ((bool )1);
  }
  {
#line 224
  tmp___0 = extract_subst_template(ibufpp, isglobal);
  }
#line 224
  if (! tmp___0) {
#line 224
    return ((bool )0);
  }
#line 225
  if ((int const   )*(*ibufpp) == 10) {
#line 225
    *gflagsp = 8;
#line 225
    return ((bool )1);
  }
#line 226
  if ((int const   )*(*ibufpp) == (int const   )delimiter) {
#line 226
    (*ibufpp) ++;
  }
#line 227
  if ((int const   )*(*ibufpp) >= 49) {
#line 227
    if ((int const   )*(*ibufpp) <= 57) {
      {
#line 228
      tmp___1 = parse_int(snump, (char const   */* const  */)*ibufpp, ibufpp);
      }
#line 228
      return (tmp___1);
    }
  }
#line 229
  if ((int const   )*(*ibufpp) == 103) {
#line 229
    (*ibufpp) ++;
#line 229
    *gflagsp = 16;
  }
#line 230
  return ((bool )1);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
int next_matching_node_addr(char const   ** const  ibufpp , bool const   forward ) 
{ 
  regex_t const   *pat ;
  regex_t *tmp ;
  int addr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  line_t const   *lp___0 ;
  line_t *tmp___3 ;
  char *s ;
  char *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 238
  tmp = get_compiled_pattern(ibufpp);
#line 238
  pat = (regex_t const   *)tmp;
#line 239
  tmp___0 = current_addr();
#line 239
  addr = tmp___0;
  }
#line 241
  if (! pat) {
#line 241
    return (-1);
  }
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (forward) {
      {
#line 243
      tmp___1 = inc_addr(addr);
#line 243
      addr = tmp___1;
      }
    } else {
      {
#line 243
      tmp___2 = dec_addr(addr);
#line 243
      addr = tmp___2;
      }
    }
#line 244
    if (addr) {
      {
#line 246
      tmp___3 = search_line_node((int const   )addr);
#line 246
      lp___0 = (line_t const   *)tmp___3;
#line 247
      tmp___4 = get_sbuf_line((line_t const   */* const  */)lp___0);
#line 247
      s = tmp___4;
      }
#line 248
      if (! s) {
#line 248
        return (-1);
      }
      {
#line 249
      tmp___5 = isbinary();
      }
#line 249
      if (tmp___5) {
        {
#line 249
        nul_to_newline((char */* const  */)s, lp___0->len);
        }
      }
      {
#line 250
      tmp___6 = regexec((regex_t const   */* __restrict  */)pat, (char const   */* __restrict  */)s,
                        (size_t )0, (regmatch_t */* __restrict  */)0, 0);
      }
#line 250
      if (! tmp___6) {
#line 250
        return (addr);
      }
    }
    {
#line 242
    tmp___7 = current_addr();
    }
#line 242
    if (! (addr != tmp___7)) {
#line 242
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  set_error_msg("No match");
  }
#line 255
  return (-1);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
bool new_compiled_pattern(char const   ** const  ibufpp ) 
{ 
  regex_t *tpat ;
  int tmp ;

  {
  {
#line 263
  disable_interrupts();
#line 264
  tpat = get_compiled_pattern(ibufpp);
  }
#line 265
  if (tpat) {
#line 265
    if ((unsigned long )tpat != (unsigned long )global_pat) {
#line 267
      if (global_pat) {
        {
#line 267
        regfree(global_pat);
#line 267
        free((void *)global_pat);
        }
      }
#line 268
      global_pat = tpat;
#line 269
      patlock = (bool )1;
    }
  }
  {
#line 271
  enable_interrupts();
  }
#line 272
  if (tpat) {
#line 272
    tmp = 1;
  } else {
#line 272
    tmp = 0;
  }
#line 272
  return ((bool )tmp);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static int apply_subst_template(char const   * const  boln , regmatch_t const   * const  rm ,
                                int offset , int const   re_nsub ) 
{ 
  char const   *sub ;
  int n ;
  int j ;
  int k ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int j___0 ;
  int k___0 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
#line 282
  sub = (char const   *)stbuf;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! (sub - (char const   *)stbuf < (long )stlen)) {
#line 284
      goto while_break;
    }
#line 287
    if ((int const   )*sub == 38) {
      {
#line 289
      j = (int )(rm + 0)->rm_so;
#line 289
      k = (int )(rm + 0)->rm_eo;
#line 290
      tmp = resize_buffer((char **/* const  */)(& rbuf), (int */* const  */)(& rbufsz),
                          (int const   )((offset + k) - j));
      }
#line 290
      if (! tmp) {
#line 290
        return (-1);
      }
      {
#line 291
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 291
        if (! (j < k)) {
#line 291
          goto while_break___0;
        }
#line 291
        tmp___0 = offset;
#line 291
        offset ++;
#line 291
        tmp___1 = j;
#line 291
        j ++;
#line 291
        *(rbuf + tmp___0) = (char )*(boln + tmp___1);
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 293
    if ((int const   )*sub == 92) {
#line 293
      sub ++;
#line 293
      if ((int const   )*sub >= 49) {
#line 293
        if ((int const   )*sub <= 57) {
#line 293
          n = (int )((int const   )*sub - 48);
#line 293
          if (n <= (int )re_nsub) {
            {
#line 296
            j___0 = (int )(rm + n)->rm_so;
#line 296
            k___0 = (int )(rm + n)->rm_eo;
#line 297
            tmp___2 = resize_buffer((char **/* const  */)(& rbuf), (int */* const  */)(& rbufsz),
                                    (int const   )((offset + k___0) - j___0));
            }
#line 297
            if (! tmp___2) {
#line 297
              return (-1);
            }
            {
#line 298
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 298
              if (! (j___0 < k___0)) {
#line 298
                goto while_break___1;
              }
#line 298
              tmp___3 = offset;
#line 298
              offset ++;
#line 298
              tmp___4 = j___0;
#line 298
              j___0 ++;
#line 298
              *(rbuf + tmp___3) = (char )*(boln + tmp___4);
            }
            while_break___1: /* CIL Label */ ;
            }
          } else {
#line 293
            goto _L___1;
          }
        } else {
#line 293
          goto _L___1;
        }
      } else {
#line 293
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 302
      tmp___5 = resize_buffer((char **/* const  */)(& rbuf), (int */* const  */)(& rbufsz),
                              (int const   )(offset + 1));
      }
#line 302
      if (! tmp___5) {
#line 302
        return (-1);
      }
#line 303
      tmp___6 = offset;
#line 303
      offset ++;
#line 303
      *(rbuf + tmp___6) = (char )*sub;
    }
#line 284
    sub ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 306
  tmp___7 = resize_buffer((char **/* const  */)(& rbuf), (int */* const  */)(& rbufsz),
                          (int const   )(offset + 1));
  }
#line 306
  if (! tmp___7) {
#line 306
    return (-1);
  }
#line 307
  *(rbuf + offset) = (char)0;
#line 308
  return (offset);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
static int replace_matching_text(line_t const   * const  lp___0 , int const   gflags___0 ,
                                 int const   snum___0 ) 
{ 
  regmatch_t rm[30] ;
  char *txt ;
  char *tmp ;
  char const   *eot ;
  int i ;
  int offset ;
  bool changed ;
  bool tmp___0 ;
  int matchno ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 319
  tmp = get_sbuf_line(lp___0);
#line 319
  txt = tmp;
#line 321
  i = 0;
#line 321
  offset = 0;
#line 322
  changed = (bool )0;
  }
#line 324
  if (! txt) {
#line 324
    return (-1);
  }
  {
#line 325
  tmp___0 = isbinary();
  }
#line 325
  if (tmp___0) {
    {
#line 325
    nul_to_newline((char */* const  */)txt, lp___0->len);
    }
  }
  {
#line 326
  eot = (char const   *)(txt + lp___0->len);
#line 327
  tmp___8 = regexec((regex_t const   */* __restrict  */)global_pat, (char const   */* __restrict  */)txt,
                    (size_t )30, (regmatch_t */* __restrict  */)(rm), 0);
  }
#line 327
  if (! tmp___8) {
#line 329
    matchno = 0;
    {
#line 330
    while (1) {
      while_continue: /* CIL Label */ ;
#line 331
      if (! snum___0) {
#line 331
        goto _L;
      } else {
#line 331
        matchno ++;
#line 331
        if (snum___0 == (int const   )matchno) {
          _L: /* CIL Label */ 
          {
#line 333
          changed = (bool )1;
#line 333
          i = rm[0].rm_so;
#line 334
          tmp___1 = resize_buffer((char **/* const  */)(& rbuf), (int */* const  */)(& rbufsz),
                                  (int const   )(offset + i));
          }
#line 334
          if (! tmp___1) {
#line 334
            return (-1);
          }
          {
#line 335
          tmp___2 = isbinary();
          }
#line 335
          if (tmp___2) {
            {
#line 335
            newline_to_nul((char */* const  */)txt, (int const   )rm[0].rm_eo);
            }
          }
          {
#line 336
          memcpy((void */* __restrict  */)(rbuf + offset), (void const   */* __restrict  */)txt,
                 (size_t )i);
#line 336
          offset += i;
#line 337
          offset = apply_subst_template((char const   */* const  */)txt, (regmatch_t const   */* const  */)(rm),
                                        offset, (int const   )global_pat->re_nsub);
          }
#line 338
          if (offset < 0) {
#line 338
            return (-1);
          }
        } else {
          {
#line 342
          i = rm[0].rm_eo;
#line 343
          tmp___3 = resize_buffer((char **/* const  */)(& rbuf), (int */* const  */)(& rbufsz),
                                  (int const   )(offset + i));
          }
#line 343
          if (! tmp___3) {
#line 343
            return (-1);
          }
          {
#line 344
          tmp___4 = isbinary();
          }
#line 344
          if (tmp___4) {
            {
#line 344
            newline_to_nul((char */* const  */)txt, (int const   )i);
            }
          }
          {
#line 345
          memcpy((void */* __restrict  */)(rbuf + offset), (void const   */* __restrict  */)txt,
                 (size_t )i);
#line 345
          offset += i;
          }
        }
      }
#line 347
      txt += rm[0].rm_eo;
#line 330
      if (*txt) {
#line 330
        if (! changed) {
#line 330
          goto _L___0;
        } else
#line 330
        if (gflags___0 & 16) {
#line 330
          if (rm[0].rm_eo) {
            _L___0: /* CIL Label */ 
            {
#line 330
            tmp___5 = regexec((regex_t const   */* __restrict  */)global_pat, (char const   */* __restrict  */)txt,
                              (size_t )30, (regmatch_t */* __restrict  */)(rm), 1);
            }
#line 330
            if (tmp___5) {
#line 330
              goto while_break;
            }
          } else {
#line 330
            goto while_break;
          }
        } else {
#line 330
          goto while_break;
        }
      } else {
#line 330
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 351
    i = (int )(eot - (char const   *)txt);
#line 352
    tmp___6 = resize_buffer((char **/* const  */)(& rbuf), (int */* const  */)(& rbufsz),
                            (int const   )((offset + i) + 2));
    }
#line 352
    if (! tmp___6) {
#line 352
      return (-1);
    }
#line 353
    if (i > 0) {
#line 353
      if (! rm[0].rm_eo) {
#line 353
        if (gflags___0 & 16) {
          {
#line 354
          set_error_msg("Infinite substitution loop");
          }
#line 354
          return (-1);
        }
      }
    }
    {
#line 355
    tmp___7 = isbinary();
    }
#line 355
    if (tmp___7) {
      {
#line 355
      newline_to_nul((char */* const  */)txt, (int const   )i);
      }
    }
    {
#line 356
    memcpy((void */* __restrict  */)(rbuf + offset), (void const   */* __restrict  */)txt,
           (size_t )i);
#line 357
    memcpy((void */* __restrict  */)((rbuf + offset) + i), (void const   */* __restrict  */)"\n",
           (size_t )2);
    }
  }
#line 359
  if (changed) {
#line 359
    tmp___9 = (offset + i) + 1;
  } else {
#line 359
    tmp___9 = 0;
  }
#line 359
  return (tmp___9);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/ed-1.9/regex.c"
bool search_and_replace(int const   first_addr___0 , int const   second_addr___0 ,
                        int const   gflags___0 , int const   snum___0 , bool const   isglobal ) 
{ 
  int lc ;
  bool match_found ;
  line_t const   *lp___0 ;
  int tmp ;
  line_t *tmp___0 ;
  int size ;
  int tmp___1 ;
  char const   *txt ;
  char const   *eot ;
  undo_t *up ;
  int tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 369
  match_found = (bool )0;
#line 371
  set_current_addr(first_addr___0 - 1);
#line 372
  lc = 0;
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (lc <= (int )(second_addr___0 - first_addr___0))) {
#line 372
      goto while_break;
    }
    {
#line 374
    tmp = inc_current_addr();
#line 374
    tmp___0 = search_line_node((int const   )tmp);
#line 374
    lp___0 = (line_t const   *)tmp___0;
#line 375
    tmp___1 = replace_matching_text((line_t const   */* const  */)lp___0, gflags___0,
                                    snum___0);
#line 375
    size = tmp___1;
    }
#line 376
    if (size < 0) {
#line 376
      return ((bool )0);
    }
#line 377
    if (size) {
      {
#line 379
      txt = (char const   *)rbuf;
#line 380
      eot = (char const   *)(rbuf + size);
#line 381
      up = (undo_t *)0;
#line 382
      disable_interrupts();
#line 383
      tmp___2 = current_addr();
#line 383
      tmp___3 = current_addr();
#line 383
      tmp___4 = delete_lines((int const   )tmp___3, (int const   )tmp___2, isglobal);
      }
#line 383
      if (! tmp___4) {
        {
#line 384
        enable_interrupts();
        }
#line 384
        return ((bool )0);
      }
      {
#line 385
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 386
        tmp___5 = current_addr();
#line 386
        txt = put_sbuf_line((char const   */* const  */)txt, (int const   )size, (int const   )tmp___5);
        }
#line 387
        if (! txt) {
          {
#line 387
          enable_interrupts();
          }
#line 387
          return ((bool )0);
        }
#line 388
        if (up) {
          {
#line 388
          tmp___6 = current_addr();
#line 388
          up->tail = search_line_node((int const   )tmp___6);
          }
        } else {
          {
#line 391
          tmp___7 = current_addr();
#line 391
          tmp___8 = current_addr();
#line 391
          up = push_undo_atom((int const   )0, (int const   )tmp___8, (int const   )tmp___7);
          }
#line 392
          if (! up) {
            {
#line 392
            enable_interrupts();
            }
#line 392
            return ((bool )0);
          }
        }
#line 385
        if (! ((unsigned long )txt != (unsigned long )eot)) {
#line 385
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 396
      enable_interrupts();
#line 397
      match_found = (bool )1;
      }
    }
#line 372
    lc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  if (! match_found) {
#line 400
    if (! (gflags___0 & 1)) {
      {
#line 401
      set_error_msg("No match");
      }
#line 401
      return ((bool )0);
    }
  }
#line 402
  return ((bool )1);
}
}
#line 74 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 152 "/home/june/repo/benchmarks/collector/temp/ed-1.9/ed.h"
int window_columns(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
jmp_buf jmp_state  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static int mutex  =    0;
#line 37 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static int window_lines_  =    22;
#line 38 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static int window_columns_  =    72;
#line 39 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static bool sighup_pending  =    (bool )0;
#line 40 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static bool sigint_pending  =    (bool )0;
#line 43 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static void sighup_handler(int signum ) 
{ 
  char hb[7] ;
  char *s ;
  char *tmp ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int need_slash ;
  int tmp___2 ;
  char *hup ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 46
  if (mutex) {
#line 46
    sighup_pending = (bool )1;
  } else {
    {
#line 49
    hb[0] = (char )'e';
#line 49
    hb[1] = (char )'d';
#line 49
    hb[2] = (char )'.';
#line 49
    hb[3] = (char )'h';
#line 49
    hb[4] = (char )'u';
#line 49
    hb[5] = (char )'p';
#line 49
    hb[6] = (char )'\000';
#line 50
    sighup_pending = (bool )0;
#line 51
    tmp___9 = last_addr();
    }
#line 51
    if (tmp___9) {
      {
#line 51
      tmp___10 = modified();
      }
#line 51
      if (tmp___10) {
        {
#line 51
        tmp___11 = last_addr();
#line 51
        tmp___12 = write_file((char const   */* const  */)(hb), (char const   */* const  */)"w",
                              (int const   )1, (int const   )tmp___11);
        }
#line 51
        if (tmp___12 < 0) {
          {
#line 54
          tmp = getenv("HOME");
#line 54
          s = tmp;
          }
#line 55
          if (s) {
            {
#line 55
            tmp___0 = strlen((char const   *)s);
#line 55
            tmp___1 = tmp___0;
            }
          } else {
#line 55
            tmp___1 = (size_t )0;
          }
#line 55
          len = (int )tmp___1;
#line 56
          if (! len) {
#line 56
            tmp___2 = 1;
          } else
#line 56
          if ((int )*(s + (len - 1)) != 47) {
#line 56
            tmp___2 = 1;
          } else {
#line 56
            tmp___2 = 0;
          }
          {
#line 56
          need_slash = tmp___2;
#line 57
          tmp___6 = path_max((char const   *)0);
          }
#line 57
          if ((len + need_slash) + (int )sizeof(hb) < tmp___6) {
            {
#line 57
            tmp___4 = malloc((unsigned long )(len + need_slash) + sizeof(hb));
#line 57
            tmp___5 = (char *)tmp___4;
            }
          } else {
#line 57
            tmp___5 = (char *)0;
          }
#line 57
          hup = tmp___5;
#line 59
          if (len) {
#line 59
            if (hup) {
              {
#line 61
              memcpy((void */* __restrict  */)hup, (void const   */* __restrict  */)s,
                     (size_t )len);
              }
#line 62
              if (need_slash) {
#line 62
                *(hup + len) = (char )'/';
              }
              {
#line 63
              memcpy((void */* __restrict  */)((hup + len) + need_slash), (void const   */* __restrict  */)(hb),
                     sizeof(hb));
#line 64
              tmp___7 = last_addr();
#line 64
              tmp___8 = write_file((char const   */* const  */)hup, (char const   */* const  */)"w",
                                   (int const   )1, (int const   )tmp___7);
              }
#line 64
              if (tmp___8 >= 0) {
                {
#line 64
                exit(0);
                }
              }
            }
          }
          {
#line 66
          exit(1);
          }
        }
      }
    }
    {
#line 68
    exit(0);
    }
  }
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static void sigint_handler(int signum ) 
{ 
  sigset_t set ;

  {
#line 75
  if (mutex) {
#line 75
    sigint_pending = (bool )1;
  } else {
    {
#line 79
    sigint_pending = (bool )0;
#line 80
    sigemptyset(& set);
#line 81
    sigaddset(& set, signum);
#line 82
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)0);
#line 83
    longjmp((struct __jmp_buf_tag *)(jmp_state), -1);
    }
  }
#line 85
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static void sigwinch_handler(int signum ) 
{ 
  struct winsize ws ;
  int tmp ;

  {
  {
#line 93
  tmp = ioctl(0, 21523UL, (char *)(& ws));
  }
#line 93
  if (tmp >= 0) {
#line 96
    if ((int )ws.ws_row > 2) {
#line 96
      if ((int )ws.ws_row < 600) {
#line 96
        window_lines_ = (int )ws.ws_row - 2;
      }
    }
#line 97
    if ((int )ws.ws_col > 8) {
#line 97
      if ((int )ws.ws_col < 1800) {
#line 97
        window_columns_ = (int )ws.ws_col - 8;
      }
    }
  }
#line 101
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static int set_signal(int signum , void (*handler)(int  ) ) 
{ 
  struct sigaction new_action ;
  int tmp ;

  {
  {
#line 108
  new_action.__sigaction_handler.sa_handler = handler;
#line 109
  sigemptyset(& new_action.sa_mask);
#line 111
  new_action.sa_flags = 268435456;
#line 115
  tmp = sigaction(signum, (struct sigaction  const  */* __restrict  */)(& new_action),
                  (struct sigaction */* __restrict  */)0);
  }
#line 115
  return (tmp);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
void enable_interrupts(void) 
{ 


  {
#line 121
  mutex --;
#line 121
  if (mutex <= 0) {
#line 123
    mutex = 0;
#line 124
    if (sighup_pending) {
      {
#line 124
      sighup_handler(1);
      }
    }
#line 125
    if (sigint_pending) {
      {
#line 125
      sigint_handler(2);
      }
    }
  }
#line 127
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
void disable_interrupts(void) 
{ 


  {
#line 130
  mutex ++;
#line 130
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
void set_signals(void) 
{ 
  int tmp ;

  {
  {
#line 136
  sigwinch_handler(28);
#line 137
  tmp = isatty(0);
  }
#line 137
  if (tmp) {
    {
#line 137
    set_signal(28, & sigwinch_handler);
    }
  }
  {
#line 139
  set_signal(1, & sighup_handler);
#line 140
  set_signal(3, (void (*)(int  ))1);
#line 141
  set_signal(2, & sigint_handler);
  }
#line 142
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
void set_window_lines(int const   lines ) 
{ 


  {
#line 145
  window_lines_ = (int )lines;
#line 145
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
int window_columns(void) 
{ 


  {
#line 146
  return (window_columns_);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
int window_lines(void) 
{ 


  {
#line 147
  return (window_lines_);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
bool parse_int(int * const  i , char const   * const  str , char const   ** const  tail ) 
{ 
  char *tmp ;
  long li ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 156
  tmp___0 = __errno_location();
#line 156
  *tmp___0 = 0;
#line 157
  li = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tmp),
              10);
#line 157
  *i = (int )li;
  }
#line 158
  if (tail) {
#line 158
    *tail = (char const   *)tmp;
  }
#line 159
  if ((unsigned long )tmp == (unsigned long )str) {
    {
#line 161
    set_error_msg("Bad numerical result");
#line 162
    *i = 0;
    }
#line 163
    return ((bool )0);
  }
  {
#line 165
  tmp___1 = __errno_location();
  }
#line 165
  if (*tmp___1 == 34) {
    {
#line 167
    set_error_msg("Numerical result out of range");
#line 168
    *i = 0;
    }
#line 169
    return ((bool )0);
  } else
#line 165
  if (li > 2147483647L) {
    {
#line 167
    set_error_msg("Numerical result out of range");
#line 168
    *i = 0;
    }
#line 169
    return ((bool )0);
  } else
#line 165
  if (li < (-0x7FFFFFFF-1)) {
    {
#line 167
    set_error_msg("Numerical result out of range");
#line 168
    *i = 0;
    }
#line 169
    return ((bool )0);
  }
#line 171
  return ((bool )1);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
bool resize_buffer(char ** const  buf___9 , int * const  size , int const   min_size ) 
{ 
  int new_size ;
  int tmp ;
  void *new_buf ;
  int *tmp___0 ;

  {
#line 178
  if (*size < (int )min_size) {
#line 180
    if (min_size < 512) {
#line 180
      tmp = 512;
    } else {
#line 180
      tmp = (int )((min_size / 512) * 1024);
    }
    {
#line 180
    new_size = tmp;
#line 181
    new_buf = (void *)0;
#line 182
    disable_interrupts();
    }
#line 183
    if (*buf___9) {
      {
#line 183
      new_buf = realloc((void *)*buf___9, (size_t )new_size);
      }
    } else {
      {
#line 184
      new_buf = malloc((size_t )new_size);
      }
    }
#line 185
    if (! new_buf) {
      {
#line 187
      tmp___0 = __errno_location();
#line 187
      show_strerror((char const   */* const  */)0, (int const   )*tmp___0);
#line 188
      set_error_msg("Memory exhausted");
#line 189
      enable_interrupts();
      }
#line 190
      return ((bool )0);
    }
    {
#line 192
    *size = new_size;
#line 193
    *buf___9 = (char *)new_buf;
#line 194
    enable_interrupts();
    }
  }
#line 196
  return ((bool )1);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
bool resize_line_buffer(line_t const   *** const  buf___9 , int * const  size , int const   min_size ) 
{ 
  int new_size ;
  int tmp ;
  void *new_buf ;
  int *tmp___0 ;

  {
#line 204
  if (*size < (int )min_size) {
#line 206
    if (min_size < 512) {
#line 206
      tmp = 512;
    } else {
#line 206
      tmp = (int )((min_size / 512) * 1024);
    }
    {
#line 206
    new_size = tmp;
#line 207
    new_buf = (void *)0;
#line 208
    disable_interrupts();
    }
#line 209
    if (*buf___9) {
      {
#line 209
      new_buf = realloc((void *)*buf___9, (size_t )new_size);
      }
    } else {
      {
#line 210
      new_buf = malloc((size_t )new_size);
      }
    }
#line 211
    if (! new_buf) {
      {
#line 213
      tmp___0 = __errno_location();
#line 213
      show_strerror((char const   */* const  */)0, (int const   )*tmp___0);
#line 214
      set_error_msg("Memory exhausted");
#line 215
      enable_interrupts();
      }
#line 216
      return ((bool )0);
    }
    {
#line 218
    *size = new_size;
#line 219
    *buf___9 = (line_t const   **)new_buf;
#line 220
    enable_interrupts();
    }
  }
#line 222
  return ((bool )1);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
bool resize_undo_buffer(undo_t ** const  buf___9 , int * const  size , int const   min_size ) 
{ 
  int new_size ;
  int tmp ;
  void *new_buf ;
  int *tmp___0 ;

  {
#line 230
  if (*size < (int )min_size) {
#line 232
    if (min_size < 512) {
#line 232
      tmp = 512;
    } else {
#line 232
      tmp = (int )((min_size / 512) * 1024);
    }
    {
#line 232
    new_size = tmp;
#line 233
    new_buf = (void *)0;
#line 234
    disable_interrupts();
    }
#line 235
    if (*buf___9) {
      {
#line 235
      new_buf = realloc((void *)*buf___9, (size_t )new_size);
      }
    } else {
      {
#line 236
      new_buf = malloc((size_t )new_size);
      }
    }
#line 237
    if (! new_buf) {
      {
#line 239
      tmp___0 = __errno_location();
#line 239
      show_strerror((char const   */* const  */)0, (int const   )*tmp___0);
#line 240
      set_error_msg("Memory exhausted");
#line 241
      enable_interrupts();
      }
#line 242
      return ((bool )0);
    }
    {
#line 244
    *size = new_size;
#line 245
    *buf___9 = (undo_t *)new_buf;
#line 246
    enable_interrupts();
    }
  }
#line 248
  return ((bool )1);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static char *buf___5  =    (char *)0;
#line 256 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
static int bufsz___5  =    0;
#line 253 "/home/june/repo/benchmarks/collector/temp/ed-1.9/signal.c"
char const   *strip_escapes(char const   *p ) 
{ 
  int len ;
  size_t tmp ;
  int i ;
  bool tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;

  {
  {
#line 257
  tmp = strlen(p);
#line 257
  len = (int )tmp;
#line 258
  i = 0;
#line 260
  tmp___0 = resize_buffer((char **/* const  */)(& buf___5), (int */* const  */)(& bufsz___5),
                          (int const   )(len + 1));
  }
#line 260
  if (! tmp___0) {
#line 260
    return ((char const   *)0);
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    tmp___1 = i;
#line 262
    i ++;
#line 262
    if ((int const   )*p == 92) {
#line 262
      p ++;
#line 262
      tmp___2 = (char )*p;
    } else {
#line 262
      tmp___2 = (char )*p;
    }
#line 262
    *(buf___5 + tmp___1) = tmp___2;
#line 262
    if (! tmp___2) {
#line 262
      goto while_break;
    }
#line 263
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return ((char const   *)buf___5);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 538
extern int getchar(void) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static void put_tty_line(char const   *p , int len , int const   gflags___0 ) 
{ 
  char escapes[9] ;
  char escchars[9] ;
  int col ;
  int tmp ;
  unsigned char ch ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *p___0 ;
  char *tmp___2 ;
  bool tmp___3 ;

  {
#line 31
  escapes[0] = (char )'\a';
#line 31
  escapes[1] = (char )'\b';
#line 31
  escapes[2] = (char )'\f';
#line 31
  escapes[3] = (char )'\n';
#line 31
  escapes[4] = (char )'\r';
#line 31
  escapes[5] = (char )'\t';
#line 31
  escapes[6] = (char )'\v';
#line 31
  escapes[7] = (char )'\\';
#line 31
  escapes[8] = (char )'\000';
#line 32
  escchars[0] = (char )'a';
#line 32
  escchars[1] = (char )'b';
#line 32
  escchars[2] = (char )'f';
#line 32
  escchars[3] = (char )'n';
#line 32
  escchars[4] = (char )'r';
#line 32
  escchars[5] = (char )'t';
#line 32
  escchars[6] = (char )'v';
#line 32
  escchars[7] = (char )'\\';
#line 32
  escchars[8] = (char )'\000';
#line 33
  col = 0;
#line 35
  if (gflags___0 & 4) {
    {
#line 35
    tmp = current_addr();
#line 35
    printf((char const   */* __restrict  */)"%d\t", tmp);
#line 35
    col = 8;
    }
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    len --;
#line 36
    if (! (len >= 0)) {
#line 36
      goto while_break;
    }
#line 38
    tmp___0 = p;
#line 38
    p ++;
#line 38
    ch = (unsigned char )*tmp___0;
#line 39
    if (! (gflags___0 & 2)) {
      {
#line 39
      putchar((int )ch);
      }
    } else {
      {
#line 42
      col ++;
#line 42
      tmp___1 = window_columns();
      }
#line 42
      if (col > tmp___1) {
        {
#line 42
        col = 1;
#line 42
        fputs((char const   */* __restrict  */)"\\\n", (FILE */* __restrict  */)stdout);
        }
      }
#line 43
      if ((int )ch >= 32) {
#line 43
        if ((int )ch <= 126) {
#line 43
          if ((int )ch != 92) {
            {
#line 43
            putchar((int )ch);
            }
          } else {
#line 43
            goto _L___0;
          }
        } else {
#line 43
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 46
        tmp___2 = strchr((char const   *)(escapes), (int )ch);
#line 46
        p___0 = tmp___2;
#line 47
        col ++;
#line 47
        putchar('\\');
        }
#line 48
        if (ch) {
#line 48
          if (p___0) {
            {
#line 48
            putchar((int )escchars[p___0 - escapes]);
            }
          } else {
            {
#line 51
            col += 2;
#line 52
            putchar((((int )ch >> 6) & 7) + 48);
#line 53
            putchar((((int )ch >> 3) & 7) + 48);
#line 54
            putchar(((int )ch & 7) + 48);
            }
          }
        } else {
          {
#line 51
          col += 2;
#line 52
          putchar((((int )ch >> 6) & 7) + 48);
#line 53
          putchar((((int )ch >> 3) & 7) + 48);
#line 54
          putchar(((int )ch & 7) + 48);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  tmp___3 = traditional();
  }
#line 59
  if (! tmp___3) {
#line 59
    if (gflags___0 & 2) {
      {
#line 59
      putchar('$');
      }
    }
  }
  {
#line 60
  putchar('\n');
  }
#line 61
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
bool display_lines(int from , int const   to , int const   gflags___0 ) 
{ 
  line_t *ep ;
  int tmp ;
  line_t *tmp___0 ;
  line_t *bp ;
  line_t *tmp___1 ;
  char const   *s ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 67
  tmp = inc_addr((int )to);
#line 67
  tmp___0 = search_line_node((int const   )tmp);
#line 67
  ep = tmp___0;
#line 68
  tmp___1 = search_line_node((int const   )from);
#line 68
  bp = tmp___1;
  }
#line 70
  if (! from) {
    {
#line 70
    set_error_msg("Invalid address");
    }
#line 70
    return ((bool )0);
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((unsigned long )bp != (unsigned long )ep)) {
#line 71
      goto while_break;
    }
    {
#line 73
    tmp___2 = get_sbuf_line((line_t const   */* const  */)bp);
#line 73
    s = (char const   *)tmp___2;
    }
#line 74
    if (! s) {
#line 74
      return ((bool )0);
    }
    {
#line 75
    tmp___3 = from;
#line 75
    from ++;
#line 75
    set_current_addr((int const   )tmp___3);
#line 76
    put_tty_line(s, bp->len, gflags___0);
#line 77
    bp = bp->q_forw;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return ((bool )1);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static bool trailing_escape(char const   * const  s , int len ) 
{ 
  bool odd_escape ;

  {
#line 86
  odd_escape = (bool )0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    len --;
#line 87
    if (len >= 0) {
#line 87
      if (! ((int const   )*(s + len) == 92)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 87
    odd_escape = (bool )(! odd_escape);
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (odd_escape);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static char *buf___6  =    (char *)0;
#line 98 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static int bufsz___6  =    0;
#line 94 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
bool get_extended_line(char const   ** const  ibufpp , int * const  lenp , bool const   strip_escaped_newlines ) 
{ 
  int len ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int len2 ;
  char const   *s ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
#line 101
  len = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    tmp = len;
#line 101
    len ++;
#line 101
    if (! ((int const   )*(*ibufpp + tmp) != 10)) {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (len < 2) {
#line 102
    goto _L;
  } else {
    {
#line 102
    tmp___0 = trailing_escape((char const   */* const  */)*ibufpp, len - 1);
    }
#line 102
    if (! tmp___0) {
      _L: /* CIL Label */ 
#line 103
      if (lenp) {
#line 103
        *lenp = len;
      }
#line 103
      return ((bool )1);
    }
  }
  {
#line 104
  tmp___1 = resize_buffer((char **/* const  */)(& buf___6), (int */* const  */)(& bufsz___6),
                          (int const   )len);
  }
#line 104
  if (! tmp___1) {
#line 104
    return ((bool )0);
  }
  {
#line 105
  memcpy((void */* __restrict  */)buf___6, (void const   */* __restrict  */)*ibufpp,
         (size_t )len);
#line 106
  len --;
#line 106
  *(buf___6 + (len - 1)) = (char )'\n';
  }
#line 107
  if (strip_escaped_newlines) {
#line 107
    len --;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 111
    tmp___2 = get_tty_line((int */* const  */)(& len2));
#line 111
    s = tmp___2;
    }
#line 112
    if (! s) {
#line 112
      return ((bool )0);
    }
#line 113
    if (len2 == 0) {
      {
#line 114
      set_error_msg("Unexpected end-of-file");
      }
#line 114
      return ((bool )0);
    } else
#line 113
    if ((int const   )*(s + (len2 - 1)) != 10) {
      {
#line 114
      set_error_msg("Unexpected end-of-file");
      }
#line 114
      return ((bool )0);
    }
    {
#line 115
    tmp___3 = resize_buffer((char **/* const  */)(& buf___6), (int */* const  */)(& bufsz___6),
                            (int const   )(len + len2));
    }
#line 115
    if (! tmp___3) {
#line 115
      return ((bool )0);
    }
    {
#line 116
    memcpy((void */* __restrict  */)(buf___6 + len), (void const   */* __restrict  */)s,
           (size_t )len2);
#line 117
    len += len2;
    }
#line 118
    if (len2 < 2) {
#line 118
      goto while_break___0;
    } else {
      {
#line 118
      tmp___4 = trailing_escape((char const   */* const  */)buf___6, len - 1);
      }
#line 118
      if (! tmp___4) {
#line 118
        goto while_break___0;
      }
    }
#line 119
    len --;
#line 119
    *(buf___6 + (len - 1)) = (char )'\n';
#line 120
    if (strip_escaped_newlines) {
#line 120
      len --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 122
  tmp___5 = resize_buffer((char **/* const  */)(& buf___6), (int */* const  */)(& bufsz___6),
                          (int const   )(len + 1));
  }
#line 122
  if (! tmp___5) {
#line 122
    return ((bool )0);
  }
#line 123
  *(buf___6 + len) = (char)0;
#line 124
  *ibufpp = (char const   *)buf___6;
#line 125
  if (lenp) {
#line 125
    *lenp = len;
  }
#line 126
  return ((bool )1);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static char *buf___7  =    (char *)0;
#line 136 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static int bufsz___7  =    0;
#line 133 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
char const   *get_tty_line(int * const  sizep ) 
{ 
  int i ;
  int c ;
  int tmp ;
  bool tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 137
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    tmp = getchar();
#line 141
    c = tmp;
#line 142
    tmp___0 = resize_buffer((char **/* const  */)(& buf___7), (int */* const  */)(& bufsz___7),
                            (int const   )(i + 2));
    }
#line 142
    if (! tmp___0) {
#line 143
      if (sizep) {
#line 143
        *sizep = 0;
      }
#line 143
      return ((char const   *)0);
    }
#line 144
    if (c == -1) {
      {
#line 146
      tmp___2 = ferror(stdin);
      }
#line 146
      if (tmp___2) {
        {
#line 148
        tmp___1 = __errno_location();
#line 148
        show_strerror((char const   */* const  */)"stdin", (int const   )*tmp___1);
#line 148
        set_error_msg("Cannot read stdin");
#line 149
        clearerr(stdin);
        }
#line 149
        if (sizep) {
#line 149
          *sizep = 0;
        }
#line 150
        return ((char const   *)0);
      }
      {
#line 152
      tmp___3 = feof(stdin);
      }
#line 152
      if (tmp___3) {
        {
#line 154
        clearerr(stdin);
#line 155
        *(buf___7 + i) = (char)0;
        }
#line 155
        if (sizep) {
#line 155
          *sizep = i;
        }
#line 156
        return ((char const   *)buf___7);
      }
    } else {
#line 161
      tmp___4 = i;
#line 161
      i ++;
#line 161
      *(buf___7 + tmp___4) = (char )c;
#line 161
      if (! c) {
        {
#line 161
        set_binary();
        }
      }
#line 161
      if (c != 10) {
#line 161
        goto while_continue;
      }
#line 162
      *(buf___7 + i) = (char)0;
#line 162
      if (sizep) {
#line 162
        *sizep = i;
      }
#line 163
      return ((char const   *)buf___7);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 175
static char const   *read_stream_line(FILE * const  fp , int * const  sizep , bool * const  newline_added_nowp ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static char *buf___8  =    (char *)0;
#line 176 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static int bufsz___8  =    0;
#line 172 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static char const   *read_stream_line(FILE * const  fp , int * const  sizep , bool * const  newline_added_nowp ) 
{ 
  int c ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 177
  i = 0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 181
    tmp = resize_buffer((char **/* const  */)(& buf___8), (int */* const  */)(& bufsz___8),
                        (int const   )(i + 2));
    }
#line 181
    if (! tmp) {
#line 181
      return ((char const   *)0);
    }
    {
#line 182
    c = _IO_getc((_IO_FILE *)fp);
    }
#line 182
    if (c == -1) {
#line 182
      goto while_break;
    }
#line 183
    tmp___0 = i;
#line 183
    i ++;
#line 183
    *(buf___8 + tmp___0) = (char )c;
#line 184
    if (! c) {
      {
#line 184
      set_binary();
      }
    } else
#line 184
    if (c == 10) {
#line 184
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  *(buf___8 + i) = (char)0;
#line 187
  if (c == -1) {
    {
#line 189
    tmp___3 = ferror((FILE *)fp);
    }
#line 189
    if (tmp___3) {
      {
#line 191
      tmp___1 = __errno_location();
#line 191
      show_strerror((char const   */* const  */)0, (int const   )*tmp___1);
#line 192
      set_error_msg("Cannot read input file");
      }
#line 193
      return ((char const   *)0);
    } else
#line 195
    if (i) {
      {
#line 197
      *(buf___8 + i) = (char )'\n';
#line 197
      *(buf___8 + (i + 1)) = (char)0;
#line 197
      *newline_added_nowp = (bool )1;
#line 198
      tmp___2 = isbinary();
      }
#line 198
      if (! tmp___2) {
#line 198
        i ++;
      }
    }
  }
#line 201
  *sizep = i;
#line 202
  return ((char const   *)buf___8);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static long read_stream(FILE * const  fp , int const   addr ) 
{ 
  line_t *lp___0 ;
  line_t *tmp ;
  undo_t *up ;
  long total_size ;
  bool o_isbinary ;
  bool tmp___0 ;
  bool appended ;
  int tmp___1 ;
  bool newline_added_now ;
  int size ;
  char const   *s ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;

  {
  {
#line 209
  tmp = search_line_node(addr);
#line 209
  lp___0 = tmp;
#line 210
  up = (undo_t *)0;
#line 211
  total_size = 0L;
#line 212
  tmp___0 = isbinary();
#line 212
  o_isbinary = tmp___0;
#line 213
  tmp___1 = last_addr();
#line 213
  appended = (bool )(addr == (int const   )tmp___1);
#line 214
  newline_added_now = (bool )0;
#line 216
  set_current_addr(addr);
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 219
    size = 0;
#line 220
    tmp___2 = read_stream_line(fp, (int */* const  */)(& size), (bool */* const  */)(& newline_added_now));
#line 220
    s = tmp___2;
    }
#line 221
    if (! s) {
#line 221
      return (-1L);
    }
#line 222
    if (size > 0) {
#line 222
      total_size += (long )size;
    } else {
#line 223
      goto while_break;
    }
    {
#line 224
    disable_interrupts();
#line 225
    tmp___3 = current_addr();
#line 225
    tmp___4 = put_sbuf_line((char const   */* const  */)s, (int const   )((unsigned int )size + (unsigned int )newline_added_now),
                            (int const   )tmp___3);
    }
#line 225
    if (! tmp___4) {
      {
#line 226
      enable_interrupts();
      }
#line 226
      return (-1L);
    }
#line 227
    lp___0 = lp___0->q_forw;
#line 228
    if (up) {
#line 228
      up->tail = lp___0;
    } else {
      {
#line 231
      tmp___5 = current_addr();
#line 231
      tmp___6 = current_addr();
#line 231
      up = push_undo_atom((int const   )0, (int const   )tmp___6, (int const   )tmp___5);
      }
#line 232
      if (! up) {
        {
#line 232
        enable_interrupts();
        }
#line 232
        return (-1L);
      }
    }
    {
#line 234
    enable_interrupts();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (addr) {
#line 236
    if (appended) {
#line 236
      if (total_size) {
#line 236
        if (o_isbinary) {
          {
#line 236
          tmp___8 = newline_added();
          }
#line 236
          if (tmp___8) {
            {
#line 237
            fputs((char const   */* __restrict  */)"Newline inserted\n", (FILE */* __restrict  */)stderr);
            }
          } else {
#line 236
            goto _L___2;
          }
        } else {
#line 236
          goto _L___2;
        }
      } else {
#line 236
        goto _L___2;
      }
    } else {
#line 236
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 238
  if (newline_added_now) {
#line 238
    if (! appended) {
      {
#line 239
      fputs((char const   */* __restrict  */)"Newline appended\n", (FILE */* __restrict  */)stderr);
      }
    } else {
      {
#line 238
      tmp___7 = isbinary();
      }
#line 238
      if (! tmp___7) {
        {
#line 239
        fputs((char const   */* __restrict  */)"Newline appended\n", (FILE */* __restrict  */)stderr);
        }
      }
    }
  }
  {
#line 240
  tmp___9 = isbinary();
  }
#line 240
  if (tmp___9) {
#line 240
    if (! o_isbinary) {
#line 240
      if (newline_added_now) {
#line 240
        if (! appended) {
#line 241
          total_size ++;
        }
      }
    }
  }
#line 242
  if (! total_size) {
#line 242
    newline_added_now = (bool )1;
  }
#line 243
  if (appended) {
#line 243
    if (newline_added_now) {
      {
#line 243
      set_newline_added();
      }
    }
  }
#line 244
  return (total_size);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
int read_file(char const   * const  filename , int const   addr ) 
{ 
  FILE *fp ;
  long size ;
  int ret ;
  char const   *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 255
  if ((int const   )*filename == 33) {
    {
#line 255
    fp = popen((char const   *)(filename + 1), "r");
    }
  } else {
    {
#line 256
    tmp = strip_escapes((char const   *)filename);
#line 256
    fp = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"r");
    }
  }
#line 257
  if (! fp) {
    {
#line 259
    tmp___0 = __errno_location();
#line 259
    show_strerror(filename, (int const   )*tmp___0);
#line 260
    set_error_msg("Cannot open input file");
    }
#line 261
    return (-1);
  }
  {
#line 263
  size = read_stream((FILE */* const  */)fp, addr);
  }
#line 264
  if (size < 0L) {
#line 264
    return (-1);
  }
#line 265
  if ((int const   )*filename == 33) {
    {
#line 265
    ret = pclose(fp);
    }
  } else {
    {
#line 265
    ret = fclose(fp);
    }
  }
#line 266
  if (ret != 0) {
    {
#line 268
    tmp___1 = __errno_location();
#line 268
    show_strerror(filename, (int const   )*tmp___1);
#line 269
    set_error_msg("Cannot close input file");
    }
#line 270
    return (-1);
  }
  {
#line 272
  tmp___2 = scripted();
  }
#line 272
  if (! tmp___2) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lu\n",
            size);
    }
  }
  {
#line 273
  tmp___3 = current_addr();
  }
#line 273
  return (tmp___3 - (int )addr);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
static long write_stream(FILE * const  fp , int from , int const   to ) 
{ 
  line_t *lp___0 ;
  line_t *tmp ;
  long size ;
  int len ;
  char *p ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 280
  tmp = search_line_node((int const   )from);
#line 280
  lp___0 = tmp;
#line 281
  size = 0L;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (from) {
#line 283
      if (! (from <= (int )to)) {
#line 283
        goto while_break;
      }
    } else {
#line 283
      goto while_break;
    }
    {
#line 286
    tmp___0 = get_sbuf_line((line_t const   */* const  */)lp___0);
#line 286
    p = tmp___0;
    }
#line 287
    if (! p) {
#line 287
      return (-1L);
    }
    {
#line 288
    len = lp___0->len;
#line 289
    tmp___2 = last_addr();
    }
#line 289
    if (from != tmp___2) {
#line 290
      tmp___1 = len;
#line 290
      len ++;
#line 290
      *(p + tmp___1) = (char )'\n';
    } else {
      {
#line 289
      tmp___3 = isbinary();
      }
#line 289
      if (tmp___3) {
        {
#line 289
        tmp___4 = newline_added();
        }
#line 289
        if (! tmp___4) {
#line 290
          tmp___1 = len;
#line 290
          len ++;
#line 290
          *(p + tmp___1) = (char )'\n';
        }
      } else {
#line 290
        tmp___1 = len;
#line 290
        len ++;
#line 290
        *(p + tmp___1) = (char )'\n';
      }
    }
#line 291
    size += (long )len;
    {
#line 292
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 292
      len --;
#line 292
      if (! (len >= 0)) {
#line 292
        goto while_break___0;
      }
      {
#line 293
      tmp___6 = p;
#line 293
      p ++;
#line 293
      tmp___7 = fputc((int )*tmp___6, (FILE *)fp);
      }
#line 293
      if (tmp___7 == -1) {
        {
#line 295
        tmp___5 = __errno_location();
#line 295
        show_strerror((char const   */* const  */)0, (int const   )*tmp___5);
#line 296
        set_error_msg("Cannot write file");
        }
#line 297
        return (-1L);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 299
    from ++;
#line 299
    lp___0 = lp___0->q_forw;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (size);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/ed-1.9/io.c"
int write_file(char const   * const  filename , char const   * const  mode , int const   from ,
               int const   to ) 
{ 
  FILE *fp ;
  long size ;
  int ret ;
  char const   *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 313
  if ((int const   )*filename == 33) {
    {
#line 313
    fp = popen((char const   *)(filename + 1), "w");
    }
  } else {
    {
#line 314
    tmp = strip_escapes((char const   *)filename);
#line 314
    fp = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)mode);
    }
  }
#line 315
  if (! fp) {
    {
#line 317
    tmp___0 = __errno_location();
#line 317
    show_strerror(filename, (int const   )*tmp___0);
#line 318
    set_error_msg("Cannot open output file");
    }
#line 319
    return (-1);
  }
  {
#line 321
  size = write_stream((FILE */* const  */)fp, (int )from, to);
  }
#line 322
  if (size < 0L) {
#line 322
    return (-1);
  }
#line 323
  if ((int const   )*filename == 33) {
    {
#line 323
    ret = pclose(fp);
    }
  } else {
    {
#line 323
    ret = fclose(fp);
    }
  }
#line 324
  if (ret != 0) {
    {
#line 326
    tmp___1 = __errno_location();
#line 326
    show_strerror(filename, (int const   )*tmp___1);
#line 327
    set_error_msg("Cannot close output file");
    }
#line 328
    return (-1);
  }
  {
#line 330
  tmp___2 = scripted();
  }
#line 330
  if (! tmp___2) {
    {
#line 330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lu\n",
            size);
    }
  }
#line 331
  if (from) {
#line 331
    if (from <= to) {
#line 331
      tmp___3 = (to - from) + 1;
    } else {
#line 331
      tmp___3 = (int const   )0;
    }
  } else {
#line 331
    tmp___3 = (int const   )0;
  }
#line 331
  return ((int )tmp___3);
}
}
