/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef unsigned int size_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 27 "./unitypes.h"
typedef uint32_t ucs4_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 24 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 61 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
struct __anonstruct_slaves_entry_t_49 {
   sig_atomic_t volatile   used ;
   pid_t volatile   child ;
};
#line 61 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
typedef struct __anonstruct_slaves_entry_t_49 slaves_entry_t;
#line 324 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
union __anonunion_50 {
   int __in ;
   int __i ;
};
#line 339 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
union __anonunion_51 {
   int __in ;
   int __i ;
};
#line 341 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 345 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 336 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 350 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 352 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 359 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 80 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 129 "/usr/include/stdint.h"
typedef unsigned int uintptr_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 44 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
enum bitset_type {
    BITSET_ARRAY = 0,
    BITSET_LIST = 1,
    BITSET_TABLE = 2,
    BITSET_VARRAY = 3,
    BITSET_TYPE_NUM = 4,
    BITSET_STATS = 5
} ;
#line 53 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
typedef unsigned long bitset_word;
#line 62 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
typedef size_t bitset_bindex;
#line 65 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
typedef size_t bitset_windex;
#line 87
struct bitset_vtable;
#line 87 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
struct bbitset_struct {
   struct bitset_vtable  const  *vtable ;
   bitset_windex cindex ;
   bitset_windex csize ;
   bitset_word *cdata ;
   bitset_bindex n_bits ;
};
#line 102
union bitset_union;
#line 102 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
typedef union bitset_union *bitset;
#line 114 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
struct bitset_vtable {
   void (*set)(bitset  , bitset_bindex  ) ;
   void (*reset)(bitset  , bitset_bindex  ) ;
   _Bool (*toggle)(bitset  , bitset_bindex  ) ;
   _Bool (*test)(bitset  , bitset_bindex  ) ;
   bitset_bindex (*resize)(bitset  , bitset_bindex  ) ;
   bitset_bindex (*size)(bitset  ) ;
   bitset_bindex (*count)(bitset  ) ;
   _Bool (*empty_p)(bitset  ) ;
   void (*ones)(bitset  ) ;
   void (*zero)(bitset  ) ;
   void (*copy)(bitset  , bitset  ) ;
   _Bool (*disjoint_p)(bitset  , bitset  ) ;
   _Bool (*equal_p)(bitset  , bitset  ) ;
   void (*not_)(bitset  , bitset  ) ;
   _Bool (*subset_p)(bitset  , bitset  ) ;
   void (*and_)(bitset  , bitset  , bitset  ) ;
   _Bool (*and_cmp)(bitset  , bitset  , bitset  ) ;
   void (*andn)(bitset  , bitset  , bitset  ) ;
   _Bool (*andn_cmp)(bitset  , bitset  , bitset  ) ;
   void (*or_)(bitset  , bitset  , bitset  ) ;
   _Bool (*or_cmp)(bitset  , bitset  , bitset  ) ;
   void (*xor_)(bitset  , bitset  , bitset  ) ;
   _Bool (*xor_cmp)(bitset  , bitset  , bitset  ) ;
   void (*and_or)(bitset  , bitset  , bitset  , bitset  ) ;
   _Bool (*and_or_cmp)(bitset  , bitset  , bitset  , bitset  ) ;
   void (*andn_or)(bitset  , bitset  , bitset  , bitset  ) ;
   _Bool (*andn_or_cmp)(bitset  , bitset  , bitset  , bitset  ) ;
   void (*or_and)(bitset  , bitset  , bitset  , bitset  ) ;
   _Bool (*or_and_cmp)(bitset  , bitset  , bitset  , bitset  ) ;
   bitset_bindex (*list)(bitset  , bitset_bindex * , bitset_bindex  , bitset_bindex * ) ;
   bitset_bindex (*list_reverse)(bitset  , bitset_bindex * , bitset_bindex  , bitset_bindex * ) ;
   void (*free)(bitset  ) ;
   enum bitset_type type ;
};
#line 48 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
struct abitset_struct {
   struct bbitset_struct b ;
   bitset_word words[1] ;
};
#line 48
struct ebitset_elt_struct;
#line 48 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
struct ebitset_struct {
   struct bbitset_struct b ;
   bitset_windex size ;
   struct ebitset_elt_struct **elts ;
};
#line 48
struct lbitset_elt_struct;
#line 48 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
struct lbitset_struct {
   struct bbitset_struct b ;
   struct lbitset_elt_struct *head ;
   struct lbitset_elt_struct *tail ;
};
#line 48 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
struct bitset_stats_struct {
   struct bbitset_struct b ;
   bitset bset ;
};
#line 48 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
struct vbitset_struct {
   struct bbitset_struct b ;
   bitset_windex size ;
};
#line 48 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
union bitset_union {
   struct bbitset_struct b ;
   struct abitset_struct a ;
   struct ebitset_struct e ;
   struct lbitset_struct l ;
   struct bitset_stats_struct s ;
   struct vbitset_struct v ;
};
#line 326 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef int wchar_t;
#line 355 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef unsigned int wint_t;
#line 52 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.h"
enum __anonenum_arg_type_28 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 52 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.h"
typedef enum __anonenum_arg_type_28 arg_type;
#line 94 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.h"
union __anonunion_a_30 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 94 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.h"
struct __anonstruct_argument_29 {
   arg_type type ;
   union __anonunion_a_30 a ;
};
#line 94 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.h"
typedef struct __anonstruct_argument_29 argument;
#line 144 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.h"
struct __anonstruct_arguments_31 {
   size_t count ;
   argument *arg ;
   argument direct_alloc_arg[7] ;
};
#line 144 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.h"
typedef struct __anonstruct_arguments_31 arguments;
#line 56 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-parse.h"
struct __anonstruct_char_directive_32 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 56 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-parse.h"
typedef struct __anonstruct_char_directive_32 char_directive;
#line 73 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-parse.h"
struct __anonstruct_char_directives_33 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
   char_directive direct_alloc_dir[7] ;
};
#line 73 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-parse.h"
typedef struct __anonstruct_char_directives_33 char_directives;
#line 66 "/home/pronto/abs/test-suite/bison-2.5/lib/fpucw.h"
typedef unsigned short fpucw_t;
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 60 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 35 "/usr/include/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 52 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.h"
struct timevar_time_def {
   float user ;
   float sys ;
   float wall ;
};
#line 70
enum __anonenum_timevar_id_t_34 {
    TV_TOTAL = 0,
    TV_READER = 1,
    TV_SCANNING = 2,
    TV_PARSING = 3,
    TV_REDUCE = 4,
    TV_SETS = 5,
    TV_LR0 = 6,
    TV_LALR = 7,
    TV_IELR_PHASE1 = 8,
    TV_IELR_PHASE2 = 9,
    TV_IELR_PHASE3 = 10,
    TV_IELR_PHASE4 = 11,
    TV_CONFLICTS = 12,
    TV_REPORT = 13,
    TV_GRAPH = 14,
    TV_XML = 15,
    TV_ACTIONS = 16,
    TV_PARSER = 17,
    TV_M4 = 18,
    TV_FREE = 19,
    TIMEVAR_LAST = 20
} ;
#line 70 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.h"
typedef enum __anonenum_timevar_id_t_34 timevar_id_t;
#line 141 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
struct timevar_def {
   struct timevar_time_def elapsed ;
   struct timevar_time_def start_time ;
   char const   *name ;
   unsigned int standalone : 1 ;
   unsigned int used : 1 ;
};
#line 165 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
struct timevar_stack_def {
   struct timevar_def *timevar ;
   struct timevar_stack_def *next ;
};
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_8 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_8 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 71 "/usr/include/bits/sched.h"
struct sched_param {
   int __sched_priority ;
};
#line 30 "/usr/include/spawn.h"
struct __anonstruct_posix_spawnattr_t_48 {
   short __flags ;
   pid_t __pgrp ;
   sigset_t __sd ;
   sigset_t __ss ;
   struct sched_param __sp ;
   int __policy ;
   int __pad[16] ;
};
#line 30 "/usr/include/spawn.h"
typedef struct __anonstruct_posix_spawnattr_t_48 posix_spawnattr_t;
#line 44
struct __spawn_action;
#line 44 "/usr/include/spawn.h"
struct __anonstruct_posix_spawn_file_actions_t_49 {
   int __allocated ;
   int __used ;
   struct __spawn_action *__actions ;
   int __pad[16] ;
};
#line 44 "/usr/include/spawn.h"
typedef struct __anonstruct_posix_spawn_file_actions_t_49 posix_spawn_file_actions_t;
#line 152 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef int ptrdiff_t;
#line 32 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 237
struct quoting_options;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_25 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_24 {
   int __count ;
   union __anonunion___value_25 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_24 __mbstate_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 45 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 677 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 139 "/usr/include/stdint.h"
typedef long long intmax_t;
#line 161 "/home/pronto/abs/test-suite/bison-2.5/lib/mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 109 "/home/pronto/abs/test-suite/bison-2.5/lib/mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 202 "/home/pronto/abs/test-suite/bison-2.5/lib/mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 80 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
enum bitset_ops {
    BITSET_OP_ZERO = 0,
    BITSET_OP_ONES = 1,
    BITSET_OP_COPY = 2,
    BITSET_OP_NOT = 3,
    BITSET_OP_EMPTY_P = 4,
    BITSET_OP_EQUAL_P = 5,
    BITSET_OP_SUBSET_P = 6,
    BITSET_OP_DISJOINT_P = 7,
    BITSET_OP_AND = 8,
    BITSET_OP_OR = 9,
    BITSET_OP_XOR = 10,
    BITSET_OP_ANDN = 11,
    BITSET_OP_OR_AND = 12,
    BITSET_OP_AND_OR = 13,
    BITSET_OP_ANDN_OR = 14
} ;
#line 142 "/home/pronto/abs/test-suite/bison-2.5/lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "/home/pronto/abs/test-suite/bison-2.5/lib/obstack.h"
union __anonunion_temp_2 {
   int tempint ;
   void *tempptr ;
};
#line 149 "/home/pronto/abs/test-suite/bison-2.5/lib/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_2 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 61 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
struct lbitset_elt_struct {
   struct lbitset_elt_struct *next ;
   struct lbitset_elt_struct *prev ;
   bitset_windex index ;
   bitset_word words[2] ;
};
#line 61 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
typedef struct lbitset_elt_struct lbitset_elt;
#line 71
enum lbitset_find_mode {
    LBITSET_FIND = 0,
    LBITSET_CREATE = 1,
    LBITSET_SUBST = 2
} ;
#line 80 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
union __anonunion_memory_double_1 {
   long double value ;
   unsigned int word[((sizeof(long double ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
#line 80 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
typedef union __anonunion_memory_double_1 memory_double;
#line 80 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
union __anonunion_memory_double_1___0 {
   float value ;
   unsigned int word[((sizeof(float ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
#line 80 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
typedef union __anonunion_memory_double_1___0 memory_double___0;
#line 80 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
union __anonunion_memory_double_1___1 {
   double value ;
   unsigned int word[((sizeof(double ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
#line 80 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
typedef union __anonunion_memory_double_1___1 memory_double___1;
#line 43 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 55 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 57
struct hash_table;
#line 59 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.h"
typedef struct hash_table Hash_table;
#line 46 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 196 "./getopt.h"
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 62 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt_int.h"
enum __ord {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 68 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __ord __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_23 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_24 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_25 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_27 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_28 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_22 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_23 _kill ;
   struct __anonstruct__timer_24 _timer ;
   struct __anonstruct__rt_25 _rt ;
   struct __anonstruct__sigchld_26 _sigchld ;
   struct __anonstruct__sigfault_27 _sigfault ;
   struct __anonstruct__sigpoll_28 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_22 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_40 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_40 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 24 "/home/pronto/abs/test-suite/bison-2.5/lib/sig-handler.h"
typedef void (*sa_handler_t)(int  );
#line 115 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
struct __anonstruct_actions_entry_t_48 {
   void (* volatile  action)(void) ;
};
#line 115 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
typedef struct __anonstruct_actions_entry_t_48 actions_entry_t;
#line 57 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
union __anonunion_u_30 {
   bitset_word words[2] ;
   struct ebitset_elt_struct *next ;
};
#line 57 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
struct ebitset_elt_struct {
   union __anonunion_u_30 u ;
};
#line 57 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
typedef struct ebitset_elt_struct ebitset_elt;
#line 69 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
typedef ebitset_elt *ebitset_elts;
#line 79
enum ebitset_find_mode {
    EBITSET_FIND = 0,
    EBITSET_CREATE = 1,
    EBITSET_SUBST = 2
} ;
#line 42 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
typedef unsigned int bitset_attrs;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.h"
typedef bitset *bitsetv;
#line 77 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
struct bitset_type_info_struct {
   unsigned int allocs ;
   unsigned int frees ;
   unsigned int lists ;
   unsigned int sets ;
   unsigned int cache_sets ;
   unsigned int resets ;
   unsigned int cache_resets ;
   unsigned int tests ;
   unsigned int cache_tests ;
   unsigned int list_counts[10] ;
   unsigned int list_sizes[16] ;
   unsigned int list_density[20] ;
};
#line 93 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
struct bitset_stats_info_struct {
   unsigned int runs ;
   struct bitset_type_info_struct types[4] ;
};
#line 91 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
struct __anonstruct_bitset_iterator_23 {
   bitset_bindex list[1024] ;
   bitset_bindex next ;
   bitset_bindex num ;
   bitset_bindex i ;
};
#line 91 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
typedef struct __anonstruct_bitset_iterator_23 bitset_iterator;
#line 790 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
struct bitset_align_struct {
   char a ;
   union bitset_union b ;
};
#line 27 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.h"
typedef char const   *uniqstr;
#line 26 "/home/pronto/abs/test-suite/bison-2.5/src/location.h"
struct __anonstruct_boundary_35 {
   uniqstr file ;
   int line ;
   int column ;
};
#line 26 "/home/pronto/abs/test-suite/bison-2.5/src/location.h"
typedef struct __anonstruct_boundary_35 boundary;
#line 81 "/home/pronto/abs/test-suite/bison-2.5/src/location.h"
struct __anonstruct_location_36 {
   boundary start ;
   boundary end ;
};
#line 81 "/home/pronto/abs/test-suite/bison-2.5/src/location.h"
typedef struct __anonstruct_location_36 location;
#line 24 "/home/pronto/abs/test-suite/bison-2.5/src/assoc.h"
enum __anonenum_assoc_37 {
    undef_assoc = 0,
    right_assoc = 1,
    left_assoc = 2,
    non_assoc = 3
} ;
#line 24 "/home/pronto/abs/test-suite/bison-2.5/src/assoc.h"
typedef enum __anonenum_assoc_37 assoc;
#line 28 "/home/pronto/abs/test-suite/bison-2.5/src/named-ref.h"
struct named_ref {
   uniqstr id ;
   location loc ;
};
#line 28 "/home/pronto/abs/test-suite/bison-2.5/src/named-ref.h"
typedef struct named_ref named_ref;
#line 26 "/home/pronto/abs/test-suite/bison-2.5/src/scan-code.h"
struct symbol_list;
#line 41
enum __anonenum_kind_38 {
    CODE_PROPS_NONE = 0,
    CODE_PROPS_PLAIN = 1,
    CODE_PROPS_SYMBOL_ACTION = 2,
    CODE_PROPS_RULE_ACTION = 3
} ;
#line 41 "/home/pronto/abs/test-suite/bison-2.5/src/scan-code.h"
struct code_props {
   enum __anonenum_kind_38 kind ;
   char const   *code ;
   location location ;
   _Bool is_value_used ;
   struct symbol_list *rule ;
   named_ref *named_ref ;
};
#line 41 "/home/pronto/abs/test-suite/bison-2.5/src/scan-code.h"
typedef struct code_props code_props;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
enum __anonenum_symbol_class_39 {
    unknown_sym = 0,
    token_sym = 1,
    nterm_sym = 2
} ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
typedef enum __anonenum_symbol_class_39 symbol_class;
#line 48 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
typedef int symbol_number;
#line 52
struct symbol;
#line 52 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
typedef struct symbol symbol;
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
struct symbol {
   uniqstr tag ;
   location location ;
   uniqstr type_name ;
   location type_location ;
   code_props destructor ;
   code_props printer ;
   symbol_number number ;
   location prec_location ;
   int prec ;
   assoc assoc ;
   int user_token_number ;
   symbol *alias ;
   symbol_class class ;
   _Bool declared ;
};
#line 115 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
typedef int item_number;
#line 147 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
typedef int rule_number;
#line 173 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
struct __anonstruct_rule_41 {
   rule_number user_number ;
   rule_number number ;
   symbol *lhs ;
   item_number *rhs ;
   symbol *prec ;
   int dprec ;
   int merger ;
   symbol *precsym ;
   location location ;
   _Bool useful ;
   char const   *action ;
   location action_location ;
};
#line 173 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
typedef struct __anonstruct_rule_41 rule;
#line 94 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
typedef int state_number;
#line 105
struct state;
#line 105 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
typedef struct state state;
#line 111 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
struct __anonstruct_transitions_42 {
   int num ;
   state *states[1] ;
};
#line 111 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
typedef struct __anonstruct_transitions_42 transitions;
#line 169 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
struct __anonstruct_errs_43 {
   int num ;
   symbol *symbols[1] ;
};
#line 169 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
typedef struct __anonstruct_errs_43 errs;
#line 182 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
struct __anonstruct_reductions_44 {
   int num ;
   bitset *lookahead_tokens ;
   rule *rules[1] ;
};
#line 182 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
typedef struct __anonstruct_reductions_44 reductions;
#line 196
struct state_list;
#line 198 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
struct state {
   state_number number ;
   symbol_number accessing_symbol ;
   transitions *transitions ;
   reductions *reductions ;
   errs *errs ;
   struct state_list *state_list ;
   char consistent ;
   char const   *solved_conflicts ;
   char const   *solved_conflicts_xml ;
   size_t nitems ;
   item_number items[1] ;
};
#line 80 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.h"
typedef size_t goto_number;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.h"
enum __anonenum_content_type_47 {
    SYMLIST_SYMBOL = 0,
    SYMLIST_TYPE = 1,
    SYMLIST_DEFAULT_TAGGED = 2,
    SYMLIST_DEFAULT_TAGLESS = 3
} ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.h"
union __anonunion_content_48 {
   symbol *sym ;
   uniqstr type_name ;
};
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.h"
struct symbol_list {
   enum __anonenum_content_type_47 content_type ;
   union __anonunion_content_48 content ;
   location location ;
   location sym_loc ;
   struct symbol_list *midrule ;
   struct symbol_list *midrule_parent_rule ;
   int midrule_parent_rhs_index ;
   code_props action_props ;
   symbol *ruleprec ;
   int dprec ;
   int merger ;
   location merger_declaration_location ;
   named_ref *named_ref ;
   struct symbol_list *next ;
};
#line 117 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
typedef int base_number;
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
typedef int vector_number;
#line 98 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
typedef int action_number;
#line 189 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
struct __anonstruct_semantic_type_39 {
   uniqstr tag ;
   code_props destructor ;
   code_props printer ;
};
#line 189 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
typedef struct __anonstruct_semantic_type_39 semantic_type;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.h"
typedef struct symbol_list symbol_list;
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 89 "scan-skel.c"
typedef int16_t flex_int16_t;
#line 91 "scan-skel.c"
typedef int32_t flex_int32_t;
#line 223
struct yy_buffer_state;
#line 223 "scan-skel.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 260 "scan-skel.c"
typedef size_t yy_size_t;
#line 265 "scan-skel.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 441 "scan-skel.c"
typedef unsigned char YY_CHAR;
#line 445 "scan-skel.c"
typedef int yy_state_type;
#line 160 "/home/pronto/abs/test-suite/bison-2.5/src/parse-gram.h"
union YYSTYPE {
   symbol *symbol ;
   symbol_list *list ;
   int integer ;
   char const   *chars ;
   char *code ;
   assoc assoc ;
   uniqstr uniqstr ;
   unsigned char character ;
   named_ref *named_ref ;
};
#line 160 "/home/pronto/abs/test-suite/bison-2.5/src/parse-gram.h"
typedef union YYSTYPE YYSTYPE;
#line 320 "scan-code.l"
struct __anonstruct_variant_43 {
   unsigned int symbol_index ;
   uniqstr id ;
   location loc ;
   named_ref *hidden_by ;
   unsigned int err ;
};
#line 320 "scan-code.l"
typedef struct __anonstruct_variant_43 variant;
#line 31 "/home/pronto/abs/test-suite/bison-2.5/src/relation.h"
typedef size_t relation_node;
#line 32 "/home/pronto/abs/test-suite/bison-2.5/src/relation.h"
typedef relation_node *relation_nodes;
#line 33 "/home/pronto/abs/test-suite/bison-2.5/src/relation.h"
typedef relation_nodes *relation;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/reader.h"
struct merger_list {
   struct merger_list *next ;
   uniqstr name ;
   uniqstr type ;
   location type_declaration_location ;
};
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/reader.h"
typedef struct merger_list merger_list;
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
struct escape_buf {
   char *ptr ;
   size_t size ;
};
#line 91 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 97 "/usr/include/stdint.h"
typedef int int_fast16_t;
#line 104 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 110 "/usr/include/stdint.h"
typedef unsigned int uint_fast16_t;
#line 129 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.h"
enum __anonenum_muscle_percent_define_how_46 {
    MUSCLE_PERCENT_DEFINE_D = 0,
    MUSCLE_PERCENT_DEFINE_F = 1,
    MUSCLE_PERCENT_DEFINE_GRAMMAR_FILE = 2
} ;
#line 129 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.h"
typedef enum __anonenum_muscle_percent_define_how_46 muscle_percent_define_how;
#line 370 "parse-gram.c"
typedef uint_fast8_t yytype_uint8;
#line 376 "parse-gram.c"
typedef int_fast8_t yytype_int8;
#line 385 "parse-gram.c"
typedef uint_fast16_t yytype_uint16;
#line 391 "parse-gram.c"
typedef int_fast16_t yytype_int16;
#line 502 "parse-gram.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
   location yyls_alloc ;
};
#line 64 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
struct bison_language {
   char language[sizeof("Java")] ;
   char skeleton[sizeof("java-skel.m4")] ;
   char src_extension[sizeof(".java")] ;
   char header_extension[sizeof(".java")] ;
   _Bool add_tab ;
};
#line 36 "/home/pronto/abs/test-suite/bison-2.5/src/nullable.c"
struct rule_list {
   struct rule_list *next ;
   rule *value ;
};
#line 36 "/home/pronto/abs/test-suite/bison-2.5/src/nullable.c"
typedef struct rule_list rule_list;
#line 33 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
struct __anonstruct_muscle_entry_38 {
   char const   *key ;
   char const   *value ;
   char *storage ;
};
#line 33 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
typedef struct __anonstruct_muscle_entry_38 muscle_entry;
#line 23 "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.h"
typedef unsigned char *Sbitset;
#line 34 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.h"
typedef unsigned long long InadequacyListNodeCount;
#line 47 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.h"
typedef rule_number ContributionIndex;
#line 63 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.h"
struct __anonstruct_Conflict_46 {
   symbol *token ;
   bitset actions ;
};
#line 63 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.h"
typedef struct __anonstruct_Conflict_46 Conflict;
#line 75 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.h"
union __anonunion_inadequacy_47 {
   Conflict conflict ;
};
#line 75 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.h"
struct InadequacyList {
   struct InadequacyList *next ;
   InadequacyListNodeCount id ;
   state *manifestingState ;
   ContributionIndex contributionCount ;
   union __anonunion_inadequacy_47 inadequacy ;
};
#line 75 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.h"
typedef struct InadequacyList InadequacyList;
#line 28 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.h"
typedef unsigned int AnnotationIndex;
#line 37 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.h"
struct AnnotationList {
   struct AnnotationList *next ;
   InadequacyList *inadequacyNode ;
   Sbitset contributions[1] ;
};
#line 37 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.h"
typedef struct AnnotationList AnnotationList;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
enum __anonenum_LrType_50 {
    LR_TYPE__LALR = 0,
    LR_TYPE__IELR = 1,
    LR_TYPE__CANONICAL_LR = 2
} ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
typedef enum __anonenum_LrType_50 LrType;
#line 552 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
struct state_list {
   struct state_list *next ;
   state *state ;
   _Bool recomputedAsSuccessor ;
   bitset *lookaheads ;
   struct state_list *lr0Isocore ;
   struct state_list *nextIsocore ;
};
#line 552 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
typedef struct state_list state_list;
#line 51 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
struct goto_list {
   struct goto_list *next ;
   goto_number value ;
};
#line 51 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
typedef struct goto_list goto_list;
#line 50 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
enum conflict_resolution {
    shift_resolution = 0,
    reduce_resolution = 1,
    left_resolution = 2,
    right_resolution = 3,
    nonassoc_resolution = 4
} ;
#line 24 "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.h"
typedef size_t Sbitset__Index;
#line 198 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
struct state___0 {
   state_number number ;
   symbol_number accessing_symbol ;
   transitions *transitions ;
   reductions *reductions ;
   errs *errs ;
   struct state_list___0 *state_list ;
   char consistent ;
   char const   *solved_conflicts ;
   char const   *solved_conflicts_xml ;
   size_t nitems ;
   item_number items[1] ;
};
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
struct state_list___0 {
   struct state_list___0 *next ;
   state *state ;
};
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
typedef struct state_list___0 state_list___0;
#line 23 "/home/pronto/abs/test-suite/bison-2.5/lib/xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 181 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
#line 52 "/home/pronto/abs/test-suite/bison-2.5/lib/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.5/lib/xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 32
  tmp = strndup(string, n);
#line 32
  s = tmp;
  }
#line 33
  if (! s) {
    {
#line 34
    xalloc_die();
    }
  }
#line 35
  return (s);
}
}
#line 54 "/home/pronto/abs/test-suite/bison-2.5/lib/xalloc.h"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 56
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 58
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 60
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 62
void *x2realloc(void *p , size_t *pn ) ;
#line 63
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 65
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 205 "/home/pronto/abs/test-suite/bison-2.5/lib/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 208
  n = *pn;
#line 210
  if (! p) {
#line 212
    if (! n) {
#line 220
      n = 64U / s;
#line 221
      n += (size_t )(! n);
    }
  } else {
#line 230
    if (2863311530U / s <= n) {
      {
#line 231
      xalloc_die();
      }
    }
#line 232
    n += (n + 1U) / 2U;
  }
  {
#line 235
  *pn = n;
#line 236
  tmp = xrealloc(p, n * s);
  }
#line 236
  return (tmp);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 40 "/home/pronto/abs/test-suite/bison-2.5/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 40 "/home/pronto/abs/test-suite/bison-2.5/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 43
  tmp = malloc(n);
#line 43
  p = tmp;
  }
#line 44
  if (! p) {
#line 44
    if (n != 0U) {
      {
#line 45
      xalloc_die();
      }
    }
  }
#line 46
  return (p);
}
}
#line 52
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 52 "/home/pronto/abs/test-suite/bison-2.5/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 55
  if (! n) {
#line 55
    if (p) {
      {
#line 59
      free(p);
      }
#line 60
      return ((void *)0);
    }
  }
  {
#line 63
  p = realloc(p, n);
  }
#line 64
  if (! p) {
#line 64
    if (n) {
      {
#line 65
      xalloc_die();
      }
    }
  }
#line 66
  return (p);
}
}
#line 75 "/home/pronto/abs/test-suite/bison-2.5/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 78
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 78
  return (tmp);
}
}
#line 85
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 85 "/home/pronto/abs/test-suite/bison-2.5/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 88
  tmp = xmalloc(s);
#line 88
  tmp___0 = memset(tmp, 0, s);
  }
#line 88
  return (tmp___0);
}
}
#line 94
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 94 "/home/pronto/abs/test-suite/bison-2.5/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 102
  p = calloc(n, s);
  }
#line 102
  if (! p) {
    {
#line 104
    xalloc_die();
    }
  }
#line 105
  return (p);
}
}
#line 112
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 112 "/home/pronto/abs/test-suite/bison-2.5/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 115
  tmp = xmalloc(s);
#line 115
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 115
  return (tmp___0);
}
}
#line 120
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 120 "/home/pronto/abs/test-suite/bison-2.5/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 123
  tmp = strlen(string);
#line 123
  tmp___0 = xmemdup((void const   *)string, tmp + 1U);
  }
#line 123
  return ((char *)tmp___0);
}
}
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 42 "/home/pronto/abs/test-suite/bison-2.5/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/pronto/abs/test-suite/bison-2.5/lib/exitfail.h"
int volatile   exit_failure ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.5/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.5/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 43 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding ) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 22 "/home/pronto/abs/test-suite/bison-2.5/lib/uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 25
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 25
  if (tmp == 0) {
#line 37
    return (1);
  } else {
    {
#line 25
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 25
    if (tmp___0 == 0) {
#line 37
      return (1);
    } else {
      {
#line 25
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 25
      if (tmp___1 == 0) {
#line 37
        return (1);
      } else {
        {
#line 25
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 25
        if (tmp___2 == 0) {
#line 37
          return (1);
        } else {
          {
#line 25
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 25
          if (tmp___3 == 0) {
#line 37
            return (1);
          } else {
            {
#line 25
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 25
            if (tmp___4 == 0) {
#line 37
              return (1);
            } else {
              {
#line 25
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 25
              if (tmp___5 == 0) {
#line 37
                return (1);
              } else {
                {
#line 25
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 25
                if (tmp___6 == 0) {
#line 37
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 38
  return (0);
}
}
#line 37 "/home/pronto/abs/test-suite/bison-2.5/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data[1728]  = 
#line 37 "/home/pronto/abs/test-suite/bison-2.5/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 282 "/home/pronto/abs/test-suite/bison-2.5/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind[240]  = 
#line 282
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 316 "/home/pronto/abs/test-suite/bison-2.5/lib/uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ 
  int ind ;
  int tmp ;
  int tmp___0 ;

  {
#line 320
  if (uc >> 9 < 240U) {
#line 322
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 323
    if (ind >= 0) {
#line 324
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 326
        if (uc > 0U) {
#line 326
          if (uc < 160U) {
#line 327
            return (-1);
          } else {
#line 329
            return (0);
          }
        } else {
#line 329
          return (0);
        }
      }
    }
  } else
#line 332
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 334
    if (uc >= 917760U) {
#line 336
      if (uc <= 917999U) {
#line 337
        return (0);
      }
    } else {
#line 341
      if (uc >= 917536U) {
#line 341
        tmp = uc <= 917631U;
      } else {
#line 341
        tmp = uc == 917505U;
      }
#line 341
      if (tmp) {
#line 342
        return (0);
      }
    }
  }
#line 349
  if (uc >= 4352U) {
#line 349
    if (uc < 4448U) {
#line 363
      return (2);
    } else
#line 349
    if (uc >= 9001U) {
#line 349
      if (uc < 9003U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 349
    if (uc >= 11904U) {
#line 349
      if (uc < 42192U) {
#line 349
        if (! (uc == 12351U)) {
#line 349
          if (uc >= 19904U) {
#line 349
            if (uc < 19968U) {
#line 349
              goto _L___8;
            } else {
#line 363
              return (2);
            }
          } else {
#line 363
            return (2);
          }
        } else {
#line 349
          goto _L___8;
        }
      } else {
#line 349
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 349
    if (uc >= 44032U) {
#line 349
      if (uc < 55204U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 349
    if (uc >= 63744U) {
#line 349
      if (uc < 64256U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 349
    if (uc >= 65040U) {
#line 349
      if (uc < 65056U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 349
    if (uc >= 65072U) {
#line 349
      if (uc < 65136U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 349
    if (uc >= 65280U) {
#line 349
      if (uc < 65377U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 349
    if (uc >= 65504U) {
#line 349
      if (uc < 65511U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 349
    if (uc >= 131072U) {
#line 349
      if (uc <= 196607U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 349
    if (uc >= 196608U) {
#line 349
      if (uc <= 262143U) {
#line 363
        return (2);
      }
    }
  }
#line 366
  if (uc >= 161U) {
#line 366
    if (uc < 65377U) {
#line 366
      if (uc != 8361U) {
        {
#line 366
        tmp___0 = is_cjk_encoding(encoding);
        }
#line 366
        if (tmp___0) {
#line 368
          return (2);
        }
      }
    }
  }
#line 369
  return (1);
}
}
#line 517 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
#line 57 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.h"
int wait_subprocess(pid_t child , char const   *progname , _Bool ignore_sigpipe ,
                    _Bool null_stderr , _Bool slave_process , _Bool exit_on_error ,
                    int *termsigp ) ;
#line 66
void register_slave_subprocess(pid_t child ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 126 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 54 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.h"
void at_fatal_signal(void (*action)(void) ) ;
#line 69 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
static slaves_entry_t static_slaves[32]  ;
#line 70 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
static slaves_entry_t * volatile  slaves  =    (slaves_entry_t */* volatile  */)(static_slaves);
#line 71 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
static int volatile   slaves_count  =    (sig_atomic_t volatile   )0;
#line 72 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
static size_t slaves_allocated  =    (size_t )(sizeof(static_slaves) / sizeof(static_slaves[0]));
#line 83 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
static void cleanup_slaves(void) 
{ 
  size_t n ;
  pid_t slave ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    n = (size_t )slaves_count;
#line 90
    if (n == 0U) {
#line 91
      goto while_break;
    }
#line 92
    n --;
#line 93
    slaves_count = (int volatile   )n;
#line 95
    if ((slaves + n)->used) {
      {
#line 97
      slave = (pid_t )(slaves + n)->child;
#line 100
      kill(slave, 1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 112 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
static _Bool cleanup_slaves_registered  =    (_Bool)0;
#line 109 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
void register_slave_subprocess(pid_t child ) 
{ 
  slaves_entry_t *s ;
  slaves_entry_t *s_end ;
  slaves_entry_t *old_slaves ;
  size_t new_slaves_allocated ;
  slaves_entry_t *new_slaves ;
  void *tmp ;

  {
#line 113
  if (! cleanup_slaves_registered) {
    {
#line 115
    atexit(& cleanup_slaves);
#line 116
    at_fatal_signal(& cleanup_slaves);
#line 117
    cleanup_slaves_registered = (_Bool)1;
    }
  }
#line 122
  s = (slaves_entry_t *)slaves;
#line 123
  s_end = s + slaves_count;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 125
      goto while_break;
    }
#line 126
    if (! s->used) {
#line 132
      s->child = (pid_t volatile   )child;
#line 133
      s->used = (sig_atomic_t volatile   )1;
#line 134
      return;
    }
#line 125
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if ((size_t )slaves_count == slaves_allocated) {
    {
#line 143
    old_slaves = (slaves_entry_t *)slaves;
#line 144
    new_slaves_allocated = 2U * slaves_allocated;
#line 145
    tmp = malloc((size_t )((unsigned long )new_slaves_allocated * sizeof(slaves_entry_t )));
#line 145
    new_slaves = (slaves_entry_t *)tmp;
    }
#line 148
    if ((unsigned long )new_slaves == (unsigned long )((void *)0)) {
      {
#line 153
      kill(child, 1);
#line 154
      xalloc_die();
      }
    }
    {
#line 156
    memcpy((void */* __restrict  */)new_slaves, (void const   */* __restrict  */)old_slaves,
           (size_t )((unsigned long )slaves_allocated * sizeof(slaves_entry_t )));
#line 158
    slaves = (slaves_entry_t */* volatile  */)new_slaves;
#line 159
    slaves_allocated = new_slaves_allocated;
    }
#line 161
    if ((unsigned long )old_slaves != (unsigned long )(static_slaves)) {
      {
#line 162
      free((void *)old_slaves);
      }
    }
  }
#line 168
  (slaves + slaves_count)->child = (pid_t volatile   )child;
#line 169
  (slaves + slaves_count)->used = (sig_atomic_t volatile   )1;
#line 170
  slaves_count += (int volatile   )1;
#line 171
  return;
}
}
#line 174 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
__inline static void unregister_slave_subprocess(pid_t child ) 
{ 
  slaves_entry_t *s ;
  slaves_entry_t *s_end ;

  {
#line 180
  s = (slaves_entry_t *)slaves;
#line 181
  s_end = s + slaves_count;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 183
      goto while_break;
    }
#line 184
    if (s->used) {
#line 184
      if (s->child == (pid_t volatile   )child) {
#line 185
        s->used = (sig_atomic_t volatile   )0;
      }
    }
#line 183
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 192 "/home/pronto/abs/test-suite/bison-2.5/lib/wait-process.c"
int wait_subprocess(pid_t child , char const   *progname , _Bool ignore_sigpipe ,
                    _Bool null_stderr , _Bool slave_process , _Bool exit_on_error ,
                    int *termsigp ) 
{ 
  int status ;
  int result ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  union __anonunion_50 __constr_expr_0 ;
  union __anonunion_51 __constr_expr_1 ;
  union __anonunion_52 __constr_expr_2 ;
  union __anonunion_53 __constr_expr_3 ;
  char *tmp___4 ;
  int tmp___5 ;
  union __anonunion_54 __constr_expr_4 ;
  union __anonunion_55 __constr_expr_5 ;
  char *tmp___6 ;
  int tmp___7 ;
  union __anonunion_56 __constr_expr_6 ;
  union __anonunion_57 __constr_expr_7 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 293
  if ((unsigned long )termsigp != (unsigned long )((void *)0)) {
#line 294
    *termsigp = 0;
  }
#line 295
  status = 0;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 298
    tmp = waitpid(child, & status, 0);
#line 298
    result = tmp;
    }
#line 300
    if (result != child) {
      {
#line 303
      tmp___0 = __errno_location();
      }
#line 303
      if (*tmp___0 == 4) {
#line 304
        goto __Cont;
      }
#line 315
      if (exit_on_error) {
#line 315
        goto _L;
      } else
#line 315
      if (! null_stderr) {
        _L: /* CIL Label */ 
        {
#line 316
        tmp___1 = gettext("%s subprocess");
#line 316
        tmp___2 = __errno_location();
        }
#line 316
        if (exit_on_error) {
#line 316
          tmp___3 = 1;
        } else {
#line 316
          tmp___3 = 0;
        }
        {
#line 316
        error(tmp___3, *tmp___2, (char const   *)tmp___1, progname);
        }
      }
#line 318
      return (127);
    }
#line 324
    __constr_expr_0.__in = status;
#line 324
    if (! ((__constr_expr_0.__i & 255) == 127)) {
#line 325
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  if (slave_process) {
    {
#line 334
    unregister_slave_subprocess(child);
    }
  }
#line 336
  __constr_expr_4.__in = status;
#line 336
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 338
    if ((unsigned long )termsigp != (unsigned long )((void *)0)) {
#line 339
      __constr_expr_1.__in = status;
#line 339
      *termsigp = __constr_expr_1.__i & 127;
    }
#line 341
    __constr_expr_2.__in = status;
#line 341
    if ((__constr_expr_2.__i & 127) == 13) {
#line 341
      if (ignore_sigpipe) {
#line 342
        return (0);
      }
    }
#line 344
    if (exit_on_error) {
#line 344
      goto _L___0;
    } else
#line 344
    if (! null_stderr) {
#line 344
      if ((unsigned long )termsigp == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
        {
#line 345
        __constr_expr_3.__in = status;
#line 345
        tmp___4 = gettext("%s subprocess got fatal signal %d");
        }
#line 345
        if (exit_on_error) {
#line 345
          tmp___5 = 1;
        } else {
#line 345
          tmp___5 = 0;
        }
        {
#line 345
        error(tmp___5, 0, (char const   *)tmp___4, progname, __constr_expr_3.__i & 127);
        }
      }
    }
#line 348
    return (127);
  }
#line 350
  __constr_expr_5.__in = status;
#line 350
  if (! ((__constr_expr_5.__i & 127) == 0)) {
    {
#line 351
    abort();
    }
  }
#line 352
  __constr_expr_6.__in = status;
#line 352
  if ((__constr_expr_6.__i & 65280) >> 8 == 127) {
#line 354
    if (exit_on_error) {
#line 354
      goto _L___1;
    } else
#line 354
    if (! null_stderr) {
      _L___1: /* CIL Label */ 
      {
#line 355
      tmp___6 = gettext("%s subprocess failed");
      }
#line 355
      if (exit_on_error) {
#line 355
        tmp___7 = 1;
      } else {
#line 355
        tmp___7 = 0;
      }
      {
#line 355
      error(tmp___7, 0, (char const   *)tmp___6, progname);
      }
    }
#line 357
    return (127);
  }
#line 359
  __constr_expr_7.__in = status;
#line 359
  return ((__constr_expr_7.__i & 65280) >> 8);
}
}
#line 1452 "./stdio.h"
int ( /* format attribute */ __attribute__((__nonnull__(1,2))) rpl_vsprintf)(char *str ,
                                                                             char const   *format ,
                                                                             va_list args ) ;
#line 75 "/home/pronto/abs/test-suite/bison-2.5/lib/vasnprintf.h"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) ;
#line 41 "/home/pronto/abs/test-suite/bison-2.5/lib/vsprintf.c"
int ( /* format attribute */ __attribute__((__nonnull__(1,2))) rpl_vsprintf)(char *str ,
                                                                             char const   *format ,
                                                                             va_list args ) 
{ 
  char *output___0 ;
  size_t len ;
  size_t lenbuf ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 54
  lenbuf = 2147483647U;
#line 55
  if (lenbuf > ~ ((uintptr_t )str)) {
#line 56
    lenbuf = ~ ((uintptr_t )str);
  }
  {
#line 58
  output___0 = vasnprintf(str, & lenbuf, format, args);
#line 59
  len = lenbuf;
  }
#line 61
  if (! output___0) {
#line 62
    return (-1);
  }
#line 64
  if ((unsigned long )output___0 != (unsigned long )str) {
    {
#line 67
    free((void *)output___0);
#line 68
    tmp = __errno_location();
#line 68
    *tmp = 75;
    }
#line 69
    return (-1);
  }
#line 72
  if (len > 2147483647U) {
    {
#line 74
    tmp___0 = __errno_location();
#line 74
    *tmp___0 = 75;
    }
#line 75
    return (-1);
  }
#line 78
  return ((int )len);
}
}
#line 1422 "./stdio.h"
int ( /* format attribute */ __attribute__((__nonnull__(3))) rpl_vsnprintf)(char *str ,
                                                                            size_t size ,
                                                                            char const   *format ,
                                                                            va_list args ) ;
#line 41 "/home/pronto/abs/test-suite/bison-2.5/lib/vsnprintf.c"
int ( /* format attribute */ __attribute__((__nonnull__(3))) rpl_vsnprintf)(char *str ,
                                                                            size_t size ,
                                                                            char const   *format ,
                                                                            va_list args ) 
{ 
  char *output___0 ;
  size_t len ;
  size_t lenbuf ;
  size_t pruned_len ;
  size_t tmp ;
  int *tmp___0 ;

  {
  {
#line 46
  lenbuf = size;
#line 48
  output___0 = vasnprintf(str, & lenbuf, format, args);
#line 49
  len = lenbuf;
  }
#line 51
  if (! output___0) {
#line 52
    return (-1);
  }
#line 54
  if ((unsigned long )output___0 != (unsigned long )str) {
#line 56
    if (size) {
#line 58
      if (len < size) {
#line 58
        tmp = len;
      } else {
#line 58
        tmp = size - 1U;
      }
      {
#line 58
      pruned_len = tmp;
#line 59
      memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)output___0,
             pruned_len);
#line 60
      *(str + pruned_len) = (char )'\000';
      }
    }
    {
#line 63
    free((void *)output___0);
    }
  }
#line 66
  if (len > 2147483647U) {
    {
#line 68
    tmp___0 = __errno_location();
#line 68
    *tmp___0 = 75;
    }
#line 69
    return (-1);
  }
#line 72
  return ((int )len);
}
}
#line 688 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 1354 "./stdio.h"
int ( /* format attribute */ __attribute__((__nonnull__(1,2))) rpl_vfprintf)(FILE *fp ,
                                                                             char const   *format ,
                                                                             va_list args ) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/lib/fseterr.h"
void fseterr(FILE *fp ) ;
#line 37 "/home/pronto/abs/test-suite/bison-2.5/lib/vfprintf.c"
int ( /* format attribute */ __attribute__((__nonnull__(1,2))) rpl_vfprintf)(FILE *fp ,
                                                                             char const   *format ,
                                                                             va_list args ) 
{ 
  char buf___0[2000] ;
  char *output___0 ;
  size_t len ;
  size_t lenbuf ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  void *__cil_tmp13 ;

  {
  {
#line 43
  lenbuf = (size_t )sizeof(buf___0);
#line 45
  output___0 = vasnprintf(buf___0, & lenbuf, format, args);
#line 46
  len = lenbuf;
  }
#line 48
  if (! output___0) {
    {
#line 50
    fseterr(fp);
    }
#line 51
    return (-1);
  }
  {
#line 54
  tmp___1 = fwrite((void const   */* __restrict  */)output___0, (size_t )1, len, (FILE */* __restrict  */)fp);
  }
#line 54
  if (tmp___1 < len) {
#line 56
    if ((unsigned long )output___0 != (unsigned long )(buf___0)) {
      {
#line 58
      tmp = __errno_location();
#line 58
      saved_errno = *tmp;
#line 59
      free((void *)output___0);
#line 60
      tmp___0 = __errno_location();
#line 60
      *tmp___0 = saved_errno;
      }
    }
#line 62
    return (-1);
  }
#line 65
  if ((unsigned long )output___0 != (unsigned long )(buf___0)) {
    {
#line 66
    free((void *)output___0);
    }
  }
#line 68
  if (len > 2147483647U) {
    {
#line 70
    tmp___2 = __errno_location();
#line 70
    *tmp___2 = 75;
#line 71
    fseterr(fp);
    }
#line 72
    return (-1);
  }
#line 75
  return ((int )len);
}
}
#line 284 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
_Bool bitset_toggle_(bitset bset , bitset_bindex bitno ) ;
#line 286
bitset_bindex bitset_count_(bitset src ) ;
#line 288
bitset_bindex bitset_size_(bitset src ) ;
#line 290
_Bool bitset_copy_(bitset dst , bitset src ) ;
#line 292
void bitset_and_or_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 294
_Bool bitset_and_or_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 296
void bitset_andn_or_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 298
_Bool bitset_andn_or_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 300
void bitset_or_and_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 302
_Bool bitset_or_and_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.h"
size_t vbitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) ;
#line 27
bitset vbitset_init(bitset bset , bitset_bindex n_bits ) ;
#line 35 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
__inline static void vbitset_unused_clear(bitset dst ) ;
#line 37
static void vbitset_set(bitset dst , bitset_bindex bitno ) ;
#line 38
static void vbitset_reset(bitset dst  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) ;
#line 39
static _Bool vbitset_test(bitset src  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) ;
#line 40
static bitset_bindex vbitset_list(bitset src , bitset_bindex *list , bitset_bindex num ,
                                  bitset_bindex *next ) ;
#line 42
static bitset_bindex vbitset_list_reverse(bitset src , bitset_bindex *list , bitset_bindex num ,
                                          bitset_bindex *next ) ;
#line 55 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static bitset_bindex vbitset_resize(bitset src , bitset_bindex n_bits ) 
{ 
  bitset_windex oldsize ;
  bitset_windex newsize ;
  bitset_windex size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 61
  if (n_bits == src->b.n_bits) {
#line 62
    return (n_bits);
  }
#line 64
  oldsize = src->b.csize;
#line 65
  newsize = ((n_bits + (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (unsigned int )(8UL * sizeof(bitset_word ));
#line 67
  if (oldsize < newsize) {
#line 73
    if (newsize > src->v.size) {
#line 80
      if (oldsize == 0U) {
#line 81
        size = newsize;
      } else {
#line 83
        size = newsize + newsize / 4U;
      }
      {
#line 85
      tmp = realloc((void *)src->b.cdata, (size_t )((unsigned long )size * sizeof(bitset_word )));
#line 85
      src->b.cdata = (bitset_word *)tmp;
#line 87
      src->v.size = size;
      }
    }
    {
#line 90
    memset((void *)(src->b.cdata + oldsize), 0, (size_t )((unsigned long )(newsize - oldsize) * sizeof(bitset_word )));
#line 92
    src->b.csize = newsize;
    }
  } else {
#line 98
    if (oldsize - newsize >= oldsize / 2U) {
      {
#line 100
      tmp___0 = realloc((void *)src->b.cdata, (size_t )((unsigned long )newsize * sizeof(bitset_word )));
#line 100
      src->b.cdata = (bitset_word *)tmp___0;
#line 102
      src->v.size = newsize;
      }
    }
#line 107
    src->b.csize = newsize;
  }
#line 110
  src->b.n_bits = n_bits;
#line 111
  return (n_bits);
}
}
#line 116 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_set(bitset dst , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;

  {
  {
#line 121
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 127
  vbitset_resize(dst, bitno);
#line 129
  *(dst->b.cdata + (windex - dst->b.cindex)) |= 1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word ));
  }
#line 131
  return;
}
}
#line 135 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_reset(bitset dst  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) 
{ 


  {
#line 142
  return;
}
}
#line 146 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_test(bitset src  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) 
{ 


  {
#line 153
  return ((_Bool)0);
}
}
#line 161 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static bitset_bindex vbitset_list_reverse(bitset src , bitset_bindex *list , bitset_bindex num ,
                                          bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_bindex rbitno ;
  bitset_bindex count ;
  bitset_windex windex ;
  unsigned int bitcnt ;
  bitset_bindex bitoff ;
  bitset_word *srcp ;
  bitset_bindex n_bits ;
  bitset_bindex tmp ;
  bitset_word word ;
  bitset_bindex tmp___0 ;
  bitset_windex tmp___1 ;

  {
  {
#line 174
  srcp = src->b.cdata;
#line 175
  tmp = (*((src->b.vtable)->size))(src);
#line 175
  n_bits = tmp;
#line 177
  rbitno = *next;
  }
#line 182
  if (rbitno >= n_bits) {
#line 183
    return ((bitset_bindex )0);
  }
#line 185
  count = (bitset_bindex )0;
#line 187
  bitno = n_bits - (rbitno + 1U);
#line 189
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 190
  bitcnt = bitno % (unsigned int )(8UL * sizeof(bitset_word ));
#line 191
  bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    word = *(srcp + windex) << (((unsigned int )(8UL * sizeof(bitset_word )) - 1U) - bitcnt);
    {
#line 198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! word) {
#line 198
        goto while_break___0;
      }
#line 200
      if (word & (1UL << ((unsigned int )(8UL * sizeof(bitset_word )) - 1U))) {
#line 202
        tmp___0 = count;
#line 202
        count ++;
#line 202
        *(list + tmp___0) = bitoff + bitcnt;
#line 203
        if (count >= num) {
#line 205
          *next = n_bits - (bitoff + bitcnt);
#line 206
          return (count);
        }
      }
#line 209
      word <<= 1;
#line 198
      bitcnt --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 211
    bitoff -= (unsigned int )(8UL * sizeof(bitset_word ));
#line 212
    bitcnt = (unsigned int )(8UL * sizeof(bitset_word )) - 1U;
#line 193
    tmp___1 = windex;
#line 193
    windex --;
#line 193
    if (! tmp___1) {
#line 193
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  *next = n_bits - (bitoff + 1U);
#line 217
  return (count);
}
}
#line 224 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static bitset_bindex vbitset_list(bitset src , bitset_bindex *list , bitset_bindex num ,
                                  bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_bindex count ;
  bitset_windex windex ;
  bitset_bindex bitoff ;
  bitset_windex size ;
  bitset_word *srcp ;
  bitset_word word ;
  bitset_bindex tmp ;
  bitset_bindex tmp___0 ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;

  {
#line 235
  size = src->b.csize;
#line 236
  srcp = src->b.cdata;
#line 239
  bitno = *next;
#line 241
  count = (bitset_bindex )0;
#line 242
  if (! bitno) {
#line 245
    windex = (bitset_windex )0;
    {
#line 245
    while (1) {
      while_continue: /* CIL Label */ ;
#line 245
      if (windex < size) {
#line 245
        if (! (! *(srcp + windex))) {
#line 245
          goto while_break;
        }
      } else {
#line 245
        goto while_break;
      }
#line 246
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 245
      windex ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 247
    if (windex >= size) {
#line 248
      return ((bitset_bindex )0);
    }
#line 253
    bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  } else {
    {
#line 257
    tmp = (*((src->b.vtable)->size))(src);
    }
#line 257
    if (bitno >= tmp) {
#line 258
      return ((bitset_bindex )0);
    }
#line 260
    windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 261
    bitno %= (unsigned int )(8UL * sizeof(bitset_word ));
#line 263
    if (bitno) {
#line 270
      bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
#line 271
      word = *(srcp + windex) >> bitno;
#line 272
      bitno = bitoff + bitno;
      {
#line 272
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 272
        if (! word) {
#line 272
          goto while_break___0;
        }
#line 274
        if (word & 1UL) {
#line 276
          tmp___0 = count;
#line 276
          count ++;
#line 276
          *(list + tmp___0) = bitno;
#line 277
          if (count >= num) {
#line 279
            *next = bitno + 1U;
#line 280
            return (count);
          }
        }
#line 283
        word >>= 1;
#line 272
        bitno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 285
      windex ++;
    }
#line 287
    bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  }
  {
#line 290
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 290
    if (! (windex < size)) {
#line 290
      goto while_break___1;
    }
#line 292
    word = *(srcp + windex);
#line 292
    if (! word) {
#line 293
      goto __Cont___0;
    }
#line 295
    if (count + (unsigned int )(8UL * sizeof(bitset_word )) < num) {
#line 297
      bitno = bitoff;
      {
#line 297
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 297
        if (! word) {
#line 297
          goto while_break___2;
        }
#line 299
        if (word & 1UL) {
#line 300
          tmp___1 = count;
#line 300
          count ++;
#line 300
          *(list + tmp___1) = bitno;
        }
#line 301
        word >>= 1;
#line 297
        bitno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 306
      bitno = bitoff;
      {
#line 306
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 306
        if (! word) {
#line 306
          goto while_break___3;
        }
#line 308
        if (word & 1UL) {
#line 310
          tmp___2 = count;
#line 310
          count ++;
#line 310
          *(list + tmp___2) = bitno;
#line 311
          if (count >= num) {
#line 313
            *next = bitno + 1U;
#line 314
            return (count);
          }
        }
#line 317
        word >>= 1;
#line 306
        bitno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 290
    windex ++;
#line 290
    bitoff += (unsigned int )(8UL * sizeof(bitset_word ));
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  *next = bitoff;
#line 323
  return (count);
}
}
#line 328 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
__inline static void vbitset_unused_clear(bitset dst ) 
{ 
  unsigned int last_bit ;
  bitset_bindex tmp ;

  {
  {
#line 334
  tmp = (*((dst->b.vtable)->size))(dst);
#line 334
  last_bit = tmp % (unsigned int )(8UL * sizeof(bitset_word ));
  }
#line 335
  if (last_bit) {
#line 336
    *(dst->b.cdata + (dst->b.csize - 1U)) &= (1UL << last_bit) - 1UL;
  }
#line 338
  return;
}
}
#line 341 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_ones(bitset dst ) 
{ 
  bitset_word *dstp ;
  unsigned int bytes ;

  {
  {
#line 344
  dstp = dst->b.cdata;
#line 347
  bytes = (unsigned int )(sizeof(bitset_word ) * (unsigned long )dst->b.csize);
#line 349
  memset((void *)dstp, -1, bytes);
#line 350
  vbitset_unused_clear(dst);
  }
#line 351
  return;
}
}
#line 354 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_zero(bitset dst ) 
{ 
  bitset_word *dstp ;
  unsigned int bytes ;

  {
  {
#line 357
  dstp = dst->b.cdata;
#line 360
  bytes = (unsigned int )(sizeof(bitset_word ) * (unsigned long )dst->b.csize);
#line 362
  memset((void *)dstp, 0, bytes);
  }
#line 363
  return;
}
}
#line 366 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_empty_p(bitset dst ) 
{ 
  unsigned int i ;
  bitset_word *dstp ;

  {
#line 370
  dstp = dst->b.cdata;
#line 372
  i = 0U;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (i < dst->b.csize)) {
#line 372
      goto while_break;
    }
#line 373
    if (*(dstp + i)) {
#line 374
      return ((_Bool)0);
    }
#line 372
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  return ((_Bool)1);
}
}
#line 380 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_copy1(bitset dst , bitset src ) 
{ 
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_bindex tmp ;

  {
#line 388
  if ((unsigned long )src == (unsigned long )dst) {
#line 389
    return;
  }
  {
#line 391
  tmp = (*((src->b.vtable)->size))(src);
#line 391
  vbitset_resize(dst, tmp);
#line 393
  srcp = src->b.cdata;
#line 394
  dstp = dst->b.cdata;
#line 395
  ssize = src->b.csize;
#line 396
  dsize = dst->b.csize;
#line 398
  memcpy((void */* __restrict  */)dstp, (void const   */* __restrict  */)srcp, (size_t )(sizeof(bitset_word ) * (unsigned long )ssize));
#line 400
  memset((void *)(dstp + sizeof(bitset_word ) * (unsigned long )ssize), 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize)));
  }
#line 402
  return;
}
}
#line 405 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_not(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_bindex tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
  {
#line 414
  tmp = (*((src->b.vtable)->size))(src);
#line 414
  vbitset_resize(dst, tmp);
#line 416
  srcp = src->b.cdata;
#line 417
  dstp = dst->b.cdata;
#line 418
  ssize = src->b.csize;
#line 419
  dsize = dst->b.csize;
#line 421
  i = 0U;
  }
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (i < ssize)) {
#line 421
      goto while_break;
    }
#line 422
    tmp___0 = dstp;
#line 422
    dstp ++;
#line 422
    tmp___1 = srcp;
#line 422
    srcp ++;
#line 422
    *tmp___0 = ~ *tmp___1;
#line 421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 424
  vbitset_unused_clear(dst);
#line 425
  memset((void *)(dstp + sizeof(bitset_word ) * (unsigned long )ssize), 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize)));
  }
#line 427
  return;
}
}
#line 430 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_equal_p(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_windex tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word *tmp___3 ;

  {
#line 434
  srcp = src->b.cdata;
#line 435
  dstp = dst->b.cdata;
#line 436
  ssize = src->b.csize;
#line 437
  dsize = dst->b.csize;
#line 439
  i = 0U;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (ssize > dsize) {
#line 439
      tmp___1 = dsize;
    } else {
#line 439
      tmp___1 = ssize;
    }
#line 439
    if (! (i < tmp___1)) {
#line 439
      goto while_break;
    }
#line 440
    tmp = srcp;
#line 440
    srcp ++;
#line 440
    tmp___0 = dstp;
#line 440
    dstp ++;
#line 440
    if (*tmp != *tmp___0) {
#line 441
      return ((_Bool)0);
    }
#line 439
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  if (ssize > dsize) {
    {
#line 445
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 445
      if (! (i < ssize)) {
#line 445
        goto while_break___0;
      }
#line 446
      tmp___2 = srcp;
#line 446
      srcp ++;
#line 446
      if (*tmp___2) {
#line 447
        return ((_Bool)0);
      }
#line 445
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 451
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 451
      if (! (i < dsize)) {
#line 451
        goto while_break___1;
      }
#line 452
      tmp___3 = dstp;
#line 452
      dstp ++;
#line 452
      if (*tmp___3) {
#line 453
        return ((_Bool)0);
      }
#line 451
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 456
  return ((_Bool)1);
}
}
#line 460 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_subset_p(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_windex tmp ;
  bitset_word *tmp___0 ;

  {
#line 464
  srcp = src->b.cdata;
#line 465
  dstp = dst->b.cdata;
#line 466
  ssize = src->b.csize;
#line 467
  dsize = dst->b.csize;
#line 469
  i = 0U;
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (ssize > dsize) {
#line 469
      tmp = dsize;
    } else {
#line 469
      tmp = ssize;
    }
#line 469
    if (! (i < tmp)) {
#line 469
      goto while_break;
    }
#line 470
    if (*dstp != (*srcp | *dstp)) {
#line 471
      return ((_Bool)0);
    }
#line 469
    i ++;
#line 469
    dstp ++;
#line 469
    srcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  if (ssize > dsize) {
    {
#line 475
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 475
      if (! (i < ssize)) {
#line 475
        goto while_break___0;
      }
#line 476
      tmp___0 = srcp;
#line 476
      srcp ++;
#line 476
      if (*tmp___0) {
#line 477
        return ((_Bool)0);
      }
#line 475
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 480
  return ((_Bool)1);
}
}
#line 484 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_disjoint_p(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_windex tmp___1 ;

  {
#line 488
  srcp = src->b.cdata;
#line 489
  dstp = dst->b.cdata;
#line 490
  ssize = src->b.csize;
#line 491
  dsize = dst->b.csize;
#line 493
  i = 0U;
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (ssize > dsize) {
#line 493
      tmp___1 = dsize;
    } else {
#line 493
      tmp___1 = ssize;
    }
#line 493
    if (! (i < tmp___1)) {
#line 493
      goto while_break;
    }
#line 494
    tmp = srcp;
#line 494
    srcp ++;
#line 494
    tmp___0 = dstp;
#line 494
    dstp ++;
#line 494
    if (*tmp & *tmp___0) {
#line 495
      return ((_Bool)0);
    }
#line 493
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  return ((_Bool)1);
}
}
#line 501 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_and(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word *tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_windex tmp___10 ;

  {
  {
#line 512
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 512
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 512
  if (tmp___4 > tmp___5) {
    {
#line 512
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 512
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 512
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 512
    tmp___3 = tmp___2;
    }
  }
  {
#line 512
  vbitset_resize(dst, tmp___3);
#line 514
  dsize = dst->b.csize;
#line 515
  ssize1 = src1->b.csize;
#line 516
  ssize2 = src2->b.csize;
#line 517
  dstp = dst->b.cdata;
#line 518
  src1p = src1->b.cdata;
#line 519
  src2p = src2->b.cdata;
#line 521
  i = 0U;
  }
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 521
    if (ssize1 > ssize2) {
#line 521
      tmp___9 = ssize2;
    } else {
#line 521
      tmp___9 = ssize1;
    }
#line 521
    if (! (i < tmp___9)) {
#line 521
      goto while_break;
    }
#line 522
    tmp___6 = dstp;
#line 522
    dstp ++;
#line 522
    tmp___7 = src1p;
#line 522
    src1p ++;
#line 522
    tmp___8 = src2p;
#line 522
    src2p ++;
#line 522
    *tmp___6 = *tmp___7 & *tmp___8;
#line 521
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 524
  if (ssize1 > ssize2) {
#line 524
    tmp___10 = ssize2;
  } else {
#line 524
    tmp___10 = ssize1;
  }
  {
#line 524
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - tmp___10)));
  }
#line 525
  return;
}
}
#line 528 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_and_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;

  {
  {
#line 532
  changed = 0;
#line 540
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 540
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 540
  if (tmp___4 > tmp___5) {
    {
#line 540
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 540
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 540
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 540
    tmp___3 = tmp___2;
    }
  }
  {
#line 540
  vbitset_resize(dst, tmp___3);
#line 542
  dsize = dst->b.csize;
#line 543
  ssize1 = src1->b.csize;
#line 544
  ssize2 = src2->b.csize;
#line 545
  dstp = dst->b.cdata;
#line 546
  src1p = src1->b.cdata;
#line 547
  src2p = src2->b.cdata;
#line 549
  i = 0U;
  }
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    if (ssize1 > ssize2) {
#line 549
      tmp___9 = ssize2;
    } else {
#line 549
      tmp___9 = ssize1;
    }
#line 549
    if (! (i < tmp___9)) {
#line 549
      goto while_break;
    }
#line 551
    tmp___7 = src1p;
#line 551
    src1p ++;
#line 551
    tmp___8 = src2p;
#line 551
    src2p ++;
#line 551
    tmp___6 = *tmp___7 & *tmp___8;
#line 553
    if (*dstp != tmp___6) {
#line 555
      changed = 1;
#line 556
      *dstp = tmp___6;
    }
#line 549
    i ++;
#line 549
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  if (ssize2 > ssize1) {
#line 562
    src1p = src2p;
#line 563
    ssize1 = ssize2;
  }
  {
#line 566
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 566
    if (! (i < ssize1)) {
#line 566
      goto while_break___0;
    }
#line 568
    if (*dstp != 0UL) {
#line 570
      changed = 1;
#line 571
      *dstp = (bitset_word )0;
    }
#line 566
    i ++;
#line 566
    dstp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 575
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 577
  return ((_Bool )changed);
}
}
#line 581 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_andn(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word *tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word *tmp___10 ;
  bitset_word *tmp___11 ;
  bitset_word *tmp___12 ;

  {
  {
#line 592
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 592
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 592
  if (tmp___4 > tmp___5) {
    {
#line 592
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 592
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 592
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 592
    tmp___3 = tmp___2;
    }
  }
  {
#line 592
  vbitset_resize(dst, tmp___3);
#line 594
  dsize = dst->b.csize;
#line 595
  ssize1 = src1->b.csize;
#line 596
  ssize2 = src2->b.csize;
#line 597
  dstp = dst->b.cdata;
#line 598
  src1p = src1->b.cdata;
#line 599
  src2p = src2->b.cdata;
#line 601
  i = 0U;
  }
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (ssize1 > ssize2) {
#line 601
      tmp___9 = ssize2;
    } else {
#line 601
      tmp___9 = ssize1;
    }
#line 601
    if (! (i < tmp___9)) {
#line 601
      goto while_break;
    }
#line 602
    tmp___6 = dstp;
#line 602
    dstp ++;
#line 602
    tmp___7 = src1p;
#line 602
    src1p ++;
#line 602
    tmp___8 = src2p;
#line 602
    src2p ++;
#line 602
    *tmp___6 = *tmp___7 & ~ *tmp___8;
#line 601
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  if (ssize2 > ssize1) {
    {
#line 606
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 606
      if (! (i < ssize2)) {
#line 606
        goto while_break___0;
      }
#line 607
      tmp___10 = dstp;
#line 607
      dstp ++;
#line 607
      *tmp___10 = (bitset_word )0;
#line 606
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 609
    memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize2)));
    }
  } else {
    {
#line 613
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 613
      if (! (i < ssize1)) {
#line 613
        goto while_break___1;
      }
#line 614
      tmp___11 = dstp;
#line 614
      dstp ++;
#line 614
      tmp___12 = src1p;
#line 614
      src1p ++;
#line 614
      *tmp___11 = *tmp___12;
#line 613
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 616
    memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
    }
  }
#line 618
  return;
}
}
#line 621 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_andn_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 625
  changed = 0;
#line 633
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 633
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 633
  if (tmp___4 > tmp___5) {
    {
#line 633
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 633
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 633
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 633
    tmp___3 = tmp___2;
    }
  }
  {
#line 633
  vbitset_resize(dst, tmp___3);
#line 635
  dsize = dst->b.csize;
#line 636
  ssize1 = src1->b.csize;
#line 637
  ssize2 = src2->b.csize;
#line 638
  dstp = dst->b.cdata;
#line 639
  src1p = src1->b.cdata;
#line 640
  src2p = src2->b.cdata;
#line 642
  i = 0U;
  }
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (ssize1 > ssize2) {
#line 642
      tmp___9 = ssize2;
    } else {
#line 642
      tmp___9 = ssize1;
    }
#line 642
    if (! (i < tmp___9)) {
#line 642
      goto while_break;
    }
#line 644
    tmp___7 = src1p;
#line 644
    src1p ++;
#line 644
    tmp___8 = src2p;
#line 644
    src2p ++;
#line 644
    tmp___6 = *tmp___7 & ~ *tmp___8;
#line 646
    if (*dstp != tmp___6) {
#line 648
      changed = 1;
#line 649
      *dstp = tmp___6;
    }
#line 642
    i ++;
#line 642
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  if (ssize2 > ssize1) {
    {
#line 655
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 655
      if (! (i < ssize2)) {
#line 655
        goto while_break___0;
      }
#line 657
      if (*dstp != 0UL) {
#line 659
        changed = 1;
#line 660
        *dstp = (bitset_word )0;
      }
#line 655
      i ++;
#line 655
      dstp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 664
    memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize2)));
    }
  } else {
    {
#line 668
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 668
      if (! (i < ssize1)) {
#line 668
        goto while_break___1;
      }
#line 670
      tmp___11 = src1p;
#line 670
      src1p ++;
#line 670
      tmp___10 = *tmp___11;
#line 672
      if (*dstp != tmp___10) {
#line 674
        changed = 1;
#line 675
        *dstp = tmp___10;
      }
#line 668
      i ++;
#line 668
      dstp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 679
    memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
    }
  }
#line 682
  return ((_Bool )changed);
}
}
#line 686 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_or(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word *tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word *tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 697
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 697
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 697
  if (tmp___4 > tmp___5) {
    {
#line 697
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 697
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 697
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 697
    tmp___3 = tmp___2;
    }
  }
  {
#line 697
  vbitset_resize(dst, tmp___3);
#line 699
  dsize = dst->b.csize;
#line 700
  ssize1 = src1->b.csize;
#line 701
  ssize2 = src2->b.csize;
#line 702
  dstp = dst->b.cdata;
#line 703
  src1p = src1->b.cdata;
#line 704
  src2p = src2->b.cdata;
#line 706
  i = 0U;
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (ssize1 > ssize2) {
#line 706
      tmp___9 = ssize2;
    } else {
#line 706
      tmp___9 = ssize1;
    }
#line 706
    if (! (i < tmp___9)) {
#line 706
      goto while_break;
    }
#line 707
    tmp___6 = dstp;
#line 707
    dstp ++;
#line 707
    tmp___7 = src1p;
#line 707
    src1p ++;
#line 707
    tmp___8 = src2p;
#line 707
    src2p ++;
#line 707
    *tmp___6 = *tmp___7 | *tmp___8;
#line 706
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  if (ssize2 > ssize1) {
#line 711
    src1p = src2p;
#line 712
    ssize1 = ssize2;
  }
  {
#line 715
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 715
    if (! (i < ssize1)) {
#line 715
      goto while_break___0;
    }
#line 716
    tmp___10 = dstp;
#line 716
    dstp ++;
#line 716
    tmp___11 = src1p;
#line 716
    src1p ++;
#line 716
    *tmp___10 = *tmp___11;
#line 715
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 718
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 719
  return;
}
}
#line 722 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_or_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 726
  changed = 0;
#line 734
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 734
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 734
  if (tmp___4 > tmp___5) {
    {
#line 734
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 734
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 734
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 734
    tmp___3 = tmp___2;
    }
  }
  {
#line 734
  vbitset_resize(dst, tmp___3);
#line 736
  dsize = dst->b.csize;
#line 737
  ssize1 = src1->b.csize;
#line 738
  ssize2 = src2->b.csize;
#line 739
  dstp = dst->b.cdata;
#line 740
  src1p = src1->b.cdata;
#line 741
  src2p = src2->b.cdata;
#line 743
  i = 0U;
  }
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 743
    if (ssize1 > ssize2) {
#line 743
      tmp___9 = ssize2;
    } else {
#line 743
      tmp___9 = ssize1;
    }
#line 743
    if (! (i < tmp___9)) {
#line 743
      goto while_break;
    }
#line 745
    tmp___7 = src1p;
#line 745
    src1p ++;
#line 745
    tmp___8 = src2p;
#line 745
    src2p ++;
#line 745
    tmp___6 = *tmp___7 | *tmp___8;
#line 747
    if (*dstp != tmp___6) {
#line 749
      changed = 1;
#line 750
      *dstp = tmp___6;
    }
#line 743
    i ++;
#line 743
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  if (ssize2 > ssize1) {
#line 756
    src1p = src2p;
#line 757
    ssize1 = ssize2;
  }
  {
#line 760
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 760
    if (! (i < ssize1)) {
#line 760
      goto while_break___0;
    }
#line 762
    tmp___11 = src1p;
#line 762
    src1p ++;
#line 762
    tmp___10 = *tmp___11;
#line 764
    if (*dstp != tmp___10) {
#line 766
      changed = 1;
#line 767
      *dstp = tmp___10;
    }
#line 760
    i ++;
#line 760
    dstp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 771
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 773
  return ((_Bool )changed);
}
}
#line 777 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_xor(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word *tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word *tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 788
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 788
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 788
  if (tmp___4 > tmp___5) {
    {
#line 788
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 788
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 788
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 788
    tmp___3 = tmp___2;
    }
  }
  {
#line 788
  vbitset_resize(dst, tmp___3);
#line 790
  dsize = dst->b.csize;
#line 791
  ssize1 = src1->b.csize;
#line 792
  ssize2 = src2->b.csize;
#line 793
  dstp = dst->b.cdata;
#line 794
  src1p = src1->b.cdata;
#line 795
  src2p = src2->b.cdata;
#line 797
  i = 0U;
  }
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    if (ssize1 > ssize2) {
#line 797
      tmp___9 = ssize2;
    } else {
#line 797
      tmp___9 = ssize1;
    }
#line 797
    if (! (i < tmp___9)) {
#line 797
      goto while_break;
    }
#line 798
    tmp___6 = dstp;
#line 798
    dstp ++;
#line 798
    tmp___7 = src1p;
#line 798
    src1p ++;
#line 798
    tmp___8 = src2p;
#line 798
    src2p ++;
#line 798
    *tmp___6 = *tmp___7 ^ *tmp___8;
#line 797
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  if (ssize2 > ssize1) {
#line 802
    src1p = src2p;
#line 803
    ssize1 = ssize2;
  }
  {
#line 806
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 806
    if (! (i < ssize1)) {
#line 806
      goto while_break___0;
    }
#line 807
    tmp___10 = dstp;
#line 807
    dstp ++;
#line 807
    tmp___11 = src1p;
#line 807
    src1p ++;
#line 807
    *tmp___10 = *tmp___11;
#line 806
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 809
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 810
  return;
}
}
#line 813 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_xor_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 817
  changed = 0;
#line 825
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 825
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 825
  if (tmp___4 > tmp___5) {
    {
#line 825
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 825
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 825
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 825
    tmp___3 = tmp___2;
    }
  }
  {
#line 825
  vbitset_resize(dst, tmp___3);
#line 827
  dsize = dst->b.csize;
#line 828
  ssize1 = src1->b.csize;
#line 829
  ssize2 = src2->b.csize;
#line 830
  dstp = dst->b.cdata;
#line 831
  src1p = src1->b.cdata;
#line 832
  src2p = src2->b.cdata;
#line 834
  i = 0U;
  }
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (ssize1 > ssize2) {
#line 834
      tmp___9 = ssize2;
    } else {
#line 834
      tmp___9 = ssize1;
    }
#line 834
    if (! (i < tmp___9)) {
#line 834
      goto while_break;
    }
#line 836
    tmp___7 = src1p;
#line 836
    src1p ++;
#line 836
    tmp___8 = src2p;
#line 836
    src2p ++;
#line 836
    tmp___6 = *tmp___7 ^ *tmp___8;
#line 838
    if (*dstp != tmp___6) {
#line 840
      changed = 1;
#line 841
      *dstp = tmp___6;
    }
#line 834
    i ++;
#line 834
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (ssize2 > ssize1) {
#line 847
    src1p = src2p;
#line 848
    ssize1 = ssize2;
  }
  {
#line 851
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 851
    if (! (i < ssize1)) {
#line 851
      goto while_break___0;
    }
#line 853
    tmp___11 = src1p;
#line 853
    src1p ++;
#line 853
    tmp___10 = *tmp___11;
#line 855
    if (*dstp != tmp___10) {
#line 857
      changed = 1;
#line 858
      *dstp = tmp___10;
    }
#line 851
    i ++;
#line 851
    dstp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 862
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 864
  return ((_Bool )changed);
}
}
#line 871 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_and_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 881
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 884
    bitset_and_or_(dst, src1, src2, src3);
    }
#line 885
    return;
  } else
#line 881
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 884
    bitset_and_or_(dst, src1, src2, src3);
    }
#line 885
    return;
  }
  {
#line 888
  vbitset_resize(dst, src1->b.n_bits);
#line 890
  src1p = src1->b.cdata;
#line 891
  src2p = src2->b.cdata;
#line 892
  src3p = src3->b.cdata;
#line 893
  dstp = dst->b.cdata;
#line 894
  size = dst->b.csize;
#line 896
  i = 0U;
  }
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 896
    if (! (i < size)) {
#line 896
      goto while_break;
    }
#line 897
    tmp = dstp;
#line 897
    dstp ++;
#line 897
    tmp___0 = src1p;
#line 897
    src1p ++;
#line 897
    tmp___1 = src2p;
#line 897
    src2p ++;
#line 897
    tmp___2 = src3p;
#line 897
    src3p ++;
#line 897
    *tmp = (*tmp___0 & *tmp___1) | *tmp___2;
#line 896
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return;
}
}
#line 901 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_and_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  _Bool tmp ;
  bitset_word tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word *tmp___3 ;

  {
#line 905
  changed = 0;
#line 912
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 914
    tmp = bitset_and_or_cmp_(dst, src1, src2, src3);
    }
#line 914
    return (tmp);
  } else
#line 912
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 914
    tmp = bitset_and_or_cmp_(dst, src1, src2, src3);
    }
#line 914
    return (tmp);
  }
  {
#line 916
  vbitset_resize(dst, src1->b.n_bits);
#line 918
  src1p = src1->b.cdata;
#line 919
  src2p = src2->b.cdata;
#line 920
  src3p = src3->b.cdata;
#line 921
  dstp = dst->b.cdata;
#line 922
  size = dst->b.csize;
#line 924
  i = 0U;
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! (i < size)) {
#line 924
      goto while_break;
    }
#line 926
    tmp___1 = src1p;
#line 926
    src1p ++;
#line 926
    tmp___2 = src2p;
#line 926
    src2p ++;
#line 926
    tmp___3 = src3p;
#line 926
    src3p ++;
#line 926
    tmp___0 = (*tmp___1 & *tmp___2) | *tmp___3;
#line 928
    if (*dstp != tmp___0) {
#line 930
      changed = 1;
#line 931
      *dstp = tmp___0;
    }
#line 924
    i ++;
#line 924
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 934
  return ((_Bool )changed);
}
}
#line 938 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_andn_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 948
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 951
    bitset_andn_or_(dst, src1, src2, src3);
    }
#line 952
    return;
  } else
#line 948
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 951
    bitset_andn_or_(dst, src1, src2, src3);
    }
#line 952
    return;
  }
  {
#line 955
  vbitset_resize(dst, src1->b.n_bits);
#line 957
  src1p = src1->b.cdata;
#line 958
  src2p = src2->b.cdata;
#line 959
  src3p = src3->b.cdata;
#line 960
  dstp = dst->b.cdata;
#line 961
  size = dst->b.csize;
#line 963
  i = 0U;
  }
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 963
    if (! (i < size)) {
#line 963
      goto while_break;
    }
#line 964
    tmp = dstp;
#line 964
    dstp ++;
#line 964
    tmp___0 = src1p;
#line 964
    src1p ++;
#line 964
    tmp___1 = src2p;
#line 964
    src2p ++;
#line 964
    tmp___2 = src3p;
#line 964
    src3p ++;
#line 964
    *tmp = (*tmp___0 & ~ *tmp___1) | *tmp___2;
#line 963
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 965
  return;
}
}
#line 968 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_andn_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  _Bool tmp ;
  bitset_word tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word *tmp___3 ;

  {
#line 972
  changed = 0;
#line 979
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 981
    tmp = bitset_andn_or_cmp_(dst, src1, src2, src3);
    }
#line 981
    return (tmp);
  } else
#line 979
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 981
    tmp = bitset_andn_or_cmp_(dst, src1, src2, src3);
    }
#line 981
    return (tmp);
  }
  {
#line 983
  vbitset_resize(dst, src1->b.n_bits);
#line 985
  src1p = src1->b.cdata;
#line 986
  src2p = src2->b.cdata;
#line 987
  src3p = src3->b.cdata;
#line 988
  dstp = dst->b.cdata;
#line 989
  size = dst->b.csize;
#line 991
  i = 0U;
  }
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 991
    if (! (i < size)) {
#line 991
      goto while_break;
    }
#line 993
    tmp___1 = src1p;
#line 993
    src1p ++;
#line 993
    tmp___2 = src2p;
#line 993
    src2p ++;
#line 993
    tmp___3 = src3p;
#line 993
    src3p ++;
#line 993
    tmp___0 = (*tmp___1 & ~ *tmp___2) | *tmp___3;
#line 995
    if (*dstp != tmp___0) {
#line 997
      changed = 1;
#line 998
      *dstp = tmp___0;
    }
#line 991
    i ++;
#line 991
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1001
  return ((_Bool )changed);
}
}
#line 1005 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_or_and(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 1015
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 1018
    bitset_or_and_(dst, src1, src2, src3);
    }
#line 1019
    return;
  } else
#line 1015
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 1018
    bitset_or_and_(dst, src1, src2, src3);
    }
#line 1019
    return;
  }
  {
#line 1022
  vbitset_resize(dst, src1->b.n_bits);
#line 1024
  src1p = src1->b.cdata;
#line 1025
  src2p = src2->b.cdata;
#line 1026
  src3p = src3->b.cdata;
#line 1027
  dstp = dst->b.cdata;
#line 1028
  size = dst->b.csize;
#line 1030
  i = 0U;
  }
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! (i < size)) {
#line 1030
      goto while_break;
    }
#line 1031
    tmp = dstp;
#line 1031
    dstp ++;
#line 1031
    tmp___0 = src1p;
#line 1031
    src1p ++;
#line 1031
    tmp___1 = src2p;
#line 1031
    src2p ++;
#line 1031
    tmp___2 = src3p;
#line 1031
    src3p ++;
#line 1031
    *tmp = (*tmp___0 | *tmp___1) & *tmp___2;
#line 1030
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1032
  return;
}
}
#line 1035 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static _Bool vbitset_or_and_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  _Bool tmp ;
  bitset_word tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word *tmp___3 ;

  {
#line 1039
  changed = 0;
#line 1046
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 1048
    tmp = bitset_or_and_cmp_(dst, src1, src2, src3);
    }
#line 1048
    return (tmp);
  } else
#line 1046
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 1048
    tmp = bitset_or_and_cmp_(dst, src1, src2, src3);
    }
#line 1048
    return (tmp);
  }
  {
#line 1050
  vbitset_resize(dst, src1->b.n_bits);
#line 1052
  src1p = src1->b.cdata;
#line 1053
  src2p = src2->b.cdata;
#line 1054
  src3p = src3->b.cdata;
#line 1055
  dstp = dst->b.cdata;
#line 1056
  size = dst->b.csize;
#line 1058
  i = 0U;
  }
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1058
    if (! (i < size)) {
#line 1058
      goto while_break;
    }
#line 1060
    tmp___1 = src1p;
#line 1060
    src1p ++;
#line 1060
    tmp___2 = src2p;
#line 1060
    src2p ++;
#line 1060
    tmp___3 = src3p;
#line 1060
    src3p ++;
#line 1060
    tmp___0 = (*tmp___1 | *tmp___2) & *tmp___3;
#line 1062
    if (*dstp != tmp___0) {
#line 1064
      changed = 1;
#line 1065
      *dstp = tmp___0;
    }
#line 1058
    i ++;
#line 1058
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1068
  return ((_Bool )changed);
}
}
#line 1072 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
static void vbitset_copy(bitset dst , bitset src ) 
{ 


  {
#line 1075
  if ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable) {
    {
#line 1076
    vbitset_copy1(dst, src);
    }
  } else {
    {
#line 1078
    bitset_copy_(dst, src);
    }
  }
#line 1079
  return;
}
}
#line 1083 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
struct bitset_vtable vbitset_vtable  = 
#line 1083
     {& vbitset_set, & vbitset_reset, & bitset_toggle_, & vbitset_test, & vbitset_resize,
    & bitset_size_, & bitset_count_, & vbitset_empty_p, & vbitset_ones, & vbitset_zero,
    & vbitset_copy, & vbitset_disjoint_p, & vbitset_equal_p, & vbitset_not, & vbitset_subset_p,
    & vbitset_and, & vbitset_and_cmp, & vbitset_andn, & vbitset_andn_cmp, & vbitset_or,
    & vbitset_or_cmp, & vbitset_xor, & vbitset_xor_cmp, & vbitset_and_or, & vbitset_and_or_cmp,
    & vbitset_andn_or, & vbitset_andn_or_cmp, & vbitset_or_and, & vbitset_or_and_cmp,
    & vbitset_list, & vbitset_list_reverse, (void (*)(bitset  ))((void *)0), (enum bitset_type )3};
#line 1120 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
size_t vbitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) 
{ 


  {
#line 1124
  return ((size_t )sizeof(struct vbitset_struct ));
}
}
#line 1128 "/home/pronto/abs/test-suite/bison-2.5/lib/vbitset.c"
bitset vbitset_init(bitset bset , bitset_bindex n_bits ) 
{ 


  {
  {
#line 1133
  bset->b.vtable = (struct bitset_vtable  const  *)(& vbitset_vtable);
#line 1135
  bset->b.cindex = (bitset_windex )0;
#line 1137
  bset->b.csize = (bitset_windex )0;
#line 1138
  vbitset_resize(bset, n_bits);
  }
#line 1139
  return (bset);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 363
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 157 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 191 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 54 "/home/pronto/abs/test-suite/bison-2.5/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 60
  sum = size1 + size2;
#line 61
  if (sum >= size1) {
#line 61
    tmp = sum;
  } else {
#line 61
    tmp = 4294967295U;
  }
#line 61
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 75 "/home/pronto/abs/test-suite/bison-2.5/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 81
  tmp = xsum(size1, size2);
#line 81
  tmp___0 = xsum((size_t )tmp, size3);
#line 81
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
#line 81
  return (tmp___1);
}
}
#line 85 "/home/pronto/abs/test-suite/bison-2.5/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 93
  if (size1 >= size2) {
#line 93
    tmp = size1;
  } else {
#line 93
    tmp = size2;
  }
#line 93
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 1005 "./math.h"
int rpl_isnanl(long double x ) ;
#line 276 "/home/pronto/abs/test-suite/bison-2.5/lib/vasnprintf.c"
static char decimal_point_char(void) 
{ 
  char const   *point ;
  char pointbuf[5] ;
  int tmp ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 288
  sprintf((char */* __restrict  */)(pointbuf), (char const   */* __restrict  */)"%#.0f",
          1.0);
#line 289
  point = (char const   *)(& pointbuf[1]);
  }
#line 294
  if ((int const   )*(point + 0) != 0) {
#line 294
    tmp = (int const   )*(point + 0);
  } else {
#line 294
    tmp = (int const   )'.';
  }
#line 294
  return ((char )tmp);
}
}
#line 313 "/home/pronto/abs/test-suite/bison-2.5/lib/vasnprintf.c"
static int is_infinite_or_zerol(long double x ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 316
  tmp = rpl_isnanl(x);
  }
#line 316
  if (tmp) {
#line 316
    tmp___0 = 1;
  } else
#line 316
  if (x + x == x) {
#line 316
    tmp___0 = 1;
  } else {
#line 316
    tmp___0 = 0;
  }
#line 316
  return (tmp___0);
}
}
#line 3600
extern int ( /* missing proto */  __builtin_signbitl)() ;
#line 3600
extern int ( /* missing proto */  __builtin_signbit)() ;
#line 3600
extern int ( /* missing proto */  __builtin_signbitf)() ;
#line 1746 "/home/pronto/abs/test-suite/bison-2.5/lib/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf___0 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int flags ;
  int has_width ;
  size_t width___0 ;
  int has_precision ;
  size_t precision ;
  size_t tmp_length ;
  char tmpbuf[700] ;
  char *tmp___16 ;
  char *pad_ptr ;
  char *p ;
  int arg ;
  char const   *digitp ;
  char const   *tmp___17 ;
  size_t tmp___18 ;
  size_t __attribute__((__pure__))  tmp___19 ;
  int arg___0 ;
  char const   *digitp___0 ;
  char const   *tmp___20 ;
  size_t tmp___21 ;
  size_t __attribute__((__pure__))  tmp___22 ;
  size_t __attribute__((__pure__))  tmp___23 ;
  size_t __attribute__((__pure__))  tmp___24 ;
  size_t tmp_memsize ;
  unsigned long tmp___25 ;
  void *tmp___26 ;
  long double arg___1 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int sign ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  size_t ndigits ;
  size_t tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  fpucw_t _ncw___0 ;
  int tmp___69 ;
  size_t pad ;
  char *end ;
  char *tmp___70 ;
  char *q ;
  char *tmp___71 ;
  char *q___0 ;
  char *tmp___72 ;
  size_t count ;
  size_t n___0 ;
  size_t __attribute__((__pure__))  tmp___73 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  arg_type type ;
  int flags___0 ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  int orig_errno ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  size_t n___1 ;
  char const   *mp ;
  char *tmp___85 ;
  char const   *tmp___86 ;
  size_t n___2 ;
  char const   *mp___0 ;
  char *tmp___87 ;
  char const   *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___94 ;
  size_t __attribute__((__pure__))  tmp___95 ;
  size_t __attribute__((__pure__))  tmp___96 ;
  void *tmp___97 ;
  void *tmp___98 ;
  size_t __attribute__((__pure__))  tmp___99 ;
  int *tmp___100 ;
  int count___0 ;
  int retcount ;
  size_t maxlen ;
  int *tmp___101 ;
  int arg___2 ;
  unsigned int arg___3 ;
  int arg___4 ;
  unsigned int arg___5 ;
  int arg___6 ;
  unsigned int arg___7 ;
  long arg___8 ;
  unsigned long arg___9 ;
  long long arg___10 ;
  unsigned long long arg___11 ;
  double arg___12 ;
  long double arg___13 ;
  int arg___14 ;
  wint_t arg___15 ;
  char const   *arg___16 ;
  wchar_t const   *arg___17 ;
  void *arg___18 ;
  int saved_errno ;
  int *tmp___102 ;
  int *tmp___103 ;
  int tmp___104 ;
  size_t n___3 ;
  size_t tmp___105 ;
  size_t __attribute__((__pure__))  tmp___106 ;
  size_t __attribute__((__pure__))  tmp___107 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___108 ;
  void *tmp___109 ;
  void *tmp___110 ;
  int *tmp___111 ;
  int tmp___112 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___113 ;
  size_t __attribute__((__pure__))  tmp___114 ;
  size_t __attribute__((__pure__))  tmp___115 ;
  void *tmp___116 ;
  void *tmp___117 ;
  size_t __attribute__((__pure__))  tmp___118 ;
  char *memory___5 ;
  void *tmp___119 ;
  int *tmp___120 ;
  int *tmp___121 ;
  void *__cil_tmp215 ;
  void *__cil_tmp216 ;

  {
  {
#line 1753
  tmp = printf_parse(format, & d, & a);
  }
#line 1753
  if (tmp < 0) {
#line 1755
    return ((char *)((void *)0));
  }
  {
#line 1763
  tmp___1 = printf_fetchargs(args, & a);
  }
#line 1763
  if (tmp___1 < 0) {
#line 1765
    if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
      {
#line 1765
      free((void *)d.dir);
      }
    }
#line 1765
    if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
      {
#line 1765
      free((void *)a.arg);
      }
    }
    {
#line 1766
    tmp___0 = __errno_location();
#line 1766
    *tmp___0 = 22;
    }
#line 1767
    return ((char *)((void *)0));
  }
  {
#line 1784
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1784
  buf_neededlength = (size_t )tmp___2;
  }
#line 1787
  if ((unsigned long )buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1789
    tmp___3 = __builtin_alloca((unsigned long )buf_neededlength * sizeof(char ));
#line 1789
    buf___0 = (char *)tmp___3;
#line 1790
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1795
    if ((unsigned long )buf_neededlength <= 4294967295UL / sizeof(char )) {
#line 1795
      tmp___4 = (unsigned long )buf_neededlength * sizeof(char );
    } else {
#line 1795
      tmp___4 = 4294967295UL;
    }
#line 1795
    buf_memsize = (size_t )tmp___4;
#line 1796
    if (buf_memsize == 4294967295U) {
#line 1797
      goto out_of_memory_1;
    }
    {
#line 1798
    tmp___5 = malloc(buf_memsize);
#line 1798
    buf___0 = (char *)tmp___5;
    }
#line 1799
    if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 1800
      goto out_of_memory_1;
    }
#line 1801
    buf_malloced = buf___0;
  }
#line 1804
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1806
    result = resultbuf;
#line 1807
    allocated = *lengthp;
  } else {
#line 1811
    result = (char *)((void *)0);
#line 1812
    allocated = (size_t )0;
  }
#line 1814
  length = (size_t )0;
#line 1844
  cp = format;
#line 1844
  i = (size_t )0;
#line 1844
  dp = d.dir + 0;
  {
#line 1844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1846
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
#line 1848
      n = (size_t )(dp->dir_start - cp);
#line 1849
      tmp___6 = xsum(length, n);
#line 1849
      augmented_length = (size_t )tmp___6;
      }
#line 1851
      if (augmented_length > allocated) {
#line 1851
        if (allocated > 0U) {
#line 1851
          if (allocated <= 2147483647U) {
#line 1851
            tmp___7 = allocated * 2U;
          } else {
#line 1851
            tmp___7 = 4294967295U;
          }
#line 1851
          allocated = tmp___7;
        } else {
#line 1851
          allocated = (size_t )12;
        }
#line 1851
        if (augmented_length > allocated) {
#line 1851
          allocated = augmented_length;
        }
#line 1851
        if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 1851
          memory_size = (size_t )((unsigned long )allocated * sizeof(char ));
        } else {
#line 1851
          memory_size = 4294967295U;
        }
#line 1851
        if (memory_size == 4294967295U) {
#line 1851
          goto out_of_memory;
        }
#line 1851
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1851
          tmp___8 = malloc(memory_size);
#line 1851
          memory = (char *)tmp___8;
          }
        } else
#line 1851
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1851
          tmp___8 = malloc(memory_size);
#line 1851
          memory = (char *)tmp___8;
          }
        } else {
          {
#line 1851
          tmp___9 = realloc((void *)result, memory_size);
#line 1851
          memory = (char *)tmp___9;
          }
        }
#line 1851
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1851
          goto out_of_memory;
        }
#line 1851
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1851
          if (length > 0U) {
            {
#line 1851
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1851
        result = memory;
      }
#line 1855
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1857
        memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)cp,
               n);
#line 1858
        length = augmented_length;
        }
      } else {
        {
#line 1862
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1863
          tmp___10 = length;
#line 1863
          length ++;
#line 1863
          tmp___11 = cp;
#line 1863
          cp ++;
#line 1863
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
#line 1862
          n --;
#line 1862
          if (! (n > 0U)) {
#line 1862
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1867
    if (i == d.count) {
#line 1868
      goto while_break;
    }
#line 1871
    if ((int )dp->conversion == 37) {
#line 1875
      if (! (dp->arg_index == 4294967295U)) {
        {
#line 1876
        abort();
        }
      }
      {
#line 1877
      tmp___12 = xsum(length, (size_t )1);
#line 1877
      augmented_length___0 = (size_t )tmp___12;
      }
#line 1878
      if (augmented_length___0 > allocated) {
#line 1878
        if (allocated > 0U) {
#line 1878
          if (allocated <= 2147483647U) {
#line 1878
            tmp___13 = allocated * 2U;
          } else {
#line 1878
            tmp___13 = 4294967295U;
          }
#line 1878
          allocated = tmp___13;
        } else {
#line 1878
          allocated = (size_t )12;
        }
#line 1878
        if (augmented_length___0 > allocated) {
#line 1878
          allocated = augmented_length___0;
        }
#line 1878
        if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 1878
          memory_size___0 = (size_t )((unsigned long )allocated * sizeof(char ));
        } else {
#line 1878
          memory_size___0 = 4294967295U;
        }
#line 1878
        if (memory_size___0 == 4294967295U) {
#line 1878
          goto out_of_memory;
        }
#line 1878
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1878
          tmp___14 = malloc(memory_size___0);
#line 1878
          memory___0 = (char *)tmp___14;
          }
        } else
#line 1878
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1878
          tmp___14 = malloc(memory_size___0);
#line 1878
          memory___0 = (char *)tmp___14;
          }
        } else {
          {
#line 1878
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1878
          memory___0 = (char *)tmp___15;
          }
        }
#line 1878
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1878
          goto out_of_memory;
        }
#line 1878
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1878
          if (length > 0U) {
            {
#line 1878
            memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1878
        result = memory___0;
      }
#line 1879
      *(result + length) = (char )'%';
#line 1880
      length = augmented_length___0;
    } else {
#line 1884
      if (! (dp->arg_index != 4294967295U)) {
        {
#line 1885
        abort();
        }
      }
#line 1887
      if ((int )dp->conversion == 110) {
        {
#line 1891
        if ((unsigned int )(a.arg + dp->arg_index)->type == 18U) {
#line 1891
          goto case_18;
        }
#line 1894
        if ((unsigned int )(a.arg + dp->arg_index)->type == 19U) {
#line 1894
          goto case_19;
        }
#line 1897
        if ((unsigned int )(a.arg + dp->arg_index)->type == 20U) {
#line 1897
          goto case_20;
        }
#line 1900
        if ((unsigned int )(a.arg + dp->arg_index)->type == 21U) {
#line 1900
          goto case_21;
        }
#line 1904
        if ((unsigned int )(a.arg + dp->arg_index)->type == 22U) {
#line 1904
          goto case_22;
        }
#line 1908
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1892
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1893
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1895
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1896
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1898
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1899
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1901
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1902
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1905
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1906
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1909
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else
#line 3393
      if ((int )dp->conversion == 102) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 70) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 101) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 69) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 103) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 71) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 97) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 65) {
        _L___11: /* CIL Label */ 
#line 3393
        if ((unsigned int )(a.arg + dp->arg_index)->type == 12U) {
          {
#line 3393
          tmp___112 = is_infinite_or_zerol((a.arg + dp->arg_index)->a.a_longdouble);
          }
#line 3393
          if (tmp___112) {
#line 3422
            flags = dp->flags;
#line 3433
            has_width = 0;
#line 3434
            width___0 = (size_t )0;
#line 3435
            if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 3437
              if (dp->width_arg_index != 4294967295U) {
#line 3441
                if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
                  {
#line 3442
                  abort();
                  }
                }
#line 3443
                arg = (a.arg + dp->width_arg_index)->a.a_int;
#line 3444
                if (arg < 0) {
#line 3448
                  flags |= 2;
#line 3449
                  width___0 = (unsigned int )(- arg);
                } else {
#line 3452
                  width___0 = (size_t )arg;
                }
              } else {
#line 3456
                digitp = dp->width_start;
                {
#line 3458
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 3459
                  tmp___17 = digitp;
#line 3459
                  digitp ++;
#line 3459
                  if (width___0 <= 429496729U) {
#line 3459
                    tmp___18 = width___0 * 10U;
                  } else {
#line 3459
                    tmp___18 = 4294967295U;
                  }
                  {
#line 3459
                  tmp___19 = xsum(tmp___18, (size_t )((int const   )*tmp___17 - 48));
#line 3459
                  width___0 = (size_t )tmp___19;
                  }
#line 3458
                  if (! ((unsigned long )digitp != (unsigned long )dp->width_end)) {
#line 3458
                    goto while_break___1;
                  }
                }
                while_break___1: /* CIL Label */ ;
                }
              }
#line 3462
              has_width = 1;
            }
#line 3465
            has_precision = 0;
#line 3466
            precision = (size_t )0;
#line 3467
            if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 3469
              if (dp->precision_arg_index != 4294967295U) {
#line 3473
                if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
                  {
#line 3474
                  abort();
                  }
                }
#line 3475
                arg___0 = (a.arg + dp->precision_arg_index)->a.a_int;
#line 3478
                if (arg___0 >= 0) {
#line 3480
                  precision = (size_t )arg___0;
#line 3481
                  has_precision = 1;
                }
              } else {
#line 3486
                digitp___0 = dp->precision_start + 1;
#line 3488
                precision = (size_t )0;
                {
#line 3489
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 3489
                  if (! ((unsigned long )digitp___0 != (unsigned long )dp->precision_end)) {
#line 3489
                    goto while_break___2;
                  }
#line 3490
                  tmp___20 = digitp___0;
#line 3490
                  digitp___0 ++;
#line 3490
                  if (precision <= 429496729U) {
#line 3490
                    tmp___21 = precision * 10U;
                  } else {
#line 3490
                    tmp___21 = 4294967295U;
                  }
                  {
#line 3490
                  tmp___22 = xsum(tmp___21, (size_t )((int const   )*tmp___20 - 48));
#line 3490
                  precision = (size_t )tmp___22;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
#line 3491
                has_precision = 1;
              }
            }
#line 3499
            if (! has_precision) {
#line 3500
              if (! ((int )dp->conversion == 97)) {
#line 3500
                if (! ((int )dp->conversion == 65)) {
#line 3501
                  precision = (size_t )6;
                }
              }
            }
#line 3513
            tmp_length = (size_t )0;
#line 3515
            if (tmp_length < precision) {
#line 3516
              tmp_length = precision;
            }
            {
#line 3550
            tmp___23 = xsum(tmp_length, (size_t )12);
#line 3550
            tmp_length = (size_t )tmp___23;
            }
#line 3552
            if (tmp_length < width___0) {
#line 3553
              tmp_length = width___0;
            }
            {
#line 3555
            tmp___24 = xsum(tmp_length, (size_t )1);
#line 3555
            tmp_length = (size_t )tmp___24;
            }
#line 3557
            if ((unsigned long )tmp_length <= sizeof(tmpbuf) / sizeof(char )) {
#line 3558
              tmp___16 = tmpbuf;
            } else {
#line 3561
              if ((unsigned long )tmp_length <= 4294967295UL / sizeof(char )) {
#line 3561
                tmp___25 = (unsigned long )tmp_length * sizeof(char );
              } else {
#line 3561
                tmp___25 = 4294967295UL;
              }
#line 3561
              tmp_memsize = (size_t )tmp___25;
#line 3563
              if (tmp_memsize == 4294967295U) {
#line 3565
                goto out_of_memory;
              }
              {
#line 3566
              tmp___26 = malloc(tmp_memsize);
#line 3566
              tmp___16 = (char *)tmp___26;
              }
#line 3567
              if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
#line 3569
                goto out_of_memory;
              }
            }
            {
#line 3572
            pad_ptr = (char *)((void *)0);
#line 3573
            p = tmp___16;
#line 3580
            arg___1 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 3582
            tmp___69 = rpl_isnanl(arg___1);
            }
#line 3582
            if (tmp___69) {
#line 3584
              if ((int )dp->conversion >= 65) {
#line 3584
                if ((int )dp->conversion <= 90) {
#line 3586
                  tmp___27 = p;
#line 3586
                  p ++;
#line 3586
                  *tmp___27 = (char )'N';
#line 3586
                  tmp___28 = p;
#line 3586
                  p ++;
#line 3586
                  *tmp___28 = (char )'A';
#line 3586
                  tmp___29 = p;
#line 3586
                  p ++;
#line 3586
                  *tmp___29 = (char )'N';
                } else {
#line 3584
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 3590
                tmp___30 = p;
#line 3590
                p ++;
#line 3590
                *tmp___30 = (char )'n';
#line 3590
                tmp___31 = p;
#line 3590
                p ++;
#line 3590
                *tmp___31 = (char )'a';
#line 3590
                tmp___32 = p;
#line 3590
                p ++;
#line 3590
                *tmp___32 = (char )'n';
              }
            } else {
#line 3595
              sign = 0;
#line 3598
              __asm__  volatile   ("fnstcw %0": "=m" (_cw));
#line 3598
              oldcw = _cw;
#line 3598
              _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
#line 3598
              __asm__  volatile   ("fldcw %0": : "m" (_ncw));
#line 3600
              if (sizeof(arg___1) == sizeof(long double )) {
                {
#line 3600
                tmp___33 = __builtin_signbitl(arg___1);
#line 3600
                tmp___37 = tmp___33;
                }
              } else {
#line 3600
                if (sizeof(arg___1) == sizeof(double )) {
                  {
#line 3600
                  tmp___34 = __builtin_signbit(arg___1);
#line 3600
                  tmp___36 = tmp___34;
                  }
                } else {
                  {
#line 3600
                  tmp___35 = __builtin_signbitf(arg___1);
#line 3600
                  tmp___36 = tmp___35;
                  }
                }
#line 3600
                tmp___37 = tmp___36;
              }
#line 3600
              if (tmp___37) {
#line 3602
                sign = -1;
#line 3603
                arg___1 = - arg___1;
              }
#line 3606
              if (sign < 0) {
#line 3607
                tmp___38 = p;
#line 3607
                p ++;
#line 3607
                *tmp___38 = (char )'-';
              } else
#line 3608
              if (flags & 4) {
#line 3609
                tmp___39 = p;
#line 3609
                p ++;
#line 3609
                *tmp___39 = (char )'+';
              } else
#line 3610
              if (flags & 8) {
#line 3611
                tmp___40 = p;
#line 3611
                p ++;
#line 3611
                *tmp___40 = (char )' ';
              }
#line 3613
              if (arg___1 > 0.0L) {
#line 3613
                if (arg___1 + arg___1 == arg___1) {
#line 3615
                  if ((int )dp->conversion >= 65) {
#line 3615
                    if ((int )dp->conversion <= 90) {
#line 3617
                      tmp___41 = p;
#line 3617
                      p ++;
#line 3617
                      *tmp___41 = (char )'I';
#line 3617
                      tmp___42 = p;
#line 3617
                      p ++;
#line 3617
                      *tmp___42 = (char )'N';
#line 3617
                      tmp___43 = p;
#line 3617
                      p ++;
#line 3617
                      *tmp___43 = (char )'F';
                    } else {
#line 3615
                      goto _L___0;
                    }
                  } else {
                    _L___0: /* CIL Label */ 
#line 3621
                    tmp___44 = p;
#line 3621
                    p ++;
#line 3621
                    *tmp___44 = (char )'i';
#line 3621
                    tmp___45 = p;
#line 3621
                    p ++;
#line 3621
                    *tmp___45 = (char )'n';
#line 3621
                    tmp___46 = p;
#line 3621
                    p ++;
#line 3621
                    *tmp___46 = (char )'f';
                  }
                } else {
#line 3613
                  goto _L___8;
                }
              } else {
                _L___8: /* CIL Label */ 
#line 3977
                if (! (arg___1 == 0.0L)) {
                  {
#line 3978
                  abort();
                  }
                }
#line 3980
                pad_ptr = p;
#line 3982
                if ((int )dp->conversion == 102) {
#line 3982
                  goto _L___7;
                } else
#line 3982
                if ((int )dp->conversion == 70) {
                  _L___7: /* CIL Label */ 
#line 3984
                  tmp___47 = p;
#line 3984
                  p ++;
#line 3984
                  *tmp___47 = (char )'0';
#line 3985
                  if (flags & 16) {
#line 3985
                    goto _L___1;
                  } else
#line 3985
                  if (precision > 0U) {
                    _L___1: /* CIL Label */ 
                    {
#line 3987
                    tmp___48 = p;
#line 3987
                    p ++;
#line 3987
                    *tmp___48 = decimal_point_char();
                    }
                    {
#line 3988
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
#line 3988
                      if (! (precision > 0U)) {
#line 3988
                        goto while_break___3;
                      }
#line 3989
                      tmp___49 = p;
#line 3989
                      p ++;
#line 3989
                      *tmp___49 = (char )'0';
#line 3988
                      precision --;
                    }
                    while_break___3: /* CIL Label */ ;
                    }
                  }
                } else
#line 3992
                if ((int )dp->conversion == 101) {
#line 3992
                  goto _L___6;
                } else
#line 3992
                if ((int )dp->conversion == 69) {
                  _L___6: /* CIL Label */ 
#line 3994
                  tmp___50 = p;
#line 3994
                  p ++;
#line 3994
                  *tmp___50 = (char )'0';
#line 3995
                  if (flags & 16) {
#line 3995
                    goto _L___2;
                  } else
#line 3995
                  if (precision > 0U) {
                    _L___2: /* CIL Label */ 
                    {
#line 3997
                    tmp___51 = p;
#line 3997
                    p ++;
#line 3997
                    *tmp___51 = decimal_point_char();
                    }
                    {
#line 3998
                    while (1) {
                      while_continue___4: /* CIL Label */ ;
#line 3998
                      if (! (precision > 0U)) {
#line 3998
                        goto while_break___4;
                      }
#line 3999
                      tmp___52 = p;
#line 3999
                      p ++;
#line 3999
                      *tmp___52 = (char )'0';
#line 3998
                      precision --;
                    }
                    while_break___4: /* CIL Label */ ;
                    }
                  }
#line 4001
                  tmp___53 = p;
#line 4001
                  p ++;
#line 4001
                  *tmp___53 = dp->conversion;
#line 4002
                  tmp___54 = p;
#line 4002
                  p ++;
#line 4002
                  *tmp___54 = (char )'+';
#line 4003
                  tmp___55 = p;
#line 4003
                  p ++;
#line 4003
                  *tmp___55 = (char )'0';
#line 4004
                  tmp___56 = p;
#line 4004
                  p ++;
#line 4004
                  *tmp___56 = (char )'0';
                } else
#line 4006
                if ((int )dp->conversion == 103) {
#line 4006
                  goto _L___5;
                } else
#line 4006
                if ((int )dp->conversion == 71) {
                  _L___5: /* CIL Label */ 
#line 4008
                  tmp___57 = p;
#line 4008
                  p ++;
#line 4008
                  *tmp___57 = (char )'0';
#line 4009
                  if (flags & 16) {
#line 4011
                    if (precision > 0U) {
#line 4011
                      tmp___58 = precision - 1U;
                    } else {
#line 4011
                      tmp___58 = (size_t )0;
                    }
                    {
#line 4011
                    ndigits = tmp___58;
#line 4013
                    tmp___59 = p;
#line 4013
                    p ++;
#line 4013
                    *tmp___59 = decimal_point_char();
                    }
                    {
#line 4014
                    while (1) {
                      while_continue___5: /* CIL Label */ ;
#line 4014
                      if (! (ndigits > 0U)) {
#line 4014
                        goto while_break___5;
                      }
#line 4015
                      tmp___60 = p;
#line 4015
                      p ++;
#line 4015
                      *tmp___60 = (char )'0';
#line 4014
                      ndigits --;
                    }
                    while_break___5: /* CIL Label */ ;
                    }
                  }
                } else
#line 4018
                if ((int )dp->conversion == 97) {
#line 4018
                  goto _L___4;
                } else
#line 4018
                if ((int )dp->conversion == 65) {
                  _L___4: /* CIL Label */ 
#line 4020
                  tmp___61 = p;
#line 4020
                  p ++;
#line 4020
                  *tmp___61 = (char )'0';
#line 4021
                  tmp___62 = p;
#line 4021
                  p ++;
#line 4021
                  *tmp___62 = (char )(((int )dp->conversion - 65) + 88);
#line 4022
                  pad_ptr = p;
#line 4023
                  tmp___63 = p;
#line 4023
                  p ++;
#line 4023
                  *tmp___63 = (char )'0';
#line 4024
                  if (flags & 16) {
#line 4024
                    goto _L___3;
                  } else
#line 4024
                  if (precision > 0U) {
                    _L___3: /* CIL Label */ 
                    {
#line 4026
                    tmp___64 = p;
#line 4026
                    p ++;
#line 4026
                    *tmp___64 = decimal_point_char();
                    }
                    {
#line 4027
                    while (1) {
                      while_continue___6: /* CIL Label */ ;
#line 4027
                      if (! (precision > 0U)) {
#line 4027
                        goto while_break___6;
                      }
#line 4028
                      tmp___65 = p;
#line 4028
                      p ++;
#line 4028
                      *tmp___65 = (char )'0';
#line 4027
                      precision --;
                    }
                    while_break___6: /* CIL Label */ ;
                    }
                  }
#line 4030
                  tmp___66 = p;
#line 4030
                  p ++;
#line 4030
                  *tmp___66 = (char )(((int )dp->conversion - 65) + 80);
#line 4031
                  tmp___67 = p;
#line 4031
                  p ++;
#line 4031
                  *tmp___67 = (char )'+';
#line 4032
                  tmp___68 = p;
#line 4032
                  p ++;
#line 4032
                  *tmp___68 = (char )'0';
                } else {
                  {
#line 4035
                  abort();
                  }
                }
              }
#line 4039
              _ncw___0 = oldcw;
#line 4039
              __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
            }
#line 4519
            if (has_width) {
#line 4519
              if (p - tmp___16 < (long )width___0) {
#line 4521
                pad = (size_t )((long )width___0 - (p - tmp___16));
#line 4522
                end = p + pad;
#line 4524
                if (flags & 2) {
                  {
#line 4527
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
#line 4527
                    if (! (pad > 0U)) {
#line 4527
                      goto while_break___7;
                    }
#line 4528
                    tmp___70 = p;
#line 4528
                    p ++;
#line 4528
                    *tmp___70 = (char )' ';
#line 4527
                    pad --;
                  }
                  while_break___7: /* CIL Label */ ;
                  }
                } else
#line 4530
                if (flags & 32) {
#line 4530
                  if ((unsigned long )pad_ptr != (unsigned long )((void *)0)) {
#line 4533
                    q = end;
                    {
#line 4535
                    while (1) {
                      while_continue___8: /* CIL Label */ ;
#line 4535
                      if (! ((unsigned long )p > (unsigned long )pad_ptr)) {
#line 4535
                        goto while_break___8;
                      }
#line 4536
                      q --;
#line 4536
                      p --;
#line 4536
                      *q = *p;
                    }
                    while_break___8: /* CIL Label */ ;
                    }
                    {
#line 4537
                    while (1) {
                      while_continue___9: /* CIL Label */ ;
#line 4537
                      if (! (pad > 0U)) {
#line 4537
                        goto while_break___9;
                      }
#line 4538
                      tmp___71 = p;
#line 4538
                      p ++;
#line 4538
                      *tmp___71 = (char )'0';
#line 4537
                      pad --;
                    }
                    while_break___9: /* CIL Label */ ;
                    }
                  } else {
#line 4530
                    goto _L___9;
                  }
                } else {
                  _L___9: /* CIL Label */ 
#line 4543
                  q___0 = end;
                  {
#line 4545
                  while (1) {
                    while_continue___10: /* CIL Label */ ;
#line 4545
                    if (! ((unsigned long )p > (unsigned long )tmp___16)) {
#line 4545
                      goto while_break___10;
                    }
#line 4546
                    q___0 --;
#line 4546
                    p --;
#line 4546
                    *q___0 = *p;
                  }
                  while_break___10: /* CIL Label */ ;
                  }
                  {
#line 4547
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
#line 4547
                    if (! (pad > 0U)) {
#line 4547
                      goto while_break___11;
                    }
#line 4548
                    tmp___72 = p;
#line 4548
                    p ++;
#line 4548
                    *tmp___72 = (char )' ';
#line 4547
                    pad --;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
                }
#line 4551
                p = end;
              }
            }
#line 4555
            count = (size_t )(p - tmp___16);
#line 4557
            if (count >= tmp_length) {
              {
#line 4560
              abort();
              }
            }
#line 4563
            if (count >= allocated - length) {
              {
#line 4565
              tmp___73 = xsum(length, count);
#line 4565
              n___0 = (size_t )tmp___73;
              }
#line 4567
              if (n___0 > allocated) {
#line 4567
                if (allocated > 0U) {
#line 4567
                  if (allocated <= 2147483647U) {
#line 4567
                    tmp___74 = allocated * 2U;
                  } else {
#line 4567
                    tmp___74 = 4294967295U;
                  }
#line 4567
                  allocated = tmp___74;
                } else {
#line 4567
                  allocated = (size_t )12;
                }
#line 4567
                if (n___0 > allocated) {
#line 4567
                  allocated = n___0;
                }
#line 4567
                if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 4567
                  memory_size___1 = (size_t )((unsigned long )allocated * sizeof(char ));
                } else {
#line 4567
                  memory_size___1 = 4294967295U;
                }
#line 4567
                if (memory_size___1 == 4294967295U) {
#line 4567
                  goto out_of_memory;
                }
#line 4567
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 4567
                  tmp___75 = malloc(memory_size___1);
#line 4567
                  memory___1 = (char *)tmp___75;
                  }
                } else
#line 4567
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 4567
                  tmp___75 = malloc(memory_size___1);
#line 4567
                  memory___1 = (char *)tmp___75;
                  }
                } else {
                  {
#line 4567
                  tmp___76 = realloc((void *)result, memory_size___1);
#line 4567
                  memory___1 = (char *)tmp___76;
                  }
                }
#line 4567
                if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4567
                  goto out_of_memory;
                }
#line 4567
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4567
                  if (length > 0U) {
                    {
#line 4567
                    memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 4567
                result = memory___1;
              }
            }
            {
#line 4571
            memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)tmp___16,
                   (size_t )((unsigned long )count * sizeof(char )));
            }
#line 4572
            if ((unsigned long )tmp___16 != (unsigned long )(tmpbuf)) {
              {
#line 4573
              free((void *)tmp___16);
              }
            }
#line 4574
            length += count;
          } else {
#line 3393
            goto _L___10;
          }
        } else {
#line 3393
          goto _L___10;
        }
      } else {
        _L___10: /* CIL Label */ 
#line 4580
        type = (a.arg + dp->arg_index)->type;
#line 4581
        flags___0 = dp->flags;
#line 4742
        fbp = buf___0;
#line 4743
        tmp___77 = fbp;
#line 4743
        fbp ++;
#line 4743
        *tmp___77 = (char )'%';
#line 4749
        if (flags___0 & 1) {
#line 4750
          tmp___78 = fbp;
#line 4750
          fbp ++;
#line 4750
          *tmp___78 = (char )'\'';
        }
#line 4752
        if (flags___0 & 2) {
#line 4753
          tmp___79 = fbp;
#line 4753
          fbp ++;
#line 4753
          *tmp___79 = (char )'-';
        }
#line 4754
        if (flags___0 & 4) {
#line 4755
          tmp___80 = fbp;
#line 4755
          fbp ++;
#line 4755
          *tmp___80 = (char )'+';
        }
#line 4756
        if (flags___0 & 8) {
#line 4757
          tmp___81 = fbp;
#line 4757
          fbp ++;
#line 4757
          *tmp___81 = (char )' ';
        }
#line 4758
        if (flags___0 & 16) {
#line 4759
          tmp___82 = fbp;
#line 4759
          fbp ++;
#line 4759
          *tmp___82 = (char )'#';
        }
#line 4761
        if (flags___0 & 64) {
#line 4762
          tmp___83 = fbp;
#line 4762
          fbp ++;
#line 4762
          *tmp___83 = (char )'I';
        }
#line 4766
        if (flags___0 & 32) {
#line 4767
          tmp___84 = fbp;
#line 4767
          fbp ++;
#line 4767
          *tmp___84 = (char )'0';
        }
#line 4768
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4770
          n___1 = (size_t )(dp->width_end - dp->width_start);
#line 4773
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4775
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->width_start,
                   (size_t )((unsigned long )n___1 * sizeof(char )));
#line 4776
            fbp += n___1;
            }
          } else {
#line 4780
            mp = dp->width_start;
            {
#line 4781
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 4782
              tmp___85 = fbp;
#line 4782
              fbp ++;
#line 4782
              tmp___86 = mp;
#line 4782
              mp ++;
#line 4782
              *tmp___85 = (char )((unsigned char )*tmp___86);
#line 4781
              n___1 --;
#line 4781
              if (! (n___1 > 0U)) {
#line 4781
                goto while_break___12;
              }
            }
            while_break___12: /* CIL Label */ ;
            }
          }
        }
#line 4789
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4791
          n___2 = (size_t )(dp->precision_end - dp->precision_start);
#line 4794
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4796
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->precision_start,
                   (size_t )((unsigned long )n___2 * sizeof(char )));
#line 4797
            fbp += n___2;
            }
          } else {
#line 4801
            mp___0 = dp->precision_start;
            {
#line 4802
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 4803
              tmp___87 = fbp;
#line 4803
              fbp ++;
#line 4803
              tmp___88 = mp___0;
#line 4803
              mp___0 ++;
#line 4803
              *tmp___87 = (char )((unsigned char )*tmp___88);
#line 4802
              n___2 --;
#line 4802
              if (! (n___2 > 0U)) {
#line 4802
                goto while_break___13;
              }
            }
            while_break___13: /* CIL Label */ ;
            }
          }
        }
        {
#line 4813
        if ((unsigned int )type == 10U) {
#line 4813
          goto case_10;
        }
#line 4813
        if ((unsigned int )type == 9U) {
#line 4813
          goto case_10;
        }
#line 4830
        if ((unsigned int )type == 16U) {
#line 4830
          goto case_16;
        }
#line 4830
        if ((unsigned int )type == 14U) {
#line 4830
          goto case_16;
        }
#line 4830
        if ((unsigned int )type == 8U) {
#line 4830
          goto case_16;
        }
#line 4830
        if ((unsigned int )type == 7U) {
#line 4830
          goto case_16;
        }
#line 4834
        if ((unsigned int )type == 12U) {
#line 4834
          goto case_12;
        }
#line 4837
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4820
        tmp___89 = fbp;
#line 4820
        fbp ++;
#line 4820
        *tmp___89 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4832
        tmp___90 = fbp;
#line 4832
        fbp ++;
#line 4832
        *tmp___90 = (char )'l';
#line 4833
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4835
        tmp___91 = fbp;
#line 4835
        fbp ++;
#line 4835
        *tmp___91 = (char )'L';
#line 4836
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4838
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4845
        *fbp = dp->conversion;
#line 4876
        *(fbp + 1) = (char )'\000';
#line 4883
        prefix_count = 0U;
#line 4884
        if (dp->width_arg_index != 4294967295U) {
#line 4886
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4887
            abort();
            }
          }
#line 4888
          tmp___92 = prefix_count;
#line 4888
          prefix_count ++;
#line 4888
          prefixes[tmp___92] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4890
        if (dp->precision_arg_index != 4294967295U) {
#line 4892
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4893
            abort();
            }
          }
#line 4894
          tmp___93 = prefix_count;
#line 4894
          prefix_count ++;
#line 4894
          prefixes[tmp___93] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4906
        tmp___99 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
        }
#line 4906
        if (tmp___99 > (size_t __attribute__((__pure__))  )allocated) {
#line 4906
          if (allocated > 0U) {
#line 4906
            if (allocated <= 2147483647U) {
#line 4906
              tmp___94 = allocated * 2U;
            } else {
#line 4906
              tmp___94 = 4294967295U;
            }
#line 4906
            allocated = tmp___94;
          } else {
#line 4906
            allocated = (size_t )12;
          }
          {
#line 4906
          tmp___96 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
          }
#line 4906
          if (tmp___96 > (size_t __attribute__((__pure__))  )allocated) {
            {
#line 4906
            tmp___95 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
#line 4906
            allocated = (size_t )tmp___95;
            }
          }
#line 4906
          if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 4906
            memory_size___2 = (size_t )((unsigned long )allocated * sizeof(char ));
          } else {
#line 4906
            memory_size___2 = 4294967295U;
          }
#line 4906
          if (memory_size___2 == 4294967295U) {
#line 4906
            goto out_of_memory;
          }
#line 4906
          if ((unsigned long )result == (unsigned long )resultbuf) {
            {
#line 4906
            tmp___97 = malloc(memory_size___2);
#line 4906
            memory___2 = (char *)tmp___97;
            }
          } else
#line 4906
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 4906
            tmp___97 = malloc(memory_size___2);
#line 4906
            memory___2 = (char *)tmp___97;
            }
          } else {
            {
#line 4906
            tmp___98 = realloc((void *)result, memory_size___2);
#line 4906
            memory___2 = (char *)tmp___98;
            }
          }
#line 4906
          if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 4906
            goto out_of_memory;
          }
#line 4906
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4906
            if (length > 0U) {
              {
#line 4906
              memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)result,
                     length);
              }
            }
          }
#line 4906
          result = memory___2;
        }
        {
#line 4911
        *(result + length) = (char )'\000';
#line 4914
        tmp___100 = __errno_location();
#line 4914
        orig_errno = *tmp___100;
        }
        {
#line 4916
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 4918
          count___0 = -1;
#line 4921
          retcount = 0;
#line 4922
          maxlen = allocated - length;
#line 4925
          if ((unsigned long )maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4926
            maxlen = (size_t )(2147483647UL / (sizeof(char ) / sizeof(char )));
          }
          {
#line 4927
          maxlen = (size_t )((unsigned long )maxlen * (sizeof(char ) / sizeof(char )));
#line 4969
          tmp___101 = __errno_location();
#line 4969
          *tmp___101 = 0;
          }
          {
#line 4972
          if ((unsigned int )type == 1U) {
#line 4972
            goto case_1;
          }
#line 4978
          if ((unsigned int )type == 2U) {
#line 4978
            goto case_2___0;
          }
#line 4984
          if ((unsigned int )type == 3U) {
#line 4984
            goto case_3;
          }
#line 4990
          if ((unsigned int )type == 4U) {
#line 4990
            goto case_4;
          }
#line 4996
          if ((unsigned int )type == 5U) {
#line 4996
            goto case_5;
          }
#line 5002
          if ((unsigned int )type == 6U) {
#line 5002
            goto case_6;
          }
#line 5008
          if ((unsigned int )type == 7U) {
#line 5008
            goto case_7___0;
          }
#line 5014
          if ((unsigned int )type == 8U) {
#line 5014
            goto case_8___0;
          }
#line 5021
          if ((unsigned int )type == 9U) {
#line 5021
            goto case_9___0;
          }
#line 5027
          if ((unsigned int )type == 10U) {
#line 5027
            goto case_10___0;
          }
#line 5034
          if ((unsigned int )type == 11U) {
#line 5034
            goto case_11;
          }
#line 5040
          if ((unsigned int )type == 12U) {
#line 5040
            goto case_12___0;
          }
#line 5046
          if ((unsigned int )type == 13U) {
#line 5046
            goto case_13;
          }
#line 5053
          if ((unsigned int )type == 14U) {
#line 5053
            goto case_14___0;
          }
#line 5060
          if ((unsigned int )type == 15U) {
#line 5060
            goto case_15;
          }
#line 5067
          if ((unsigned int )type == 16U) {
#line 5067
            goto case_16___0;
          }
#line 5074
          if ((unsigned int )type == 17U) {
#line 5074
            goto case_17;
          }
#line 5080
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 4974
          arg___2 = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 4975
          if (prefix_count == 0U) {
#line 4975
            goto case_0;
          }
#line 4975
          if (prefix_count == 1U) {
#line 4975
            goto case_1___0;
          }
#line 4975
          if (prefix_count == 2U) {
#line 4975
            goto case_2;
          }
#line 4975
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 4975
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___2, & count___0);
          }
#line 4975
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 4975
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___2, & count___0);
          }
#line 4975
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 4975
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___2, & count___0);
          }
#line 4975
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 4975
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }
#line 4977
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 4980
          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 4981
          if (prefix_count == 0U) {
#line 4981
            goto case_0___0;
          }
#line 4981
          if (prefix_count == 1U) {
#line 4981
            goto case_1___1;
          }
#line 4981
          if (prefix_count == 2U) {
#line 4981
            goto case_2___1;
          }
#line 4981
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 4981
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___3, & count___0);
          }
#line 4981
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 4981
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___3, & count___0);
          }
#line 4981
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 4981
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___3, & count___0);
          }
#line 4981
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 4981
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }
#line 4983
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 4986
          arg___4 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 4987
          if (prefix_count == 0U) {
#line 4987
            goto case_0___1;
          }
#line 4987
          if (prefix_count == 1U) {
#line 4987
            goto case_1___2;
          }
#line 4987
          if (prefix_count == 2U) {
#line 4987
            goto case_2___2;
          }
#line 4987
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 4987
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___4, & count___0);
          }
#line 4987
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 4987
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___4, & count___0);
          }
#line 4987
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 4987
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___4, & count___0);
          }
#line 4987
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 4987
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }
#line 4989
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 4992
          arg___5 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 4993
          if (prefix_count == 0U) {
#line 4993
            goto case_0___2;
          }
#line 4993
          if (prefix_count == 1U) {
#line 4993
            goto case_1___3;
          }
#line 4993
          if (prefix_count == 2U) {
#line 4993
            goto case_2___3;
          }
#line 4993
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 4993
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___5, & count___0);
          }
#line 4993
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 4993
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___5, & count___0);
          }
#line 4993
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 4993
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___5, & count___0);
          }
#line 4993
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 4993
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }
#line 4995
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 4998
          arg___6 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 4999
          if (prefix_count == 0U) {
#line 4999
            goto case_0___3;
          }
#line 4999
          if (prefix_count == 1U) {
#line 4999
            goto case_1___4;
          }
#line 4999
          if (prefix_count == 2U) {
#line 4999
            goto case_2___4;
          }
#line 4999
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 4999
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___6, & count___0);
          }
#line 4999
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 4999
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___6, & count___0);
          }
#line 4999
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 4999
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___6, & count___0);
          }
#line 4999
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 4999
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }
#line 5001
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 5004
          arg___7 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 5005
          if (prefix_count == 0U) {
#line 5005
            goto case_0___4;
          }
#line 5005
          if (prefix_count == 1U) {
#line 5005
            goto case_1___5;
          }
#line 5005
          if (prefix_count == 2U) {
#line 5005
            goto case_2___5;
          }
#line 5005
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 5005
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___7, & count___0);
          }
#line 5005
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 5005
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___7, & count___0);
          }
#line 5005
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 5005
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___7, & count___0);
          }
#line 5005
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 5005
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }
#line 5007
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 5010
          arg___8 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 5011
          if (prefix_count == 0U) {
#line 5011
            goto case_0___5;
          }
#line 5011
          if (prefix_count == 1U) {
#line 5011
            goto case_1___6;
          }
#line 5011
          if (prefix_count == 2U) {
#line 5011
            goto case_2___6;
          }
#line 5011
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 5011
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___8, & count___0);
          }
#line 5011
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 5011
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___8, & count___0);
          }
#line 5011
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 5011
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___8, & count___0);
          }
#line 5011
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 5011
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }
#line 5013
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 5016
          arg___9 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 5017
          if (prefix_count == 0U) {
#line 5017
            goto case_0___6;
          }
#line 5017
          if (prefix_count == 1U) {
#line 5017
            goto case_1___7;
          }
#line 5017
          if (prefix_count == 2U) {
#line 5017
            goto case_2___7;
          }
#line 5017
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 5017
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___9, & count___0);
          }
#line 5017
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 5017
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___9, & count___0);
          }
#line 5017
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 5017
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___9, & count___0);
          }
#line 5017
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 5017
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }
#line 5019
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 5023
          arg___10 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 5024
          if (prefix_count == 0U) {
#line 5024
            goto case_0___7;
          }
#line 5024
          if (prefix_count == 1U) {
#line 5024
            goto case_1___8;
          }
#line 5024
          if (prefix_count == 2U) {
#line 5024
            goto case_2___8;
          }
#line 5024
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 5024
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___10,
                              & count___0);
          }
#line 5024
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 5024
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___10, & count___0);
          }
#line 5024
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 5024
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___10, & count___0);
          }
#line 5024
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 5024
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }
#line 5026
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 5029
          arg___11 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 5030
          if (prefix_count == 0U) {
#line 5030
            goto case_0___8;
          }
#line 5030
          if (prefix_count == 1U) {
#line 5030
            goto case_1___9;
          }
#line 5030
          if (prefix_count == 2U) {
#line 5030
            goto case_2___9;
          }
#line 5030
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 5030
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___11,
                              & count___0);
          }
#line 5030
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 5030
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___11, & count___0);
          }
#line 5030
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 5030
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___11, & count___0);
          }
#line 5030
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 5030
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }
#line 5032
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 5036
          arg___12 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 5037
          if (prefix_count == 0U) {
#line 5037
            goto case_0___9;
          }
#line 5037
          if (prefix_count == 1U) {
#line 5037
            goto case_1___10;
          }
#line 5037
          if (prefix_count == 2U) {
#line 5037
            goto case_2___10;
          }
#line 5037
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 5037
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___12,
                              & count___0);
          }
#line 5037
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 5037
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___12, & count___0);
          }
#line 5037
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 5037
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___12, & count___0);
          }
#line 5037
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 5037
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }
#line 5039
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 5042
          arg___13 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 5043
          if (prefix_count == 0U) {
#line 5043
            goto case_0___10;
          }
#line 5043
          if (prefix_count == 1U) {
#line 5043
            goto case_1___11;
          }
#line 5043
          if (prefix_count == 2U) {
#line 5043
            goto case_2___11;
          }
#line 5043
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 5043
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___13,
                              & count___0);
          }
#line 5043
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 5043
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___13, & count___0);
          }
#line 5043
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 5043
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___13, & count___0);
          }
#line 5043
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 5043
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }
#line 5045
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 5048
          arg___14 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5049
          if (prefix_count == 0U) {
#line 5049
            goto case_0___11;
          }
#line 5049
          if (prefix_count == 1U) {
#line 5049
            goto case_1___12;
          }
#line 5049
          if (prefix_count == 2U) {
#line 5049
            goto case_2___12;
          }
#line 5049
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5049
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___14,
                              & count___0);
          }
#line 5049
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5049
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___14, & count___0);
          }
#line 5049
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5049
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___14, & count___0);
          }
#line 5049
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5049
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }
#line 5051
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5055
          arg___15 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5056
          if (prefix_count == 0U) {
#line 5056
            goto case_0___12;
          }
#line 5056
          if (prefix_count == 1U) {
#line 5056
            goto case_1___13;
          }
#line 5056
          if (prefix_count == 2U) {
#line 5056
            goto case_2___13;
          }
#line 5056
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___15,
                              & count___0);
          }
#line 5056
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___15, & count___0);
          }
#line 5056
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___15, & count___0);
          }
#line 5056
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5056
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }
#line 5058
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5062
          arg___16 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5063
          if (prefix_count == 0U) {
#line 5063
            goto case_0___13;
          }
#line 5063
          if (prefix_count == 1U) {
#line 5063
            goto case_1___14;
          }
#line 5063
          if (prefix_count == 2U) {
#line 5063
            goto case_2___14;
          }
#line 5063
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___16,
                              & count___0);
          }
#line 5063
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___16, & count___0);
          }
#line 5063
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___16, & count___0);
          }
#line 5063
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5063
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }
#line 5065
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5069
          arg___17 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5070
          if (prefix_count == 0U) {
#line 5070
            goto case_0___14;
          }
#line 5070
          if (prefix_count == 1U) {
#line 5070
            goto case_1___15;
          }
#line 5070
          if (prefix_count == 2U) {
#line 5070
            goto case_2___15;
          }
#line 5070
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5070
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___17,
                              & count___0);
          }
#line 5070
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5070
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___17, & count___0);
          }
#line 5070
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5070
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___17, & count___0);
          }
#line 5070
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5070
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }
#line 5072
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5076
          arg___18 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5077
          if (prefix_count == 0U) {
#line 5077
            goto case_0___15;
          }
#line 5077
          if (prefix_count == 1U) {
#line 5077
            goto case_1___16;
          }
#line 5077
          if (prefix_count == 2U) {
#line 5077
            goto case_2___16;
          }
#line 5077
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5077
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___18,
                              & count___0);
          }
#line 5077
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5077
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___18, & count___0);
          }
#line 5077
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5077
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___18, & count___0);
          }
#line 5077
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5077
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }
#line 5079
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5081
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5089
          if (count___0 >= 0) {
#line 5093
            if ((size_t )count___0 < maxlen) {
#line 5093
              if ((int )*((result + length) + count___0) != 0) {
                {
#line 5095
                abort();
                }
              }
            }
#line 5097
            if (retcount > count___0) {
#line 5098
              count___0 = retcount;
            }
          } else
#line 5104
          if ((int )*(fbp + 1) != 0) {
#line 5108
            *(fbp + 1) = (char )'\000';
#line 5109
            goto __Cont;
          } else
#line 5114
          if (! (retcount < 0)) {
#line 5156
            count___0 = retcount;
          }
#line 5162
          if (count___0 < 0) {
            {
#line 5166
            tmp___102 = __errno_location();
#line 5166
            saved_errno = *tmp___102;
            }
#line 5168
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5168
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                {
#line 5169
                free((void *)result);
                }
              }
            }
#line 5170
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              {
#line 5171
              free((void *)buf_malloced);
              }
            }
#line 5172
            if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
              {
#line 5172
              free((void *)d.dir);
              }
            }
#line 5172
            if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
              {
#line 5172
              free((void *)a.arg);
              }
            }
            {
#line 5173
            tmp___103 = __errno_location();
            }
#line 5173
            if (saved_errno != 0) {
#line 5173
              *tmp___103 = saved_errno;
            } else {
#line 5173
              if ((int )dp->conversion == 99) {
#line 5173
                tmp___104 = 84;
              } else
#line 5173
              if ((int )dp->conversion == 115) {
#line 5173
                tmp___104 = 84;
              } else {
#line 5173
                tmp___104 = 22;
              }
#line 5173
              *tmp___103 = tmp___104;
            }
#line 5179
            return ((char *)((void *)0));
          }
#line 5188
          if ((unsigned int )count___0 + 1U >= maxlen) {
#line 5193
            if ((unsigned long )maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5194
              goto overflow;
            } else {
#line 5206
              if (allocated <= 2147483647U) {
#line 5206
                tmp___105 = allocated * 2U;
              } else {
#line 5206
                tmp___105 = 4294967295U;
              }
              {
#line 5206
              tmp___106 = xsum(length, (size_t )((((unsigned long )((unsigned int )count___0 + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
#line 5206
              tmp___107 = xmax((size_t )tmp___106, tmp___105);
#line 5206
              n___3 = (size_t )tmp___107;
              }
#line 5213
              if (n___3 > allocated) {
#line 5213
                if (allocated > 0U) {
#line 5213
                  if (allocated <= 2147483647U) {
#line 5213
                    tmp___108 = allocated * 2U;
                  } else {
#line 5213
                    tmp___108 = 4294967295U;
                  }
#line 5213
                  allocated = tmp___108;
                } else {
#line 5213
                  allocated = (size_t )12;
                }
#line 5213
                if (n___3 > allocated) {
#line 5213
                  allocated = n___3;
                }
#line 5213
                if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5213
                  memory_size___3 = (size_t )((unsigned long )allocated * sizeof(char ));
                } else {
#line 5213
                  memory_size___3 = 4294967295U;
                }
#line 5213
                if (memory_size___3 == 4294967295U) {
#line 5213
                  goto out_of_memory;
                }
#line 5213
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 5213
                  tmp___109 = malloc(memory_size___3);
#line 5213
                  memory___3 = (char *)tmp___109;
                  }
                } else
#line 5213
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 5213
                  tmp___109 = malloc(memory_size___3);
#line 5213
                  memory___3 = (char *)tmp___109;
                  }
                } else {
                  {
#line 5213
                  tmp___110 = realloc((void *)result, memory_size___3);
#line 5213
                  memory___3 = (char *)tmp___110;
                  }
                }
#line 5213
                if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5213
                  goto out_of_memory;
                }
#line 5213
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5213
                  if (length > 0U) {
                    {
#line 5213
                    memcpy((void */* __restrict  */)memory___3, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 5213
                result = memory___3;
              }
#line 5214
              goto __Cont;
            }
          }
#line 5510
          length += (size_t )count___0;
#line 5511
          goto while_break___14;
          __Cont: /* CIL Label */ ;
        }
        while_break___14: /* CIL Label */ ;
        }
        {
#line 5513
        tmp___111 = __errno_location();
#line 5513
        *tmp___111 = orig_errno;
        }
      }
    }
#line 1844
    cp = dp->dir_end;
#line 1844
    i ++;
#line 1844
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5521
  tmp___118 = xsum(length, (size_t )1);
  }
#line 5521
  if (tmp___118 > (size_t __attribute__((__pure__))  )allocated) {
#line 5521
    if (allocated > 0U) {
#line 5521
      if (allocated <= 2147483647U) {
#line 5521
        tmp___113 = allocated * 2U;
      } else {
#line 5521
        tmp___113 = 4294967295U;
      }
#line 5521
      allocated = tmp___113;
    } else {
#line 5521
      allocated = (size_t )12;
    }
    {
#line 5521
    tmp___115 = xsum(length, (size_t )1);
    }
#line 5521
    if (tmp___115 > (size_t __attribute__((__pure__))  )allocated) {
      {
#line 5521
      tmp___114 = xsum(length, (size_t )1);
#line 5521
      allocated = (size_t )tmp___114;
      }
    }
#line 5521
    if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5521
      memory_size___4 = (size_t )((unsigned long )allocated * sizeof(char ));
    } else {
#line 5521
      memory_size___4 = 4294967295U;
    }
#line 5521
    if (memory_size___4 == 4294967295U) {
#line 5521
      goto out_of_memory;
    }
#line 5521
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
#line 5521
      tmp___116 = malloc(memory_size___4);
#line 5521
      memory___4 = (char *)tmp___116;
      }
    } else
#line 5521
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 5521
      tmp___116 = malloc(memory_size___4);
#line 5521
      memory___4 = (char *)tmp___116;
      }
    } else {
      {
#line 5521
      tmp___117 = realloc((void *)result, memory_size___4);
#line 5521
      memory___4 = (char *)tmp___117;
      }
    }
#line 5521
    if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
#line 5521
      goto out_of_memory;
    }
#line 5521
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5521
      if (length > 0U) {
        {
#line 5521
        memcpy((void */* __restrict  */)memory___4, (void const   */* __restrict  */)result,
               length);
        }
      }
    }
#line 5521
    result = memory___4;
  }
#line 5522
  *(result + length) = (char )'\000';
#line 5524
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5524
    if (length + 1U < allocated) {
      {
#line 5529
      tmp___119 = realloc((void *)result, (size_t )((unsigned long )(length + 1U) * sizeof(char )));
#line 5529
      memory___5 = (char *)tmp___119;
      }
#line 5530
      if ((unsigned long )memory___5 != (unsigned long )((void *)0)) {
#line 5531
        result = memory___5;
      }
    }
  }
#line 5534
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5535
    free((void *)buf_malloced);
    }
  }
#line 5536
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5536
    free((void *)d.dir);
    }
  }
#line 5536
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5536
    free((void *)a.arg);
    }
  }
#line 5537
  *lengthp = length;
#line 5542
  return (result);
  overflow: 
#line 5546
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5546
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5547
      free((void *)result);
      }
    }
  }
#line 5548
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5549
    free((void *)buf_malloced);
    }
  }
#line 5550
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5550
    free((void *)d.dir);
    }
  }
#line 5550
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5550
    free((void *)a.arg);
    }
  }
  {
#line 5551
  tmp___120 = __errno_location();
#line 5551
  *tmp___120 = 75;
  }
#line 5552
  return ((char *)((void *)0));
  out_of_memory: 
#line 5556
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5556
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5557
      free((void *)result);
      }
    }
  }
#line 5558
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5559
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
#line 5561
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5561
    free((void *)d.dir);
    }
  }
#line 5561
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5561
    free((void *)a.arg);
    }
  }
  {
#line 5562
  tmp___121 = __errno_location();
#line 5562
  *tmp___121 = 12;
  }
#line 5563
  return ((char *)((void *)0));
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 584
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 699
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 526 "./stdio.h"
int ( /* format attribute */ __attribute__((__nonnull__(1,2))) rpl_fprintf)(FILE *fp ,
                                                                            char const   *format 
                                                                            , ...) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
int timevar_report  =    0;
#line 49 "/usr/include/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 120 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
static float ticks_to_msec  ;
#line 78 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.h"
void init_timevar(void) ;
#line 79
void timevar_push(timevar_id_t timevar ) ;
#line 80
void timevar_pop(timevar_id_t timevar ) ;
#line 81
void timevar_start(timevar_id_t timevar ) ;
#line 82
void timevar_stop(timevar_id_t timevar ) ;
#line 83
void timevar_get(timevar_id_t timevar , struct timevar_time_def *elapsed ) ;
#line 84
void timevar_print(FILE *fp ) ;
#line 87
long get_run_time(void) ;
#line 88
void print_time(char const   *str , long total ) ;
#line 176 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
static struct timevar_def timevars[20]  ;
#line 179 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
static struct timevar_stack_def *stack  ;
#line 183 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
static struct timevar_stack_def *unused_stack_instances  ;
#line 188 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
static struct timevar_time_def start_time  ;
#line 190
static void get_time(struct timevar_time_def *now ) ;
#line 191
static void timevar_accumulate(struct timevar_time_def *timer , struct timevar_time_def *start ,
                               struct timevar_time_def *stop ) ;
#line 199 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
static void get_time(struct timevar_time_def *now ) 
{ 
  struct tms tms ;
  clock_t tmp ;

  {
#line 203
  now->user = (float )0;
#line 204
  now->sys = (float )0;
#line 205
  now->wall = (float )0;
#line 207
  if (! timevar_report) {
#line 208
    return;
  }
  {
#line 213
  tmp = times(& tms);
#line 213
  now->wall = (float )tmp * ticks_to_msec;
#line 218
  now->user = (float )(tms.tms_utime + tms.tms_cutime) * ticks_to_msec;
#line 219
  now->sys = (float )(tms.tms_stime + tms.tms_cstime) * ticks_to_msec;
  }
#line 236
  return;
}
}
#line 240 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
static void timevar_accumulate(struct timevar_time_def *timer , struct timevar_time_def *start ,
                               struct timevar_time_def *stop ) 
{ 


  {
#line 246
  timer->user += stop->user - start->user;
#line 247
  timer->sys += stop->sys - start->sys;
#line 248
  timer->wall += stop->wall - start->wall;
#line 249
  return;
}
}
#line 253 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
void init_timevar(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 256
  if (! timevar_report) {
#line 257
    return;
  }
  {
#line 260
  memset((void *)(timevars), 0, (size_t )sizeof(timevars));
#line 34 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.def"
  timevars[0].name = "total time";
#line 37
  timevars[1].name = "reader";
#line 38
  timevars[2].name = "scanner";
#line 39
  timevars[3].name = "parser";
#line 42
  timevars[4].name = "reducing the grammar";
#line 43
  timevars[5].name = "computing the sets";
#line 44
  timevars[6].name = "LR(0)";
#line 45
  timevars[7].name = "LALR(1)";
#line 46
  timevars[8].name = "IELR(1) Phase 1";
#line 47
  timevars[9].name = "IELR(1) Phase 2";
#line 48
  timevars[10].name = "IELR(1) Phase 3";
#line 49
  timevars[11].name = "IELR(1) Phase 4";
#line 50
  timevars[12].name = "conflicts";
#line 53
  timevars[13].name = "outputing report";
#line 54
  timevars[14].name = "outputing graph";
#line 55
  timevars[15].name = "outputing xml";
#line 56
  timevars[16].name = "parser action tables";
#line 57
  timevars[17].name = "outputing parser";
#line 58
  timevars[18].name = "running m4";
#line 61
  timevars[19].name = "freeing";
#line 269 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
  ticks_to_msec = (float )(1.0 / (double )100);
  }
#line 274
  return;
}
}
#line 283 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
void timevar_push(timevar_id_t timevar ) 
{ 
  struct timevar_def *tv ;
  struct timevar_stack_def *context ;
  struct timevar_time_def now ;
  void *tmp ;

  {
#line 287
  tv = & timevars[timevar];
#line 291
  if (! timevar_report) {
#line 292
    return;
  }
#line 295
  tv->used = 1U;
#line 298
  if (tv->standalone) {
    {
#line 299
    abort();
    }
  }
  {
#line 302
  get_time(& now);
  }
#line 306
  if (stack) {
    {
#line 307
    timevar_accumulate(& (stack->timevar)->elapsed, & start_time, & now);
    }
  }
#line 311
  start_time = now;
#line 315
  if ((unsigned long )unused_stack_instances != (unsigned long )((void *)0)) {
#line 317
    context = unused_stack_instances;
#line 318
    unused_stack_instances = unused_stack_instances->next;
  } else {
    {
#line 321
    tmp = xmalloc((size_t )sizeof(struct timevar_stack_def ));
#line 321
    context = (struct timevar_stack_def *)tmp;
    }
  }
#line 325
  context->timevar = tv;
#line 326
  context->next = stack;
#line 327
  stack = context;
#line 328
  return;
}
}
#line 336 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
void timevar_pop(timevar_id_t timevar ) 
{ 
  struct timevar_time_def now ;
  struct timevar_stack_def *popped ;

  {
#line 341
  popped = stack;
#line 343
  if (! timevar_report) {
#line 344
    return;
  }
#line 346
  if ((unsigned long )(& timevars[timevar]) != (unsigned long )stack->timevar) {
    {
#line 347
    abort();
    }
  }
  {
#line 350
  get_time(& now);
#line 353
  timevar_accumulate(& (popped->timevar)->elapsed, & start_time, & now);
#line 357
  start_time = now;
#line 360
  stack = stack->next;
#line 364
  popped->next = unused_stack_instances;
#line 365
  unused_stack_instances = popped;
  }
#line 366
  return;
}
}
#line 372 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
void timevar_start(timevar_id_t timevar ) 
{ 
  struct timevar_def *tv ;

  {
#line 376
  tv = & timevars[timevar];
#line 378
  if (! timevar_report) {
#line 379
    return;
  }
#line 382
  tv->used = 1U;
#line 386
  if (tv->standalone) {
    {
#line 387
    abort();
    }
  }
  {
#line 388
  tv->standalone = 1U;
#line 390
  get_time(& tv->start_time);
  }
#line 391
  return;
}
}
#line 396 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
void timevar_stop(timevar_id_t timevar ) 
{ 
  struct timevar_def *tv ;
  struct timevar_time_def now ;

  {
#line 400
  tv = & timevars[timevar];
#line 403
  if (! timevar_report) {
#line 404
    return;
  }
#line 407
  if (! tv->standalone) {
    {
#line 408
    abort();
    }
  }
  {
#line 410
  get_time(& now);
#line 411
  timevar_accumulate(& tv->elapsed, & tv->start_time, & now);
  }
#line 412
  return;
}
}
#line 417 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
void timevar_get(timevar_id_t timevar , struct timevar_time_def *elapsed ) 
{ 
  struct timevar_def *tv ;
  struct timevar_time_def now ;

  {
#line 422
  tv = & timevars[timevar];
#line 425
  *elapsed = tv->elapsed;
#line 428
  if (tv->standalone) {
    {
#line 430
    get_time(& now);
#line 431
    timevar_accumulate(elapsed, & tv->start_time, & now);
    }
  } else
#line 434
  if ((unsigned long )stack->timevar == (unsigned long )tv) {
    {
#line 436
    get_time(& now);
#line 437
    timevar_accumulate(elapsed, & start_time, & now);
    }
  }
#line 439
  return;
}
}
#line 445 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
void timevar_print(FILE *fp ) 
{ 
  unsigned int id ;
  struct timevar_time_def *total ;
  struct timevar_time_def now ;
  char *tmp ;
  struct timevar_def *tv ;
  float tiny ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 452
  total = & timevars[0].elapsed;
#line 455
  if (! timevar_report) {
#line 456
    return;
  }
#line 460
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
#line 461
    fp = stderr;
  }
  {
#line 464
  get_time(& now);
  }
#line 468
  if (stack) {
    {
#line 469
    timevar_accumulate(& (stack->timevar)->elapsed, & start_time, & now);
    }
  }
  {
#line 473
  start_time = now;
#line 475
  tmp = gettext("\nExecution times (seconds)\n");
#line 475
  fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)fp);
#line 476
  id = 0U;
  }
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (id < 20U)) {
#line 476
      goto while_break;
    }
#line 478
    tv = & timevars[(timevar_id_t )id];
#line 479
    tiny = (float )5e-3;
#line 483
    if ((unsigned int )((timevar_id_t )id) == 0U) {
#line 484
      goto __Cont;
    }
#line 487
    if (! tv->used) {
#line 488
      goto __Cont;
    }
#line 492
    if (tv->elapsed.user < tiny) {
#line 492
      if (tv->elapsed.sys < tiny) {
#line 492
        if (tv->elapsed.wall < tiny) {
#line 495
          goto __Cont;
        }
      }
    }
    {
#line 498
    rpl_fprintf(fp, " %-22s:", tv->name);
    }
#line 502
    if (total->user == (float )0) {
#line 502
      tmp___0 = (float )0;
    } else {
#line 502
      tmp___0 = tv->elapsed.user / total->user;
    }
    {
#line 502
    rpl_fprintf(fp, "%7.2f (%2.0f%%) usr", (double )tv->elapsed.user, (double )(tmp___0 * (float )100));
    }
#line 509
    if (total->sys == (float )0) {
#line 509
      tmp___1 = (float )0;
    } else {
#line 509
      tmp___1 = tv->elapsed.sys / total->sys;
    }
    {
#line 509
    rpl_fprintf(fp, "%7.2f (%2.0f%%) sys", (double )tv->elapsed.sys, (double )(tmp___1 * (float )100));
    }
#line 516
    if (total->wall == (float )0) {
#line 516
      tmp___2 = (float )0;
    } else {
#line 516
      tmp___2 = tv->elapsed.wall / total->wall;
    }
    {
#line 516
    rpl_fprintf(fp, "%7.2f (%2.0f%%) wall", (double )tv->elapsed.wall, (double )(tmp___2 * (float )100));
#line 521
    putc_unlocked('\n', fp);
    }
    __Cont: /* CIL Label */ 
#line 476
    id ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 525
  tmp___3 = gettext(" TOTAL                 :");
#line 525
  fputs_unlocked((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)fp);
#line 527
  rpl_fprintf(fp, "%7.2f          ", (double )total->user);
#line 530
  rpl_fprintf(fp, "%7.2f          ", (double )total->sys);
#line 533
  rpl_fprintf(fp, "%7.2f\n", (double )total->wall);
  }
#line 538
  return;
}
}
#line 543 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
long get_run_time(void) 
{ 
  struct timevar_time_def total_elapsed ;

  {
  {
#line 547
  timevar_get((timevar_id_t )0, & total_elapsed);
  }
#line 548
  return ((long )(total_elapsed.user + total_elapsed.sys));
}
}
#line 554 "/home/pronto/abs/test-suite/bison-2.5/lib/timevar.c"
void print_time(char const   *str , long total ) 
{ 
  long all_time ;
  long tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 559
  tmp = get_run_time();
#line 559
  all_time = tmp;
  }
#line 560
  if (all_time == 0L) {
#line 560
    tmp___0 = 0L;
  } else {
#line 560
    tmp___0 = (long )((100.0 * (double )total) / (double )all_time + .5);
  }
  {
#line 560
  tmp___1 = gettext("time in %s: %ld.%06ld (%ld%%)\n");
#line 560
  rpl_fprintf(stderr, (char const   *)tmp___1, str, total / 1000000L, total % 1000000L,
              tmp___0);
  }
#line 565
  return;
}
}
#line 31 "/home/pronto/abs/test-suite/bison-2.5/lib/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen ) ;
#line 94 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 27 "/home/pronto/abs/test-suite/bison-2.5/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ 
  char const   *end ;
  void *tmp ;

  {
  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
  }
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1L));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 40 "/home/pronto/abs/test-suite/bison-2.5/lib/dirname.h"
size_t base_len(char const   *name ) ;
#line 42
char *last_component(char const   *name ) ;
#line 44
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base___0 ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base___0 = tmp;
  }
#line 39
  if (! *base___0) {
#line 40
    base___0 = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base___0);
#line 41
  base_lim = base___0 + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 1233 "./stdio.h"
int ( /* format attribute */ __attribute__((__nonnull__(1,2))) rpl_sprintf)(char *str ,
                                                                            char const   *format 
                                                                            , ...) ;
#line 41 "/home/pronto/abs/test-suite/bison-2.5/lib/sprintf.c"
int ( /* format attribute */ __attribute__((__nonnull__(1,2))) rpl_sprintf)(char *str ,
                                                                            char const   *format 
                                                                            , ...) 
{ 
  char *output___0 ;
  size_t len ;
  size_t lenbuf ;
  va_list args ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 55
  lenbuf = 2147483647U;
#line 56
  if (lenbuf > ~ ((uintptr_t )str)) {
#line 57
    lenbuf = ~ ((uintptr_t )str);
  }
  {
#line 59
  __builtin_va_start(args, format);
#line 60
  output___0 = vasnprintf(str, & lenbuf, format, args);
#line 61
  len = lenbuf;
#line 62
  __builtin_va_end(args);
  }
#line 64
  if (! output___0) {
#line 65
    return (-1);
  }
#line 67
  if ((unsigned long )output___0 != (unsigned long )str) {
    {
#line 70
    free((void *)output___0);
#line 71
    tmp = __errno_location();
#line 71
    *tmp = 75;
    }
#line 72
    return (-1);
  }
#line 75
  if (len > 2147483647U) {
    {
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 75;
    }
#line 78
    return (-1);
  }
#line 81
  return ((int )len);
}
}
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 540
extern char **environ ;
#line 85 "/home/pronto/abs/test-suite/bison-2.5/lib/spawn-pipe.h"
pid_t create_pipe_out(char const   *progname , char const   *prog_path , char **prog_argv ,
                      char const   *prog_stdout , _Bool null_stderr , _Bool slave_process ,
                      _Bool exit_on_error , int *fd ) ;
#line 98
pid_t create_pipe_in(char const   *progname , char const   *prog_path , char **prog_argv ,
                     char const   *prog_stdin , _Bool null_stderr , _Bool slave_process ,
                     _Bool exit_on_error , int *fd ) ;
#line 126
pid_t create_pipe_bidi(char const   *progname , char const   *prog_path , char **prog_argv ,
                       _Bool null_stderr , _Bool slave_process , _Bool exit_on_error ,
                       int *fd ) ;
#line 255 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 68 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.h"
void block_fatal_signals(void) ;
#line 71
void unblock_fatal_signals(void) ;
#line 22 "/home/pronto/abs/test-suite/bison-2.5/lib/unistd-safer.h"
int pipe_safer(int *fd ) ;
#line 84 "/usr/include/spawn.h"
extern int posix_spawnp(pid_t *__pid , char const   *__file , posix_spawn_file_actions_t const   *__file_actions ,
                        posix_spawnattr_t const   *__attrp , char * const  *__argv ,
                        char * const  *__envp ) ;
#line 91
extern  __attribute__((__nothrow__)) int posix_spawnattr_init(posix_spawnattr_t *__attr ) ;
#line 94
extern  __attribute__((__nothrow__)) int posix_spawnattr_destroy(posix_spawnattr_t *__attr ) ;
#line 115
extern  __attribute__((__nothrow__)) int posix_spawnattr_setsigmask(posix_spawnattr_t * __restrict  __attr ,
                                                                    sigset_t const   * __restrict  __sigmask ) ;
#line 125
extern  __attribute__((__nothrow__)) int posix_spawnattr_setflags(posix_spawnattr_t *_attr ,
                                                                  short __flags ) ;
#line 160
extern  __attribute__((__nothrow__)) int posix_spawn_file_actions_init(posix_spawn_file_actions_t *__file_actions ) ;
#line 164
extern  __attribute__((__nothrow__)) int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *__file_actions ) ;
#line 169
extern  __attribute__((__nothrow__)) int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t * __restrict  __file_actions ,
                                                                          int __fd ,
                                                                          char const   * __restrict  __path ,
                                                                          int __oflag ,
                                                                          mode_t __mode ) ;
#line 178
extern  __attribute__((__nothrow__)) int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *__file_actions ,
                                                                           int __fd ) ;
#line 184
extern  __attribute__((__nothrow__)) int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *__file_actions ,
                                                                          int __fd ,
                                                                          int __newfd ) ;
#line 63 "/home/pronto/abs/test-suite/bison-2.5/lib/spawn-pipe.c"
__inline static int nonintr_close(int fd ) 
{ 
  int retval ;
  int *tmp ;

  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    retval = close(fd);
    }
#line 68
    if (retval < 0) {
      {
#line 68
      tmp = __errno_location();
      }
#line 68
      if (! (*tmp == 4)) {
#line 68
        goto while_break;
      }
    } else {
#line 68
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return (retval);
}
}
#line 106 "/home/pronto/abs/test-suite/bison-2.5/lib/spawn-pipe.c"
static pid_t create_pipe(char const   *progname , char const   *prog_path , char **prog_argv ,
                         _Bool pipe_stdin , _Bool pipe_stdout , char const   *prog_stdin ,
                         char const   *prog_stdout , _Bool null_stderr , _Bool slave_process ,
                         _Bool exit_on_error , int *fd ) 
{ 
  int ifd[2] ;
  int ofd[2] ;
  sigset_t blocked_signals ;
  posix_spawn_file_actions_t actions___0 ;
  _Bool actions_allocated___0 ;
  posix_spawnattr_t attrs ;
  _Bool attrs_allocated ;
  int err ;
  pid_t child ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  posix_spawnattr_t *tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 260
  if (pipe_stdout) {
    {
#line 261
    tmp___1 = pipe_safer((int *)(ifd));
    }
#line 261
    if (tmp___1 < 0) {
      {
#line 262
      tmp = gettext("cannot create pipe");
#line 262
      tmp___0 = __errno_location();
#line 262
      error(1, *tmp___0, (char const   *)tmp);
      }
    }
  }
#line 263
  if (pipe_stdin) {
    {
#line 264
    tmp___4 = pipe_safer((int *)(ofd));
    }
#line 264
    if (tmp___4 < 0) {
      {
#line 265
      tmp___2 = gettext("cannot create pipe");
#line 265
      tmp___3 = __errno_location();
#line 265
      error(1, *tmp___3, (char const   *)tmp___2);
      }
    }
  }
#line 275
  if (slave_process) {
    {
#line 277
    sigprocmask(2, (sigset_t const   */* __restrict  */)((void *)0), (sigset_t */* __restrict  */)(& blocked_signals));
#line 278
    block_fatal_signals();
    }
  }
  {
#line 280
  actions_allocated___0 = (_Bool)0;
#line 281
  attrs_allocated = (_Bool)0;
#line 282
  err = posix_spawn_file_actions_init(& actions___0);
  }
#line 282
  if (err != 0) {
#line 282
    goto _L___12;
  } else {
#line 282
    actions_allocated___0 = (_Bool)1;
#line 282
    if (pipe_stdin) {
      {
#line 282
      err = posix_spawn_file_actions_adddup2(& actions___0, ofd[0], 0);
      }
#line 282
      if (err != 0) {
#line 282
        tmp___10 = 1;
      } else {
#line 282
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 282
    if (pipe_stdout) {
      {
#line 282
      err = posix_spawn_file_actions_adddup2(& actions___0, ifd[1], 1);
      }
#line 282
      if (err != 0) {
#line 282
        tmp___10 = 1;
      } else {
#line 282
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 282
    if (pipe_stdin) {
      {
#line 282
      err = posix_spawn_file_actions_addclose(& actions___0, ofd[0]);
      }
#line 282
      if (err != 0) {
#line 282
        tmp___10 = 1;
      } else {
#line 282
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 282
    if (pipe_stdout) {
      {
#line 282
      err = posix_spawn_file_actions_addclose(& actions___0, ifd[1]);
      }
#line 282
      if (err != 0) {
#line 282
        tmp___10 = 1;
      } else {
#line 282
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 282
    if (pipe_stdin) {
      {
#line 282
      err = posix_spawn_file_actions_addclose(& actions___0, ofd[1]);
      }
#line 282
      if (err != 0) {
#line 282
        tmp___10 = 1;
      } else {
#line 282
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 282
    if (pipe_stdout) {
      {
#line 282
      err = posix_spawn_file_actions_addclose(& actions___0, ifd[0]);
      }
#line 282
      if (err != 0) {
#line 282
        tmp___10 = 1;
      } else {
#line 282
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 282
    if (null_stderr) {
      {
#line 282
      err = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t */* __restrict  */)(& actions___0),
                                             2, (char const   */* __restrict  */)"/dev/null",
                                             2, (mode_t )0);
      }
#line 282
      if (err != 0) {
#line 282
        tmp___10 = 1;
      } else {
#line 282
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 282
    if (! pipe_stdin) {
#line 282
      if ((unsigned long )prog_stdin != (unsigned long )((void *)0)) {
        {
#line 282
        err = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t */* __restrict  */)(& actions___0),
                                               0, (char const   */* __restrict  */)prog_stdin,
                                               0, (mode_t )0);
        }
#line 282
        if (err != 0) {
#line 282
          tmp___10 = 1;
        } else {
#line 282
          goto _L___4;
        }
      } else {
#line 282
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 282
    if (! pipe_stdout) {
#line 282
      if ((unsigned long )prog_stdout != (unsigned long )((void *)0)) {
        {
#line 282
        err = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t */* __restrict  */)(& actions___0),
                                               1, (char const   */* __restrict  */)prog_stdout,
                                               1, (mode_t )0);
        }
#line 282
        if (err != 0) {
#line 282
          tmp___10 = 1;
        } else {
#line 282
          goto _L___2;
        }
      } else {
#line 282
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 282
    if (slave_process) {
      {
#line 282
      err = posix_spawnattr_init(& attrs);
      }
#line 282
      if (err != 0) {
#line 282
        tmp___10 = 1;
      } else {
        {
#line 282
        attrs_allocated = (_Bool)1;
#line 282
        err = posix_spawnattr_setsigmask((posix_spawnattr_t */* __restrict  */)(& attrs),
                                         (sigset_t const   */* __restrict  */)(& blocked_signals));
        }
#line 282
        if (err != 0) {
#line 282
          tmp___8 = 1;
        } else {
          {
#line 282
          err = posix_spawnattr_setflags(& attrs, (short)8);
          }
#line 282
          if (err != 0) {
#line 282
            tmp___8 = 1;
          } else {
#line 282
            tmp___8 = 0;
          }
        }
#line 282
        if (tmp___8) {
#line 282
          tmp___10 = 1;
        } else {
#line 282
          goto _L___0;
        }
      }
    } else {
      _L___0: /* CIL Label */ 
#line 282
      if (attrs_allocated) {
#line 282
        tmp___9 = & attrs;
      } else {
#line 282
        tmp___9 = (posix_spawnattr_t *)((void *)0);
      }
      {
#line 282
      err = posix_spawnp(& child, prog_path, (posix_spawn_file_actions_t const   *)(& actions___0),
                         (posix_spawnattr_t const   *)tmp___9, (char * const  *)prog_argv,
                         (char * const  *)environ);
      }
#line 282
      if (err != 0) {
#line 282
        tmp___10 = 1;
      } else {
#line 282
        tmp___10 = 0;
      }
    }
#line 282
    if (tmp___10) {
      _L___12: /* CIL Label */ 
#line 338
      if (actions_allocated___0) {
        {
#line 339
        posix_spawn_file_actions_destroy(& actions___0);
        }
      }
#line 340
      if (attrs_allocated) {
        {
#line 341
        posix_spawnattr_destroy(& attrs);
        }
      }
#line 342
      if (slave_process) {
        {
#line 343
        unblock_fatal_signals();
        }
      }
#line 344
      if (exit_on_error) {
#line 344
        goto _L;
      } else
#line 344
      if (! null_stderr) {
        _L: /* CIL Label */ 
        {
#line 345
        tmp___5 = gettext("%s subprocess failed");
        }
#line 345
        if (exit_on_error) {
#line 345
          tmp___6 = 1;
        } else {
#line 345
          tmp___6 = 0;
        }
        {
#line 345
        error(tmp___6, err, (char const   *)tmp___5, progname);
        }
      }
#line 347
      if (pipe_stdout) {
        {
#line 349
        nonintr_close(ifd[0]);
#line 350
        nonintr_close(ifd[1]);
        }
      }
#line 352
      if (pipe_stdin) {
        {
#line 354
        nonintr_close(ofd[0]);
#line 355
        nonintr_close(ofd[1]);
        }
      }
      {
#line 357
      tmp___7 = __errno_location();
#line 357
      *tmp___7 = err;
      }
#line 358
      return (-1);
    }
  }
  {
#line 360
  posix_spawn_file_actions_destroy(& actions___0);
  }
#line 361
  if (attrs_allocated) {
    {
#line 362
    posix_spawnattr_destroy(& attrs);
    }
  }
#line 363
  if (slave_process) {
    {
#line 365
    register_slave_subprocess(child);
#line 366
    unblock_fatal_signals();
    }
  }
#line 368
  if (pipe_stdin) {
    {
#line 369
    nonintr_close(ofd[0]);
    }
  }
#line 370
  if (pipe_stdout) {
    {
#line 371
    nonintr_close(ifd[1]);
    }
  }
#line 373
  if (pipe_stdout) {
#line 374
    *(fd + 0) = ifd[0];
  }
#line 375
  if (pipe_stdin) {
#line 376
    *(fd + 1) = ofd[1];
  }
#line 377
  return (child);
}
}
#line 390 "/home/pronto/abs/test-suite/bison-2.5/lib/spawn-pipe.c"
pid_t create_pipe_bidi(char const   *progname , char const   *prog_path , char **prog_argv ,
                       _Bool null_stderr , _Bool slave_process , _Bool exit_on_error ,
                       int *fd ) 
{ 
  pid_t result ;
  pid_t tmp ;

  {
  {
#line 397
  tmp = create_pipe(progname, prog_path, prog_argv, (_Bool)1, (_Bool)1, (char const   *)((void *)0),
                    (char const   *)((void *)0), null_stderr, slave_process, exit_on_error,
                    fd);
#line 397
  result = tmp;
  }
#line 401
  return (result);
}
}
#line 411 "/home/pronto/abs/test-suite/bison-2.5/lib/spawn-pipe.c"
pid_t create_pipe_in(char const   *progname , char const   *prog_path , char **prog_argv ,
                     char const   *prog_stdin , _Bool null_stderr , _Bool slave_process ,
                     _Bool exit_on_error , int *fd ) 
{ 
  int iofd[2] ;
  pid_t result ;
  pid_t tmp ;
  void *__cil_tmp12 ;

  {
  {
#line 419
  tmp = create_pipe(progname, prog_path, prog_argv, (_Bool)0, (_Bool)1, prog_stdin,
                    (char const   *)((void *)0), null_stderr, slave_process, exit_on_error,
                    (int *)(iofd));
#line 419
  result = tmp;
  }
#line 423
  if (result != -1) {
#line 424
    *(fd + 0) = iofd[0];
  }
#line 425
  return (result);
}
}
#line 435 "/home/pronto/abs/test-suite/bison-2.5/lib/spawn-pipe.c"
pid_t create_pipe_out(char const   *progname , char const   *prog_path , char **prog_argv ,
                      char const   *prog_stdout , _Bool null_stderr , _Bool slave_process ,
                      _Bool exit_on_error , int *fd ) 
{ 
  int iofd[2] ;
  pid_t result ;
  pid_t tmp ;
  void *__cil_tmp12 ;

  {
  {
#line 443
  tmp = create_pipe(progname, prog_path, prog_argv, (_Bool)1, (_Bool)0, (char const   *)((void *)0),
                    prog_stdout, null_stderr, slave_process, exit_on_error, (int *)(iofd));
#line 443
  result = tmp;
  }
#line 447
  if (result != -1) {
#line 448
    *(fd + 0) = iofd[1];
  }
#line 449
  return (result);
}
}
#line 1194 "./stdio.h"
int ( /* format attribute */ __attribute__((__nonnull__(3))) rpl_snprintf)(char *str ,
                                                                           size_t size ,
                                                                           char const   *format 
                                                                           , ...) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/lib/snprintf.c"
int ( /* format attribute */ __attribute__((__nonnull__(3))) rpl_snprintf)(char *str ,
                                                                           size_t size ,
                                                                           char const   *format 
                                                                           , ...) 
{ 
  char *output___0 ;
  size_t len ;
  size_t lenbuf ;
  va_list args ;
  size_t pruned_len ;
  size_t tmp ;
  int *tmp___0 ;

  {
  {
#line 44
  lenbuf = size;
#line 47
  __builtin_va_start(args, format);
#line 48
  output___0 = vasnprintf(str, & lenbuf, format, args);
#line 49
  len = lenbuf;
#line 50
  __builtin_va_end(args);
  }
#line 52
  if (! output___0) {
#line 53
    return (-1);
  }
#line 55
  if ((unsigned long )output___0 != (unsigned long )str) {
#line 57
    if (size) {
#line 59
      if (len < size) {
#line 59
        tmp = len;
      } else {
#line 59
        tmp = size - 1U;
      }
      {
#line 59
      pruned_len = tmp;
#line 60
      memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)output___0,
             pruned_len);
#line 61
      *(str + pruned_len) = (char )'\000';
      }
    }
    {
#line 64
    free((void *)output___0);
    }
  }
#line 67
  if (2147483647U < len) {
    {
#line 69
    tmp___0 = __errno_location();
#line 69
    *tmp___0 = 75;
    }
#line 70
    return (-1);
  }
#line 73
  return ((int )len);
}
}
#line 234 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 235
enum quoting_style  const  quoting_style_vals[8] ;
#line 245
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 248
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 252
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 261
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 267
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 278
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 293
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 300
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 309
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 319
char *quotearg_n(int n , char const   *arg ) ;
#line 322
char *quotearg(char const   *arg ) ;
#line 327
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 330
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 335
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 340
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 344
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 347
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 352
char *quotearg_char(char const   *arg , char ch ) ;
#line 355
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 358
char *quotearg_colon(char const   *arg ) ;
#line 361
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 367
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 372
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 377
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 382
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 387
void quotearg_free(void) ;
#line 127 "/home/pronto/abs/test-suite/bison-2.5/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 129
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 129 "/home/pronto/abs/test-suite/bison-2.5/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 132
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 132
    tmp = -1;
  } else {
#line 132
    tmp = -2;
  }
#line 132
  if ((size_t )tmp / s < n) {
    {
#line 133
    xalloc_die();
    }
  }
  {
#line 134
//  tmp___0 = xmalloc(n * s);
  tmp___0 = xmalloc(n);
  }
#line 134
  return (tmp___0);
}
}
#line 242
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 244
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 244 "/home/pronto/abs/test-suite/bison-2.5/lib/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 247
  if (sizeof(char ) == 1UL) {
    {
#line 247
    tmp = xmalloc(n);
#line 247
    tmp___1 = tmp;
    }
  } else {
    {
#line 247
    tmp___0 = xnmalloc(n, (size_t )sizeof(char ));
#line 247
    tmp___1 = tmp___0;
    }
  }
#line 247
  return ((char *)tmp___1);
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 359 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 137 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 65 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 65 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 79 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 79
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 92 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 97 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 100
  tmp = __errno_location();
#line 100
  e = *tmp;
  }
#line 101
  if (o) {
#line 101
    tmp___0 = o;
  } else {
#line 101
    tmp___0 = & default_quoting_options;
  }
  {
#line 101
  tmp___1 = xmemdup((void const   *)tmp___0, (size_t )sizeof(*o));
#line 101
  p = (struct quoting_options *)tmp___1;
#line 103
  tmp___2 = __errno_location();
#line 103
  *tmp___2 = e;
  }
#line 104
  return (p);
}
}
#line 108 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 111
  if (o) {
#line 111
    tmp = o;
  } else {
#line 111
    tmp = & default_quoting_options;
  }
#line 111
  return (tmp->style);
}
}
#line 116 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 119
  if (o) {
#line 119
    tmp = o;
  } else {
#line 119
    tmp = & default_quoting_options;
  }
#line 119
  tmp->style = s;
#line 120
  return;
}
}
#line 127 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 130
  uc = (unsigned char )c;
#line 131
  if (o) {
#line 131
    tmp = o;
  } else {
#line 131
    tmp = & default_quoting_options;
  }
#line 131
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 133
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 134
  r = (int )((*p >> shift) & 1U);
#line 135
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 136
  return (r);
}
}
#line 143 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 147
  if (! o) {
#line 148
    o = & default_quoting_options;
  }
#line 149
  r = o->flags;
#line 150
  o->flags = i;
#line 151
  return (r);
}
}
#line 154 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 158
  if (! o) {
#line 159
    o = & default_quoting_options;
  }
#line 160
  o->style = (enum quoting_style )8;
#line 161
  if (! left_quote) {
    {
#line 162
    abort();
    }
  } else
#line 161
  if (! right_quote) {
    {
#line 162
    abort();
    }
  }
#line 163
  o->left_quote = left_quote;
#line 164
  o->right_quote = right_quote;
#line 165
  return;
}
}
#line 168 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;

  {
  {
#line 172
  o.style = style;
#line 173
  o.flags = 0;
#line 174
  memset((void *)(o.quote_these_too), 0, (size_t )sizeof(o.quote_these_too));
  }
#line 175
  return (o);
}
}
#line 180 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 183
  tmp = gettext(msgid);
#line 183
  translation = (char const   *)tmp;
  }
#line 184
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 184
    if ((unsigned int )s == 7U) {
#line 185
      translation = "\"";
    }
  }
#line 186
  return (translation);
}
}
#line 202 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 211
  len = (size_t )0;
#line 212
  quote_string = (char const   *)0;
#line 213
  quote_string_len = (size_t )0;
#line 214
  backslash_escapes = (_Bool)0;
#line 215
  tmp = __ctype_get_mb_cur_max();
#line 215
  unibyte_locale = (_Bool )(tmp == 1U);
#line 216
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 229
  if ((unsigned int )quoting_style == 4U) {
#line 229
    goto case_4;
  }
#line 233
  if ((unsigned int )quoting_style == 3U) {
#line 233
    goto case_3;
  }
#line 241
  if ((unsigned int )quoting_style == 5U) {
#line 241
    goto case_5;
  }
#line 248
  if ((unsigned int )quoting_style == 8U) {
#line 248
    goto case_8;
  }
#line 248
  if ((unsigned int )quoting_style == 7U) {
#line 248
    goto case_8;
  }
#line 248
  if ((unsigned int )quoting_style == 6U) {
#line 248
    goto case_8;
  }
#line 283
  if ((unsigned int )quoting_style == 1U) {
#line 283
    goto case_1;
  }
#line 287
  if ((unsigned int )quoting_style == 2U) {
#line 287
    goto case_2;
  }
#line 294
  if ((unsigned int )quoting_style == 0U) {
#line 294
    goto case_0;
  }
#line 298
  goto switch_default;
  case_4: /* CIL Label */ 
#line 230
  quoting_style = (enum quoting_style )3;
#line 231
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 234
  if (! elide_outer_quotes) {
    {
#line 235
    while (1) {
      while_continue: /* CIL Label */ ;
#line 235
      if (len < buffersize) {
#line 235
        *(buffer + len) = (char )'\"';
      }
#line 235
      len ++;
#line 235
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 236
  backslash_escapes = (_Bool)1;
#line 237
  quote_string = "\"";
#line 238
  quote_string_len = (size_t )1;
#line 239
  goto switch_break;
  case_5: /* CIL Label */ 
#line 242
  backslash_escapes = (_Bool)1;
#line 243
  elide_outer_quotes = (_Bool)0;
#line 244
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 250
  if ((unsigned int )quoting_style != 8U) {
    {
#line 271
    left_quote = gettext_quote("`", quoting_style);
#line 272
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 274
  if (! elide_outer_quotes) {
#line 275
    quote_string = left_quote;
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! *quote_string) {
#line 275
        goto while_break___0;
      }
      {
#line 276
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 276
        if (len < buffersize) {
#line 276
          *(buffer + len) = (char )*quote_string;
        }
#line 276
        len ++;
#line 276
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 275
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 277
  backslash_escapes = (_Bool)1;
#line 278
  quote_string = right_quote;
#line 279
  quote_string_len = strlen(quote_string);
  }
#line 281
  goto switch_break;
  case_1: /* CIL Label */ 
#line 284
  quoting_style = (enum quoting_style )2;
#line 285
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 288
  if (! elide_outer_quotes) {
    {
#line 289
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 289
      if (len < buffersize) {
#line 289
        *(buffer + len) = (char )'\'';
      }
#line 289
      len ++;
#line 289
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 290
  quote_string = "\'";
#line 291
  quote_string_len = (size_t )1;
#line 292
  goto switch_break;
  case_0: /* CIL Label */ 
#line 295
  elide_outer_quotes = (_Bool)0;
#line 296
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 299
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 302
  i = (size_t )0;
  {
#line 302
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 302
    if (argsize == 4294967295U) {
#line 302
      tmp___6 = (int const   )*(arg + i) == 0;
    } else {
#line 302
      tmp___6 = i == argsize;
    }
#line 302
    if (tmp___6) {
#line 302
      goto while_break___3;
    }
#line 306
    is_right_quote = (_Bool)0;
#line 308
    if (backslash_escapes) {
#line 308
      if (quote_string_len) {
#line 308
        if (i + quote_string_len <= argsize) {
          {
#line 308
          tmp___0 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 308
          if (tmp___0 == 0) {
#line 313
            if (elide_outer_quotes) {
#line 314
              goto force_outer_quoting_style;
            }
#line 315
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 318
    c = (unsigned char )*(arg + i);
    {
#line 321
    if ((int )c == 0) {
#line 321
      goto case_0___0;
    }
#line 347
    if ((int )c == 63) {
#line 347
      goto case_63;
    }
#line 385
    if ((int )c == 7) {
#line 385
      goto case_7___0;
    }
#line 386
    if ((int )c == 8) {
#line 386
      goto case_8___0;
    }
#line 387
    if ((int )c == 12) {
#line 387
      goto case_12;
    }
#line 388
    if ((int )c == 10) {
#line 388
      goto case_10;
    }
#line 389
    if ((int )c == 13) {
#line 389
      goto case_13;
    }
#line 390
    if ((int )c == 9) {
#line 390
      goto case_9;
    }
#line 391
    if ((int )c == 11) {
#line 391
      goto case_11;
    }
#line 392
    if ((int )c == 92) {
#line 392
      goto case_92;
    }
#line 411
    if ((int )c == 125) {
#line 411
      goto case_125;
    }
#line 411
    if ((int )c == 123) {
#line 411
      goto case_125;
    }
#line 415
    if ((int )c == 126) {
#line 415
      goto case_126;
    }
#line 415
    if ((int )c == 35) {
#line 415
      goto case_126;
    }
#line 427
    if ((int )c == 124) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 96) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 94) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 91) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 62) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 61) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 60) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 59) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 42) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 41) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 40) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 38) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 36) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 34) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 33) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 32) {
#line 427
      goto case_124;
    }
#line 437
    if ((int )c == 39) {
#line 437
      goto case_39___0;
    }
#line 459
    if ((int )c == 122) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 121) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 120) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 119) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 118) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 117) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 116) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 115) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 114) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 113) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 112) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 111) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 110) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 109) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 108) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 107) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 106) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 105) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 104) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 103) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 102) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 101) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 100) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 99) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 98) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 97) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 95) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 93) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 90) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 89) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 88) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 87) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 86) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 85) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 84) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 83) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 82) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 81) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 80) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 79) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 78) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 77) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 76) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 75) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 74) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 73) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 72) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 71) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 70) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 69) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 68) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 67) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 66) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 65) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 58) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 57) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 56) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 55) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 54) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 53) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 52) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 51) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 50) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 49) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 48) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 47) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 46) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 45) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 44) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 43) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 37) {
#line 459
      goto case_122;
    }
#line 472
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 322
    if (backslash_escapes) {
#line 324
      if (elide_outer_quotes) {
#line 325
        goto force_outer_quoting_style;
      }
      {
#line 326
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 326
        if (len < buffersize) {
#line 326
          *(buffer + len) = (char )'\\';
        }
#line 326
        len ++;
#line 326
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 332
      if (i + 1U < argsize) {
#line 332
        if (48 <= (int )*(arg + (i + 1U))) {
#line 332
          if ((int const   )*(arg + (i + 1U)) <= 57) {
            {
#line 334
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 334
              if (len < buffersize) {
#line 334
                *(buffer + len) = (char )'0';
              }
#line 334
              len ++;
#line 334
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 335
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 335
              if (len < buffersize) {
#line 335
                *(buffer + len) = (char )'0';
              }
#line 335
              len ++;
#line 335
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 337
      c = (unsigned char )'0';
    } else
#line 343
    if (flags & 1) {
#line 344
      goto __Cont;
    }
#line 345
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 350
    if ((unsigned int )quoting_style == 2U) {
#line 350
      goto case_2___0;
    }
#line 355
    if ((unsigned int )quoting_style == 3U) {
#line 355
      goto case_3___0;
    }
#line 380
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 351
    if (elide_outer_quotes) {
#line 352
      goto force_outer_quoting_style;
    }
#line 353
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 356
    if (flags & 4) {
#line 356
      if (i + 2U < argsize) {
#line 356
        if ((int const   )*(arg + (i + 1U)) == 63) {
          {
#line 362
          if ((int const   )*(arg + (i + 2U)) == 62) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2U)) == 61) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2U)) == 60) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2U)) == 47) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2U)) == 45) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2U)) == 41) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2U)) == 40) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2U)) == 39) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2U)) == 33) {
#line 362
            goto case_62;
          }
#line 375
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 365
          if (elide_outer_quotes) {
#line 366
            goto force_outer_quoting_style;
          }
#line 367
          c = (unsigned char )*(arg + (i + 2U));
#line 368
          i += 2U;
          {
#line 369
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 369
            if (len < buffersize) {
#line 369
              *(buffer + len) = (char )'?';
            }
#line 369
            len ++;
#line 369
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 370
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 370
            if (len < buffersize) {
#line 370
              *(buffer + len) = (char )'\"';
            }
#line 370
            len ++;
#line 370
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 371
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 371
            if (len < buffersize) {
#line 371
              *(buffer + len) = (char )'\"';
            }
#line 371
            len ++;
#line 371
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 372
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 372
            if (len < buffersize) {
#line 372
              *(buffer + len) = (char )'?';
            }
#line 372
            len ++;
#line 372
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 373
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 376
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 378
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 381
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 383
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 385
    esc = (unsigned char )'a';
#line 385
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 386
    esc = (unsigned char )'b';
#line 386
    goto c_escape;
    case_12: /* CIL Label */ 
#line 387
    esc = (unsigned char )'f';
#line 387
    goto c_escape;
    case_10: /* CIL Label */ 
#line 388
    esc = (unsigned char )'n';
#line 388
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 389
    esc = (unsigned char )'r';
#line 389
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 390
    esc = (unsigned char )'t';
#line 390
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 391
    esc = (unsigned char )'v';
#line 391
    goto c_escape;
    case_92: /* CIL Label */ 
#line 392
    esc = c;
#line 395
    if (backslash_escapes) {
#line 395
      if (elide_outer_quotes) {
#line 395
        if (quote_string_len) {
#line 396
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 399
    if ((unsigned int )quoting_style == 2U) {
#line 399
      if (elide_outer_quotes) {
#line 401
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 404
    if (backslash_escapes) {
#line 406
      c = esc;
#line 407
      goto store_escape;
    }
#line 409
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 412
    if (argsize == 4294967295U) {
#line 412
      tmp___1 = (int const   )*(arg + 1) == 0;
    } else {
#line 412
      tmp___1 = argsize == 1U;
    }
#line 412
    if (! tmp___1) {
#line 413
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 416
    if (i != 0U) {
#line 417
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 432
    if ((unsigned int )quoting_style == 2U) {
#line 432
      if (elide_outer_quotes) {
#line 434
        goto force_outer_quoting_style;
      }
    }
#line 435
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 438
    if ((unsigned int )quoting_style == 2U) {
#line 440
      if (elide_outer_quotes) {
#line 441
        goto force_outer_quoting_style;
      }
      {
#line 442
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 442
        if (len < buffersize) {
#line 442
          *(buffer + len) = (char )'\'';
        }
#line 442
        len ++;
#line 442
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 443
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 443
        if (len < buffersize) {
#line 443
          *(buffer + len) = (char )'\\';
        }
#line 443
        len ++;
#line 443
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 444
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 444
        if (len < buffersize) {
#line 444
          *(buffer + len) = (char )'\'';
        }
#line 444
        len ++;
#line 444
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 446
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 470
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 484
    if (unibyte_locale) {
      {
#line 486
      m = (size_t )1;
#line 487
      tmp___2 = __ctype_b_loc();
#line 487
      printable = (_Bool )(((int const   )*(*tmp___2 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 492
      memset((void *)(& mbstate), 0, (size_t )sizeof(mbstate));
#line 494
      m = (size_t )0;
#line 495
      printable = (_Bool)1;
      }
#line 496
      if (argsize == 4294967295U) {
        {
#line 497
        argsize = strlen(arg);
        }
      }
      {
#line 499
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 502
        tmp___3 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), & mbstate);
#line 502
        bytes = tmp___3;
        }
#line 504
        if (bytes == 0U) {
#line 505
          goto while_break___14;
        } else
#line 506
        if (bytes == 4294967295U) {
#line 508
          printable = (_Bool)0;
#line 509
          goto while_break___14;
        } else
#line 511
        if (bytes == 4294967294U) {
#line 513
          printable = (_Bool)0;
          {
#line 514
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 514
            if (i + m < argsize) {
#line 514
              if (! *(arg + (i + m))) {
#line 514
                goto while_break___15;
              }
            } else {
#line 514
              goto while_break___15;
            }
#line 515
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 516
          goto while_break___14;
        } else {
#line 524
          if (elide_outer_quotes) {
#line 524
            if ((unsigned int )quoting_style == 2U) {
#line 528
              j = (size_t )1;
              {
#line 528
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 528
                if (! (j < bytes)) {
#line 528
                  goto while_break___16;
                }
                {
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 532
                  goto case_124___0;
                }
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 532
                  goto case_124___0;
                }
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 532
                  goto case_124___0;
                }
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 532
                  goto case_124___0;
                }
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 532
                  goto case_124___0;
                }
#line 535
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 533
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 536
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 528
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 540
          tmp___4 = iswprint((wint_t )w);
          }
#line 540
          if (! tmp___4) {
#line 541
            printable = (_Bool)0;
          }
#line 542
          m += bytes;
        }
        {
#line 499
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 499
        if (tmp___5) {
#line 499
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 548
    if (1U < m) {
#line 548
      goto _L___0;
    } else
#line 548
    if (backslash_escapes) {
#line 548
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 552
        ilim = i + m;
        {
#line 554
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 556
          if (backslash_escapes) {
#line 556
            if (! printable) {
#line 558
              if (elide_outer_quotes) {
#line 559
                goto force_outer_quoting_style;
              }
              {
#line 560
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 560
                if (len < buffersize) {
#line 560
                  *(buffer + len) = (char )'\\';
                }
#line 560
                len ++;
#line 560
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 561
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 561
                if (len < buffersize) {
#line 561
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 561
                len ++;
#line 561
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 562
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 562
                if (len < buffersize) {
#line 562
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 562
                len ++;
#line 562
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 563
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 556
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 565
          if (is_right_quote) {
            {
#line 567
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 567
              if (len < buffersize) {
#line 567
                *(buffer + len) = (char )'\\';
              }
#line 567
              len ++;
#line 567
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 568
            is_right_quote = (_Bool)0;
          }
#line 570
          if (ilim <= i + 1U) {
#line 571
            goto while_break___17;
          }
          {
#line 572
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 572
            if (len < buffersize) {
#line 572
              *(buffer + len) = (char )c;
            }
#line 572
            len ++;
#line 572
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 573
          i ++;
#line 573
          c = (unsigned char )*(arg + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 576
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 581
    if (backslash_escapes) {
#line 581
      goto _L___3;
    } else
#line 581
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 581
      if (quote_these_too) {
#line 581
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 581
          goto _L___2;
        }
      } else {
#line 581
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 581
    if (! is_right_quote) {
#line 585
      goto store_c;
    }
    store_escape: 
#line 588
    if (elide_outer_quotes) {
#line 589
      goto force_outer_quoting_style;
    }
    {
#line 590
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 590
      if (len < buffersize) {
#line 590
        *(buffer + len) = (char )'\\';
      }
#line 590
      len ++;
#line 590
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 593
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 593
      if (len < buffersize) {
#line 593
        *(buffer + len) = (char )c;
      }
#line 593
      len ++;
#line 593
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 302
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 596
  if (len == 0U) {
#line 596
    if ((unsigned int )quoting_style == 2U) {
#line 596
      if (elide_outer_quotes) {
#line 598
        goto force_outer_quoting_style;
      }
    }
  }
#line 600
  if (quote_string) {
#line 600
    if (! elide_outer_quotes) {
      {
#line 601
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 601
        if (! *quote_string) {
#line 601
          goto while_break___25;
        }
        {
#line 602
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 602
          if (len < buffersize) {
#line 602
            *(buffer + len) = (char )*quote_string;
          }
#line 602
          len ++;
#line 602
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 601
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 604
  if (len < buffersize) {
#line 605
    *(buffer + len) = (char )'\000';
  }
#line 606
  return (len);
  force_outer_quoting_style: 
  {
#line 611
  tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 611
  return (tmp___7);
}
}
#line 626 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 631
  if (o) {
#line 631
    tmp = o;
  } else {
#line 631
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 631
  p = tmp;
#line 632
  tmp___0 = __errno_location();
#line 632
  e = *tmp___0;
#line 633
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 633
  r = tmp___1;
#line 636
  tmp___2 = __errno_location();
#line 636
  *tmp___2 = e;
  }
#line 637
  return (r);
}
}
#line 641 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 645
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 645
  return (tmp);
}
}
#line 654 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf___0 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 658
  if (o) {
#line 658
    tmp = o;
  } else {
#line 658
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 658
  p = tmp;
#line 659
  tmp___0 = __errno_location();
#line 659
  e = *tmp___0;
  }
#line 661
  if (size) {
#line 661
    tmp___1 = 0;
  } else {
#line 661
    tmp___1 = 1;
  }
  {
#line 661
  flags = (int )(p->flags | (int const   )tmp___1);
#line 662
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 662
  bufsize = tmp___2 + 1U;
#line 666
  tmp___3 = xcharalloc(bufsize);
#line 666
  buf___0 = tmp___3;
#line 667
  quotearg_buffer_restyled(buf___0, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 670
  tmp___4 = __errno_location();
#line 670
  *tmp___4 = e;
  }
#line 671
  if (size) {
#line 672
    *size = bufsize - 1U;
  }
#line 673
  return (buf___0);
}
}
#line 685 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
static char slot0[256]  ;
#line 686 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
static unsigned int nslots  =    1U;
#line 687 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
static struct slotvec slotvec0  =    {(size_t )sizeof(slot0), slot0};
#line 688 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 690 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 693
  sv = slotvec;
#line 695
  i = 1U;
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! (i < nslots)) {
#line 695
      goto while_break;
    }
    {
#line 696
    free((void *)(sv + i)->val);
#line 695
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 699
    free((void *)(sv + 0)->val);
#line 700
    slotvec0.size = (size_t )sizeof(slot0);
#line 701
    slotvec0.val = slot0;
    }
  }
#line 703
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 705
    free((void *)sv);
#line 706
    slotvec = & slotvec0;
    }
  }
#line 708
  nslots = 1U;
#line 709
  return;
}
}
#line 719 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 723
  tmp = __errno_location();
#line 723
  e = *tmp;
#line 725
  n0 = (unsigned int )n;
#line 726
  sv = slotvec;
  }
#line 728
  if (n < 0) {
    {
#line 729
    abort();
    }
  }
#line 731
  if (nslots <= n0) {
#line 738
    n1 = n0 + 1U;
#line 739
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 741
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 741
      tmp___0 = -1;
    } else {
#line 741
      tmp___0 = -2;
    }
#line 741
    if ((unsigned long )((size_t )tmp___0) / sizeof(*sv) < (unsigned long )n1) {
      {
#line 742
      xalloc_die();
      }
    }
#line 744
    if (preallocated) {
#line 744
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 744
      tmp___1 = sv;
    }
    {
#line 744
    tmp___2 = xrealloc((void *)tmp___1, (size_t )((unsigned long )n1 * sizeof(*sv)));
#line 744
    sv = (struct slotvec *)tmp___2;
#line 744
    slotvec = sv;
    }
#line 745
    if (preallocated) {
#line 746
      *sv = slotvec0;
    }
    {
#line 747
    memset((void *)(sv + nslots), 0, (size_t )((unsigned long )(n1 - nslots) * sizeof(*sv)));
#line 748
    nslots = n1;
    }
  }
  {
#line 752
  size = (sv + n)->size;
#line 753
  val = (sv + n)->val;
#line 755
  flags = (int )(options->flags | 1);
#line 756
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 756
  qsize = tmp___3;
  }
#line 762
  if (size <= qsize) {
#line 764
    size = qsize + 1U;
#line 764
    (sv + n)->size = size;
#line 765
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 766
      free((void *)val);
      }
    }
    {
#line 767
    val = xcharalloc(size);
#line 767
    (sv + n)->val = val;
#line 768
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 774
  tmp___4 = __errno_location();
#line 774
  *tmp___4 = e;
  }
#line 775
  return (val);
}
}
#line 779 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 782
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 782
  return (tmp);
}
}
#line 785 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 788
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 788
  return (tmp);
}
}
#line 791 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 794
  tmp = quotearg_n(0, arg);
  }
#line 794
  return (tmp);
}
}
#line 797 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 800
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 800
  return (tmp);
}
}
#line 803 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 806
  tmp = quoting_options_from_style(s);
#line 806
  o = tmp;
#line 807
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 807
  return (tmp___0);
}
}
#line 810 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 814
  tmp = quoting_options_from_style(s);
#line 814
  o = tmp;
#line 815
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 815
  return (tmp___0);
}
}
#line 818 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 821
  tmp = quotearg_n_style(0, s, arg);
  }
#line 821
  return (tmp);
}
}
#line 824 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 827
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 827
  return (tmp);
}
}
#line 830 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 834
  options = default_quoting_options;
#line 835
  set_char_quoting(& options, ch, 1);
#line 836
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 836
  return (tmp);
}
}
#line 839 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 842
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 842
  return (tmp);
}
}
#line 845 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 848
  tmp = quotearg_char(arg, (char )':');
  }
#line 848
  return (tmp);
}
}
#line 851 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 854
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 854
  return (tmp);
}
}
#line 857 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 861
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
  }
#line 861
  return (tmp);
}
}
#line 865 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 870
  o = default_quoting_options;
#line 871
  set_custom_quoting(& o, left_quote, right_quote);
#line 872
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 872
  return (tmp);
}
}
#line 875 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 879
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 879
  return (tmp);
}
}
#line 882 "/home/pronto/abs/test-suite/bison-2.5/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 886
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 886
  return (tmp);
}
}
#line 19 "/home/pronto/abs/test-suite/bison-2.5/lib/quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 20
char const   *quote(char const   *name ) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.5/lib/quote.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 31
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
  }
#line 31
  return ((char const   *)tmp);
}
}
#line 36 "/home/pronto/abs/test-suite/bison-2.5/lib/quote.c"
char const   *quote(char const   *name ) 
{ 
  char const   *tmp ;

  {
  {
#line 39
  tmp = quote_n(0, name);
  }
#line 39
  return (tmp);
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 1035 "./stdio.h"
int ( /* format attribute */ __attribute__((__nonnull__(1))) __printf__)(char const   *format 
                                                                         , ...)  __asm__("rpl_printf")  ;
#line 31 "/home/pronto/abs/test-suite/bison-2.5/lib/printf.c"
int ( /* format attribute */ __attribute__((__nonnull__(1))) __printf__)(char const   *format 
                                                                         , ...)  __asm__("rpl_printf")  ;
#line 31 "/home/pronto/abs/test-suite/bison-2.5/lib/printf.c"
int ( /* format attribute */ __attribute__((__nonnull__(1))) __printf__)(char const   *format 
                                                                         , ...) 
{ 
  int retval ;
  va_list args ;

  {
  {
#line 37
  __builtin_va_start(args, format);
#line 38
  retval = rpl_vfprintf(stdout, format, args);
#line 39
  __builtin_va_end(args);
  }
#line 41
  return (retval);
}
}
#line 85 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  char c ;
  char const   *tmp ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___2 ;
  size_t __attribute__((__pure__))  tmp___3 ;
  size_t tmp___4 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___10 ;
  size_t __attribute__((__pure__))  tmp___11 ;
  size_t tmp___12 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___18 ;
  size_t tmp___19 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;

  {
#line 88
  cp = format;
#line 89
  arg_posn = (size_t )0;
#line 92
  max_width_length = (size_t )0;
#line 93
  max_precision_length = (size_t )0;
#line 95
  d->count = (size_t )0;
#line 96
  d_allocated = (size_t )7;
#line 97
  d->dir = d->direct_alloc_dir;
#line 99
  a->count = (size_t )0;
#line 100
  a_allocated = (size_t )7;
#line 101
  a->arg = a->direct_alloc_arg;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! ((int const   )*cp != 0)) {
#line 137
      goto while_break;
    }
#line 139
    tmp = cp;
#line 139
    cp ++;
#line 139
    c = (char )*tmp;
#line 140
    if ((int )c == 37) {
#line 142
      arg_index = ~ ((size_t )0);
#line 143
      dp = d->dir + d->count;
#line 146
      dp->dir_start = cp - 1;
#line 147
      dp->flags = 0;
#line 148
      dp->width_start = (char const   *)((void *)0);
#line 149
      dp->width_end = (char const   *)((void *)0);
#line 150
      dp->width_arg_index = ~ ((size_t )0);
#line 151
      dp->precision_start = (char const   *)((void *)0);
#line 152
      dp->precision_end = (char const   *)((void *)0);
#line 153
      dp->precision_arg_index = ~ ((size_t )0);
#line 154
      dp->arg_index = ~ ((size_t )0);
#line 157
      if ((int const   )*cp >= 48) {
#line 157
        if ((int const   )*cp <= 57) {
#line 161
          np = cp;
          {
#line 161
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 161
            if ((int const   )*np >= 48) {
#line 161
              if (! ((int const   )*np <= 57)) {
#line 161
                goto while_break___0;
              }
            } else {
#line 161
              goto while_break___0;
            }
#line 161
            np ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 163
          if ((int const   )*np == 36) {
#line 165
            n = (size_t )0;
#line 167
            np = cp;
            {
#line 167
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 167
              if ((int const   )*np >= 48) {
#line 167
                if (! ((int const   )*np <= 57)) {
#line 167
                  goto while_break___1;
                }
              } else {
#line 167
                goto while_break___1;
              }
#line 168
              if (n <= 429496729U) {
#line 168
                tmp___0 = n * 10U;
              } else {
#line 168
                tmp___0 = 4294967295U;
              }
              {
#line 168
              tmp___1 = xsum(tmp___0, (size_t )((int const   )*np - 48));
#line 168
              n = (size_t )tmp___1;
#line 167
              np ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 169
            if (n == 0U) {
#line 171
              goto error;
            }
#line 172
            if (n == 4294967295U) {
#line 174
              goto error;
            }
#line 175
            arg_index = n - 1U;
#line 176
            cp = np + 1;
          }
        }
      }
      {
#line 181
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 183
        if ((int const   )*cp == 39) {
#line 185
          dp->flags |= 1;
#line 186
          cp ++;
        } else
#line 188
        if ((int const   )*cp == 45) {
#line 190
          dp->flags |= 2;
#line 191
          cp ++;
        } else
#line 193
        if ((int const   )*cp == 43) {
#line 195
          dp->flags |= 4;
#line 196
          cp ++;
        } else
#line 198
        if ((int const   )*cp == 32) {
#line 200
          dp->flags |= 8;
#line 201
          cp ++;
        } else
#line 203
        if ((int const   )*cp == 35) {
#line 205
          dp->flags |= 16;
#line 206
          cp ++;
        } else
#line 208
        if ((int const   )*cp == 48) {
#line 210
          dp->flags |= 32;
#line 211
          cp ++;
        } else
#line 214
        if ((int const   )*cp == 73) {
#line 216
          dp->flags |= 64;
#line 217
          cp ++;
        } else {
#line 221
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 225
      if ((int const   )*cp == 42) {
#line 227
        dp->width_start = cp;
#line 228
        cp ++;
#line 229
        dp->width_end = cp;
#line 230
        if (max_width_length < 1U) {
#line 231
          max_width_length = (size_t )1;
        }
#line 234
        if ((int const   )*cp >= 48) {
#line 234
          if ((int const   )*cp <= 57) {
#line 238
            np___0 = cp;
            {
#line 238
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 238
              if ((int const   )*np___0 >= 48) {
#line 238
                if (! ((int const   )*np___0 <= 57)) {
#line 238
                  goto while_break___3;
                }
              } else {
#line 238
                goto while_break___3;
              }
#line 238
              np___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 240
            if ((int const   )*np___0 == 36) {
#line 242
              n___0 = (size_t )0;
#line 244
              np___0 = cp;
              {
#line 244
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 244
                if ((int const   )*np___0 >= 48) {
#line 244
                  if (! ((int const   )*np___0 <= 57)) {
#line 244
                    goto while_break___4;
                  }
                } else {
#line 244
                  goto while_break___4;
                }
#line 245
                if (n___0 <= 429496729U) {
#line 245
                  tmp___2 = n___0 * 10U;
                } else {
#line 245
                  tmp___2 = 4294967295U;
                }
                {
#line 245
                tmp___3 = xsum(tmp___2, (size_t )((int const   )*np___0 - 48));
#line 245
                n___0 = (size_t )tmp___3;
#line 244
                np___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 246
              if (n___0 == 0U) {
#line 248
                goto error;
              }
#line 249
              if (n___0 == 4294967295U) {
#line 251
                goto error;
              }
#line 252
              dp->width_arg_index = n___0 - 1U;
#line 253
              cp = np___0 + 1;
            }
          }
        }
#line 256
        if (dp->width_arg_index == 4294967295U) {
#line 258
          tmp___4 = arg_posn;
#line 258
          arg_posn ++;
#line 258
          dp->width_arg_index = tmp___4;
#line 259
          if (dp->width_arg_index == 4294967295U) {
#line 261
            goto error;
          }
        }
#line 263
        n___1 = dp->width_arg_index;
#line 263
        if (n___1 >= a_allocated) {
#line 263
          if (a_allocated <= 2147483647U) {
#line 263
            a_allocated *= 2U;
          } else {
#line 263
            a_allocated = 4294967295U;
          }
#line 263
          if (a_allocated <= n___1) {
            {
#line 263
            tmp___5 = xsum(n___1, (size_t )1);
#line 263
            a_allocated = (size_t )tmp___5;
            }
          }
#line 263
          if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 263
            memory_size = (size_t )((unsigned long )a_allocated * sizeof(argument ));
          } else {
#line 263
            memory_size = 4294967295U;
          }
#line 263
          if (memory_size == 4294967295U) {
#line 263
            goto out_of_memory;
          }
#line 263
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
#line 263
            tmp___6 = realloc((void *)a->arg, memory_size);
#line 263
            tmp___8 = tmp___6;
            }
          } else {
            {
#line 263
            tmp___7 = malloc(memory_size);
#line 263
            tmp___8 = tmp___7;
            }
          }
#line 263
          memory = (argument *)tmp___8;
#line 263
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 263
            goto out_of_memory;
          }
#line 263
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
#line 263
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)a->arg,
                   (size_t )((unsigned long )a->count * sizeof(argument )));
            }
          }
#line 263
          a->arg = memory;
        }
        {
#line 263
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 263
          if (! (a->count <= n___1)) {
#line 263
            goto while_break___5;
          }
#line 263
          tmp___9 = a->count;
#line 263
          (a->count) ++;
#line 263
          (a->arg + tmp___9)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 263
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 263
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 263
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 263
          goto error;
        }
      } else
#line 265
      if ((int const   )*cp >= 48) {
#line 265
        if ((int const   )*cp <= 57) {
#line 269
          dp->width_start = cp;
          {
#line 270
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 270
            if ((int const   )*cp >= 48) {
#line 270
              if (! ((int const   )*cp <= 57)) {
#line 270
                goto while_break___6;
              }
            } else {
#line 270
              goto while_break___6;
            }
#line 270
            cp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 272
          dp->width_end = cp;
#line 273
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 274
          if (max_width_length < width_length) {
#line 275
            max_width_length = width_length;
          }
        }
      }
#line 279
      if ((int const   )*cp == 46) {
#line 281
        cp ++;
#line 282
        if ((int const   )*cp == 42) {
#line 284
          dp->precision_start = cp - 1;
#line 285
          cp ++;
#line 286
          dp->precision_end = cp;
#line 287
          if (max_precision_length < 2U) {
#line 288
            max_precision_length = (size_t )2;
          }
#line 291
          if ((int const   )*cp >= 48) {
#line 291
            if ((int const   )*cp <= 57) {
#line 295
              np___1 = cp;
              {
#line 295
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 295
                if ((int const   )*np___1 >= 48) {
#line 295
                  if (! ((int const   )*np___1 <= 57)) {
#line 295
                    goto while_break___7;
                  }
                } else {
#line 295
                  goto while_break___7;
                }
#line 295
                np___1 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 297
              if ((int const   )*np___1 == 36) {
#line 299
                n___2 = (size_t )0;
#line 301
                np___1 = cp;
                {
#line 301
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 301
                  if ((int const   )*np___1 >= 48) {
#line 301
                    if (! ((int const   )*np___1 <= 57)) {
#line 301
                      goto while_break___8;
                    }
                  } else {
#line 301
                    goto while_break___8;
                  }
#line 302
                  if (n___2 <= 429496729U) {
#line 302
                    tmp___10 = n___2 * 10U;
                  } else {
#line 302
                    tmp___10 = 4294967295U;
                  }
                  {
#line 302
                  tmp___11 = xsum(tmp___10, (size_t )((int const   )*np___1 - 48));
#line 302
                  n___2 = (size_t )tmp___11;
#line 301
                  np___1 ++;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 303
                if (n___2 == 0U) {
#line 305
                  goto error;
                }
#line 306
                if (n___2 == 4294967295U) {
#line 309
                  goto error;
                }
#line 310
                dp->precision_arg_index = n___2 - 1U;
#line 311
                cp = np___1 + 1;
              }
            }
          }
#line 314
          if (dp->precision_arg_index == 4294967295U) {
#line 316
            tmp___12 = arg_posn;
#line 316
            arg_posn ++;
#line 316
            dp->precision_arg_index = tmp___12;
#line 317
            if (dp->precision_arg_index == 4294967295U) {
#line 319
              goto error;
            }
          }
#line 321
          n___3 = dp->precision_arg_index;
#line 321
          if (n___3 >= a_allocated) {
#line 321
            if (a_allocated <= 2147483647U) {
#line 321
              a_allocated *= 2U;
            } else {
#line 321
              a_allocated = 4294967295U;
            }
#line 321
            if (a_allocated <= n___3) {
              {
#line 321
              tmp___13 = xsum(n___3, (size_t )1);
#line 321
              a_allocated = (size_t )tmp___13;
              }
            }
#line 321
            if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 321
              memory_size___0 = (size_t )((unsigned long )a_allocated * sizeof(argument ));
            } else {
#line 321
              memory_size___0 = 4294967295U;
            }
#line 321
            if (memory_size___0 == 4294967295U) {
#line 321
              goto out_of_memory;
            }
#line 321
            if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
              {
#line 321
              tmp___14 = realloc((void *)a->arg, memory_size___0);
#line 321
              tmp___16 = tmp___14;
              }
            } else {
              {
#line 321
              tmp___15 = malloc(memory_size___0);
#line 321
              tmp___16 = tmp___15;
              }
            }
#line 321
            memory___0 = (argument *)tmp___16;
#line 321
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 321
              goto out_of_memory;
            }
#line 321
            if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
              {
#line 321
              memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)a->arg,
                     (size_t )((unsigned long )a->count * sizeof(argument )));
              }
            }
#line 321
            a->arg = memory___0;
          }
          {
#line 321
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 321
            if (! (a->count <= n___3)) {
#line 321
              goto while_break___9;
            }
#line 321
            tmp___17 = a->count;
#line 321
            (a->count) ++;
#line 321
            (a->arg + tmp___17)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 321
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 321
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 321
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 321
            goto error;
          }
        } else {
#line 327
          dp->precision_start = cp - 1;
          {
#line 328
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 328
            if ((int const   )*cp >= 48) {
#line 328
              if (! ((int const   )*cp <= 57)) {
#line 328
                goto while_break___10;
              }
            } else {
#line 328
              goto while_break___10;
            }
#line 328
            cp ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 330
          dp->precision_end = cp;
#line 331
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 332
          if (max_precision_length < precision_length) {
#line 333
            max_precision_length = precision_length;
          }
        }
      }
#line 342
      flags = 0;
      {
#line 344
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 346
        if ((int const   )*cp == 104) {
#line 348
          flags |= 1 << (flags & 1);
#line 349
          cp ++;
        } else
#line 351
        if ((int const   )*cp == 76) {
#line 353
          flags |= 4;
#line 354
          cp ++;
        } else
#line 356
        if ((int const   )*cp == 108) {
#line 358
          flags += 8;
#line 359
          cp ++;
        } else
#line 361
        if ((int const   )*cp == 106) {
#line 363
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 366
            flags += 16;
          } else
#line 368
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 371
            flags += 8;
          }
#line 373
          cp ++;
        } else
#line 375
        if ((int const   )*cp == 122) {
#line 375
          goto _L;
        } else
#line 375
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 380
          if (sizeof(size_t ) > sizeof(long )) {
#line 383
            flags += 16;
          } else
#line 385
          if (sizeof(size_t ) > sizeof(int )) {
#line 388
            flags += 8;
          }
#line 390
          cp ++;
        } else
#line 392
        if ((int const   )*cp == 116) {
#line 394
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 397
            flags += 16;
          } else
#line 399
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 402
            flags += 8;
          }
#line 404
          cp ++;
        } else {
#line 445
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 449
      tmp___18 = cp;
#line 449
      cp ++;
#line 449
      c = (char )*tmp___18;
      {
#line 452
      if ((int )c == 105) {
#line 452
        goto case_105;
      }
#line 452
      if ((int )c == 100) {
#line 452
        goto case_105;
      }
#line 470
      if ((int )c == 88) {
#line 470
        goto case_88;
      }
#line 470
      if ((int )c == 120) {
#line 470
        goto case_88;
      }
#line 470
      if ((int )c == 117) {
#line 470
        goto case_88;
      }
#line 470
      if ((int )c == 111) {
#line 470
        goto case_88;
      }
#line 489
      if ((int )c == 65) {
#line 489
        goto case_65;
      }
#line 489
      if ((int )c == 97) {
#line 489
        goto case_65;
      }
#line 489
      if ((int )c == 71) {
#line 489
        goto case_65;
      }
#line 489
      if ((int )c == 103) {
#line 489
        goto case_65;
      }
#line 489
      if ((int )c == 69) {
#line 489
        goto case_65;
      }
#line 489
      if ((int )c == 101) {
#line 489
        goto case_65;
      }
#line 489
      if ((int )c == 70) {
#line 489
        goto case_65;
      }
#line 489
      if ((int )c == 102) {
#line 489
        goto case_65;
      }
#line 495
      if ((int )c == 99) {
#line 495
        goto case_99;
      }
#line 506
      if ((int )c == 67) {
#line 506
        goto case_67;
      }
#line 511
      if ((int )c == 115) {
#line 511
        goto case_115;
      }
#line 522
      if ((int )c == 83) {
#line 522
        goto case_83;
      }
#line 527
      if ((int )c == 112) {
#line 527
        goto case_112;
      }
#line 530
      if ((int )c == 110) {
#line 530
        goto case_110;
      }
#line 559
      if ((int )c == 37) {
#line 559
        goto case_37;
      }
#line 562
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 455
      if (flags >= 16) {
#line 456
        type = (arg_type )9;
      } else
#line 455
      if (flags & 4) {
#line 456
        type = (arg_type )9;
      } else
#line 461
      if (flags >= 8) {
#line 462
        type = (arg_type )7;
      } else
#line 463
      if (flags & 2) {
#line 464
        type = (arg_type )1;
      } else
#line 465
      if (flags & 1) {
#line 466
        type = (arg_type )3;
      } else {
#line 468
        type = (arg_type )5;
      }
#line 469
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 473
      if (flags >= 16) {
#line 474
        type = (arg_type )10;
      } else
#line 473
      if (flags & 4) {
#line 474
        type = (arg_type )10;
      } else
#line 479
      if (flags >= 8) {
#line 480
        type = (arg_type )8;
      } else
#line 481
      if (flags & 2) {
#line 482
        type = (arg_type )2;
      } else
#line 483
      if (flags & 1) {
#line 484
        type = (arg_type )4;
      } else {
#line 486
        type = (arg_type )6;
      }
#line 487
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 490
      if (flags >= 16) {
#line 491
        type = (arg_type )12;
      } else
#line 490
      if (flags & 4) {
#line 491
        type = (arg_type )12;
      } else {
#line 493
        type = (arg_type )11;
      }
#line 494
      goto switch_break;
      case_99: /* CIL Label */ 
#line 496
      if (flags >= 8) {
#line 498
        type = (arg_type )14;
      } else {
#line 503
        type = (arg_type )13;
      }
#line 504
      goto switch_break;
      case_67: /* CIL Label */ 
#line 507
      type = (arg_type )14;
#line 508
      c = (char )'c';
#line 509
      goto switch_break;
      case_115: /* CIL Label */ 
#line 512
      if (flags >= 8) {
#line 514
        type = (arg_type )16;
      } else {
#line 519
        type = (arg_type )15;
      }
#line 520
      goto switch_break;
      case_83: /* CIL Label */ 
#line 523
      type = (arg_type )16;
#line 524
      c = (char )'s';
#line 525
      goto switch_break;
      case_112: /* CIL Label */ 
#line 528
      type = (arg_type )17;
#line 529
      goto switch_break;
      case_110: /* CIL Label */ 
#line 533
      if (flags >= 16) {
#line 534
        type = (arg_type )22;
      } else
#line 533
      if (flags & 4) {
#line 534
        type = (arg_type )22;
      } else
#line 539
      if (flags >= 8) {
#line 540
        type = (arg_type )21;
      } else
#line 541
      if (flags & 2) {
#line 542
        type = (arg_type )18;
      } else
#line 543
      if (flags & 1) {
#line 544
        type = (arg_type )19;
      } else {
#line 546
        type = (arg_type )20;
      }
#line 547
      goto switch_break;
      case_37: /* CIL Label */ 
#line 560
      type = (arg_type )0;
#line 561
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 564
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 568
      if ((unsigned int )type != 0U) {
#line 570
        dp->arg_index = arg_index;
#line 571
        if (dp->arg_index == 4294967295U) {
#line 573
          tmp___19 = arg_posn;
#line 573
          arg_posn ++;
#line 573
          dp->arg_index = tmp___19;
#line 574
          if (dp->arg_index == 4294967295U) {
#line 576
            goto error;
          }
        }
#line 578
        n___4 = dp->arg_index;
#line 578
        if (n___4 >= a_allocated) {
#line 578
          if (a_allocated <= 2147483647U) {
#line 578
            a_allocated *= 2U;
          } else {
#line 578
            a_allocated = 4294967295U;
          }
#line 578
          if (a_allocated <= n___4) {
            {
#line 578
            tmp___20 = xsum(n___4, (size_t )1);
#line 578
            a_allocated = (size_t )tmp___20;
            }
          }
#line 578
          if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 578
            memory_size___1 = (size_t )((unsigned long )a_allocated * sizeof(argument ));
          } else {
#line 578
            memory_size___1 = 4294967295U;
          }
#line 578
          if (memory_size___1 == 4294967295U) {
#line 578
            goto out_of_memory;
          }
#line 578
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
#line 578
            tmp___21 = realloc((void *)a->arg, memory_size___1);
#line 578
            tmp___23 = tmp___21;
            }
          } else {
            {
#line 578
            tmp___22 = malloc(memory_size___1);
#line 578
            tmp___23 = tmp___22;
            }
          }
#line 578
          memory___1 = (argument *)tmp___23;
#line 578
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 578
            goto out_of_memory;
          }
#line 578
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
#line 578
            memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)a->arg,
                   (size_t )((unsigned long )a->count * sizeof(argument )));
            }
          }
#line 578
          a->arg = memory___1;
        }
        {
#line 578
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 578
          if (! (a->count <= n___4)) {
#line 578
            goto while_break___12;
          }
#line 578
          tmp___24 = a->count;
#line 578
          (a->count) ++;
#line 578
          (a->arg + tmp___24)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 578
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 578
          (a->arg + n___4)->type = type;
        } else
#line 578
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 578
          goto error;
        }
      }
#line 580
      dp->conversion = c;
#line 581
      dp->dir_end = cp;
#line 584
      (d->count) ++;
#line 585
      if (d->count >= d_allocated) {
#line 590
        if (d_allocated <= 2147483647U) {
#line 590
          d_allocated *= 2U;
        } else {
#line 590
          d_allocated = 4294967295U;
        }
#line 591
        if ((unsigned long )d_allocated <= 4294967295UL / sizeof(char_directive )) {
#line 591
          memory_size___2 = (size_t )((unsigned long )d_allocated * sizeof(char_directive ));
        } else {
#line 591
          memory_size___2 = 4294967295U;
        }
#line 592
        if (memory_size___2 == 4294967295U) {
#line 594
          goto out_of_memory;
        }
#line 595
        if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
          {
#line 595
          tmp___25 = realloc((void *)d->dir, memory_size___2);
#line 595
          tmp___27 = tmp___25;
          }
        } else {
          {
#line 595
          tmp___26 = malloc(memory_size___2);
#line 595
          tmp___27 = tmp___26;
          }
        }
#line 595
        memory___2 = (char_directive *)tmp___27;
#line 598
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 600
          goto out_of_memory;
        }
#line 601
        if ((unsigned long )d->dir == (unsigned long )(d->direct_alloc_dir)) {
          {
#line 602
          memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)d->dir,
                 (size_t )((unsigned long )d->count * sizeof(char_directive )));
          }
        }
#line 603
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  (d->dir + d->count)->dir_start = cp;
#line 616
  d->max_width_length = max_width_length;
#line 617
  d->max_precision_length = max_precision_length;
#line 618
  return (0);
  error: 
#line 621
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
#line 622
    free((void *)a->arg);
    }
  }
#line 623
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
#line 624
    free((void *)d->dir);
    }
  }
  {
#line 625
  tmp___28 = __errno_location();
#line 625
  *tmp___28 = 22;
  }
#line 626
  return (-1);
  out_of_memory: 
#line 629
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
#line 630
    free((void *)a->arg);
    }
  }
#line 631
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
#line 632
    free((void *)d->dir);
    }
  }
  {
#line 633
  tmp___29 = __errno_location();
#line 633
  *tmp___29 = 12;
  }
#line 634
  return (-1);
}
}
#line 23 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-frexpl.h"
long double printf_frexpl(long double x , int *expptr ) ;
#line 104 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 64 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-frexp.c"
long double printf_frexpl(long double x , int *expptr ) 
{ 
  int exponent ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  fpucw_t _ncw___0 ;

  {
  {
#line 70
  __asm__  volatile   ("fnstcw %0": "=m" (_cw));
#line 70
  oldcw = _cw;
#line 70
  _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
#line 70
  __asm__  volatile   ("fldcw %0": : "m" (_ncw));
#line 74
  x = frexpl(x, & exponent);
#line 76
  x += x;
#line 77
  exponent --;
  }
#line 79
  if (exponent < -16382) {
    {
#line 81
    x = ldexpl(x, exponent - -16382);
#line 82
    exponent = -16382;
    }
  }
#line 184
  _ncw___0 = oldcw;
#line 184
  __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
#line 23 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-frexp.h"
double printf_frexp(double x , int *expptr ) ;
#line 104 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 64 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-frexp.c"
double printf_frexp(double x , int *expptr ) 
{ 
  int exponent ;

  {
  {
#line 74
  x = frexp(x, & exponent);
#line 76
  x += x;
#line 77
  exponent --;
  }
#line 79
  if (exponent < -1022) {
    {
#line 81
    x = ldexp(x, exponent - -1022);
#line 82
    exponent = -1022;
    }
  }
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 115 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 38 "/home/pronto/abs/test-suite/bison-2.5/lib/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;
  char *__cil_tmp30 ;

  {
#line 44
  i = (size_t )0;
#line 44
  ap = a->arg + 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < a->count)) {
#line 44
      goto while_break;
    }
    {
#line 47
    if ((unsigned int )ap->type == 1U) {
#line 47
      goto case_1;
    }
#line 50
    if ((unsigned int )ap->type == 2U) {
#line 50
      goto case_2;
    }
#line 53
    if ((unsigned int )ap->type == 3U) {
#line 53
      goto case_3;
    }
#line 56
    if ((unsigned int )ap->type == 4U) {
#line 56
      goto case_4;
    }
#line 59
    if ((unsigned int )ap->type == 5U) {
#line 59
      goto case_5;
    }
#line 62
    if ((unsigned int )ap->type == 6U) {
#line 62
      goto case_6;
    }
#line 65
    if ((unsigned int )ap->type == 7U) {
#line 65
      goto case_7;
    }
#line 68
    if ((unsigned int )ap->type == 8U) {
#line 68
      goto case_8;
    }
#line 72
    if ((unsigned int )ap->type == 9U) {
#line 72
      goto case_9;
    }
#line 75
    if ((unsigned int )ap->type == 10U) {
#line 75
      goto case_10;
    }
#line 79
    if ((unsigned int )ap->type == 11U) {
#line 79
      goto case_11;
    }
#line 82
    if ((unsigned int )ap->type == 12U) {
#line 82
      goto case_12;
    }
#line 85
    if ((unsigned int )ap->type == 13U) {
#line 85
      goto case_13;
    }
#line 89
    if ((unsigned int )ap->type == 14U) {
#line 89
      goto case_14;
    }
#line 99
    if ((unsigned int )ap->type == 15U) {
#line 99
      goto case_15;
    }
#line 108
    if ((unsigned int )ap->type == 16U) {
#line 108
      goto case_16;
    }
#line 126
    if ((unsigned int )ap->type == 17U) {
#line 126
      goto case_17;
    }
#line 129
    if ((unsigned int )ap->type == 18U) {
#line 129
      goto case_18;
    }
#line 132
    if ((unsigned int )ap->type == 19U) {
#line 132
      goto case_19;
    }
#line 135
    if ((unsigned int )ap->type == 20U) {
#line 135
      goto case_20;
    }
#line 138
    if ((unsigned int )ap->type == 21U) {
#line 138
      goto case_21;
    }
#line 142
    if ((unsigned int )ap->type == 22U) {
#line 142
      goto case_22;
    }
#line 185
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 48
    tmp = __builtin_va_arg(args, int );
#line 48
    ap->a.a_schar = tmp;
    }
#line 49
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 51
    tmp___0 = __builtin_va_arg(args, int );
#line 51
    ap->a.a_uchar = tmp___0;
    }
#line 52
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 54
    tmp___1 = __builtin_va_arg(args, int );
#line 54
    ap->a.a_short = tmp___1;
    }
#line 55
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 57
    tmp___2 = __builtin_va_arg(args, int );
#line 57
    ap->a.a_ushort = tmp___2;
    }
#line 58
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 60
    tmp___3 = __builtin_va_arg(args, int );
#line 60
    ap->a.a_int = tmp___3;
    }
#line 61
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 63
    tmp___4 = __builtin_va_arg(args, unsigned int );
#line 63
    ap->a.a_uint = tmp___4;
    }
#line 64
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 66
    tmp___5 = __builtin_va_arg(args, long );
#line 66
    ap->a.a_longint = tmp___5;
    }
#line 67
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 69
    tmp___6 = __builtin_va_arg(args, unsigned long );
#line 69
    ap->a.a_ulongint = tmp___6;
    }
#line 70
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 73
    tmp___7 = __builtin_va_arg(args, long long );
#line 73
    ap->a.a_longlongint = tmp___7;
    }
#line 74
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 76
    tmp___8 = __builtin_va_arg(args, unsigned long long );
#line 76
    ap->a.a_ulonglongint = tmp___8;
    }
#line 77
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 80
    tmp___9 = __builtin_va_arg(args, double );
#line 80
    ap->a.a_double = tmp___9;
    }
#line 81
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 83
    tmp___10 = __builtin_va_arg(args, long double );
#line 83
    ap->a.a_longdouble = tmp___10;
    }
#line 84
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 86
    tmp___11 = __builtin_va_arg(args, int );
#line 86
    ap->a.a_char = tmp___11;
    }
#line 87
    goto switch_break;
    case_14: /* CIL Label */ 
#line 93
    if (sizeof(wint_t ) < sizeof(int )) {
      {
#line 93
      tmp___13 = __builtin_va_arg(args, int );
#line 93
      ap->a.a_wide_char = (wint_t )tmp___13;
      }
    } else {
      {
#line 93
      tmp___15 = __builtin_va_arg(args, wint_t );
#line 93
      ap->a.a_wide_char = tmp___15;
      }
    }
#line 97
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 100
    tmp___16 = __builtin_va_arg(args, char const   *);
#line 100
    ap->a.a_string = tmp___16;
    }
#line 104
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 105
      ap->a.a_string = "(NULL)";
    }
#line 106
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 109
    tmp___17 = __builtin_va_arg(args, wchar_t const   *);
#line 109
    ap->a.a_wide_string = tmp___17;
    }
#line 113
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 122
      ap->a.a_wide_string = wide_null_string;
    }
#line 124
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 127
    tmp___18 = __builtin_va_arg(args, void *);
#line 127
    ap->a.a_pointer = tmp___18;
    }
#line 128
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 130
    tmp___19 = __builtin_va_arg(args, signed char *);
#line 130
    ap->a.a_count_schar_pointer = tmp___19;
    }
#line 131
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 133
    tmp___20 = __builtin_va_arg(args, short *);
#line 133
    ap->a.a_count_short_pointer = tmp___20;
    }
#line 134
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 136
    tmp___21 = __builtin_va_arg(args, int *);
#line 136
    ap->a.a_count_int_pointer = tmp___21;
    }
#line 137
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 139
    tmp___22 = __builtin_va_arg(args, long *);
#line 139
    ap->a.a_count_longint_pointer = tmp___22;
    }
#line 140
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 143
    tmp___23 = __builtin_va_arg(args, long long *);
#line 143
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
#line 144
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 187
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 44
    i ++;
#line 44
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (0);
}
}
#line 414 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 419
extern  __attribute__((__nothrow__)) int pipe2(int *__pipedes , int __flags ) ;
#line 1339 "./unistd.h"
int ( __attribute__((__nonnull__(1))) rpl_pipe2)(int *fd , int flags ) ;
#line 393 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 47 "/home/pronto/abs/test-suite/bison-2.5/lib/pipe2.c"
static int have_pipe2_really  ;
#line 38 "/home/pronto/abs/test-suite/bison-2.5/lib/pipe2.c"
int ( __attribute__((__nonnull__(1))) rpl_pipe2)(int *fd , int flags ) 
{ 
  int result ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int fcntl_flags ;
  int tmp___3 ;
  int tmp___4 ;
  int fcntl_flags___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int saved_errno ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 48
  if (have_pipe2_really >= 0) {
    {
#line 50
    tmp = pipe2(fd, flags);
#line 50
    result = tmp;
    }
#line 51
    if (result < 0) {
      {
#line 51
      tmp___0 = __errno_location();
      }
#line 51
      if (! (*tmp___0 == 38)) {
#line 53
        have_pipe2_really = 1;
#line 54
        return (result);
      }
    } else {
#line 53
      have_pipe2_really = 1;
#line 54
      return (result);
    }
#line 56
    have_pipe2_really = -1;
  }
#line 62
  if ((flags & -526337) != 0) {
    {
#line 64
    tmp___1 = __errno_location();
#line 64
    *tmp___1 = 22;
    }
#line 65
    return (-1);
  }
  {
#line 92
  tmp___2 = pipe(fd);
  }
#line 92
  if (tmp___2 < 0) {
#line 93
    return (-1);
  }
#line 99
  if (flags & 2048) {
    {
#line 103
    fcntl_flags = rpl_fcntl(*(fd + 1), 3, 0);
    }
#line 103
    if (fcntl_flags < 0) {
#line 107
      goto fail;
    } else {
      {
#line 103
      tmp___3 = rpl_fcntl(*(fd + 1), 4, fcntl_flags | 2048);
      }
#line 103
      if (tmp___3 == -1) {
#line 107
        goto fail;
      } else {
        {
#line 103
        fcntl_flags = rpl_fcntl(*(fd + 0), 3, 0);
        }
#line 103
        if (fcntl_flags < 0) {
#line 107
          goto fail;
        } else {
          {
#line 103
          tmp___4 = rpl_fcntl(*(fd + 0), 4, fcntl_flags | 2048);
          }
#line 103
          if (tmp___4 == -1) {
#line 107
            goto fail;
          }
        }
      }
    }
  }
#line 110
  if (flags & 524288) {
    {
#line 114
    fcntl_flags___0 = rpl_fcntl(*(fd + 1), 1, 0);
    }
#line 114
    if (fcntl_flags___0 < 0) {
#line 118
      goto fail;
    } else {
      {
#line 114
      tmp___5 = rpl_fcntl(*(fd + 1), 2, fcntl_flags___0 | 1);
      }
#line 114
      if (tmp___5 == -1) {
#line 118
        goto fail;
      } else {
        {
#line 114
        fcntl_flags___0 = rpl_fcntl(*(fd + 0), 1, 0);
        }
#line 114
        if (fcntl_flags___0 < 0) {
#line 118
          goto fail;
        } else {
          {
#line 114
          tmp___6 = rpl_fcntl(*(fd + 0), 2, fcntl_flags___0 | 1);
          }
#line 114
          if (tmp___6 == -1) {
#line 118
            goto fail;
          }
        }
      }
    }
  }
#line 134
  return (0);
  fail: 
  {
#line 138
  tmp___7 = __errno_location();
#line 138
  saved_errno = *tmp___7;
#line 139
  close(*(fd + 0));
#line 140
  close(*(fd + 1));
#line 141
  tmp___8 = __errno_location();
#line 141
  *tmp___8 = saved_errno;
  }
#line 142
  return (-1);
}
}
#line 26 "/home/pronto/abs/test-suite/bison-2.5/lib/unistd-safer.h"
int fd_safer_flag(int fd , int flag ) ;
#line 30
int pipe2_safer(int *fd , int flags ) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/lib/pipe2-safer.c"
int pipe2_safer(int *fd , int flags ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = rpl_pipe2(fd, flags);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer_flag(*(fd + i), flags);
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 51
  return (-1);
}
}
#line 21 "/home/pronto/abs/test-suite/bison-2.5/lib/unistd-safer.h"
int fd_safer(int fd ) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/lib/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = pipe(fd);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
#line 48 "/home/pronto/abs/test-suite/bison-2.5/lib/nonblocking.h"
int get_nonblocking_flag(int desc ) ;
#line 55
int set_nonblocking_flag(int desc , _Bool value ) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 123 "/home/pronto/abs/test-suite/bison-2.5/lib/nonblocking.c"
int get_nonblocking_flag(int desc ) 
{ 
  int fcntl_flags ;

  {
  {
#line 128
  fcntl_flags = fcntl(desc, 3, 0);
  }
#line 129
  if (fcntl_flags < 0) {
#line 130
    return (-1);
  }
#line 131
  return ((fcntl_flags & 2048) != 0);
}
}
#line 134 "/home/pronto/abs/test-suite/bison-2.5/lib/nonblocking.c"
int set_nonblocking_flag(int desc , _Bool value ) 
{ 
  int fcntl_flags ;
  int tmp ;

  {
  {
#line 139
  fcntl_flags = fcntl(desc, 3, 0);
  }
#line 140
  if (fcntl_flags < 0) {
#line 141
    return (-1);
  }
#line 142
  if (((fcntl_flags & 2048) != 0) == (int )value) {
#line 143
    return (0);
  }
#line 144
  if (value) {
#line 145
    fcntl_flags |= 2048;
  } else {
#line 147
    fcntl_flags &= -2049;
  }
  {
#line 148
  tmp = fcntl(desc, 4, fcntl_flags);
  }
#line 148
  return (tmp);
}
}
#line 51 "/home/pronto/abs/test-suite/bison-2.5/lib/mbswidth.h"
int gnu_mbswidth(char const   *string , int flags ) ;
#line 55
int mbsnwidth(char const   *string , size_t nbytes , int flags ) ;
#line 437 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int wcwidth(wchar_t __c ) ;
#line 121 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswcntrl(wint_t __wc ) ;
#line 46 "/home/pronto/abs/test-suite/bison-2.5/lib/mbswidth.c"
int gnu_mbswidth(char const   *string , int flags ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 49
  tmp = strlen(string);
#line 49
  tmp___0 = mbsnwidth(string, tmp, flags);
  }
#line 49
  return (tmp___0);
}
}
#line 56 "/home/pronto/abs/test-suite/bison-2.5/lib/mbswidth.c"
int mbsnwidth(char const   *string , size_t nbytes , int flags ) 
{ 
  char const   *p ;
  char const   *plimit ;
  int width___0 ;
  mbstate_t mbstate ;
  wchar_t wc ;
  size_t bytes ;
  int w ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned char c ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 59
  p = string;
#line 60
  plimit = p + nbytes;
#line 63
  width___0 = 0;
#line 64
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 64
  if (tmp___1 > 1U) {
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
#line 66
      if (! ((unsigned long )p < (unsigned long )plimit)) {
#line 66
        goto while_break;
      }
      {
#line 88
      if ((int const   )*p == 126) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 125) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 124) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 123) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 122) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 121) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 120) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 119) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 118) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 117) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 116) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 115) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 114) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 113) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 112) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 111) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 110) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 109) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 108) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 107) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 106) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 105) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 104) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 103) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 102) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 101) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 100) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 99) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 98) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 97) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 95) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 94) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 93) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 92) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 91) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 90) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 89) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 88) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 87) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 86) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 85) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 84) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 83) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 82) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 81) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 80) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 79) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 78) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 77) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 76) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 75) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 74) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 73) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 72) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 71) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 70) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 69) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 68) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 67) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 66) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 65) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 63) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 62) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 61) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 60) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 59) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 58) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 57) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 56) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 55) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 54) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 53) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 52) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 51) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 50) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 49) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 48) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 47) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 46) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 45) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 44) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 43) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 42) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 41) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 40) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 39) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 38) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 37) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 35) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 34) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 33) {
#line 88
        goto case_126;
      }
#line 88
      if ((int const   )*p == 32) {
#line 88
        goto case_126;
      }
#line 93
      goto switch_default;
      case_126: /* CIL Label */ 
      case_125: /* CIL Label */ 
      case_124: /* CIL Label */ 
      case_123: /* CIL Label */ 
      case_122: /* CIL Label */ 
      case_121: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_119: /* CIL Label */ 
      case_118: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_116: /* CIL Label */ 
      case_115: /* CIL Label */ 
      case_114: /* CIL Label */ 
      case_113: /* CIL Label */ 
      case_112: /* CIL Label */ 
      case_111: /* CIL Label */ 
      case_110: /* CIL Label */ 
      case_109: /* CIL Label */ 
      case_108: /* CIL Label */ 
      case_107: /* CIL Label */ 
      case_106: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_104: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_102: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_99: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_95: /* CIL Label */ 
      case_94: /* CIL Label */ 
      case_93: /* CIL Label */ 
      case_92: /* CIL Label */ 
      case_91: /* CIL Label */ 
      case_90: /* CIL Label */ 
      case_89: /* CIL Label */ 
      case_88: /* CIL Label */ 
      case_87: /* CIL Label */ 
      case_86: /* CIL Label */ 
      case_85: /* CIL Label */ 
      case_84: /* CIL Label */ 
      case_83: /* CIL Label */ 
      case_82: /* CIL Label */ 
      case_81: /* CIL Label */ 
      case_80: /* CIL Label */ 
      case_79: /* CIL Label */ 
      case_78: /* CIL Label */ 
      case_77: /* CIL Label */ 
      case_76: /* CIL Label */ 
      case_75: /* CIL Label */ 
      case_74: /* CIL Label */ 
      case_73: /* CIL Label */ 
      case_72: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_68: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_65: /* CIL Label */ 
      case_63: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_61: /* CIL Label */ 
      case_60: /* CIL Label */ 
      case_59: /* CIL Label */ 
      case_58: /* CIL Label */ 
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
      case_47: /* CIL Label */ 
      case_46: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_44: /* CIL Label */ 
      case_43: /* CIL Label */ 
      case_42: /* CIL Label */ 
      case_41: /* CIL Label */ 
      case_40: /* CIL Label */ 
      case_39: /* CIL Label */ 
      case_38: /* CIL Label */ 
      case_37: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_34: /* CIL Label */ 
      case_33: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 90
      p ++;
#line 91
      width___0 ++;
#line 92
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 97
      memset((void *)(& mbstate), 0, (size_t )sizeof(mbstate));
      }
      {
#line 98
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 104
        bytes = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)p,
                        (size_t )(plimit - p), & mbstate);
        }
#line 106
        if (bytes == 4294967295U) {
#line 109
          if (! (flags & 1)) {
#line 111
            p ++;
#line 112
            width___0 ++;
#line 113
            goto while_break___0;
          } else {
#line 116
            return (-1);
          }
        }
#line 119
        if (bytes == 4294967294U) {
#line 122
          if (! (flags & 1)) {
#line 124
            p = plimit;
#line 125
            width___0 ++;
#line 126
            goto while_break___0;
          } else {
#line 129
            return (-1);
          }
        }
#line 132
        if (bytes == 0U) {
#line 134
          bytes = (size_t )1;
        }
        {
#line 136
        w = wcwidth(wc);
        }
#line 137
        if (w >= 0) {
#line 140
          if (w > 2147483647 - width___0) {
#line 141
            goto overflow;
          }
#line 142
          width___0 += w;
        } else
#line 146
        if (! (flags & 2)) {
          {
#line 148
          tmp = iswcntrl((wint_t )wc);
          }
#line 148
          if (! tmp) {
#line 150
            if (width___0 == 2147483647) {
#line 151
              goto overflow;
            }
#line 152
            width___0 ++;
          }
        } else {
#line 156
          return (-1);
        }
        {
#line 158
        p += bytes;
#line 98
        tmp___0 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 98
        if (tmp___0) {
#line 98
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 162
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 164
    return (width___0);
  }
  {
#line 167
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 167
    if (! ((unsigned long )p < (unsigned long )plimit)) {
#line 167
      goto while_break___1;
    }
    {
#line 169
    tmp___2 = p;
#line 169
    p ++;
#line 169
    c = (unsigned char )*tmp___2;
#line 171
    tmp___4 = __ctype_b_loc();
    }
#line 171
    if ((int const   )*(*tmp___4 + (int )c) & 16384) {
#line 173
      if (width___0 == 2147483647) {
#line 174
        goto overflow;
      }
#line 175
      width___0 ++;
    } else
#line 177
    if (! (flags & 2)) {
      {
#line 179
      tmp___3 = __ctype_b_loc();
      }
#line 179
      if (! ((int const   )*(*tmp___3 + (int )c) & 2)) {
#line 181
        if (width___0 == 2147483647) {
#line 182
          goto overflow;
        }
#line 183
        width___0 ++;
      }
    } else {
#line 187
      return (-1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 189
  return (width___0);
  overflow: 
#line 192
  return (2147483647);
}
}
#line 260 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 1050 "./string.h"
char *( __attribute__((__nonnull__(1))) mbsrchr)(char const   *string , int c ) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 305 "/home/pronto/abs/test-suite/bison-2.5/lib/mbchar.h"
unsigned int const   is_basic_table[8] ;
#line 307 "/home/pronto/abs/test-suite/bison-2.5/lib/mbchar.h"
__inline static _Bool is_basic(char c ) 
{ 


  {
#line 310
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 123 "/home/pronto/abs/test-suite/bison-2.5/lib/mbuiter.h"
__inline static void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
  {
#line 131
  tmp___3 = is_basic((char )*(iter->cur.ptr));
  }
#line 131
  if (tmp___3) {
#line 136
    iter->cur.bytes = (size_t )1;
#line 137
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 142
    tmp = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 142
    if (! tmp) {
      {
#line 142
      __assert_fail("mbsinit (&iter->state)", "/home/pronto/abs/test-suite/bison-2.5/lib/mbuiter.h",
                    142U, "mbuiter_multi_next");
      }
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 145
    tmp___0 = __ctype_get_mb_cur_max();
#line 145
    tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
#line 145
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              tmp___1, & iter->state);
    }
#line 148
    if (iter->cur.bytes == 4294967295U) {
#line 151
      iter->cur.bytes = (size_t )1;
#line 152
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 156
    if (iter->cur.bytes == 4294967294U) {
      {
#line 159
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 160
      iter->cur.wc_valid = (_Bool)0;
      }
    } else {
#line 166
      if (iter->cur.bytes == 0U) {
#line 169
        iter->cur.bytes = (size_t )1;
#line 170
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 170
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/pronto/abs/test-suite/bison-2.5/lib/mbuiter.h",
                        170U, "mbuiter_multi_next");
          }
        }
#line 171
        if (! (iter->cur.wc == 0)) {
          {
#line 171
          __assert_fail("iter->cur.wc == 0", "/home/pronto/abs/test-suite/bison-2.5/lib/mbuiter.h",
                        171U, "mbuiter_multi_next");
          }
        }
      }
      {
#line 173
      iter->cur.wc_valid = (_Bool)1;
#line 177
      tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 177
      if (tmp___2) {
#line 178
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 181
  iter->next_done = (_Bool)1;
#line 182
  return;
}
}
#line 27 "/home/pronto/abs/test-suite/bison-2.5/lib/mbsrchr.c"
char *( __attribute__((__nonnull__(1))) mbsrchr)(char const   *string , int c ) 
{ 
  char const   *result ;
  mbui_iterator_t iter ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 30
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 30
  if (tmp___1 > 1U) {
#line 30
    if ((int )((unsigned char )c) >= 48) {
      {
#line 36
      result = (char const   *)((void *)0);
#line 39
      iter.cur.ptr = string;
#line 39
      iter.in_shift = (_Bool)0;
#line 39
      memset((void *)(& iter.state), '\000', (size_t )sizeof(mbstate_t ));
#line 39
      iter.next_done = (_Bool)0;
      }
      {
#line 39
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 39
        mbuiter_multi_next(& iter);
        }
#line 39
        if (iter.cur.wc_valid) {
#line 39
          if (iter.cur.wc == 0) {
#line 39
            tmp = 0;
          } else {
#line 39
            tmp = 1;
          }
        } else {
#line 39
          tmp = 1;
        }
#line 39
        if (! tmp) {
#line 39
          goto while_break;
        }
#line 41
        if (iter.cur.bytes == 1U) {
#line 41
          if ((int )((unsigned char )*(iter.cur.ptr)) == (int )((unsigned char )c)) {
#line 43
            result = iter.cur.ptr;
          }
        }
#line 39
        iter.cur.ptr += iter.cur.bytes;
#line 39
        iter.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
#line 45
      return ((char *)result);
    } else {
      {
#line 48
      tmp___0 = strrchr(string, c);
      }
#line 48
      return (tmp___0);
    }
  } else {
    {
#line 48
    tmp___0 = strrchr(string, c);
    }
#line 48
    return (tmp___0);
  }
}
}
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 1030 "./string.h"
char *( __attribute__((__nonnull__(1))) mbschr)(char const   *string , int c ) ;
#line 27 "/home/pronto/abs/test-suite/bison-2.5/lib/mbschr.c"
char *( __attribute__((__nonnull__(1))) mbschr)(char const   *string , int c ) 
{ 
  mbui_iterator_t iter ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 30
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 30
  if (tmp___1 > 1U) {
#line 30
    if ((int )((unsigned char )c) >= 48) {
      {
#line 38
      iter.cur.ptr = string;
#line 38
      iter.in_shift = (_Bool)0;
#line 38
      memset((void *)(& iter.state), '\000', (size_t )sizeof(mbstate_t ));
#line 38
      iter.next_done = (_Bool)0;
      }
      {
#line 38
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 40
        mbuiter_multi_next(& iter);
        }
#line 40
        if (iter.cur.wc_valid) {
#line 40
          if (iter.cur.wc == 0) {
#line 40
            tmp = 0;
          } else {
#line 40
            tmp = 1;
          }
        } else {
#line 40
          tmp = 1;
        }
#line 40
        if (! tmp) {
#line 41
          goto notfound;
        }
#line 42
        if (iter.cur.bytes == 1U) {
#line 42
          if ((int )((unsigned char )*(iter.cur.ptr)) == (int )((unsigned char )c)) {
#line 44
            goto while_break;
          }
        }
#line 38
        iter.cur.ptr += iter.cur.bytes;
#line 38
        iter.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
#line 46
      return ((char *)iter.cur.ptr);
      notfound: 
#line 48
      return ((char *)((void *)0));
    } else {
      {
#line 51
      tmp___0 = strchr(string, c);
      }
#line 51
      return (tmp___0);
    }
  } else {
    {
#line 51
    tmp___0 = strchr(string, c);
    }
#line 51
    return (tmp___0);
  }
}
}
#line 26 "/home/pronto/abs/test-suite/bison-2.5/lib/mbchar.c"
unsigned int const   is_basic_table[8]  = {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646};
#line 35 "/home/pronto/abs/test-suite/bison-2.5/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 532
extern int getc_unlocked(FILE *__stream ) ;
#line 675
extern int ungetc(int __c , FILE *__stream ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 582 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 117 "/home/pronto/abs/test-suite/bison-2.5/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 120 "/home/pronto/abs/test-suite/bison-2.5/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base___0 ;
  char *file_name ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 125
  cp = (char const   *)charset_aliases;
#line 126
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 130
    base___0 = "charset.alias";
#line 135
    tmp = getenv("CHARSETALIASDIR");
#line 135
    dir = (char const   *)tmp;
    }
#line 136
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 137
      dir = "/usr/local/lib";
    } else
#line 136
    if ((int const   )*(dir + 0) == 0) {
#line 137
      dir = "/usr/local/lib";
    }
    {
#line 141
    tmp___0 = strlen(dir);
#line 141
    dir_len___0 = tmp___0;
#line 142
    tmp___1 = strlen(base___0);
#line 142
    base_len___0 = tmp___1;
    }
#line 143
    if (dir_len___0 > 0U) {
#line 143
      if (! ((int const   )*(dir + (dir_len___0 - 1U)) == 47)) {
#line 143
        tmp___2 = 1;
      } else {
#line 143
        tmp___2 = 0;
      }
    } else {
#line 143
      tmp___2 = 0;
    }
    {
#line 143
    add_slash = tmp___2;
#line 144
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1U);
#line 144
    file_name = (char *)tmp___3;
    }
#line 145
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 147
      memcpy((void */* __restrict  */)file_name, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 148
      if (add_slash) {
#line 149
        *(file_name + dir_len___0) = (char )'/';
      }
      {
#line 150
      memcpy((void */* __restrict  */)((file_name + dir_len___0) + add_slash), (void const   */* __restrict  */)base___0,
             base_len___0 + 1U);
      }
    }
#line 154
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 156
      cp = "";
    } else {
      {
#line 168
      fd = open((char const   *)file_name, 131072);
      }
#line 170
      if (fd < 0) {
#line 172
        cp = "";
      } else {
        {
#line 177
        fp = fdopen(fd, "r");
        }
#line 178
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 181
          close(fd);
#line 182
          cp = "";
          }
        } else {
#line 187
          res_ptr = (char *)((void *)0);
#line 188
          res_size = (size_t )0;
          {
#line 190
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 198
            c = getc_unlocked(fp);
            }
#line 199
            if (c == -1) {
#line 200
              goto while_break;
            }
#line 201
            if (c == 10) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 32) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 9) {
#line 202
              goto __Cont;
            }
#line 203
            if (c == 35) {
              {
#line 206
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 207
                c = getc_unlocked(fp);
                }
#line 206
                if (c == -1) {
#line 206
                  goto while_break___0;
                } else
#line 206
                if (c == 10) {
#line 206
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 209
              if (c == -1) {
#line 210
                goto while_break;
              }
#line 211
              goto __Cont;
            }
            {
#line 213
            ungetc(c, fp);
#line 214
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 214
            if (tmp___4 < 2) {
#line 215
              goto while_break;
            }
            {
#line 216
            l1 = strlen((char const   *)(buf1));
#line 217
            l2 = strlen((char const   *)(buf2));
#line 218
            old_res_ptr = res_ptr;
            }
#line 219
            if (res_size == 0U) {
              {
#line 221
              res_size = ((l1 + 1U) + l2) + 1U;
#line 222
              tmp___5 = malloc(res_size + 1U);
#line 222
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 226
              res_size += ((l1 + 1U) + l2) + 1U;
#line 227
              tmp___6 = realloc((void *)res_ptr, res_size + 1U);
#line 227
              res_ptr = (char *)tmp___6;
              }
            }
#line 229
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 232
              res_size = (size_t )0;
#line 233
              free((void *)old_res_ptr);
              }
#line 234
              goto while_break;
            }
            {
#line 236
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1U)) - (l1 + 1U)),
                   (char const   */* __restrict  */)(buf1));
#line 237
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1U)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 239
          fclose(fp);
          }
#line 240
          if (res_size == 0U) {
#line 241
            cp = "";
          } else {
#line 244
            *(res_ptr + res_size) = (char )'\000';
#line 245
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 250
      free((void *)file_name);
      }
    }
#line 344
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 347
  return (cp);
}
}
#line 359 "/home/pronto/abs/test-suite/bison-2.5/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 370
  tmp = nl_langinfo(14);
#line 370
  codeset = (char const   *)tmp;
  }
#line 527
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 529
    codeset = "";
  }
  {
#line 532
  aliases = get_charset_aliases();
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((int const   )*aliases != 0)) {
#line 532
      goto while_break;
    }
    {
#line 535
    tmp___3 = strcmp(codeset, aliases);
    }
#line 535
    if (tmp___3 == 0) {
      {
#line 538
      tmp___2 = strlen(aliases);
#line 538
      codeset = (aliases + tmp___2) + 1;
      }
#line 539
      goto while_break;
    } else
#line 535
    if ((int const   )*(aliases + 0) == 42) {
#line 535
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 538
        tmp___2 = strlen(aliases);
#line 538
        codeset = (aliases + tmp___2) + 1;
        }
#line 539
        goto while_break;
      }
    }
    {
#line 532
    tmp___0 = strlen(aliases);
#line 532
    aliases += tmp___0 + 1U;
#line 532
    tmp___1 = strlen(aliases);
#line 532
    aliases += tmp___1 + 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  if ((int const   )*(codeset + 0) == 0) {
#line 546
    codeset = "ASCII";
  }
#line 548
  return (codeset);
}
}
#line 180 "/home/pronto/abs/test-suite/bison-2.5/lib/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 181
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 193
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.h"
size_t lbitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) ;
#line 27
bitset lbitset_init(bitset bset , bitset_bindex n_bits  __attribute__((__unused__)) ) ;
#line 29
void lbitset_release_memory(void) ;
#line 74 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static lbitset_elt lbitset_zero_elts[3]  ;
#line 77 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static struct obstack lbitset_obstack  ;
#line 78 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_obstack_init  =    (_Bool)0;
#line 79 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static lbitset_elt *lbitset_free_list  ;
#line 81
void debug_lbitset(bitset bset ) ;
#line 92 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static lbitset_elt *lbitset_elt_alloc(void) 
{ 
  lbitset_elt *elt ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 97
  if ((unsigned long )lbitset_free_list != (unsigned long )((lbitset_elt *)0)) {
#line 99
    elt = lbitset_free_list;
#line 100
    lbitset_free_list = elt->next;
  } else {
#line 104
    if (! lbitset_obstack_init) {
      {
#line 106
      lbitset_obstack_init = (_Bool)1;
#line 128
      _obstack_begin(& lbitset_obstack, 0, (int )__alignof__(lbitset_elt ), (void *(*)(long  ))(& xmalloc),
                     & free);
      }
    }
#line 136
    __h = & lbitset_obstack;
#line 136
    __o = __h;
#line 136
    __len = (int )sizeof(lbitset_elt );
#line 136
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
#line 136
      _obstack_newchunk(__o, __len);
      }
    }
#line 136
    __o->next_free += __len;
#line 136
    __o1 = __h;
#line 136
    __value = (void *)__o1->object_base;
#line 136
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 136
      __o1->maybe_empty_object = 1U;
    }
#line 136
    if (sizeof(int ) < sizeof(void *)) {
#line 136
      tmp = __o1->object_base;
    } else {
#line 136
      tmp = (char *)0;
    }
#line 136
    if (sizeof(int ) < sizeof(void *)) {
#line 136
      tmp___0 = __o1->object_base;
    } else {
#line 136
      tmp___0 = (char *)0;
    }
#line 136
    __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 136
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 136
      __o1->next_free = __o1->chunk_limit;
    }
#line 136
    __o1->object_base = __o1->next_free;
#line 136
    elt = (lbitset_elt *)__value;
  }
#line 140
  return (elt);
}
}
#line 145 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static lbitset_elt *lbitset_elt_calloc(void) 
{ 
  lbitset_elt *elt ;

  {
  {
#line 150
  elt = lbitset_elt_alloc();
#line 151
  memset((void *)(elt->words), 0, (size_t )sizeof(elt->words));
  }
#line 152
  return (elt);
}
}
#line 156 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static void lbitset_elt_free(lbitset_elt *elt ) 
{ 


  {
#line 159
  elt->next = lbitset_free_list;
#line 160
  lbitset_free_list = elt;
#line 161
  return;
}
}
#line 165 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static void lbitset_elt_unlink(bitset bset , lbitset_elt *elt ) 
{ 
  lbitset_elt *next ;
  lbitset_elt *prev ;

  {
#line 168
  next = elt->next;
#line 169
  prev = elt->prev;
#line 171
  if (prev) {
#line 172
    prev->next = next;
  }
#line 174
  if (next) {
#line 175
    next->prev = prev;
  }
#line 177
  if ((unsigned long )bset->l.head == (unsigned long )elt) {
#line 178
    bset->l.head = next;
  }
#line 179
  if ((unsigned long )bset->l.tail == (unsigned long )elt) {
#line 180
    bset->l.tail = prev;
  }
#line 185
  if ((unsigned long )((lbitset_elt *)((void *)((char *)bset->b.cdata - (unsigned long )(& ((lbitset_elt *)0)->words)))) == (unsigned long )elt) {
#line 187
    if (next) {
#line 189
      bset->b.cdata = next->words;
#line 190
      bset->b.cindex = next->index;
    } else
#line 192
    if (prev) {
#line 194
      bset->b.cdata = prev->words;
#line 195
      bset->b.cindex = prev->index;
    } else {
#line 199
      bset->b.csize = (bitset_windex )0;
#line 200
      bset->b.cdata = (bitset_word *)0;
    }
  }
  {
#line 204
  lbitset_elt_free(elt);
  }
#line 205
  return;
}
}
#line 210 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static void lbitset_prune(bitset bset , lbitset_elt *elt ) 
{ 
  lbitset_elt *next ;

  {
#line 215
  if (! elt) {
#line 216
    return;
  }
#line 218
  if (elt->prev) {
#line 220
    bset->l.tail = elt->prev;
#line 221
    bset->b.cdata = (elt->prev)->words;
#line 222
    bset->b.cindex = (elt->prev)->index;
#line 223
    (elt->prev)->next = (struct lbitset_elt_struct *)0;
  } else {
#line 227
    bset->l.head = (struct lbitset_elt_struct *)0;
#line 228
    bset->l.tail = (struct lbitset_elt_struct *)0;
#line 229
    bset->b.cdata = (bitset_word *)0;
#line 230
    bset->b.csize = (bitset_windex )0;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! elt) {
#line 233
      goto while_break;
    }
    {
#line 235
    next = elt->next;
#line 236
    lbitset_elt_free(elt);
#line 233
    elt = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return;
}
}
#line 242 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static _Bool lbitset_elt_zero_p(lbitset_elt *elt ) 
{ 
  int i ;

  {
#line 247
  i = 0;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (i < 2)) {
#line 247
      goto while_break;
    }
#line 248
    if (elt->words[i]) {
#line 249
      return ((_Bool)0);
    }
#line 247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  return ((_Bool)1);
}
}
#line 256 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static void lbitset_elt_link(bitset bset , lbitset_elt *elt ) 
{ 
  bitset_windex windex ;
  lbitset_elt *ptr ;
  lbitset_elt *current ;
  struct lbitset_elt_struct *tmp ;

  {
#line 259
  windex = elt->index;
#line 263
  if (bset->b.csize) {
#line 264
    current = (lbitset_elt *)((void *)((char *)bset->b.cdata - (unsigned long )(& ((lbitset_elt *)0)->words)));
  } else {
#line 266
    current = bset->l.head;
  }
#line 269
  if ((unsigned long )bset->l.head == (unsigned long )((struct lbitset_elt_struct *)0)) {
#line 271
    tmp = (struct lbitset_elt_struct *)0;
#line 271
    elt->prev = tmp;
#line 271
    elt->next = tmp;
#line 272
    bset->l.head = elt;
#line 273
    bset->l.tail = elt;
  } else
#line 278
  if (windex < bset->b.cindex) {
#line 280
    ptr = current;
    {
#line 280
    while (1) {
      while_continue: /* CIL Label */ ;
#line 280
      if (ptr->prev) {
#line 280
        if (! ((ptr->prev)->index > windex)) {
#line 280
          goto while_break;
        }
      } else {
#line 280
        goto while_break;
      }
#line 282
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 280
      ptr = ptr->prev;
    }
    while_break: /* CIL Label */ ;
    }
#line 284
    if (ptr->prev) {
#line 285
      (ptr->prev)->next = elt;
    } else {
#line 287
      bset->l.head = elt;
    }
#line 289
    elt->prev = ptr->prev;
#line 290
    elt->next = ptr;
#line 291
    ptr->prev = elt;
  } else {
#line 297
    ptr = current;
    {
#line 297
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 297
      if (ptr->next) {
#line 297
        if (! ((ptr->next)->index < windex)) {
#line 297
          goto while_break___0;
        }
      } else {
#line 297
        goto while_break___0;
      }
#line 299
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 297
      ptr = ptr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 301
    if (ptr->next) {
#line 302
      (ptr->next)->prev = elt;
    } else {
#line 304
      bset->l.tail = elt;
    }
#line 306
    elt->next = ptr->next;
#line 307
    elt->prev = ptr;
#line 308
    ptr->next = elt;
  }
#line 312
  bset->b.cindex = windex;
#line 313
  bset->b.csize = (bitset_windex )2;
#line 314
  bset->b.cdata = elt->words;
#line 315
  return;
}
}
#line 318 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static lbitset_elt *lbitset_elt_find(bitset bset , bitset_windex windex , enum lbitset_find_mode mode ) 
{ 
  lbitset_elt *elt ;
  lbitset_elt *current ;

  {
#line 325
  if (bset->b.csize) {
#line 327
    current = (lbitset_elt *)((void *)((char *)bset->b.cdata - (unsigned long )(& ((lbitset_elt *)0)->words)));
#line 329
    if (windex - bset->b.cindex < bset->b.csize) {
#line 330
      return (current);
    }
  } else {
#line 334
    current = bset->l.head;
  }
#line 337
  if (current) {
#line 339
    if (windex < bset->b.cindex) {
#line 341
      elt = current;
      {
#line 341
      while (1) {
        while_continue: /* CIL Label */ ;
#line 341
        if (elt->prev) {
#line 341
          if (! (elt->index > windex)) {
#line 341
            goto while_break;
          }
        } else {
#line 341
          goto while_break;
        }
#line 343
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 341
        elt = elt->prev;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 347
      elt = current;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (elt->next) {
#line 347
          if (! ((elt->index + 2U) - 1U < windex)) {
#line 347
            goto while_break___0;
          }
        } else {
#line 347
          goto while_break___0;
        }
#line 350
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 347
        elt = elt->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 355
    if (elt) {
#line 355
      if (windex - elt->index < 2U) {
#line 357
        bset->b.cindex = elt->index;
#line 358
        bset->b.csize = (bitset_windex )2;
#line 359
        bset->b.cdata = elt->words;
#line 360
        return (elt);
      }
    }
  }
  {
#line 369
  if ((unsigned int )mode == 0U) {
#line 369
    goto case_0;
  }
#line 372
  if ((unsigned int )mode == 1U) {
#line 372
    goto case_1;
  }
#line 380
  if ((unsigned int )mode == 2U) {
#line 380
    goto case_2;
  }
#line 366
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 367
  abort();
  }
  case_0: /* CIL Label */ 
#line 370
  return ((lbitset_elt *)0);
  case_1: /* CIL Label */ 
  {
#line 373
  windex -= windex % 2U;
#line 375
  elt = lbitset_elt_calloc();
#line 376
  elt->index = windex;
#line 377
  lbitset_elt_link(bset, elt);
  }
#line 378
  return (elt);
  case_2: /* CIL Label */ 
#line 381
  return (& lbitset_zero_elts[0]);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 387 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static void lbitset_weed(bitset bset ) 
{ 
  lbitset_elt *elt ;
  lbitset_elt *next ;
  _Bool tmp ;

  {
#line 393
  elt = bset->l.head;
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! elt) {
#line 393
      goto while_break;
    }
    {
#line 395
    next = elt->next;
#line 396
    tmp = lbitset_elt_zero_p(elt);
    }
#line 396
    if (tmp) {
      {
#line 397
      lbitset_elt_unlink(bset, elt);
      }
    }
#line 393
    elt = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  return;
}
}
#line 403 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_zero(bitset bset ) 
{ 
  lbitset_elt *head ;

  {
#line 408
  head = bset->l.head;
#line 409
  if (! head) {
#line 410
    return;
  }
  {
#line 413
  lbitset_prune(bset, head);
  }
#line 414
  return;
}
}
#line 418 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static _Bool lbitset_equal_p(bitset dst , bitset src ) 
{ 
  lbitset_elt *selt ;
  lbitset_elt *delt ;
  int j ;
  int tmp ;

  {
#line 425
  if ((unsigned long )src == (unsigned long )dst) {
#line 426
    return ((_Bool)1);
  }
  {
#line 428
  lbitset_weed(src);
#line 429
  lbitset_weed(dst);
#line 430
  selt = src->l.head;
#line 430
  delt = dst->l.head;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (selt) {
#line 430
      if (! delt) {
#line 430
        goto while_break;
      }
    } else {
#line 430
      goto while_break;
    }
#line 433
    if (selt->index != delt->index) {
#line 434
      return ((_Bool)0);
    }
#line 436
    j = 0;
    {
#line 436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 436
      if (! (j < 2)) {
#line 436
        goto while_break___0;
      }
#line 437
      if (delt->words[j] != selt->words[j]) {
#line 438
        return ((_Bool)0);
      }
#line 436
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 430
    selt = selt->next;
#line 430
    delt = delt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 440
  if (! selt) {
#line 440
    if (! delt) {
#line 440
      tmp = 1;
    } else {
#line 440
      tmp = 0;
    }
  } else {
#line 440
    tmp = 0;
  }
#line 440
  return ((_Bool )tmp);
}
}
#line 445 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static void lbitset_copy(bitset dst , bitset src ) 
{ 
  lbitset_elt *elt ;
  lbitset_elt *head ;
  lbitset_elt *prev ;
  lbitset_elt *tmp ;

  {
#line 453
  if ((unsigned long )src == (unsigned long )dst) {
#line 454
    return;
  }
  {
#line 456
  lbitset_zero(dst);
#line 458
  head = src->l.head;
  }
#line 459
  if (! head) {
#line 460
    return;
  }
#line 462
  prev = (lbitset_elt *)0;
#line 463
  elt = head;
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    if (! elt) {
#line 463
      goto while_break;
    }
    {
#line 465
    tmp = lbitset_elt_alloc();
#line 466
    tmp->index = elt->index;
#line 467
    tmp->prev = prev;
#line 468
    tmp->next = (struct lbitset_elt_struct *)0;
    }
#line 469
    if (prev) {
#line 470
      prev->next = tmp;
    } else {
#line 472
      dst->l.head = tmp;
    }
    {
#line 473
    prev = tmp;
#line 475
    memcpy((void */* __restrict  */)(tmp->words), (void const   */* __restrict  */)(elt->words),
           (size_t )sizeof(elt->words));
#line 463
    elt = elt->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  dst->l.tail = tmp;
#line 479
  dst->b.csize = (bitset_windex )2;
#line 480
  dst->b.cdata = (dst->l.head)->words;
#line 481
  dst->b.cindex = (dst->l.head)->index;
#line 482
  return;
}
}
#line 487 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static _Bool lbitset_copy_cmp(bitset dst , bitset src ) 
{ 
  _Bool tmp ;

  {
#line 490
  if ((unsigned long )src == (unsigned long )dst) {
#line 491
    return ((_Bool)0);
  }
#line 493
  if (! dst->l.head) {
    {
#line 495
    lbitset_copy(dst, src);
    }
#line 496
    return ((_Bool )((unsigned long )src->l.head != (unsigned long )((struct lbitset_elt_struct *)0)));
  }
  {
#line 499
  tmp = lbitset_equal_p(dst, src);
  }
#line 499
  if (tmp) {
#line 500
    return ((_Bool)0);
  }
  {
#line 502
  lbitset_copy(dst, src);
  }
#line 503
  return ((_Bool)1);
}
}
#line 507 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static bitset_bindex lbitset_resize(bitset src , bitset_bindex size ) 
{ 


  {
#line 510
  src->b.n_bits = size;
#line 513
  return (size);
}
}
#line 517 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_set(bitset dst , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;

  {
  {
#line 520
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 522
  lbitset_elt_find(dst, windex, (enum lbitset_find_mode )1);
#line 524
  *(dst->b.cdata + (windex - dst->b.cindex)) |= 1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word ));
  }
#line 526
  return;
}
}
#line 530 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_reset(bitset dst , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  lbitset_elt *tmp ;

  {
  {
#line 533
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 535
  tmp = lbitset_elt_find(dst, windex, (enum lbitset_find_mode )0);
  }
#line 535
  if (! tmp) {
#line 536
    return;
  }
#line 538
  *(dst->b.cdata + (windex - dst->b.cindex)) &= ~ (1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word )));
#line 542
  return;
}
}
#line 546 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_test(bitset src , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  lbitset_elt *tmp ;
  int tmp___0 ;

  {
  {
#line 549
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 551
  tmp = lbitset_elt_find(src, windex, (enum lbitset_find_mode )0);
  }
#line 551
  if (tmp) {
#line 551
    if ((*(src->b.cdata + (windex - src->b.cindex)) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ))) & 1UL) {
#line 551
      tmp___0 = 1;
    } else {
#line 551
      tmp___0 = 0;
    }
  } else {
#line 551
    tmp___0 = 0;
  }
#line 551
  return ((_Bool )tmp___0);
}
}
#line 558 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_free(bitset bset ) 
{ 


  {
  {
#line 561
  lbitset_zero(bset);
  }
#line 562
  return;
}
}
#line 568 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static bitset_bindex lbitset_list_reverse(bitset bset , bitset_bindex *list , bitset_bindex num ,
                                          bitset_bindex *next ) 
{ 
  bitset_bindex rbitno ;
  bitset_bindex bitno ;
  unsigned int bcount ;
  bitset_bindex boffset ;
  bitset_windex windex ;
  bitset_bindex count ;
  lbitset_elt *elt ;
  bitset_word word ;
  bitset_bindex n_bits ;
  bitset_word *srcp ;
  bitset_bindex tmp ;

  {
#line 582
  elt = bset->l.tail;
#line 583
  if (! elt) {
#line 584
    return ((bitset_bindex )0);
  }
#line 586
  n_bits = (elt->index + 2U) * (unsigned int )(8UL * sizeof(bitset_word ));
#line 587
  rbitno = *next;
#line 589
  if (rbitno >= n_bits) {
#line 590
    return ((bitset_bindex )0);
  }
#line 592
  bitno = n_bits - (rbitno + 1U);
#line 594
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 597
    if (elt) {
#line 597
      if (! (elt->index > windex)) {
#line 597
        goto while_break;
      }
    } else {
#line 597
      goto while_break;
    }
#line 598
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 597
    elt = elt->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 600
  if (! elt) {
#line 601
    return ((bitset_bindex )0);
  }
#line 603
  if (windex >= elt->index + 2U) {
#line 607
    bcount = (unsigned int )(8UL * sizeof(bitset_word )) - 1U;
#line 608
    windex = (elt->index + 2U) - 1U;
  } else {
#line 612
    bcount = bitno % (unsigned int )(8UL * sizeof(bitset_word ));
  }
#line 615
  count = (bitset_bindex )0;
#line 616
  boffset = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  {
#line 621
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 621
    if (! elt) {
#line 621
      goto while_break___0;
    }
#line 623
    srcp = elt->words;
    {
#line 625
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 625
      if (! (windex - elt->index < 2U)) {
#line 625
        goto while_break___1;
      }
#line 629
      word = *(srcp + (windex - elt->index)) << (((unsigned int )(8UL * sizeof(bitset_word )) - 1U) - bcount);
      {
#line 632
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 632
        if (! word) {
#line 632
          goto while_break___2;
        }
#line 634
        if (word & (1UL << ((unsigned int )(8UL * sizeof(bitset_word )) - 1U))) {
#line 636
          tmp = count;
#line 636
          count ++;
#line 636
          *(list + tmp) = boffset + bcount;
#line 637
          if (count >= num) {
#line 639
            *next = n_bits - (boffset + bcount);
#line 640
            return (count);
          }
        }
#line 643
        word <<= 1;
#line 632
        bcount --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 625
      windex --;
#line 625
      boffset -= (unsigned int )(8UL * sizeof(bitset_word ));
#line 625
      bcount = (unsigned int )(8UL * sizeof(bitset_word )) - 1U;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 647
    elt = elt->prev;
#line 648
    if (elt) {
#line 650
      windex = (elt->index + 2U) - 1U;
#line 651
      boffset = windex * (unsigned int )(8UL * sizeof(bitset_word ));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 655
  *next = n_bits - (boffset + 1U);
#line 656
  return (count);
}
}
#line 663 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static bitset_bindex lbitset_list(bitset bset , bitset_bindex *list , bitset_bindex num ,
                                  bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_windex windex ;
  bitset_bindex count ;
  lbitset_elt *elt ;
  lbitset_elt *head ;
  bitset_word word ;
  bitset_word *srcp ;
  bitset_bindex tmp ;
  int i ;
  bitset_word *srcp___0 ;
  bitset_bindex tmp___0 ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;

  {
#line 674
  head = bset->l.head;
#line 675
  if (! head) {
#line 676
    return ((bitset_bindex )0);
  }
#line 678
  bitno = *next;
#line 679
  count = (bitset_bindex )0;
#line 681
  if (! bitno) {
#line 686
    elt = head;
#line 687
    windex = elt->index;
#line 688
    bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  } else {
#line 692
    windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 695
    elt = head;
    {
#line 695
    while (1) {
      while_continue: /* CIL Label */ ;
#line 695
      if (elt) {
#line 695
        if (! ((elt->index + 2U) - 1U < windex)) {
#line 695
          goto while_break;
        }
      } else {
#line 695
        goto while_break;
      }
#line 698
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 695
      elt = elt->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 700
    if (! elt) {
#line 701
      return ((bitset_bindex )0);
    }
#line 703
    if (windex < elt->index) {
#line 705
      windex = elt->index;
#line 706
      bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
    } else {
#line 710
      srcp = elt->words;
      {
#line 714
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 714
        if (! (windex - elt->index < 2U)) {
#line 714
          goto while_break___0;
        }
#line 716
        word = *(srcp + (windex - elt->index)) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ));
        {
#line 718
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 718
          if (! word) {
#line 718
            goto while_break___1;
          }
#line 720
          if (word & 1UL) {
#line 722
            tmp = count;
#line 722
            count ++;
#line 722
            *(list + tmp) = bitno;
#line 723
            if (count >= num) {
#line 725
              *next = bitno + 1U;
#line 726
              return (count);
            }
          }
#line 729
          word >>= 1;
#line 718
          bitno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 731
        bitno = (windex + 1U) * (unsigned int )(8UL * sizeof(bitset_word ));
#line 714
        windex ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 734
      elt = elt->next;
#line 735
      if (elt) {
#line 737
        windex = elt->index;
#line 738
        bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
      }
    }
  }
  {
#line 747
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 747
    if (! elt) {
#line 747
      goto while_break___2;
    }
#line 750
    srcp___0 = elt->words;
#line 752
    if (count + 2U * (unsigned int )(8UL * sizeof(bitset_word )) < num) {
#line 757
      word = *(srcp___0 + 0);
#line 758
      if (word) {
#line 760
        if (! (word & 65535UL)) {
#line 762
          word >>= 16;
#line 763
          bitno += 16U;
        }
#line 765
        if (! (word & 255UL)) {
#line 767
          word >>= 8;
#line 768
          bitno += 8U;
        }
        {
#line 770
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 770
          if (! word) {
#line 770
            goto while_break___3;
          }
#line 772
          if (word & 1UL) {
#line 773
            tmp___0 = count;
#line 773
            count ++;
#line 773
            *(list + tmp___0) = bitno;
          }
#line 774
          word >>= 1;
#line 770
          bitno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 777
      windex ++;
#line 778
      bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
#line 780
      word = *(srcp___0 + 1);
#line 781
      if (word) {
#line 783
        if (! (word & 65535UL)) {
#line 785
          word >>= 16;
#line 786
          bitno += 16U;
        }
        {
#line 788
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 788
          if (! word) {
#line 788
            goto while_break___4;
          }
#line 790
          if (word & 1UL) {
#line 791
            tmp___1 = count;
#line 791
            count ++;
#line 791
            *(list + tmp___1) = bitno;
          }
#line 792
          word >>= 1;
#line 788
          bitno ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 795
      windex ++;
#line 796
      bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
    } else {
#line 830
      i = 0;
      {
#line 830
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 830
        if (! (i < 2)) {
#line 830
          goto while_break___5;
        }
#line 832
        word = *(srcp___0 + i);
        {
#line 832
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 832
          if (! word) {
#line 832
            goto while_break___6;
          }
#line 834
          if (word & 1UL) {
#line 836
            tmp___2 = count;
#line 836
            count ++;
#line 836
            *(list + tmp___2) = bitno;
#line 837
            if (count >= num) {
#line 839
              *next = bitno + 1U;
#line 840
              return (count);
            }
          }
#line 843
          word >>= 1;
#line 832
          bitno ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 845
        windex ++;
#line 846
        bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
#line 830
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 850
    elt = elt->next;
#line 851
    if (elt) {
#line 853
      windex = elt->index;
#line 854
      bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 858
  *next = bitno;
#line 859
  return (count);
}
}
#line 863 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_empty_p(bitset dst ) 
{ 
  lbitset_elt *elt ;
  lbitset_elt *next ;
  _Bool tmp ;

  {
#line 869
  elt = dst->l.head;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! elt) {
#line 869
      goto while_break;
    }
    {
#line 871
    next = elt->next;
#line 872
    tmp = lbitset_elt_zero_p(elt);
    }
#line 872
    if (! tmp) {
#line 873
      return ((_Bool)0);
    }
    {
#line 875
    lbitset_elt_unlink(dst, elt);
#line 869
    elt = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  return ((_Bool)1);
}
}
#line 883 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
__inline static void lbitset_unused_clear(bitset dst ) 
{ 
  unsigned int last_bit ;
  bitset_bindex n_bits ;
  lbitset_elt *elt ;
  bitset_windex windex ;
  bitset_word *srcp ;

  {
  {
#line 889
  n_bits = (*((dst->b.vtable)->size))(dst);
#line 890
  last_bit = n_bits % (2U * (unsigned int )(8UL * sizeof(bitset_word )));
  }
#line 892
  if (last_bit) {
#line 898
    elt = dst->l.tail;
#line 899
    srcp = elt->words;
#line 900
    windex = n_bits / (unsigned int )(8UL * sizeof(bitset_word ));
#line 902
    *(srcp + (windex - elt->index)) &= (1UL << last_bit) - 1UL;
#line 903
    windex ++;
    {
#line 905
    while (1) {
      while_continue: /* CIL Label */ ;
#line 905
      if (! (windex - elt->index < 2U)) {
#line 905
        goto while_break;
      }
#line 906
      *(srcp + (windex - elt->index)) = (bitset_word )0;
#line 905
      windex ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 908
  return;
}
}
#line 911 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_ones(bitset dst ) 
{ 
  bitset_windex i ;
  bitset_windex windex ;
  lbitset_elt *elt ;
  bitset_bindex tmp ;

  {
  {
#line 923
  tmp = (*((dst->b.vtable)->size))(dst);
#line 923
  windex = ((tmp + (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (unsigned int )(8UL * sizeof(bitset_word ));
#line 925
  i = (bitset_windex )0;
  }
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 925
    if (! (i < windex)) {
#line 925
      goto while_break;
    }
    {
#line 928
    elt = lbitset_elt_find(dst, i, (enum lbitset_find_mode )1);
#line 929
    memset((void *)(elt->words), -1, (size_t )sizeof(elt->words));
#line 925
    i += 2U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 932
  lbitset_unused_clear(dst);
  }
#line 933
  return;
}
}
#line 936 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_not(bitset dst , bitset src ) 
{ 
  lbitset_elt *elt ;
  lbitset_elt *selt ;
  lbitset_elt *delt ;
  bitset_windex i ;
  unsigned int j ;
  bitset_windex windex ;
  bitset_bindex tmp ;

  {
  {
#line 948
  elt = dst->l.tail;
#line 950
  tmp = (*((dst->b.vtable)->size))(dst);
#line 950
  windex = ((tmp + (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (unsigned int )(8UL * sizeof(bitset_word ));
#line 952
  i = (bitset_windex )0;
  }
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 952
    if (! (i < windex)) {
#line 952
      goto while_break;
    }
    {
#line 956
    selt = lbitset_elt_find(src, i, (enum lbitset_find_mode )2);
#line 957
    delt = lbitset_elt_find(dst, i, (enum lbitset_find_mode )1);
#line 959
    j = 0U;
    }
    {
#line 959
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 959
      if (! (j < 2U)) {
#line 959
        goto while_break___0;
      }
#line 960
      delt->words[j] = ~ selt->words[j];
#line 959
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 952
    i += 2U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 962
  lbitset_unused_clear(dst);
#line 963
  lbitset_weed(dst);
  }
#line 964
  return;
}
}
#line 969 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_subset_p(bitset dst , bitset src ) 
{ 
  lbitset_elt *selt ;
  lbitset_elt *delt ;
  unsigned int j ;

  {
#line 976
  selt = src->l.head;
#line 976
  delt = dst->l.head;
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    if (! selt) {
#line 976
      if (! delt) {
#line 976
        goto while_break;
      }
    }
#line 979
    if (! selt) {
#line 980
      selt = & lbitset_zero_elts[0];
    } else
#line 981
    if (! delt) {
#line 982
      delt = & lbitset_zero_elts[0];
    } else
#line 983
    if (selt->index != delt->index) {
#line 985
      if (selt->index < delt->index) {
#line 987
        lbitset_zero_elts[2].next = delt;
#line 988
        delt = & lbitset_zero_elts[2];
      } else {
#line 992
        lbitset_zero_elts[1].next = selt;
#line 993
        selt = & lbitset_zero_elts[1];
      }
    }
#line 997
    j = 0U;
    {
#line 997
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 997
      if (! (j < 2U)) {
#line 997
        goto while_break___0;
      }
#line 998
      if (delt->words[j] != (selt->words[j] | delt->words[j])) {
#line 999
        return ((_Bool)0);
      }
#line 997
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 976
    selt = selt->next;
#line 976
    delt = delt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1001
  return ((_Bool)1);
}
}
#line 1006 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_disjoint_p(bitset dst , bitset src ) 
{ 
  lbitset_elt *selt ;
  lbitset_elt *delt ;
  unsigned int j ;

  {
#line 1013
  selt = src->l.head;
#line 1013
  delt = dst->l.head;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1013
    if (selt) {
#line 1013
      if (! delt) {
#line 1013
        goto while_break;
      }
    } else {
#line 1013
      goto while_break;
    }
#line 1016
    if (selt->index != delt->index) {
#line 1018
      if (selt->index < delt->index) {
#line 1020
        lbitset_zero_elts[2].next = delt;
#line 1021
        delt = & lbitset_zero_elts[2];
      } else {
#line 1025
        lbitset_zero_elts[1].next = selt;
#line 1026
        selt = & lbitset_zero_elts[1];
      }
#line 1030
      goto __Cont;
    }
#line 1033
    j = 0U;
    {
#line 1033
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1033
      if (! (j < 2U)) {
#line 1033
        goto while_break___0;
      }
#line 1034
      if (selt->words[j] & delt->words[j]) {
#line 1035
        return ((_Bool)0);
      }
#line 1033
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1013
    selt = selt->next;
#line 1013
    delt = delt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1037
  return ((_Bool)1);
}
}
#line 1041 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_op3_cmp(bitset dst , bitset src1 , bitset src2 , enum bitset_ops op ) 
{ 
  lbitset_elt *selt1 ;
  lbitset_elt *selt2 ;
  lbitset_elt *delt ;
  bitset_windex windex1 ;
  bitset_windex windex2 ;
  bitset_windex windex ;
  lbitset_elt *stmp1 ;
  lbitset_elt *stmp2 ;
  lbitset_elt *dtmp ;
  bitset_word *srcp1 ;
  bitset_word *srcp2 ;
  bitset_word *dstp ;
  _Bool changed ;
  unsigned int i ;
  bitset_word tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word tmp___2 ;
  bitset_word *tmp___3 ;
  bitset_word *tmp___4 ;
  bitset_word tmp___5 ;
  bitset_word *tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word tmp___8 ;
  bitset_word *tmp___9 ;
  bitset_word *tmp___10 ;
  _Bool tmp___11 ;

  {
#line 1044
  selt1 = src1->l.head;
#line 1045
  selt2 = src2->l.head;
#line 1046
  delt = dst->l.head;
#line 1056
  changed = (_Bool)0;
#line 1059
  dst->l.head = (struct lbitset_elt_struct *)0;
#line 1060
  dst->b.csize = (bitset_windex )0;
#line 1062
  if (selt1) {
#line 1062
    windex1 = selt1->index;
  } else {
#line 1062
    windex1 = 4294967295U >> 1;
  }
#line 1063
  if (selt2) {
#line 1063
    windex2 = selt2->index;
  } else {
#line 1063
    windex2 = 4294967295U >> 1;
  }
  {
#line 1065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1065
    if (! selt1) {
#line 1065
      if (! selt2) {
#line 1065
        goto while_break;
      }
    }
#line 1069
    if (windex1 == windex2) {
#line 1071
      windex = windex1;
#line 1072
      stmp1 = selt1;
#line 1073
      stmp2 = selt2;
#line 1074
      selt1 = selt1->next;
#line 1075
      if (selt1) {
#line 1075
        windex1 = selt1->index;
      } else {
#line 1075
        windex1 = 4294967295U >> 1;
      }
#line 1076
      selt2 = selt2->next;
#line 1077
      if (selt2) {
#line 1077
        windex2 = selt2->index;
      } else {
#line 1077
        windex2 = 4294967295U >> 1;
      }
    } else
#line 1079
    if (windex1 < windex2) {
#line 1081
      windex = windex1;
#line 1082
      stmp1 = selt1;
#line 1083
      stmp2 = & lbitset_zero_elts[0];
#line 1084
      selt1 = selt1->next;
#line 1085
      if (selt1) {
#line 1085
        windex1 = selt1->index;
      } else {
#line 1085
        windex1 = 4294967295U >> 1;
      }
    } else {
#line 1089
      windex = windex2;
#line 1090
      stmp1 = & lbitset_zero_elts[0];
#line 1091
      stmp2 = selt2;
#line 1092
      selt2 = selt2->next;
#line 1093
      if (selt2) {
#line 1093
        windex2 = selt2->index;
      } else {
#line 1093
        windex2 = 4294967295U >> 1;
      }
    }
    {
#line 1098
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1098
      if (delt) {
#line 1098
        if (! (delt->index < windex)) {
#line 1098
          goto while_break___0;
        }
      } else {
#line 1098
        goto while_break___0;
      }
      {
#line 1100
      changed = (_Bool)1;
#line 1101
      dtmp = delt;
#line 1102
      delt = delt->next;
#line 1103
      lbitset_elt_free(dtmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1105
    if (delt) {
#line 1105
      if (delt->index == windex) {
#line 1107
        dtmp = delt;
#line 1108
        delt = delt->next;
      } else {
        {
#line 1111
        dtmp = lbitset_elt_calloc();
        }
      }
    } else {
      {
#line 1111
      dtmp = lbitset_elt_calloc();
      }
    }
#line 1115
    srcp1 = stmp1->words;
#line 1116
    srcp2 = stmp2->words;
#line 1117
    dstp = dtmp->words;
    {
#line 1123
    if ((unsigned int )op == 9U) {
#line 1123
      goto case_9;
    }
#line 1136
    if ((unsigned int )op == 8U) {
#line 1136
      goto case_8;
    }
#line 1149
    if ((unsigned int )op == 10U) {
#line 1149
      goto case_10;
    }
#line 1162
    if ((unsigned int )op == 11U) {
#line 1162
      goto case_11;
    }
#line 1120
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 1121
    abort();
    }
    case_9: /* CIL Label */ 
#line 1124
    i = 0U;
    {
#line 1124
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1124
      if (! (i < 2U)) {
#line 1124
        goto while_break___1;
      }
#line 1126
      tmp___0 = srcp1;
#line 1126
      srcp1 ++;
#line 1126
      tmp___1 = srcp2;
#line 1126
      srcp2 ++;
#line 1126
      tmp = *tmp___0 | *tmp___1;
#line 1128
      if (*dstp != tmp) {
#line 1130
        changed = (_Bool)1;
#line 1131
        *dstp = tmp;
      }
#line 1124
      i ++;
#line 1124
      dstp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1134
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1137
    i = 0U;
    {
#line 1137
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1137
      if (! (i < 2U)) {
#line 1137
        goto while_break___2;
      }
#line 1139
      tmp___3 = srcp1;
#line 1139
      srcp1 ++;
#line 1139
      tmp___4 = srcp2;
#line 1139
      srcp2 ++;
#line 1139
      tmp___2 = *tmp___3 & *tmp___4;
#line 1141
      if (*dstp != tmp___2) {
#line 1143
        changed = (_Bool)1;
#line 1144
        *dstp = tmp___2;
      }
#line 1137
      i ++;
#line 1137
      dstp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1147
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1150
    i = 0U;
    {
#line 1150
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1150
      if (! (i < 2U)) {
#line 1150
        goto while_break___3;
      }
#line 1152
      tmp___6 = srcp1;
#line 1152
      srcp1 ++;
#line 1152
      tmp___7 = srcp2;
#line 1152
      srcp2 ++;
#line 1152
      tmp___5 = *tmp___6 ^ *tmp___7;
#line 1154
      if (*dstp != tmp___5) {
#line 1156
        changed = (_Bool)1;
#line 1157
        *dstp = tmp___5;
      }
#line 1150
      i ++;
#line 1150
      dstp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1160
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1163
    i = 0U;
    {
#line 1163
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1163
      if (! (i < 2U)) {
#line 1163
        goto while_break___4;
      }
#line 1165
      tmp___9 = srcp1;
#line 1165
      srcp1 ++;
#line 1165
      tmp___10 = srcp2;
#line 1165
      srcp2 ++;
#line 1165
      tmp___8 = *tmp___9 & ~ *tmp___10;
#line 1167
      if (*dstp != tmp___8) {
#line 1169
        changed = (_Bool)1;
#line 1170
        *dstp = tmp___8;
      }
#line 1163
      i ++;
#line 1163
      dstp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1173
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1176
    tmp___11 = lbitset_elt_zero_p(dtmp);
    }
#line 1176
    if (tmp___11) {
      {
#line 1184
      lbitset_elt_free(dtmp);
      }
    } else {
      {
#line 1178
      dtmp->index = windex;
#line 1180
      lbitset_elt_link(dst, dtmp);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1189
  if (delt) {
    {
#line 1191
    changed = (_Bool)1;
#line 1192
    lbitset_prune(dst, delt);
    }
  }
#line 1195
  return (changed);
}
}
#line 1199 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_and_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  lbitset_elt *selt1 ;
  lbitset_elt *selt2 ;
  _Bool changed ;
  _Bool tmp ;

  {
#line 1202
  selt1 = src1->l.head;
#line 1203
  selt2 = src2->l.head;
#line 1206
  if (! selt2) {
    {
#line 1208
    lbitset_weed(dst);
#line 1209
    changed = (_Bool )(! dst->l.head);
#line 1210
    lbitset_zero(dst);
    }
#line 1211
    return (changed);
  } else
#line 1213
  if (! selt1) {
    {
#line 1215
    lbitset_weed(dst);
#line 1216
    changed = (_Bool )(! dst->l.head);
#line 1217
    lbitset_zero(dst);
    }
#line 1218
    return (changed);
  }
  {
#line 1220
  tmp = lbitset_op3_cmp(dst, src1, src2, (enum bitset_ops )8);
  }
#line 1220
  return (tmp);
}
}
#line 1224 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_and(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1227
  lbitset_and_cmp(dst, src1, src2);
  }
#line 1228
  return;
}
}
#line 1231 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_andn_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  lbitset_elt *selt1 ;
  lbitset_elt *selt2 ;
  _Bool changed ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 1234
  selt1 = src1->l.head;
#line 1235
  selt2 = src2->l.head;
#line 1238
  if (! selt2) {
    {
#line 1240
    tmp = lbitset_copy_cmp(dst, src1);
    }
#line 1240
    return (tmp);
  } else
#line 1242
  if (! selt1) {
    {
#line 1244
    lbitset_weed(dst);
#line 1245
    changed = (_Bool )(! dst->l.head);
#line 1246
    lbitset_zero(dst);
    }
#line 1247
    return (changed);
  }
  {
#line 1249
  tmp___0 = lbitset_op3_cmp(dst, src1, src2, (enum bitset_ops )11);
  }
#line 1249
  return (tmp___0);
}
}
#line 1253 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_andn(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1256
  lbitset_andn_cmp(dst, src1, src2);
  }
#line 1257
  return;
}
}
#line 1260 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_or_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  lbitset_elt *selt1 ;
  lbitset_elt *selt2 ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1263
  selt1 = src1->l.head;
#line 1264
  selt2 = src2->l.head;
#line 1266
  if (! selt2) {
    {
#line 1268
    tmp = lbitset_copy_cmp(dst, src1);
    }
#line 1268
    return (tmp);
  } else
#line 1270
  if (! selt1) {
    {
#line 1272
    tmp___0 = lbitset_copy_cmp(dst, src2);
    }
#line 1272
    return (tmp___0);
  }
  {
#line 1274
  tmp___1 = lbitset_op3_cmp(dst, src1, src2, (enum bitset_ops )9);
  }
#line 1274
  return (tmp___1);
}
}
#line 1278 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_or(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1281
  lbitset_or_cmp(dst, src1, src2);
  }
#line 1282
  return;
}
}
#line 1285 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static _Bool lbitset_xor_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  lbitset_elt *selt1 ;
  lbitset_elt *selt2 ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1288
  selt1 = src1->l.head;
#line 1289
  selt2 = src2->l.head;
#line 1291
  if (! selt2) {
    {
#line 1293
    tmp = lbitset_copy_cmp(dst, src1);
    }
#line 1293
    return (tmp);
  } else
#line 1295
  if (! selt1) {
    {
#line 1297
    tmp___0 = lbitset_copy_cmp(dst, src2);
    }
#line 1297
    return (tmp___0);
  }
  {
#line 1299
  tmp___1 = lbitset_op3_cmp(dst, src1, src2, (enum bitset_ops )10);
  }
#line 1299
  return (tmp___1);
}
}
#line 1303 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
static void lbitset_xor(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1306
  lbitset_xor_cmp(dst, src1, src2);
  }
#line 1307
  return;
}
}
#line 1312 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
struct bitset_vtable lbitset_vtable  = 
#line 1312
     {& lbitset_set, & lbitset_reset, & bitset_toggle_, & lbitset_test, & lbitset_resize,
    & bitset_size_, & bitset_count_, & lbitset_empty_p, & lbitset_ones, & lbitset_zero,
    & lbitset_copy, & lbitset_disjoint_p, & lbitset_equal_p, & lbitset_not, & lbitset_subset_p,
    & lbitset_and, & lbitset_and_cmp, & lbitset_andn, & lbitset_andn_cmp, & lbitset_or,
    & lbitset_or_cmp, & lbitset_xor, & lbitset_xor_cmp, & bitset_and_or_, & bitset_and_or_cmp_,
    & bitset_andn_or_, & bitset_andn_or_cmp_, & bitset_or_and_, & bitset_or_and_cmp_,
    & lbitset_list, & lbitset_list_reverse, & lbitset_free, (enum bitset_type )1};
#line 1350 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
size_t lbitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) 
{ 


  {
#line 1353
  return ((size_t )sizeof(struct lbitset_struct ));
}
}
#line 1358 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
bitset lbitset_init(bitset bset , bitset_bindex n_bits  __attribute__((__unused__)) ) 
{ 


  {
#line 1361
  bset->b.n_bits = n_bits;
#line 1362
  bset->b.vtable = (struct bitset_vtable  const  *)(& lbitset_vtable);
#line 1363
  return (bset);
}
}
#line 1367 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
void lbitset_release_memory(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 1370
  lbitset_free_list = (lbitset_elt *)0;
#line 1371
  if (lbitset_obstack_init) {
#line 1373
    lbitset_obstack_init = (_Bool)0;
#line 1374
    __o = & lbitset_obstack;
#line 1374
    __obj = (void *)0;
#line 1374
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 1374
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 1374
        tmp = (char *)__obj;
#line 1374
        __o->object_base = tmp;
#line 1374
        __o->next_free = tmp;
      } else {
        {
#line 1374
        obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 1374
      obstack_free(__o, __obj);
      }
    }
  }
#line 1376
  return;
}
}
#line 1380 "/home/pronto/abs/test-suite/bison-2.5/lib/lbitset.c"
void debug_lbitset(bitset bset ) 
{ 
  lbitset_elt *elt ;
  unsigned int i ;
  unsigned int j ;
  bitset_word word ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1386
  if (! bset) {
#line 1387
    return;
  }
#line 1389
  elt = bset->l.head;
  {
#line 1389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1389
    if (! elt) {
#line 1389
      goto while_break;
    }
    {
#line 1391
    rpl_fprintf(stderr, "Elt %lu\n", (unsigned long )elt->index);
#line 1392
    i = 0U;
    }
    {
#line 1392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1392
      if (! (i < 2U)) {
#line 1392
        goto while_break___0;
      }
      {
#line 1397
      word = elt->words[i];
#line 1399
      rpl_fprintf(stderr, "  Word %u:", i);
#line 1400
      j = 0U;
      }
      {
#line 1400
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1400
        if (! (j < (unsigned int )(8UL * sizeof(bitset_word )))) {
#line 1400
          goto while_break___1;
        }
#line 1401
        if (word & (1UL << j)) {
          {
#line 1402
          rpl_fprintf(stderr, " %u", j);
          }
        }
#line 1400
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1403
      rpl_fprintf(stderr, "\n");
#line 1392
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1389
    elt = elt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1406
  return;
}
}
#line 82 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
int rpl_isnanl(long double x ) 
{ 
  memory_double m ;
  unsigned int exponent ;

  {
#line 98
  m.value = x;
#line 99
  exponent = m.word[2] & 32767U;
#line 110
  if (exponent == 0U) {
#line 111
    return ((int )(m.word[1] >> 31));
  } else
#line 112
  if (exponent == 32767U) {
#line 113
    return (((m.word[1] ^ 2147483648U) | m.word[0]) != 0U);
  } else {
#line 115
    return ((int )((m.word[1] >> 31) ^ 1U));
  }
}
}
#line 30
int rpl_isnanf(float x ) ;
#line 133 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
static memory_double___0 nan  =    {0.0f / 0.0f};
#line 134 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
static float plus_inf  =    1.0f / 0.0f;
#line 135 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
static float minus_inf  =    - 1.0f / 0.0f;
#line 82 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
int rpl_isnanf(float x ) 
{ 
  memory_double___0 m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 142
  m.value = x;
#line 143
  if (((m.word[0] ^ nan.word[0]) & (unsigned int )(255 << 23)) == 0U) {
    {
#line 146
    tmp = memcmp((void const   *)(& m.value), (void const   *)(& plus_inf), (size_t )4);
    }
#line 146
    if (tmp != 0) {
      {
#line 146
      tmp___0 = memcmp((void const   *)(& m.value), (void const   *)(& minus_inf),
                       (size_t )4);
      }
#line 146
      if (tmp___0 != 0) {
#line 146
        tmp___1 = 1;
      } else {
#line 146
        tmp___1 = 0;
      }
    } else {
#line 146
      tmp___1 = 0;
    }
#line 146
    return (tmp___1);
  } else {
#line 149
    return (0);
  }
}
}
#line 27
int rpl_isnand(double x ) ;
#line 133 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
static memory_double___1 nan___0  =    {0.0 / 0.0};
#line 134 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
static double plus_inf___0  =    1.0 / 0.0;
#line 135 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
static double minus_inf___0  =    - 1.0 / 0.0;
#line 82 "/home/pronto/abs/test-suite/bison-2.5/lib/isnan.c"
int rpl_isnand(double x ) 
{ 
  memory_double___1 m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 142
  m.value = x;
#line 143
  if (((m.word[1] ^ nan___0.word[1]) & (unsigned int )(2047 << 20)) == 0U) {
    {
#line 146
    tmp = memcmp((void const   *)(& m.value), (void const   *)(& plus_inf___0), (size_t )8);
    }
#line 146
    if (tmp != 0) {
      {
#line 146
      tmp___0 = memcmp((void const   *)(& m.value), (void const   *)(& minus_inf___0),
                       (size_t )8);
      }
#line 146
      if (tmp___0 != 0) {
#line 146
        tmp___1 = 1;
      } else {
#line 146
        tmp___1 = 0;
      }
    } else {
#line 146
      tmp___1 = 0;
    }
#line 146
    return (tmp___1);
  } else {
#line 149
    return (0);
  }
}
}
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 357 "./sys/ioctl.h"
int rpl_ioctl(int fd , int request  , ...) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/lib/ioctl.c"
int rpl_ioctl(int fd , int request  , ...) 
{ 
  void *buf___0 ;
  va_list args ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 36
  __builtin_va_start(args, request);
#line 37
  tmp = __builtin_va_arg(args, void *);
#line 37
  buf___0 = tmp;
#line 38
  __builtin_va_end(args);
#line 42
  tmp___0 = ioctl(fd, (unsigned long )((unsigned int )request), buf___0);
  }
#line 42
  return (tmp___0);
}
}
#line 62 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table___0 ) ;
#line 63
size_t hash_get_n_buckets_used(Hash_table const   *table___0 ) ;
#line 64
size_t hash_get_n_entries(Hash_table const   *table___0 ) ;
#line 65
size_t hash_get_max_bucket_length(Hash_table const   *table___0 ) ;
#line 66
_Bool hash_table_ok(Hash_table const   *table___0 ) ;
#line 67
void hash_print_statistics(Hash_table const   *table___0 , FILE *stream ) ;
#line 68
void *hash_lookup(Hash_table const   *table___0 , void const   *entry ) ;
#line 71
void *hash_get_first(Hash_table const   *table___0 ) ;
#line 72
void *hash_get_next(Hash_table const   *table___0 , void const   *entry ) ;
#line 73
size_t hash_get_entries(Hash_table const   *table___0 , void **buffer , size_t buffer_size ) ;
#line 74
size_t hash_do_for_each(Hash_table const   *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) ;
#line 77
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 78
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 79
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 82
void hash_clear(Hash_table *table___0 ) ;
#line 83
void hash_free(Hash_table *table___0 ) ;
#line 86
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table___0 ,
                                                             size_t candidate ) ;
#line 87
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table___0 ,
                                                             void const   *entry ) ;
#line 88
int hash_insert0(Hash_table *table___0 , void const   *entry , void const   **matched_ent ) ;
#line 90
void *hash_delete(Hash_table *table___0 , void const   *entry ) ;
#line 76 "/home/pronto/abs/test-suite/bison-2.5/lib/bitrotate.h"
__inline static size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 79
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 4294967295U);
}
}
#line 130 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 149 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table___0 ) 
{ 


  {
#line 152
  return ((size_t )table___0->n_buckets);
}
}
#line 157 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table___0 ) 
{ 


  {
#line 160
  return ((size_t )table___0->n_buckets_used);
}
}
#line 165 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table___0 ) 
{ 


  {
#line 168
  return ((size_t )table___0->n_entries);
}
}
#line 173 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table___0 ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 179
      goto while_break;
    }
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        cursor = (struct hash_entry  const  *)cursor->next;
#line 186
        if (! cursor) {
#line 186
          goto while_break___0;
        }
#line 187
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
#line 179
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (max_bucket_length);
}
}
#line 200 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table___0 ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 207
      goto while_break;
    }
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        cursor = (struct hash_entry  const  *)cursor->next;
#line 218
        if (! cursor) {
#line 218
          goto while_break___0;
        }
#line 219
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 207
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (n_buckets_used == (size_t )table___0->n_buckets_used) {
#line 223
    if (n_entries == (size_t )table___0->n_entries) {
#line 224
      return ((_Bool)1);
    }
  }
#line 226
  return ((_Bool)0);
}
}
#line 229 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
void hash_print_statistics(Hash_table const   *table___0 , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 232
  tmp = hash_get_n_entries(table___0);
#line 232
  n_entries = tmp;
#line 233
  tmp___0 = hash_get_n_buckets(table___0);
#line 233
  n_buckets = tmp___0;
#line 234
  tmp___1 = hash_get_n_buckets_used(table___0);
#line 234
  n_buckets_used = tmp___1;
#line 235
  tmp___2 = hash_get_max_bucket_length(table___0);
#line 235
  max_bucket_length = tmp___2;
#line 237
  rpl_fprintf(stream, "# entries:         %lu\n", (unsigned long )n_entries);
#line 238
  rpl_fprintf(stream, "# buckets:         %lu\n", (unsigned long )n_buckets);
#line 239
  rpl_fprintf(stream, "# buckets used:    %lu (%.2f%%)\n", (unsigned long )n_buckets_used,
              (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 242
  rpl_fprintf(stream, "max bucket length: %lu\n", (unsigned long )max_bucket_length);
  }
#line 244
  return;
}
}
#line 248 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static struct hash_entry *safe_hasher(Hash_table const   *table___0 , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table___0->hasher))(key, (size_t )table___0->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table___0->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table___0->bucket + n));
}
}
#line 260 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
void *hash_lookup(Hash_table const   *table___0 , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 263
  tmp = safe_hasher(table___0, entry);
#line 263
  bucket = (struct hash_entry  const  *)tmp;
  }
#line 266
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! cursor) {
#line 269
      goto while_break;
    }
#line 270
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 271
      return ((void *)cursor->data);
    } else {
      {
#line 270
      tmp___0 = (*(table___0->comparator))(entry, (void const   *)cursor->data);
      }
#line 270
      if (tmp___0) {
#line 271
        return ((void *)cursor->data);
      }
    }
#line 269
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return ((void *)0);
}
}
#line 287 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
void *hash_get_first(Hash_table const   *table___0 ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 292
  if (table___0->n_entries == 0U) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
#line 297
      abort();
      }
    } else
#line 298
    if (bucket->data) {
#line 299
      return ((void *)bucket->data);
    }
#line 295
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 306 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
void *hash_get_next(Hash_table const   *table___0 , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 309
  tmp = safe_hasher(table___0, entry);
#line 309
  bucket = (struct hash_entry  const  *)tmp;
#line 313
  cursor = bucket;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = (struct hash_entry  const  *)cursor->next;
#line 314
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    bucket ++;
#line 323
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 323
      goto while_break___0;
    }
#line 324
    if (bucket->data) {
#line 325
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return ((void *)0);
}
}
#line 335 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table___0 , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 343
      goto while_break;
    }
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! cursor) {
#line 347
          goto while_break___0;
        }
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        tmp = counter;
#line 351
        counter ++;
#line 351
        *(buffer + tmp) = (void *)cursor->data;
#line 347
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 343
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (counter);
}
}
#line 367 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 375
      goto while_break;
    }
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! cursor) {
#line 379
          goto while_break___0;
        }
        {
#line 381
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 381
        if (! tmp) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
#line 379
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 375
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (counter);
}
}
#line 427 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 430
  value = (size_t )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    ch = (unsigned char )*string;
#line 433
    if (! ch) {
#line 433
      goto while_break;
    }
#line 434
    value = (value * 31U + (size_t )ch) % n_buckets;
#line 433
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (value);
}
}
#line 443 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4U * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10U) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1U;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (4294967295U != candidate) {
      {
#line 472
      tmp = is_prime(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 478 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 481
  *tuning = (Hash_tuning )default_tuning;
#line 482
  return;
}
}
#line 485 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static _Bool check_tuning(Hash_table *table___0 ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table___0->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table___0->tuning = & default_tuning;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static size_t compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )4294967295U <= new_candidate) {
#line 550
      return ((size_t )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime(candidate);
  }
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = -1;
  } else {
#line 554
    tmp = -2;
  }
#line 554
  if ((unsigned long )((size_t )tmp) / sizeof(struct hash_entry *) < (unsigned long )candidate) {
#line 555
    return ((size_t )0);
  }
#line 556
  return (candidate);
}
}
#line 593 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table___0 ;
  void *tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;

  {
#line 600
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 601
    hasher = & raw_hasher;
  }
#line 602
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 603
    comparator = & raw_comparator;
  }
  {
#line 605
  tmp = malloc((size_t )sizeof(*table___0));
#line 605
  table___0 = (Hash_table *)tmp;
  }
#line 606
  if ((unsigned long )table___0 == (unsigned long )((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
  {
#line 611
  table___0->tuning = tuning;
#line 612
  tmp___0 = check_tuning(table___0);
  }
#line 612
  if (! tmp___0) {
#line 619
    goto fail;
  }
  {
#line 622
  table___0->n_buckets = compute_bucket_size(candidate, tuning);
  }
#line 623
  if (! table___0->n_buckets) {
#line 624
    goto fail;
  }
  {
#line 626
  tmp___1 = calloc(table___0->n_buckets, (size_t )sizeof(*(table___0->bucket)));
#line 626
  table___0->bucket = (struct hash_entry *)tmp___1;
  }
#line 627
  if ((unsigned long )table___0->bucket == (unsigned long )((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table___0->bucket_limit = (struct hash_entry  const  *)(table___0->bucket + table___0->n_buckets);
#line 630
  table___0->n_buckets_used = (size_t )0;
#line 631
  table___0->n_entries = (size_t )0;
#line 633
  table___0->hasher = hasher;
#line 634
  table___0->comparator = comparator;
#line 635
  table___0->data_freer = data_freer;
#line 637
  table___0->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table___0);
  fail: 
  {
#line 644
  free((void *)table___0);
  }
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 652 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
void hash_clear(Hash_table *table___0 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table___0->bucket;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 657
      goto while_break;
    }
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
      {
#line 665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 665
        if (! cursor) {
#line 665
          goto while_break___0;
        }
#line 667
        if (table___0->data_freer) {
          {
#line 668
          (*(table___0->data_freer))(cursor->data);
          }
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table___0->free_entry_list;
#line 675
        table___0->free_entry_list = cursor;
#line 665
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 679
      if (table___0->data_freer) {
        {
#line 680
        (*(table___0->data_freer))(bucket->data);
        }
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 657
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  table___0->n_buckets_used = (size_t )0;
#line 687
  table___0->n_entries = (size_t )0;
#line 688
  return;
}
}
#line 695 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
void hash_free(Hash_table *table___0 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table___0->data_freer) {
#line 703
    if (table___0->n_entries) {
#line 705
      bucket = table___0->bucket;
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 705
          goto while_break;
        }
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
          {
#line 709
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 709
            if (! cursor) {
#line 709
              goto while_break___0;
            }
            {
#line 710
            (*(table___0->data_freer))(cursor->data);
#line 709
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 705
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 722
  bucket = table___0->bucket;
  {
#line 722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 722
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 722
      goto while_break___1;
    }
#line 724
    cursor = bucket->next;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! cursor) {
#line 724
        goto while_break___2;
      }
      {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
#line 724
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 722
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  cursor = table___0->free_entry_list;
  {
#line 732
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 732
    if (! cursor) {
#line 732
      goto while_break___3;
    }
    {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
#line 732
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 741
  free((void *)table___0->bucket);
#line 742
  free((void *)table___0);
  }
#line 743
  return;
}
}
#line 750 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table___0 ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table___0->free_entry_list) {
#line 757
    new = table___0->free_entry_list;
#line 758
    table___0->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc((size_t )sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static void free_entry(Hash_table *table___0 , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table___0->free_entry_list;
#line 780
  table___0->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static void *hash_find_entry(Hash_table *table___0 , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher((Hash_table const   *)table___0, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table___0->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry(table___0, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table___0->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry(table___0, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 942 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table___0 ,
                                                             size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 947
  tmp = compute_bucket_size(candidate, table___0->tuning);
#line 947
  new_size = tmp;
  }
#line 949
  if (! new_size) {
#line 950
    return ((_Bool)0);
  }
#line 951
  if (new_size == table___0->n_buckets) {
#line 952
    return ((_Bool)1);
  }
  {
#line 953
  new_table = & storage;
#line 954
  tmp___0 = calloc(new_size, (size_t )sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 955
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 956
    return ((_Bool)0);
  }
  {
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table___0->tuning;
#line 962
  new_table->hasher = table___0->hasher;
#line 963
  new_table->comparator = table___0->comparator;
#line 964
  new_table->data_freer = table___0->data_freer;
#line 984
  new_table->free_entry_list = table___0->free_entry_list;
#line 986
  tmp___1 = transfer_entries(new_table, table___0, (_Bool)0);
  }
#line 986
  if (tmp___1) {
    {
#line 989
    free((void *)table___0->bucket);
#line 990
    table___0->bucket = new_table->bucket;
#line 991
    table___0->bucket_limit = new_table->bucket_limit;
#line 992
    table___0->n_buckets = new_table->n_buckets;
#line 993
    table___0->n_buckets_used = new_table->n_buckets_used;
#line 994
    table___0->free_entry_list = new_table->free_entry_list;
    }
#line 996
    return ((_Bool)1);
  }
  {
#line 1012
  table___0->free_entry_list = new_table->free_entry_list;
#line 1013
  tmp___2 = transfer_entries(table___0, new_table, (_Bool)1);
  }
#line 1013
  if (tmp___2) {
    {
#line 1013
    tmp___3 = transfer_entries(table___0, new_table, (_Bool)0);
    }
#line 1013
    if (! tmp___3) {
      {
#line 1015
      abort();
      }
    }
  } else {
    {
#line 1015
    abort();
    }
  }
  {
#line 1017
  free((void *)new_table->bucket);
  }
#line 1018
  return ((_Bool)0);
}
}
#line 1035 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
int hash_insert0(Hash_table *table___0 , void const   *entry , void const   **matched_ent ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1044
  if (! entry) {
    {
#line 1045
    abort();
    }
  }
  {
#line 1048
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)0);
  }
#line 1048
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1050
    if (matched_ent) {
#line 1051
      *matched_ent = (void const   *)data;
    }
#line 1052
    return (0);
  }
#line 1060
  if ((float const   )table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const   )table___0->n_buckets) {
    {
#line 1065
    check_tuning(table___0);
    }
#line 1066
    if ((float const   )table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const   )table___0->n_buckets) {
#line 1069
      tuning = table___0->tuning;
#line 1070
      if (tuning->is_n_buckets) {
#line 1070
        tmp = (float const   )table___0->n_buckets * tuning->growth_factor;
      } else {
#line 1070
        tmp = ((float const   )table___0->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1070
      candidate = (float )tmp;
#line 1076
      if ((float )4294967295U <= candidate) {
#line 1077
        return (-1);
      }
      {
#line 1080
      tmp___0 = hash_rehash(table___0, (size_t )candidate);
      }
#line 1080
      if (! tmp___0) {
#line 1081
        return (-1);
      }
      {
#line 1084
      tmp___1 = hash_find_entry(table___0, entry, & bucket, (_Bool)0);
      }
#line 1084
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1085
        abort();
        }
      }
    }
  }
#line 1091
  if (bucket->data) {
    {
#line 1093
    tmp___2 = allocate_entry(table___0);
#line 1093
    new_entry = tmp___2;
    }
#line 1095
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1096
      return (-1);
    }
#line 1100
    new_entry->data = (void *)entry;
#line 1101
    new_entry->next = bucket->next;
#line 1102
    bucket->next = new_entry;
#line 1103
    (table___0->n_entries) ++;
#line 1104
    return (1);
  }
#line 1109
  bucket->data = (void *)entry;
#line 1110
  (table___0->n_entries) ++;
#line 1111
  (table___0->n_buckets_used) ++;
#line 1113
  return (1);
}
}
#line 1122 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table___0 ,
                                                             void const   *entry ) 
{ 
  void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1126
  tmp = hash_insert0(table___0, entry, & matched_ent);
#line 1126
  err = tmp;
  }
#line 1127
  if (err == -1) {
#line 1127
    tmp___1 = (void *)0;
  } else {
#line 1127
    if (err == 0) {
#line 1127
      tmp___0 = matched_ent;
    } else {
#line 1127
      tmp___0 = entry;
    }
#line 1127
    tmp___1 = (void *)tmp___0;
  }
#line 1127
  return (tmp___1);
}
}
#line 1136 "/home/pronto/abs/test-suite/bison-2.5/lib/hash.c"
void *hash_delete(Hash_table *table___0 , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1142
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)1);
  }
#line 1143
  if (! data) {
#line 1144
    return ((void *)0);
  }
#line 1146
  (table___0->n_entries) --;
#line 1147
  if (! bucket->data) {
#line 1149
    (table___0->n_buckets_used) --;
#line 1154
    if ((float const   )table___0->n_buckets_used < (table___0->tuning)->shrink_threshold * (float const   )table___0->n_buckets) {
      {
#line 1159
      check_tuning(table___0);
      }
#line 1160
      if ((float const   )table___0->n_buckets_used < (table___0->tuning)->shrink_threshold * (float const   )table___0->n_buckets) {
#line 1163
        tuning = table___0->tuning;
#line 1164
        if (tuning->is_n_buckets) {
#line 1164
          tmp = (float const   )table___0->n_buckets * tuning->shrink_factor;
        } else {
#line 1164
          tmp = ((float const   )table___0->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1164
        candidate = (size_t )tmp;
#line 1170
        tmp___0 = hash_rehash(table___0, candidate);
        }
#line 1170
        if (! tmp___0) {
#line 1178
          cursor = table___0->free_entry_list;
          {
#line 1180
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1180
            if (! cursor) {
#line 1180
              goto while_break;
            }
            {
#line 1182
            next = cursor->next;
#line 1183
            free((void *)cursor);
#line 1184
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1186
          table___0->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1193
  return (data);
}
}
#line 245 "./getopt.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc ,
                                                                                       char **argv ,
                                                                                       char const   *options ,
                                                                                       struct rpl_option  const  *long_options___0 ,
                                                                                       int *opt_index ) ;
#line 249
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc ,
                                                                                            char **argv ,
                                                                                            char const   *options ,
                                                                                            struct rpl_option  const  *long_options___0 ,
                                                                                            int *opt_index ) ;
#line 24 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt_int.h"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) ;
#line 118
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) ;
#line 124
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___0 ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 129
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___0 ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt1.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc ,
                                                                                       char **argv ,
                                                                                       char const   *options ,
                                                                                       struct rpl_option  const  *long_options___0 ,
                                                                                       int *opt_index ) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt1.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc , char **argv ,
                                                         char const   *options , struct rpl_option  const  *long_options___0 ,
                                                         int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = rpl_getopt_internal(argc, argv, options, long_options___0, opt_index, 0, 0);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt1.c"
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___0 ,
                   int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 52
  tmp = _getopt_internal_r(argc, argv, options, long_options___0, opt_index, 0, d,
                           0);
  }
#line 52
  return (tmp);
}
}
#line 61
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc ,
                                                                                            char **argv ,
                                                                                            char const   *options ,
                                                                                            struct rpl_option  const  *long_options___0 ,
                                                                                            int *opt_index ) ;
#line 61 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt1.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc , char **argv ,
                                                              char const   *options ,
                                                              struct rpl_option  const  *long_options___0 ,
                                                              int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 66
  tmp = rpl_getopt_internal(argc, argv, options, long_options___0, opt_index, 1, 0);
  }
#line 66
  return (tmp);
}
}
#line 70 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt1.c"
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___0 ,
                        int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 75
  tmp = _getopt_internal_r(argc, argv, options, long_options___0, opt_index, 1, d,
                           0);
  }
#line 75
  return (tmp);
}
}
#line 148 "./getopt.h"
char *rpl_optarg  ;
#line 162
int rpl_optind ;
#line 167
int rpl_opterr ;
#line 171
int rpl_optopt ;
#line 241
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc ,
                                                                                  char * const  *argv ,
                                                                                  char const   *optstring ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 82 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt.c"
int rpl_optind  =    1;
#line 87 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt.c"
int rpl_opterr  =    1;
#line 93 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt.c"
int rpl_optopt  =    '?';
#line 97 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt.c"
static struct _getopt_data getopt_data  ;
#line 143 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ 
  int bottom ;
  int middle ;
  int top___0 ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
#line 146
  bottom = d->__first_nonopt;
#line 147
  middle = d->__last_nonopt;
#line 148
  top___0 = d->rpl_optind;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (top___0 > middle) {
#line 178
      if (! (middle > bottom)) {
#line 178
        goto while_break;
      }
    } else {
#line 178
      goto while_break;
    }
#line 180
    if (top___0 - middle > middle - bottom) {
#line 183
      len = middle - bottom;
#line 187
      i = 0;
      {
#line 187
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 187
        if (! (i < len)) {
#line 187
          goto while_break___0;
        }
#line 189
        tem = *(argv + (bottom + i));
#line 190
        *(argv + (bottom + i)) = *(argv + ((top___0 - (middle - bottom)) + i));
#line 191
        *(argv + ((top___0 - (middle - bottom)) + i)) = tem;
#line 187
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 195
      top___0 -= len;
    } else {
#line 200
      len___0 = top___0 - middle;
#line 204
      i___0 = 0;
      {
#line 204
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 204
        if (! (i___0 < len___0)) {
#line 204
          goto while_break___1;
        }
#line 206
        tem = *(argv + (bottom + i___0));
#line 207
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
#line 208
        *(argv + (middle + i___0)) = tem;
#line 204
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 212
      bottom += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
#line 219
  d->__last_nonopt = d->rpl_optind;
#line 220
  return;
}
}
#line 224 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt.c"
static char const   *_getopt_initialize(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                                        char const   *optstring , struct _getopt_data *d ,
                                        int posixly_correct ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 233
  tmp = d->rpl_optind;
#line 233
  d->__last_nonopt = tmp;
#line 233
  d->__first_nonopt = tmp;
#line 235
  d->__nextchar = (char *)((void *)0);
#line 237
  if (posixly_correct) {
#line 237
    tmp___1 = 1;
  } else {
    {
#line 237
    tmp___0 = getenv("POSIXLY_CORRECT");
    }
#line 237
    if (tmp___0) {
#line 237
      tmp___1 = 1;
    } else {
#line 237
      tmp___1 = 0;
    }
  }
#line 237
  d->__posixly_correct = tmp___1;
#line 241
  if ((int const   )*(optstring + 0) == 45) {
#line 243
    d->__ordering = (enum __ord )2;
#line 244
    optstring ++;
  } else
#line 246
  if ((int const   )*(optstring + 0) == 43) {
#line 248
    d->__ordering = (enum __ord )0;
#line 249
    optstring ++;
  } else
#line 251
  if (d->__posixly_correct) {
#line 252
    d->__ordering = (enum __ord )0;
  } else {
#line 254
    d->__ordering = (enum __ord )1;
  }
#line 286
  return (optstring);
}
}
#line 345 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt.c"
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) 
{ 
  int print_errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *nameend ;
  struct rpl_option  const  *p ;
  struct rpl_option  const  *pfound ;
  int exact ;
  int ambig ;
  int indfound ;
  int option_index ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char c ;
  char *tmp___18 ;
  char const   *temp ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *nameend___0 ;
  struct rpl_option  const  *p___0 ;
  struct rpl_option  const  *pfound___0 ;
  int exact___0 ;
  int ambig___0 ;
  int indfound___0 ;
  int option_index___0 ;
  char *tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;

  {
#line 350
  print_errors = d->rpl_opterr;
#line 352
  if (argc < 1) {
#line 353
    return (-1);
  }
#line 355
  d->rpl_optarg = (char *)((void *)0);
#line 357
  if (d->rpl_optind == 0) {
#line 357
    goto _L;
  } else
#line 357
  if (! d->__initialized) {
    _L: /* CIL Label */ 
#line 359
    if (d->rpl_optind == 0) {
#line 360
      d->rpl_optind = 1;
    }
    {
#line 361
    optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct);
#line 363
    d->__initialized = 1;
    }
  } else
#line 365
  if ((int const   )*(optstring + 0) == 45) {
#line 366
    optstring ++;
  } else
#line 365
  if ((int const   )*(optstring + 0) == 43) {
#line 366
    optstring ++;
  }
#line 367
  if ((int const   )*(optstring + 0) == 58) {
#line 368
    print_errors = 0;
  }
#line 382
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
#line 382
    goto _L___3;
  } else
#line 382
  if ((int )*(d->__nextchar) == 0) {
    _L___3: /* CIL Label */ 
#line 388
    if (d->__last_nonopt > d->rpl_optind) {
#line 389
      d->__last_nonopt = d->rpl_optind;
    }
#line 390
    if (d->__first_nonopt > d->rpl_optind) {
#line 391
      d->__first_nonopt = d->rpl_optind;
    }
#line 393
    if ((unsigned int )d->__ordering == 1U) {
#line 398
      if (d->__first_nonopt != d->__last_nonopt) {
#line 398
        if (d->__last_nonopt != d->rpl_optind) {
          {
#line 400
          exchange(argv, d);
          }
        } else {
#line 398
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 401
      if (d->__last_nonopt != d->rpl_optind) {
#line 402
        d->__first_nonopt = d->rpl_optind;
      }
      {
#line 407
      while (1) {
        while_continue: /* CIL Label */ ;
#line 407
        if (d->rpl_optind < argc) {
#line 407
          if (! ((int )*(*(argv + d->rpl_optind) + 0) != 45)) {
#line 407
            if (! ((int )*(*(argv + d->rpl_optind) + 1) == 0)) {
#line 407
              goto while_break;
            }
          }
        } else {
#line 407
          goto while_break;
        }
#line 408
        (d->rpl_optind) ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 409
      d->__last_nonopt = d->rpl_optind;
    }
#line 417
    if (d->rpl_optind != argc) {
      {
#line 417
      tmp = strcmp((char const   *)*(argv + d->rpl_optind), "--");
      }
#line 417
      if (! tmp) {
#line 419
        (d->rpl_optind) ++;
#line 421
        if (d->__first_nonopt != d->__last_nonopt) {
#line 421
          if (d->__last_nonopt != d->rpl_optind) {
            {
#line 423
            exchange(argv, d);
            }
          } else {
#line 421
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 424
        if (d->__first_nonopt == d->__last_nonopt) {
#line 425
          d->__first_nonopt = d->rpl_optind;
        }
#line 426
        d->__last_nonopt = argc;
#line 428
        d->rpl_optind = argc;
      }
    }
#line 434
    if (d->rpl_optind == argc) {
#line 438
      if (d->__first_nonopt != d->__last_nonopt) {
#line 439
        d->rpl_optind = d->__first_nonopt;
      }
#line 440
      return (-1);
    }
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
#line 446
      goto _L___2;
    } else
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
      _L___2: /* CIL Label */ 
#line 448
      if ((unsigned int )d->__ordering == 0U) {
#line 449
        return (-1);
      }
#line 450
      tmp___0 = d->rpl_optind;
#line 450
      (d->rpl_optind) ++;
#line 450
      d->rpl_optarg = *(argv + tmp___0);
#line 451
      return (1);
    }
#line 457
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 457
      if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 457
        tmp___1 = 1;
      } else {
#line 457
        tmp___1 = 0;
      }
    } else {
#line 457
      tmp___1 = 0;
    }
#line 457
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + tmp___1;
  }
#line 476
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 476
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 476
      goto _L___6;
    } else
#line 476
    if (long_only) {
#line 476
      if (*(*(argv + d->rpl_optind) + 2)) {
#line 476
        goto _L___6;
      } else {
        {
#line 476
        tmp___17 = strchr(optstring, (int )*(*(argv + d->rpl_optind) + 1));
        }
#line 476
        if (! tmp___17) {
          _L___6: /* CIL Label */ 
#line 483
          pfound = (struct rpl_option  const  *)((void *)0);
#line 484
          exact = 0;
#line 485
          ambig = 0;
#line 486
          indfound = -1;
#line 489
          nameend = d->__nextchar;
          {
#line 489
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 489
            if (*nameend) {
#line 489
              if (! ((int )*nameend != 61)) {
#line 489
                goto while_break___0;
              }
            } else {
#line 489
              goto while_break___0;
            }
#line 489
            nameend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 494
          p = longopts;
#line 494
          option_index = 0;
          {
#line 494
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 494
            if (! p->name) {
#line 494
              goto while_break___1;
            }
            {
#line 495
            tmp___3 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                              (size_t )(nameend - d->__nextchar));
            }
#line 495
            if (! tmp___3) {
              {
#line 497
              tmp___2 = strlen((char const   *)p->name);
              }
#line 497
              if ((unsigned int )(nameend - d->__nextchar) == tmp___2) {
#line 501
                pfound = p;
#line 502
                indfound = option_index;
#line 503
                exact = 1;
#line 504
                goto while_break___1;
              } else
#line 506
              if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 509
                pfound = p;
#line 510
                indfound = option_index;
              } else
#line 512
              if (long_only) {
#line 517
                ambig = 1;
              } else
#line 512
              if (pfound->has_arg != p->has_arg) {
#line 517
                ambig = 1;
              } else
#line 512
              if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
#line 517
                ambig = 1;
              } else
#line 512
              if (pfound->val != p->val) {
#line 517
                ambig = 1;
              }
            }
#line 494
            p ++;
#line 494
            option_index ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 520
          if (ambig) {
#line 520
            if (! exact) {
#line 522
              if (print_errors) {
                {
#line 543
                tmp___4 = gettext("%s: option \'%s\' is ambiguous\n");
#line 543
                rpl_fprintf(stderr, (char const   *)tmp___4, *(argv + 0), *(argv + d->rpl_optind));
                }
              }
              {
#line 547
              tmp___5 = strlen((char const   *)d->__nextchar);
#line 547
              d->__nextchar += tmp___5;
#line 548
              (d->rpl_optind) ++;
#line 549
              d->rpl_optopt = 0;
              }
#line 550
              return ('?');
            }
          }
#line 553
          if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 555
            option_index = indfound;
#line 556
            (d->rpl_optind) ++;
#line 557
            if (*nameend) {
#line 561
              if (pfound->has_arg) {
#line 562
                d->rpl_optarg = nameend + 1;
              } else {
#line 565
                if (print_errors) {
#line 572
                  if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
                    {
#line 580
                    tmp___6 = gettext("%s: option \'--%s\' doesn\'t allow an argument\n");
#line 580
                    rpl_fprintf(stderr, (char const   *)tmp___6, *(argv + 0), pfound->name);
                    }
                  } else {
                    {
#line 594
                    tmp___7 = gettext("%s: option \'%c%s\' doesn\'t allow an argument\n");
#line 594
                    rpl_fprintf(stderr, (char const   *)tmp___7, *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                                pfound->name);
                    }
                  }
                }
                {
#line 620
                tmp___8 = strlen((char const   *)d->__nextchar);
#line 620
                d->__nextchar += tmp___8;
#line 622
                d->rpl_optopt = (int )pfound->val;
                }
#line 623
                return ('?');
              }
            } else
#line 626
            if (pfound->has_arg == 1) {
#line 628
              if (d->rpl_optind < argc) {
#line 629
                tmp___9 = d->rpl_optind;
#line 629
                (d->rpl_optind) ++;
#line 629
                d->rpl_optarg = *(argv + tmp___9);
              } else {
#line 632
                if (print_errors) {
                  {
#line 655
                  tmp___10 = gettext("%s: option \'--%s\' requires an argument\n");
#line 655
                  rpl_fprintf(stderr, (char const   *)tmp___10, *(argv + 0), pfound->name);
                  }
                }
                {
#line 660
                tmp___11 = strlen((char const   *)d->__nextchar);
#line 660
                d->__nextchar += tmp___11;
#line 661
                d->rpl_optopt = (int )pfound->val;
                }
#line 662
                if ((int const   )*(optstring + 0) == 58) {
#line 662
                  tmp___12 = ':';
                } else {
#line 662
                  tmp___12 = '?';
                }
#line 662
                return (tmp___12);
              }
            }
            {
#line 665
            tmp___13 = strlen((char const   *)d->__nextchar);
#line 665
            d->__nextchar += tmp___13;
            }
#line 666
            if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 667
              *longind = option_index;
            }
#line 668
            if (pfound->flag) {
#line 670
              *(pfound->flag) = (int )pfound->val;
#line 671
              return (0);
            }
#line 673
            return ((int )pfound->val);
          }
#line 680
          if (! long_only) {
#line 680
            goto _L___4;
          } else
#line 680
          if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 680
            goto _L___4;
          } else {
            {
#line 680
            tmp___16 = strchr(optstring, (int )*(d->__nextchar));
            }
#line 680
            if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
              _L___4: /* CIL Label */ 
#line 683
              if (print_errors) {
#line 690
                if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
                  {
#line 697
                  tmp___14 = gettext("%s: unrecognized option \'--%s\'\n");
#line 697
                  rpl_fprintf(stderr, (char const   *)tmp___14, *(argv + 0), d->__nextchar);
                  }
                } else {
                  {
#line 708
                  tmp___15 = gettext("%s: unrecognized option \'%c%s\'\n");
#line 708
                  rpl_fprintf(stderr, (char const   *)tmp___15, *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0),
                              d->__nextchar);
                  }
                }
              }
#line 730
              d->__nextchar = (char *)"";
#line 731
              (d->rpl_optind) ++;
#line 732
              d->rpl_optopt = 0;
#line 733
              return ('?');
            }
          }
        }
      }
    }
  }
  {
#line 740
  tmp___18 = d->__nextchar;
#line 740
  (d->__nextchar) ++;
#line 740
  c = *tmp___18;
#line 741
  tmp___19 = strchr(optstring, (int )c);
#line 741
  temp = (char const   *)tmp___19;
  }
#line 744
  if ((int )*(d->__nextchar) == 0) {
#line 745
    (d->rpl_optind) ++;
  }
#line 747
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 747
    goto _L___7;
  } else
#line 747
  if ((int )c == 58) {
#line 747
    goto _L___7;
  } else
#line 747
  if ((int )c == 59) {
    _L___7: /* CIL Label */ 
#line 749
    if (print_errors) {
      {
#line 760
      tmp___20 = gettext("%s: invalid option -- \'%c\'\n");
#line 760
      rpl_fprintf(stderr, (char const   *)tmp___20, *(argv + 0), (int )c);
      }
    }
#line 780
    d->rpl_optopt = (int )c;
#line 781
    return ('?');
  }
#line 784
  if ((int const   )*(temp + 0) == 87) {
#line 784
    if ((int const   )*(temp + 1) == 59) {
#line 788
      pfound___0 = (struct rpl_option  const  *)((void *)0);
#line 789
      exact___0 = 0;
#line 790
      ambig___0 = 0;
#line 791
      indfound___0 = 0;
#line 795
      if ((int )*(d->__nextchar) != 0) {
#line 797
        d->rpl_optarg = d->__nextchar;
#line 800
        (d->rpl_optind) ++;
      } else
#line 802
      if (d->rpl_optind == argc) {
#line 804
        if (print_errors) {
          {
#line 826
          tmp___21 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 826
          rpl_fprintf(stderr, (char const   *)tmp___21, *(argv + 0), (int )c);
          }
        }
#line 831
        d->rpl_optopt = (int )c;
#line 832
        if ((int const   )*(optstring + 0) == 58) {
#line 833
          c = (char )':';
        } else {
#line 835
          c = (char )'?';
        }
#line 836
        return ((int )c);
      } else {
#line 841
        tmp___22 = d->rpl_optind;
#line 841
        (d->rpl_optind) ++;
#line 841
        d->rpl_optarg = *(argv + tmp___22);
      }
#line 846
      nameend___0 = d->rpl_optarg;
#line 846
      d->__nextchar = nameend___0;
      {
#line 846
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 846
        if (*nameend___0) {
#line 846
          if (! ((int )*nameend___0 != 61)) {
#line 846
            goto while_break___2;
          }
        } else {
#line 846
          goto while_break___2;
        }
#line 846
        nameend___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 852
      p___0 = longopts;
#line 852
      option_index___0 = 0;
      {
#line 852
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 852
        if (! p___0->name) {
#line 852
          goto while_break___3;
        }
        {
#line 853
        tmp___24 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                           (size_t )(nameend___0 - d->__nextchar));
        }
#line 853
        if (! tmp___24) {
          {
#line 855
          tmp___23 = strlen((char const   *)p___0->name);
          }
#line 855
          if ((unsigned int )(nameend___0 - d->__nextchar) == tmp___23) {
#line 858
            pfound___0 = p___0;
#line 859
            indfound___0 = option_index___0;
#line 860
            exact___0 = 1;
#line 861
            goto while_break___3;
          } else
#line 863
          if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
#line 866
            pfound___0 = p___0;
#line 867
            indfound___0 = option_index___0;
          } else
#line 869
          if (long_only) {
#line 874
            ambig___0 = 1;
          } else
#line 869
          if (pfound___0->has_arg != p___0->has_arg) {
#line 874
            ambig___0 = 1;
          } else
#line 869
          if ((unsigned long )pfound___0->flag != (unsigned long )p___0->flag) {
#line 874
            ambig___0 = 1;
          } else
#line 869
          if (pfound___0->val != p___0->val) {
#line 874
            ambig___0 = 1;
          }
        }
#line 852
        p___0 ++;
#line 852
        option_index___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 876
      if (ambig___0) {
#line 876
        if (! exact___0) {
#line 878
          if (print_errors) {
            {
#line 899
            tmp___25 = gettext("%s: option \'-W %s\' is ambiguous\n");
#line 899
            rpl_fprintf(stderr, (char const   *)tmp___25, *(argv + 0), d->rpl_optarg);
            }
          }
          {
#line 903
          tmp___26 = strlen((char const   *)d->__nextchar);
#line 903
          d->__nextchar += tmp___26;
#line 904
          (d->rpl_optind) ++;
          }
#line 905
          return ('?');
        }
      }
#line 907
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
#line 909
        option_index___0 = indfound___0;
#line 910
        if (*nameend___0) {
#line 914
          if (pfound___0->has_arg) {
#line 915
            d->rpl_optarg = nameend___0 + 1;
          } else {
#line 918
            if (print_errors) {
              {
#line 941
              tmp___27 = gettext("%s: option \'-W %s\' doesn\'t allow an argument\n");
#line 941
              rpl_fprintf(stderr, (char const   *)tmp___27, *(argv + 0), pfound___0->name);
              }
            }
            {
#line 947
            tmp___28 = strlen((char const   *)d->__nextchar);
#line 947
            d->__nextchar += tmp___28;
            }
#line 948
            return ('?');
          }
        } else
#line 951
        if (pfound___0->has_arg == 1) {
#line 953
          if (d->rpl_optind < argc) {
#line 954
            tmp___29 = d->rpl_optind;
#line 954
            (d->rpl_optind) ++;
#line 954
            d->rpl_optarg = *(argv + tmp___29);
          } else {
#line 957
            if (print_errors) {
              {
#line 980
              tmp___30 = gettext("%s: option \'-W %s\' requires an argument\n");
#line 980
              rpl_fprintf(stderr, (char const   *)tmp___30, *(argv + 0), pfound___0->name);
              }
            }
            {
#line 985
            tmp___31 = strlen((char const   *)d->__nextchar);
#line 985
            d->__nextchar += tmp___31;
            }
#line 986
            if ((int const   )*(optstring + 0) == 58) {
#line 986
              tmp___32 = ':';
            } else {
#line 986
              tmp___32 = '?';
            }
#line 986
            return (tmp___32);
          }
        } else {
#line 990
          d->rpl_optarg = (char *)((void *)0);
        }
        {
#line 991
        tmp___33 = strlen((char const   *)d->__nextchar);
#line 991
        d->__nextchar += tmp___33;
        }
#line 992
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 993
          *longind = option_index___0;
        }
#line 994
        if (pfound___0->flag) {
#line 996
          *(pfound___0->flag) = (int )pfound___0->val;
#line 997
          return (0);
        }
#line 999
        return ((int )pfound___0->val);
      }
#line 1001
      d->__nextchar = (char *)((void *)0);
#line 1002
      return ('W');
    }
  }
#line 1004
  if ((int const   )*(temp + 1) == 58) {
#line 1006
    if ((int const   )*(temp + 2) == 58) {
#line 1009
      if ((int )*(d->__nextchar) != 0) {
#line 1011
        d->rpl_optarg = d->__nextchar;
#line 1012
        (d->rpl_optind) ++;
      } else {
#line 1015
        d->rpl_optarg = (char *)((void *)0);
      }
#line 1016
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1021
      if ((int )*(d->__nextchar) != 0) {
#line 1023
        d->rpl_optarg = d->__nextchar;
#line 1026
        (d->rpl_optind) ++;
      } else
#line 1028
      if (d->rpl_optind == argc) {
#line 1030
        if (print_errors) {
          {
#line 1052
          tmp___34 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 1052
          rpl_fprintf(stderr, (char const   *)tmp___34, *(argv + 0), (int )c);
          }
        }
#line 1057
        d->rpl_optopt = (int )c;
#line 1058
        if ((int const   )*(optstring + 0) == 58) {
#line 1059
          c = (char )':';
        } else {
#line 1061
          c = (char )'?';
        }
      } else {
#line 1066
        tmp___35 = d->rpl_optind;
#line 1066
        (d->rpl_optind) ++;
#line 1066
        d->rpl_optarg = *(argv + tmp___35);
      }
#line 1067
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1070
  return ((int )c);
}
}
#line 1074 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt.c"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) 
{ 
  int result ;

  {
  {
#line 1081
  getopt_data.rpl_optind = rpl_optind;
#line 1082
  getopt_data.rpl_opterr = rpl_opterr;
#line 1084
  result = _getopt_internal_r(argc, argv, optstring, longopts, longind, long_only,
                              & getopt_data, posixly_correct);
#line 1088
  rpl_optind = getopt_data.rpl_optind;
#line 1089
  rpl_optarg = getopt_data.rpl_optarg;
#line 1090
  rpl_optopt = getopt_data.rpl_optopt;
  }
#line 1092
  return (result);
}
}
#line 1103
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc ,
                                                                                  char * const  *argv ,
                                                                                  char const   *optstring ) ;
#line 1103 "/home/pronto/abs/test-suite/bison-2.5/lib/getopt.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc , char * const  *argv ,
                                                    char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 1106
  tmp = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option  const  *)0,
                            (int *)0, 0, 1);
  }
#line 1106
  return (tmp);
}
}
#line 18 "/home/pronto/abs/test-suite/bison-2.5/lib/get-errno.h"
int get_errno(void) ;
#line 19
void set_errno(int e ) ;
#line 32 "/home/pronto/abs/test-suite/bison-2.5/lib/get-errno.c"
int get_errno(void) 
{ 
  int *tmp ;

  {
  {
#line 35
  tmp = __errno_location();
  }
#line 35
  return (*tmp);
}
}
#line 38 "/home/pronto/abs/test-suite/bison-2.5/lib/get-errno.c"
void set_errno(int e ) 
{ 
  int *tmp ;

  {
  {
#line 41
  tmp = __errno_location();
#line 41
  *tmp = e;
  }
#line 42
  return;
}
}
#line 26 "/home/pronto/abs/test-suite/bison-2.5/lib/fseterr.c"
void fseterr(FILE *fp ) 
{ 


  {
#line 33
  fp->_flags |= 32;
#line 74
  return;
}
}
#line 37 "/home/pronto/abs/test-suite/bison-2.5/lib/fprintf.c"
int ( /* format attribute */ __attribute__((__nonnull__(1,2))) rpl_fprintf)(FILE *fp ,
                                                                            char const   *format 
                                                                            , ...) 
{ 
  char buf___0[2000] ;
  char *output___0 ;
  size_t len ;
  size_t lenbuf ;
  va_list args ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  void *__cil_tmp13 ;

  {
  {
#line 43
  lenbuf = (size_t )sizeof(buf___0);
#line 46
  __builtin_va_start(args, format);
#line 47
  output___0 = vasnprintf(buf___0, & lenbuf, format, args);
#line 48
  len = lenbuf;
#line 49
  __builtin_va_end(args);
  }
#line 51
  if (! output___0) {
    {
#line 53
    fseterr(fp);
    }
#line 54
    return (-1);
  }
  {
#line 57
  tmp___1 = fwrite((void const   */* __restrict  */)output___0, (size_t )1, len, (FILE */* __restrict  */)fp);
  }
#line 57
  if (tmp___1 < len) {
#line 59
    if ((unsigned long )output___0 != (unsigned long )(buf___0)) {
      {
#line 61
      tmp = __errno_location();
#line 61
      saved_errno = *tmp;
#line 62
      free((void *)output___0);
#line 63
      tmp___0 = __errno_location();
#line 63
      *tmp___0 = saved_errno;
      }
    }
#line 65
    return (-1);
  }
#line 68
  if ((unsigned long )output___0 != (unsigned long )(buf___0)) {
    {
#line 69
    free((void *)output___0);
    }
  }
#line 71
  if (len > 2147483647U) {
    {
#line 73
    tmp___2 = __errno_location();
#line 73
    *tmp___2 = 75;
#line 74
    fseterr(fp);
    }
#line 75
    return (-1);
  }
#line 78
  return ((int )len);
}
}
#line 249 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 23 "/home/pronto/abs/test-suite/bison-2.5/lib/stdio-safer.h"
FILE *fopen_safer(char const   *file , char const   *mode ) ;
#line 20 "/home/pronto/abs/test-suite/bison-2.5/lib/unistd-safer.h"
int dup_safer(int fd ) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/lib/fopen-safer.c"
FILE *fopen_safer(char const   *file , char const   *mode ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  int fd ;
  int tmp___0 ;
  int f ;
  int tmp___1 ;
  int e ;
  int *tmp___2 ;
  int *tmp___3 ;
  int e___0 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 33
  tmp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)mode);
#line 33
  fp = tmp;
  }
#line 35
  if (fp) {
    {
#line 37
    tmp___0 = fileno(fp);
#line 37
    fd = tmp___0;
    }
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
        {
#line 41
        tmp___1 = dup_safer(fd);
#line 41
        f = tmp___1;
        }
#line 43
        if (f < 0) {
          {
#line 45
          tmp___2 = __errno_location();
#line 45
          e = *tmp___2;
#line 46
          fclose(fp);
#line 47
          tmp___3 = __errno_location();
#line 47
          *tmp___3 = e;
          }
#line 48
          return ((FILE *)((void *)0));
        }
        {
#line 51
        tmp___6 = fclose(fp);
        }
#line 51
        if (tmp___6 != 0) {
#line 51
          goto _L;
        } else {
          {
#line 51
          fp = fdopen(f, mode);
          }
#line 51
          if (! fp) {
            _L: /* CIL Label */ 
            {
#line 54
            tmp___4 = __errno_location();
#line 54
            e___0 = *tmp___4;
#line 55
            close(f);
#line 56
            tmp___5 = __errno_location();
#line 56
            *tmp___5 = e___0;
            }
#line 57
            return ((FILE *)((void *)0));
          }
        }
      }
    }
  }
#line 62
  return (fp);
}
}
#line 36 "/home/pronto/abs/test-suite/bison-2.5/lib/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 39
  if (0 <= fd) {
#line 39
    if (fd <= 2) {
      {
#line 41
      tmp = dup_safer(fd);
#line 41
      f = tmp;
#line 42
      tmp___0 = __errno_location();
#line 42
      e = *tmp___0;
#line 43
      close(fd);
#line 44
      tmp___1 = __errno_location();
#line 44
      *tmp___1 = e;
#line 45
      fd = f;
      }
    }
  }
#line 48
  return (fd);
}
}
#line 25 "/home/pronto/abs/test-suite/bison-2.5/lib/unistd-safer.h"
int dup_safer_flag(int fd , int flag ) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/lib/fd-safer-flag.c"
int fd_safer_flag(int fd , int flag ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 42
  if (0 <= fd) {
#line 42
    if (fd <= 2) {
      {
#line 44
      tmp = dup_safer_flag(fd, flag);
#line 44
      f = tmp;
#line 45
      tmp___0 = __errno_location();
#line 45
      e = *tmp___0;
#line 46
      close(fd);
#line 47
      tmp___1 = __errno_location();
#line 47
      *tmp___1 = e;
#line 48
      fd = f;
      }
    }
  }
#line 51
  return (fd);
}
}
#line 229 "/home/pronto/abs/test-suite/bison-2.5/lib/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 165 "/home/pronto/abs/test-suite/bison-2.5/lib/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list arg ;
  int result ;
  int target ;
  int tmp___0 ;
  int *tmp___1 ;
  int flags ;
  int tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *p ;
  void *tmp___7 ;

  {
  {
#line 169
  result = -1;
#line 170
  __builtin_va_start(arg, action);
  }
  {
#line 214
  if (action == 1030) {
#line 214
    goto case_1030;
  }
#line 295
  goto switch_default;
  case_1030: /* CIL Label */ 
  {
#line 216
  tmp___0 = __builtin_va_arg(arg, int );
#line 216
  target = tmp___0;
  }
#line 230
  if (0 <= have_dupfd_cloexec) {
    {
#line 232
    result = fcntl(fd, action, target);
    }
#line 233
    if (0 <= result) {
#line 235
      have_dupfd_cloexec = 1;
    } else {
      {
#line 233
      tmp___1 = __errno_location();
      }
#line 233
      if (*tmp___1 != 22) {
#line 235
        have_dupfd_cloexec = 1;
      } else {
        {
#line 243
        result = rpl_fcntl(fd, 0, target);
        }
#line 244
        if (result < 0) {
#line 245
          goto switch_break;
        }
#line 246
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    {
#line 250
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 251
  if (0 <= result) {
#line 251
    if (have_dupfd_cloexec == -1) {
      {
#line 253
      tmp___2 = fcntl(result, 1);
#line 253
      flags = tmp___2;
      }
#line 254
      if (flags < 0) {
#line 254
        goto _L;
      } else {
        {
#line 254
        tmp___5 = fcntl(result, 2, flags | 1);
        }
#line 254
        if (tmp___5 == -1) {
          _L: /* CIL Label */ 
          {
#line 256
          tmp___3 = __errno_location();
#line 256
          saved_errno = *tmp___3;
#line 257
          close(result);
#line 258
          tmp___4 = __errno_location();
#line 258
          *tmp___4 = saved_errno;
#line 259
          result = -1;
          }
        }
      }
    }
  }
#line 262
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 298
  tmp___7 = __builtin_va_arg(arg, void *);
#line 298
  p = tmp___7;
#line 299
  result = fcntl(fd, action, p);
  }
#line 303
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 306
  __builtin_va_end(arg);
  }
#line 307
  return (result);
}
}
#line 138 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 222
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 228
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 266
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.5/lib/sig-handler.h"
__inline static sa_handler_t get_handler(struct sigaction  const  *a ) 
{ 


  {
#line 38
  if (a->sa_flags & 4) {
#line 39
    return ((void (*)(int  ))a->__sigaction_handler.sa_sigaction);
  }
#line 41
  return ((sa_handler_t )a->__sigaction_handler.sa_handler);
}
}
#line 127 "/home/pronto/abs/test-suite/bison-2.5/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 51 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static int fatal_signals[7]  = {      2,      15,      1,      13, 
        24,      25,      0};
#line 88
static void init_fatal_signals(void) ;
#line 88 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static _Bool fatal_signals_initialized  =    (_Bool)0;
#line 85 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static void init_fatal_signals(void) 
{ 
  size_t i ;
  struct sigaction action ;
  int tmp ;
  sa_handler_t tmp___0 ;

  {
#line 89
  if (! fatal_signals_initialized) {
#line 93
    i = (size_t )0;
    {
#line 93
    while (1) {
      while_continue: /* CIL Label */ ;
#line 93
      if (! ((unsigned long )i < sizeof(fatal_signals) / sizeof(fatal_signals[0]) - 1UL)) {
#line 93
        goto while_break;
      }
      {
#line 97
      tmp = sigaction(fatal_signals[i], (struct sigaction  const  */* __restrict  */)((void *)0),
                      (struct sigaction */* __restrict  */)(& action));
      }
#line 97
      if (tmp >= 0) {
        {
#line 97
        tmp___0 = get_handler((struct sigaction  const  *)(& action));
        }
#line 97
        if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
#line 99
          fatal_signals[i] = -1;
        }
      }
#line 93
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 102
    fatal_signals_initialized = (_Bool)1;
  }
#line 104
  return;
}
}
#line 122 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static actions_entry_t static_actions[32]  ;
#line 123 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static actions_entry_t * volatile  actions  =    (actions_entry_t */* volatile  */)(static_actions);
#line 124 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static int volatile   actions_count  =    (sig_atomic_t volatile   )0;
#line 125 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static size_t actions_allocated  =    (size_t )(sizeof(static_actions) / sizeof(static_actions[0]));
#line 130 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static struct sigaction saved_sigactions[64]  ;
#line 134 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
__inline static void uninstall_handlers(void) 
{ 
  size_t i ;
  int sig ;

  {
#line 139
  i = (size_t )0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )i < sizeof(fatal_signals) / sizeof(fatal_signals[0]) - 1UL)) {
#line 139
      goto while_break;
    }
#line 140
    if (fatal_signals[i] >= 0) {
#line 142
      sig = fatal_signals[i];
#line 143
      if ((unsigned long )saved_sigactions[sig].__sigaction_handler.sa_handler == (unsigned long )((void (*)(int  ))1)) {
#line 144
        saved_sigactions[sig].__sigaction_handler.sa_handler = (void (*)(int  ))0;
      }
      {
#line 145
      sigaction(sig, (struct sigaction  const  */* __restrict  */)(& saved_sigactions[sig]),
                (struct sigaction */* __restrict  */)((void *)0));
      }
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 151 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static void fatal_signal_handler(int sig ) 
{ 
  void (*action)(void) ;
  size_t n ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    n = (size_t )actions_count;
#line 159
    if (n == 0U) {
#line 160
      goto while_break;
    }
    {
#line 161
    n --;
#line 162
    actions_count = (int volatile   )n;
#line 163
    action = (void (*)(void))(actions + n)->action;
#line 165
    (*action)();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  uninstall_handlers();
#line 174
  raise(sig);
  }
#line 175
  return;
}
}
#line 179 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
__inline static void install_handlers(void) 
{ 
  size_t i ;
  struct sigaction action ;
  int sig ;

  {
  {
#line 185
  action.__sigaction_handler.sa_handler = & fatal_signal_handler;
#line 189
  action.sa_flags = 1073741824;
#line 190
  sigemptyset(& action.sa_mask);
#line 191
  i = (size_t )0;
  }
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )i < sizeof(fatal_signals) / sizeof(fatal_signals[0]) - 1UL)) {
#line 191
      goto while_break;
    }
#line 192
    if (fatal_signals[i] >= 0) {
#line 194
      sig = fatal_signals[i];
#line 196
      if (! ((unsigned long )sig < sizeof(saved_sigactions) / sizeof(saved_sigactions[0]))) {
        {
#line 197
        abort();
        }
      }
      {
#line 198
      sigaction(sig, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)(& saved_sigactions[sig]));
      }
    }
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return;
}
}
#line 208 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static _Bool cleanup_initialized  =    (_Bool)0;
#line 205 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
void at_fatal_signal(void (*action)(void) ) 
{ 
  actions_entry_t *old_actions ;
  size_t old_actions_allocated ;
  size_t new_actions_allocated ;
  actions_entry_t *new_actions ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t k ;

  {
#line 209
  if (! cleanup_initialized) {
    {
#line 211
    init_fatal_signals();
#line 212
    install_handlers();
#line 213
    cleanup_initialized = (_Bool)1;
    }
  }
#line 216
  if ((size_t )actions_count == actions_allocated) {
#line 221
    old_actions = (actions_entry_t *)actions;
#line 222
    old_actions_allocated = actions_allocated;
#line 223
    new_actions_allocated = 2U * actions_allocated;
#line 224
    if (sizeof(actions_entry_t ) == 1UL) {
      {
#line 224
      tmp = xmalloc(new_actions_allocated);
#line 224
      tmp___1 = tmp;
      }
    } else {
      {
#line 224
      tmp___0 = xnmalloc(new_actions_allocated, (size_t )sizeof(actions_entry_t ));
#line 224
      tmp___1 = tmp___0;
      }
    }
#line 224
    new_actions = (actions_entry_t *)tmp___1;
#line 231
    k = (size_t )0;
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 231
      if (! (k < old_actions_allocated)) {
#line 231
        goto while_break;
      }
#line 232
      *(new_actions + k) = *(old_actions + k);
#line 231
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 233
    actions = (actions_entry_t */* volatile  */)new_actions;
#line 234
    actions_allocated = new_actions_allocated;
#line 236
    if ((unsigned long )old_actions != (unsigned long )(static_actions)) {
      {
#line 237
      free((void *)old_actions);
      }
    }
  }
#line 243
  (actions + actions_count)->action = (void (*/* volatile  */)(void))action;
#line 244
  actions_count += (int volatile   )1;
#line 245
  return;
}
}
#line 251 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static sigset_t fatal_signal_set  ;
#line 256
static void init_fatal_signal_set(void) ;
#line 256 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static _Bool fatal_signal_set_initialized  =    (_Bool)0;
#line 253 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
static void init_fatal_signal_set(void) 
{ 
  size_t i ;

  {
#line 257
  if (! fatal_signal_set_initialized) {
    {
#line 261
    init_fatal_signals();
#line 263
    sigemptyset(& fatal_signal_set);
#line 264
    i = (size_t )0;
    }
    {
#line 264
    while (1) {
      while_continue: /* CIL Label */ ;
#line 264
      if (! ((unsigned long )i < sizeof(fatal_signals) / sizeof(fatal_signals[0]) - 1UL)) {
#line 264
        goto while_break;
      }
#line 265
      if (fatal_signals[i] >= 0) {
        {
#line 266
        sigaddset(& fatal_signal_set, fatal_signals[i]);
        }
      }
#line 264
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 268
    fatal_signal_set_initialized = (_Bool)1;
  }
#line 270
  return;
}
}
#line 273 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
void block_fatal_signals(void) 
{ 


  {
  {
#line 276
  init_fatal_signal_set();
#line 277
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& fatal_signal_set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 278
  return;
}
}
#line 281 "/home/pronto/abs/test-suite/bison-2.5/lib/fatal-signal.c"
void unblock_fatal_signals(void) 
{ 


  {
  {
#line 284
  init_fatal_signal_set();
#line 285
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& fatal_signal_set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 286
  return;
}
}
#line 24 "/home/pronto/abs/test-suite/bison-2.5/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.h"
size_t ebitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) ;
#line 27
bitset ebitset_init(bitset bset , bitset_bindex n_bits ) ;
#line 29
void ebitset_release_memory(void) ;
#line 82 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static ebitset_elt ebitset_zero_elts[1]  ;
#line 85 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static struct obstack ebitset_obstack  ;
#line 86 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_obstack_init  =    (_Bool)0;
#line 87 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static ebitset_elt *ebitset_free_list  ;
#line 122 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static bitset_bindex ebitset_resize(bitset src , bitset_bindex n_bits ) 
{ 
  bitset_windex oldsize ;
  bitset_windex newsize ;
  bitset_windex size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 128
  if (n_bits == src->b.n_bits) {
#line 129
    return (n_bits);
  }
#line 131
  oldsize = ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 132
  newsize = ((n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 134
  if (oldsize < newsize) {
#line 140
    if (newsize > src->e.size) {
#line 147
      if (oldsize == 0U) {
#line 148
        size = newsize;
      } else {
#line 150
        size = newsize + newsize / 4U;
      }
      {
#line 152
      tmp = realloc((void *)src->e.elts, (size_t )((unsigned long )size * sizeof(ebitset_elt *)));
#line 152
      src->e.elts = (struct ebitset_elt_struct **)tmp;
#line 154
      src->e.size = size;
      }
    }
    {
#line 157
    memset((void *)(src->e.elts + oldsize), 0, (size_t )((unsigned long )(newsize - oldsize) * sizeof(ebitset_elt *)));
    }
  } else
#line 164
  if (oldsize - newsize >= oldsize / 2U) {
    {
#line 166
    tmp___0 = realloc((void *)src->e.elts, (size_t )((unsigned long )newsize * sizeof(ebitset_elt *)));
#line 166
    src->e.elts = (struct ebitset_elt_struct **)tmp___0;
#line 168
    src->e.size = newsize;
    }
  }
#line 174
  src->b.n_bits = n_bits;
#line 175
  return (n_bits);
}
}
#line 180 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static ebitset_elt *ebitset_elt_alloc(void) 
{ 
  ebitset_elt *elt ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 185
  if ((unsigned long )ebitset_free_list != (unsigned long )((ebitset_elt *)0)) {
#line 187
    elt = ebitset_free_list;
#line 188
    ebitset_free_list = elt->u.next;
  } else {
#line 192
    if (! ebitset_obstack_init) {
      {
#line 194
      ebitset_obstack_init = (_Bool)1;
#line 216
      _obstack_begin(& ebitset_obstack, 0, (int )__alignof__(ebitset_elt ), (void *(*)(long  ))(& xmalloc),
                     & free);
      }
    }
#line 224
    __h = & ebitset_obstack;
#line 224
    __o = __h;
#line 224
    __len = (int )sizeof(ebitset_elt );
#line 224
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
#line 224
      _obstack_newchunk(__o, __len);
      }
    }
#line 224
    __o->next_free += __len;
#line 224
    __o1 = __h;
#line 224
    __value = (void *)__o1->object_base;
#line 224
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 224
      __o1->maybe_empty_object = 1U;
    }
#line 224
    if (sizeof(int ) < sizeof(void *)) {
#line 224
      tmp = __o1->object_base;
    } else {
#line 224
      tmp = (char *)0;
    }
#line 224
    if (sizeof(int ) < sizeof(void *)) {
#line 224
      tmp___0 = __o1->object_base;
    } else {
#line 224
      tmp___0 = (char *)0;
    }
#line 224
    __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 224
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 224
      __o1->next_free = __o1->chunk_limit;
    }
#line 224
    __o1->object_base = __o1->next_free;
#line 224
    elt = (ebitset_elt *)__value;
  }
#line 228
  return (elt);
}
}
#line 233 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static ebitset_elt *ebitset_elt_calloc(void) 
{ 
  ebitset_elt *elt ;

  {
  {
#line 238
  elt = ebitset_elt_alloc();
#line 239
  memset((void *)(elt->u.words), 0, (size_t )sizeof(elt->u.words));
  }
#line 240
  return (elt);
}
}
#line 244 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static void ebitset_elt_free(ebitset_elt *elt ) 
{ 


  {
#line 247
  elt->u.next = ebitset_free_list;
#line 248
  ebitset_free_list = elt;
#line 249
  return;
}
}
#line 253 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static void ebitset_elt_remove(bitset bset , bitset_windex eindex ) 
{ 
  ebitset_elts *elts ;
  ebitset_elt *elt ;

  {
  {
#line 259
  elts = bset->e.elts;
#line 261
  elt = *(elts + eindex);
#line 263
  *(elts + eindex) = (ebitset_elts )0;
#line 264
  ebitset_elt_free(elt);
  }
#line 265
  return;
}
}
#line 269 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static void ebitset_elt_add(bitset bset , ebitset_elt *elt , bitset_windex eindex ) 
{ 
  ebitset_elts *elts ;

  {
#line 274
  elts = bset->e.elts;
#line 276
  *(elts + eindex) = elt;
#line 277
  return;
}
}
#line 281 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static _Bool ebitset_elt_zero_p(ebitset_elt *elt ) 
{ 
  int i ;

  {
#line 286
  i = 0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (i < 2)) {
#line 286
      goto while_break;
    }
#line 287
    if (elt->u.words[i]) {
#line 288
      return ((_Bool)0);
    }
#line 286
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((_Bool)1);
}
}
#line 294 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static ebitset_elt *ebitset_elt_find(bitset bset , bitset_bindex bindex , enum ebitset_find_mode mode ) 
{ 
  ebitset_elt *elt ;
  bitset_windex size ;
  bitset_windex eindex ;
  ebitset_elts *elts ;

  {
#line 303
  eindex = bindex / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 305
  elts = bset->e.elts;
#line 306
  size = ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 308
  if (eindex < size) {
#line 310
    elt = *(elts + eindex);
#line 310
    if (elt) {
#line 312
      if ((unsigned long )(elt->u.words) == (unsigned long )bset->b.cdata) {
#line 313
        return (elt);
      }
#line 315
      bset->b.cindex = eindex * 2U;
#line 315
      bset->b.cdata = (*(bset->e.elts + eindex))->u.words;
#line 316
      return (elt);
    }
  }
  {
#line 327
  if ((unsigned int )mode == 0U) {
#line 327
    goto case_0;
  }
#line 330
  if ((unsigned int )mode == 1U) {
#line 330
    goto case_1;
  }
#line 340
  if ((unsigned int )mode == 2U) {
#line 340
    goto case_2;
  }
#line 324
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 325
  abort();
  }
  case_0: /* CIL Label */ 
#line 328
  return ((ebitset_elt *)0);
  case_1: /* CIL Label */ 
#line 331
  if (eindex >= size) {
    {
#line 332
    ebitset_resize(bset, bindex);
    }
  }
  {
#line 335
  elt = ebitset_elt_calloc();
#line 336
  ebitset_elt_add(bset, elt, eindex);
#line 337
  bset->b.cindex = eindex * 2U;
#line 337
  bset->b.cdata = (*(bset->e.elts + eindex))->u.words;
  }
#line 338
  return (elt);
  case_2: /* CIL Label */ 
#line 341
  return (& ebitset_zero_elts[0]);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 347 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static bitset_windex ebitset_weed(bitset bset ) 
{ 
  ebitset_elts *elts ;
  bitset_windex j ;
  bitset_windex count ;
  ebitset_elt *elt ;
  _Bool tmp ;

  {
#line 354
  if ((unsigned long )bset->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 355
    return ((bitset_windex )0);
  }
#line 357
  elts = bset->e.elts;
#line 358
  count = (bitset_windex )0;
#line 359
  j = (bitset_windex )0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (j < ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 359
      goto while_break;
    }
#line 361
    elt = *(elts + j);
#line 363
    if (elt) {
      {
#line 365
      tmp = ebitset_elt_zero_p(elt);
      }
#line 365
      if (tmp) {
        {
#line 367
        ebitset_elt_remove(bset, j);
#line 368
        count ++;
        }
      }
    } else {
#line 372
      count ++;
    }
#line 359
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  count = j - count;
#line 376
  if (! count) {
#line 380
    bset->b.cindex = 4294967295U >> 1;
#line 380
    bset->b.cdata = (bitset_word *)0;
  } else {
#line 383
    bset->b.cindex = 4294967295U >> 1;
#line 383
    bset->b.cdata = (bitset_word *)(~ 0);
  }
#line 385
  return (count);
}
}
#line 390 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static void ebitset_zero(bitset bset ) 
{ 
  ebitset_elts *elts ;
  bitset_windex j ;
  ebitset_elt *elt ;

  {
#line 396
  if ((unsigned long )bset->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 397
    return;
  }
#line 399
  elts = bset->e.elts;
#line 400
  j = (bitset_windex )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (j < ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 400
      goto while_break;
    }
#line 402
    elt = *(elts + j);
#line 404
    if (elt) {
      {
#line 405
      ebitset_elt_remove(bset, j);
      }
    }
#line 400
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  bset->b.cindex = 4294967295U >> 1;
#line 410
  bset->b.cdata = (bitset_word *)0;
#line 411
  return;
}
}
#line 414 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static _Bool ebitset_equal_p(bitset dst , bitset src ) 
{ 
  ebitset_elts *selts ;
  ebitset_elts *delts ;
  bitset_windex j ;
  unsigned int i ;
  ebitset_elt *selt ;
  ebitset_elt *delt ;

  {
#line 421
  if ((unsigned long )src == (unsigned long )dst) {
#line 422
    return ((_Bool)1);
  }
  {
#line 424
  ebitset_weed(dst);
#line 425
  ebitset_weed(src);
  }
#line 427
  if (((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))) != ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )))) {
#line 428
    return ((_Bool)0);
  }
#line 430
  selts = src->e.elts;
#line 431
  delts = dst->e.elts;
#line 433
  j = (bitset_windex )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! (j < ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 433
      goto while_break;
    }
#line 436
    selt = *(selts + j);
#line 437
    delt = *(delts + j);
#line 439
    if (! selt) {
#line 439
      if (! delt) {
#line 440
        goto __Cont;
      }
    }
#line 441
    if (selt) {
#line 441
      if (! delt) {
#line 442
        return ((_Bool)0);
      } else {
#line 441
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 441
    if (! selt) {
#line 441
      if (delt) {
#line 442
        return ((_Bool)0);
      }
    }
#line 444
    i = 0U;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! (i < 2U)) {
#line 444
        goto while_break___0;
      }
#line 445
      if (selt->u.words[i] != delt->u.words[i]) {
#line 446
        return ((_Bool)0);
      }
#line 444
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 433
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  return ((_Bool)1);
}
}
#line 453 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static void ebitset_copy_(bitset dst , bitset src ) 
{ 
  ebitset_elts *selts ;
  ebitset_elts *delts ;
  bitset_windex j ;
  ebitset_elt *selt ;
  ebitset_elt *tmp ;

  {
#line 460
  if ((unsigned long )src == (unsigned long )dst) {
#line 461
    return;
  }
  {
#line 463
  ebitset_zero(dst);
  }
#line 465
  if (dst->b.n_bits != src->b.n_bits) {
    {
#line 466
    ebitset_resize(dst, src->b.n_bits);
    }
  }
#line 468
  selts = src->e.elts;
#line 469
  delts = dst->e.elts;
#line 470
  j = (bitset_windex )0;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! (j < ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 470
      goto while_break;
    }
#line 472
    selt = *(selts + j);
#line 474
    if (selt) {
      {
#line 478
      tmp = ebitset_elt_alloc();
#line 479
      *(delts + j) = tmp;
#line 480
      memcpy((void */* __restrict  */)(tmp->u.words), (void const   */* __restrict  */)(selt->u.words),
             (size_t )sizeof(selt->u.words));
      }
    }
#line 470
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  dst->b.cindex = 4294967295U >> 1;
#line 484
  dst->b.cdata = (bitset_word *)(~ 0);
#line 485
  return;
}
}
#line 490 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static _Bool ebitset_copy_cmp(bitset dst , bitset src ) 
{ 
  _Bool tmp ;

  {
#line 493
  if ((unsigned long )src == (unsigned long )dst) {
#line 494
    return ((_Bool)0);
  }
#line 496
  if ((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 498
    ebitset_copy_(dst, src);
    }
#line 499
    return ((_Bool )(! ((unsigned long )src->b.cdata == (unsigned long )((bitset_word *)0))));
  }
  {
#line 502
  tmp = ebitset_equal_p(dst, src);
  }
#line 502
  if (tmp) {
#line 503
    return ((_Bool)0);
  }
  {
#line 505
  ebitset_copy_(dst, src);
  }
#line 506
  return ((_Bool)1);
}
}
#line 511 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_set(bitset dst , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;

  {
  {
#line 514
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 516
  ebitset_elt_find(dst, bitno, (enum ebitset_find_mode )1);
#line 518
  *(dst->b.cdata + (windex - dst->b.cindex)) |= 1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word ));
  }
#line 520
  return;
}
}
#line 524 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_reset(bitset dst , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  ebitset_elt *tmp ;

  {
  {
#line 527
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 529
  tmp = ebitset_elt_find(dst, bitno, (enum ebitset_find_mode )0);
  }
#line 529
  if (! tmp) {
#line 530
    return;
  }
#line 532
  *(dst->b.cdata + (windex - dst->b.cindex)) &= ~ (1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word )));
#line 538
  return;
}
}
#line 542 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_test(bitset src , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  ebitset_elt *tmp ;
  int tmp___0 ;

  {
  {
#line 545
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 547
  tmp = ebitset_elt_find(src, bitno, (enum ebitset_find_mode )0);
  }
#line 547
  if (tmp) {
#line 547
    if ((*(src->b.cdata + (windex - src->b.cindex)) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ))) & 1UL) {
#line 547
      tmp___0 = 1;
    } else {
#line 547
      tmp___0 = 0;
    }
  } else {
#line 547
    tmp___0 = 0;
  }
#line 547
  return ((_Bool )tmp___0);
}
}
#line 554 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_free(bitset bset ) 
{ 


  {
  {
#line 557
  ebitset_zero(bset);
#line 558
  free((void *)bset->e.elts);
  }
#line 559
  return;
}
}
#line 565 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static bitset_bindex ebitset_list_reverse(bitset bset , bitset_bindex *list , bitset_bindex num ,
                                          bitset_bindex *next ) 
{ 
  bitset_bindex n_bits ;
  bitset_bindex bitno ;
  bitset_bindex rbitno ;
  unsigned int bcount ;
  bitset_bindex boffset ;
  bitset_windex windex ;
  bitset_windex eindex ;
  bitset_windex woffset ;
  bitset_bindex count ;
  bitset_windex size ;
  ebitset_elts *elts ;
  ebitset_elt *elt ;
  bitset_word *srcp ;
  bitset_word word ;
  bitset_bindex tmp ;
  bitset_windex tmp___0 ;
  bitset_windex tmp___1 ;

  {
#line 581
  if ((unsigned long )bset->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 582
    return ((bitset_bindex )0);
  }
#line 584
  size = ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 585
  n_bits = size * (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 586
  rbitno = *next;
#line 588
  if (rbitno >= n_bits) {
#line 589
    return ((bitset_bindex )0);
  }
#line 591
  elts = bset->e.elts;
#line 593
  bitno = n_bits - (rbitno + 1U);
#line 595
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 596
  eindex = bitno / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 597
  woffset = windex - eindex * 2U;
#line 602
  count = (bitset_bindex )0;
#line 603
  bcount = bitno % (unsigned int )(8UL * sizeof(bitset_word ));
#line 604
  boffset = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    elt = *(elts + eindex);
#line 612
    if (elt) {
#line 614
      srcp = elt->u.words;
      {
#line 616
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 620
        word = *(srcp + woffset) << (((unsigned int )(8UL * sizeof(bitset_word )) - 1U) - bcount);
        {
#line 622
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 622
          if (! word) {
#line 622
            goto while_break___1;
          }
#line 624
          if (word & (1UL << ((unsigned int )(8UL * sizeof(bitset_word )) - 1U))) {
#line 626
            tmp = count;
#line 626
            count ++;
#line 626
            *(list + tmp) = boffset + bcount;
#line 627
            if (count >= num) {
#line 629
              *next = n_bits - (boffset + bcount);
#line 630
              return (count);
            }
          }
#line 633
          word <<= 1;
#line 622
          bcount --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 635
        boffset -= (unsigned int )(8UL * sizeof(bitset_word ));
#line 636
        bcount = (unsigned int )(8UL * sizeof(bitset_word )) - 1U;
#line 616
        tmp___0 = woffset;
#line 616
        woffset --;
#line 616
        if (! tmp___0) {
#line 616
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 641
    woffset = (bitset_windex )1;
#line 642
    boffset = eindex * (2U * (unsigned int )(8UL * sizeof(bitset_word ))) - (unsigned int )(8UL * sizeof(bitset_word ));
#line 606
    tmp___1 = eindex;
#line 606
    eindex --;
#line 606
    if (! tmp___1) {
#line 606
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  *next = n_bits - (boffset + 1U);
#line 647
  return (count);
}
}
#line 654 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static bitset_bindex ebitset_list(bitset bset , bitset_bindex *list , bitset_bindex num ,
                                  bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_windex windex ;
  bitset_windex eindex ;
  bitset_bindex count ;
  bitset_windex size ;
  ebitset_elt *elt ;
  bitset_word word ;
  ebitset_elts *elts ;
  bitset_windex woffset ;
  bitset_word *srcp ;
  bitset_bindex tmp ;
  int i ;
  bitset_word *srcp___0 ;
  bitset_bindex tmp___0 ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;

  {
#line 667
  if ((unsigned long )bset->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 668
    return ((bitset_bindex )0);
  }
#line 670
  bitno = *next;
#line 671
  count = (bitset_bindex )0;
#line 673
  elts = bset->e.elts;
#line 674
  size = ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 675
  eindex = bitno / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 677
  if (bitno % (2U * (unsigned int )(8UL * sizeof(bitset_word )))) {
#line 681
    elt = *(elts + eindex);
#line 682
    if (elt) {
#line 685
      srcp = elt->u.words;
#line 687
      windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 688
      woffset = eindex * 2U;
      {
#line 690
      while (1) {
        while_continue: /* CIL Label */ ;
#line 690
        if (! (windex - woffset < 2U)) {
#line 690
          goto while_break;
        }
#line 692
        word = *(srcp + (windex - woffset)) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ));
        {
#line 694
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 694
          if (! word) {
#line 694
            goto while_break___0;
          }
#line 696
          if (word & 1UL) {
#line 698
            tmp = count;
#line 698
            count ++;
#line 698
            *(list + tmp) = bitno;
#line 699
            if (count >= num) {
#line 701
              *next = bitno + 1U;
#line 702
              return (count);
            }
          }
#line 705
          word >>= 1;
#line 694
          bitno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 707
        bitno = (windex + 1U) * (unsigned int )(8UL * sizeof(bitset_word ));
#line 690
        windex ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 712
    eindex ++;
  }
  {
#line 718
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 718
    if (! (eindex < size)) {
#line 718
      goto while_break___1;
    }
#line 723
    elt = *(elts + eindex);
#line 724
    if (! elt) {
#line 725
      goto __Cont;
    }
#line 727
    srcp___0 = elt->u.words;
#line 728
    windex = eindex * 2U;
#line 730
    if (count + 2U * (unsigned int )(8UL * sizeof(bitset_word )) < num) {
#line 735
      word = *(srcp___0 + 0);
#line 736
      if (word) {
#line 738
        if (! (word & 65535UL)) {
#line 740
          word >>= 16;
#line 741
          bitno += 16U;
        }
#line 743
        if (! (word & 255UL)) {
#line 745
          word >>= 8;
#line 746
          bitno += 8U;
        }
        {
#line 748
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 748
          if (! word) {
#line 748
            goto while_break___2;
          }
#line 750
          if (word & 1UL) {
#line 751
            tmp___0 = count;
#line 751
            count ++;
#line 751
            *(list + tmp___0) = bitno;
          }
#line 752
          word >>= 1;
#line 748
          bitno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 755
      windex ++;
#line 756
      bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
#line 758
      word = *(srcp___0 + 1);
#line 759
      if (word) {
#line 761
        if (! (word & 65535UL)) {
#line 763
          word >>= 16;
#line 764
          bitno += 16U;
        }
        {
#line 766
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 766
          if (! word) {
#line 766
            goto while_break___3;
          }
#line 768
          if (word & 1UL) {
#line 769
            tmp___1 = count;
#line 769
            count ++;
#line 769
            *(list + tmp___1) = bitno;
          }
#line 770
          word >>= 1;
#line 766
          bitno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 773
      windex ++;
#line 774
      bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
    } else {
#line 808
      i = 0;
      {
#line 808
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 808
        if (! (i < 2)) {
#line 808
          goto while_break___4;
        }
#line 810
        bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
#line 812
        word = *(srcp___0 + i);
        {
#line 812
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 812
          if (! word) {
#line 812
            goto while_break___5;
          }
#line 814
          if (word & 1UL) {
#line 816
            tmp___2 = count;
#line 816
            count ++;
#line 816
            *(list + tmp___2) = bitno;
#line 817
            if (count >= num) {
#line 819
              *next = bitno + 1U;
#line 820
              return (count);
            }
          }
#line 823
          word >>= 1;
#line 812
          bitno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 808
        i ++;
#line 808
        windex ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 718
    eindex ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 829
  *next = bitno;
#line 830
  return (count);
}
}
#line 835 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
__inline static void ebitset_unused_clear(bitset dst ) 
{ 
  unsigned int last_bit ;
  bitset_bindex n_bits ;
  bitset_windex eindex ;
  ebitset_elts *elts ;
  ebitset_elt *elt ;
  bitset_windex windex ;
  bitset_windex woffset ;
  bitset_word *srcp ;

  {
#line 841
  n_bits = dst->b.n_bits;
#line 842
  last_bit = n_bits % (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 844
  if (last_bit) {
#line 850
    elts = dst->e.elts;
#line 852
    eindex = n_bits / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 854
    elt = *(elts + eindex);
#line 855
    if (elt) {
#line 859
      srcp = elt->u.words;
#line 861
      windex = n_bits / (unsigned int )(8UL * sizeof(bitset_word ));
#line 862
      woffset = eindex * 2U;
#line 864
      *(srcp + (windex - woffset)) &= (1UL << last_bit) - 1UL;
#line 865
      windex ++;
      {
#line 866
      while (1) {
        while_continue: /* CIL Label */ ;
#line 866
        if (! (windex - woffset < 2U)) {
#line 866
          goto while_break;
        }
#line 867
        *(srcp + (windex - woffset)) = (bitset_word )0;
#line 866
        windex ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 870
  return;
}
}
#line 873 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_ones(bitset dst ) 
{ 
  bitset_windex j ;
  ebitset_elt *elt ;

  {
#line 879
  j = (bitset_windex )0;
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
#line 879
    if (! (j < ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 879
      goto while_break;
    }
    {
#line 883
    elt = ebitset_elt_find(dst, j * (2U * (unsigned int )(8UL * sizeof(bitset_word ))),
                           (enum ebitset_find_mode )1);
#line 885
    memset((void *)(elt->u.words), -1, (size_t )sizeof(elt->u.words));
#line 879
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 887
  dst->b.cindex = 4294967295U >> 1;
#line 887
  dst->b.cdata = (bitset_word *)(~ 0);
#line 888
  ebitset_unused_clear(dst);
  }
#line 889
  return;
}
}
#line 892 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_empty_p(bitset dst ) 
{ 
  ebitset_elts *elts ;
  bitset_windex j ;
  ebitset_elt *elt ;
  _Bool tmp ;

  {
#line 898
  if ((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 899
    return ((_Bool)1);
  }
#line 901
  elts = dst->e.elts;
#line 902
  j = (bitset_windex )0;
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 902
    if (! (j < ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 902
      goto while_break;
    }
#line 904
    elt = *(elts + j);
#line 906
    if (elt) {
      {
#line 908
      tmp = ebitset_elt_zero_p(elt);
      }
#line 908
      if (! tmp) {
#line 909
        return ((_Bool)0);
      }
      {
#line 911
      ebitset_elt_remove(dst, j);
      }
    }
#line 902
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 917
  dst->b.cindex = 4294967295U >> 1;
#line 917
  dst->b.cdata = (bitset_word *)0;
#line 918
  return ((_Bool)1);
}
}
#line 922 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_not(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  ebitset_elt *selt ;
  ebitset_elt *delt ;
  bitset_windex j ;

  {
  {
#line 930
  ebitset_resize(dst, src->b.n_bits);
#line 932
  j = (bitset_windex )0;
  }
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    if (! (j < ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 932
      goto while_break;
    }
    {
#line 936
    selt = ebitset_elt_find(dst, j * (2U * (unsigned int )(8UL * sizeof(bitset_word ))),
                            (enum ebitset_find_mode )2);
#line 938
    delt = ebitset_elt_find(dst, j * (2U * (unsigned int )(8UL * sizeof(bitset_word ))),
                            (enum ebitset_find_mode )1);
#line 941
    i = 0U;
    }
    {
#line 941
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 941
      if (! (i < 2U)) {
#line 941
        goto while_break___0;
      }
#line 942
      delt->u.words[i] = ~ selt->u.words[i];
#line 941
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 932
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 944
  dst->b.cindex = 4294967295U >> 1;
#line 944
  dst->b.cdata = (bitset_word *)(~ 0);
#line 945
  ebitset_unused_clear(dst);
  }
#line 946
  return;
}
}
#line 950 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_subset_p(bitset dst , bitset src ) 
{ 
  bitset_windex j ;
  ebitset_elts *selts ;
  ebitset_elts *delts ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  unsigned int i ;
  ebitset_elt *selt ;
  ebitset_elt *delt ;

  {
#line 959
  selts = src->e.elts;
#line 960
  delts = dst->e.elts;
#line 962
  ssize = ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 963
  dsize = ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 965
  j = (bitset_windex )0;
  {
#line 965
  while (1) {
    while_continue: /* CIL Label */ ;
#line 965
    if (! (j < ssize)) {
#line 965
      goto while_break;
    }
#line 971
    if (j < ssize) {
#line 971
      selt = *(selts + j);
    } else {
#line 971
      selt = (ebitset_elt *)0;
    }
#line 972
    if (j < dsize) {
#line 972
      delt = *(delts + j);
    } else {
#line 972
      delt = (ebitset_elt *)0;
    }
#line 974
    if (! selt) {
#line 974
      if (! delt) {
#line 975
        goto __Cont;
      }
    }
#line 977
    if (! selt) {
#line 978
      selt = & ebitset_zero_elts[0];
    }
#line 979
    if (! delt) {
#line 980
      delt = & ebitset_zero_elts[0];
    }
#line 982
    i = 0U;
    {
#line 982
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 982
      if (! (i < 2U)) {
#line 982
        goto while_break___0;
      }
#line 983
      if (delt->u.words[i] != (selt->u.words[i] | delt->u.words[i])) {
#line 985
        return ((_Bool)0);
      }
#line 982
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 965
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  return ((_Bool)1);
}
}
#line 992 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_disjoint_p(bitset dst , bitset src ) 
{ 
  bitset_windex j ;
  ebitset_elts *selts ;
  ebitset_elts *delts ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  unsigned int i ;
  ebitset_elt *selt ;
  ebitset_elt *delt ;

  {
#line 1001
  selts = src->e.elts;
#line 1002
  delts = dst->e.elts;
#line 1004
  ssize = ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1005
  dsize = ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1007
  j = (bitset_windex )0;
  {
#line 1007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1007
    if (! (j < ssize)) {
#line 1007
      goto while_break;
    }
#line 1013
    if (j < ssize) {
#line 1013
      selt = *(selts + j);
    } else {
#line 1013
      selt = (ebitset_elt *)0;
    }
#line 1014
    if (j < dsize) {
#line 1014
      delt = *(delts + j);
    } else {
#line 1014
      delt = (ebitset_elt *)0;
    }
#line 1016
    if (! selt) {
#line 1017
      goto __Cont;
    } else
#line 1016
    if (! delt) {
#line 1017
      goto __Cont;
    }
#line 1019
    i = 0U;
    {
#line 1019
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1019
      if (! (i < 2U)) {
#line 1019
        goto while_break___0;
      }
#line 1020
      if (selt->u.words[i] & delt->u.words[i]) {
#line 1021
        return ((_Bool)0);
      }
#line 1019
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1007
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1023
  return ((_Bool)1);
}
}
#line 1028 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_op3_cmp(bitset dst , bitset src1 , bitset src2 , enum bitset_ops op ) 
{ 
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_windex size ;
  ebitset_elts *selts1 ;
  ebitset_elts *selts2 ;
  ebitset_elts *delts ;
  bitset_word *srcp1 ;
  bitset_word *srcp2 ;
  bitset_word *dstp ;
  _Bool changed ;
  unsigned int i ;
  bitset_windex j ;
  bitset_bindex tmp ;
  ebitset_elt *selt1 ;
  ebitset_elt *selt2 ;
  ebitset_elt *delt ;
  bitset_word tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word tmp___3 ;
  bitset_word *tmp___4 ;
  bitset_word *tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_word tmp___9 ;
  bitset_word *tmp___10 ;
  bitset_word *tmp___11 ;
  _Bool tmp___12 ;
  ebitset_elt *delt___0 ;

  {
#line 1041
  changed = (_Bool)0;
#line 1045
  if (src1->b.n_bits > src2->b.n_bits) {
#line 1045
    tmp = src1->b.n_bits;
  } else {
#line 1045
    tmp = src2->b.n_bits;
  }
  {
#line 1045
  ebitset_resize(dst, tmp);
#line 1047
  ssize1 = ((src1->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1048
  ssize2 = ((src2->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1049
  dsize = ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1050
  size = ssize1;
  }
#line 1051
  if (size < ssize2) {
#line 1052
    size = ssize2;
  }
#line 1054
  selts1 = src1->e.elts;
#line 1055
  selts2 = src2->e.elts;
#line 1056
  delts = dst->e.elts;
#line 1058
  j = (bitset_windex )0;
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1058
    if (! (j < size)) {
#line 1058
      goto while_break;
    }
#line 1064
    if (j < ssize1) {
#line 1064
      selt1 = *(selts1 + j);
    } else {
#line 1064
      selt1 = (ebitset_elt *)0;
    }
#line 1065
    if (j < ssize2) {
#line 1065
      selt2 = *(selts2 + j);
    } else {
#line 1065
      selt2 = (ebitset_elt *)0;
    }
#line 1066
    if (j < dsize) {
#line 1066
      delt = *(delts + j);
    } else {
#line 1066
      delt = (ebitset_elt *)0;
    }
#line 1068
    if (! selt1) {
#line 1068
      if (! selt2) {
#line 1070
        if (delt) {
          {
#line 1072
          changed = (_Bool)1;
#line 1073
          ebitset_elt_remove(dst, j);
          }
        }
#line 1075
        goto __Cont;
      }
    }
#line 1078
    if (! selt1) {
#line 1079
      selt1 = & ebitset_zero_elts[0];
    }
#line 1080
    if (! selt2) {
#line 1081
      selt2 = & ebitset_zero_elts[0];
    }
#line 1082
    if (! delt) {
      {
#line 1083
      delt = ebitset_elt_calloc();
      }
    } else {
#line 1085
      *(delts + j) = (ebitset_elts )0;
    }
#line 1087
    srcp1 = selt1->u.words;
#line 1088
    srcp2 = selt2->u.words;
#line 1089
    dstp = delt->u.words;
    {
#line 1095
    if ((unsigned int )op == 9U) {
#line 1095
      goto case_9;
    }
#line 1108
    if ((unsigned int )op == 8U) {
#line 1108
      goto case_8;
    }
#line 1121
    if ((unsigned int )op == 10U) {
#line 1121
      goto case_10;
    }
#line 1134
    if ((unsigned int )op == 11U) {
#line 1134
      goto case_11;
    }
#line 1092
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 1093
    abort();
    }
    case_9: /* CIL Label */ 
#line 1096
    i = 0U;
    {
#line 1096
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1096
      if (! (i < 2U)) {
#line 1096
        goto while_break___0;
      }
#line 1098
      tmp___1 = srcp1;
#line 1098
      srcp1 ++;
#line 1098
      tmp___2 = srcp2;
#line 1098
      srcp2 ++;
#line 1098
      tmp___0 = *tmp___1 | *tmp___2;
#line 1100
      if (*dstp != tmp___0) {
#line 1102
        changed = (_Bool)1;
#line 1103
        *dstp = tmp___0;
      }
#line 1096
      i ++;
#line 1096
      dstp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1106
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1109
    i = 0U;
    {
#line 1109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1109
      if (! (i < 2U)) {
#line 1109
        goto while_break___1;
      }
#line 1111
      tmp___4 = srcp1;
#line 1111
      srcp1 ++;
#line 1111
      tmp___5 = srcp2;
#line 1111
      srcp2 ++;
#line 1111
      tmp___3 = *tmp___4 & *tmp___5;
#line 1113
      if (*dstp != tmp___3) {
#line 1115
        changed = (_Bool)1;
#line 1116
        *dstp = tmp___3;
      }
#line 1109
      i ++;
#line 1109
      dstp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1119
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1122
    i = 0U;
    {
#line 1122
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1122
      if (! (i < 2U)) {
#line 1122
        goto while_break___2;
      }
#line 1124
      tmp___7 = srcp1;
#line 1124
      srcp1 ++;
#line 1124
      tmp___8 = srcp2;
#line 1124
      srcp2 ++;
#line 1124
      tmp___6 = *tmp___7 ^ *tmp___8;
#line 1126
      if (*dstp != tmp___6) {
#line 1128
        changed = (_Bool)1;
#line 1129
        *dstp = tmp___6;
      }
#line 1122
      i ++;
#line 1122
      dstp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1132
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1135
    i = 0U;
    {
#line 1135
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1135
      if (! (i < 2U)) {
#line 1135
        goto while_break___3;
      }
#line 1137
      tmp___10 = srcp1;
#line 1137
      srcp1 ++;
#line 1137
      tmp___11 = srcp2;
#line 1137
      srcp2 ++;
#line 1137
      tmp___9 = *tmp___10 & ~ *tmp___11;
#line 1139
      if (*dstp != tmp___9) {
#line 1141
        changed = (_Bool)1;
#line 1142
        *dstp = tmp___9;
      }
#line 1135
      i ++;
#line 1135
      dstp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1145
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1148
    tmp___12 = ebitset_elt_zero_p(delt);
    }
#line 1148
    if (tmp___12) {
      {
#line 1154
      ebitset_elt_free(delt);
      }
    } else {
      {
#line 1150
      ebitset_elt_add(dst, delt, j);
      }
    }
    __Cont: /* CIL Label */ 
#line 1058
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1159
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1159
    if (! (j < dsize)) {
#line 1159
      goto while_break___4;
    }
#line 1163
    changed = (_Bool)1;
#line 1165
    delt___0 = *(delts + j);
#line 1167
    if (delt___0) {
      {
#line 1168
      ebitset_elt_remove(dst, j);
      }
    }
#line 1159
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1171
  dst->b.cindex = 4294967295U >> 1;
#line 1171
  dst->b.cdata = (bitset_word *)(~ 0);
#line 1172
  return (changed);
}
}
#line 1176 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_and_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool changed ;
  _Bool tmp ;

  {
#line 1181
  if ((unsigned long )src2->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1183
    ebitset_weed(dst);
#line 1184
    changed = (_Bool )((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0));
#line 1185
    ebitset_zero(dst);
    }
#line 1186
    return (changed);
  } else
#line 1188
  if ((unsigned long )src1->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1190
    ebitset_weed(dst);
#line 1191
    changed = (_Bool )((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0));
#line 1192
    ebitset_zero(dst);
    }
#line 1193
    return (changed);
  }
  {
#line 1195
  tmp = ebitset_op3_cmp(dst, src1, src2, (enum bitset_ops )8);
  }
#line 1195
  return (tmp);
}
}
#line 1199 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_and(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1202
  ebitset_and_cmp(dst, src1, src2);
  }
#line 1203
  return;
}
}
#line 1206 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_andn_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool changed ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 1211
  if ((unsigned long )src2->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1213
    tmp = ebitset_copy_cmp(dst, src1);
    }
#line 1213
    return (tmp);
  } else
#line 1215
  if ((unsigned long )src1->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1217
    ebitset_weed(dst);
#line 1218
    changed = (_Bool )((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0));
#line 1219
    ebitset_zero(dst);
    }
#line 1220
    return (changed);
  }
  {
#line 1222
  tmp___0 = ebitset_op3_cmp(dst, src1, src2, (enum bitset_ops )11);
  }
#line 1222
  return (tmp___0);
}
}
#line 1226 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_andn(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1229
  ebitset_andn_cmp(dst, src1, src2);
  }
#line 1230
  return;
}
}
#line 1233 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_or_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1236
  if ((unsigned long )src2->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1238
    tmp = ebitset_copy_cmp(dst, src1);
    }
#line 1238
    return (tmp);
  } else
#line 1240
  if ((unsigned long )src1->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1242
    tmp___0 = ebitset_copy_cmp(dst, src2);
    }
#line 1242
    return (tmp___0);
  }
  {
#line 1244
  tmp___1 = ebitset_op3_cmp(dst, src1, src2, (enum bitset_ops )9);
  }
#line 1244
  return (tmp___1);
}
}
#line 1248 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_or(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1251
  ebitset_or_cmp(dst, src1, src2);
  }
#line 1252
  return;
}
}
#line 1255 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static _Bool ebitset_xor_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1258
  if ((unsigned long )src2->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1260
    tmp = ebitset_copy_cmp(dst, src1);
    }
#line 1260
    return (tmp);
  } else
#line 1262
  if ((unsigned long )src1->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1264
    tmp___0 = ebitset_copy_cmp(dst, src2);
    }
#line 1264
    return (tmp___0);
  }
  {
#line 1266
  tmp___1 = ebitset_op3_cmp(dst, src1, src2, (enum bitset_ops )10);
  }
#line 1266
  return (tmp___1);
}
}
#line 1270 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_xor(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1273
  ebitset_xor_cmp(dst, src1, src2);
  }
#line 1274
  return;
}
}
#line 1277 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
static void ebitset_copy(bitset dst , bitset src ) 
{ 


  {
#line 1280
  if ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable) {
    {
#line 1281
    ebitset_copy_(dst, src);
    }
  } else {
    {
#line 1283
    bitset_copy_(dst, src);
    }
  }
#line 1284
  return;
}
}
#line 1288 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
struct bitset_vtable ebitset_vtable  = 
#line 1288
     {& ebitset_set, & ebitset_reset, & bitset_toggle_, & ebitset_test, & ebitset_resize,
    & bitset_size_, & bitset_count_, & ebitset_empty_p, & ebitset_ones, & ebitset_zero,
    & ebitset_copy, & ebitset_disjoint_p, & ebitset_equal_p, & ebitset_not, & ebitset_subset_p,
    & ebitset_and, & ebitset_and_cmp, & ebitset_andn, & ebitset_andn_cmp, & ebitset_or,
    & ebitset_or_cmp, & ebitset_xor, & ebitset_xor_cmp, & bitset_and_or_, & bitset_and_or_cmp_,
    & bitset_andn_or_, & bitset_andn_or_cmp_, & bitset_or_and_, & bitset_or_and_cmp_,
    & ebitset_list, & ebitset_list_reverse, & ebitset_free, (enum bitset_type )2};
#line 1326 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
size_t ebitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) 
{ 


  {
#line 1329
  return ((size_t )sizeof(struct ebitset_struct ));
}
}
#line 1335 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
bitset ebitset_init(bitset bset , bitset_bindex n_bits ) 
{ 
  bitset_windex size ;

  {
#line 1340
  bset->b.vtable = (struct bitset_vtable  const  *)(& ebitset_vtable);
#line 1342
  bset->b.csize = (bitset_windex )2;
#line 1344
  bset->b.cindex = 4294967295U >> 1;
#line 1344
  bset->b.cdata = (bitset_word *)0;
#line 1346
  if (n_bits) {
#line 1346
    size = ((n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
  } else {
#line 1346
    size = (bitset_windex )2;
  }
  {
#line 1349
  bset->e.size = (bitset_windex )0;
#line 1350
  bset->e.elts = (struct ebitset_elt_struct **)0;
#line 1351
  ebitset_resize(bset, n_bits);
  }
#line 1353
  return (bset);
}
}
#line 1357 "/home/pronto/abs/test-suite/bison-2.5/lib/ebitset.c"
void ebitset_release_memory(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 1360
  ebitset_free_list = (ebitset_elt *)0;
#line 1361
  if (ebitset_obstack_init) {
#line 1363
    ebitset_obstack_init = (_Bool)0;
#line 1364
    __o = & ebitset_obstack;
#line 1364
    __obj = (void *)0;
#line 1364
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 1364
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 1364
        tmp = (char *)__obj;
#line 1364
        __o->object_base = tmp;
#line 1364
        __o->next_free = tmp;
      } else {
        {
#line 1364
        obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 1364
      obstack_free(__o, __obj);
      }
    }
  }
#line 1366
  return;
}
}
#line 30 "/home/pronto/abs/test-suite/bison-2.5/lib/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = rpl_fcntl(fd, 0, 3);
  }
#line 33
  return (tmp);
}
}
#line 35 "/home/pronto/abs/test-suite/bison-2.5/lib/dup-safer-flag.c"
int dup_safer_flag(int fd , int flag ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 38
  if (flag & 524288) {
#line 38
    tmp = 1030;
  } else {
#line 38
    tmp = 0;
  }
  {
#line 38
  tmp___0 = rpl_fcntl(fd, tmp, 3);
  }
#line 38
  return (tmp___0);
}
}
#line 36 "/home/pronto/abs/test-suite/bison-2.5/lib/dirname.h"
char *dir_name(char const   *file ) ;
#line 39
char *mdir_name(char const   *file ) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.5/lib/dirname.c"
char *dir_name(char const   *file ) 
{ 
  char *result ;
  char *tmp ;

  {
  {
#line 34
  tmp = mdir_name(file);
#line 34
  result = tmp;
  }
#line 35
  if (! result) {
    {
#line 36
    xalloc_die();
    }
  }
#line 37
  return (result);
}
}
#line 41 "/home/pronto/abs/test-suite/bison-2.5/lib/dirname.h"
size_t dir_len(char const   *file ) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.5/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0U) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1U)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/pronto/abs/test-suite/bison-2.5/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0U) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1U);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 32 "/home/pronto/abs/test-suite/bison-2.5/lib/cloexec.h"
int set_cloexec_flag(int desc , _Bool value ) ;
#line 38
int dup_cloexec(int fd ) ;
#line 38 "/home/pronto/abs/test-suite/bison-2.5/lib/cloexec.c"
int set_cloexec_flag(int desc , _Bool value ) 
{ 
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 43
  tmp = rpl_fcntl(desc, 1, 0);
#line 43
  flags = tmp;
  }
#line 45
  if (0 <= flags) {
#line 47
    if (value) {
#line 47
      tmp___0 = flags | 1;
    } else {
#line 47
      tmp___0 = flags & -2;
    }
#line 47
    newflags = tmp___0;
#line 49
    if (flags == newflags) {
#line 51
      return (0);
    } else {
      {
#line 49
      tmp___1 = rpl_fcntl(desc, 2, newflags);
      }
#line 49
      if (tmp___1 != -1) {
#line 51
        return (0);
      }
    }
  }
#line 54
  return (-1);
}
}
#line 79 "/home/pronto/abs/test-suite/bison-2.5/lib/cloexec.c"
int dup_cloexec(int fd ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = rpl_fcntl(fd, 1030, 0);
  }
#line 82
  return (tmp);
}
}
#line 50 "/home/pronto/abs/test-suite/bison-2.5/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 138 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.h"
int c_tolower(int c ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.5/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  } else
#line 36
  if (n == 0U) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
#line 44
    n --;
    }
#line 44
    if (n == 0U) {
#line 45
      goto while_break;
    } else
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 45 "/home/pronto/abs/test-suite/bison-2.5/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.5/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
    }
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 123 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.h"
_Bool c_isascii(int c ) ;
#line 125
_Bool c_isalnum(int c ) ;
#line 126
_Bool c_isalpha(int c ) ;
#line 127
_Bool c_isblank(int c ) ;
#line 128
_Bool c_iscntrl(int c ) ;
#line 129
_Bool c_isdigit(int c ) ;
#line 130
_Bool c_islower(int c ) ;
#line 131
_Bool c_isgraph(int c ) ;
#line 132
_Bool c_isprint(int c ) ;
#line 133
_Bool c_ispunct(int c ) ;
#line 134
_Bool c_isspace(int c ) ;
#line 135
_Bool c_isupper(int c ) ;
#line 136
_Bool c_isxdigit(int c ) ;
#line 139
int c_toupper(int c ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 32
  if (c >= 0) {
#line 32
    if (c <= 127) {
#line 32
      tmp = 1;
    } else {
#line 32
      tmp = 0;
    }
  } else {
#line 32
    tmp = 0;
  }
#line 32
  return ((_Bool )tmp);
}
}
#line 35 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 41
  if (c >= 48) {
#line 41
    if (c <= 57) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if ((c & -33) >= 65) {
#line 41
    if ((c & -33) <= 90) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return ((_Bool )tmp);
}
}
#line 70 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 75
  if ((c & -33) >= 65) {
#line 75
    if ((c & -33) <= 90) {
#line 75
      tmp = 1;
    } else {
#line 75
      tmp = 0;
    }
  } else {
#line 75
    tmp = 0;
  }
#line 75
  return ((_Bool )tmp);
}
}
#line 99 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 102
  if (c == 32) {
#line 102
    tmp = 1;
  } else
#line 102
  if (c == 9) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return ((_Bool )tmp);
}
}
#line 105 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 109
  if ((c & -32) == 0) {
#line 109
    tmp = 1;
  } else
#line 109
  if (c == 127) {
#line 109
    tmp = 1;
  } else {
#line 109
    tmp = 0;
  }
#line 109
  return ((_Bool )tmp);
}
}
#line 139 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 143
  if (c >= 48) {
#line 143
    if (c <= 57) {
#line 143
      tmp = 1;
    } else {
#line 143
      tmp = 0;
    }
  } else {
#line 143
    tmp = 0;
  }
#line 143
  return ((_Bool )tmp);
}
}
#line 156 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 160
  if (c >= 97) {
#line 160
    if (c <= 122) {
#line 160
      tmp = 1;
    } else {
#line 160
      tmp = 0;
    }
  } else {
#line 160
    tmp = 0;
  }
#line 160
  return ((_Bool )tmp);
}
}
#line 176 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 180
  if (c >= 33) {
#line 180
    if (c <= 126) {
#line 180
      tmp = 1;
    } else {
#line 180
      tmp = 0;
    }
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return ((_Bool )tmp);
}
}
#line 210 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 214
  if (c >= 32) {
#line 214
    if (c <= 126) {
#line 214
      tmp = 1;
    } else {
#line 214
      tmp = 0;
    }
  } else {
#line 214
    tmp = 0;
  }
#line 214
  return ((_Bool )tmp);
}
}
#line 244 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 248
  if (c >= 33) {
#line 248
    if (c <= 126) {
#line 248
      if (c >= 48) {
#line 248
        if (c <= 57) {
#line 248
          tmp = 0;
        } else {
#line 248
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 248
      if ((c & -33) >= 65) {
#line 248
        if ((c & -33) <= 90) {
#line 248
          tmp = 0;
        } else {
#line 248
          tmp = 1;
        }
      } else {
#line 248
        tmp = 1;
      }
    } else {
#line 248
      tmp = 0;
    }
  } else {
#line 248
    tmp = 0;
  }
#line 248
  return ((_Bool )tmp);
}
}
#line 268 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 271
  if (c == 32) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 9) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 10) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 11) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 12) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 13) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
#line 271
  return ((_Bool )tmp);
}
}
#line 275 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 279
  if (c >= 65) {
#line 279
    if (c <= 90) {
#line 279
      tmp = 1;
    } else {
#line 279
      tmp = 0;
    }
  } else {
#line 279
    tmp = 0;
  }
#line 279
  return ((_Bool )tmp);
}
}
#line 295 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 301
  if (c >= 48) {
#line 301
    if (c <= 57) {
#line 301
      tmp = 1;
    } else {
#line 301
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 301
  if ((c & -33) >= 65) {
#line 301
    if ((c & -33) <= 70) {
#line 301
      tmp = 1;
    } else {
#line 301
      tmp = 0;
    }
  } else {
#line 301
    tmp = 0;
  }
#line 301
  return ((_Bool )tmp);
}
}
#line 322 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 326
  if (c >= 65) {
#line 326
    if (c <= 90) {
#line 326
      tmp = (c - 65) + 97;
    } else {
#line 326
      tmp = c;
    }
  } else {
#line 326
    tmp = c;
  }
#line 326
  return (tmp);
}
}
#line 361 "/home/pronto/abs/test-suite/bison-2.5/lib/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 365
  if (c >= 97) {
#line 365
    if (c <= 122) {
#line 365
      tmp = (c - 97) + 65;
    } else {
#line 365
      tmp = c;
    }
  } else {
#line 365
    tmp = c;
  }
#line 365
  return (tmp);
}
}
#line 101 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
size_t bitset_bytes(enum bitset_type type , bitset_bindex n_bits ) ;
#line 104
bitset bitset_init(bitset bset , bitset_bindex n_bits , enum bitset_type type ) ;
#line 108
enum bitset_type bitset_type_choose(bitset_bindex n_bits  __attribute__((__unused__)) ,
                                    unsigned int attr ) ;
#line 135 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
__inline static void bitset_set(bitset bset , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  bitset_windex offset ;

  {
#line 138
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 139
  offset = windex - bset->b.cindex;
#line 141
  if (offset < bset->b.csize) {
#line 142
    *(bset->b.cdata + offset) |= 1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word ));
  } else {
    {
#line 144
    (*((bset->b.vtable)->set))(bset, bitno);
    }
  }
#line 145
  return;
}
}
#line 163 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
__inline static _Bool bitset_test(bitset bset , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  bitset_windex offset ;
  _Bool tmp ;

  {
#line 166
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 167
  offset = windex - bset->b.cindex;
#line 169
  if (offset < bset->b.csize) {
#line 170
    return ((_Bool )((*(bset->b.cdata + offset) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ))) & 1UL));
  } else {
    {
#line 172
    tmp = (*((bset->b.vtable)->test))(bset, bitno);
    }
#line 172
    return (tmp);
  }
}
}
#line 301
void bitset_dump(FILE *file , bitset bset ) ;
#line 388
void debug_bitset(bitset bset ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.h"
bitset *bitsetv_alloc(bitset_bindex n_vecs , bitset_bindex n_bits , enum bitset_type type ) ;
#line 33
bitset *bitsetv_create(bitset_bindex n_vecs , bitset_bindex n_bits , unsigned int attr ) ;
#line 36
void bitsetv_free(bitsetv bsetv ) ;
#line 39
void bitsetv_zero(bitsetv bsetv ) ;
#line 42
void bitsetv_ones(bitsetv bsetv ) ;
#line 46
void bitsetv_transitive_closure(bitsetv bsetv ) ;
#line 52
void bitsetv_reflexive_transitive_closure(bitsetv bsetv ) ;
#line 55
void bitsetv_dump(FILE *file , char const   *title , char const   *subtitle , bitsetv bsetv ) ;
#line 58
void debug_bitsetv(bitsetv bsetv ) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.c"
bitset *bitsetv_alloc(bitset_bindex n_vecs , bitset_bindex n_bits , enum bitset_type type ) 
{ 
  size_t vector_bytes ;
  size_t bytes ;
  bitset *bsetv ;
  bitset_bindex i ;
  void *tmp ;

  {
  {
#line 38
  bytes = bitset_bytes(type, n_bits);
  }
#line 41
  if (4294967295UL / (sizeof(bitset ) + (unsigned long )bytes) <= (unsigned long )n_vecs) {
    {
#line 42
    xalloc_die();
    }
  }
  {
#line 45
  vector_bytes = (size_t )(((unsigned long )(n_vecs + 1U) * sizeof(bitset ) + (unsigned long )bytes) - 1UL);
#line 46
  vector_bytes -= vector_bytes % bytes;
#line 47
  tmp = xcalloc((size_t )1, vector_bytes + bytes * n_vecs);
#line 47
  bsetv = (bitset *)tmp;
#line 49
  i = (bitset_bindex )0;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i < n_vecs)) {
#line 49
      goto while_break;
    }
    {
#line 51
    *(bsetv + i) = (bitset )((void *)(((char *)bsetv + vector_bytes) + i * bytes));
#line 53
    bitset_init(*(bsetv + i), n_bits, type);
#line 49
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  *(bsetv + i) = (bitset )0;
#line 58
  return (bsetv);
}
}
#line 64 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.c"
bitset *bitsetv_create(bitset_bindex n_vecs , bitset_bindex n_bits , unsigned int attr ) 
{ 
  enum bitset_type type ;
  bitset *tmp ;

  {
  {
#line 69
  type = bitset_type_choose(n_bits, attr);
#line 70
  tmp = bitsetv_alloc(n_vecs, n_bits, type);
  }
#line 70
  return (tmp);
}
}
#line 75 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.c"
void bitsetv_free(bitsetv bsetv ) 
{ 
  bitset_bindex i ;

  {
#line 80
  i = (bitset_bindex )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! *(bsetv + i)) {
#line 80
      goto while_break;
    }
#line 81
    if (((*(bsetv + i))->b.vtable)->free) {
      {
#line 81
      (*(((*(bsetv + i))->b.vtable)->free))(*(bsetv + i));
      }
    }
#line 80
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  free((void *)bsetv);
  }
#line 83
  return;
}
}
#line 87 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.c"
void bitsetv_zero(bitsetv bsetv ) 
{ 
  bitset_bindex i ;

  {
#line 92
  i = (bitset_bindex )0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! *(bsetv + i)) {
#line 92
      goto while_break;
    }
    {
#line 93
    (*(((*(bsetv + i))->b.vtable)->zero))(*(bsetv + i));
#line 92
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 98 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.c"
void bitsetv_ones(bitsetv bsetv ) 
{ 
  bitset_bindex i ;

  {
#line 103
  i = (bitset_bindex )0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! *(bsetv + i)) {
#line 103
      goto while_break;
    }
    {
#line 104
    (*(((*(bsetv + i))->b.vtable)->ones))(*(bsetv + i));
#line 103
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 110 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.c"
void bitsetv_transitive_closure(bitsetv bsetv ) 
{ 
  bitset_bindex i ;
  bitset_bindex j ;
  _Bool tmp ;

  {
#line 116
  i = (bitset_bindex )0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! *(bsetv + i)) {
#line 116
      goto while_break;
    }
#line 117
    j = (bitset_bindex )0;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! *(bsetv + j)) {
#line 117
        goto while_break___0;
      }
      {
#line 118
      tmp = bitset_test(*(bsetv + j), i);
      }
#line 118
      if (tmp) {
        {
#line 119
        (*(((*(bsetv + j))->b.vtable)->or_))(*(bsetv + j), *(bsetv + j), *(bsetv + i));
        }
      }
#line 117
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 127 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.c"
void bitsetv_reflexive_transitive_closure(bitsetv bsetv ) 
{ 
  bitset_bindex i ;

  {
  {
#line 132
  bitsetv_transitive_closure(bsetv);
#line 133
  i = (bitset_bindex )0;
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! *(bsetv + i)) {
#line 133
      goto while_break;
    }
    {
#line 134
    bitset_set(*(bsetv + i), i);
#line 133
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 140 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.c"
void bitsetv_dump(FILE *file , char const   *title , char const   *subtitle , bitsetv bsetv ) 
{ 
  bitset_windex i ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 146
  rpl_fprintf(file, "%s\n", title);
#line 147
  i = (bitset_windex )0;
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! *(bsetv + i)) {
#line 147
      goto while_break;
    }
    {
#line 149
    rpl_fprintf(file, "%s %lu\n", subtitle, (unsigned long )i);
#line 150
    bitset_dump(file, *(bsetv + i));
#line 147
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  rpl_fprintf(file, "\n");
  }
#line 154
  return;
}
}
#line 157 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv.c"
void debug_bitsetv(bitsetv bsetv ) 
{ 
  bitset_windex i ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 162
  i = (bitset_windex )0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! *(bsetv + i)) {
#line 162
      goto while_break;
    }
    {
#line 164
    rpl_fprintf(stderr, "%lu: ", (unsigned long )i);
#line 165
    debug_bitset(*(bsetv + i));
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  rpl_fprintf(stderr, "\n");
  }
#line 169
  return;
}
}
#line 26 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv-print.h"
void bitsetv_matrix_dump(FILE *out , char const   *title , bitsetv bset ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.5/lib/bitsetv-print.c"
void bitsetv_matrix_dump(FILE *out , char const   *title , bitsetv bset ) 
{ 
  bitset_bindex i ;
  bitset_bindex j ;
  bitset_bindex hsize ;
  bitset_bindex tmp ;
  bitset_bindex tmp___0 ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 33
  tmp = (*(((*(bset + 0))->b.vtable)->size))(*(bset + 0));
#line 33
  hsize = tmp;
#line 36
  rpl_fprintf(out, "%s BEGIN\n", title);
#line 39
  fputs_unlocked((char const   */* __restrict  */)"   ", (FILE */* __restrict  */)out);
#line 40
  i = (bitset_bindex )0;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < hsize)) {
#line 40
      goto while_break;
    }
#line 41
    if (i / 10U) {
#line 41
      tmp___0 = 48U + i / 10U;
    } else {
#line 41
      tmp___0 = (bitset_bindex )' ';
    }
    {
#line 41
    putc_unlocked((int )tmp___0, out);
#line 40
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 42
  putc_unlocked('\n', out);
#line 43
  fputs_unlocked((char const   */* __restrict  */)"   ", (FILE */* __restrict  */)out);
#line 44
  i = (bitset_bindex )0;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! (i < hsize)) {
#line 44
      goto while_break___0;
    }
    {
#line 45
    rpl_fprintf(out, "%d", (int )(i % 10U));
#line 44
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 46
  putc_unlocked('\n', out);
#line 49
  fputs_unlocked((char const   */* __restrict  */)"  .", (FILE */* __restrict  */)out);
#line 50
  i = (bitset_bindex )0;
  }
  {
#line 50
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 50
    if (! (i < hsize)) {
#line 50
      goto while_break___1;
    }
    {
#line 51
    putc_unlocked('-', out);
#line 50
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 52
  fputs_unlocked((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)out);
#line 55
  i = (bitset_bindex )0;
  }
  {
#line 55
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 55
    if (! *(bset + i)) {
#line 55
      goto while_break___2;
    }
    {
#line 57
    rpl_fprintf(out, "%2lu|", (unsigned long )i);
#line 58
    j = (bitset_bindex )0;
    }
    {
#line 58
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 58
      if (! (j < hsize)) {
#line 58
        goto while_break___3;
      }
      {
#line 59
      tmp___3 = bitset_test(*(bset + i), j);
      }
#line 59
      if (tmp___3) {
#line 59
        tmp___2 = "1";
      } else {
#line 59
        tmp___2 = " ";
      }
      {
#line 59
      fputs_unlocked((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)out);
#line 58
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 60
    fputs_unlocked((char const   */* __restrict  */)"|\n", (FILE */* __restrict  */)out);
#line 55
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 64
  fputs_unlocked((char const   */* __restrict  */)"  `", (FILE */* __restrict  */)out);
#line 65
  i = (bitset_bindex )0;
  }
  {
#line 65
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 65
    if (! (i < hsize)) {
#line 65
      goto while_break___4;
    }
    {
#line 66
    putc_unlocked('-', out);
#line 65
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 67
  fputs_unlocked((char const   */* __restrict  */)"\'\n", (FILE */* __restrict  */)out);
#line 70
  rpl_fprintf(out, "%s END\n\n", title);
  }
#line 71
  return;
}
}
#line 48 "/home/pronto/abs/test-suite/bison-2.5/lib/bbitset.h"
char const   * const  bitset_type_names[4] ;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.h"
_Bool bitset_stats_enabled ;
#line 27
enum bitset_type bitset_stats_type_get(bitset bset ) ;
#line 29
size_t bitset_stats_bytes(void) ;
#line 31
bitset bitset_stats_init(bitset bset , bitset_bindex n_bits , enum bitset_type type ) ;
#line 710 "/usr/include/stdio.h"
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 712
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 810
extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
#line 819
extern void perror(char const   *__s ) ;
#line 373 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
void bitset_stats_enable(void) ;
#line 376
void bitset_stats_disable(void) ;
#line 379
void bitset_stats_read(char const   *file_name ) ;
#line 382
void bitset_stats_write(char const   *file_name ) ;
#line 385
void bitset_stats_dump(FILE *file ) ;
#line 391
void debug_bitset_stats(void) ;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.h"
size_t abitset_bytes(bitset_bindex n_bits ) ;
#line 27
bitset abitset_init(bitset bset , bitset_bindex n_bits ) ;
#line 100 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
struct bitset_stats_info_struct bitset_stats_info_data  ;
#line 101 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
struct bitset_stats_info_struct *bitset_stats_info  ;
#line 102 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
_Bool bitset_stats_enabled  =    (_Bool)0;
#line 106 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_percent_histogram_print(FILE *file , char const   *name , char const   *msg ,
                                           unsigned int n_bins , unsigned int *bins ) 
{ 
  unsigned int i ;
  unsigned int total ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 113
  total = 0U;
#line 114
  i = 0U;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < n_bins)) {
#line 114
      goto while_break;
    }
#line 115
    total += *(bins + i);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (! total) {
#line 118
    return;
  }
  {
#line 120
  rpl_fprintf(file, "%s %s", name, msg);
#line 121
  i = 0U;
  }
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (i < n_bins)) {
#line 121
      goto while_break___0;
    }
    {
#line 122
    rpl_fprintf(file, "%.0f-%.0f%%\t%8u (%5.1f%%)\n", ((double )i * 100.0) / (double )n_bins,
                ((double )(i + 1U) * 100.0) / (double )n_bins, *(bins + i), (100.0 * (double )*(bins + i)) / (double )total);
#line 121
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 130 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_log_histogram_print(FILE *file , char const   *name , char const   *msg ,
                                       unsigned int n_bins , unsigned int *bins ) 
{ 
  unsigned int i ;
  unsigned int total ;
  unsigned int max_width ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 138
  total = 0U;
#line 139
  i = 0U;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < n_bins)) {
#line 139
      goto while_break;
    }
#line 140
    total += *(bins + i);
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (! total) {
#line 143
    return;
  }
#line 146
  i = n_bins;
  {
#line 146
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 146
    if (i > 3U) {
#line 146
      if (! (! *(bins + (i - 1U)))) {
#line 146
        goto while_break___0;
      }
    } else {
#line 146
      goto while_break___0;
    }
#line 147
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 146
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 148
  n_bins = i;
#line 151
  max_width = 2U * (unsigned int )(0.30103 * (double )(n_bins - 1U) + 0.9999) + 1U;
#line 153
  rpl_fprintf(file, "%s %s", name, msg);
#line 154
  i = 0U;
  }
  {
#line 154
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 154
    if (! (i < 2U)) {
#line 154
      goto while_break___1;
    }
    {
#line 155
    rpl_fprintf(file, "%*d\t%8u (%5.1f%%)\n", max_width, i, *(bins + i), (100.0 * (double )*(bins + i)) / (double )total);
#line 154
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 158
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 158
    if (! (i < n_bins)) {
#line 158
      goto while_break___2;
    }
    {
#line 159
    rpl_fprintf(file, "%*lu-%lu\t%8u (%5.1f%%)\n", max_width - ((unsigned int )(0.30103 * (double )i + 0.9999) + 1U),
                1UL << (i - 1U), (1UL << i) - 1UL, *(bins + i), (100.0 * (double )*(bins + i)) / (double )total);
#line 158
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 165
  return;
}
}
#line 169 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_print_1(FILE *file , char const   *name , struct bitset_type_info_struct *stats ) 
{ 
  double tmp ;
  char *tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  char *tmp___4 ;
  double tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 173
  if (! stats) {
#line 174
    return;
  }
  {
#line 176
  rpl_fprintf(file, "%s:\n", name);
  }
#line 177
  if (stats->allocs) {
#line 177
    tmp = (100.0 * (double )stats->frees) / (double )stats->allocs;
  } else {
#line 177
    tmp = (double )0;
  }
  {
#line 177
  tmp___0 = gettext("%u bitset_allocs, %u freed (%.2f%%).\n");
#line 177
  rpl_fprintf(file, (char const   *)tmp___0, stats->allocs, stats->frees, tmp);
  }
#line 180
  if (stats->sets) {
#line 180
    tmp___1 = (100.0 * (double )stats->cache_sets) / (double )stats->sets;
  } else {
#line 180
    tmp___1 = (double )0;
  }
  {
#line 180
  tmp___2 = gettext("%u bitset_sets, %u cached (%.2f%%)\n");
#line 180
  rpl_fprintf(file, (char const   *)tmp___2, stats->sets, stats->cache_sets, tmp___1);
  }
#line 183
  if (stats->resets) {
#line 183
    tmp___3 = (100.0 * (double )stats->cache_resets) / (double )stats->resets;
  } else {
#line 183
    tmp___3 = (double )0;
  }
  {
#line 183
  tmp___4 = gettext("%u bitset_resets, %u cached (%.2f%%)\n");
#line 183
  rpl_fprintf(file, (char const   *)tmp___4, stats->resets, stats->cache_resets, tmp___3);
  }
#line 186
  if (stats->tests) {
#line 186
    tmp___5 = (100.0 * (double )stats->cache_tests) / (double )stats->tests;
  } else {
#line 186
    tmp___5 = (double )0;
  }
  {
#line 186
  tmp___6 = gettext("%u bitset_tests, %u cached (%.2f%%)\n");
#line 186
  rpl_fprintf(file, (char const   *)tmp___6, stats->tests, stats->cache_tests, tmp___5);
#line 190
  tmp___7 = gettext("%u bitset_lists\n");
#line 190
  rpl_fprintf(file, (char const   *)tmp___7, stats->lists);
#line 192
  tmp___8 = gettext("count log histogram\n");
#line 192
  bitset_log_histogram_print(file, name, (char const   *)tmp___8, 10U, stats->list_counts);
#line 195
  tmp___9 = gettext("size log histogram\n");
#line 195
  bitset_log_histogram_print(file, name, (char const   *)tmp___9, 16U, stats->list_sizes);
#line 198
  tmp___10 = gettext("density histogram\n");
#line 198
  bitset_percent_histogram_print(file, name, (char const   *)tmp___10, 20U, stats->list_density);
  }
#line 200
  return;
}
}
#line 204 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_print(FILE *file , _Bool verbose  __attribute__((__unused__)) ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 209
  if (! bitset_stats_info) {
#line 210
    return;
  }
  {
#line 212
  tmp = gettext("Bitset statistics:\n\n");
#line 212
  rpl_fprintf(file, (char const   *)tmp);
  }
#line 214
  if (bitset_stats_info->runs > 1U) {
    {
#line 215
    tmp___0 = gettext("Accumulated runs = %u\n");
#line 215
    rpl_fprintf(file, (char const   *)tmp___0, bitset_stats_info->runs);
    }
  }
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < 4)) {
#line 217
      goto while_break;
    }
    {
#line 218
    bitset_stats_print_1(file, (char const   *)bitset_type_names[i], & bitset_stats_info->types[i]);
#line 217
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 224 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
void bitset_stats_enable(void) 
{ 


  {
#line 227
  if (! bitset_stats_info) {
#line 228
    bitset_stats_info = & bitset_stats_info_data;
  }
#line 229
  bitset_stats_enabled = (_Bool)1;
#line 230
  return;
}
}
#line 233 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
void bitset_stats_disable(void) 
{ 


  {
#line 236
  bitset_stats_enabled = (_Bool)0;
#line 237
  return;
}
}
#line 241 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
void bitset_stats_read(char const   *file_name ) 
{ 
  FILE *file ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 246
  if (! bitset_stats_info) {
#line 247
    return;
  }
#line 249
  if (! file_name) {
#line 250
    file_name = "bitset.dat";
  }
  {
#line 252
  file = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
  }
#line 253
  if (file) {
    {
#line 255
    tmp___2 = fread_unlocked((void */* __restrict  */)(& bitset_stats_info_data),
                             (size_t )sizeof(bitset_stats_info_data), (size_t )1,
                             (FILE */* __restrict  */)file);
    }
#line 255
    if (tmp___2 != 1U) {
      {
#line 258
      tmp___1 = ferror_unlocked(file);
      }
#line 258
      if (tmp___1) {
        {
#line 259
        tmp = gettext("Could not read stats file.");
#line 259
        perror((char const   *)tmp);
        }
      } else {
        {
#line 261
        tmp___0 = gettext("Bad stats file size.\n");
#line 261
        rpl_fprintf(stderr, (char const   *)tmp___0);
        }
      }
    }
    {
#line 263
    tmp___4 = fclose(file);
    }
#line 263
    if (tmp___4 != 0) {
      {
#line 264
      tmp___3 = gettext("Could not read stats file.");
#line 264
      perror((char const   *)tmp___3);
      }
    }
  }
#line 266
  (bitset_stats_info_data.runs) ++;
#line 267
  return;
}
}
#line 271 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
void bitset_stats_write(char const   *file_name ) 
{ 
  FILE *file ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 276
  if (! bitset_stats_info) {
#line 277
    return;
  }
#line 279
  if (! file_name) {
#line 280
    file_name = "bitset.dat";
  }
  {
#line 282
  file = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"w");
  }
#line 283
  if (file) {
    {
#line 285
    tmp___0 = fwrite_unlocked((void const   */* __restrict  */)(& bitset_stats_info_data),
                              (size_t )sizeof(bitset_stats_info_data), (size_t )1,
                              (FILE */* __restrict  */)file);
    }
#line 285
    if (tmp___0 != 1U) {
      {
#line 287
      tmp = gettext("Could not write stats file.");
#line 287
      perror((char const   *)tmp);
      }
    }
    {
#line 288
    tmp___2 = fclose(file);
    }
#line 288
    if (tmp___2 != 0) {
      {
#line 289
      tmp___1 = gettext("Could not write stats file.");
#line 289
      perror((char const   *)tmp___1);
      }
    }
  } else {
    {
#line 292
    tmp___3 = gettext("Could not open stats file for writing.");
#line 292
    perror((char const   *)tmp___3);
    }
  }
#line 293
  return;
}
}
#line 297 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
void bitset_stats_dump(FILE *file ) 
{ 


  {
  {
#line 300
  bitset_stats_print(file, (_Bool)0);
  }
#line 301
  return;
}
}
#line 305 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
void debug_bitset_stats(void) 
{ 


  {
  {
#line 308
  bitset_stats_print(stderr, (_Bool)1);
  }
#line 309
  return;
}
}
#line 312 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_set(bitset dst , bitset_bindex bitno ) 
{ 
  bitset bset ;
  bitset_windex wordno ;
  bitset_windex offset ;

  {
#line 315
  bset = dst->s.bset;
#line 316
  wordno = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 317
  offset = wordno - bset->b.cindex;
#line 319
  (bitset_stats_info->types[(bset->b.vtable)->type].sets) ++;
#line 321
  if (offset < bset->b.csize) {
#line 323
    *(bset->b.cdata + offset) |= 1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word ));
#line 324
    (bitset_stats_info->types[(bset->b.vtable)->type].cache_sets) ++;
  } else {
    {
#line 327
    (*((bset->b.vtable)->set))(bset, bitno);
    }
  }
#line 328
  return;
}
}
#line 331 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_reset(bitset dst , bitset_bindex bitno ) 
{ 
  bitset bset ;
  bitset_windex wordno ;
  bitset_windex offset ;

  {
#line 334
  bset = dst->s.bset;
#line 335
  wordno = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 336
  offset = wordno - bset->b.cindex;
#line 338
  (bitset_stats_info->types[(bset->b.vtable)->type].resets) ++;
#line 340
  if (offset < bset->b.csize) {
#line 342
    *(bset->b.cdata + offset) &= ~ (1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word )));
#line 344
    (bitset_stats_info->types[(bset->b.vtable)->type].cache_resets) ++;
  } else {
    {
#line 347
    (*((bset->b.vtable)->reset))(bset, bitno);
    }
  }
#line 348
  return;
}
}
#line 351 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_toggle(bitset src , bitset_bindex bitno ) 
{ 
  _Bool tmp ;

  {
  {
#line 354
  tmp = (*(((src->s.bset)->b.vtable)->toggle))(src->s.bset, bitno);
  }
#line 354
  return (tmp);
}
}
#line 358 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_test(bitset src , bitset_bindex bitno ) 
{ 
  bitset bset ;
  bitset_windex wordno ;
  bitset_windex offset ;
  _Bool tmp ;

  {
#line 361
  bset = src->s.bset;
#line 362
  wordno = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 363
  offset = wordno - bset->b.cindex;
#line 365
  (bitset_stats_info->types[(bset->b.vtable)->type].tests) ++;
#line 367
  if (offset < bset->b.csize) {
#line 369
    (bitset_stats_info->types[(bset->b.vtable)->type].cache_tests) ++;
#line 370
    return ((_Bool )((*(bset->b.cdata + offset) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ))) & 1UL));
  } else {
    {
#line 373
    tmp = (*((bset->b.vtable)->test))(bset, bitno);
    }
#line 373
    return (tmp);
  }
}
}
#line 377 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static bitset_bindex bitset_stats_resize(bitset src , bitset_bindex size ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 380
  tmp = (*(((src->s.bset)->b.vtable)->resize))(src->s.bset, size);
  }
#line 380
  return (tmp);
}
}
#line 384 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static bitset_bindex bitset_stats_size(bitset src ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 387
  tmp = (*(((src->s.bset)->b.vtable)->size))(src->s.bset);
  }
#line 387
  return (tmp);
}
}
#line 391 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static bitset_bindex bitset_stats_count(bitset src ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 394
  tmp = (*(((src->s.bset)->b.vtable)->count))(src->s.bset);
  }
#line 394
  return (tmp);
}
}
#line 398 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_empty_p(bitset dst ) 
{ 
  _Bool tmp ;

  {
  {
#line 401
  tmp = (*(((dst->s.bset)->b.vtable)->empty_p))(dst->s.bset);
  }
#line 401
  return (tmp);
}
}
#line 405 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_ones(bitset dst ) 
{ 


  {
  {
#line 408
  (*(((dst->s.bset)->b.vtable)->ones))(dst->s.bset);
  }
#line 409
  return;
}
}
#line 412 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_zero(bitset dst ) 
{ 


  {
  {
#line 415
  (*(((dst->s.bset)->b.vtable)->zero))(dst->s.bset);
  }
#line 416
  return;
}
}
#line 419 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_copy(bitset dst , bitset src ) 
{ 


  {
#line 422
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 422
    abort();
    }
  }
  {
#line 423
  (*(((src->s.bset)->b.vtable)->copy))(dst->s.bset, src->s.bset);
  }
#line 424
  return;
}
}
#line 427 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_disjoint_p(bitset dst , bitset src ) 
{ 
  _Bool tmp ;

  {
#line 430
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 430
    abort();
    }
  }
  {
#line 431
  tmp = (*(((src->s.bset)->b.vtable)->disjoint_p))(dst->s.bset, src->s.bset);
  }
#line 431
  return (tmp);
}
}
#line 435 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_equal_p(bitset dst , bitset src ) 
{ 
  _Bool tmp ;

  {
#line 438
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 438
    abort();
    }
  }
  {
#line 439
  tmp = (*(((src->s.bset)->b.vtable)->equal_p))(dst->s.bset, src->s.bset);
  }
#line 439
  return (tmp);
}
}
#line 443 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_not(bitset dst , bitset src ) 
{ 


  {
#line 446
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 446
    abort();
    }
  }
  {
#line 447
  (*(((src->s.bset)->b.vtable)->not_))(dst->s.bset, src->s.bset);
  }
#line 448
  return;
}
}
#line 451 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_subset_p(bitset dst , bitset src ) 
{ 
  _Bool tmp ;

  {
#line 454
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 454
    abort();
    }
  }
  {
#line 455
  tmp = (*(((src->s.bset)->b.vtable)->subset_p))(dst->s.bset, src->s.bset);
  }
#line 455
  return (tmp);
}
}
#line 459 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_and(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
#line 462
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 462
    abort();
    }
  } else
#line 462
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 462
    abort();
    }
  }
  {
#line 463
  (*(((src1->s.bset)->b.vtable)->and_))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 464
  return;
}
}
#line 467 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_and_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;

  {
#line 470
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 470
    abort();
    }
  } else
#line 470
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 470
    abort();
    }
  }
  {
#line 471
  tmp = (*(((src1->s.bset)->b.vtable)->and_cmp))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 471
  return (tmp);
}
}
#line 475 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_andn(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
#line 478
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 478
    abort();
    }
  } else
#line 478
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 478
    abort();
    }
  }
  {
#line 479
  (*(((src1->s.bset)->b.vtable)->andn))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 480
  return;
}
}
#line 483 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_andn_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;

  {
#line 486
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 486
    abort();
    }
  } else
#line 486
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 486
    abort();
    }
  }
  {
#line 487
  tmp = (*(((src1->s.bset)->b.vtable)->andn_cmp))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 487
  return (tmp);
}
}
#line 491 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_or(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
#line 494
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 494
    abort();
    }
  } else
#line 494
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 494
    abort();
    }
  }
  {
#line 495
  (*(((src1->s.bset)->b.vtable)->or_))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 496
  return;
}
}
#line 499 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_or_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;

  {
#line 502
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 502
    abort();
    }
  } else
#line 502
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 502
    abort();
    }
  }
  {
#line 503
  tmp = (*(((src1->s.bset)->b.vtable)->or_cmp))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 503
  return (tmp);
}
}
#line 507 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_xor(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
#line 510
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 510
    abort();
    }
  } else
#line 510
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 510
    abort();
    }
  }
  {
#line 511
  (*(((src1->s.bset)->b.vtable)->xor_))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 512
  return;
}
}
#line 515 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_xor_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;

  {
#line 518
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 518
    abort();
    }
  } else
#line 518
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 518
    abort();
    }
  }
  {
#line 519
  tmp = (*(((src1->s.bset)->b.vtable)->xor_cmp))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 519
  return (tmp);
}
}
#line 523 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_and_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
#line 526
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 526
    abort();
    }
  } else
#line 526
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 526
    abort();
    }
  } else
#line 526
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 526
    abort();
    }
  }
  {
#line 527
  (*(((src1->s.bset)->b.vtable)->and_or))(dst->s.bset, src1->s.bset, src2->s.bset,
                                          src3->s.bset);
  }
#line 528
  return;
}
}
#line 531 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_and_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
#line 534
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 534
    abort();
    }
  } else
#line 534
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 534
    abort();
    }
  } else
#line 534
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 534
    abort();
    }
  }
  {
#line 535
  tmp = (*(((src1->s.bset)->b.vtable)->and_or_cmp))(dst->s.bset, src1->s.bset, src2->s.bset,
                                                    src3->s.bset);
  }
#line 535
  return (tmp);
}
}
#line 539 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_andn_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
#line 542
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 542
    abort();
    }
  } else
#line 542
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 542
    abort();
    }
  } else
#line 542
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 542
    abort();
    }
  }
  {
#line 543
  (*(((src1->s.bset)->b.vtable)->andn_or))(dst->s.bset, src1->s.bset, src2->s.bset,
                                           src3->s.bset);
  }
#line 544
  return;
}
}
#line 547 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_andn_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
#line 550
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 550
    abort();
    }
  } else
#line 550
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 550
    abort();
    }
  } else
#line 550
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 550
    abort();
    }
  }
  {
#line 551
  tmp = (*(((src1->s.bset)->b.vtable)->andn_or_cmp))(dst->s.bset, src1->s.bset, src2->s.bset,
                                                     src3->s.bset);
  }
#line 551
  return (tmp);
}
}
#line 555 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_or_and(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
#line 558
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 558
    abort();
    }
  } else
#line 558
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 558
    abort();
    }
  } else
#line 558
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 558
    abort();
    }
  }
  {
#line 559
  (*(((src1->s.bset)->b.vtable)->or_and))(dst->s.bset, src1->s.bset, src2->s.bset,
                                          src3->s.bset);
  }
#line 560
  return;
}
}
#line 563 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static _Bool bitset_stats_or_and_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
#line 566
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 566
    abort();
    }
  } else
#line 566
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 566
    abort();
    }
  } else
#line 566
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 566
    abort();
    }
  }
  {
#line 567
  tmp = (*(((src1->s.bset)->b.vtable)->or_and_cmp))(dst->s.bset, src1->s.bset, src2->s.bset,
                                                    src3->s.bset);
  }
#line 567
  return (tmp);
}
}
#line 571 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static bitset_bindex bitset_stats_list(bitset bset , bitset_bindex *list , bitset_bindex num ,
                                       bitset_bindex *next ) 
{ 
  bitset_bindex count ;
  bitset_bindex tmp ;
  bitset_bindex size ;
  bitset_bindex i ;
  enum bitset_type type ;

  {
  {
#line 581
  count = (*(((bset->s.bset)->b.vtable)->list))(bset->s.bset, list, num, next);
#line 583
  type = (enum bitset_type )((bset->s.bset)->b.vtable)->type;
#line 584
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].lists) ++;
#line 587
  i = (bitset_bindex )0;
#line 587
  tmp = count;
  }
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! tmp) {
#line 587
      goto while_break;
    }
#line 588
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 587
    tmp >>= 1;
#line 587
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  if (i >= 10U) {
#line 590
    i = (bitset_bindex )9;
  }
  {
#line 591
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].list_counts[i]) ++;
#line 594
  size = (*(((bset->s.bset)->b.vtable)->size))(bset->s.bset);
#line 595
  i = (bitset_bindex )0;
#line 595
  tmp = size;
  }
  {
#line 595
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 595
    if (! tmp) {
#line 595
      goto while_break___0;
    }
#line 596
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 595
    tmp >>= 1;
#line 595
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 597
  if (i >= 16U) {
#line 598
    i = (bitset_bindex )15;
  }
#line 599
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].list_sizes[i]) ++;
#line 602
  if (size) {
#line 602
    i = (count * 20U) / size;
  } else {
#line 602
    i = (bitset_bindex )0;
  }
#line 603
  if (i >= 20U) {
#line 604
    i = (bitset_bindex )19;
  }
#line 605
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].list_density[i]) ++;
#line 606
  return (count);
}
}
#line 610 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static bitset_bindex bitset_stats_list_reverse(bitset bset , bitset_bindex *list ,
                                               bitset_bindex num , bitset_bindex *next ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 614
  tmp = (*(((bset->s.bset)->b.vtable)->list_reverse))(bset->s.bset, list, num, next);
  }
#line 614
  return (tmp);
}
}
#line 618 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
static void bitset_stats_free(bitset bset ) 
{ 


  {
#line 621
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].frees) ++;
#line 622
  if (((bset->s.bset)->b.vtable)->free) {
    {
#line 622
    (*(((bset->s.bset)->b.vtable)->free))(bset->s.bset);
    }
  }
#line 623
  return;
}
}
#line 626 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
struct bitset_vtable bitset_stats_vtable  = 
#line 626
     {& bitset_stats_set, & bitset_stats_reset, & bitset_stats_toggle, & bitset_stats_test,
    & bitset_stats_resize, & bitset_stats_size, & bitset_stats_count, & bitset_stats_empty_p,
    & bitset_stats_ones, & bitset_stats_zero, & bitset_stats_copy, & bitset_stats_disjoint_p,
    & bitset_stats_equal_p, & bitset_stats_not, & bitset_stats_subset_p, & bitset_stats_and,
    & bitset_stats_and_cmp, & bitset_stats_andn, & bitset_stats_andn_cmp, & bitset_stats_or,
    & bitset_stats_or_cmp, & bitset_stats_xor, & bitset_stats_xor_cmp, & bitset_stats_and_or,
    & bitset_stats_and_or_cmp, & bitset_stats_andn_or, & bitset_stats_andn_or_cmp,
    & bitset_stats_or_and, & bitset_stats_or_and_cmp, & bitset_stats_list, & bitset_stats_list_reverse,
    & bitset_stats_free, (enum bitset_type )5};
#line 664 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
enum bitset_type bitset_stats_type_get(bitset bset ) 
{ 


  {
#line 667
  return ((enum bitset_type )((bset->s.bset)->b.vtable)->type);
}
}
#line 671 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
size_t bitset_stats_bytes(void) 
{ 


  {
#line 674
  return ((size_t )sizeof(struct bitset_stats_struct ));
}
}
#line 678 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset_stats.c"
bitset bitset_stats_init(bitset bset , bitset_bindex n_bits , enum bitset_type type ) 
{ 
  size_t bytes ;
  bitset sbset ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 684
  bset->b.vtable = (struct bitset_vtable  const  *)(& bitset_stats_vtable);
#line 687
  bset->b.cindex = (bitset_windex )0;
#line 688
  bset->b.csize = (bitset_windex )0;
#line 689
  bset->b.cdata = (bitset_word *)0;
#line 691
  bset->b.n_bits = n_bits;
  {
#line 700
  if ((unsigned int )type == 0U) {
#line 700
    goto case_0;
  }
#line 706
  if ((unsigned int )type == 1U) {
#line 706
    goto case_1;
  }
#line 712
  if ((unsigned int )type == 2U) {
#line 712
    goto case_2;
  }
#line 718
  if ((unsigned int )type == 3U) {
#line 718
    goto case_3;
  }
#line 697
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 698
  abort();
  }
  case_0: /* CIL Label */ 
  {
#line 701
  bytes = abitset_bytes(n_bits);
#line 702
  tmp = xcalloc((size_t )1, bytes);
#line 702
  sbset = (bitset )tmp;
#line 703
  abitset_init(sbset, n_bits);
  }
#line 704
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 707
  bytes = lbitset_bytes(n_bits);
#line 708
  tmp___0 = xcalloc((size_t )1, bytes);
#line 708
  sbset = (bitset )tmp___0;
#line 709
  lbitset_init(sbset, n_bits);
  }
#line 710
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 713
  bytes = ebitset_bytes(n_bits);
#line 714
  tmp___1 = xcalloc((size_t )1, bytes);
#line 714
  sbset = (bitset )tmp___1;
#line 715
  ebitset_init(sbset, n_bits);
  }
#line 716
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 719
  bytes = vbitset_bytes(n_bits);
#line 720
  tmp___2 = xcalloc((size_t )1, bytes);
#line 720
  sbset = (bitset )tmp___2;
#line 721
  vbitset_init(sbset, n_bits);
  }
#line 722
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 725
  bset->s.bset = sbset;
#line 727
  (bitset_stats_info->types[type].allocs) ++;
#line 729
  return (bset);
}
}
#line 111 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
bitset bitset_alloc(bitset_bindex n_bits , enum bitset_type type ) ;
#line 114
void bitset_free(bitset bset ) ;
#line 118
bitset bitset_obstack_alloc(struct obstack *bobstack , bitset_bindex n_bits , enum bitset_type type ) ;
#line 122
void bitset_obstack_free(bitset bset ) ;
#line 125
bitset bitset_create(bitset_bindex n_bits , unsigned int attr ) ;
#line 128
enum bitset_type bitset_type_get(bitset bset ) ;
#line 131
char const   *bitset_type_name_get(bitset bset ) ;
#line 149 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.h"
__inline static void bitset_reset(bitset bset , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  bitset_windex offset ;

  {
#line 152
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 153
  offset = windex - bset->b.cindex;
#line 155
  if (offset < bset->b.csize) {
#line 156
    *(bset->b.cdata + offset) &= ~ (1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word )));
  } else {
    {
#line 158
    (*((bset->b.vtable)->reset))(bset, bitno);
    }
  }
#line 159
  return;
}
}
#line 283
extern _Bool bitset_compatible_p(bitset bset1 , bitset bset2 ) ;
#line 286
bitset_bindex bitset_next(bitset src , bitset_bindex bitno ) ;
#line 289
bitset_bindex bitset_prev(bitset src , bitset_bindex bitno ) ;
#line 292
bitset_bindex bitset_first(bitset src ) ;
#line 295
bitset_bindex bitset_last(bitset src ) ;
#line 298
_Bool bitset_only_set_p(bitset src , bitset_bindex bitno ) ;
#line 370
void bitset_release_memory(void) ;
#line 33 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
char const   * const  bitset_type_names[4]  = {      (char const   */* const  */)"abitset",      (char const   */* const  */)"lbitset",      (char const   */* const  */)"ebitset",      (char const   */* const  */)"vbitset"};
#line 38 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
size_t bitset_bytes(enum bitset_type type , bitset_bindex n_bits ) 
{ 
  size_t bytes ;
  size_t tmp ;

  {
#line 43
  if (bitset_stats_enabled) {
    {
#line 44
    tmp = bitset_stats_bytes();
    }
#line 44
    return (tmp);
  }
  {
#line 51
  if ((unsigned int )type == 0U) {
#line 51
    goto case_0;
  }
#line 55
  if ((unsigned int )type == 1U) {
#line 55
    goto case_1;
  }
#line 59
  if ((unsigned int )type == 2U) {
#line 59
    goto case_2;
  }
#line 63
  if ((unsigned int )type == 3U) {
#line 63
    goto case_3;
  }
#line 48
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 49
  abort();
  }
  case_0: /* CIL Label */ 
  {
#line 52
  bytes = abitset_bytes(n_bits);
  }
#line 53
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 56
  bytes = lbitset_bytes(n_bits);
  }
#line 57
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 60
  bytes = ebitset_bytes(n_bits);
  }
#line 61
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 64
  bytes = vbitset_bytes(n_bits);
  }
#line 65
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 68
  return (bytes);
}
}
#line 73 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset bitset_init(bitset bset , bitset_bindex n_bits , enum bitset_type type ) 
{ 
  bitset tmp ;
  bitset tmp___0 ;
  bitset tmp___1 ;
  bitset tmp___2 ;
  bitset tmp___3 ;

  {
#line 76
  if (bitset_stats_enabled) {
    {
#line 77
    tmp = bitset_stats_init(bset, n_bits, type);
    }
#line 77
    return (tmp);
  }
  {
#line 84
  if ((unsigned int )type == 0U) {
#line 84
    goto case_0;
  }
#line 87
  if ((unsigned int )type == 1U) {
#line 87
    goto case_1;
  }
#line 90
  if ((unsigned int )type == 2U) {
#line 90
    goto case_2;
  }
#line 93
  if ((unsigned int )type == 3U) {
#line 93
    goto case_3;
  }
#line 81
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 82
  abort();
  }
  case_0: /* CIL Label */ 
  {
#line 85
  tmp___0 = abitset_init(bset, n_bits);
  }
#line 85
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 88
  tmp___1 = lbitset_init(bset, n_bits);
  }
#line 88
  return (tmp___1);
  case_2: /* CIL Label */ 
  {
#line 91
  tmp___2 = ebitset_init(bset, n_bits);
  }
#line 91
  return (tmp___2);
  case_3: /* CIL Label */ 
  {
#line 94
  tmp___3 = vbitset_init(bset, n_bits);
  }
#line 94
  return (tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 102 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
enum bitset_type bitset_type_choose(bitset_bindex n_bits  __attribute__((__unused__)) ,
                                    unsigned int attr ) 
{ 


  {
#line 106
  if (attr & 1U) {
#line 106
    if (attr & 2U) {
      {
#line 107
      abort();
      }
    }
  }
#line 108
  if (attr & 8U) {
#line 108
    if (attr & 4U) {
      {
#line 109
      abort();
      }
    }
  }
#line 116
  if (! attr) {
#line 117
    return ((enum bitset_type )3);
  }
#line 119
  if (attr & 8U) {
#line 120
    return ((enum bitset_type )1);
  }
#line 122
  if (attr & 1U) {
#line 123
    return ((enum bitset_type )0);
  }
#line 125
  if (attr & 32U) {
#line 126
    return ((enum bitset_type )2);
  }
#line 128
  return ((enum bitset_type )3);
}
}
#line 133 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset bitset_alloc(bitset_bindex n_bits , enum bitset_type type ) 
{ 
  size_t bytes ;
  bitset bset ;
  void *tmp ;
  bitset tmp___0 ;

  {
  {
#line 139
  bytes = bitset_bytes(type, n_bits);
#line 141
  tmp = xcalloc((size_t )1, bytes);
#line 141
  bset = (bitset )tmp;
#line 147
  tmp___0 = bitset_init(bset, n_bits, type);
  }
#line 147
  return (tmp___0);
}
}
#line 152 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset bitset_obstack_alloc(struct obstack *bobstack , bitset_bindex n_bits , enum bitset_type type ) 
{ 
  size_t bytes ;
  bitset bset ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  bitset tmp___1 ;

  {
  {
#line 159
  bytes = bitset_bytes(type, n_bits);
#line 161
  __h = bobstack;
#line 161
  __o = __h;
#line 161
  __len = (int )bytes;
  }
#line 161
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 161
    _obstack_newchunk(__o, __len);
    }
  }
#line 161
  __o->next_free += __len;
#line 161
  __o1 = __h;
#line 161
  __value = (void *)__o1->object_base;
#line 161
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 161
    __o1->maybe_empty_object = 1U;
  }
#line 161
  if (sizeof(int ) < sizeof(void *)) {
#line 161
    tmp = __o1->object_base;
  } else {
#line 161
    tmp = (char *)0;
  }
#line 161
  if (sizeof(int ) < sizeof(void *)) {
#line 161
    tmp___0 = __o1->object_base;
  } else {
#line 161
    tmp___0 = (char *)0;
  }
#line 161
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 161
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 161
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 161
  __o1->object_base = __o1->next_free;
#line 161
  bset = (bitset )__value;
#line 162
  memset((void *)bset, 0, bytes);
#line 164
  tmp___1 = bitset_init(bset, n_bits, type);
  }
#line 164
  return (tmp___1);
}
}
#line 170 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset bitset_create(bitset_bindex n_bits , unsigned int attr ) 
{ 
  enum bitset_type type ;
  bitset tmp ;

  {
  {
#line 175
  type = bitset_type_choose(n_bits, attr);
#line 177
  tmp = bitset_alloc(n_bits, type);
  }
#line 177
  return (tmp);
}
}
#line 182 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
void bitset_free(bitset bset ) 
{ 


  {
#line 185
  if ((bset->b.vtable)->free) {
    {
#line 185
    (*((bset->b.vtable)->free))(bset);
    }
  }
  {
#line 186
  free((void *)bset);
  }
#line 187
  return;
}
}
#line 191 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
void bitset_obstack_free(bitset bset ) 
{ 


  {
#line 194
  if ((bset->b.vtable)->free) {
    {
#line 194
    (*((bset->b.vtable)->free))(bset);
    }
  }
#line 195
  return;
}
}
#line 199 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
enum bitset_type bitset_type_get(bitset bset ) 
{ 
  enum bitset_type type ;
  enum bitset_type tmp ;

  {
#line 204
  type = (enum bitset_type )(bset->b.vtable)->type;
#line 205
  if ((unsigned int )type != 5U) {
#line 206
    return (type);
  }
  {
#line 208
  tmp = bitset_stats_type_get(bset);
  }
#line 208
  return (tmp);
}
}
#line 213 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
char const   *bitset_type_name_get(bitset bset ) 
{ 
  enum bitset_type type ;

  {
  {
#line 218
  type = bitset_type_get(bset);
  }
#line 220
  return ((char const   *)bitset_type_names[type]);
}
}
#line 226 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset_bindex bitset_next(bitset src , bitset_bindex bitno ) 
{ 
  bitset_bindex val ;
  bitset_bindex next ;
  bitset_bindex tmp ;

  {
  {
#line 230
  next = bitno;
#line 232
  tmp = (*((src->b.vtable)->list))(src, & val, (bitset_bindex )1, & next);
  }
#line 232
  if (! tmp) {
#line 233
    return ((bitset_bindex )-1);
  }
#line 234
  return (val);
}
}
#line 239 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
extern _Bool bitset_compatible_p(bitset bset1 , bitset bset2 ) 
{ 


  {
#line 242
  return ((_Bool )((unsigned long )bset1->b.vtable == (unsigned long )bset2->b.vtable));
}
}
#line 248 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset_bindex bitset_prev(bitset src , bitset_bindex bitno ) 
{ 
  bitset_bindex val ;
  bitset_bindex next ;
  bitset_bindex tmp ;

  {
  {
#line 252
  next = bitno;
#line 254
  tmp = (*((src->b.vtable)->list_reverse))(src, & val, (bitset_bindex )1, & next);
  }
#line 254
  if (! tmp) {
#line 255
    return ((bitset_bindex )-1);
  }
#line 256
  return (val);
}
}
#line 261 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset_bindex bitset_first(bitset src ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 264
  tmp = bitset_next(src, (bitset_bindex )0);
  }
#line 264
  return (tmp);
}
}
#line 269 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset_bindex bitset_last(bitset src ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 272
  tmp = bitset_prev(src, (bitset_bindex )0);
  }
#line 272
  return (tmp);
}
}
#line 277 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
_Bool bitset_only_set_p(bitset src , bitset_bindex bitno ) 
{ 
  bitset_bindex val[2] ;
  bitset_bindex next ;
  bitset_bindex tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 281
  next = (bitset_bindex )0;
#line 283
  tmp = (*((src->b.vtable)->list))(src, val, (bitset_bindex )2, & next);
  }
#line 283
  if (tmp != 1U) {
#line 284
    return ((_Bool)0);
  }
#line 285
  return ((_Bool )(val[0] == bitno));
}
}
#line 290 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
static void bitset_print(FILE *file , bitset bset , _Bool verbose ) 
{ 
  unsigned int pos___0 ;
  bitset_bindex i ;
  bitset_iterator iter ;
  bitset_bindex tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 297
  if (verbose) {
    {
#line 298
    tmp = (*((bset->b.vtable)->size))(bset);
#line 298
    rpl_fprintf(file, "n_bits = %lu, set = {", (unsigned long )tmp);
    }
  }
#line 301
  pos___0 = 30U;
#line 302
  iter.next = (bitset_bindex )0;
#line 302
  iter.num = (bitset_bindex )1024;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (iter.num == 1024U) {
      {
#line 302
      iter.num = (*((bset->b.vtable)->list))(bset, iter.list, (bitset_bindex )1024,
                                             & iter.next);
      }
#line 302
      if (! iter.num) {
#line 302
        goto while_break;
      }
    } else {
#line 302
      goto while_break;
    }
#line 302
    iter.i = (bitset_bindex )0;
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 302
      if (iter.i < iter.num) {
#line 302
        i = iter.list[iter.i];
      } else {
#line 302
        goto while_break___0;
      }
#line 304
      if (pos___0 > 70U) {
        {
#line 306
        rpl_fprintf(file, "\n");
#line 307
        pos___0 = 0U;
        }
      }
      {
#line 310
      rpl_fprintf(file, "%lu ", (unsigned long )i);
#line 311
      pos___0 += (unsigned int )((1 + (i >= 10U)) + (i >= 100U));
#line 302
      (iter.i) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  if (verbose) {
    {
#line 315
    rpl_fprintf(file, "}\n");
    }
  }
#line 316
  return;
}
}
#line 320 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
void bitset_dump(FILE *file , bitset bset ) 
{ 


  {
  {
#line 323
  bitset_print(file, bset, (_Bool)0);
  }
#line 324
  return;
}
}
#line 328 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
void bitset_release_memory(void) 
{ 


  {
  {
#line 331
  lbitset_release_memory();
#line 332
  ebitset_release_memory();
  }
#line 333
  return;
}
}
#line 337 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
_Bool bitset_toggle_(bitset bset , bitset_bindex bitno ) 
{ 
  _Bool tmp ;

  {
  {
#line 342
  tmp = bitset_test(bset, bitno);
  }
#line 342
  if (tmp) {
    {
#line 344
    bitset_reset(bset, bitno);
    }
#line 345
    return ((_Bool)0);
  } else {
    {
#line 349
    bitset_set(bset, bitno);
    }
#line 350
    return ((_Bool)1);
  }
}
}
#line 356 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset_bindex bitset_size_(bitset src ) 
{ 


  {
#line 359
  return (src->b.n_bits);
}
}
#line 364 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
bitset_bindex bitset_count_(bitset src ) 
{ 
  bitset_bindex list[1024] ;
  bitset_bindex next ;
  bitset_bindex num ;
  bitset_bindex count ;
  void *__cil_tmp6 ;

  {
#line 376
  next = (bitset_bindex )0;
#line 377
  count = (bitset_bindex )0;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 377
    num = (*((src->b.vtable)->list))(src, list, (bitset_bindex )1024, & next);
    }
#line 377
    if (! num) {
#line 377
      goto while_break;
    }
#line 379
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 377
    count += num;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return (count);
}
}
#line 388 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
_Bool bitset_copy_(bitset dst , bitset src ) 
{ 
  bitset_bindex i ;
  bitset_iterator iter ;

  {
  {
#line 396
  (*((dst->b.vtable)->zero))(dst);
#line 397
  iter.next = (bitset_bindex )0;
#line 397
  iter.num = (bitset_bindex )1024;
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (iter.num == 1024U) {
      {
#line 397
      iter.num = (*((src->b.vtable)->list))(src, iter.list, (bitset_bindex )1024,
                                            & iter.next);
      }
#line 397
      if (! iter.num) {
#line 397
        goto while_break;
      }
    } else {
#line 397
      goto while_break;
    }
#line 397
    iter.i = (bitset_bindex )0;
    {
#line 397
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 397
      if (iter.i < iter.num) {
#line 397
        i = iter.list[iter.i];
      } else {
#line 397
        goto while_break___0;
      }
      {
#line 399
      bitset_set(dst, i);
#line 397
      (iter.i) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  return ((_Bool)1);
}
}
#line 408 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
__inline static _Bool bitset_op4_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ,
                                     enum bitset_ops op ) 
{ 
  _Bool changed ;
  _Bool stats_enabled_save ;
  bitset tmp ;
  enum bitset_type tmp___0 ;

  {
  {
#line 412
  changed = (_Bool)0;
#line 417
  stats_enabled_save = bitset_stats_enabled;
#line 418
  bitset_stats_enabled = (_Bool)0;
#line 419
  tmp___0 = bitset_type_get(dst);
#line 419
  tmp = bitset_alloc((bitset_bindex )0, tmp___0);
#line 420
  bitset_stats_enabled = stats_enabled_save;
  }
  {
#line 427
  if ((unsigned int )op == 12U) {
#line 427
    goto case_12;
  }
#line 432
  if ((unsigned int )op == 13U) {
#line 432
    goto case_13;
  }
#line 437
  if ((unsigned int )op == 14U) {
#line 437
    goto case_14;
  }
#line 424
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 425
  abort();
  }
  case_12: /* CIL Label */ 
  {
#line 428
  (*((src1->b.vtable)->or_))(tmp, src1, src2);
#line 429
  changed = (*((src3->b.vtable)->and_cmp))(dst, src3, tmp);
  }
#line 430
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 433
  (*((src1->b.vtable)->and_))(tmp, src1, src2);
#line 434
  changed = (*((src3->b.vtable)->or_cmp))(dst, src3, tmp);
  }
#line 435
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 438
  (*((src1->b.vtable)->andn))(tmp, src1, src2);
#line 439
  changed = (*((src3->b.vtable)->or_cmp))(dst, src3, tmp);
  }
#line 440
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 443
  bitset_free(tmp);
  }
#line 444
  return (changed);
}
}
#line 449 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
void bitset_and_or_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
  {
#line 452
  bitset_and_or_cmp_(dst, src1, src2, src3);
  }
#line 453
  return;
}
}
#line 458 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
_Bool bitset_and_or_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
  {
#line 461
  tmp = bitset_op4_cmp(dst, src1, src2, src3, (enum bitset_ops )13);
  }
#line 461
  return (tmp);
}
}
#line 466 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
void bitset_andn_or_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
  {
#line 469
  bitset_andn_or_cmp_(dst, src1, src2, src3);
  }
#line 470
  return;
}
}
#line 475 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
_Bool bitset_andn_or_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
  {
#line 478
  tmp = bitset_op4_cmp(dst, src1, src2, src3, (enum bitset_ops )14);
  }
#line 478
  return (tmp);
}
}
#line 483 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
void bitset_or_and_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
  {
#line 486
  bitset_or_and_cmp_(dst, src1, src2, src3);
  }
#line 487
  return;
}
}
#line 492 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
_Bool bitset_or_and_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
  {
#line 495
  tmp = bitset_op4_cmp(dst, src1, src2, src3, (enum bitset_ops )12);
  }
#line 495
  return (tmp);
}
}
#line 500 "/home/pronto/abs/test-suite/bison-2.5/lib/bitset.c"
void debug_bitset(bitset bset ) 
{ 


  {
#line 503
  if (bset) {
    {
#line 504
    bitset_print(stderr, bset, (_Bool)1);
    }
  }
#line 505
  return;
}
}
#line 35 "/home/pronto/abs/test-suite/bison-2.5/lib/dirname.h"
char *base_name(char const   *name ) ;
#line 27 "/home/pronto/abs/test-suite/bison-2.5/lib/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base___0 ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  {
#line 30
  tmp = last_component(name);
#line 30
  base___0 = (char const   *)tmp;
  }
#line 35
  if (! *base___0) {
    {
#line 36
    tmp___0 = base_len(name);
#line 36
    tmp___1 = xstrndup(name, tmp___0);
    }
#line 36
    return (tmp___1);
  }
  {
#line 39
  length = base_len(base___0);
  }
#line 40
  if ((int const   )*(base___0 + length) == 47) {
#line 41
    length ++;
  }
  {
#line 57
  tmp___3 = xstrndup(base___0, length);
  }
#line 57
  return (tmp___3);
}
}
#line 29 "/home/pronto/abs/test-suite/bison-2.5/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base___0 ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base___0 = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base___0 == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base___0;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base___0 = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base___0);
}
}
#line 57 "/home/pronto/abs/test-suite/bison-2.5/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1U < len) {
#line 63
      if (! ((int const   )*(name + (len - 1U)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 73 "/home/pronto/abs/test-suite/bison-2.5/lib/vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 27 "/home/pronto/abs/test-suite/bison-2.5/lib/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 33
  __builtin_va_start(args, format);
#line 34
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 35
  __builtin_va_end(args);
  }
#line 36
  return (result);
}
}
#line 42 "/home/pronto/abs/test-suite/bison-2.5/lib/argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) ;
#line 52
void (*argmatch_die)(void) ;
#line 56
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 68
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 79
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 94
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 60 "/home/pronto/abs/test-suite/bison-2.5/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 63
  exit((int )exit_failure);
  }
}
}
#line 68 "/home/pronto/abs/test-suite/bison-2.5/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82 "/home/pronto/abs/test-suite/bison-2.5/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 88
  matchind = -1;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen = strlen(arg);
#line 94
  i = (size_t )0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! *(arglist + i)) {
#line 94
      goto while_break;
    }
    {
#line 96
    tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
    }
#line 96
    if (! tmp___1) {
      {
#line 98
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 98
      if (tmp___0 == arglen) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1) {
#line 103
        matchind = (ptrdiff_t )i;
      } else
#line 107
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
        {
#line 107
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 107
        if (tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (ambiguous) {
#line 119
    return (-2);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "/home/pronto/abs/test-suite/bison-2.5/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 132
  if (problem == -1) {
    {
#line 132
    tmp = gettext("invalid argument %s for %s");
#line 132
    tmp___1 = tmp;
    }
  } else {
    {
#line 132
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 132
    tmp___1 = tmp___0;
    }
  }
  {
#line 132
  format = (char const   *)tmp___1;
#line 136
  tmp___2 = quote_n(1, context);
#line 136
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
#line 136
  error(0, 0, format, tmp___3, tmp___2);
  }
#line 138
  return;
}
}
#line 144 "/home/pronto/abs/test-suite/bison-2.5/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  tmp = gettext("Valid arguments are:");
#line 153
  rpl_fprintf(stderr, (char const   *)tmp);
#line 154
  i = (size_t )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! *(arglist + i)) {
#line 154
      goto while_break;
    }
#line 155
    if (i == 0U) {
      {
#line 158
      rpl_fprintf(stderr, "\n  - `%s\'", *(arglist + i));
#line 159
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 155
      tmp___0 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 155
      if (tmp___0) {
        {
#line 158
        rpl_fprintf(stderr, "\n  - `%s\'", *(arglist + i));
#line 159
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 163
        rpl_fprintf(stderr, ", `%s\'", *(arglist + i));
        }
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  putc_unlocked('\n', stderr);
  }
#line 166
  return;
}
}
#line 174 "/home/pronto/abs/test-suite/bison-2.5/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 180
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = tmp;
  }
#line 181
  if (res >= 0) {
#line 183
    return (res);
  }
  {
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
  }
#line 190
  return (-1);
}
}
#line 195 "/home/pronto/abs/test-suite/bison-2.5/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 202
  i = (size_t )0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! *(arglist + i)) {
#line 202
      goto while_break;
    }
    {
#line 203
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
    }
#line 203
    if (! tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 35 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static bitset_bindex abitset_resize(bitset src , bitset_bindex size ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 39
  tmp = (*((src->b.vtable)->size))(src);
  }
#line 39
  if (tmp != size) {
    {
#line 40
    abort();
    }
  }
#line 42
  return (size);
}
}
#line 48 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static bitset_bindex abitset_small_list(bitset src , bitset_bindex *list , bitset_bindex num ,
                                        bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_bindex count ;
  bitset_windex size ;
  bitset_word word ;
  bitset_bindex tmp ;
  bitset_bindex tmp___0 ;

  {
#line 57
  word = src->a.words[0];
#line 60
  if (! word) {
#line 61
    return ((bitset_bindex )0);
  }
  {
#line 63
  size = (*((src->b.vtable)->size))(src);
#line 64
  bitno = *next;
  }
#line 65
  if (bitno >= size) {
#line 66
    return ((bitset_bindex )0);
  }
#line 68
  word >>= bitno;
#line 73
  if (num >= (unsigned int )(8UL * sizeof(bitset_word ))) {
#line 75
    count = (bitset_bindex )0;
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
#line 75
      if (! word) {
#line 75
        goto while_break;
      }
#line 77
      if (word & 1UL) {
#line 78
        tmp = count;
#line 78
        count ++;
#line 78
        *(list + tmp) = bitno;
      }
#line 79
      word >>= 1;
#line 75
      bitno ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 84
    count = (bitset_bindex )0;
    {
#line 84
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 84
      if (! word) {
#line 84
        goto while_break___0;
      }
#line 86
      if (word & 1UL) {
#line 88
        tmp___0 = count;
#line 88
        count ++;
#line 88
        *(list + tmp___0) = bitno;
#line 89
        if (count >= num) {
#line 91
          bitno ++;
#line 92
          goto while_break___0;
        }
      }
#line 95
      word >>= 1;
#line 84
      bitno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 99
  *next = bitno;
#line 100
  return (count);
}
}
#line 105 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_set(bitset dst  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 111
  abort();
  }
}
}
#line 116 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_reset(bitset dst  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) 
{ 


  {
#line 123
  return;
}
}
#line 127 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_test(bitset src  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) 
{ 


  {
#line 133
  return ((_Bool)0);
}
}
#line 141 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static bitset_bindex abitset_list_reverse(bitset src , bitset_bindex *list , bitset_bindex num ,
                                          bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_bindex rbitno ;
  bitset_bindex count ;
  bitset_windex windex ;
  unsigned int bitcnt ;
  bitset_bindex bitoff ;
  bitset_word *srcp ;
  bitset_bindex n_bits ;
  bitset_bindex tmp ;
  bitset_word word ;
  bitset_bindex tmp___0 ;
  bitset_windex tmp___1 ;

  {
  {
#line 151
  srcp = src->a.words;
#line 152
  tmp = (*((src->b.vtable)->size))(src);
#line 152
  n_bits = tmp;
#line 154
  rbitno = *next;
  }
#line 159
  if (rbitno >= n_bits) {
#line 160
    return ((bitset_bindex )0);
  }
#line 162
  count = (bitset_bindex )0;
#line 164
  bitno = n_bits - (rbitno + 1U);
#line 166
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 167
  bitcnt = bitno % (unsigned int )(8UL * sizeof(bitset_word ));
#line 168
  bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    word = *(srcp + windex) << (((unsigned int )(8UL * sizeof(bitset_word )) - 1U) - bitcnt);
    {
#line 175
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 175
      if (! word) {
#line 175
        goto while_break___0;
      }
#line 177
      if (word & (1UL << ((unsigned int )(8UL * sizeof(bitset_word )) - 1U))) {
#line 179
        tmp___0 = count;
#line 179
        count ++;
#line 179
        *(list + tmp___0) = bitoff + bitcnt;
#line 180
        if (count >= num) {
#line 182
          *next = n_bits - (bitoff + bitcnt);
#line 183
          return (count);
        }
      }
#line 186
      word <<= 1;
#line 175
      bitcnt --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 188
    bitoff -= (unsigned int )(8UL * sizeof(bitset_word ));
#line 189
    bitcnt = (unsigned int )(8UL * sizeof(bitset_word )) - 1U;
#line 170
    tmp___1 = windex;
#line 170
    windex --;
#line 170
    if (! tmp___1) {
#line 170
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  *next = n_bits - (bitoff + 1U);
#line 194
  return (count);
}
}
#line 201 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static bitset_bindex abitset_list(bitset src , bitset_bindex *list , bitset_bindex num ,
                                  bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_bindex count ;
  bitset_windex windex ;
  bitset_bindex bitoff ;
  bitset_windex size ;
  bitset_word *srcp ;
  bitset_word word ;
  bitset_bindex tmp ;
  bitset_bindex tmp___0 ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;

  {
#line 209
  size = src->b.csize;
#line 210
  srcp = src->a.words;
#line 213
  bitno = *next;
#line 215
  count = (bitset_bindex )0;
#line 216
  if (! bitno) {
#line 219
    windex = (bitset_windex )0;
    {
#line 219
    while (1) {
      while_continue: /* CIL Label */ ;
#line 219
      if (windex < size) {
#line 219
        if (! (! *(srcp + windex))) {
#line 219
          goto while_break;
        }
      } else {
#line 219
        goto while_break;
      }
#line 220
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 219
      windex ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 221
    if (windex >= size) {
#line 222
      return ((bitset_bindex )0);
    }
#line 227
    bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  } else {
    {
#line 231
    tmp = (*((src->b.vtable)->size))(src);
    }
#line 231
    if (bitno >= tmp) {
#line 232
      return ((bitset_bindex )0);
    }
#line 234
    windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 235
    bitno %= (unsigned int )(8UL * sizeof(bitset_word ));
#line 237
    if (bitno) {
#line 244
      bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
#line 245
      word = *(srcp + windex) >> bitno;
#line 246
      bitno = bitoff + bitno;
      {
#line 246
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 246
        if (! word) {
#line 246
          goto while_break___0;
        }
#line 248
        if (word & 1UL) {
#line 250
          tmp___0 = count;
#line 250
          count ++;
#line 250
          *(list + tmp___0) = bitno;
#line 251
          if (count >= num) {
#line 253
            *next = bitno + 1U;
#line 254
            return (count);
          }
        }
#line 257
        word >>= 1;
#line 246
        bitno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 259
      windex ++;
    }
#line 261
    bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  }
  {
#line 264
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 264
    if (! (windex < size)) {
#line 264
      goto while_break___1;
    }
#line 266
    word = *(srcp + windex);
#line 266
    if (! word) {
#line 267
      goto __Cont___0;
    }
#line 269
    if (count + (unsigned int )(8UL * sizeof(bitset_word )) < num) {
#line 271
      bitno = bitoff;
      {
#line 271
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 271
        if (! word) {
#line 271
          goto while_break___2;
        }
#line 273
        if (word & 1UL) {
#line 274
          tmp___1 = count;
#line 274
          count ++;
#line 274
          *(list + tmp___1) = bitno;
        }
#line 275
        word >>= 1;
#line 271
        bitno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 280
      bitno = bitoff;
      {
#line 280
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 280
        if (! word) {
#line 280
          goto while_break___3;
        }
#line 282
        if (word & 1UL) {
#line 284
          tmp___2 = count;
#line 284
          count ++;
#line 284
          *(list + tmp___2) = bitno;
#line 285
          if (count >= num) {
#line 287
            *next = bitno + 1U;
#line 288
            return (count);
          }
        }
#line 291
        word >>= 1;
#line 280
        bitno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 264
    windex ++;
#line 264
    bitoff += (unsigned int )(8UL * sizeof(bitset_word ));
  }
  while_break___1: /* CIL Label */ ;
  }
#line 296
  *next = bitoff;
#line 297
  return (count);
}
}
#line 302 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
__inline static void abitset_unused_clear(bitset dst ) 
{ 
  unsigned int last_bit ;
  bitset_bindex tmp ;

  {
  {
#line 307
  tmp = (*((dst->b.vtable)->size))(dst);
#line 307
  last_bit = tmp % (unsigned int )(8UL * sizeof(bitset_word ));
  }
#line 308
  if (last_bit) {
#line 309
    dst->a.words[dst->b.csize - 1U] &= (1UL << last_bit) - 1UL;
  }
#line 311
  return;
}
}
#line 314 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_ones(bitset dst ) 
{ 
  bitset_word *dstp ;
  size_t bytes ;

  {
  {
#line 317
  dstp = dst->a.words;
#line 320
  bytes = (size_t )(sizeof(bitset_word ) * (unsigned long )dst->b.csize);
#line 322
  memset((void *)dstp, -1, bytes);
#line 323
  abitset_unused_clear(dst);
  }
#line 324
  return;
}
}
#line 327 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_zero(bitset dst ) 
{ 
  bitset_word *dstp ;
  size_t bytes ;

  {
  {
#line 330
  dstp = dst->a.words;
#line 333
  bytes = (size_t )(sizeof(bitset_word ) * (unsigned long )dst->b.csize);
#line 335
  memset((void *)dstp, 0, bytes);
  }
#line 336
  return;
}
}
#line 339 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_empty_p(bitset dst ) 
{ 
  bitset_windex i ;
  bitset_word *dstp ;

  {
#line 343
  dstp = dst->a.words;
#line 345
  i = (bitset_windex )0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (i < dst->b.csize)) {
#line 345
      goto while_break;
    }
#line 346
    if (*(dstp + i)) {
#line 347
      return ((_Bool)0);
    }
#line 345
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return ((_Bool)1);
}
}
#line 353 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_copy1(bitset dst , bitset src ) 
{ 
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex size ;

  {
#line 356
  srcp = src->a.words;
#line 357
  dstp = dst->a.words;
#line 358
  size = dst->b.csize;
#line 360
  if ((unsigned long )srcp == (unsigned long )dstp) {
#line 361
    return;
  }
  {
#line 362
  memcpy((void */* __restrict  */)dstp, (void const   */* __restrict  */)srcp, (size_t )(sizeof(bitset_word ) * (unsigned long )size));
  }
#line 363
  return;
}
}
#line 366 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_not(bitset dst , bitset src ) 
{ 
  bitset_windex i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;

  {
#line 370
  srcp = src->a.words;
#line 371
  dstp = dst->a.words;
#line 372
  size = dst->b.csize;
#line 374
  i = (bitset_windex )0;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (i < size)) {
#line 374
      goto while_break;
    }
#line 375
    tmp = dstp;
#line 375
    dstp ++;
#line 375
    tmp___0 = srcp;
#line 375
    srcp ++;
#line 375
    *tmp = ~ *tmp___0;
#line 374
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  abitset_unused_clear(dst);
  }
#line 377
  return;
}
}
#line 380 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_equal_p(bitset dst , bitset src ) 
{ 
  bitset_windex i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;

  {
#line 384
  srcp = src->a.words;
#line 385
  dstp = dst->a.words;
#line 386
  size = dst->b.csize;
#line 388
  i = (bitset_windex )0;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (i < size)) {
#line 388
      goto while_break;
    }
#line 389
    tmp = srcp;
#line 389
    srcp ++;
#line 389
    tmp___0 = dstp;
#line 389
    dstp ++;
#line 389
    if (*tmp != *tmp___0) {
#line 390
      return ((_Bool)0);
    }
#line 388
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  return ((_Bool)1);
}
}
#line 395 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_subset_p(bitset dst , bitset src ) 
{ 
  bitset_windex i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex size ;

  {
#line 399
  srcp = src->a.words;
#line 400
  dstp = dst->a.words;
#line 401
  size = dst->b.csize;
#line 403
  i = (bitset_windex )0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i < size)) {
#line 403
      goto while_break;
    }
#line 404
    if (*dstp != (*srcp | *dstp)) {
#line 405
      return ((_Bool)0);
    }
#line 403
    i ++;
#line 403
    dstp ++;
#line 403
    srcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return ((_Bool)1);
}
}
#line 410 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_disjoint_p(bitset dst , bitset src ) 
{ 
  bitset_windex i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;

  {
#line 414
  srcp = src->a.words;
#line 415
  dstp = dst->a.words;
#line 416
  size = dst->b.csize;
#line 418
  i = (bitset_windex )0;
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! (i < size)) {
#line 418
      goto while_break;
    }
#line 419
    tmp = srcp;
#line 419
    srcp ++;
#line 419
    tmp___0 = dstp;
#line 419
    dstp ++;
#line 419
    if (*tmp & *tmp___0) {
#line 420
      return ((_Bool)0);
    }
#line 418
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return ((_Bool)1);
}
}
#line 426 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_and(bitset dst , bitset src1 , bitset src2 ) 
{ 
  bitset_windex i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
#line 430
  src1p = src1->a.words;
#line 431
  src2p = src2->a.words;
#line 432
  dstp = dst->a.words;
#line 433
  size = dst->b.csize;
#line 435
  i = (bitset_windex )0;
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if (! (i < size)) {
#line 435
      goto while_break;
    }
#line 436
    tmp = dstp;
#line 436
    dstp ++;
#line 436
    tmp___0 = src1p;
#line 436
    src1p ++;
#line 436
    tmp___1 = src2p;
#line 436
    src2p ++;
#line 436
    *tmp = *tmp___0 & *tmp___1;
#line 435
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  return;
}
}
#line 440 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_and_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  bitset_windex i ;
  _Bool changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
#line 444
  changed = (_Bool)0;
#line 445
  src1p = src1->a.words;
#line 446
  src2p = src2->a.words;
#line 447
  dstp = dst->a.words;
#line 448
  size = dst->b.csize;
#line 450
  i = (bitset_windex )0;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (i < size)) {
#line 450
      goto while_break;
    }
#line 452
    tmp___0 = src1p;
#line 452
    src1p ++;
#line 452
    tmp___1 = src2p;
#line 452
    src2p ++;
#line 452
    tmp = *tmp___0 & *tmp___1;
#line 454
    if (*dstp != tmp) {
#line 456
      changed = (_Bool)1;
#line 457
      *dstp = tmp;
    }
#line 450
    i ++;
#line 450
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  return (changed);
}
}
#line 464 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_andn(bitset dst , bitset src1 , bitset src2 ) 
{ 
  bitset_windex i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
#line 468
  src1p = src1->a.words;
#line 469
  src2p = src2->a.words;
#line 470
  dstp = dst->a.words;
#line 471
  size = dst->b.csize;
#line 473
  i = (bitset_windex )0;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! (i < size)) {
#line 473
      goto while_break;
    }
#line 474
    tmp = dstp;
#line 474
    dstp ++;
#line 474
    tmp___0 = src1p;
#line 474
    src1p ++;
#line 474
    tmp___1 = src2p;
#line 474
    src2p ++;
#line 474
    *tmp = *tmp___0 & ~ *tmp___1;
#line 473
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return;
}
}
#line 478 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_andn_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  bitset_windex i ;
  _Bool changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
#line 482
  changed = (_Bool)0;
#line 483
  src1p = src1->a.words;
#line 484
  src2p = src2->a.words;
#line 485
  dstp = dst->a.words;
#line 486
  size = dst->b.csize;
#line 488
  i = (bitset_windex )0;
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! (i < size)) {
#line 488
      goto while_break;
    }
#line 490
    tmp___0 = src1p;
#line 490
    src1p ++;
#line 490
    tmp___1 = src2p;
#line 490
    src2p ++;
#line 490
    tmp = *tmp___0 & ~ *tmp___1;
#line 492
    if (*dstp != tmp) {
#line 494
      changed = (_Bool)1;
#line 495
      *dstp = tmp;
    }
#line 488
    i ++;
#line 488
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  return (changed);
}
}
#line 502 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_or(bitset dst , bitset src1 , bitset src2 ) 
{ 
  bitset_windex i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
#line 506
  src1p = src1->a.words;
#line 507
  src2p = src2->a.words;
#line 508
  dstp = dst->a.words;
#line 509
  size = dst->b.csize;
#line 511
  i = (bitset_windex )0;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (! (i < size)) {
#line 511
      goto while_break;
    }
#line 512
    tmp = dstp;
#line 512
    dstp ++;
#line 512
    tmp___0 = src1p;
#line 512
    src1p ++;
#line 512
    tmp___1 = src2p;
#line 512
    src2p ++;
#line 512
    *tmp = *tmp___0 | *tmp___1;
#line 511
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 516 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_or_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  bitset_windex i ;
  _Bool changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
#line 520
  changed = (_Bool)0;
#line 521
  src1p = src1->a.words;
#line 522
  src2p = src2->a.words;
#line 523
  dstp = dst->a.words;
#line 524
  size = dst->b.csize;
#line 526
  i = (bitset_windex )0;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if (! (i < size)) {
#line 526
      goto while_break;
    }
#line 528
    tmp___0 = src1p;
#line 528
    src1p ++;
#line 528
    tmp___1 = src2p;
#line 528
    src2p ++;
#line 528
    tmp = *tmp___0 | *tmp___1;
#line 530
    if (*dstp != tmp) {
#line 532
      changed = (_Bool)1;
#line 533
      *dstp = tmp;
    }
#line 526
    i ++;
#line 526
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  return (changed);
}
}
#line 540 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_xor(bitset dst , bitset src1 , bitset src2 ) 
{ 
  bitset_windex i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
#line 544
  src1p = src1->a.words;
#line 545
  src2p = src2->a.words;
#line 546
  dstp = dst->a.words;
#line 547
  size = dst->b.csize;
#line 549
  i = (bitset_windex )0;
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    if (! (i < size)) {
#line 549
      goto while_break;
    }
#line 550
    tmp = dstp;
#line 550
    dstp ++;
#line 550
    tmp___0 = src1p;
#line 550
    src1p ++;
#line 550
    tmp___1 = src2p;
#line 550
    src2p ++;
#line 550
    *tmp = *tmp___0 ^ *tmp___1;
#line 549
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  return;
}
}
#line 554 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_xor_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  bitset_windex i ;
  _Bool changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
#line 558
  changed = (_Bool)0;
#line 559
  src1p = src1->a.words;
#line 560
  src2p = src2->a.words;
#line 561
  dstp = dst->a.words;
#line 562
  size = dst->b.csize;
#line 564
  i = (bitset_windex )0;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (i < size)) {
#line 564
      goto while_break;
    }
#line 566
    tmp___0 = src1p;
#line 566
    src1p ++;
#line 566
    tmp___1 = src2p;
#line 566
    src2p ++;
#line 566
    tmp = *tmp___0 ^ *tmp___1;
#line 568
    if (*dstp != tmp) {
#line 570
      changed = (_Bool)1;
#line 571
      *dstp = tmp;
    }
#line 564
    i ++;
#line 564
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  return (changed);
}
}
#line 578 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_and_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  bitset_windex i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 582
  src1p = src1->a.words;
#line 583
  src2p = src2->a.words;
#line 584
  src3p = src3->a.words;
#line 585
  dstp = dst->a.words;
#line 586
  size = dst->b.csize;
#line 588
  i = (bitset_windex )0;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! (i < size)) {
#line 588
      goto while_break;
    }
#line 589
    tmp = dstp;
#line 589
    dstp ++;
#line 589
    tmp___0 = src1p;
#line 589
    src1p ++;
#line 589
    tmp___1 = src2p;
#line 589
    src2p ++;
#line 589
    tmp___2 = src3p;
#line 589
    src3p ++;
#line 589
    *tmp = (*tmp___0 & *tmp___1) | *tmp___2;
#line 588
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  return;
}
}
#line 593 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_and_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  bitset_windex i ;
  _Bool changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 597
  changed = (_Bool)0;
#line 598
  src1p = src1->a.words;
#line 599
  src2p = src2->a.words;
#line 600
  src3p = src3->a.words;
#line 601
  dstp = dst->a.words;
#line 602
  size = dst->b.csize;
#line 604
  i = (bitset_windex )0;
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    if (! (i < size)) {
#line 604
      goto while_break;
    }
#line 606
    tmp___0 = src1p;
#line 606
    src1p ++;
#line 606
    tmp___1 = src2p;
#line 606
    src2p ++;
#line 606
    tmp___2 = src3p;
#line 606
    src3p ++;
#line 606
    tmp = (*tmp___0 & *tmp___1) | *tmp___2;
#line 608
    if (*dstp != tmp) {
#line 610
      changed = (_Bool)1;
#line 611
      *dstp = tmp;
    }
#line 604
    i ++;
#line 604
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  return (changed);
}
}
#line 618 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_andn_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  bitset_windex i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 622
  src1p = src1->a.words;
#line 623
  src2p = src2->a.words;
#line 624
  src3p = src3->a.words;
#line 625
  dstp = dst->a.words;
#line 626
  size = dst->b.csize;
#line 628
  i = (bitset_windex )0;
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
#line 628
    if (! (i < size)) {
#line 628
      goto while_break;
    }
#line 629
    tmp = dstp;
#line 629
    dstp ++;
#line 629
    tmp___0 = src1p;
#line 629
    src1p ++;
#line 629
    tmp___1 = src2p;
#line 629
    src2p ++;
#line 629
    tmp___2 = src3p;
#line 629
    src3p ++;
#line 629
    *tmp = (*tmp___0 & ~ *tmp___1) | *tmp___2;
#line 628
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 630
  return;
}
}
#line 633 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_andn_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  bitset_windex i ;
  _Bool changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 637
  changed = (_Bool)0;
#line 638
  src1p = src1->a.words;
#line 639
  src2p = src2->a.words;
#line 640
  src3p = src3->a.words;
#line 641
  dstp = dst->a.words;
#line 642
  size = dst->b.csize;
#line 644
  i = (bitset_windex )0;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (i < size)) {
#line 644
      goto while_break;
    }
#line 646
    tmp___0 = src1p;
#line 646
    src1p ++;
#line 646
    tmp___1 = src2p;
#line 646
    src2p ++;
#line 646
    tmp___2 = src3p;
#line 646
    src3p ++;
#line 646
    tmp = (*tmp___0 & ~ *tmp___1) | *tmp___2;
#line 648
    if (*dstp != tmp) {
#line 650
      changed = (_Bool)1;
#line 651
      *dstp = tmp;
    }
#line 644
    i ++;
#line 644
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 654
  return (changed);
}
}
#line 658 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_or_and(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  bitset_windex i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 662
  src1p = src1->a.words;
#line 663
  src2p = src2->a.words;
#line 664
  src3p = src3->a.words;
#line 665
  dstp = dst->a.words;
#line 666
  size = dst->b.csize;
#line 668
  i = (bitset_windex )0;
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    if (! (i < size)) {
#line 668
      goto while_break;
    }
#line 669
    tmp = dstp;
#line 669
    dstp ++;
#line 669
    tmp___0 = src1p;
#line 669
    src1p ++;
#line 669
    tmp___1 = src2p;
#line 669
    src2p ++;
#line 669
    tmp___2 = src3p;
#line 669
    src3p ++;
#line 669
    *tmp = (*tmp___0 | *tmp___1) & *tmp___2;
#line 668
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 670
  return;
}
}
#line 673 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static _Bool abitset_or_and_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  bitset_windex i ;
  _Bool changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 677
  changed = (_Bool)0;
#line 678
  src1p = src1->a.words;
#line 679
  src2p = src2->a.words;
#line 680
  src3p = src3->a.words;
#line 681
  dstp = dst->a.words;
#line 682
  size = dst->b.csize;
#line 684
  i = (bitset_windex )0;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! (i < size)) {
#line 684
      goto while_break;
    }
#line 686
    tmp___0 = src1p;
#line 686
    src1p ++;
#line 686
    tmp___1 = src2p;
#line 686
    src2p ++;
#line 686
    tmp___2 = src3p;
#line 686
    src3p ++;
#line 686
    tmp = (*tmp___0 | *tmp___1) & *tmp___2;
#line 688
    if (*dstp != tmp) {
#line 690
      changed = (_Bool)1;
#line 691
      *dstp = tmp;
    }
#line 684
    i ++;
#line 684
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  return (changed);
}
}
#line 698 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
static void abitset_copy(bitset dst , bitset src ) 
{ 


  {
#line 701
  if ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable) {
    {
#line 702
    abitset_copy1(dst, src);
    }
  } else {
    {
#line 704
    bitset_copy_(dst, src);
    }
  }
#line 705
  return;
}
}
#line 709 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
struct bitset_vtable abitset_small_vtable  = 
#line 709
     {& abitset_set, & abitset_reset, & bitset_toggle_, & abitset_test, & abitset_resize,
    & bitset_size_, & bitset_count_, & abitset_empty_p, & abitset_ones, & abitset_zero,
    & abitset_copy, & abitset_disjoint_p, & abitset_equal_p, & abitset_not, & abitset_subset_p,
    & abitset_and, & abitset_and_cmp, & abitset_andn, & abitset_andn_cmp, & abitset_or,
    & abitset_or_cmp, & abitset_xor, & abitset_xor_cmp, & abitset_and_or, & abitset_and_or_cmp,
    & abitset_andn_or, & abitset_andn_or_cmp, & abitset_or_and, & abitset_or_and_cmp,
    & abitset_small_list, & abitset_list_reverse, (void (*)(bitset  ))((void *)0),
    (enum bitset_type )0};
#line 747 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
struct bitset_vtable abitset_vtable  = 
#line 747
     {& abitset_set, & abitset_reset, & bitset_toggle_, & abitset_test, & abitset_resize,
    & bitset_size_, & bitset_count_, & abitset_empty_p, & abitset_ones, & abitset_zero,
    & abitset_copy, & abitset_disjoint_p, & abitset_equal_p, & abitset_not, & abitset_subset_p,
    & abitset_and, & abitset_and_cmp, & abitset_andn, & abitset_andn_cmp, & abitset_or,
    & abitset_or_cmp, & abitset_xor, & abitset_xor_cmp, & abitset_and_or, & abitset_and_or_cmp,
    & abitset_andn_or, & abitset_andn_or_cmp, & abitset_or_and, & abitset_or_and_cmp,
    & abitset_list, & abitset_list_reverse, (void (*)(bitset  ))((void *)0), (enum bitset_type )0};
#line 784 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
size_t abitset_bytes(bitset_bindex n_bits ) 
{ 
  bitset_windex size ;
  size_t bytes ;
  size_t header_size ;
  size_t bitset_alignment ;

  {
#line 789
  header_size = (size_t )((unsigned long )(& ((union bitset_union *)0)->a.words));
#line 791
  bitset_alignment = (size_t )((unsigned long )(& ((struct bitset_align_struct *)0)->b));
#line 793
  size = ((n_bits + (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (unsigned int )(8UL * sizeof(bitset_word ));
#line 794
  bytes = (size_t )((unsigned long )header_size + (unsigned long )size * sizeof(bitset_word ));
#line 797
  if (header_size % bitset_alignment != 0U) {
#line 800
    bytes += bitset_alignment - 1U;
#line 801
    bytes -= bytes % bitset_alignment;
  } else
#line 797
  if (sizeof(bitset_word ) % (unsigned long )bitset_alignment != 0UL) {
#line 800
    bytes += bitset_alignment - 1U;
#line 801
    bytes -= bytes % bitset_alignment;
  }
#line 804
  return (bytes);
}
}
#line 808 "/home/pronto/abs/test-suite/bison-2.5/lib/abitset.c"
bitset abitset_init(bitset bset , bitset_bindex n_bits ) 
{ 
  bitset_windex size ;

  {
#line 813
  size = ((n_bits + (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (unsigned int )(8UL * sizeof(bitset_word ));
#line 814
  bset->b.n_bits = n_bits;
#line 819
  if (size == 1U) {
#line 820
    bset->b.vtable = (struct bitset_vtable  const  *)(& abitset_small_vtable);
  } else {
#line 822
    bset->b.vtable = (struct bitset_vtable  const  *)(& abitset_vtable);
  }
#line 824
  bset->b.cindex = (bitset_windex )0;
#line 825
  bset->b.csize = size;
#line 826
  bset->b.cdata = bset->a.words;
#line 827
  return (bset);
}
}
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
uniqstr grammar_file ;
#line 27 "/home/pronto/abs/test-suite/bison-2.5/src/graphviz.h"
void start_graph(FILE *fout ) ;
#line 33
void output_node(int id , char const   *label , FILE *fout ) ;
#line 42
void output_edge(int source , int destination , char const   *label , char const   *style ,
                 FILE *fout ) ;
#line 47
void finish_graph(FILE *fout ) ;
#line 33 "/home/pronto/abs/test-suite/bison-2.5/src/graphviz.c"
static char const   *quote___0(char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 36
  tmp = quotearg_n_style(2, (enum quoting_style )3, name);
  }
#line 36
  return ((char const   *)tmp);
}
}
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/graphviz.c"
void start_graph(FILE *fout ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 42
  tmp = gettext("// Generated by %s.\n// Report bugs to <%s>.\n// Home page: <%s>.\n\n");
#line 42
  rpl_fprintf(fout, (char const   *)tmp, "GNU Bison 2.5", "bug-bison@gnu.org", "http://www.gnu.org/software/bison/");
#line 50
  tmp___0 = quote___0(grammar_file);
#line 50
  rpl_fprintf(fout, "digraph %s\n{\n", tmp___0);
  }
#line 54
  return;
}
}
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/graphviz.c"
void output_node(int id , char const   *label , FILE *fout ) 
{ 
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 59
  tmp = quote___0(label);
#line 59
  rpl_fprintf(fout, "  %d [label=%s]\n", id, tmp);
  }
#line 60
  return;
}
}
#line 62 "/home/pronto/abs/test-suite/bison-2.5/src/graphviz.c"
void output_edge(int source , int destination , char const   *label , char const   *style ,
                 FILE *fout ) 
{ 
  char const   *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 66
  rpl_fprintf(fout, "  %d -> %d [style=%s", source, destination, style);
  }
#line 67
  if (label) {
    {
#line 68
    tmp = quote___0(label);
#line 68
    rpl_fprintf(fout, " label=%s", tmp);
    }
  }
  {
#line 69
  fputs_unlocked((char const   */* __restrict  */)"]\n", (FILE */* __restrict  */)fout);
  }
#line 70
  return;
}
}
#line 72 "/home/pronto/abs/test-suite/bison-2.5/src/graphviz.c"
void finish_graph(FILE *fout ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 75
  fputs_unlocked((char const   */* __restrict  */)"}\n", (FILE */* __restrict  */)fout);
  }
#line 76
  return;
}
}
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.h"
uniqstr uniqstr_new(char const   *str ) ;
#line 35
uniqstr ( /* format attribute */  uniqstr_vsprintf)(char const   *format  , ...) ;
#line 50
void uniqstrs_new(void) ;
#line 53
void uniqstr_assert(char const   *str ) ;
#line 56
void uniqstrs_free(void) ;
#line 59
void uniqstrs_print(void) ;
#line 37 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
static struct hash_table *uniqstrs_table  =    (struct hash_table *)((void *)0);
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
uniqstr uniqstr_new(char const   *str ) 
{ 
  uniqstr res ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 46
  tmp = hash_lookup((Hash_table const   *)uniqstrs_table, (void const   *)str);
#line 46
  res = (uniqstr )tmp;
  }
#line 47
  if (! res) {
    {
#line 50
    tmp___0 = xstrdup(str);
#line 50
    res = (uniqstr )tmp___0;
#line 51
    tmp___1 = hash_insert(uniqstrs_table, (void const   *)res);
    }
#line 51
    if (! tmp___1) {
      {
#line 52
      xalloc_die();
      }
    }
  }
#line 54
  return (res);
}
}
#line 57 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
uniqstr ( /* format attribute */  uniqstr_vsprintf)(char const   *format  , ...) 
{ 
  va_list args ;
  size_t length ;
  int tmp ;
  char *res ;
  unsigned long __lengthofres ;
  void *tmp___0 ;
  uniqstr tmp___1 ;

  {
  {
#line 62
  __builtin_va_start(args, format);
#line 63
  tmp = rpl_vsnprintf((char *)((void *)0), (size_t )0, format, args);
#line 63
  length = (size_t )tmp;
#line 64
  __builtin_va_end(args);
#line 66
  __lengthofres = (unsigned long )(length + 1U);
#line 66
  tmp___0 = __builtin_alloca(sizeof(*res) * __lengthofres);
#line 66
  res = (char *)tmp___0;
#line 67
  __builtin_va_start(args, format);
#line 68
  rpl_vsprintf(res, format, args);
#line 69
  __builtin_va_end(args);
#line 70
  tmp___1 = uniqstr_new((char const   *)res);
  }
#line 70
  return (tmp___1);
}
}
#line 77 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
void uniqstr_assert(char const   *str ) 
{ 
  char *tmp ;
  void *tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 80
  tmp___0 = hash_lookup((Hash_table const   *)uniqstrs_table, (void const   *)str);
  }
#line 80
  if (! tmp___0) {
    {
#line 82
    tmp = quotearg(str);
#line 82
    error(0, 0, "not a uniqstr: %s", tmp);
#line 84
    abort();
    }
  }
#line 86
  return;
}
}
#line 93 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
__inline static _Bool uniqstr_print(uniqstr ustr ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 96
  rpl_fprintf(stderr, "%s\n", ustr);
  }
#line 97
  return ((_Bool)1);
}
}
#line 100 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
static _Bool uniqstr_print_processor(void *ustr , void *null  __attribute__((__unused__)) ) 
{ 
  _Bool tmp ;

  {
  {
#line 103
  tmp = uniqstr_print((uniqstr )ustr);
  }
#line 103
  return (tmp);
}
}
#line 111 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
static _Bool hash_compare_uniqstr(void const   *m1 , void const   *m2 ) 
{ 
  int tmp ;

  {
  {
#line 114
  tmp = strcmp((char const   *)m1, (char const   *)m2);
  }
#line 114
  return ((_Bool )(tmp == 0));
}
}
#line 117 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
static size_t hash_uniqstr(void const   *m , size_t tablesize ) 
{ 
  size_t tmp ;

  {
  {
#line 120
  tmp = hash_string((char const   *)m, tablesize);
  }
#line 120
  return (tmp);
}
}
#line 127 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
void uniqstrs_new(void) 
{ 


  {
  {
#line 130
  uniqstrs_table = hash_initialize((size_t )257, (Hash_tuning const   *)((void *)0),
                                   & hash_uniqstr, & hash_compare_uniqstr, & free);
  }
#line 135
  return;
}
}
#line 142 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
static void uniqstrs_do(_Bool (*processor)(void * , void * ) , void *processor_data ) 
{ 


  {
  {
#line 145
  hash_do_for_each((Hash_table const   *)uniqstrs_table, processor, processor_data);
  }
#line 146
  return;
}
}
#line 153 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
void uniqstrs_print(void) 
{ 


  {
  {
#line 156
  uniqstrs_do(& uniqstr_print_processor, (void *)0);
  }
#line 157
  return;
}
}
#line 164 "/home/pronto/abs/test-suite/bison-2.5/src/uniqstr.c"
void uniqstrs_free(void) 
{ 


  {
  {
#line 167
  hash_free(uniqstrs_table);
  }
#line 168
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 140
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 142
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 142 "../lib/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 145
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 145
    tmp = -1;
  } else {
#line 145
    tmp = -2;
  }
#line 145
  if ((size_t )tmp / s < n) {
    {
#line 146
    xalloc_die();
    }
  }
  {
#line 147
  tmp___0 = xrealloc(p, n * s);
  }
#line 147
  return (tmp___0);
}
}
#line 165 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
symbol *errtoken ;
#line 111 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
int nsyms ;
#line 112
int ntokens ;
#line 113
int nvars ;
#line 149
rule_number nrules ;
#line 151 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
__inline static item_number rule_number_as_item_number(rule_number r ) 
{ 


  {
#line 154
  return (-1 - r);
}
}
#line 157 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
__inline static rule_number item_number_as_rule_number(item_number i ) 
{ 


  {
#line 160
  return (-1 - i);
}
}
#line 202
rule *rules ;
#line 98 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
__inline static int state_number_as_int(state_number s ) 
{ 


  {
#line 101
  return (s);
}
}
#line 226
state_number nstates ;
#line 269
state **states ;
#line 40 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.h"
int conflicts_total_count(void) ;
#line 60 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool nondeterministic_parser ;
#line 114
int trace_flag ;
#line 88 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.h"
goto_number *goto_map ;
#line 94
state_number *from_state ;
#line 97
state_number *to_state ;
#line 152 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.h"
char *muscle_percent_define_get(char const   *variable ) ;
#line 115 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
int nvectors  ;
#line 118
base_number *base ;
#line 122
base_number base_ninf ;
#line 124 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
unsigned int *conflict_table  ;
#line 125 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
unsigned int *conflict_list  ;
#line 126 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
int conflict_list_cnt  ;
#line 128 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
base_number *table  ;
#line 129 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
base_number *check  ;
#line 132
base_number table_ninf ;
#line 134 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
state_number *yydefgoto  ;
#line 135 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
rule_number *yydefact  ;
#line 136 "/home/pronto/abs/test-suite/bison-2.5/src/tables.h"
int high  ;
#line 138
void tables_generate(void) ;
#line 139
void tables_free(void) ;
#line 54 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
__inline static vector_number symbol_number_to_vector_number(symbol_number sym ) 
{ 
  int tmp ;

  {
  {
#line 57
  tmp = state_number_as_int(nstates);
  }
#line 57
  return ((tmp + sym) - ntokens);
}
}
#line 85 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static base_number **froms  ;
#line 86 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static base_number **tos  ;
#line 87 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static unsigned int **conflict_tos  ;
#line 88 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static int *tally  ;
#line 89 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static base_number *width  ;
#line 101 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static action_number *actrow  ;
#line 106 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static vector_number *order  ;
#line 107 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static int nentries  ;
#line 109 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
base_number *base  =    (base_number *)((void *)0);
#line 113 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
base_number base_ninf  =    0;
#line 114 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static base_number *pos  =    (base_number *)((void *)0);
#line 116 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static unsigned int *conflrow  ;
#line 120 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static int conflict_list_free  ;
#line 125 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static int table_size  =    32768;
#line 132 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
base_number table_ninf  =    0;
#line 133 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static int lowzero  ;
#line 145 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static void table_grow(int desired ) 
{ 
  int old_size ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 148
  old_size = table_size;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (table_size <= desired)) {
#line 150
      goto while_break;
    }
#line 151
    table_size *= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  if (trace_flag & 4) {
    {
#line 154
    rpl_fprintf(stderr, "growing table and check from: %d to %d\n", old_size, table_size);
    }
  }
  {
#line 157
  tmp = xnrealloc((void *)table, (size_t )table_size, (size_t )sizeof(*table));
#line 157
  table = (base_number *)tmp;
#line 158
  tmp___0 = xnrealloc((void *)conflict_table, (size_t )table_size, (size_t )sizeof(*conflict_table));
#line 158
  conflict_table = (unsigned int *)tmp___0;
#line 160
  tmp___1 = xnrealloc((void *)check, (size_t )table_size, (size_t )sizeof(*check));
#line 160
  check = (base_number *)tmp___1;
  }
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! (old_size < table_size)) {
#line 162
      goto while_break___0;
    }
#line 164
    *(table + old_size) = 0;
#line 165
    *(conflict_table + old_size) = 0U;
#line 166
    *(check + old_size) = -1;
#line 162
    old_size ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 183 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static void conflict_row(state *s ) 
{ 
  int i ;
  int j ;
  reductions *reds ;
  _Bool tmp ;
  item_number tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 187
  reds = s->reductions;
#line 189
  if (! nondeterministic_parser) {
#line 190
    return;
  }
#line 192
  j = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (j < ntokens)) {
#line 192
      goto while_break;
    }
#line 193
    if (*(conflrow + j)) {
#line 195
      *(conflrow + j) = (unsigned int )conflict_list_cnt;
#line 199
      i = 0;
      {
#line 199
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 199
        if (! (i < reds->num)) {
#line 199
          goto while_break___0;
        }
        {
#line 200
        tmp = bitset_test(*(reds->lookahead_tokens + i), (bitset_bindex )j);
        }
#line 200
        if (tmp) {
          {
#line 200
          tmp___0 = rule_number_as_item_number((reds->rules[i])->number);
          }
#line 200
          if (*(actrow + j) != tmp___0) {
#line 204
            if (! (0 < conflict_list_free)) {
              {
#line 204
              __assert_fail("0 < conflict_list_free", "/home/pronto/abs/test-suite/bison-2.5/src/tables.c",
                            204U, "conflict_row");
              }
            }
#line 205
            *(conflict_list + conflict_list_cnt) = (unsigned int )((reds->rules[i])->number + 1);
#line 206
            conflict_list_cnt ++;
#line 207
            conflict_list_free --;
          }
        }
#line 199
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 211
      if (! (0 < conflict_list_free)) {
        {
#line 211
        __assert_fail("0 < conflict_list_free", "/home/pronto/abs/test-suite/bison-2.5/src/tables.c",
                      211U, "conflict_row");
        }
      }
#line 212
      *(conflict_list + conflict_list_cnt) = 0U;
#line 213
      conflict_list_cnt ++;
#line 214
      conflict_list_free --;
    }
#line 192
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return;
}
}
#line 239 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static rule *action_row(state *s ) 
{ 
  int i ;
  rule *default_reduction ;
  reductions *reds ;
  transitions *trans ;
  errs *errp ;
  _Bool nodefault ;
  _Bool conflicted ;
  unsigned int tmp ;
  int j ;
  bitset_iterator biter ;
  symbol_number sym ;
  state *shift_state ;
  symbol *sym___0 ;
  char *default_reductions ;
  char *tmp___0 ;
  int tmp___1 ;
  int max ;
  int count ;
  rule *r ;
  symbol_number j___0 ;
  item_number tmp___2 ;
  int j___1 ;
  item_number tmp___3 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 243
  default_reduction = (rule *)((void *)0);
#line 244
  reds = s->reductions;
#line 245
  trans = s->transitions;
#line 246
  errp = s->errs;
#line 248
  nodefault = (_Bool)0;
#line 249
  conflicted = (_Bool)0;
#line 251
  i = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < ntokens)) {
#line 251
      goto while_break;
    }
#line 252
    tmp = 0U;
#line 252
    *(conflrow + i) = tmp;
#line 252
    *(actrow + i) = (action_number )tmp;
#line 251
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  if (reds->lookahead_tokens) {
#line 261
    i = reds->num - 1;
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      if (! (i >= 0)) {
#line 261
        goto while_break___0;
      }
#line 264
      biter.next = (bitset_bindex )0;
#line 264
      biter.num = (bitset_bindex )1024;
      {
#line 264
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 264
        if (biter.num == 1024U) {
          {
#line 264
          biter.num = (*(((*(reds->lookahead_tokens + i))->b.vtable)->list))(*(reds->lookahead_tokens + i),
                                                                             biter.list,
                                                                             (bitset_bindex )1024,
                                                                             & biter.next);
          }
#line 264
          if (! biter.num) {
#line 264
            goto while_break___1;
          }
        } else {
#line 264
          goto while_break___1;
        }
#line 264
        biter.i = (bitset_bindex )0;
        {
#line 264
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 264
          if (biter.i < biter.num) {
#line 264
            j = (int )biter.list[biter.i];
          } else {
#line 264
            goto while_break___2;
          }
#line 268
          if (*(actrow + j) != 0) {
#line 270
            conflicted = (_Bool)1;
#line 271
            *(conflrow + j) = 1U;
          }
          {
#line 273
          *(actrow + j) = rule_number_as_item_number((reds->rules[i])->number);
#line 264
          (biter.i) ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 261
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 280
  i = 0;
  {
#line 280
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 280
    if (i < trans->num) {
#line 280
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 280
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 280
          goto while_break___3;
        }
      }
    } else {
#line 280
      goto while_break___3;
    }
#line 280
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 282
      sym = (trans->states[i])->accessing_symbol;
#line 283
      shift_state = trans->states[i];
#line 285
      if (*(actrow + sym) != 0) {
#line 287
        conflicted = (_Bool)1;
#line 288
        *(conflrow + sym) = 1U;
      }
      {
#line 290
      *(actrow + sym) = state_number_as_int(shift_state->number);
      }
#line 294
      if (sym == errtoken->number) {
#line 295
        nodefault = (_Bool)1;
      }
    }
#line 280
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 301
  i = 0;
  {
#line 301
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 301
    if (! (i < errp->num)) {
#line 301
      goto while_break___4;
    }
#line 303
    sym___0 = errp->symbols[i];
#line 304
    *(actrow + sym___0->number) = (-0x7FFFFFFF-1);
#line 301
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 311
  tmp___0 = muscle_percent_define_get("lr.default-reductions");
#line 311
  default_reductions = tmp___0;
#line 313
  tmp___1 = strcmp((char const   *)default_reductions, "most");
  }
#line 313
  if (0 != tmp___1) {
#line 313
    if (! s->consistent) {
#line 314
      nodefault = (_Bool)1;
    }
  }
  {
#line 315
  free((void *)default_reductions);
  }
#line 321
  if (reds->num >= 1) {
#line 321
    if (! nodefault) {
#line 323
      if (s->consistent) {
#line 324
        default_reduction = reds->rules[0];
      } else {
#line 327
        max = 0;
#line 328
        i = 0;
        {
#line 328
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 328
          if (! (i < reds->num)) {
#line 328
            goto while_break___5;
          }
#line 330
          count = 0;
#line 331
          r = reds->rules[i];
#line 334
          j___0 = 0;
          {
#line 334
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 334
            if (! (j___0 < ntokens)) {
#line 334
              goto while_break___6;
            }
            {
#line 335
            tmp___2 = rule_number_as_item_number(r->number);
            }
#line 335
            if (*(actrow + j___0) == tmp___2) {
#line 336
              count ++;
            }
#line 334
            j___0 ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 338
          if (count > max) {
#line 340
            max = count;
#line 341
            default_reduction = r;
          }
#line 328
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 351
        if (max > 0) {
#line 354
          j___1 = 0;
          {
#line 354
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 354
            if (! (j___1 < ntokens)) {
#line 354
              goto while_break___7;
            }
            {
#line 355
            tmp___3 = rule_number_as_item_number(default_reduction->number);
            }
#line 355
            if (*(actrow + j___1) == tmp___3) {
#line 355
              if (nondeterministic_parser) {
#line 355
                if (! *(conflrow + j___1)) {
#line 358
                  *(actrow + j___1) = 0;
                }
              } else {
#line 358
                *(actrow + j___1) = 0;
              }
            }
#line 354
            j___1 ++;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 366
  if (! default_reduction) {
#line 367
    i = 0;
    {
#line 367
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 367
      if (! (i < ntokens)) {
#line 367
        goto while_break___8;
      }
#line 368
      if (*(actrow + i) == (-0x7FFFFFFF-1)) {
#line 369
        *(actrow + i) = 0;
      }
#line 367
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 371
  if (conflicted) {
    {
#line 372
    conflict_row(s);
    }
  }
#line 374
  return (default_reduction);
}
}
#line 382 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static void save_row(state_number s ) 
{ 
  symbol_number i ;
  int count ;
  base_number *sp ;
  base_number *sp1 ;
  base_number *sp2 ;
  unsigned int *sp3 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  base_number *tmp___2 ;
  base_number *tmp___3 ;
  unsigned int *tmp___4 ;

  {
#line 393
  count = 0;
#line 394
  i = 0;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i < ntokens)) {
#line 394
      goto while_break;
    }
#line 395
    if (*(actrow + i) != 0) {
#line 396
      count ++;
    }
#line 394
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  if (count == 0) {
#line 399
    return;
  }
  {
#line 402
  tmp = xnmalloc((size_t )count, (size_t )sizeof(*sp1));
#line 402
  sp1 = (base_number *)tmp;
#line 402
  sp = sp1;
#line 402
  *(froms + s) = sp;
#line 403
  tmp___0 = xnmalloc((size_t )count, (size_t )sizeof(*sp2));
#line 403
  sp2 = (base_number *)tmp___0;
#line 403
  *(tos + s) = sp2;
  }
#line 404
  if (nondeterministic_parser) {
    {
#line 404
    tmp___1 = xnmalloc((size_t )count, (size_t )sizeof(*sp3));
#line 404
    sp3 = (unsigned int *)tmp___1;
    }
  } else {
#line 404
    sp3 = (unsigned int *)((void *)0);
  }
#line 404
  *(conflict_tos + s) = sp3;
#line 408
  i = 0;
  {
#line 408
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 408
    if (! (i < ntokens)) {
#line 408
      goto while_break___0;
    }
#line 409
    if (*(actrow + i) != 0) {
#line 411
      tmp___2 = sp1;
#line 411
      sp1 ++;
#line 411
      *tmp___2 = i;
#line 412
      tmp___3 = sp2;
#line 412
      sp2 ++;
#line 412
      *tmp___3 = *(actrow + i);
#line 413
      if (nondeterministic_parser) {
#line 414
        tmp___4 = sp3;
#line 414
        sp3 ++;
#line 414
        *tmp___4 = *(conflrow + i);
      }
    }
#line 408
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 417
  *(tally + s) = count;
#line 418
  *(width + s) = (*(sp1 + -1) - *(sp + 0)) + 1;
#line 419
  return;
}
}
#line 430 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static void token_actions(void) 
{ 
  state_number i ;
  symbol_number j ;
  rule_number r ;
  int nconflict ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  rule *default_reduction ;
  rule *tmp___5 ;
  rule_number tmp___6 ;

  {
#line 437
  if (nondeterministic_parser) {
    {
#line 437
    tmp = conflicts_total_count();
#line 437
    tmp___0 = tmp;
    }
  } else {
#line 437
    tmp___0 = 0;
  }
  {
#line 437
  nconflict = tmp___0;
#line 439
  tmp___1 = xnmalloc((size_t )nstates, (size_t )sizeof(*yydefact));
#line 439
  yydefact = (rule_number *)tmp___1;
#line 441
  tmp___2 = xnmalloc((size_t )ntokens, (size_t )sizeof(*actrow));
#line 441
  actrow = (action_number *)tmp___2;
#line 442
  tmp___3 = xnmalloc((size_t )ntokens, (size_t )sizeof(*conflrow));
#line 442
  conflrow = (unsigned int *)tmp___3;
#line 444
  tmp___4 = xnmalloc((size_t )(1 + 2 * nconflict), (size_t )sizeof(*conflict_list));
#line 444
  conflict_list = (unsigned int *)tmp___4;
#line 445
  conflict_list_free = 2 * nconflict;
#line 446
  conflict_list_cnt = 1;
  }
#line 449
  if (! nondeterministic_parser) {
#line 450
    r = 0;
    {
#line 450
    while (1) {
      while_continue: /* CIL Label */ ;
#line 450
      if (! (r < nrules)) {
#line 450
        goto while_break;
      }
#line 451
      (rules + r)->useful = (_Bool)0;
#line 450
      r ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 453
  i = 0;
  {
#line 453
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 453
    if (! (i < nstates)) {
#line 453
      goto while_break___0;
    }
    {
#line 455
    tmp___5 = action_row(*(states + i));
#line 455
    default_reduction = tmp___5;
    }
#line 456
    if (default_reduction) {
#line 456
      *(yydefact + i) = default_reduction->number + 1;
    } else {
#line 456
      *(yydefact + i) = 0;
    }
    {
#line 457
    save_row(i);
    }
#line 462
    if (! nondeterministic_parser) {
#line 464
      j = 0;
      {
#line 464
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 464
        if (! (j < ntokens)) {
#line 464
          goto while_break___1;
        }
#line 465
        if (*(actrow + j) < 0) {
#line 465
          if (*(actrow + j) != (-0x7FFFFFFF-1)) {
            {
#line 466
            tmp___6 = item_number_as_rule_number(*(actrow + j));
#line 466
            (rules + tmp___6)->useful = (_Bool)1;
            }
          }
        }
#line 464
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 467
      if (*(yydefact + i)) {
#line 468
        (rules + (*(yydefact + i) - 1))->useful = (_Bool)1;
      }
    }
#line 453
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 472
  free((void *)actrow);
#line 473
  free((void *)conflrow);
  }
#line 474
  return;
}
}
#line 486 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static void save_column(symbol_number sym , state_number default_state ) 
{ 
  goto_number i ;
  base_number *sp ;
  base_number *sp1 ;
  base_number *sp2 ;
  int count ;
  vector_number symno ;
  vector_number tmp ;
  goto_number begin ;
  goto_number end ;
  void *tmp___0 ;
  void *tmp___1 ;
  base_number *tmp___2 ;
  base_number *tmp___3 ;

  {
  {
#line 494
  tmp = symbol_number_to_vector_number(sym);
#line 494
  symno = tmp;
#line 496
  begin = *(goto_map + (sym - ntokens));
#line 497
  end = *(goto_map + ((sym - ntokens) + 1));
#line 500
  count = 0;
#line 501
  i = begin;
  }
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! (i < end)) {
#line 501
      goto while_break;
    }
#line 502
    if (*(to_state + i) != default_state) {
#line 503
      count ++;
    }
#line 501
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  if (count == 0) {
#line 506
    return;
  }
  {
#line 509
  tmp___0 = xnmalloc((size_t )count, (size_t )sizeof(*sp1));
#line 509
  sp1 = (base_number *)tmp___0;
#line 509
  sp = sp1;
#line 509
  *(froms + symno) = sp;
#line 510
  tmp___1 = xnmalloc((size_t )count, (size_t )sizeof(*sp2));
#line 510
  sp2 = (base_number *)tmp___1;
#line 510
  *(tos + symno) = sp2;
#line 513
  i = begin;
  }
  {
#line 513
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 513
    if (! (i < end)) {
#line 513
      goto while_break___0;
    }
#line 514
    if (*(to_state + i) != default_state) {
#line 516
      tmp___2 = sp1;
#line 516
      sp1 ++;
#line 516
      *tmp___2 = *(from_state + i);
#line 517
      tmp___3 = sp2;
#line 517
      sp2 ++;
#line 517
      *tmp___3 = *(to_state + i);
    }
#line 513
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 520
  *(tally + symno) = count;
#line 521
  *(width + symno) = (*(sp1 + -1) - *(sp + 0)) + 1;
#line 522
  return;
}
}
#line 529 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static state_number default_goto(symbol_number sym , size_t *state_count ) 
{ 
  state_number s ;
  goto_number i ;
  goto_number m ;
  goto_number n ;
  state_number default_state ;
  size_t max ;

  {
#line 534
  m = *(goto_map + (sym - ntokens));
#line 535
  n = *(goto_map + ((sym - ntokens) + 1));
#line 536
  default_state = -1;
#line 537
  max = (size_t )0;
#line 539
  if (m == n) {
#line 540
    return (-1);
  }
#line 542
  s = 0;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 542
    if (! (s < nstates)) {
#line 542
      goto while_break;
    }
#line 543
    *(state_count + s) = (size_t )0;
#line 542
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  i = m;
  {
#line 545
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 545
    if (! (i < n)) {
#line 545
      goto while_break___0;
    }
#line 546
    (*(state_count + *(to_state + i))) ++;
#line 545
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 548
  s = 0;
  {
#line 548
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 548
    if (! (s < nstates)) {
#line 548
      goto while_break___1;
    }
#line 549
    if (*(state_count + s) > max) {
#line 551
      max = *(state_count + s);
#line 552
      default_state = s;
    }
#line 548
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 555
  return (default_state);
}
}
#line 568 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static void goto_actions(void) 
{ 
  symbol_number i ;
  size_t *state_count ;
  void *tmp ;
  void *tmp___0 ;
  state_number default_state ;
  state_number tmp___1 ;

  {
  {
#line 572
  tmp = xnmalloc((size_t )nstates, (size_t )sizeof(*state_count));
#line 572
  state_count = (size_t *)tmp;
#line 573
  tmp___0 = xnmalloc((size_t )nvars, (size_t )sizeof(*yydefgoto));
#line 573
  yydefgoto = (state_number *)tmp___0;
#line 577
  i = ntokens;
  }
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! (i < nsyms)) {
#line 577
      goto while_break;
    }
    {
#line 579
    tmp___1 = default_goto(i, state_count);
#line 579
    default_state = tmp___1;
#line 580
    save_column(i, default_state);
#line 581
    *(yydefgoto + (i - ntokens)) = default_state;
#line 577
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 583
  free((void *)state_count);
  }
#line 584
  return;
}
}
#line 592 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static void sort_actions(void) 
{ 
  int i ;
  int k ;
  int t ;
  int w ;
  int j ;

  {
#line 597
  nentries = 0;
#line 599
  i = 0;
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 599
    if (! (i < nvectors)) {
#line 599
      goto while_break;
    }
#line 600
    if (*(tally + i) > 0) {
#line 603
      t = *(tally + i);
#line 604
      w = *(width + i);
#line 605
      j = nentries - 1;
      {
#line 607
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 607
        if (j >= 0) {
#line 607
          if (! (*(width + *(order + j)) < w)) {
#line 607
            goto while_break___0;
          }
        } else {
#line 607
          goto while_break___0;
        }
#line 608
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 610
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 610
        if (j >= 0) {
#line 610
          if (*(width + *(order + j)) == w) {
#line 610
            if (! (*(tally + *(order + j)) < t)) {
#line 610
              goto while_break___1;
            }
          } else {
#line 610
            goto while_break___1;
          }
        } else {
#line 610
          goto while_break___1;
        }
#line 611
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 613
      k = nentries - 1;
      {
#line 613
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 613
        if (! (k > j)) {
#line 613
          goto while_break___2;
        }
#line 614
        *(order + (k + 1)) = *(order + k);
#line 613
        k --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 616
      *(order + (j + 1)) = i;
#line 617
      nentries ++;
    }
#line 599
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return;
}
}
#line 628 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static state_number matching_state(vector_number vector ) 
{ 
  vector_number i ;
  int t ;
  int w ;
  int prev ;
  int j ;
  vector_number j___0 ;
  int k ;
  int match ;

  {
#line 631
  i = *(order + vector);
#line 637
  if (nstates <= i) {
#line 638
    return (-1);
  }
#line 640
  t = *(tally + i);
#line 641
  w = *(width + i);
#line 644
  if ((unsigned long )*(conflict_tos + i) != (unsigned long )((void *)0)) {
#line 647
    j = 0;
    {
#line 647
    while (1) {
      while_continue: /* CIL Label */ ;
#line 647
      if (! (j < t)) {
#line 647
        goto while_break;
      }
#line 648
      if (*(*(conflict_tos + i) + j) != 0U) {
#line 649
        return (-1);
      }
#line 647
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 652
  prev = vector - 1;
  {
#line 652
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 652
    if (! (prev >= 0)) {
#line 652
      goto while_break___0;
    }
#line 654
    j___0 = *(order + prev);
#line 656
    match = 1;
#line 660
    if (*(width + j___0) != w) {
#line 661
      return (-1);
    } else
#line 660
    if (*(tally + j___0) != t) {
#line 661
      return (-1);
    }
#line 663
    k = 0;
    {
#line 663
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 663
      if (match) {
#line 663
        if (! (k < t)) {
#line 663
          goto while_break___1;
        }
      } else {
#line 663
        goto while_break___1;
      }
#line 664
      if (*(*(tos + j___0) + k) != *(*(tos + i) + k)) {
#line 666
        match = 0;
      } else
#line 664
      if (*(*(froms + j___0) + k) != *(*(froms + i) + k)) {
#line 666
        match = 0;
      } else
#line 664
      if ((unsigned long )*(conflict_tos + j___0) != (unsigned long )((void *)0)) {
#line 664
        if (*(*(conflict_tos + j___0) + k) != 0U) {
#line 666
          match = 0;
        }
      }
#line 663
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 668
    if (match) {
#line 669
      return (j___0);
    }
#line 652
    prev --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 672
  return (-1);
}
}
#line 676 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static base_number pack_vector(vector_number vector ) 
{ 
  vector_number i ;
  int j ;
  int t ;
  int loc___0 ;
  base_number *from ;
  base_number *to ;
  unsigned int *conflict_to ;
  int k ;
  _Bool ok ;
  int tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 679
  i = *(order + vector);
#line 681
  t = *(tally + i);
#line 682
  loc___0 = 0;
#line 683
  from = *(froms + i);
#line 684
  to = *(tos + i);
#line 685
  conflict_to = *(conflict_tos + i);
#line 687
  if (! (t != 0)) {
    {
#line 687
    __assert_fail("t != 0", "/home/pronto/abs/test-suite/bison-2.5/src/tables.c",
                  687U, "pack_vector");
    }
  }
#line 689
  j = lowzero - *(from + 0);
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    ok = (_Bool)1;
#line 694
    if (! (j < table_size)) {
      {
#line 694
      __assert_fail("j < table_size", "/home/pronto/abs/test-suite/bison-2.5/src/tables.c",
                    694U, "pack_vector");
      }
    }
#line 696
    k = 0;
    {
#line 696
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 696
      if (ok) {
#line 696
        if (! (k < t)) {
#line 696
          goto while_break___0;
        }
      } else {
#line 696
        goto while_break___0;
      }
      {
#line 698
      tmp = state_number_as_int(*(from + k));
#line 698
      loc___0 = j + tmp;
      }
#line 699
      if (table_size <= loc___0) {
        {
#line 700
        table_grow(loc___0);
        }
      }
#line 702
      if (*(table + loc___0) != 0) {
#line 703
        ok = (_Bool)0;
      }
#line 696
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 706
    k = 0;
    {
#line 706
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 706
      if (ok) {
#line 706
        if (! (k < vector)) {
#line 706
          goto while_break___1;
        }
      } else {
#line 706
        goto while_break___1;
      }
#line 707
      if (*(pos + k) == j) {
#line 708
        ok = (_Bool)0;
      }
#line 706
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 710
    if (ok) {
#line 712
      k = 0;
      {
#line 712
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 712
        if (! (k < t)) {
#line 712
          goto while_break___2;
        }
#line 714
        loc___0 = j + *(from + k);
#line 715
        *(table + loc___0) = *(to + k);
#line 716
        if (nondeterministic_parser) {
#line 716
          if ((unsigned long )conflict_to != (unsigned long )((void *)0)) {
#line 717
            *(conflict_table + loc___0) = *(conflict_to + k);
          }
        }
#line 718
        *(check + loc___0) = *(from + k);
#line 712
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 721
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 721
        if (! (*(table + lowzero) != 0)) {
#line 721
          goto while_break___3;
        }
#line 722
        lowzero ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 724
      if (loc___0 > high) {
#line 725
        high = loc___0;
      }
#line 727
      if ((-0x7FFFFFFF-1) <= j) {
#line 727
        if (! (j <= 2147483647)) {
          {
#line 727
          __assert_fail("(-2147483647 - 1) <= j && j <= 2147483647", "/home/pronto/abs/test-suite/bison-2.5/src/tables.c",
                        727U, "pack_vector");
          }
        }
      } else {
        {
#line 727
        __assert_fail("(-2147483647 - 1) <= j && j <= 2147483647", "/home/pronto/abs/test-suite/bison-2.5/src/tables.c",
                      727U, "pack_vector");
        }
      }
#line 728
      return (j);
    }
#line 689
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 742 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static base_number table_ninf_remap(base_number *tab , int size , base_number ninf ) 
{ 
  base_number res ;
  int i ;

  {
#line 745
  res = 0;
#line 748
  i = 0;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! (i < size)) {
#line 748
      goto while_break;
    }
#line 749
    if (*(tab + i) < res) {
#line 749
      if (*(tab + i) != ninf) {
#line 750
        res = *(tab + i);
      }
    }
#line 748
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  res --;
#line 754
  i = 0;
  {
#line 754
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 754
    if (! (i < size)) {
#line 754
      goto while_break___0;
    }
#line 755
    if (*(tab + i) == ninf) {
#line 756
      *(tab + i) = res;
    }
#line 754
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 758
  return (res);
}
}
#line 761 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
static void pack_table(void) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  state_number s ;
  state_number tmp___4 ;
  base_number place ;

  {
  {
#line 766
  tmp = xnmalloc((size_t )nvectors, (size_t )sizeof(*base));
#line 766
  base = (base_number *)tmp;
#line 767
  tmp___0 = xnmalloc((size_t )nentries, (size_t )sizeof(*pos));
#line 767
  pos = (base_number *)tmp___0;
#line 768
  tmp___1 = xcalloc((size_t )table_size, (size_t )sizeof(*table));
#line 768
  table = (base_number *)tmp___1;
#line 769
  tmp___2 = xcalloc((size_t )table_size, (size_t )sizeof(*conflict_table));
#line 769
  conflict_table = (unsigned int *)tmp___2;
#line 770
  tmp___3 = xnmalloc((size_t )table_size, (size_t )sizeof(*check));
#line 770
  check = (base_number *)tmp___3;
#line 772
  lowzero = 0;
#line 773
  high = 0;
#line 775
  i = 0;
  }
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if (! (i < nvectors)) {
#line 775
      goto while_break;
    }
#line 776
    *(base + i) = (-0x7FFFFFFF-1);
#line 775
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  i = 0;
  {
#line 778
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 778
    if (! (i < table_size)) {
#line 778
      goto while_break___0;
    }
#line 779
    *(check + i) = -1;
#line 778
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 781
  i = 0;
  {
#line 781
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 781
    if (! (i < nentries)) {
#line 781
      goto while_break___1;
    }
    {
#line 783
    tmp___4 = matching_state(i);
#line 783
    s = tmp___4;
    }
#line 786
    if (s < 0) {
      {
#line 788
      place = pack_vector(i);
      }
    } else {
#line 791
      place = *(base + s);
    }
#line 793
    *(pos + i) = place;
#line 794
    *(base + *(order + i)) = place;
#line 781
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 798
  base_ninf = table_ninf_remap(base, nvectors, (-0x7FFFFFFF-1));
#line 799
  table_ninf = table_ninf_remap(table, high + 1, (-0x7FFFFFFF-1));
#line 801
  free((void *)pos);
  }
#line 802
  return;
}
}
#line 811 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
void tables_generate(void) 
{ 
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 822
  tmp = state_number_as_int(nstates);
#line 822
  nvectors = tmp + nvars;
#line 824
  tmp___0 = xcalloc((size_t )nvectors, (size_t )sizeof(*froms));
#line 824
  froms = (base_number **)tmp___0;
#line 825
  tmp___1 = xcalloc((size_t )nvectors, (size_t )sizeof(*tos));
#line 825
  tos = (base_number **)tmp___1;
#line 826
  tmp___2 = xcalloc((size_t )nvectors, (size_t )sizeof(*conflict_tos));
#line 826
  conflict_tos = (unsigned int **)tmp___2;
#line 827
  tmp___3 = xcalloc((size_t )nvectors, (size_t )sizeof(*tally));
#line 827
  tally = (int *)tmp___3;
#line 828
  tmp___4 = xnmalloc((size_t )nvectors, (size_t )sizeof(*width));
#line 828
  width = (base_number *)tmp___4;
#line 830
  token_actions();
#line 832
  goto_actions();
#line 833
  free((void *)goto_map);
#line 834
  free((void *)from_state);
#line 835
  free((void *)to_state);
#line 837
  tmp___5 = xcalloc((size_t )nvectors, (size_t )sizeof(*order));
#line 837
  order = (vector_number *)tmp___5;
#line 838
  sort_actions();
#line 839
  pack_table();
#line 840
  free((void *)order);
#line 842
  free((void *)tally);
#line 843
  free((void *)width);
#line 845
  i = 0;
  }
  {
#line 845
  while (1) {
    while_continue: /* CIL Label */ ;
#line 845
    if (! (i < nvectors)) {
#line 845
      goto while_break;
    }
    {
#line 847
    free((void *)*(froms + i));
#line 848
    free((void *)*(tos + i));
#line 849
    free((void *)*(conflict_tos + i));
#line 845
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 852
  free((void *)froms);
#line 853
  free((void *)tos);
#line 854
  free((void *)conflict_tos);
  }
#line 855
  return;
}
}
#line 862 "/home/pronto/abs/test-suite/bison-2.5/src/tables.c"
void tables_free(void) 
{ 


  {
  {
#line 865
  free((void *)base);
#line 866
  free((void *)conflict_table);
#line 867
  free((void *)conflict_list);
#line 868
  free((void *)table);
#line 869
  free((void *)check);
#line 870
  free((void *)yydefgoto);
#line 871
  free((void *)yydefact);
  }
#line 872
  return;
}
}
#line 710 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 140
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 60 "/home/pronto/abs/test-suite/bison-2.5/src/location.h"
__inline static int boundary_cmp(boundary a , boundary b ) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 63
  tmp = strcmp(a.file, b.file);
#line 63
  res = tmp;
  }
#line 64
  if (! res) {
#line 65
    res = a.line - b.line;
  }
#line 66
  if (! res) {
#line 67
    res = a.column - b.column;
  }
#line 68
  return (res);
}
}
#line 107 "/home/pronto/abs/test-suite/bison-2.5/src/location.h"
__inline static int location_cmp(location a , location b ) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 110
  tmp = boundary_cmp(a.start, b.start);
#line 110
  res = tmp;
  }
#line 111
  if (! res) {
    {
#line 112
    res = boundary_cmp(a.end, b.end);
    }
  }
#line 113
  return (res);
}
}
#line 41 "/home/pronto/abs/test-suite/bison-2.5/src/complain.h"
void ( /* format attribute */  warn_at)(location loc___0 , char const   *message 
                                        , ...) ;
#line 56
void ( /* format attribute */  complain_at)(location loc___0 , char const   *message 
                                            , ...) ;
#line 69
void ( /* format attribute */  yacc_at)(location loc___0 , char const   *message 
                                        , ...) ;
#line 80
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *message 
                                                                     , ...) ;
#line 83
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal_at)(location loc___0 ,
                                                                        char const   *message 
                                                                        , ...) ;
#line 32 "/home/pronto/abs/test-suite/bison-2.5/src/assoc.h"
char const   *assoc_to_string(assoc a ) ;
#line 79 "/home/pronto/abs/test-suite/bison-2.5/src/scan-code.h"
void code_props_none_init(code_props *self ) ;
#line 86
struct code_props  const  code_props_none ;
#line 109 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
void symbol_print(symbol *s , FILE *f ) ;
#line 112
symbol *symbol_from_uniqstr(uniqstr const   key , location loc___0 ) ;
#line 115
symbol *symbol_get(char const   *key , location loc___0 ) ;
#line 120
symbol *dummy_symbol_get(location loc___0 ) ;
#line 123
_Bool symbol_is_dummy(symbol const   *sym ) ;
#line 129
void symbol_make_alias(symbol *sym , symbol *str , location loc___0 ) ;
#line 134
void symbol_type_set(symbol *sym , uniqstr type_name , location loc___0 ) ;
#line 137
void symbol_destructor_set(symbol *sym , code_props const   *destructor ) ;
#line 141
code_props const   *symbol_destructor_get(symbol const   *sym ) ;
#line 144
void symbol_printer_set(symbol *sym , code_props const   *printer ) ;
#line 148
code_props const   *symbol_printer_get(symbol const   *sym ) ;
#line 154
void symbol_precedence_set(symbol *sym , int prec , assoc a , location loc___0 ) ;
#line 157
void symbol_class_set(symbol *sym , symbol_class class , location loc___0 , _Bool declaring ) ;
#line 161
void symbol_user_token_number_set(symbol *sym , int user_token_number , location loc___0 ) ;
#line 167
symbol *undeftoken ;
#line 169
symbol *endtoken ;
#line 173
symbol *accept ;
#line 176
symbol *startsymbol ;
#line 178 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.h"
location startsymbol_location  ;
#line 200
semantic_type *semantic_type_from_uniqstr(uniqstr const   key ) ;
#line 203
semantic_type *semantic_type_get(char const   *key ) ;
#line 206
void semantic_type_destructor_set(semantic_type *type , code_props const   *destructor ) ;
#line 210
void semantic_type_printer_set(semantic_type *type , code_props const   *printer ) ;
#line 218
void symbols_new(void) ;
#line 221
void symbols_free(void) ;
#line 226
void symbols_check_defined(void) ;
#line 232
void symbols_pack(void) ;
#line 240
void default_tagged_destructor_set(code_props const   *destructor ) ;
#line 242
void default_tagless_destructor_set(code_props const   *destructor ) ;
#line 245
void default_tagged_printer_set(code_props const   *printer ) ;
#line 247
void default_tagless_printer_set(code_props const   *printer ) ;
#line 238 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
symbol **symbols ;
#line 243
symbol_number *token_translations ;
#line 244
int max_user_token_number ;
#line 36 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static symbol **symbols_sorted  =    (symbol **)((void *)0);
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
symbol *errtoken  =    (symbol *)((void *)0);
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
symbol *undeftoken  =    (symbol *)((void *)0);
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
symbol *endtoken  =    (symbol *)((void *)0);
#line 45 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
symbol *accept  =    (symbol *)((void *)0);
#line 46 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
symbol *startsymbol  =    (symbol *)((void *)0);
#line 53 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static code_props default_tagged_destructor  =    {(enum __anonenum_kind_38 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0), (named_ref *)((void *)0)};
#line 54 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static code_props default_tagless_destructor  =    {(enum __anonenum_kind_38 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0), (named_ref *)((void *)0)};
#line 55 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static code_props default_tagged_printer  =    {(enum __anonenum_kind_38 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0), (named_ref *)((void *)0)};
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static code_props default_tagless_printer  =    {(enum __anonenum_kind_38 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0), (named_ref *)((void *)0)};
#line 62 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static symbol *symbol_new(uniqstr tag , location loc___0 ) 
{ 
  symbol *res ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 65
  tmp = xmalloc((size_t )sizeof(*res));
#line 65
  res = (symbol *)tmp;
#line 67
  uniqstr_assert(tag);
  }
#line 71
  if ((int const   )*(tag + 0) != 34) {
#line 71
    if ((int const   )*(tag + 0) != 39) {
      {
#line 71
      tmp___1 = mbschr(tag, '-');
      }
#line 71
      if (tmp___1) {
        {
#line 72
        tmp___0 = gettext("POSIX Yacc forbids dashes in symbol names: %s");
#line 72
        yacc_at(loc___0, (char const   *)tmp___0, tag);
        }
      }
    }
  }
  {
#line 75
  res->tag = tag;
#line 76
  res->location = loc___0;
#line 78
  res->type_name = (uniqstr )((void *)0);
#line 79
  code_props_none_init(& res->destructor);
#line 80
  code_props_none_init(& res->printer);
#line 82
  res->number = -1;
#line 83
  res->prec = 0;
#line 84
  res->assoc = (assoc )0;
#line 85
  res->user_token_number = -1;
#line 87
  res->alias = (symbol *)((void *)0);
#line 88
  res->class = (symbol_class )0;
#line 89
  res->declared = (_Bool)0;
  }
#line 91
  if (nsyms == 2147483647) {
    {
#line 92
    tmp___2 = gettext("too many symbols in input grammar (limit is %d)");
#line 92
    fatal((char const   *)tmp___2, 2147483647);
    }
  }
#line 94
  nsyms ++;
#line 95
  return (res);
}
}
#line 102 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static semantic_type *semantic_type_new(uniqstr tag ) 
{ 
  semantic_type *res ;
  void *tmp ;

  {
  {
#line 105
  tmp = xmalloc((size_t )sizeof(*res));
#line 105
  res = (semantic_type *)tmp;
#line 107
  uniqstr_assert(tag);
#line 108
  res->tag = tag;
#line 109
  code_props_none_init(& res->destructor);
#line 110
  code_props_none_init(& res->printer);
  }
#line 112
  return (res);
}
}
#line 128 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbol_print(symbol *s , FILE *f ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 131
  if (s) {
    {
#line 133
    rpl_fprintf(f, "\"%s\"", s->tag);
    }
#line 134
    if (s->type_name) {
      {
#line 134
      rpl_fprintf(f, " %s { %s }", "type_name", s->type_name);
      }
    }
#line 135
    if (s->destructor.code) {
      {
#line 135
      rpl_fprintf(f, " %s { %s }", "destructor", s->destructor.code);
      }
    }
#line 136
    if (s->printer.code) {
      {
#line 136
      rpl_fprintf(f, " %s { %s }", "printer", s->printer.code);
      }
    }
  } else {
    {
#line 139
    rpl_fprintf(f, "<NULL>");
    }
  }
#line 140
  return;
}
}
#line 150 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static void symbol_redeclaration(symbol *s , char const   *what , location first ,
                                 location second ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 154
  tmp = gettext("%s redeclaration for %s");
#line 154
  complain_at(second, (char const   *)tmp, what, s->tag);
#line 155
  tmp___0 = gettext("previous declaration");
#line 155
  complain_at(first, (char const   *)tmp___0);
  }
#line 156
  return;
}
}
#line 158 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static void semantic_type_redeclaration(semantic_type *s , char const   *what , location first ,
                                        location second ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 162
  tmp = gettext("%s redeclaration for <%s>");
#line 162
  complain_at(second, (char const   *)tmp, what, s->tag);
#line 163
  tmp___0 = gettext("previous declaration");
#line 163
  complain_at(first, (char const   *)tmp___0);
  }
#line 164
  return;
}
}
#line 173 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbol_type_set(symbol *sym , uniqstr type_name , location loc___0 ) 
{ 
  char *__cil_tmp4 ;

  {
#line 176
  if (type_name) {
#line 178
    if (sym->type_name) {
      {
#line 179
      symbol_redeclaration(sym, "%type", sym->type_location, loc___0);
      }
    }
    {
#line 180
    uniqstr_assert(type_name);
#line 181
    sym->type_name = type_name;
#line 182
    sym->type_location = loc___0;
    }
  }
#line 184
  return;
}
}
#line 190 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbol_destructor_set(symbol *sym , code_props const   *destructor ) 
{ 
  char *__cil_tmp3 ;

  {
#line 193
  if (sym->destructor.code) {
    {
#line 194
    symbol_redeclaration(sym, "%destructor", sym->destructor.location, (location )destructor->location);
    }
  }
#line 196
  sym->destructor = (code_props )*destructor;
#line 197
  return;
}
}
#line 203 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void semantic_type_destructor_set(semantic_type *type , code_props const   *destructor ) 
{ 
  char *__cil_tmp3 ;

  {
#line 207
  if (type->destructor.code) {
    {
#line 208
    semantic_type_redeclaration(type, "%destructor", type->destructor.location, (location )destructor->location);
    }
  }
#line 211
  type->destructor = (code_props )*destructor;
#line 212
  return;
}
}
#line 218 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
code_props const   *symbol_destructor_get(symbol const   *sym ) 
{ 
  code_props const   *destructor ;
  semantic_type *tmp ;

  {
#line 222
  if (sym->destructor.code) {
#line 223
    return (& sym->destructor);
  }
#line 226
  if (sym->type_name) {
    {
#line 228
    tmp = semantic_type_get((char const   *)sym->type_name);
#line 228
    destructor = (code_props const   *)(& tmp->destructor);
    }
#line 230
    if (destructor->code) {
#line 231
      return (destructor);
    }
  }
#line 235
  if ((int const   )*(sym->tag + 0) == 36) {
#line 236
    return (& code_props_none);
  } else
#line 235
  if ((unsigned long )sym == (unsigned long )errtoken) {
#line 236
    return (& code_props_none);
  }
#line 238
  if (sym->type_name) {
#line 239
    return ((code_props const   *)(& default_tagged_destructor));
  }
#line 240
  return ((code_props const   *)(& default_tagless_destructor));
}
}
#line 247 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbol_printer_set(symbol *sym , code_props const   *printer ) 
{ 
  char *__cil_tmp3 ;

  {
#line 250
  if (sym->printer.code) {
    {
#line 251
    symbol_redeclaration(sym, "%printer", sym->printer.location, (location )printer->location);
    }
  }
#line 253
  sym->printer = (code_props )*printer;
#line 254
  return;
}
}
#line 260 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void semantic_type_printer_set(semantic_type *type , code_props const   *printer ) 
{ 
  char *__cil_tmp3 ;

  {
#line 263
  if (type->printer.code) {
    {
#line 264
    semantic_type_redeclaration(type, "%printer", type->printer.location, (location )printer->location);
    }
  }
#line 266
  type->printer = (code_props )*printer;
#line 267
  return;
}
}
#line 273 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
code_props const   *symbol_printer_get(symbol const   *sym ) 
{ 
  code_props const   *printer ;
  semantic_type *tmp ;

  {
#line 277
  if (sym->printer.code) {
#line 278
    return (& sym->printer);
  }
#line 281
  if (sym->type_name) {
    {
#line 283
    tmp = semantic_type_get((char const   *)sym->type_name);
#line 283
    printer = (code_props const   *)(& tmp->printer);
    }
#line 284
    if (printer->code) {
#line 285
      return (printer);
    }
  }
#line 289
  if ((int const   )*(sym->tag + 0) == 36) {
#line 290
    return (& code_props_none);
  } else
#line 289
  if ((unsigned long )sym == (unsigned long )errtoken) {
#line 290
    return (& code_props_none);
  }
#line 292
  if (sym->type_name) {
#line 293
    return ((code_props const   *)(& default_tagged_printer));
  }
#line 294
  return ((code_props const   *)(& default_tagless_printer));
}
}
#line 302 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbol_precedence_set(symbol *sym , int prec , assoc a , location loc___0 ) 
{ 
  char const   *tmp ;

  {
#line 305
  if ((unsigned int )a != 0U) {
#line 307
    if (sym->prec != 0) {
      {
#line 308
      tmp = assoc_to_string(a);
#line 308
      symbol_redeclaration(sym, tmp, sym->prec_location, loc___0);
      }
    }
#line 310
    sym->prec = prec;
#line 311
    sym->assoc = a;
#line 312
    sym->prec_location = loc___0;
  }
  {
#line 316
  symbol_class_set(sym, (symbol_class )1, loc___0, (_Bool)0);
  }
#line 317
  return;
}
}
#line 324 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbol_class_set(symbol *sym , symbol_class class , location loc___0 , _Bool declaring ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 327
  if ((unsigned int )sym->class != 0U) {
#line 327
    if ((unsigned int )sym->class != (unsigned int )class) {
      {
#line 329
      tmp = gettext("symbol %s redefined");
#line 329
      complain_at(loc___0, (char const   *)tmp, sym->tag);
#line 330
      sym->declared = (_Bool)0;
      }
    }
  }
#line 333
  if ((unsigned int )class == 2U) {
#line 333
    if ((unsigned int )sym->class != 2U) {
#line 334
      tmp___0 = nvars;
#line 334
      nvars ++;
#line 334
      sym->number = tmp___0;
    } else {
#line 333
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 335
  if ((unsigned int )class == 1U) {
#line 335
    if (sym->number == -1) {
#line 336
      tmp___1 = ntokens;
#line 336
      ntokens ++;
#line 336
      sym->number = tmp___1;
    }
  }
#line 338
  sym->class = class;
#line 340
  if (declaring) {
#line 342
    if (sym->declared) {
      {
#line 343
      tmp___2 = gettext("symbol %s redeclared");
#line 343
      warn_at(loc___0, (char const   *)tmp___2, sym->tag);
      }
    }
#line 344
    sym->declared = (_Bool)1;
  }
#line 346
  return;
}
}
#line 353 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbol_user_token_number_set(symbol *sym , int user_token_number , location loc___0 ) 
{ 
  int *user_token_numberp ;
  char *tmp ;
  char *__cil_tmp6 ;

  {
#line 358
  if (sym->user_token_number != -9991) {
#line 359
    user_token_numberp = & sym->user_token_number;
  } else {
#line 361
    user_token_numberp = & (sym->alias)->user_token_number;
  }
#line 362
  if (*user_token_numberp != -1) {
#line 362
    if (*user_token_numberp != user_token_number) {
      {
#line 364
      tmp = gettext("redefining user token number of %s");
#line 364
      complain_at(loc___0, (char const   *)tmp, sym->tag);
      }
    }
  }
#line 366
  *user_token_numberp = user_token_number;
#line 368
  if (user_token_number == 0) {
#line 370
    endtoken = sym;
#line 373
    if (endtoken->number != -1) {
#line 374
      ntokens --;
    }
#line 375
    endtoken->number = 0;
  }
#line 377
  return;
}
}
#line 385 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
__inline static _Bool symbol_check_defined(symbol *sym ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 388
  if ((unsigned int )sym->class == 0U) {
    {
#line 390
    tmp = gettext("symbol %s is used, but is not defined as a token and has no rules");
#line 390
    complain_at(sym->location, (char const   *)tmp, sym->tag);
#line 394
    sym->class = (symbol_class )2;
#line 395
    tmp___0 = nvars;
#line 395
    nvars ++;
#line 395
    sym->number = tmp___0;
    }
  }
#line 398
  return ((_Bool)1);
}
}
#line 401 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static _Bool symbol_check_defined_processor(void *sym , void *null  __attribute__((__unused__)) ) 
{ 
  _Bool tmp ;

  {
  {
#line 404
  tmp = symbol_check_defined((symbol *)sym);
  }
#line 404
  return (tmp);
}
}
#line 408 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbol_make_alias(symbol *sym , symbol *str , location loc___0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 411
  if (str->alias) {
    {
#line 412
    tmp = gettext("symbol `%s\' used more than once as a literal string");
#line 412
    warn_at(loc___0, (char const   *)tmp, str->tag);
    }
  } else
#line 414
  if (sym->alias) {
    {
#line 415
    tmp___0 = gettext("symbol `%s\' given more than one literal string");
#line 415
    warn_at(loc___0, (char const   *)tmp___0, sym->tag);
    }
  } else {
    {
#line 419
    str->class = (symbol_class )1;
#line 420
    str->user_token_number = sym->user_token_number;
#line 421
    sym->user_token_number = -9991;
#line 422
    str->alias = sym;
#line 423
    sym->alias = str;
#line 424
    str->number = sym->number;
#line 425
    symbol_type_set(str, sym->type_name, loc___0);
    }
  }
#line 427
  return;
}
}
#line 435 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
__inline static void symbol_check_alias_consistency(symbol *this ) 
{ 
  symbol *sym ;
  symbol *str ;

  {
#line 438
  sym = this;
#line 439
  str = this->alias;
#line 442
  if (this->alias) {
#line 442
    if (! (this->user_token_number == -9991)) {
#line 444
      return;
    }
  } else {
#line 444
    return;
  }
#line 446
  if ((unsigned long )str->type_name != (unsigned long )sym->type_name) {
#line 448
    if (str->type_name) {
      {
#line 449
      symbol_type_set(sym, str->type_name, str->type_location);
      }
    } else {
      {
#line 451
      symbol_type_set(str, sym->type_name, sym->type_location);
      }
    }
  }
#line 455
  if (str->destructor.code) {
#line 455
    goto _L;
  } else
#line 455
  if (sym->destructor.code) {
    _L: /* CIL Label */ 
#line 457
    if (str->destructor.code) {
      {
#line 458
      symbol_destructor_set(sym, (code_props const   *)(& str->destructor));
      }
    } else {
      {
#line 460
      symbol_destructor_set(str, (code_props const   *)(& sym->destructor));
      }
    }
  }
#line 463
  if (str->printer.code) {
#line 463
    goto _L___0;
  } else
#line 463
  if (sym->printer.code) {
    _L___0: /* CIL Label */ 
#line 465
    if (str->printer.code) {
      {
#line 466
      symbol_printer_set(sym, (code_props const   *)(& str->printer));
      }
    } else {
      {
#line 468
      symbol_printer_set(str, (code_props const   *)(& sym->printer));
      }
    }
  }
#line 471
  if (sym->prec) {
#line 471
    goto _L___1;
  } else
#line 471
  if (str->prec) {
    _L___1: /* CIL Label */ 
#line 473
    if (str->prec) {
      {
#line 474
      symbol_precedence_set(sym, str->prec, str->assoc, str->prec_location);
      }
    } else {
      {
#line 477
      symbol_precedence_set(str, sym->prec, sym->assoc, sym->prec_location);
      }
    }
  }
#line 480
  return;
}
}
#line 482 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static _Bool symbol_check_alias_consistency_processor(void *this , void *null  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 486
  symbol_check_alias_consistency((symbol *)this);
  }
#line 487
  return ((_Bool)1);
}
}
#line 496 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
__inline static _Bool symbol_pack(symbol *this ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 499
  if (! (this->number != -1)) {
    {
#line 499
    __assert_fail("this->number != (-1)", "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c",
                  499U, "symbol_pack");
    }
  }
#line 500
  if ((unsigned int )this->class == 2U) {
#line 501
    this->number += ntokens;
  } else
#line 502
  if (this->user_token_number == -9991) {
#line 503
    return ((_Bool)1);
  }
#line 505
  *(symbols + this->number) = this;
#line 506
  return ((_Bool)1);
}
}
#line 509 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static _Bool symbol_pack_processor(void *this , void *null  __attribute__((__unused__)) ) 
{ 
  _Bool tmp ;

  {
  {
#line 512
  tmp = symbol_pack((symbol *)this);
  }
#line 512
  return (tmp);
}
}
#line 516 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static void user_token_number_redeclaration(int num , symbol *first , symbol *second ) 
{ 
  symbol *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 524
  tmp___0 = location_cmp(first->location, second->location);
  }
#line 524
  if (tmp___0 > 0) {
#line 526
    tmp = first;
#line 527
    first = second;
#line 528
    second = tmp;
  }
  {
#line 530
  tmp___1 = gettext("user token number %d redeclaration for %s");
#line 530
  complain_at(second->location, (char const   *)tmp___1, num, second->tag);
#line 533
  tmp___2 = gettext("previous declaration for %s");
#line 533
  complain_at(first->location, (char const   *)tmp___2, first->tag);
  }
#line 535
  return;
}
}
#line 541 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
__inline static _Bool symbol_translation(symbol *this ) 
{ 


  {
#line 545
  if ((unsigned int )this->class == 1U) {
#line 545
    if (this->user_token_number != -9991) {
#line 549
      if (*(token_translations + this->user_token_number) != undeftoken->number) {
        {
#line 550
        user_token_number_redeclaration(this->user_token_number, *(symbols + *(token_translations + this->user_token_number)),
                                        this);
        }
      }
#line 555
      *(token_translations + this->user_token_number) = this->number;
    }
  }
#line 558
  return ((_Bool)1);
}
}
#line 561 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static _Bool symbol_translation_processor(void *this , void *null  __attribute__((__unused__)) ) 
{ 
  _Bool tmp ;

  {
  {
#line 564
  tmp = symbol_translation((symbol *)this);
  }
#line 564
  return (tmp);
}
}
#line 575 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static struct hash_table *symbol_table  =    (struct hash_table *)((void *)0);
#line 576 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static struct hash_table *semantic_type_table  =    (struct hash_table *)((void *)0);
#line 578 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
__inline static _Bool hash_compare_symbol(symbol const   *m1 , symbol const   *m2 ) 
{ 


  {
#line 582
  return ((_Bool )((unsigned long )m1->tag == (unsigned long )m2->tag));
}
}
#line 585 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
__inline static _Bool hash_compare_semantic_type(semantic_type const   *m1 , semantic_type const   *m2 ) 
{ 


  {
#line 589
  return ((_Bool )((unsigned long )m1->tag == (unsigned long )m2->tag));
}
}
#line 592 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static _Bool hash_symbol_comparator(void const   *m1 , void const   *m2 ) 
{ 
  _Bool tmp ;

  {
  {
#line 595
  tmp = hash_compare_symbol((symbol const   *)m1, (symbol const   *)m2);
  }
#line 595
  return (tmp);
}
}
#line 598 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static _Bool hash_semantic_type_comparator(void const   *m1 , void const   *m2 ) 
{ 
  _Bool tmp ;

  {
  {
#line 601
  tmp = hash_compare_semantic_type((semantic_type const   *)m1, (semantic_type const   *)m2);
  }
#line 601
  return (tmp);
}
}
#line 604 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
__inline static size_t hash_symbol(symbol const   *m , size_t tablesize ) 
{ 


  {
#line 608
  return ((uintptr_t )m->tag % tablesize);
}
}
#line 611 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
__inline static size_t hash_semantic_type(semantic_type const   *m , size_t tablesize ) 
{ 


  {
#line 615
  return ((uintptr_t )m->tag % tablesize);
}
}
#line 618 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static size_t hash_symbol_hasher(void const   *m , size_t tablesize ) 
{ 
  size_t tmp ;

  {
  {
#line 621
  tmp = hash_symbol((symbol const   *)m, tablesize);
  }
#line 621
  return (tmp);
}
}
#line 624 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static size_t hash_semantic_type_hasher(void const   *m , size_t tablesize ) 
{ 
  size_t tmp ;

  {
  {
#line 627
  tmp = hash_semantic_type((semantic_type const   *)m, tablesize);
  }
#line 627
  return (tmp);
}
}
#line 634 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbols_new(void) 
{ 


  {
  {
#line 637
  symbol_table = hash_initialize((size_t )257, (Hash_tuning const   *)((void *)0),
                                 & hash_symbol_hasher, & hash_symbol_comparator, & free);
#line 642
  semantic_type_table = hash_initialize((size_t )257, (Hash_tuning const   *)((void *)0),
                                        & hash_semantic_type_hasher, & hash_semantic_type_comparator,
                                        & free);
  }
#line 647
  return;
}
}
#line 655 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
symbol *symbol_from_uniqstr(uniqstr const   key , location loc___0 ) 
{ 
  symbol probe ;
  symbol *entry ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 661
  probe.tag = (uniqstr )key;
#line 662
  tmp = hash_lookup((Hash_table const   *)symbol_table, (void const   *)(& probe));
#line 662
  entry = (symbol *)tmp;
  }
#line 664
  if (! entry) {
#line 667
    if (! (! symbols_sorted)) {
      {
#line 667
      __assert_fail("!symbols_sorted", "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c",
                    667U, "symbol_from_uniqstr");
      }
    }
    {
#line 668
    entry = symbol_new((uniqstr )key, loc___0);
#line 669
    tmp___0 = hash_insert(symbol_table, (void const   *)entry);
    }
#line 669
    if (! tmp___0) {
      {
#line 670
      xalloc_die();
      }
    }
  }
#line 672
  return (entry);
}
}
#line 681 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
semantic_type *semantic_type_from_uniqstr(uniqstr const   key ) 
{ 
  semantic_type probe ;
  semantic_type *entry ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 687
  probe.tag = (uniqstr )key;
#line 688
  tmp = hash_lookup((Hash_table const   *)semantic_type_table, (void const   *)(& probe));
#line 688
  entry = (semantic_type *)tmp;
  }
#line 690
  if (! entry) {
    {
#line 693
    entry = semantic_type_new((uniqstr )key);
#line 694
    tmp___0 = hash_insert(semantic_type_table, (void const   *)entry);
    }
#line 694
    if (! tmp___0) {
      {
#line 695
      xalloc_die();
      }
    }
  }
#line 697
  return (entry);
}
}
#line 706 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
symbol *symbol_get(char const   *key , location loc___0 ) 
{ 
  uniqstr tmp ;
  symbol *tmp___0 ;

  {
  {
#line 709
  tmp = uniqstr_new(key);
#line 709
  tmp___0 = symbol_from_uniqstr((uniqstr const   )tmp, loc___0);
  }
#line 709
  return (tmp___0);
}
}
#line 718 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
semantic_type *semantic_type_get(char const   *key ) 
{ 
  uniqstr tmp ;
  semantic_type *tmp___0 ;

  {
  {
#line 721
  tmp = uniqstr_new(key);
#line 721
  tmp___0 = semantic_type_from_uniqstr((uniqstr const   )tmp);
  }
#line 721
  return (tmp___0);
}
}
#line 734 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static int dummy_count  =    0;
#line 735 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static char buf[256]  ;
#line 730 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
symbol *dummy_symbol_get(location loc___0 ) 
{ 
  symbol *sym ;
  int tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 739
  dummy_count ++;
#line 739
  rpl_sprintf(buf, "$@%d", dummy_count);
#line 740
  sym = symbol_get((char const   *)(buf), loc___0);
#line 741
  sym->class = (symbol_class )2;
#line 742
  tmp = nvars;
#line 742
  nvars ++;
#line 742
  sym->number = tmp;
  }
#line 743
  return (sym);
}
}
#line 746 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
_Bool symbol_is_dummy(symbol const   *sym ) 
{ 
  int tmp ;

  {
#line 749
  if ((int const   )*(sym->tag + 0) == 64) {
#line 749
    tmp = 1;
  } else
#line 749
  if ((int const   )*(sym->tag + 0) == 36) {
#line 749
    if ((int const   )*(sym->tag + 1) == 64) {
#line 749
      tmp = 1;
    } else {
#line 749
      tmp = 0;
    }
  } else {
#line 749
    tmp = 0;
  }
#line 749
  return ((_Bool )tmp);
}
}
#line 756 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbols_free(void) 
{ 


  {
  {
#line 759
  hash_free(symbol_table);
#line 760
  hash_free(semantic_type_table);
#line 761
  free((void *)symbols);
#line 762
  free((void *)symbols_sorted);
  }
#line 763
  return;
}
}
#line 771 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static int symbols_cmp(symbol const   *a , symbol const   *b ) 
{ 
  int tmp ;

  {
  {
#line 774
  tmp = strcmp((char const   *)a->tag, (char const   *)b->tag);
  }
#line 774
  return (tmp);
}
}
#line 777 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static int symbols_cmp_qsort(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 780
  tmp = symbols_cmp((symbol const   *)*((symbol * const  *)a), (symbol const   *)*((symbol * const  *)b));
  }
#line 780
  return (tmp);
}
}
#line 783 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static void symbols_do(_Bool (*processor)(void * , void * ) , void *processor_data ) 
{ 
  size_t count ;
  size_t tmp ;
  void *tmp___0 ;
  size_t i ;

  {
  {
#line 786
  tmp = hash_get_n_entries((Hash_table const   *)symbol_table);
#line 786
  count = tmp;
  }
#line 787
  if (! symbols_sorted) {
    {
#line 789
    tmp___0 = xnmalloc(count, (size_t )sizeof(*symbols_sorted));
#line 789
    symbols_sorted = (symbol **)tmp___0;
#line 790
    hash_get_entries((Hash_table const   *)symbol_table, (void **)symbols_sorted,
                     count);
#line 791
    qsort((void *)symbols_sorted, count, (size_t )sizeof(*symbols_sorted), & symbols_cmp_qsort);
    }
  }
#line 796
  i = (size_t )0;
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 796
    if (! (i < count)) {
#line 796
      goto while_break;
    }
    {
#line 797
    (*processor)((void *)*(symbols_sorted + i), processor_data);
#line 796
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  return;
}
}
#line 806 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbols_check_defined(void) 
{ 


  {
  {
#line 809
  symbols_do(& symbol_check_defined_processor, (void *)0);
  }
#line 810
  return;
}
}
#line 817 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
static void symbols_token_translations_init(void) 
{ 
  _Bool num_256_available_p ;
  int i ;
  symbol *this ;
  symbol *this___0 ;
  void *tmp ;

  {
#line 820
  num_256_available_p = (_Bool)1;
#line 825
  max_user_token_number = 0;
#line 826
  i = 0;
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! (i < ntokens)) {
#line 826
      goto while_break;
    }
#line 828
    this = *(symbols + i);
#line 829
    if (this->user_token_number != -1) {
#line 831
      if (this->user_token_number > max_user_token_number) {
#line 832
        max_user_token_number = this->user_token_number;
      }
#line 833
      if (this->user_token_number == 256) {
#line 834
        num_256_available_p = (_Bool)0;
      }
    }
#line 826
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  if (num_256_available_p) {
#line 839
    if (errtoken->user_token_number == -1) {
#line 841
      errtoken->user_token_number = 256;
    }
  }
#line 844
  if (max_user_token_number < 256) {
#line 845
    max_user_token_number = 256;
  }
#line 847
  i = 0;
  {
#line 847
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 847
    if (! (i < ntokens)) {
#line 847
      goto while_break___0;
    }
#line 849
    this___0 = *(symbols + i);
#line 850
    if (this___0->user_token_number == -1) {
#line 851
      max_user_token_number ++;
#line 851
      this___0->user_token_number = max_user_token_number;
    }
#line 852
    if (this___0->user_token_number > max_user_token_number) {
#line 853
      max_user_token_number = this___0->user_token_number;
    }
#line 847
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 856
  tmp = xnmalloc((size_t )(max_user_token_number + 1), (size_t )sizeof(*token_translations));
#line 856
  token_translations = (symbol_number *)tmp;
#line 862
  i = 0;
  }
  {
#line 862
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 862
    if (! (i < max_user_token_number + 1)) {
#line 862
      goto while_break___1;
    }
#line 863
    *(token_translations + i) = undeftoken->number;
#line 862
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 864
  symbols_do(& symbol_translation_processor, (void *)0);
  }
#line 865
  return;
}
}
#line 873 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void symbols_pack(void) 
{ 
  void *tmp ;
  int writei ;
  int readi ;
  int nsyms_old ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 876
  symbols_do(& symbol_check_alias_consistency_processor, (void *)0);
#line 878
  tmp = xcalloc((size_t )nsyms, (size_t )sizeof(*symbols));
#line 878
  symbols = (symbol **)tmp;
#line 879
  symbols_do(& symbol_pack_processor, (void *)0);
#line 885
  nsyms_old = nsyms;
#line 886
  writei = 0;
#line 886
  readi = 0;
  }
  {
#line 886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 886
    if (! (readi < nsyms_old)) {
#line 886
      goto while_break;
    }
#line 888
    if ((unsigned long )*(symbols + readi) == (unsigned long )((void *)0)) {
#line 890
      nsyms --;
#line 891
      ntokens --;
    } else {
#line 895
      *(symbols + writei) = *(symbols + readi);
#line 896
      (*(symbols + writei))->number = writei;
#line 897
      if ((*(symbols + writei))->alias) {
#line 898
        ((*(symbols + writei))->alias)->number = writei;
      }
#line 899
      writei ++;
    }
#line 886
    readi ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 903
  tmp___0 = xnrealloc((void *)symbols, (size_t )nsyms, (size_t )sizeof(*symbols));
#line 903
  symbols = (symbol **)tmp___0;
#line 905
  symbols_token_translations_init();
  }
#line 907
  if ((unsigned int )startsymbol->class == 0U) {
    {
#line 908
    tmp___1 = gettext("the start symbol %s is undefined");
#line 908
    fatal_at(startsymbol_location, (char const   *)tmp___1, startsymbol->tag);
    }
  } else
#line 911
  if ((unsigned int )startsymbol->class == 1U) {
    {
#line 912
    tmp___2 = gettext("the start symbol %s is a token");
#line 912
    fatal_at(startsymbol_location, (char const   *)tmp___2, startsymbol->tag);
    }
  }
#line 915
  return;
}
}
#line 922 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void default_tagged_destructor_set(code_props const   *destructor ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 925
  if (default_tagged_destructor.code) {
    {
#line 927
    tmp = gettext("redeclaration for default tagged %%destructor");
#line 927
    complain_at((location )destructor->location, (char const   *)tmp);
#line 929
    tmp___0 = gettext("previous declaration");
#line 929
    complain_at(default_tagged_destructor.location, (char const   *)tmp___0);
    }
  }
#line 932
  default_tagged_destructor = (code_props )*destructor;
#line 933
  return;
}
}
#line 935 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void default_tagless_destructor_set(code_props const   *destructor ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 938
  if (default_tagless_destructor.code) {
    {
#line 940
    tmp = gettext("redeclaration for default tagless %%destructor");
#line 940
    complain_at((location )destructor->location, (char const   *)tmp);
#line 942
    tmp___0 = gettext("previous declaration");
#line 942
    complain_at(default_tagless_destructor.location, (char const   *)tmp___0);
    }
  }
#line 945
  default_tagless_destructor = (code_props )*destructor;
#line 946
  return;
}
}
#line 948 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void default_tagged_printer_set(code_props const   *printer ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 951
  if (default_tagged_printer.code) {
    {
#line 953
    tmp = gettext("redeclaration for default tagged %%printer");
#line 953
    complain_at((location )printer->location, (char const   *)tmp);
#line 955
    tmp___0 = gettext("previous declaration");
#line 955
    complain_at(default_tagged_printer.location, (char const   *)tmp___0);
    }
  }
#line 958
  default_tagged_printer = (code_props )*printer;
#line 959
  return;
}
}
#line 961 "/home/pronto/abs/test-suite/bison-2.5/src/symtab.c"
void default_tagless_printer_set(code_props const   *printer ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 964
  if (default_tagless_printer.code) {
    {
#line 966
    tmp = gettext("redeclaration for default tagless %%printer");
#line 966
    complain_at((location )printer->location, (char const   *)tmp);
#line 968
    tmp___0 = gettext("previous declaration");
#line 968
    complain_at(default_tagless_printer.location, (char const   *)tmp___0);
    }
  }
#line 971
  default_tagless_printer = (code_props )*printer;
#line 972
  return;
}
}
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/named-ref.h"
void named_ref_free(named_ref *r ) ;
#line 115 "/home/pronto/abs/test-suite/bison-2.5/src/scan-code.h"
void code_props_symbol_action_init(code_props *self , char const   *code , location code_loc ) ;
#line 150
void code_props_translate_code(code_props *self ) ;
#line 86 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.h"
symbol_list *symbol_list_sym_new(symbol *sym , location loc___0 ) ;
#line 89
symbol_list *symbol_list_type_new(uniqstr type_name , location loc___0 ) ;
#line 92
symbol_list *symbol_list_default_tagged_new(location loc___0 ) ;
#line 94
symbol_list *symbol_list_default_tagless_new(location loc___0 ) ;
#line 100
void symbol_list_syms_print(symbol_list const   *l , FILE *f ) ;
#line 103
symbol_list *symbol_list_prepend(symbol_list *list , symbol_list *node ) ;
#line 106
void symbol_list_free(symbol_list *list ) ;
#line 109
int symbol_list_length(symbol_list const   *l ) ;
#line 112
symbol_list *symbol_list_n_get(symbol_list *l , int n ) ;
#line 116
uniqstr symbol_list_n_type_name_get(symbol_list *l , location loc___0 , int n ) ;
#line 119
_Bool symbol_list_null(symbol_list *node ) ;
#line 122
void symbol_list_destructor_set(symbol_list *node , char const   *code , location loc___0 ) ;
#line 126
void symbol_list_printer_set(symbol_list *node , char const   *code , location loc___0 ) ;
#line 32 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
symbol_list *symbol_list_sym_new(symbol *sym , location loc___0 ) 
{ 
  symbol_list *res ;
  void *tmp ;
  location tmp___0 ;

  {
  {
#line 35
  tmp = xmalloc((size_t )sizeof(*res));
#line 35
  res = (symbol_list *)tmp;
#line 37
  res->content_type = (enum __anonenum_content_type_47 )0;
#line 38
  res->content.sym = sym;
#line 39
  tmp___0 = loc___0;
#line 39
  res->sym_loc = tmp___0;
#line 39
  res->location = tmp___0;
#line 41
  res->midrule = (struct symbol_list *)((void *)0);
#line 42
  res->midrule_parent_rule = (struct symbol_list *)((void *)0);
#line 43
  res->midrule_parent_rhs_index = 0;
#line 45
  code_props_none_init(& res->action_props);
#line 47
  res->ruleprec = (symbol *)((void *)0);
#line 48
  res->dprec = 0;
#line 49
  res->merger = 0;
#line 51
  res->named_ref = (named_ref *)((void *)0);
#line 53
  res->next = (struct symbol_list *)((void *)0);
  }
#line 55
  return (res);
}
}
#line 63 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
symbol_list *symbol_list_type_new(uniqstr type_name , location loc___0 ) 
{ 
  symbol_list *res ;
  void *tmp ;
  location tmp___0 ;

  {
  {
#line 66
  tmp = xmalloc((size_t )sizeof(*res));
#line 66
  res = (symbol_list *)tmp;
#line 68
  res->content_type = (enum __anonenum_content_type_47 )1;
#line 69
  res->content.type_name = type_name;
#line 70
  tmp___0 = loc___0;
#line 70
  res->sym_loc = tmp___0;
#line 70
  res->location = tmp___0;
#line 71
  res->named_ref = (named_ref *)((void *)0);
#line 72
  res->next = (struct symbol_list *)((void *)0);
  }
#line 74
  return (res);
}
}
#line 82 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
symbol_list *symbol_list_default_tagged_new(location loc___0 ) 
{ 
  symbol_list *res ;
  void *tmp ;
  location tmp___0 ;

  {
  {
#line 85
  tmp = xmalloc((size_t )sizeof(*res));
#line 85
  res = (symbol_list *)tmp;
#line 87
  res->content_type = (enum __anonenum_content_type_47 )2;
#line 88
  tmp___0 = loc___0;
#line 88
  res->sym_loc = tmp___0;
#line 88
  res->location = tmp___0;
#line 89
  res->named_ref = (named_ref *)((void *)0);
#line 90
  res->next = (struct symbol_list *)((void *)0);
  }
#line 92
  return (res);
}
}
#line 100 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
symbol_list *symbol_list_default_tagless_new(location loc___0 ) 
{ 
  symbol_list *res ;
  void *tmp ;
  location tmp___0 ;

  {
  {
#line 103
  tmp = xmalloc((size_t )sizeof(*res));
#line 103
  res = (symbol_list *)tmp;
#line 105
  res->content_type = (enum __anonenum_content_type_47 )3;
#line 106
  tmp___0 = loc___0;
#line 106
  res->sym_loc = tmp___0;
#line 106
  res->location = tmp___0;
#line 107
  res->named_ref = (named_ref *)((void *)0);
#line 108
  res->next = (struct symbol_list *)((void *)0);
  }
#line 110
  return (res);
}
}
#line 118 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
void symbol_list_syms_print(symbol_list const   *l , FILE *f ) 
{ 
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (l) {
#line 121
      if (! l->content.sym) {
#line 121
        goto while_break;
      }
    } else {
#line 121
      goto while_break;
    }
    {
#line 123
    symbol_print((symbol *)l->content.sym, f);
    }
#line 124
    if (l->action_props.is_value_used) {
#line 124
      tmp = " used";
    } else {
#line 124
      tmp = " unused";
    }
    {
#line 124
    rpl_fprintf(stderr, tmp);
    }
#line 125
    if (l) {
#line 125
      if (l->content.sym) {
        {
#line 126
        rpl_fprintf(f, ", ");
        }
      }
    }
#line 121
    l = (symbol_list const   *)l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 135 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
symbol_list *symbol_list_prepend(symbol_list *list , symbol_list *node ) 
{ 


  {
#line 138
  node->next = list;
#line 139
  return (node);
}
}
#line 147 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
void symbol_list_free(symbol_list *list ) 
{ 
  symbol_list *node ;
  symbol_list *next ;

  {
#line 151
  node = list;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! node) {
#line 151
      goto while_break;
    }
    {
#line 153
    next = node->next;
#line 154
    named_ref_free(node->named_ref);
#line 155
    free((void *)node);
#line 151
    node = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 164 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
int symbol_list_length(symbol_list const   *l ) 
{ 
  int res ;

  {
#line 167
  res = 0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (l) {
#line 168
      if ((unsigned int const   )l->content_type == 0U) {
#line 168
        if ((unsigned long )l->content.sym == (unsigned long )((void *)0)) {
#line 168
          goto while_break;
        }
      }
    } else {
#line 168
      goto while_break;
    }
#line 171
    res ++;
#line 168
    l = (symbol_list const   *)l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return (res);
}
}
#line 180 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
symbol_list *symbol_list_n_get(symbol_list *l , int n ) 
{ 
  int i ;

  {
#line 185
  if (n < 0) {
#line 186
    return ((symbol_list *)((void *)0));
  }
#line 188
  i = 0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < n)) {
#line 188
      goto while_break;
    }
#line 190
    l = l->next;
#line 191
    if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 193
      return ((symbol_list *)((void *)0));
    } else
#line 191
    if ((unsigned int )l->content_type == 0U) {
#line 191
      if ((unsigned long )l->content.sym == (unsigned long )((void *)0)) {
#line 193
        return ((symbol_list *)((void *)0));
      }
    }
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (l);
}
}
#line 205 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
uniqstr symbol_list_n_type_name_get(symbol_list *l , location loc___0 , int n ) 
{ 
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 208
  l = symbol_list_n_get(l, n);
  }
#line 209
  if (! l) {
    {
#line 211
    tmp = gettext("invalid $ value: $%d");
#line 211
    complain_at(loc___0, (char const   *)tmp, n);
    }
#line 212
    return ((uniqstr )((void *)0));
  }
#line 214
  if (! ((unsigned int )l->content_type == 0U)) {
    {
#line 214
    __assert_fail("l->content_type == SYMLIST_SYMBOL", "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c",
                  214U, "symbol_list_n_type_name_get");
    }
  }
#line 215
  return ((l->content.sym)->type_name);
}
}
#line 218 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
_Bool symbol_list_null(symbol_list *node ) 
{ 
  int tmp ;

  {
#line 221
  if (! node) {
#line 221
    tmp = 1;
  } else
#line 221
  if ((unsigned int )node->content_type == 0U) {
#line 221
    if (! node->content.sym) {
#line 221
      tmp = 1;
    } else {
#line 221
      tmp = 0;
    }
  } else {
#line 221
    tmp = 0;
  }
#line 221
  return ((_Bool )tmp);
}
}
#line 225 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
void symbol_list_destructor_set(symbol_list *node , char const   *code , location loc___0 ) 
{ 
  code_props destructor ;
  semantic_type *tmp ;

  {
  {
#line 229
  code_props_symbol_action_init(& destructor, code, loc___0);
#line 230
  code_props_translate_code(& destructor);
  }
  {
#line 233
  if ((unsigned int )node->content_type == 0U) {
#line 233
    goto case_0;
  }
#line 236
  if ((unsigned int )node->content_type == 1U) {
#line 236
    goto case_1;
  }
#line 240
  if ((unsigned int )node->content_type == 2U) {
#line 240
    goto case_2;
  }
#line 243
  if ((unsigned int )node->content_type == 3U) {
#line 243
    goto case_3;
  }
#line 231
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 234
  symbol_destructor_set(node->content.sym, (code_props const   *)(& destructor));
  }
#line 235
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 237
  tmp = semantic_type_get(node->content.type_name);
#line 237
  semantic_type_destructor_set(tmp, (code_props const   *)(& destructor));
  }
#line 239
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 241
  default_tagged_destructor_set((code_props const   *)(& destructor));
  }
#line 242
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 244
  default_tagless_destructor_set((code_props const   *)(& destructor));
  }
#line 245
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 249 "/home/pronto/abs/test-suite/bison-2.5/src/symlist.c"
void symbol_list_printer_set(symbol_list *node , char const   *code , location loc___0 ) 
{ 
  code_props printer ;
  semantic_type *tmp ;

  {
  {
#line 253
  code_props_symbol_action_init(& printer, code, loc___0);
#line 254
  code_props_translate_code(& printer);
  }
  {
#line 257
  if ((unsigned int )node->content_type == 0U) {
#line 257
    goto case_0;
  }
#line 260
  if ((unsigned int )node->content_type == 1U) {
#line 260
    goto case_1;
  }
#line 264
  if ((unsigned int )node->content_type == 2U) {
#line 264
    goto case_2;
  }
#line 267
  if ((unsigned int )node->content_type == 3U) {
#line 267
    goto case_3;
  }
#line 255
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 258
  symbol_printer_set(node->content.sym, (code_props const   *)(& printer));
  }
#line 259
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 261
  tmp = semantic_type_get(node->content.type_name);
#line 261
  semantic_type_printer_set(tmp, (code_props const   *)(& printer));
  }
#line 263
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 265
  default_tagged_printer_set((code_props const   *)(& printer));
  }
#line 266
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 268
  default_tagless_printer_set((code_props const   *)(& printer));
  }
#line 269
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 271
  return;
}
}
#line 162 "/home/pronto/abs/test-suite/bison-2.5/src/state.h"
struct state *transitions_to(transitions *shifts , symbol_number sym ) ;
#line 175
errs *errs_new(int num , symbol **tokens ) ;
#line 227
state *final_state ;
#line 230
state *state_new(symbol_number accessing_symbol , size_t nitems , item_number *core ) ;
#line 232
state *state_new_isocore(state const   *s ) ;
#line 235
void state_transitions_set(state *s , int num , state **trans ) ;
#line 238
void state_reductions_set(state *s , int num , rule **reds ) ;
#line 240
int state_reduction_find(state *s , rule *r ) ;
#line 243
void state_errs_set(state *s , int num , symbol **tokens ) ;
#line 247
void state_rule_lookahead_tokens_print(state *s , rule *r , FILE *out ) ;
#line 248
void state_rule_lookahead_tokens_print_xml(state *s , rule *r , FILE *out , int level ) ;
#line 252
void state_hash_new(void) ;
#line 253
void state_hash_free(void) ;
#line 257
state *state_hash_lookup(size_t nitems , item_number *core ) ;
#line 260
void state_hash_insert(state *s ) ;
#line 266
void state_remove_unreachable_states(state_number *old_to_new ) ;
#line 272
void states_free(void) ;
#line 24 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.h"
void xml_puts(FILE *out , int level , char const   *s ) ;
#line 25
void xml_printf(FILE *out , int level , char const   *fmt  , ...) ;
#line 27
char const   *xml_escape(char const   *str ) ;
#line 40 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
static transitions *transitions_new(int num , state **the_states ) 
{ 
  size_t states_size ;
  transitions *res ;
  void *tmp ;

  {
  {
#line 43
  states_size = (size_t )((unsigned long )num * sizeof(*the_states));
#line 44
  tmp = xmalloc((size_t )((unsigned long )(& ((transitions *)0)->states) + (unsigned long )states_size));
#line 44
  res = (transitions *)tmp;
#line 45
  res->num = num;
#line 46
  memcpy((void */* __restrict  */)(res->states), (void const   */* __restrict  */)the_states,
         states_size);
  }
#line 47
  return (res);
}
}
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
struct state *transitions_to(transitions *shifts , symbol_number sym ) 
{ 
  int j ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 60
  j = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (j < shifts->num)) {
      {
#line 62
      __assert_fail("j < shifts->num", "/home/pronto/abs/test-suite/bison-2.5/src/state.c",
                    62U, "transitions_to");
      }
    }
#line 63
    if ((shifts->states[j])->accessing_symbol == sym) {
#line 64
      return (shifts->states[j]);
    }
#line 60
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 78 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
errs *errs_new(int num , symbol **tokens ) 
{ 
  size_t symbols_size ;
  errs *res ;
  void *tmp ;

  {
  {
#line 81
  symbols_size = (size_t )((unsigned long )num * sizeof(*tokens));
#line 82
  tmp = xmalloc((size_t )((unsigned long )(& ((errs *)0)->symbols) + (unsigned long )symbols_size));
#line 82
  res = (errs *)tmp;
#line 83
  res->num = num;
#line 84
  memcpy((void */* __restrict  */)(res->symbols), (void const   */* __restrict  */)tokens,
         symbols_size);
  }
#line 85
  return (res);
}
}
#line 100 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
static reductions *reductions_new(int num , rule **reds ) 
{ 
  size_t rules_size ;
  reductions *res ;
  void *tmp ;

  {
  {
#line 103
  rules_size = (size_t )((unsigned long )num * sizeof(*reds));
#line 104
  tmp = xmalloc((size_t )((unsigned long )(& ((reductions *)0)->rules) + (unsigned long )rules_size));
#line 104
  res = (reductions *)tmp;
#line 105
  res->num = num;
#line 106
  res->lookahead_tokens = (bitset *)((void *)0);
#line 107
  memcpy((void */* __restrict  */)(res->rules), (void const   */* __restrict  */)reds,
         rules_size);
  }
#line 108
  return (res);
}
}
#line 118 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
state_number nstates  =    0;
#line 121 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
state *final_state  =    (state *)((void *)0);
#line 129 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
state *state_new(symbol_number accessing_symbol , size_t nitems , item_number *core ) 
{ 
  state *res ;
  size_t items_size ;
  void *tmp ;
  state_number tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 134
  items_size = (size_t )((unsigned long )nitems * sizeof(*core));
#line 136
  if (! (nstates < 2147483647)) {
    {
#line 136
    __assert_fail("nstates < 2147483647", "/home/pronto/abs/test-suite/bison-2.5/src/state.c",
                  136U, "state_new");
    }
  }
  {
#line 138
  tmp = xmalloc((size_t )((unsigned long )(& ((state *)0)->items) + (unsigned long )items_size));
#line 138
  res = (state *)tmp;
#line 139
  tmp___0 = nstates;
#line 139
  nstates ++;
#line 139
  res->number = tmp___0;
#line 140
  res->accessing_symbol = accessing_symbol;
#line 141
  res->transitions = (transitions *)((void *)0);
#line 142
  res->reductions = (reductions *)((void *)0);
#line 143
  res->errs = (errs *)((void *)0);
#line 144
  res->state_list = (struct state_list *)((void *)0);
#line 145
  res->consistent = (char)0;
#line 146
  res->solved_conflicts = (char const   *)((void *)0);
#line 147
  res->solved_conflicts_xml = (char const   *)((void *)0);
#line 149
  res->nitems = nitems;
#line 150
  memcpy((void */* __restrict  */)(res->items), (void const   */* __restrict  */)core,
         items_size);
#line 152
  state_hash_insert(res);
  }
#line 154
  return (res);
}
}
#line 157 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
state *state_new_isocore(state const   *s ) 
{ 
  state *res ;
  size_t items_size ;
  void *tmp ;
  state_number tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 161
  items_size = (size_t )((unsigned long )s->nitems * sizeof(s->items[0]));
#line 163
  if (! (nstates < 2147483647)) {
    {
#line 163
    __assert_fail("nstates < 2147483647", "/home/pronto/abs/test-suite/bison-2.5/src/state.c",
                  163U, "state_new_isocore");
    }
  }
  {
#line 165
  tmp = xmalloc((size_t )((unsigned long )(& ((state *)0)->items) + (unsigned long )items_size));
#line 165
  res = (state *)tmp;
#line 166
  tmp___0 = nstates;
#line 166
  nstates ++;
#line 166
  res->number = tmp___0;
#line 167
  res->accessing_symbol = (symbol_number )s->accessing_symbol;
#line 168
  res->transitions = transitions_new((s->transitions)->num, (s->transitions)->states);
#line 170
  res->reductions = reductions_new((s->reductions)->num, (s->reductions)->rules);
#line 171
  res->errs = (errs *)((void *)0);
#line 172
  res->state_list = (struct state_list *)((void *)0);
#line 173
  res->consistent = (char )s->consistent;
#line 174
  res->solved_conflicts = (char const   *)((void *)0);
#line 175
  res->solved_conflicts_xml = (char const   *)((void *)0);
#line 177
  res->nitems = (size_t )s->nitems;
#line 178
  memcpy((void */* __restrict  */)(res->items), (void const   */* __restrict  */)(s->items),
         items_size);
  }
#line 180
  return (res);
}
}
#line 188 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
static void state_free(state *s ) 
{ 


  {
  {
#line 191
  free((void *)s->transitions);
#line 192
  free((void *)s->reductions);
#line 193
  free((void *)s->errs);
#line 194
  free((void *)s);
  }
#line 195
  return;
}
}
#line 202 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void state_transitions_set(state *s , int num , state **trans ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 205
  if (! (! s->transitions)) {
    {
#line 205
    __assert_fail("!s->transitions", "/home/pronto/abs/test-suite/bison-2.5/src/state.c",
                  205U, "state_transitions_set");
    }
  }
  {
#line 206
  s->transitions = transitions_new(num, trans);
  }
#line 207
  return;
}
}
#line 214 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void state_reductions_set(state *s , int num , rule **reds ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 217
  if (! (! s->reductions)) {
    {
#line 217
    __assert_fail("!s->reductions", "/home/pronto/abs/test-suite/bison-2.5/src/state.c",
                  217U, "state_reductions_set");
    }
  }
  {
#line 218
  s->reductions = reductions_new(num, reds);
  }
#line 219
  return;
}
}
#line 222 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
int state_reduction_find(state *s , rule *r ) 
{ 
  int i ;
  reductions *reds ;

  {
#line 226
  reds = s->reductions;
#line 227
  i = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < reds->num)) {
#line 227
      goto while_break;
    }
#line 228
    if ((unsigned long )reds->rules[i] == (unsigned long )r) {
#line 229
      return (i);
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  return (-1);
}
}
#line 238 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void state_errs_set(state *s , int num , symbol **tokens ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 241
  if (! (! s->errs)) {
    {
#line 241
    __assert_fail("!s->errs", "/home/pronto/abs/test-suite/bison-2.5/src/state.c",
                  241U, "state_errs_set");
    }
  }
  {
#line 242
  s->errs = errs_new(num, tokens);
  }
#line 243
  return;
}
}
#line 252 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void state_rule_lookahead_tokens_print(state *s , rule *r , FILE *out ) 
{ 
  reductions *reds ;
  int red ;
  int tmp ;
  bitset_iterator biter ;
  int k ;
  char const   *sep ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 256
  reds = s->reductions;
#line 257
  tmp = state_reduction_find(s, r);
#line 257
  red = tmp;
  }
#line 260
  if (reds->lookahead_tokens) {
#line 260
    if (red != -1) {
      {
#line 264
      sep = "";
#line 265
      rpl_fprintf(out, "  [");
#line 266
      biter.next = (bitset_bindex )0;
#line 266
      biter.num = (bitset_bindex )1024;
      }
      {
#line 266
      while (1) {
        while_continue: /* CIL Label */ ;
#line 266
        if (biter.num == 1024U) {
          {
#line 266
          biter.num = (*(((*(reds->lookahead_tokens + red))->b.vtable)->list))(*(reds->lookahead_tokens + red),
                                                                               biter.list,
                                                                               (bitset_bindex )1024,
                                                                               & biter.next);
          }
#line 266
          if (! biter.num) {
#line 266
            goto while_break;
          }
        } else {
#line 266
          goto while_break;
        }
#line 266
        biter.i = (bitset_bindex )0;
        {
#line 266
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 266
          if (biter.i < biter.num) {
#line 266
            k = (int )biter.list[biter.i];
          } else {
#line 266
            goto while_break___0;
          }
          {
#line 268
          rpl_fprintf(out, "%s%s", sep, (*(symbols + k))->tag);
#line 269
          sep = ", ";
#line 266
          (biter.i) ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 271
      rpl_fprintf(out, "]");
      }
    }
  }
#line 273
  return;
}
}
#line 275 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void state_rule_lookahead_tokens_print_xml(state *s , rule *r , FILE *out , int level ) 
{ 
  reductions *reds ;
  int red ;
  int tmp ;
  bitset_iterator biter ;
  int k ;
  char const   *tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 280
  reds = s->reductions;
#line 281
  tmp = state_reduction_find(s, r);
#line 281
  red = tmp;
  }
#line 284
  if (reds->lookahead_tokens) {
#line 284
    if (red != -1) {
      {
#line 288
      xml_puts(out, level, "<lookaheads>");
#line 289
      biter.next = (bitset_bindex )0;
#line 289
      biter.num = (bitset_bindex )1024;
      }
      {
#line 289
      while (1) {
        while_continue: /* CIL Label */ ;
#line 289
        if (biter.num == 1024U) {
          {
#line 289
          biter.num = (*(((*(reds->lookahead_tokens + red))->b.vtable)->list))(*(reds->lookahead_tokens + red),
                                                                               biter.list,
                                                                               (bitset_bindex )1024,
                                                                               & biter.next);
          }
#line 289
          if (! biter.num) {
#line 289
            goto while_break;
          }
        } else {
#line 289
          goto while_break;
        }
#line 289
        biter.i = (bitset_bindex )0;
        {
#line 289
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 289
          if (biter.i < biter.num) {
#line 289
            k = (int )biter.list[biter.i];
          } else {
#line 289
            goto while_break___0;
          }
          {
#line 291
          tmp___0 = xml_escape((*(symbols + k))->tag);
#line 291
          xml_printf(out, level + 1, "<symbol>%s</symbol>", tmp___0);
#line 289
          (biter.i) ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 294
      xml_puts(out, level, "</lookaheads>");
      }
    }
  }
#line 296
  return;
}
}
#line 306 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
static struct hash_table *state_table  =    (struct hash_table *)((void *)0);
#line 309 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
__inline static _Bool state_compare(state const   *s1 , state const   *s2 ) 
{ 
  size_t i ;

  {
#line 314
  if (s1->nitems != s2->nitems) {
#line 315
    return ((_Bool)0);
  }
#line 317
  i = (size_t )0;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! (i < (size_t )s1->nitems)) {
#line 317
      goto while_break;
    }
#line 318
    if (s1->items[i] != s2->items[i]) {
#line 319
      return ((_Bool)0);
    }
#line 317
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return ((_Bool)1);
}
}
#line 324 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
static _Bool state_comparator(void const   *s1 , void const   *s2 ) 
{ 
  _Bool tmp ;

  {
  {
#line 327
  tmp = state_compare((state const   *)s1, (state const   *)s2);
  }
#line 327
  return (tmp);
}
}
#line 330 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
__inline static size_t state_hash(state const   *s , size_t tablesize ) 
{ 
  size_t key ;
  size_t i ;

  {
#line 334
  key = (size_t )0;
#line 336
  i = (size_t )0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (i < (size_t )s->nitems)) {
#line 336
      goto while_break;
    }
#line 337
    key += (size_t )s->items[i];
#line 336
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  return (key % tablesize);
}
}
#line 341 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
static size_t state_hasher(void const   *s , size_t tablesize ) 
{ 
  size_t tmp ;

  {
  {
#line 344
  tmp = state_hash((state const   *)s, tablesize);
  }
#line 344
  return (tmp);
}
}
#line 352 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void state_hash_new(void) 
{ 


  {
  {
#line 355
  state_table = hash_initialize((size_t )257, (Hash_tuning const   *)((void *)0),
                                & state_hasher, & state_comparator, (void (*)(void * ))((void *)0));
  }
#line 360
  return;
}
}
#line 367 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void state_hash_free(void) 
{ 


  {
  {
#line 370
  hash_free(state_table);
  }
#line 371
  return;
}
}
#line 378 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void state_hash_insert(state *s ) 
{ 
  void *tmp ;

  {
  {
#line 381
  tmp = hash_insert(state_table, (void const   *)s);
  }
#line 381
  if (! tmp) {
    {
#line 382
    xalloc_die();
    }
  }
#line 383
  return;
}
}
#line 391 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
state *state_hash_lookup(size_t nitems , item_number *core ) 
{ 
  size_t items_size ;
  state *probe ;
  void *tmp ;
  state *entry ;
  void *tmp___0 ;

  {
  {
#line 394
  items_size = (size_t )((unsigned long )nitems * sizeof(*core));
#line 395
  tmp = xmalloc((size_t )((unsigned long )(& ((state *)0)->items) + (unsigned long )items_size));
#line 395
  probe = (state *)tmp;
#line 398
  probe->nitems = nitems;
#line 399
  memcpy((void */* __restrict  */)(probe->items), (void const   */* __restrict  */)core,
         items_size);
#line 400
  tmp___0 = hash_lookup((Hash_table const   *)state_table, (void const   *)probe);
#line 400
  entry = (state *)tmp___0;
#line 401
  free((void *)probe);
  }
#line 402
  return (entry);
}
}
#line 410 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
static void state_record_reachable_states(state *s , bitset reachable ) 
{ 
  _Bool tmp ;
  int i ;

  {
  {
#line 413
  tmp = bitset_test(reachable, (bitset_bindex )s->number);
  }
#line 413
  if (tmp) {
#line 414
    return;
  }
  {
#line 415
  bitset_set(reachable, (bitset_bindex )s->number);
#line 418
  i = 0;
  }
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! (i < (s->transitions)->num)) {
#line 418
      goto while_break;
    }
#line 419
    if (! ((unsigned long )(s->transitions)->states[i] == (unsigned long )((void *)0))) {
      {
#line 420
      state_record_reachable_states((s->transitions)->states[i], reachable);
      }
    }
#line 418
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return;
}
}
#line 424 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void state_remove_unreachable_states(state_number *old_to_new ) 
{ 
  state_number nstates_reachable ;
  bitset reachable ;
  bitset tmp ;
  state_number i ;
  state_number tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 427
  nstates_reachable = 0;
#line 428
  tmp = bitset_create((bitset_bindex )nstates, (bitset_attrs )1);
#line 428
  reachable = tmp;
#line 429
  state_record_reachable_states(*(states + 0), reachable);
#line 432
  i = 0;
  }
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (i < nstates)) {
#line 432
      goto while_break;
    }
    {
#line 434
    tmp___1 = bitset_test(reachable, (bitset_bindex )(*(states + i))->number);
    }
#line 434
    if (tmp___1) {
#line 436
      *(states + nstates_reachable) = *(states + i);
#line 437
      (*(states + nstates_reachable))->number = nstates_reachable;
#line 438
      tmp___0 = nstates_reachable;
#line 438
      nstates_reachable ++;
#line 438
      *(old_to_new + i) = tmp___0;
    } else {
      {
#line 442
      state_free(*(states + i));
#line 443
      *(old_to_new + i) = nstates;
      }
    }
#line 432
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  nstates = nstates_reachable;
#line 448
  bitset_free(reachable);
  }
#line 449
  return;
}
}
#line 452 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
state **states  =    (state **)((void *)0);
#line 459 "/home/pronto/abs/test-suite/bison-2.5/src/state.c"
void states_free(void) 
{ 
  state_number i ;

  {
#line 463
  i = 0;
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    if (! (i < nstates)) {
#line 463
      goto while_break;
    }
    {
#line 464
    state_free(*(states + i));
#line 463
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 465
  free((void *)states);
  }
#line 466
  return;
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 576
extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 808
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 227 "scan-skel.c"
int skel_leng  ;
#line 232
FILE *skel_in ;
#line 232
FILE *skel_out ;
#line 339 "scan-skel.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 340 "scan-skel.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 341 "scan-skel.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 368 "scan-skel.c"
static char yy_hold_char  ;
#line 369 "scan-skel.c"
static int yy_n_chars  ;
#line 373 "scan-skel.c"
static char *yy_c_buf_p  =    (char *)0;
#line 374 "scan-skel.c"
static int yy_init  =    0;
#line 375 "scan-skel.c"
static int yy_start  =    0;
#line 380 "scan-skel.c"
static int yy_did_buffer_switch_on_eof  ;
#line 385
void skel_restart(FILE *input_file ) ;
#line 386
void skel__switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 387
YY_BUFFER_STATE skel__create_buffer(FILE *file , int size ) ;
#line 388
void skel__delete_buffer(YY_BUFFER_STATE b ) ;
#line 389
void skel__flush_buffer(YY_BUFFER_STATE b ) ;
#line 390
void skel_push_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 391
void skel_pop_buffer_state(void) ;
#line 393
static void skel_ensure_buffer_stack(void) ;
#line 394
static void skel__load_buffer_state(void) ;
#line 395
static void skel__init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 399
YY_BUFFER_STATE skel__scan_buffer(char *base___0 , yy_size_t size ) ;
#line 400
YY_BUFFER_STATE skel__scan_string(char const   *yystr ) ;
#line 401
YY_BUFFER_STATE skel__scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 405
void *skel_alloc(yy_size_t size ) ;
#line 406
void *skel_realloc(void *ptr , yy_size_t size ) ;
#line 407
void skel_free(void *ptr ) ;
#line 443 "scan-skel.c"
FILE *skel_in  =    (FILE *)0;
#line 443 "scan-skel.c"
FILE *skel_out  =    (FILE *)0;
#line 447
int skel_lineno ;
#line 449 "scan-skel.c"
int skel_lineno  =    1;
#line 451 "scan-skel.c"
char *skel_text  ;
#line 456
static yy_state_type yy_get_previous_state(void) ;
#line 457
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 458
static int yy_get_next_buffer(void) ;
#line 459
static void yy_fatal_error(char const   *msg ) ;
#line 485 "scan-skel.c"
static flex_int16_t const   yy_accept[56]  = 
#line 485
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )24, 
        (flex_int16_t const   )12,      (flex_int16_t const   )11,      (flex_int16_t const   )10,      (flex_int16_t const   )13, 
        (flex_int16_t const   )20,      (flex_int16_t const   )22,      (flex_int16_t const   )21,      (flex_int16_t const   )21, 
        (flex_int16_t const   )12,      (flex_int16_t const   )10,      (flex_int16_t const   )5,      (flex_int16_t const   )1, 
        (flex_int16_t const   )10,      (flex_int16_t const   )4,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )13,      (flex_int16_t const   )20, 
        (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )14,      (flex_int16_t const   )17, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )7,      (flex_int16_t const   )6,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )8,      (flex_int16_t const   )0};
#line 495 "scan-skel.c"
static flex_int32_t const   yy_ec[256]  = 
#line 495
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )9, 
        (flex_int32_t const   )9,      (flex_int32_t const   )13,      (flex_int32_t const   )9,      (flex_int32_t const   )9, 
        (flex_int32_t const   )14,      (flex_int32_t const   )9,      (flex_int32_t const   )15,      (flex_int32_t const   )16, 
        (flex_int32_t const   )17,      (flex_int32_t const   )9,      (flex_int32_t const   )18,      (flex_int32_t const   )9, 
        (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9, 
        (flex_int32_t const   )19,      (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )20, 
        (flex_int32_t const   )1,      (flex_int32_t const   )21,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 527 "scan-skel.c"
static flex_int32_t const   yy_meta[22]  = 
#line 527
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3};
#line 534 "scan-skel.c"
static flex_int16_t const   yy_base[63]  = 
#line 534
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )60, 
        (flex_int16_t const   )58,      (flex_int16_t const   )6,      (flex_int16_t const   )8,      (flex_int16_t const   )63, 
        (flex_int16_t const   )0,      (flex_int16_t const   )93,      (flex_int16_t const   )11,      (flex_int16_t const   )0, 
        (flex_int16_t const   )30,      (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )93,      (flex_int16_t const   )93, 
        (flex_int16_t const   )49,      (flex_int16_t const   )93,      (flex_int16_t const   )49,      (flex_int16_t const   )25, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )0,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )43, 
        (flex_int16_t const   )47,      (flex_int16_t const   )45,      (flex_int16_t const   )49,      (flex_int16_t const   )40, 
        (flex_int16_t const   )34,      (flex_int16_t const   )31,      (flex_int16_t const   )36,      (flex_int16_t const   )35, 
        (flex_int16_t const   )27,      (flex_int16_t const   )38,      (flex_int16_t const   )37,      (flex_int16_t const   )31, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )29,      (flex_int16_t const   )27, 
        (flex_int16_t const   )15,      (flex_int16_t const   )9,      (flex_int16_t const   )93,      (flex_int16_t const   )93, 
        (flex_int16_t const   )70,      (flex_int16_t const   )74,      (flex_int16_t const   )78,      (flex_int16_t const   )82, 
        (flex_int16_t const   )85,      (flex_int16_t const   )88,      (flex_int16_t const   )0};
#line 545 "scan-skel.c"
static flex_int16_t const   yy_def[63]  = 
#line 545
  {      (flex_int16_t const   )0,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )57, 
        (flex_int16_t const   )57,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )55, 
        (flex_int16_t const   )59,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )60, 
        (flex_int16_t const   )61,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )59,      (flex_int16_t const   )62,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )10,      (flex_int16_t const   )55,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )60,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )55,      (flex_int16_t const   )0, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55};
#line 556 "scan-skel.c"
static flex_int16_t const   yy_nxt[115]  = 
#line 556
  {      (flex_int16_t const   )0,      (flex_int16_t const   )17,      (flex_int16_t const   )55,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )55,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )14,      (flex_int16_t const   )15, 
        (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )18,      (flex_int16_t const   )54, 
        (flex_int16_t const   )17,      (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )21, 
        (flex_int16_t const   )20,      (flex_int16_t const   )22,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )23, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )24, 
        (flex_int16_t const   )25,      (flex_int16_t const   )28,      (flex_int16_t const   )53,      (flex_int16_t const   )29, 
        (flex_int16_t const   )30,      (flex_int16_t const   )36,      (flex_int16_t const   )31,      (flex_int16_t const   )37, 
        (flex_int16_t const   )52,      (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )49, 
        (flex_int16_t const   )48,      (flex_int16_t const   )47,      (flex_int16_t const   )46,      (flex_int16_t const   )45, 
        (flex_int16_t const   )44,      (flex_int16_t const   )43,      (flex_int16_t const   )32,      (flex_int16_t const   )33, 
        (flex_int16_t const   )55,      (flex_int16_t const   )34,      (flex_int16_t const   )42,      (flex_int16_t const   )55, 
        (flex_int16_t const   )41,      (flex_int16_t const   )55,      (flex_int16_t const   )40,      (flex_int16_t const   )20, 
        (flex_int16_t const   )39,      (flex_int16_t const   )38,      (flex_int16_t const   )35,      (flex_int16_t const   )55, 
        (flex_int16_t const   )12,      (flex_int16_t const   )20,      (flex_int16_t const   )12,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )13, 
        (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )16, 
        (flex_int16_t const   )55,      (flex_int16_t const   )16,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )7,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55};
#line 573 "scan-skel.c"
static flex_int16_t const   yy_chk[115]  = 
#line 573
  {      (flex_int16_t const   )0,      (flex_int16_t const   )62,      (flex_int16_t const   )0,      (flex_int16_t const   )1, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )2, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )6, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )53, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )12,      (flex_int16_t const   )52,      (flex_int16_t const   )12, 
        (flex_int16_t const   )12,      (flex_int16_t const   )23,      (flex_int16_t const   )12,      (flex_int16_t const   )23, 
        (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )47,      (flex_int16_t const   )46, 
        (flex_int16_t const   )45,      (flex_int16_t const   )44,      (flex_int16_t const   )43,      (flex_int16_t const   )42, 
        (flex_int16_t const   )41,      (flex_int16_t const   )40,      (flex_int16_t const   )12,      (flex_int16_t const   )12, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )39,      (flex_int16_t const   )20, 
        (flex_int16_t const   )38,      (flex_int16_t const   )20,      (flex_int16_t const   )37,      (flex_int16_t const   )20, 
        (flex_int16_t const   )36,      (flex_int16_t const   )35,      (flex_int16_t const   )22,      (flex_int16_t const   )7, 
        (flex_int16_t const   )4,      (flex_int16_t const   )20,      (flex_int16_t const   )3,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )57, 
        (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )59, 
        (flex_int16_t const   )0,      (flex_int16_t const   )59,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55};
#line 590 "scan-skel.c"
static yy_state_type yy_last_accepting_state  ;
#line 591 "scan-skel.c"
static char *yy_last_accepting_cpos  ;
#line 593
int skel__flex_debug ;
#line 594 "scan-skel.c"
int skel__flex_debug  =    1;
#line 596 "scan-skel.c"
static flex_int16_t const   yy_rule_linenum[23]  = 
#line 596
  {      (flex_int16_t const   )0,      (flex_int16_t const   )72,      (flex_int16_t const   )73,      (flex_int16_t const   )74, 
        (flex_int16_t const   )75,      (flex_int16_t const   )76,      (flex_int16_t const   )78,      (flex_int16_t const   )79, 
        (flex_int16_t const   )80,      (flex_int16_t const   )82,      (flex_int16_t const   )91,      (flex_int16_t const   )92, 
        (flex_int16_t const   )93,      (flex_int16_t const   )105,      (flex_int16_t const   )107,      (flex_int16_t const   )108, 
        (flex_int16_t const   )109,      (flex_int16_t const   )110,      (flex_int16_t const   )112,      (flex_int16_t const   )114, 
        (flex_int16_t const   )135,      (flex_int16_t const   )139,      (flex_int16_t const   )140};
#line 25 "/home/pronto/abs/test-suite/bison-2.5/src/flex-scanner.h"
int skel_get_lineno(void) ;
#line 26
FILE *skel_get_in(void) ;
#line 27
FILE *skel_get_out(void) ;
#line 28
int skel_get_leng(void) ;
#line 29
char *skel_get_text(void) ;
#line 30
void skel_set_lineno(int line_number ) ;
#line 31
void skel_set_in(FILE *in_str ) ;
#line 32
void skel_set_out(FILE *out_str ) ;
#line 33
int skel_get_debug(void) ;
#line 34
void skel_set_debug(int bdebug ) ;
#line 35
int skel_lex_destroy(void) ;
#line 74 "/home/pronto/abs/test-suite/bison-2.5/src/flex-scanner.h"
static struct obstack obstack_for_string  ;
#line 117 "/home/pronto/abs/test-suite/bison-2.5/src/location.h"
void boundary_set_from_string(boundary *bound , char *loc_str ) ;
#line 38 "/home/pronto/abs/test-suite/bison-2.5/src/complain.h"
void ( /* format attribute */  warn)(char const   *message  , ...) ;
#line 53
void ( /* format attribute */  complain)(char const   *message  , ...) ;
#line 51 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
char *dir_prefix ;
#line 66
void output_file_name_check(char **file_name ) ;
#line 68
FILE *xfopen(char const   *name , char const   *mode ) ;
#line 69
void xfclose(FILE *ptr ) ;
#line 20 "/home/pronto/abs/test-suite/bison-2.5/src/scan-skel.h"
void scan_skel(FILE *in ) ;
#line 27
void skel_scanner_free(void) ;
#line 42 "scan-skel.l"
static int skel_lex(void) ;
#line 47
static void at_directive_perform(int at_directive_argc , char **at_directive_argv ,
                                 char **outnamep , int *out_linenop ) ;
#line 50
static void fail_for_at_directive_too_many_args(char const   *at_directive_name ) ;
#line 51
static void fail_for_at_directive_too_few_args(char const   *at_directive_name ) ;
#line 52
static void fail_for_invalid_at(char const   *at ) ;
#line 689 "scan-skel.c"
static int yy_init_globals(void) ;
#line 903 "scan-skel.c"
static int skel_lex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  int out_lineno ;
  char *outname ;
  int at_directive_argc ;
  char *at_directive_argv[8] ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o ;
  int __len ;
  int tmp___2 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o___1 ;
  char *tmp___5 ;
  struct obstack *__o___2 ;
  char *tmp___6 ;
  struct obstack *__o___3 ;
  char *tmp___7 ;
  struct obstack *__o___4 ;
  char *tmp___8 ;
  int tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o___5 ;
  void *__obj ;
  char *tmp___12 ;
  int yyless_macro_arg ;
  char *tmp___13 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___14 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
#line 61 "scan-skel.l"
  out_lineno = 0;
#line 62
  outname = (char *)((void *)0);
#line 68
  at_directive_argc = 0;
#line 927
  if (! yy_init) {
#line 929 "scan-skel.c"
    yy_init = 1;
#line 935
    if (! yy_start) {
#line 936
      yy_start = 1;
    }
#line 938
    if (! skel_in) {
#line 940
      skel_in = stdin;
    }
#line 945
    if (! skel_out) {
#line 947
      skel_out = stdout;
    }
#line 952
    if (yy_buffer_stack) {
#line 952
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 952
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 952
    if (! tmp) {
      {
#line 953
      skel_ensure_buffer_stack();
#line 954
      *(yy_buffer_stack + yy_buffer_stack_top) = skel__create_buffer(skel_in, 16384);
      }
    }
    {
#line 958
    skel__load_buffer_state();
    }
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 964
    yy_cp = yy_c_buf_p;
#line 967
    *yy_cp = yy_hold_char;
#line 972
    yy_bp = yy_cp;
#line 975
    yy_current_state = yy_start;
    yy_match: 
    {
#line 977
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 979
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 980
      if (yy_accept[yy_current_state]) {
#line 982
        yy_last_accepting_state = yy_current_state;
#line 983
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 985
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 985
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 985
          goto while_break___1;
        }
#line 987
        yy_current_state = (int )yy_def[yy_current_state];
#line 988
        if (yy_current_state >= 56) {
#line 989
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 991
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 992
      yy_cp ++;
#line 977
      if (! (yy_current_state != 55)) {
#line 977
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 995
    yy_cp = yy_last_accepting_cpos;
#line 996
    yy_current_state = yy_last_accepting_state;
    yy_find_action: 
#line 1000
    yy_act = (int )yy_accept[yy_current_state];
#line 1002
    skel_text = yy_bp;
#line 1002
    skel_leng = (int )((size_t )(yy_cp - yy_bp));
#line 1002
    yy_hold_char = *yy_cp;
#line 1002
    *yy_cp = (char )'\000';
#line 1002
    yy_c_buf_p = yy_cp;
    do_action: 
#line 1009
    if (skel__flex_debug) {
#line 1011
      if (yy_act == 0) {
        {
#line 1012
        rpl_fprintf(stderr, "--scanner backing up\n");
        }
      } else
#line 1013
      if (yy_act < 23) {
        {
#line 1014
        rpl_fprintf(stderr, "--accepting rule at line %ld (\"%s\")\n", (long )yy_rule_linenum[yy_act],
                    skel_text);
        }
      } else
#line 1016
      if (yy_act == 23) {
        {
#line 1017
        rpl_fprintf(stderr, "--accepting default rule (\"%s\")\n", skel_text);
        }
      } else
#line 1019
      if (yy_act == 24) {
        {
#line 1020
        rpl_fprintf(stderr, "--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 1022
        rpl_fprintf(stderr, "--EOF (start condition %d)\n", (yy_start - 1) / 2);
        }
      }
    }
    {
#line 1028
    if (yy_act == 0) {
#line 1028
      goto case_0;
    }
#line 1035
    if (yy_act == 1) {
#line 1035
      goto case_1;
    }
#line 74
    if (yy_act == 2) {
#line 74 "scan-skel.l"
      goto case_2;
    }
#line 75
    if (yy_act == 3) {
#line 75
      goto case_3;
    }
#line 76
    if (yy_act == 4) {
#line 76
      goto case_4;
    }
#line 77
    if (yy_act == 5) {
#line 77
      goto case_5;
    }
#line 78
    if (yy_act == 6) {
#line 78
      goto case_6;
    }
#line 80
    if (yy_act == 7) {
#line 80
      goto case_7;
    }
#line 81
    if (yy_act == 8) {
#line 81
      goto case_8;
    }
#line 82
    if (yy_act == 9) {
#line 82
      goto case_9;
    }
#line 91
    if (yy_act == 10) {
#line 91
      goto case_10;
    }
#line 93
    if (yy_act == 11) {
#line 93
      goto case_11;
    }
#line 94
    if (yy_act == 12) {
#line 94
      goto case_12;
    }
#line 95
    if (yy_act == 25) {
#line 95
      goto case_25;
    }
#line 105
    if (yy_act == 13) {
#line 105
      goto case_13;
    }
#line 107
    if (yy_act == 14) {
#line 107
      goto case_14;
    }
#line 109
    if (yy_act == 15) {
#line 109
      goto case_15;
    }
#line 110
    if (yy_act == 16) {
#line 110
      goto case_16;
    }
#line 111
    if (yy_act == 17) {
#line 111
      goto case_17;
    }
#line 113
    if (yy_act == 18) {
#line 113
      goto case_18;
    }
#line 114
    if (yy_act == 19) {
#line 114
      goto case_19;
    }
#line 135
    if (yy_act == 20) {
#line 135
      goto case_20;
    }
#line 139
    if (yy_act == 21) {
#line 139
      goto case_21;
    }
#line 141
    if (yy_act == 22) {
#line 141
      goto case_22;
    }
#line 145
    if (yy_act == 27) {
#line 145
      goto case_27;
    }
#line 145
    if (yy_act == 26) {
#line 145
      goto case_27;
    }
#line 149
    if (yy_act == 23) {
#line 149
      goto case_23;
    }
#line 1208
    if (yy_act == 24) {
#line 1208 "scan-skel.c"
      goto case_24;
    }
#line 1332
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1030
    *yy_cp = yy_hold_char;
#line 1031
    yy_cp = yy_last_accepting_cpos;
#line 1032
    yy_current_state = yy_last_accepting_state;
#line 1033
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 72 "scan-skel.l"
    fputc_unlocked('@', skel_out);
    }
#line 73
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 73
    fputc_unlocked('[', skel_out);
    }
#line 74
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 74
    fputc_unlocked(']', skel_out);
    }
#line 75
    goto switch_break;
    case_4: /* CIL Label */ 
#line 76
    goto switch_break;
    case_5: /* CIL Label */ 
#line 77
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 78
    rpl_fprintf(skel_out, "%d", out_lineno + 1);
    }
#line 79
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 79
    tmp___0 = quotearg_style((enum quoting_style )3, (char const   *)outname);
#line 79
    fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)skel_out);
    }
#line 80
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 80
    tmp___1 = quotearg_style((enum quoting_style )3, (char const   *)dir_prefix);
#line 80
    fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)skel_out);
    }
#line 81
    goto switch_break;
    case_9: /* CIL Label */ 
#line 83
    *(skel_text + (skel_leng - 1)) = (char )'\000';
#line 84
    __o = & obstack_for_string;
#line 84
    __len = skel_leng;
#line 84
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 84
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 84
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)skel_text,
           (size_t )__len);
#line 84
    __o->next_free += __len;
#line 85
    tmp___2 = at_directive_argc;
#line 85
    at_directive_argc ++;
#line 86
    __o1 = & obstack_for_string;
#line 86
    __value = (void *)__o1->object_base;
    }
#line 86
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 86
      __o1->maybe_empty_object = 1U;
    }
#line 86
    if (sizeof(int ) < sizeof(void *)) {
#line 86
      tmp___3 = __o1->object_base;
    } else {
#line 86
      tmp___3 = (char *)0;
    }
#line 86
    if (sizeof(int ) < sizeof(void *)) {
#line 86
      tmp___4 = __o1->object_base;
    } else {
#line 86
      tmp___4 = (char *)0;
    }
#line 86
    __o1->next_free = tmp___3 + (((__o1->next_free - tmp___4) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 86
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 86
      __o1->next_free = __o1->chunk_limit;
    }
#line 86
    __o1->object_base = __o1->next_free;
#line 86
    at_directive_argv[tmp___2] = (char *)__value;
#line 87
    yy_start = 3;
#line 89
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 91
    fail_for_invalid_at((char const   *)skel_text);
    }
#line 92
    goto switch_break;
    case_11: /* CIL Label */ 
#line 92
    out_lineno ++;
    {
#line 92
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 92
      fwrite_unlocked((void const   */* __restrict  */)skel_text, (size_t )skel_leng,
                      (size_t )1, (FILE */* __restrict  */)skel_out);
      }
#line 92
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 93
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 93
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 93
      fwrite_unlocked((void const   */* __restrict  */)skel_text, (size_t )skel_leng,
                      (size_t )1, (FILE */* __restrict  */)skel_out);
      }
#line 93
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 94
    goto switch_break;
    case_25: /* CIL Label */ 
#line 96
    if (outname) {
      {
#line 98
      free((void *)outname);
#line 99
      xfclose(skel_out);
      }
    }
#line 101
    return (-1);
#line 103
    goto switch_break;
    case_13: /* CIL Label */ 
#line 105
    __o___0 = & obstack_for_string;
#line 105
    __len___0 = skel_leng;
#line 105
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 105
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)skel_text,
           (size_t )__len___0);
#line 105
    __o___0->next_free += __len___0;
    }
#line 106
    goto switch_break;
    case_14: /* CIL Label */ 
#line 107
    __o___1 = & obstack_for_string;
#line 107
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 107
    tmp___5 = __o___1->next_free;
#line 107
    (__o___1->next_free) ++;
#line 107
    *tmp___5 = (char )'@';
#line 108
    goto switch_break;
    case_15: /* CIL Label */ 
#line 108
    __o___2 = & obstack_for_string;
#line 108
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 108
    tmp___6 = __o___2->next_free;
#line 108
    (__o___2->next_free) ++;
#line 108
    *tmp___6 = (char )'[';
#line 109
    goto switch_break;
    case_16: /* CIL Label */ 
#line 109
    __o___3 = & obstack_for_string;
#line 109
    if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 109
      _obstack_newchunk(__o___3, 1);
      }
    }
#line 109
    tmp___7 = __o___3->next_free;
#line 109
    (__o___3->next_free) ++;
#line 109
    *tmp___7 = (char )']';
#line 110
    goto switch_break;
    case_17: /* CIL Label */ 
#line 112
    goto switch_break;
    case_18: /* CIL Label */ 
#line 113
    goto switch_break;
    case_19: /* CIL Label */ 
#line 115
    if (at_directive_argc >= 8) {
      {
#line 116
      fail_for_at_directive_too_many_args((char const   *)at_directive_argv[0]);
      }
    }
#line 118
    __o___4 = & obstack_for_string;
#line 118
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 118
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 118
    tmp___8 = __o___4->next_free;
#line 118
    (__o___4->next_free) ++;
#line 118
    *tmp___8 = (char )'\000';
#line 119
    tmp___9 = at_directive_argc;
#line 119
    at_directive_argc ++;
#line 120
    __o1___0 = & obstack_for_string;
#line 120
    __value___0 = (void *)__o1___0->object_base;
#line 120
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 120
      __o1___0->maybe_empty_object = 1U;
    }
#line 120
    if (sizeof(int ) < sizeof(void *)) {
#line 120
      tmp___10 = __o1___0->object_base;
    } else {
#line 120
      tmp___10 = (char *)0;
    }
#line 120
    if (sizeof(int ) < sizeof(void *)) {
#line 120
      tmp___11 = __o1___0->object_base;
    } else {
#line 120
      tmp___11 = (char *)0;
    }
#line 120
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 120
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 120
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 120
    __o1___0->object_base = __o1___0->next_free;
#line 120
    at_directive_argv[tmp___9] = (char *)__value___0;
#line 123
    if ((int )*(skel_text + 1) == 44) {
#line 124
      yy_start = 5;
    } else {
      {
#line 127
      at_directive_perform(at_directive_argc, at_directive_argv, & outname, & out_lineno);
#line 129
      __o___5 = & obstack_for_string;
#line 129
      __obj = (void *)at_directive_argv[0];
      }
#line 129
      if ((unsigned long )__obj > (unsigned long )((void *)__o___5->chunk)) {
#line 129
        if ((unsigned long )__obj < (unsigned long )((void *)__o___5->chunk_limit)) {
#line 129
          tmp___12 = (char *)__obj;
#line 129
          __o___5->object_base = tmp___12;
#line 129
          __o___5->next_free = tmp___12;
        } else {
          {
#line 129
          obstack_free(__o___5, __obj);
          }
        }
      } else {
        {
#line 129
        obstack_free(__o___5, __obj);
        }
      }
#line 130
      at_directive_argc = 0;
#line 131
      yy_start = 1;
    }
#line 134
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 135
    fail_for_invalid_at((char const   *)skel_text);
    }
#line 136
    goto switch_break;
    case_21: /* CIL Label */ 
#line 140
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 140
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 140
      yyless_macro_arg = 0;
#line 140
      *yy_cp = yy_hold_char;
#line 140
      yy_cp = (yy_bp + yyless_macro_arg) - 0;
#line 140
      yy_c_buf_p = yy_cp;
#line 140
      skel_text = yy_bp;
#line 140
      skel_leng = (int )((size_t )(yy_cp - yy_bp));
#line 140
      yy_hold_char = *yy_cp;
#line 140
      *yy_cp = (char )'\000';
#line 140
      yy_c_buf_p = yy_cp;
#line 140
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 140
    yy_start = 3;
#line 141
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    {
#line 145
    tmp___13 = gettext("unclosed %s directive in skeleton");
#line 145
    fatal((char const   *)tmp___13, at_directive_argv[0]);
    }
#line 147
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 149
    yy_fatal_error("flex scanner jammed");
    }
#line 150
    goto switch_break;
    case_24: /* CIL Label */ 
#line 1211 "scan-skel.c"
    yy_amount_of_matched_text = (int )(yy_cp - skel_text) - 1;
#line 1214
    *yy_cp = yy_hold_char;
#line 1217
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1228
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1229
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = skel_in;
#line 1230
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1240
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1244
      yy_c_buf_p = skel_text + yy_amount_of_matched_text;
#line 1246
      yy_current_state = yy_get_previous_state();
#line 1257
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1259
      yy_bp = skel_text + 0;
      }
#line 1261
      if (yy_next_state) {
#line 1264
        yy_c_buf_p ++;
#line 1264
        yy_cp = yy_c_buf_p;
#line 1265
        yy_current_state = yy_next_state;
#line 1266
        goto yy_match;
      } else {
#line 1272
        yy_cp = yy_last_accepting_cpos;
#line 1273
        yy_current_state = yy_last_accepting_state;
#line 1274
        goto yy_find_action;
      }
    } else {
      {
#line 1278
      tmp___14 = yy_get_next_buffer();
      }
      {
#line 1280
      if (tmp___14 == 1) {
#line 1280
        goto case_1___0;
      }
#line 1309
      if (tmp___14 == 0) {
#line 1309
        goto case_0___0;
      }
#line 1319
      if (tmp___14 == 2) {
#line 1319
        goto case_2___0;
      }
#line 1278
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1282
      yy_did_buffer_switch_on_eof = 0;
#line 1295
      yy_c_buf_p = skel_text + 0;
#line 1297
      yy_act = (24 + (yy_start - 1) / 2) + 1;
#line 1298
      goto do_action;
#line 1306
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1310
      yy_c_buf_p = skel_text + yy_amount_of_matched_text;
#line 1313
      yy_current_state = yy_get_previous_state();
#line 1315
      yy_cp = yy_c_buf_p;
#line 1316
      yy_bp = skel_text + 0;
      }
#line 1317
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1320
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1323
      yy_current_state = yy_get_previous_state();
#line 1325
      yy_cp = yy_c_buf_p;
#line 1326
      yy_bp = skel_text + 0;
      }
#line 1327
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1329
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1333
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1355 "scan-skel.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1360
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1361
  source = skel_text;
#line 1365
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1366
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1369
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1371
    if (yy_c_buf_p - skel_text == 1L) {
#line 1376
      return (1);
    } else {
#line 1384
      return (2);
    }
  }
#line 1391
  number_to_move = (int )(yy_c_buf_p - skel_text) - 1;
#line 1393
  i = 0;
  {
#line 1393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1393
    if (! (i < number_to_move)) {
#line 1393
      goto while_break;
    }
#line 1394
    tmp = dest;
#line 1394
    dest ++;
#line 1394
    tmp___0 = source;
#line 1394
    source ++;
#line 1394
    *tmp = *tmp___0;
#line 1393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1396
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1400
    yy_n_chars = 0;
#line 1400
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1404
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1407
      if (! (num_to_read <= 0)) {
#line 1407
        goto while_break___0;
      }
#line 1411
      if (yy_buffer_stack) {
#line 1411
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1411
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1411
      b = tmp___1;
#line 1413
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1416
      if (b->yy_is_our_buffer) {
#line 1418
        new_size = (int )(b->yy_buf_size * 2U);
#line 1420
        if (new_size <= 0) {
#line 1421
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1423
          b->yy_buf_size *= 2U;
        }
        {
#line 1425
        tmp___2 = skel_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1425
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1431
        b->yy_ch_buf = (char *)0;
      }
#line 1433
      if (! b->yy_ch_buf) {
        {
#line 1434
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1437
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1439
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1444
    if (num_to_read > 8192) {
#line 1445
      num_to_read = 8192;
    }
#line 1448
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1448
      c = '*';
#line 1448
      n = (size_t )0;
      {
#line 1448
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1448
        if (n < (size_t )num_to_read) {
          {
#line 1448
          c = getc_unlocked(skel_in);
          }
#line 1448
          if (c != -1) {
#line 1448
            if (! (c != 10)) {
#line 1448
              goto while_break___1;
            }
          } else {
#line 1448
            goto while_break___1;
          }
        } else {
#line 1448
          goto while_break___1;
        }
#line 1448
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1448
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1448
      if (c == 10) {
#line 1448
        tmp___3 = n;
#line 1448
        n ++;
#line 1448
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1448
      if (c == -1) {
        {
#line 1448
        tmp___4 = ferror_unlocked(skel_in);
        }
#line 1448
        if (tmp___4) {
          {
#line 1448
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1448
      yy_n_chars = (int )n;
    } else {
      {
#line 1448
      tmp___5 = __errno_location();
#line 1448
      *tmp___5 = 0;
      }
      {
#line 1448
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1448
        tmp___8 = fread_unlocked((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                                 (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)skel_in);
#line 1448
        yy_n_chars = (int )tmp___8;
        }
#line 1448
        if (yy_n_chars == 0) {
          {
#line 1448
          tmp___9 = ferror_unlocked(skel_in);
          }
#line 1448
          if (! tmp___9) {
#line 1448
            goto while_break___2;
          }
        } else {
#line 1448
          goto while_break___2;
        }
        {
#line 1448
        tmp___6 = __errno_location();
        }
#line 1448
        if (*tmp___6 != 4) {
          {
#line 1448
          yy_fatal_error("input in flex scanner failed");
          }
#line 1448
          goto while_break___2;
        }
        {
#line 1448
        tmp___7 = __errno_location();
#line 1448
        *tmp___7 = 0;
#line 1448
        clearerr_unlocked(skel_in);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1451
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1454
  if (yy_n_chars == 0) {
#line 1456
    if (number_to_move == 0) {
      {
#line 1458
      ret_val = 1;
#line 1459
      skel_restart(skel_in);
      }
    } else {
#line 1464
      ret_val = 2;
#line 1465
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1471
    ret_val = 0;
  }
#line 1473
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1475
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1476
    tmp___10 = skel_realloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                            new_size___0);
#line 1476
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 1477
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1478
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1481
  yy_n_chars += number_to_move;
#line 1482
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1483
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1485
  skel_text = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1487
  return (ret_val);
}
}
#line 1495 "scan-skel.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1504
  yy_current_state = yy_start;
#line 1506
  yy_cp = skel_text + 0;
  {
#line 1506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1506
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1506
      goto while_break;
    }
#line 1509
    if (*yy_cp) {
#line 1509
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1509
      tmp = (flex_int32_t const   )1;
    }
#line 1509
    yy_c = (YY_CHAR )tmp;
#line 1510
    if (yy_accept[yy_current_state]) {
#line 1512
      yy_last_accepting_state = yy_current_state;
#line 1513
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1515
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1515
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1515
        goto while_break___0;
      }
#line 1517
      yy_current_state = (int )yy_def[yy_current_state];
#line 1518
      if (yy_current_state >= 56) {
#line 1519
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1521
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1506
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1524
  return (yy_current_state);
}
}
#line 1533 "scan-skel.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1540
  yy_cp = yy_c_buf_p;
#line 1542
  yy_c = (YY_CHAR )1;
#line 1543
  if (yy_accept[yy_current_state]) {
#line 1545
    yy_last_accepting_state = yy_current_state;
#line 1546
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1548
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1548
      goto while_break;
    }
#line 1550
    yy_current_state = (int )yy_def[yy_current_state];
#line 1551
    if (yy_current_state >= 56) {
#line 1552
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1554
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1555
  yy_is_jam = yy_current_state == 55;
#line 1557
  if (yy_is_jam) {
#line 1557
    tmp = 0;
  } else {
#line 1557
    tmp = yy_current_state;
  }
#line 1557
  return (tmp);
}
}
#line 1652 "scan-skel.c"
void skel_restart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1658
  if (yy_buffer_stack) {
#line 1658
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1658
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1658
  if (! tmp) {
    {
#line 1659
    skel_ensure_buffer_stack();
#line 1660
    *(yy_buffer_stack + yy_buffer_stack_top) = skel__create_buffer(skel_in, 16384);
    }
  }
#line 1664
  if (yy_buffer_stack) {
#line 1664
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1664
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1664
  skel__init_buffer(tmp___0, input_file);
#line 1665
  skel__load_buffer_state();
  }
#line 1666
  return;
}
}
#line 1673 "scan-skel.c"
void skel__switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1684
  skel_ensure_buffer_stack();
  }
#line 1685
  if (yy_buffer_stack) {
#line 1685
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1685
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1685
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1686
    return;
  }
#line 1688
  if (yy_buffer_stack) {
#line 1688
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1688
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1688
  if (tmp___0) {
#line 1691
    *yy_c_buf_p = yy_hold_char;
#line 1692
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1693
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1696
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1697
  skel__load_buffer_state();
#line 1704
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1705
  return;
}
}
#line 1708 "scan-skel.c"
static void skel__load_buffer_state(void) 
{ 


  {
#line 1713
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1714
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1714
  skel_text = yy_c_buf_p;
#line 1715
  skel_in = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1716
  yy_hold_char = *yy_c_buf_p;
#line 1717
  return;
}
}
#line 1726 "scan-skel.c"
YY_BUFFER_STATE skel__create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1733
  tmp = skel_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1733
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1734
  if (! b) {
    {
#line 1735
    yy_fatal_error("out of dynamic memory in skel__create_buffer()");
    }
  }
  {
#line 1737
  b->yy_buf_size = (yy_size_t )size;
#line 1742
  tmp___0 = skel_alloc(b->yy_buf_size + 2U);
#line 1742
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1743
  if (! b->yy_ch_buf) {
    {
#line 1744
    yy_fatal_error("out of dynamic memory in skel__create_buffer()");
    }
  }
  {
#line 1746
  b->yy_is_our_buffer = 1;
#line 1748
  skel__init_buffer(b, file);
  }
#line 1750
  return (b);
}
}
#line 1758 "scan-skel.c"
void skel__delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1764
  if (! b) {
#line 1765
    return;
  }
#line 1767
  if (yy_buffer_stack) {
#line 1767
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1767
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1767
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1768
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1770
  if (b->yy_is_our_buffer) {
    {
#line 1771
    skel_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 1773
  skel_free((void *)b);
  }
#line 1774
  return;
}
}
#line 1788 "scan-skel.c"
static void skel__init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1794
  tmp = __errno_location();
#line 1794
  oerrno = *tmp;
#line 1796
  skel__flush_buffer(b);
#line 1798
  b->yy_input_file = file;
#line 1799
  b->yy_fill_buffer = 1;
  }
#line 1805
  if (yy_buffer_stack) {
#line 1805
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1805
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1805
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1806
    b->yy_bs_lineno = 1;
#line 1807
    b->yy_bs_column = 0;
  }
  {
#line 1812
  b->yy_is_interactive = 0;
#line 1817
  tmp___1 = __errno_location();
#line 1817
  *tmp___1 = oerrno;
  }
#line 1818
  return;
}
}
#line 1825 "scan-skel.c"
void skel__flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1830
  if (! b) {
#line 1831
    return;
  }
#line 1833
  b->yy_n_chars = 0;
#line 1839
  *(b->yy_ch_buf + 0) = (char)0;
#line 1840
  *(b->yy_ch_buf + 1) = (char)0;
#line 1842
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1844
  b->yy_at_bol = 1;
#line 1845
  b->yy_buffer_status = 0;
#line 1847
  if (yy_buffer_stack) {
#line 1847
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1847
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1847
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1848
    skel__load_buffer_state();
    }
  }
#line 1849
  return;
}
}
#line 1859 "scan-skel.c"
void skel_push_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1864
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1865
    return;
  }
  {
#line 1867
  skel_ensure_buffer_stack();
  }
#line 1870
  if (yy_buffer_stack) {
#line 1870
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1870
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1870
  if (tmp) {
#line 1873
    *yy_c_buf_p = yy_hold_char;
#line 1874
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1875
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1879
  if (yy_buffer_stack) {
#line 1879
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1879
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1879
  if (tmp___0) {
#line 1880
    yy_buffer_stack_top ++;
  }
  {
#line 1881
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1884
  skel__load_buffer_state();
#line 1885
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1886
  return;
}
}
#line 1895 "scan-skel.c"
void skel_pop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1900
  if (yy_buffer_stack) {
#line 1900
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1900
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1900
  if (! tmp) {
#line 1901
    return;
  }
#line 1903
  if (yy_buffer_stack) {
#line 1903
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1903
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1903
  skel__delete_buffer(tmp___0);
#line 1904
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1905
  if (yy_buffer_stack_top > 0U) {
#line 1906
    yy_buffer_stack_top --;
  }
#line 1908
  if (yy_buffer_stack) {
#line 1908
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1908
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1908
  if (tmp___1) {
    {
#line 1909
    skel__load_buffer_state();
#line 1910
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1912
  return;
}
}
#line 1920 "scan-skel.c"
static void skel_ensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1927
  if (! yy_buffer_stack) {
    {
#line 1933
    num_to_alloc = 1;
#line 1934
    tmp = skel_alloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1934
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 1937
    if (! yy_buffer_stack) {
      {
#line 1938
      yy_fatal_error("out of dynamic memory in skel_ensure_buffer_stack()");
      }
    }
    {
#line 1940
    memset((void *)yy_buffer_stack, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1942
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1943
    yy_buffer_stack_top = (size_t )0;
    }
#line 1944
    return;
  }
#line 1947
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1U) {
    {
#line 1950
    grow_size = 8;
#line 1952
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1953
    tmp___0 = skel_realloc((void *)yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1953
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 1957
    if (! yy_buffer_stack) {
      {
#line 1958
      yy_fatal_error("out of dynamic memory in skel_ensure_buffer_stack()");
      }
    }
    {
#line 1961
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 1962
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1964
  return;
}
}
#line 1974 "scan-skel.c"
YY_BUFFER_STATE skel__scan_buffer(char *base___0 , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 1978
  if (size < 2U) {
#line 1982
    return ((YY_BUFFER_STATE )0);
  } else
#line 1978
  if ((int )*(base___0 + (size - 2U)) != 0) {
#line 1982
    return ((YY_BUFFER_STATE )0);
  } else
#line 1978
  if ((int )*(base___0 + (size - 1U)) != 0) {
#line 1982
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1984
  tmp = skel_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1984
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1985
  if (! b) {
    {
#line 1986
    yy_fatal_error("out of dynamic memory in skel__scan_buffer()");
    }
  }
  {
#line 1988
  b->yy_buf_size = size - 2U;
#line 1989
  tmp___0 = base___0;
#line 1989
  b->yy_ch_buf = tmp___0;
#line 1989
  b->yy_buf_pos = tmp___0;
#line 1990
  b->yy_is_our_buffer = 0;
#line 1991
  b->yy_input_file = (FILE *)0;
#line 1992
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1993
  b->yy_is_interactive = 0;
#line 1994
  b->yy_at_bol = 1;
#line 1995
  b->yy_fill_buffer = 0;
#line 1996
  b->yy_buffer_status = 0;
#line 1998
  skel__switch_to_buffer(b);
  }
#line 2000
  return (b);
}
}
#line 2013 "scan-skel.c"
YY_BUFFER_STATE skel__scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2016
  tmp = strlen(yystr);
#line 2016
  tmp___0 = skel__scan_bytes(yystr, (int )tmp);
  }
#line 2016
  return (tmp___0);
}
}
#line 2028 "scan-skel.c"
YY_BUFFER_STATE skel__scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2036
  n = (yy_size_t )(_yybytes_len + 2);
#line 2037
  tmp = skel_alloc(n);
#line 2037
  buf___0 = (char *)tmp;
  }
#line 2038
  if (! buf___0) {
    {
#line 2039
    yy_fatal_error("out of dynamic memory in skel__scan_bytes()");
    }
  }
#line 2041
  i = 0;
  {
#line 2041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2041
    if (! (i < _yybytes_len)) {
#line 2041
      goto while_break;
    }
#line 2042
    *(buf___0 + i) = (char )*(yybytes + i);
#line 2041
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2044
  tmp___0 = (char)0;
#line 2044
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 2044
  *(buf___0 + _yybytes_len) = tmp___0;
#line 2046
  b = skel__scan_buffer(buf___0, n);
  }
#line 2047
  if (! b) {
    {
#line 2048
    yy_fatal_error("bad buffer in skel__scan_bytes()");
    }
  }
#line 2053
  b->yy_is_our_buffer = 1;
#line 2055
  return (b);
}
}
#line 2064 "scan-skel.c"
static void yy_fatal_error(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 2066
  rpl_fprintf(stderr, "%s\n", msg);
#line 2067
  exit(2);
  }
}
}
#line 2099 "scan-skel.c"
int skel_get_lineno(void) 
{ 


  {
#line 2102
  return (skel_lineno);
}
}
#line 2108 "scan-skel.c"
FILE *skel_get_in(void) 
{ 


  {
#line 2110
  return (skel_in);
}
}
#line 2116 "scan-skel.c"
FILE *skel_get_out(void) 
{ 


  {
#line 2118
  return (skel_out);
}
}
#line 2124 "scan-skel.c"
int skel_get_leng(void) 
{ 


  {
#line 2126
  return (skel_leng);
}
}
#line 2133 "scan-skel.c"
char *skel_get_text(void) 
{ 


  {
#line 2135
  return (skel_text);
}
}
#line 2145 "scan-skel.c"
void skel_set_lineno(int line_number ) 
{ 


  {
#line 2148
  skel_lineno = line_number;
#line 2149
  return;
}
}
#line 2157 "scan-skel.c"
void skel_set_in(FILE *in_str ) 
{ 


  {
#line 2159
  skel_in = in_str;
#line 2160
  return;
}
}
#line 2162 "scan-skel.c"
void skel_set_out(FILE *out_str ) 
{ 


  {
#line 2164
  skel_out = out_str;
#line 2165
  return;
}
}
#line 2167 "scan-skel.c"
int skel_get_debug(void) 
{ 


  {
#line 2169
  return (skel__flex_debug);
}
}
#line 2172 "scan-skel.c"
void skel_set_debug(int bdebug ) 
{ 


  {
#line 2174
  skel__flex_debug = bdebug;
#line 2175
  return;
}
}
#line 2185 "scan-skel.c"
static int yy_init_globals(void) 
{ 


  {
#line 2191
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2192
  yy_buffer_stack_top = (size_t )0;
#line 2193
  yy_buffer_stack_max = (size_t )0;
#line 2194
  yy_c_buf_p = (char *)0;
#line 2195
  yy_init = 0;
#line 2196
  yy_start = 0;
#line 2203
  skel_in = (FILE *)0;
#line 2204
  skel_out = (FILE *)0;
#line 2210
  return (0);
}
}
#line 2216 "scan-skel.c"
int skel_lex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2220
    if (yy_buffer_stack) {
#line 2220
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2220
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2220
    if (! tmp___0) {
#line 2220
      goto while_break;
    }
#line 2221
    if (yy_buffer_stack) {
#line 2221
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2221
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2221
    skel__delete_buffer(tmp);
#line 2222
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2223
    skel_pop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2227
  skel_free((void *)yy_buffer_stack);
#line 2228
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2232
  yy_init_globals();
  }
#line 2236
  return (0);
}
}
#line 2264 "scan-skel.c"
void *skel_alloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2266
  tmp = malloc(size);
  }
#line 2266
  return (tmp);
}
}
#line 2269 "scan-skel.c"
void *skel_realloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2278
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2278
  return (tmp);
}
}
#line 2281 "scan-skel.c"
void skel_free(void *ptr ) 
{ 


  {
  {
#line 2283
  free((void *)((char *)ptr));
  }
#line 2284
  return;
}
}
#line 159 "scan-skel.l"
static _Bool initialized  =    (_Bool)0;
#line 156 "scan-skel.l"
void scan_skel(FILE *in ) 
{ 


  {
#line 160
  if (! initialized) {
    {
#line 162
    initialized = (_Bool)1;
#line 163
    _obstack_begin(& obstack_for_string, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
    }
  }
  {
#line 165
  skel_in = in;
#line 166
  skel__flex_debug = trace_flag & 512;
#line 167
  skel_lex();
  }
#line 168
  return;
}
}
#line 170 "scan-skel.l"
void skel_scanner_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 173
  __o = & obstack_for_string;
#line 173
  __obj = (void *)0;
#line 173
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 173
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 173
      tmp = (char *)__obj;
#line 173
      __o->object_base = tmp;
#line 173
      __o->next_free = tmp;
    } else {
      {
#line 173
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 173
    obstack_free(__o, __obj);
    }
  }
  {
#line 175
  skel_lex_destroy();
  }
#line 176
  return;
}
}
#line 178 "scan-skel.l"
static void at_directive_perform(int at_directive_argc , char **at_directive_argv ,
                                 char **outnamep , int *out_linenop ) 
{ 
  char *tmp ;
  void (*func)(char const   *  , ...) ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void (*func___0)(location  , char const   *  , ...) ;
  location loc___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 183
  tmp___17 = strcmp((char const   *)*(at_directive_argv + 0), "@basename");
  }
#line 183
  if (0 == tmp___17) {
#line 185
    if (at_directive_argc > 2) {
      {
#line 186
      fail_for_at_directive_too_many_args((char const   *)*(at_directive_argv + 0));
      }
    }
    {
#line 187
    tmp = last_component((char const   *)*(at_directive_argv + 1));
#line 187
    fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)skel_out);
    }
  } else {
    {
#line 189
    tmp___14 = strcmp((char const   *)*(at_directive_argv + 0), "@warn");
    }
#line 189
    if (0 == tmp___14) {
#line 189
      goto _L___0;
    } else {
      {
#line 189
      tmp___15 = strcmp((char const   *)*(at_directive_argv + 0), "@complain");
      }
#line 189
      if (0 == tmp___15) {
#line 189
        goto _L___0;
      } else {
        {
#line 189
        tmp___16 = strcmp((char const   *)*(at_directive_argv + 0), "@fatal");
        }
#line 189
        if (0 == tmp___16) {
          _L___0: /* CIL Label */ 
          {
#line 196
          if ((int )*(*(at_directive_argv + 0) + 1) == 119) {
#line 196
            goto case_119;
          }
#line 197
          if ((int )*(*(at_directive_argv + 0) + 1) == 99) {
#line 197
            goto case_99;
          }
#line 198
          if ((int )*(*(at_directive_argv + 0) + 1) == 102) {
#line 198
            goto case_102;
          }
#line 199
          goto switch_default;
          case_119: /* CIL Label */ 
#line 196
          func = (void (*)(char const   *  , ...))(& warn);
#line 196
          goto switch_break;
          case_99: /* CIL Label */ 
#line 197
          func = (void (*)(char const   *  , ...))(& complain);
#line 197
          goto switch_break;
          case_102: /* CIL Label */ 
#line 198
          func = (void (*)(char const   *  , ...))(& fatal);
#line 198
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 199
          __assert_fail("0", "scan-skel.l", 199U, "at_directive_perform");
          }
#line 199
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
          {
#line 203
          if (at_directive_argc == 2) {
#line 203
            goto case_2;
          }
#line 206
          if (at_directive_argc == 3) {
#line 206
            goto case_3;
          }
#line 209
          if (at_directive_argc == 4) {
#line 209
            goto case_4;
          }
#line 213
          if (at_directive_argc == 5) {
#line 213
            goto case_5;
          }
#line 217
          if (at_directive_argc == 6) {
#line 217
            goto case_6;
          }
#line 222
          goto switch_default___0;
          case_2: /* CIL Label */ 
          {
#line 204
          tmp___0 = gettext((char const   *)*(at_directive_argv + 1));
#line 204
          (*func)((char const   *)tmp___0);
          }
#line 205
          goto switch_break___0;
          case_3: /* CIL Label */ 
          {
#line 207
          tmp___1 = gettext((char const   *)*(at_directive_argv + 1));
#line 207
          (*func)((char const   *)tmp___1, *(at_directive_argv + 2));
          }
#line 208
          goto switch_break___0;
          case_4: /* CIL Label */ 
          {
#line 210
          tmp___2 = gettext((char const   *)*(at_directive_argv + 1));
#line 210
          (*func)((char const   *)tmp___2, *(at_directive_argv + 2), *(at_directive_argv + 3));
          }
#line 212
          goto switch_break___0;
          case_5: /* CIL Label */ 
          {
#line 214
          tmp___3 = gettext((char const   *)*(at_directive_argv + 1));
#line 214
          (*func)((char const   *)tmp___3, *(at_directive_argv + 2), *(at_directive_argv + 3),
                  *(at_directive_argv + 4));
          }
#line 216
          goto switch_break___0;
          case_6: /* CIL Label */ 
          {
#line 218
          tmp___4 = gettext((char const   *)*(at_directive_argv + 1));
#line 218
          (*func)((char const   *)tmp___4, *(at_directive_argv + 2), *(at_directive_argv + 3),
                  *(at_directive_argv + 4), *(at_directive_argv + 5));
          }
#line 221
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
          {
#line 223
          fail_for_at_directive_too_many_args((char const   *)*(at_directive_argv + 0));
          }
#line 224
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 227
          tmp___11 = strcmp((char const   *)*(at_directive_argv + 0), "@warn_at");
          }
#line 227
          if (0 == tmp___11) {
#line 227
            goto _L;
          } else {
            {
#line 227
            tmp___12 = strcmp((char const   *)*(at_directive_argv + 0), "@complain_at");
            }
#line 227
            if (0 == tmp___12) {
#line 227
              goto _L;
            } else {
              {
#line 227
              tmp___13 = strcmp((char const   *)*(at_directive_argv + 0), "@fatal_at");
              }
#line 227
              if (0 == tmp___13) {
                _L: /* CIL Label */ 
#line 233
                if (at_directive_argc < 4) {
                  {
#line 234
                  fail_for_at_directive_too_few_args((char const   *)*(at_directive_argv + 0));
                  }
                }
                {
#line 237
                if ((int )*(*(at_directive_argv + 0) + 1) == 119) {
#line 237
                  goto case_119___0;
                }
#line 238
                if ((int )*(*(at_directive_argv + 0) + 1) == 99) {
#line 238
                  goto case_99___0;
                }
#line 239
                if ((int )*(*(at_directive_argv + 0) + 1) == 102) {
#line 239
                  goto case_102___0;
                }
#line 240
                goto switch_default___1;
                case_119___0: /* CIL Label */ 
#line 237
                func___0 = (void (*)(location  , char const   *  , ...))(& warn_at);
#line 237
                goto switch_break___1;
                case_99___0: /* CIL Label */ 
#line 238
                func___0 = (void (*)(location  , char const   *  , ...))(& complain_at);
#line 238
                goto switch_break___1;
                case_102___0: /* CIL Label */ 
#line 239
                func___0 = (void (*)(location  , char const   *  , ...))(& fatal_at);
#line 239
                goto switch_break___1;
                switch_default___1: /* CIL Label */ 
                {
#line 240
                __assert_fail("0", "scan-skel.l", 240U, "at_directive_perform");
                }
#line 240
                goto switch_break___1;
                switch_break___1: /* CIL Label */ ;
                }
                {
#line 242
                boundary_set_from_string(& loc___0.start, *(at_directive_argv + 1));
#line 243
                boundary_set_from_string(& loc___0.end, *(at_directive_argv + 2));
                }
                {
#line 246
                if (at_directive_argc == 4) {
#line 246
                  goto case_4___0;
                }
#line 249
                if (at_directive_argc == 5) {
#line 249
                  goto case_5___0;
                }
#line 252
                if (at_directive_argc == 6) {
#line 252
                  goto case_6___0;
                }
#line 256
                if (at_directive_argc == 7) {
#line 256
                  goto case_7;
                }
#line 260
                if (at_directive_argc == 8) {
#line 260
                  goto case_8;
                }
#line 265
                goto switch_default___2;
                case_4___0: /* CIL Label */ 
                {
#line 247
                tmp___5 = gettext((char const   *)*(at_directive_argv + 3));
#line 247
                (*func___0)(loc___0, (char const   *)tmp___5);
                }
#line 248
                goto switch_break___2;
                case_5___0: /* CIL Label */ 
                {
#line 250
                tmp___6 = gettext((char const   *)*(at_directive_argv + 3));
#line 250
                (*func___0)(loc___0, (char const   *)tmp___6, *(at_directive_argv + 4));
                }
#line 251
                goto switch_break___2;
                case_6___0: /* CIL Label */ 
                {
#line 253
                tmp___7 = gettext((char const   *)*(at_directive_argv + 3));
#line 253
                (*func___0)(loc___0, (char const   *)tmp___7, *(at_directive_argv + 4),
                            *(at_directive_argv + 5));
                }
#line 255
                goto switch_break___2;
                case_7: /* CIL Label */ 
                {
#line 257
                tmp___8 = gettext((char const   *)*(at_directive_argv + 3));
#line 257
                (*func___0)(loc___0, (char const   *)tmp___8, *(at_directive_argv + 4),
                            *(at_directive_argv + 5), *(at_directive_argv + 6));
                }
#line 259
                goto switch_break___2;
                case_8: /* CIL Label */ 
                {
#line 261
                tmp___9 = gettext((char const   *)*(at_directive_argv + 3));
#line 261
                (*func___0)(loc___0, (char const   *)tmp___9, *(at_directive_argv + 4),
                            *(at_directive_argv + 5), *(at_directive_argv + 6), *(at_directive_argv + 7));
                }
#line 264
                goto switch_break___2;
                switch_default___2: /* CIL Label */ 
                {
#line 266
                fail_for_at_directive_too_many_args((char const   *)*(at_directive_argv + 0));
                }
#line 267
                goto switch_break___2;
                switch_break___2: /* CIL Label */ ;
                }
              } else {
                {
#line 270
                tmp___10 = strcmp((char const   *)*(at_directive_argv + 0), "@output");
                }
#line 270
                if (0 == tmp___10) {
#line 272
                  if (at_directive_argc > 2) {
                    {
#line 273
                    fail_for_at_directive_too_many_args((char const   *)*(at_directive_argv + 0));
                    }
                  }
#line 274
                  if (*outnamep) {
                    {
#line 276
                    free((void *)*outnamep);
#line 277
                    xfclose(skel_out);
                    }
                  }
                  {
#line 279
                  *outnamep = xstrdup((char const   *)*(at_directive_argv + 1));
#line 280
                  output_file_name_check(outnamep);
#line 281
                  skel_out = xfopen((char const   *)*outnamep, "w");
#line 282
                  *out_linenop = 1;
                  }
                } else {
                  {
#line 285
                  fail_for_invalid_at((char const   *)*(at_directive_argv + 0));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 286
  return;
}
}
#line 288 "scan-skel.l"
static void fail_for_at_directive_too_few_args(char const   *at_directive_name ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 291
  tmp = gettext("too few arguments for %s directive in skeleton");
#line 291
  fatal((char const   *)tmp, at_directive_name);
  }
}
}
#line 295 "scan-skel.l"
static void fail_for_at_directive_too_many_args(char const   *at_directive_name ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 298
  tmp = gettext("too many arguments for %s directive in skeleton");
#line 298
  fatal((char const   *)tmp, at_directive_name);
  }
}
}
#line 302 "scan-skel.l"
static void fail_for_invalid_at(char const   *at ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 305
  fatal("invalid @ in skeleton: %s", at);
  }
}
}
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 227 "scan-gram.c"
int gram_leng  ;
#line 232
FILE *gram_in ;
#line 232
FILE *gram_out ;
#line 339 "scan-gram.c"
static size_t yy_buffer_stack_top___0  =    (size_t )0;
#line 340 "scan-gram.c"
static size_t yy_buffer_stack_max___0  =    (size_t )0;
#line 341 "scan-gram.c"
static YY_BUFFER_STATE *yy_buffer_stack___0  =    (YY_BUFFER_STATE *)0;
#line 368 "scan-gram.c"
static char yy_hold_char___0  ;
#line 369 "scan-gram.c"
static int yy_n_chars___0  ;
#line 373 "scan-gram.c"
static char *yy_c_buf_p___0  =    (char *)0;
#line 374 "scan-gram.c"
static int yy_init___0  =    0;
#line 375 "scan-gram.c"
static int yy_start___0  =    0;
#line 380 "scan-gram.c"
static int yy_did_buffer_switch_on_eof___0  ;
#line 385
void gram_restart(FILE *input_file ) ;
#line 386
void gram__switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 387
YY_BUFFER_STATE gram__create_buffer(FILE *file , int size ) ;
#line 388
void gram__delete_buffer(YY_BUFFER_STATE b ) ;
#line 389
void gram__flush_buffer(YY_BUFFER_STATE b ) ;
#line 390
void gram_push_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 391
void gram_pop_buffer_state(void) ;
#line 393
static void gram_ensure_buffer_stack(void) ;
#line 394
static void gram__load_buffer_state(void) ;
#line 395
static void gram__init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 399
YY_BUFFER_STATE gram__scan_buffer(char *base___0 , yy_size_t size ) ;
#line 400
YY_BUFFER_STATE gram__scan_string(char const   *yystr ) ;
#line 401
YY_BUFFER_STATE gram__scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 405
void *gram_alloc(yy_size_t size ) ;
#line 406
void *gram_realloc(void *ptr , yy_size_t size ) ;
#line 407
void gram_free(void *ptr ) ;
#line 443 "scan-gram.c"
FILE *gram_in  =    (FILE *)0;
#line 443 "scan-gram.c"
FILE *gram_out  =    (FILE *)0;
#line 447
int gram_lineno ;
#line 449 "scan-gram.c"
int gram_lineno  =    1;
#line 451 "scan-gram.c"
char *gram_text  ;
#line 456
static yy_state_type yy_get_previous_state___0(void) ;
#line 457
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) ;
#line 458
static int yy_get_next_buffer___0(void) ;
#line 459
static void yy_fatal_error___0(char const   *msg ) ;
#line 485 "scan-gram.c"
static flex_int16_t const   yy_accept___0[474]  = 
#line 485
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )110,      (flex_int16_t const   )65,      (flex_int16_t const   )2, 
        (flex_int16_t const   )2,      (flex_int16_t const   )59,      (flex_int16_t const   )65,      (flex_int16_t const   )58, 
        (flex_int16_t const   )1,      (flex_int16_t const   )54,      (flex_int16_t const   )65,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )51,      (flex_int16_t const   )65,      (flex_int16_t const   )49, 
        (flex_int16_t const   )64,      (flex_int16_t const   )61,      (flex_int16_t const   )50,      (flex_int16_t const   )65, 
        (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )107,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )107,      (flex_int16_t const   )80,      (flex_int16_t const   )79, 
        (flex_int16_t const   )79,      (flex_int16_t const   )68,      (flex_int16_t const   )2,      (flex_int16_t const   )1, 
        (flex_int16_t const   )68,      (flex_int16_t const   )67,      (flex_int16_t const   )66,      (flex_int16_t const   )68, 
        (flex_int16_t const   )108,      (flex_int16_t const   )99,      (flex_int16_t const   )107,      (flex_int16_t const   )98, 
        (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )102, 
        (flex_int16_t const   )104,      (flex_int16_t const   )107,      (flex_int16_t const   )76,      (flex_int16_t const   )107, 
        (flex_int16_t const   )97,      (flex_int16_t const   )96,      (flex_int16_t const   )107,      (flex_int16_t const   )95, 
        (flex_int16_t const   )94,      (flex_int16_t const   )71,      (flex_int16_t const   )2,      (flex_int16_t const   )1, 
        (flex_int16_t const   )69,      (flex_int16_t const   )71,      (flex_int16_t const   )70,      (flex_int16_t const   )71, 
        (flex_int16_t const   )72,      (flex_int16_t const   )2,      (flex_int16_t const   )1,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )63,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )60,      (flex_int16_t const   )54,      (flex_int16_t const   )4, 
        (flex_int16_t const   )3,      (flex_int16_t const   )57,      (flex_int16_t const   )55,      (flex_int16_t const   )57, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )53,      (flex_int16_t const   )0, 
        (flex_int16_t const   )73,      (flex_int16_t const   )92,      (flex_int16_t const   )90,      (flex_int16_t const   )81, 
        (flex_int16_t const   )92,      (flex_int16_t const   )83,      (flex_int16_t const   )84,      (flex_int16_t const   )85, 
        (flex_int16_t const   )86,      (flex_int16_t const   )87,      (flex_int16_t const   )88,      (flex_int16_t const   )92, 
        (flex_int16_t const   )89,      (flex_int16_t const   )92,      (flex_int16_t const   )106,      (flex_int16_t const   )100, 
        (flex_int16_t const   )101,      (flex_int16_t const   )0,      (flex_int16_t const   )103,      (flex_int16_t const   )0, 
        (flex_int16_t const   )102,      (flex_int16_t const   )105,      (flex_int16_t const   )0,      (flex_int16_t const   )75, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )77,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )69, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )3, 
        (flex_int16_t const   )57,      (flex_int16_t const   )56,      (flex_int16_t const   )62,      (flex_int16_t const   )52, 
        (flex_int16_t const   )0,      (flex_int16_t const   )81,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )82,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )0,      (flex_int16_t const   )81, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )48,      (flex_int16_t const   )7, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )22,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )34,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )41, 
        (flex_int16_t const   )48,      (flex_int16_t const   )44,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )47,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )48,      (flex_int16_t const   )8,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )13,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )25, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )31,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )38, 
        (flex_int16_t const   )48,      (flex_int16_t const   )40,      (flex_int16_t const   )42,      (flex_int16_t const   )45, 
        (flex_int16_t const   )48,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )91, 
        (flex_int16_t const   )6,      (flex_int16_t const   )48,      (flex_int16_t const   )10,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )15,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )32,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )0,      (flex_int16_t const   )48, 
        (flex_int16_t const   )11,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )35,      (flex_int16_t const   )48,      (flex_int16_t const   )37, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )46,      (flex_int16_t const   )0, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )21,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )39,      (flex_int16_t const   )48, 
        (flex_int16_t const   )0,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )16,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )48, 
        (flex_int16_t const   )12,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )20,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )5,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )17, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )26,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )33,      (flex_int16_t const   )36,      (flex_int16_t const   )43, 
        (flex_int16_t const   )9,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )14,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )19,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )27,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )18,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )30,      (flex_int16_t const   )0};
#line 541 "scan-gram.c"
static flex_int32_t const   yy_ec___0[256]  = 
#line 541
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )1,      (flex_int32_t const   )8, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )9,      (flex_int32_t const   )1, 
        (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13, 
        (flex_int32_t const   )14,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )17,      (flex_int32_t const   )18, 
        (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )22, 
        (flex_int32_t const   )1,      (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23, 
        (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )23,      (flex_int32_t const   )12, 
        (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )12,      (flex_int32_t const   )24,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )25,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )26, 
        (flex_int32_t const   )27,      (flex_int32_t const   )28,      (flex_int32_t const   )1,      (flex_int32_t const   )29, 
        (flex_int32_t const   )1,      (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )32, 
        (flex_int32_t const   )33,      (flex_int32_t const   )34,      (flex_int32_t const   )35,      (flex_int32_t const   )36, 
        (flex_int32_t const   )37,      (flex_int32_t const   )38,      (flex_int32_t const   )12,      (flex_int32_t const   )39, 
        (flex_int32_t const   )40,      (flex_int32_t const   )41,      (flex_int32_t const   )42,      (flex_int32_t const   )43, 
        (flex_int32_t const   )44,      (flex_int32_t const   )45,      (flex_int32_t const   )46,      (flex_int32_t const   )47, 
        (flex_int32_t const   )48,      (flex_int32_t const   )49,      (flex_int32_t const   )50,      (flex_int32_t const   )12, 
        (flex_int32_t const   )51,      (flex_int32_t const   )52,      (flex_int32_t const   )12,      (flex_int32_t const   )53, 
        (flex_int32_t const   )54,      (flex_int32_t const   )55,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 573 "scan-gram.c"
static flex_int32_t const   yy_meta___0[57]  = 
#line 573
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3, 
        (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )5, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )6,      (flex_int32_t const   )1, 
        (flex_int32_t const   )6,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )7};
#line 583 "scan-gram.c"
static flex_int16_t const   yy_base___0[497]  = 
#line 583
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )756,      (flex_int16_t const   )752, 
        (flex_int16_t const   )751,      (flex_int16_t const   )54,      (flex_int16_t const   )55,      (flex_int16_t const   )58, 
        (flex_int16_t const   )59,      (flex_int16_t const   )61,      (flex_int16_t const   )66,      (flex_int16_t const   )86, 
        (flex_int16_t const   )93,      (flex_int16_t const   )100,      (flex_int16_t const   )113,      (flex_int16_t const   )120, 
        (flex_int16_t const   )126,      (flex_int16_t const   )81,      (flex_int16_t const   )121,      (flex_int16_t const   )70, 
        (flex_int16_t const   )77,      (flex_int16_t const   )132,      (flex_int16_t const   )133,      (flex_int16_t const   )114, 
        (flex_int16_t const   )137,      (flex_int16_t const   )168,      (flex_int16_t const   )753,      (flex_int16_t const   )144, 
        (flex_int16_t const   )223,      (flex_int16_t const   )758,      (flex_int16_t const   )763,      (flex_int16_t const   )763, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )230,      (flex_int16_t const   )763, 
        (flex_int16_t const   )763,      (flex_int16_t const   )0,      (flex_int16_t const   )143,      (flex_int16_t const   )233, 
        (flex_int16_t const   )128,      (flex_int16_t const   )763,      (flex_int16_t const   )140,      (flex_int16_t const   )763, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )717, 
        (flex_int16_t const   )763,      (flex_int16_t const   )743,      (flex_int16_t const   )763,      (flex_int16_t const   )763, 
        (flex_int16_t const   )763,      (flex_int16_t const   )280,      (flex_int16_t const   )763,      (flex_int16_t const   )763, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )763, 
        (flex_int16_t const   )149,      (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )715, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )699,      (flex_int16_t const   )763, 
        (flex_int16_t const   )219,      (flex_int16_t const   )213,      (flex_int16_t const   )224,      (flex_int16_t const   )763, 
        (flex_int16_t const   )763,      (flex_int16_t const   )75,      (flex_int16_t const   )763,      (flex_int16_t const   )287, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )294,      (flex_int16_t const   )763, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )763, 
        (flex_int16_t const   )0,      (flex_int16_t const   )154,      (flex_int16_t const   )763,      (flex_int16_t const   )713, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )226, 
        (flex_int16_t const   )712,      (flex_int16_t const   )763,      (flex_int16_t const   )0,      (flex_int16_t const   )713, 
        (flex_int16_t const   )707,      (flex_int16_t const   )259,      (flex_int16_t const   )199,      (flex_int16_t const   )711, 
        (flex_int16_t const   )708,      (flex_int16_t const   )705,      (flex_int16_t const   )271,      (flex_int16_t const   )712, 
        (flex_int16_t const   )269,      (flex_int16_t const   )696,      (flex_int16_t const   )270,      (flex_int16_t const   )218, 
        (flex_int16_t const   )270,      (flex_int16_t const   )289,      (flex_int16_t const   )702,      (flex_int16_t const   )709, 
        (flex_int16_t const   )712,      (flex_int16_t const   )763,      (flex_int16_t const   )0,      (flex_int16_t const   )763, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )319,      (flex_int16_t const   )328, 
        (flex_int16_t const   )720,      (flex_int16_t const   )719,      (flex_int16_t const   )763,      (flex_int16_t const   )701, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )136, 
        (flex_int16_t const   )0,      (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )763, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )0, 
        (flex_int16_t const   )763,      (flex_int16_t const   )0,      (flex_int16_t const   )763,      (flex_int16_t const   )763, 
        (flex_int16_t const   )763,      (flex_int16_t const   )334,      (flex_int16_t const   )763,      (flex_int16_t const   )343, 
        (flex_int16_t const   )763,      (flex_int16_t const   )763,      (flex_int16_t const   )346,      (flex_int16_t const   )763, 
        (flex_int16_t const   )350,      (flex_int16_t const   )353,      (flex_int16_t const   )711,      (flex_int16_t const   )763, 
        (flex_int16_t const   )362,      (flex_int16_t const   )710,      (flex_int16_t const   )365,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )694,      (flex_int16_t const   )702,      (flex_int16_t const   )339, 
        (flex_int16_t const   )688,      (flex_int16_t const   )687,      (flex_int16_t const   )688,      (flex_int16_t const   )190, 
        (flex_int16_t const   )685,      (flex_int16_t const   )692,      (flex_int16_t const   )687,      (flex_int16_t const   )257, 
        (flex_int16_t const   )696,      (flex_int16_t const   )681,      (flex_int16_t const   )685,      (flex_int16_t const   )360, 
        (flex_int16_t const   )691,      (flex_int16_t const   )676,      (flex_int16_t const   )677,      (flex_int16_t const   )286, 
        (flex_int16_t const   )676,      (flex_int16_t const   )676,      (flex_int16_t const   )684,      (flex_int16_t const   )685, 
        (flex_int16_t const   )688,      (flex_int16_t const   )671,      (flex_int16_t const   )677,      (flex_int16_t const   )671, 
        (flex_int16_t const   )676,      (flex_int16_t const   )667,      (flex_int16_t const   )680,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )763,      (flex_int16_t const   )763, 
        (flex_int16_t const   )669,      (flex_int16_t const   )272,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )373,      (flex_int16_t const   )369,      (flex_int16_t const   )377, 
        (flex_int16_t const   )217,      (flex_int16_t const   )381,      (flex_int16_t const   )380,      (flex_int16_t const   )388, 
        (flex_int16_t const   )82,      (flex_int16_t const   )391,      (flex_int16_t const   )401,      (flex_int16_t const   )406, 
        (flex_int16_t const   )409,      (flex_int16_t const   )370,      (flex_int16_t const   )680,      (flex_int16_t const   )675, 
        (flex_int16_t const   )659,      (flex_int16_t const   )368,      (flex_int16_t const   )659,      (flex_int16_t const   )672, 
        (flex_int16_t const   )662,      (flex_int16_t const   )670,      (flex_int16_t const   )669,      (flex_int16_t const   )668, 
        (flex_int16_t const   )690,      (flex_int16_t const   )652,      (flex_int16_t const   )663,      (flex_int16_t const   )650, 
        (flex_int16_t const   )686,      (flex_int16_t const   )666,      (flex_int16_t const   )659,      (flex_int16_t const   )660, 
        (flex_int16_t const   )273,      (flex_int16_t const   )384,      (flex_int16_t const   )647,      (flex_int16_t const   )648, 
        (flex_int16_t const   )644,      (flex_int16_t const   )658,      (flex_int16_t const   )647,      (flex_int16_t const   )654, 
        (flex_int16_t const   )638,      (flex_int16_t const   )649,      (flex_int16_t const   )645,      (flex_int16_t const   )638, 
        (flex_int16_t const   )642,      (flex_int16_t const   )648,      (flex_int16_t const   )647,      (flex_int16_t const   )637, 
        (flex_int16_t const   )648,      (flex_int16_t const   )646,      (flex_int16_t const   )643,      (flex_int16_t const   )763, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )630,      (flex_int16_t const   )0, 
        (flex_int16_t const   )639,      (flex_int16_t const   )625,      (flex_int16_t const   )631,      (flex_int16_t const   )626, 
        (flex_int16_t const   )639,      (flex_int16_t const   )624,      (flex_int16_t const   )637,      (flex_int16_t const   )657, 
        (flex_int16_t const   )634,      (flex_int16_t const   )622,      (flex_int16_t const   )627,      (flex_int16_t const   )615, 
        (flex_int16_t const   )0,      (flex_int16_t const   )619,      (flex_int16_t const   )614,      (flex_int16_t const   )627, 
        (flex_int16_t const   )389,      (flex_int16_t const   )626,      (flex_int16_t const   )621,      (flex_int16_t const   )611, 
        (flex_int16_t const   )623,      (flex_int16_t const   )615,      (flex_int16_t const   )606,      (flex_int16_t const   )620, 
        (flex_int16_t const   )0,      (flex_int16_t const   )605,      (flex_int16_t const   )390,      (flex_int16_t const   )614, 
        (flex_int16_t const   )603,      (flex_int16_t const   )616,      (flex_int16_t const   )601,      (flex_int16_t const   )0, 
        (flex_int16_t const   )606,      (flex_int16_t const   )0,      (flex_int16_t const   )605,      (flex_int16_t const   )603, 
        (flex_int16_t const   )0,      (flex_int16_t const   )641,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )592,      (flex_int16_t const   )0,      (flex_int16_t const   )603,      (flex_int16_t const   )608, 
        (flex_int16_t const   )592,      (flex_int16_t const   )0,      (flex_int16_t const   )404,      (flex_int16_t const   )592, 
        (flex_int16_t const   )595,      (flex_int16_t const   )405,      (flex_int16_t const   )608,      (flex_int16_t const   )607, 
        (flex_int16_t const   )606,      (flex_int16_t const   )605,      (flex_int16_t const   )596,      (flex_int16_t const   )0, 
        (flex_int16_t const   )589,      (flex_int16_t const   )597,      (flex_int16_t const   )589,      (flex_int16_t const   )583, 
        (flex_int16_t const   )581,      (flex_int16_t const   )0,      (flex_int16_t const   )580,      (flex_int16_t const   )616, 
        (flex_int16_t const   )592,      (flex_int16_t const   )581,      (flex_int16_t const   )578,      (flex_int16_t const   )0, 
        (flex_int16_t const   )575,      (flex_int16_t const   )0,      (flex_int16_t const   )409,      (flex_int16_t const   )0, 
        (flex_int16_t const   )575,      (flex_int16_t const   )407,      (flex_int16_t const   )0,      (flex_int16_t const   )763, 
        (flex_int16_t const   )0,      (flex_int16_t const   )573,      (flex_int16_t const   )573,      (flex_int16_t const   )587, 
        (flex_int16_t const   )568,      (flex_int16_t const   )413,      (flex_int16_t const   )571,      (flex_int16_t const   )573, 
        (flex_int16_t const   )569,      (flex_int16_t const   )574,      (flex_int16_t const   )577,      (flex_int16_t const   )566, 
        (flex_int16_t const   )568,      (flex_int16_t const   )564,      (flex_int16_t const   )579,      (flex_int16_t const   )574, 
        (flex_int16_t const   )564,      (flex_int16_t const   )572,      (flex_int16_t const   )0,      (flex_int16_t const   )561, 
        (flex_int16_t const   )558,      (flex_int16_t const   )573,      (flex_int16_t const   )568,      (flex_int16_t const   )558, 
        (flex_int16_t const   )552,      (flex_int16_t const   )565,      (flex_int16_t const   )421,      (flex_int16_t const   )415, 
        (flex_int16_t const   )0,      (flex_int16_t const   )550,      (flex_int16_t const   )563,      (flex_int16_t const   )550, 
        (flex_int16_t const   )561,      (flex_int16_t const   )545,      (flex_int16_t const   )546,      (flex_int16_t const   )581, 
        (flex_int16_t const   )557,      (flex_int16_t const   )560,      (flex_int16_t const   )547,      (flex_int16_t const   )554, 
        (flex_int16_t const   )538,      (flex_int16_t const   )539,      (flex_int16_t const   )553,      (flex_int16_t const   )538, 
        (flex_int16_t const   )553,      (flex_int16_t const   )0,      (flex_int16_t const   )536,      (flex_int16_t const   )0, 
        (flex_int16_t const   )539,      (flex_int16_t const   )550,      (flex_int16_t const   )0,      (flex_int16_t const   )574, 
        (flex_int16_t const   )534,      (flex_int16_t const   )534,      (flex_int16_t const   )530,      (flex_int16_t const   )529, 
        (flex_int16_t const   )539,      (flex_int16_t const   )525,      (flex_int16_t const   )538,      (flex_int16_t const   )541, 
        (flex_int16_t const   )0,      (flex_int16_t const   )529,      (flex_int16_t const   )522,      (flex_int16_t const   )533, 
        (flex_int16_t const   )527,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )525, 
        (flex_int16_t const   )519,      (flex_int16_t const   )517,      (flex_int16_t const   )0,      (flex_int16_t const   )532, 
        (flex_int16_t const   )557,      (flex_int16_t const   )515,      (flex_int16_t const   )514,      (flex_int16_t const   )528, 
        (flex_int16_t const   )0,      (flex_int16_t const   )520,      (flex_int16_t const   )513,      (flex_int16_t const   )510, 
        (flex_int16_t const   )523,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )516, 
        (flex_int16_t const   )505,      (flex_int16_t const   )514,      (flex_int16_t const   )521,      (flex_int16_t const   )516, 
        (flex_int16_t const   )509,      (flex_int16_t const   )543,      (flex_int16_t const   )72,      (flex_int16_t const   )513, 
        (flex_int16_t const   )0,      (flex_int16_t const   )503,      (flex_int16_t const   )494,      (flex_int16_t const   )495, 
        (flex_int16_t const   )0,      (flex_int16_t const   )495,      (flex_int16_t const   )491,      (flex_int16_t const   )416, 
        (flex_int16_t const   )499,      (flex_int16_t const   )499,      (flex_int16_t const   )493,      (flex_int16_t const   )504, 
        (flex_int16_t const   )763,      (flex_int16_t const   )505,      (flex_int16_t const   )489,      (flex_int16_t const   )0, 
        (flex_int16_t const   )487,      (flex_int16_t const   )496,      (flex_int16_t const   )0,      (flex_int16_t const   )489, 
        (flex_int16_t const   )494,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )497,      (flex_int16_t const   )417,      (flex_int16_t const   )487, 
        (flex_int16_t const   )483,      (flex_int16_t const   )481,      (flex_int16_t const   )0,      (flex_int16_t const   )492, 
        (flex_int16_t const   )484,      (flex_int16_t const   )491,      (flex_int16_t const   )476,      (flex_int16_t const   )485, 
        (flex_int16_t const   )0,      (flex_int16_t const   )485,      (flex_int16_t const   )469,      (flex_int16_t const   )458, 
        (flex_int16_t const   )0,      (flex_int16_t const   )449,      (flex_int16_t const   )409,      (flex_int16_t const   )430, 
        (flex_int16_t const   )393,      (flex_int16_t const   )395,      (flex_int16_t const   )0,      (flex_int16_t const   )402, 
        (flex_int16_t const   )385,      (flex_int16_t const   )383,      (flex_int16_t const   )395,      (flex_int16_t const   )342, 
        (flex_int16_t const   )0,      (flex_int16_t const   )763,      (flex_int16_t const   )446,      (flex_int16_t const   )453, 
        (flex_int16_t const   )460,      (flex_int16_t const   )467,      (flex_int16_t const   )472,      (flex_int16_t const   )474, 
        (flex_int16_t const   )479,      (flex_int16_t const   )485,      (flex_int16_t const   )492,      (flex_int16_t const   )497, 
        (flex_int16_t const   )500,      (flex_int16_t const   )505,      (flex_int16_t const   )510,      (flex_int16_t const   )367, 
        (flex_int16_t const   )335,      (flex_int16_t const   )334,      (flex_int16_t const   )322,      (flex_int16_t const   )320, 
        (flex_int16_t const   )252,      (flex_int16_t const   )160,      (flex_int16_t const   )122,      (flex_int16_t const   )107, 
        (flex_int16_t const   )515};
#line 642 "scan-gram.c"
static flex_int16_t const   yy_def___0[497]  = 
#line 642
  {      (flex_int16_t const   )0,      (flex_int16_t const   )473,      (flex_int16_t const   )1,      (flex_int16_t const   )474, 
        (flex_int16_t const   )474,      (flex_int16_t const   )475,      (flex_int16_t const   )475,      (flex_int16_t const   )475, 
        (flex_int16_t const   )475,      (flex_int16_t const   )476,      (flex_int16_t const   )476,      (flex_int16_t const   )475, 
        (flex_int16_t const   )475,      (flex_int16_t const   )475,      (flex_int16_t const   )475,      (flex_int16_t const   )475, 
        (flex_int16_t const   )475,      (flex_int16_t const   )475,      (flex_int16_t const   )475,      (flex_int16_t const   )475, 
        (flex_int16_t const   )475,      (flex_int16_t const   )475,      (flex_int16_t const   )475,      (flex_int16_t const   )475, 
        (flex_int16_t const   )475,      (flex_int16_t const   )473,      (flex_int16_t const   )25,      (flex_int16_t const   )477, 
        (flex_int16_t const   )477,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )478,      (flex_int16_t const   )473,      (flex_int16_t const   )479, 
        (flex_int16_t const   )479,      (flex_int16_t const   )473,      (flex_int16_t const   )480,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )481,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )482,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )483,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )473,      (flex_int16_t const   )478,      (flex_int16_t const   )473, 
        (flex_int16_t const   )485,      (flex_int16_t const   )486,      (flex_int16_t const   )479,      (flex_int16_t const   )486, 
        (flex_int16_t const   )480,      (flex_int16_t const   )480,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )487,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )488, 
        (flex_int16_t const   )473,      (flex_int16_t const   )489,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )483, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )485, 
        (flex_int16_t const   )486,      (flex_int16_t const   )119,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )490,      (flex_int16_t const   )491, 
        (flex_int16_t const   )489,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )482,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )492,      (flex_int16_t const   )493,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )473,      (flex_int16_t const   )494,      (flex_int16_t const   )495, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )473,      (flex_int16_t const   )488,      (flex_int16_t const   )473, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )473,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )473, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )496,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )496,      (flex_int16_t const   )496,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )473,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )0,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473};
#line 701 "scan-gram.c"
static flex_int16_t const   yy_nxt___0[820]  = 
#line 701
  {      (flex_int16_t const   )0,      (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )32, 
        (flex_int16_t const   )31,      (flex_int16_t const   )33,      (flex_int16_t const   )30,      (flex_int16_t const   )34, 
        (flex_int16_t const   )35,      (flex_int16_t const   )30,      (flex_int16_t const   )36,      (flex_int16_t const   )30, 
        (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )39,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )30,      (flex_int16_t const   )41,      (flex_int16_t const   )42, 
        (flex_int16_t const   )43,      (flex_int16_t const   )30,      (flex_int16_t const   )30,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )44,      (flex_int16_t const   )30, 
        (flex_int16_t const   )30,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )45,      (flex_int16_t const   )46,      (flex_int16_t const   )30, 
        (flex_int16_t const   )30,      (flex_int16_t const   )51,      (flex_int16_t const   )51,      (flex_int16_t const   )52, 
        (flex_int16_t const   )52,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )58, 
        (flex_int16_t const   )32,      (flex_int16_t const   )58,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )58,      (flex_int16_t const   )32,      (flex_int16_t const   )58,      (flex_int16_t const   )59, 
        (flex_int16_t const   )63,      (flex_int16_t const   )74,      (flex_int16_t const   )60,      (flex_int16_t const   )432, 
        (flex_int16_t const   )59,      (flex_int16_t const   )418,      (flex_int16_t const   )61,      (flex_int16_t const   )60, 
        (flex_int16_t const   )74,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )61, 
        (flex_int16_t const   )64,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )62, 
        (flex_int16_t const   )147,      (flex_int16_t const   )64,      (flex_int16_t const   )73,      (flex_int16_t const   )65, 
        (flex_int16_t const   )62,      (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )147, 
        (flex_int16_t const   )64,      (flex_int16_t const   )75,      (flex_int16_t const   )65,      (flex_int16_t const   )68, 
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )148,      (flex_int16_t const   )64, 
        (flex_int16_t const   )75,      (flex_int16_t const   )65,      (flex_int16_t const   )68,      (flex_int16_t const   )69, 
        (flex_int16_t const   )67,      (flex_int16_t const   )148,      (flex_int16_t const   )54,      (flex_int16_t const   )54, 
        (flex_int16_t const   )327,      (flex_int16_t const   )68,      (flex_int16_t const   )54,      (flex_int16_t const   )54, 
        (flex_int16_t const   )64,      (flex_int16_t const   )79,      (flex_int16_t const   )65,      (flex_int16_t const   )70, 
        (flex_int16_t const   )69,      (flex_int16_t const   )67,      (flex_int16_t const   )80,      (flex_int16_t const   )64, 
        (flex_int16_t const   )64,      (flex_int16_t const   )65,      (flex_int16_t const   )68,      (flex_int16_t const   )326, 
        (flex_int16_t const   )67,      (flex_int16_t const   )64,      (flex_int16_t const   )73,      (flex_int16_t const   )65, 
        (flex_int16_t const   )70,      (flex_int16_t const   )68,      (flex_int16_t const   )67,      (flex_int16_t const   )76, 
        (flex_int16_t const   )76,      (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )68, 
        (flex_int16_t const   )79,      (flex_int16_t const   )78,      (flex_int16_t const   )118,      (flex_int16_t const   )118, 
        (flex_int16_t const   )118,      (flex_int16_t const   )80,      (flex_int16_t const   )89,      (flex_int16_t const   )32, 
        (flex_int16_t const   )89,      (flex_int16_t const   )121,      (flex_int16_t const   )193,      (flex_int16_t const   )193, 
        (flex_int16_t const   )115,      (flex_int16_t const   )71,      (flex_int16_t const   )90,      (flex_int16_t const   )72, 
        (flex_int16_t const   )116,      (flex_int16_t const   )91,      (flex_int16_t const   )115,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )122,      (flex_int16_t const   )116,      (flex_int16_t const   )115, 
        (flex_int16_t const   )78,      (flex_int16_t const   )291,      (flex_int16_t const   )71,      (flex_int16_t const   )116, 
        (flex_int16_t const   )72,      (flex_int16_t const   )81,      (flex_int16_t const   )82,      (flex_int16_t const   )32, 
        (flex_int16_t const   )82,      (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )81, 
        (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )83,      (flex_int16_t const   )81, 
        (flex_int16_t const   )84,      (flex_int16_t const   )85,      (flex_int16_t const   )81,      (flex_int16_t const   )81, 
        (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )81, 
        (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )81,      (flex_int16_t const   )81, 
        (flex_int16_t const   )86,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )81, 
        (flex_int16_t const   )81,      (flex_int16_t const   )89,      (flex_int16_t const   )32,      (flex_int16_t const   )89, 
        (flex_int16_t const   )139,      (flex_int16_t const   )92,      (flex_int16_t const   )218,      (flex_int16_t const   )144, 
        (flex_int16_t const   )140,      (flex_int16_t const   )90,      (flex_int16_t const   )142,      (flex_int16_t const   )115, 
        (flex_int16_t const   )91,      (flex_int16_t const   )93,      (flex_int16_t const   )142,      (flex_int16_t const   )116, 
        (flex_int16_t const   )143,      (flex_int16_t const   )219,      (flex_int16_t const   )94,      (flex_int16_t const   )145, 
        (flex_int16_t const   )143,      (flex_int16_t const   )161,      (flex_int16_t const   )141,      (flex_int16_t const   )118, 
        (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )162,      (flex_int16_t const   )146, 
        (flex_int16_t const   )177,      (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94, 
        (flex_int16_t const   )178,      (flex_int16_t const   )290,      (flex_int16_t const   )119,      (flex_int16_t const   )94, 
        (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )96,      (flex_int16_t const   )97, 
        (flex_int16_t const   )98,      (flex_int16_t const   )99,      (flex_int16_t const   )100,      (flex_int16_t const   )94, 
        (flex_int16_t const   )101,      (flex_int16_t const   )94,      (flex_int16_t const   )102,      (flex_int16_t const   )103, 
        (flex_int16_t const   )104,      (flex_int16_t const   )105,      (flex_int16_t const   )106,      (flex_int16_t const   )94, 
        (flex_int16_t const   )107,      (flex_int16_t const   )108,      (flex_int16_t const   )109,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )94,      (flex_int16_t const   )112,      (flex_int16_t const   )113, 
        (flex_int16_t const   )119,      (flex_int16_t const   )126,      (flex_int16_t const   )247,      (flex_int16_t const   )247, 
        (flex_int16_t const   )126,      (flex_int16_t const   )149,      (flex_int16_t const   )150,      (flex_int16_t const   )149, 
        (flex_int16_t const   )223,      (flex_int16_t const   )159,      (flex_int16_t const   )127,      (flex_int16_t const   )127, 
        (flex_int16_t const   )152,      (flex_int16_t const   )153,      (flex_int16_t const   )152,      (flex_int16_t const   )170, 
        (flex_int16_t const   )174,      (flex_int16_t const   )166,      (flex_int16_t const   )126,      (flex_int16_t const   )160, 
        (flex_int16_t const   )128,      (flex_int16_t const   )167,      (flex_int16_t const   )269,      (flex_int16_t const   )126, 
        (flex_int16_t const   )224,      (flex_int16_t const   )179,      (flex_int16_t const   )129,      (flex_int16_t const   )130, 
        (flex_int16_t const   )171,      (flex_int16_t const   )270,      (flex_int16_t const   )168,      (flex_int16_t const   )131, 
        (flex_int16_t const   )175,      (flex_int16_t const   )172,      (flex_int16_t const   )180,      (flex_int16_t const   )176, 
        (flex_int16_t const   )233,      (flex_int16_t const   )154,      (flex_int16_t const   )132,      (flex_int16_t const   )181, 
        (flex_int16_t const   )234,      (flex_int16_t const   )249,      (flex_int16_t const   )133,      (flex_int16_t const   )248, 
        (flex_int16_t const   )134,      (flex_int16_t const   )135,      (flex_int16_t const   )136,      (flex_int16_t const   )137, 
        (flex_int16_t const   )182,      (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )118, 
        (flex_int16_t const   )197,      (flex_int16_t const   )198,      (flex_int16_t const   )197,      (flex_int16_t const   )196, 
        (flex_int16_t const   )195,      (flex_int16_t const   )183,      (flex_int16_t const   )189,      (flex_int16_t const   )189, 
        (flex_int16_t const   )189,      (flex_int16_t const   )199,      (flex_int16_t const   )200,      (flex_int16_t const   )199, 
        (flex_int16_t const   )201,      (flex_int16_t const   )202,      (flex_int16_t const   )201,      (flex_int16_t const   )189, 
        (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )203,      (flex_int16_t const   )149, 
        (flex_int16_t const   )150,      (flex_int16_t const   )149,      (flex_int16_t const   )189,      (flex_int16_t const   )189, 
        (flex_int16_t const   )189,      (flex_int16_t const   )189,      (flex_int16_t const   )189,      (flex_int16_t const   )189, 
        (flex_int16_t const   )206,      (flex_int16_t const   )153,      (flex_int16_t const   )206,      (flex_int16_t const   )208, 
        (flex_int16_t const   )209,      (flex_int16_t const   )208,      (flex_int16_t const   )212,      (flex_int16_t const   )228, 
        (flex_int16_t const   )194,      (flex_int16_t const   )473,      (flex_int16_t const   )213,      (flex_int16_t const   )197, 
        (flex_int16_t const   )198,      (flex_int16_t const   )197,      (flex_int16_t const   )139,      (flex_int16_t const   )199, 
        (flex_int16_t const   )200,      (flex_int16_t const   )199,      (flex_int16_t const   )140,      (flex_int16_t const   )201, 
        (flex_int16_t const   )202,      (flex_int16_t const   )201,      (flex_int16_t const   )214,      (flex_int16_t const   )144, 
        (flex_int16_t const   )472,      (flex_int16_t const   )228,      (flex_int16_t const   )203,      (flex_int16_t const   )204, 
        (flex_int16_t const   )203,      (flex_int16_t const   )149,      (flex_int16_t const   )150,      (flex_int16_t const   )149, 
        (flex_int16_t const   )141,      (flex_int16_t const   )154,      (flex_int16_t const   )253,      (flex_int16_t const   )145, 
        (flex_int16_t const   )308,      (flex_int16_t const   )317,      (flex_int16_t const   )229,      (flex_int16_t const   )206, 
        (flex_int16_t const   )153,      (flex_int16_t const   )206,      (flex_int16_t const   )254,      (flex_int16_t const   )146, 
        (flex_int16_t const   )206,      (flex_int16_t const   )153,      (flex_int16_t const   )206,      (flex_int16_t const   )208, 
        (flex_int16_t const   )209,      (flex_int16_t const   )208,      (flex_int16_t const   )271,      (flex_int16_t const   )332, 
        (flex_int16_t const   )335,      (flex_int16_t const   )272,      (flex_int16_t const   )308,      (flex_int16_t const   )317, 
        (flex_int16_t const   )352,      (flex_int16_t const   )354,      (flex_int16_t const   )354,      (flex_int16_t const   )354, 
        (flex_int16_t const   )359,      (flex_int16_t const   )379,      (flex_int16_t const   )380,      (flex_int16_t const   )439, 
        (flex_int16_t const   )451,      (flex_int16_t const   )471,      (flex_int16_t const   )470,      (flex_int16_t const   )469, 
        (flex_int16_t const   )468,      (flex_int16_t const   )332,      (flex_int16_t const   )335,      (flex_int16_t const   )354, 
        (flex_int16_t const   )354,      (flex_int16_t const   )354,      (flex_int16_t const   )352,      (flex_int16_t const   )467, 
        (flex_int16_t const   )466,      (flex_int16_t const   )465,      (flex_int16_t const   )359,      (flex_int16_t const   )464, 
        (flex_int16_t const   )380,      (flex_int16_t const   )439,      (flex_int16_t const   )451,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )50,      (flex_int16_t const   )50, 
        (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )50, 
        (flex_int16_t const   )50,      (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )57, 
        (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )57, 
        (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )88, 
        (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )117,      (flex_int16_t const   )117, 
        (flex_int16_t const   )120,      (flex_int16_t const   )463,      (flex_int16_t const   )120,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )125,      (flex_int16_t const   )125, 
        (flex_int16_t const   )125,      (flex_int16_t const   )125,      (flex_int16_t const   )125,      (flex_int16_t const   )125, 
        (flex_int16_t const   )125,      (flex_int16_t const   )151,      (flex_int16_t const   )151,      (flex_int16_t const   )151, 
        (flex_int16_t const   )151,      (flex_int16_t const   )151,      (flex_int16_t const   )462,      (flex_int16_t const   )151, 
        (flex_int16_t const   )155,      (flex_int16_t const   )155,      (flex_int16_t const   )155,      (flex_int16_t const   )156, 
        (flex_int16_t const   )156,      (flex_int16_t const   )156,      (flex_int16_t const   )187,      (flex_int16_t const   )461, 
        (flex_int16_t const   )187,      (flex_int16_t const   )187,      (flex_int16_t const   )187,      (flex_int16_t const   )187, 
        (flex_int16_t const   )187,      (flex_int16_t const   )188,      (flex_int16_t const   )188,      (flex_int16_t const   )188, 
        (flex_int16_t const   )417,      (flex_int16_t const   )460,      (flex_int16_t const   )417,      (flex_int16_t const   )417, 
        (flex_int16_t const   )417,      (flex_int16_t const   )417,      (flex_int16_t const   )417,      (flex_int16_t const   )459, 
        (flex_int16_t const   )458,      (flex_int16_t const   )457,      (flex_int16_t const   )456,      (flex_int16_t const   )455, 
        (flex_int16_t const   )454,      (flex_int16_t const   )453,      (flex_int16_t const   )452,      (flex_int16_t const   )450, 
        (flex_int16_t const   )449,      (flex_int16_t const   )448,      (flex_int16_t const   )447,      (flex_int16_t const   )446, 
        (flex_int16_t const   )445,      (flex_int16_t const   )444,      (flex_int16_t const   )443,      (flex_int16_t const   )442, 
        (flex_int16_t const   )441,      (flex_int16_t const   )440,      (flex_int16_t const   )438,      (flex_int16_t const   )437, 
        (flex_int16_t const   )436,      (flex_int16_t const   )435,      (flex_int16_t const   )434,      (flex_int16_t const   )433, 
        (flex_int16_t const   )418,      (flex_int16_t const   )431,      (flex_int16_t const   )430,      (flex_int16_t const   )429, 
        (flex_int16_t const   )428,      (flex_int16_t const   )427,      (flex_int16_t const   )426,      (flex_int16_t const   )425, 
        (flex_int16_t const   )424,      (flex_int16_t const   )423,      (flex_int16_t const   )422,      (flex_int16_t const   )421, 
        (flex_int16_t const   )420,      (flex_int16_t const   )419,      (flex_int16_t const   )418,      (flex_int16_t const   )416, 
        (flex_int16_t const   )415,      (flex_int16_t const   )414,      (flex_int16_t const   )413,      (flex_int16_t const   )412, 
        (flex_int16_t const   )411,      (flex_int16_t const   )410,      (flex_int16_t const   )409,      (flex_int16_t const   )408, 
        (flex_int16_t const   )407,      (flex_int16_t const   )406,      (flex_int16_t const   )405,      (flex_int16_t const   )404, 
        (flex_int16_t const   )403,      (flex_int16_t const   )402,      (flex_int16_t const   )401,      (flex_int16_t const   )400, 
        (flex_int16_t const   )399,      (flex_int16_t const   )398,      (flex_int16_t const   )397,      (flex_int16_t const   )396, 
        (flex_int16_t const   )395,      (flex_int16_t const   )394,      (flex_int16_t const   )393,      (flex_int16_t const   )392, 
        (flex_int16_t const   )391,      (flex_int16_t const   )390,      (flex_int16_t const   )389,      (flex_int16_t const   )388, 
        (flex_int16_t const   )387,      (flex_int16_t const   )386,      (flex_int16_t const   )385,      (flex_int16_t const   )384, 
        (flex_int16_t const   )383,      (flex_int16_t const   )382,      (flex_int16_t const   )381,      (flex_int16_t const   )378, 
        (flex_int16_t const   )377,      (flex_int16_t const   )376,      (flex_int16_t const   )375,      (flex_int16_t const   )374, 
        (flex_int16_t const   )373,      (flex_int16_t const   )372,      (flex_int16_t const   )371,      (flex_int16_t const   )370, 
        (flex_int16_t const   )369,      (flex_int16_t const   )368,      (flex_int16_t const   )367,      (flex_int16_t const   )366, 
        (flex_int16_t const   )365,      (flex_int16_t const   )364,      (flex_int16_t const   )363,      (flex_int16_t const   )362, 
        (flex_int16_t const   )361,      (flex_int16_t const   )360,      (flex_int16_t const   )358,      (flex_int16_t const   )357, 
        (flex_int16_t const   )356,      (flex_int16_t const   )355,      (flex_int16_t const   )353,      (flex_int16_t const   )351, 
        (flex_int16_t const   )350,      (flex_int16_t const   )349,      (flex_int16_t const   )348,      (flex_int16_t const   )347, 
        (flex_int16_t const   )346,      (flex_int16_t const   )345,      (flex_int16_t const   )344,      (flex_int16_t const   )343, 
        (flex_int16_t const   )342,      (flex_int16_t const   )341,      (flex_int16_t const   )340,      (flex_int16_t const   )339, 
        (flex_int16_t const   )338,      (flex_int16_t const   )337,      (flex_int16_t const   )336,      (flex_int16_t const   )334, 
        (flex_int16_t const   )333,      (flex_int16_t const   )331,      (flex_int16_t const   )330,      (flex_int16_t const   )329, 
        (flex_int16_t const   )328,      (flex_int16_t const   )325,      (flex_int16_t const   )324,      (flex_int16_t const   )323, 
        (flex_int16_t const   )322,      (flex_int16_t const   )321,      (flex_int16_t const   )320,      (flex_int16_t const   )319, 
        (flex_int16_t const   )318,      (flex_int16_t const   )316,      (flex_int16_t const   )315,      (flex_int16_t const   )314, 
        (flex_int16_t const   )313,      (flex_int16_t const   )312,      (flex_int16_t const   )311,      (flex_int16_t const   )310, 
        (flex_int16_t const   )309,      (flex_int16_t const   )307,      (flex_int16_t const   )306,      (flex_int16_t const   )305, 
        (flex_int16_t const   )304,      (flex_int16_t const   )303,      (flex_int16_t const   )302,      (flex_int16_t const   )301, 
        (flex_int16_t const   )300,      (flex_int16_t const   )299,      (flex_int16_t const   )298,      (flex_int16_t const   )297, 
        (flex_int16_t const   )296,      (flex_int16_t const   )295,      (flex_int16_t const   )294,      (flex_int16_t const   )293, 
        (flex_int16_t const   )292,      (flex_int16_t const   )289,      (flex_int16_t const   )288,      (flex_int16_t const   )287, 
        (flex_int16_t const   )286,      (flex_int16_t const   )285,      (flex_int16_t const   )284,      (flex_int16_t const   )283, 
        (flex_int16_t const   )282,      (flex_int16_t const   )281,      (flex_int16_t const   )280,      (flex_int16_t const   )279, 
        (flex_int16_t const   )278,      (flex_int16_t const   )277,      (flex_int16_t const   )276,      (flex_int16_t const   )275, 
        (flex_int16_t const   )274,      (flex_int16_t const   )273,      (flex_int16_t const   )268,      (flex_int16_t const   )267, 
        (flex_int16_t const   )266,      (flex_int16_t const   )265,      (flex_int16_t const   )264,      (flex_int16_t const   )263, 
        (flex_int16_t const   )262,      (flex_int16_t const   )261,      (flex_int16_t const   )260,      (flex_int16_t const   )259, 
        (flex_int16_t const   )258,      (flex_int16_t const   )257,      (flex_int16_t const   )256,      (flex_int16_t const   )255, 
        (flex_int16_t const   )252,      (flex_int16_t const   )251,      (flex_int16_t const   )250,      (flex_int16_t const   )246, 
        (flex_int16_t const   )245,      (flex_int16_t const   )244,      (flex_int16_t const   )243,      (flex_int16_t const   )242, 
        (flex_int16_t const   )241,      (flex_int16_t const   )240,      (flex_int16_t const   )239,      (flex_int16_t const   )238, 
        (flex_int16_t const   )237,      (flex_int16_t const   )236,      (flex_int16_t const   )235,      (flex_int16_t const   )232, 
        (flex_int16_t const   )231,      (flex_int16_t const   )230,      (flex_int16_t const   )227,      (flex_int16_t const   )226, 
        (flex_int16_t const   )225,      (flex_int16_t const   )222,      (flex_int16_t const   )221,      (flex_int16_t const   )220, 
        (flex_int16_t const   )217,      (flex_int16_t const   )216,      (flex_int16_t const   )215,      (flex_int16_t const   )211, 
        (flex_int16_t const   )210,      (flex_int16_t const   )207,      (flex_int16_t const   )205,      (flex_int16_t const   )192, 
        (flex_int16_t const   )191,      (flex_int16_t const   )190,      (flex_int16_t const   )186,      (flex_int16_t const   )185, 
        (flex_int16_t const   )184,      (flex_int16_t const   )173,      (flex_int16_t const   )169,      (flex_int16_t const   )165, 
        (flex_int16_t const   )164,      (flex_int16_t const   )163,      (flex_int16_t const   )158,      (flex_int16_t const   )157, 
        (flex_int16_t const   )123,      (flex_int16_t const   )123,      (flex_int16_t const   )138,      (flex_int16_t const   )123, 
        (flex_int16_t const   )124,      (flex_int16_t const   )123,      (flex_int16_t const   )473,      (flex_int16_t const   )87, 
        (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )47,      (flex_int16_t const   )29, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473};
#line 795 "scan-gram.c"
static flex_int16_t const   yy_chk___0[820]  = 
#line 795
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )5, 
        (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )9, 
        (flex_int16_t const   )10,      (flex_int16_t const   )19,      (flex_int16_t const   )9,      (flex_int16_t const   )418, 
        (flex_int16_t const   )10,      (flex_int16_t const   )418,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )20,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )10, 
        (flex_int16_t const   )17,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )9, 
        (flex_int16_t const   )73,      (flex_int16_t const   )11,      (flex_int16_t const   )17,      (flex_int16_t const   )11, 
        (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )204, 
        (flex_int16_t const   )12,      (flex_int16_t const   )19,      (flex_int16_t const   )12,      (flex_int16_t const   )11, 
        (flex_int16_t const   )12,      (flex_int16_t const   )12,      (flex_int16_t const   )73,      (flex_int16_t const   )13, 
        (flex_int16_t const   )20,      (flex_int16_t const   )13,      (flex_int16_t const   )12,      (flex_int16_t const   )13, 
        (flex_int16_t const   )13,      (flex_int16_t const   )204,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )495,      (flex_int16_t const   )13,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )14,      (flex_int16_t const   )23,      (flex_int16_t const   )14,      (flex_int16_t const   )13, 
        (flex_int16_t const   )14,      (flex_int16_t const   )14,      (flex_int16_t const   )23,      (flex_int16_t const   )15, 
        (flex_int16_t const   )18,      (flex_int16_t const   )15,      (flex_int16_t const   )14,      (flex_int16_t const   )494, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )18,      (flex_int16_t const   )16, 
        (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )16, 
        (flex_int16_t const   )24,      (flex_int16_t const   )23,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )24,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )42,      (flex_int16_t const   )127,      (flex_int16_t const   )127, 
        (flex_int16_t const   )38,      (flex_int16_t const   )13,      (flex_int16_t const   )27,      (flex_int16_t const   )13, 
        (flex_int16_t const   )38,      (flex_int16_t const   )27,      (flex_int16_t const   )60,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )42,      (flex_int16_t const   )60,      (flex_int16_t const   )85, 
        (flex_int16_t const   )24,      (flex_int16_t const   )493,      (flex_int16_t const   )14,      (flex_int16_t const   )85, 
        (flex_int16_t const   )14,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )28, 
        (flex_int16_t const   )68,      (flex_int16_t const   )28,      (flex_int16_t const   )163,      (flex_int16_t const   )70, 
        (flex_int16_t const   )68,      (flex_int16_t const   )28,      (flex_int16_t const   )69,      (flex_int16_t const   )91, 
        (flex_int16_t const   )28,      (flex_int16_t const   )34,      (flex_int16_t const   )200,      (flex_int16_t const   )91, 
        (flex_int16_t const   )69,      (flex_int16_t const   )163,      (flex_int16_t const   )34,      (flex_int16_t const   )70, 
        (flex_int16_t const   )200,      (flex_int16_t const   )98,      (flex_int16_t const   )68,      (flex_int16_t const   )39, 
        (flex_int16_t const   )39,      (flex_int16_t const   )39,      (flex_int16_t const   )98,      (flex_int16_t const   )70, 
        (flex_int16_t const   )107,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )107,      (flex_int16_t const   )492,      (flex_int16_t const   )39,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )39,      (flex_int16_t const   )53,      (flex_int16_t const   )193,      (flex_int16_t const   )193, 
        (flex_int16_t const   )53,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )167,      (flex_int16_t const   )97,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )104, 
        (flex_int16_t const   )106,      (flex_int16_t const   )102,      (flex_int16_t const   )53,      (flex_int16_t const   )97, 
        (flex_int16_t const   )53,      (flex_int16_t const   )102,      (flex_int16_t const   )228,      (flex_int16_t const   )53, 
        (flex_int16_t const   )167,      (flex_int16_t const   )108,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )104,      (flex_int16_t const   )228,      (flex_int16_t const   )102,      (flex_int16_t const   )53, 
        (flex_int16_t const   )106,      (flex_int16_t const   )104,      (flex_int16_t const   )108,      (flex_int16_t const   )106, 
        (flex_int16_t const   )175,      (flex_int16_t const   )78,      (flex_int16_t const   )53,      (flex_int16_t const   )109, 
        (flex_int16_t const   )175,      (flex_int16_t const   )491,      (flex_int16_t const   )53,      (flex_int16_t const   )490, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )109,      (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )118, 
        (flex_int16_t const   )141,      (flex_int16_t const   )141,      (flex_int16_t const   )141,      (flex_int16_t const   )489, 
        (flex_int16_t const   )488,      (flex_int16_t const   )109,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )146,      (flex_int16_t const   )146,      (flex_int16_t const   )146,      (flex_int16_t const   )119, 
        (flex_int16_t const   )148,      (flex_int16_t const   )148,      (flex_int16_t const   )148,      (flex_int16_t const   )149, 
        (flex_int16_t const   )149,      (flex_int16_t const   )149,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )152,      (flex_int16_t const   )152,      (flex_int16_t const   )152,      (flex_int16_t const   )154, 
        (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )159,      (flex_int16_t const   )171, 
        (flex_int16_t const   )487,      (flex_int16_t const   )209,      (flex_int16_t const   )159,      (flex_int16_t const   )197, 
        (flex_int16_t const   )197,      (flex_int16_t const   )197,      (flex_int16_t const   )198,      (flex_int16_t const   )199, 
        (flex_int16_t const   )199,      (flex_int16_t const   )199,      (flex_int16_t const   )198,      (flex_int16_t const   )201, 
        (flex_int16_t const   )201,      (flex_int16_t const   )201,      (flex_int16_t const   )159,      (flex_int16_t const   )202, 
        (flex_int16_t const   )471,      (flex_int16_t const   )171,      (flex_int16_t const   )203,      (flex_int16_t const   )203, 
        (flex_int16_t const   )203,      (flex_int16_t const   )205,      (flex_int16_t const   )205,      (flex_int16_t const   )205, 
        (flex_int16_t const   )198,      (flex_int16_t const   )209,      (flex_int16_t const   )213,      (flex_int16_t const   )202, 
        (flex_int16_t const   )268,      (flex_int16_t const   )278,      (flex_int16_t const   )171,      (flex_int16_t const   )206, 
        (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )213,      (flex_int16_t const   )202, 
        (flex_int16_t const   )207,      (flex_int16_t const   )207,      (flex_int16_t const   )207,      (flex_int16_t const   )208, 
        (flex_int16_t const   )208,      (flex_int16_t const   )208,      (flex_int16_t const   )229,      (flex_int16_t const   )298, 
        (flex_int16_t const   )301,      (flex_int16_t const   )229,      (flex_int16_t const   )268,      (flex_int16_t const   )278, 
        (flex_int16_t const   )322,      (flex_int16_t const   )325,      (flex_int16_t const   )325,      (flex_int16_t const   )325, 
        (flex_int16_t const   )333,      (flex_int16_t const   )354,      (flex_int16_t const   )355,      (flex_int16_t const   )427, 
        (flex_int16_t const   )446,      (flex_int16_t const   )470,      (flex_int16_t const   )469,      (flex_int16_t const   )468, 
        (flex_int16_t const   )467,      (flex_int16_t const   )298,      (flex_int16_t const   )301,      (flex_int16_t const   )354, 
        (flex_int16_t const   )354,      (flex_int16_t const   )354,      (flex_int16_t const   )322,      (flex_int16_t const   )465, 
        (flex_int16_t const   )464,      (flex_int16_t const   )463,      (flex_int16_t const   )333,      (flex_int16_t const   )462, 
        (flex_int16_t const   )355,      (flex_int16_t const   )427,      (flex_int16_t const   )446,      (flex_int16_t const   )474, 
        (flex_int16_t const   )474,      (flex_int16_t const   )474,      (flex_int16_t const   )474,      (flex_int16_t const   )474, 
        (flex_int16_t const   )474,      (flex_int16_t const   )474,      (flex_int16_t const   )475,      (flex_int16_t const   )475, 
        (flex_int16_t const   )475,      (flex_int16_t const   )475,      (flex_int16_t const   )475,      (flex_int16_t const   )475, 
        (flex_int16_t const   )475,      (flex_int16_t const   )476,      (flex_int16_t const   )476,      (flex_int16_t const   )476, 
        (flex_int16_t const   )476,      (flex_int16_t const   )476,      (flex_int16_t const   )476,      (flex_int16_t const   )476, 
        (flex_int16_t const   )477,      (flex_int16_t const   )477,      (flex_int16_t const   )477,      (flex_int16_t const   )477, 
        (flex_int16_t const   )477,      (flex_int16_t const   )477,      (flex_int16_t const   )477,      (flex_int16_t const   )478, 
        (flex_int16_t const   )478,      (flex_int16_t const   )478,      (flex_int16_t const   )479,      (flex_int16_t const   )479, 
        (flex_int16_t const   )480,      (flex_int16_t const   )461,      (flex_int16_t const   )480,      (flex_int16_t const   )480, 
        (flex_int16_t const   )480,      (flex_int16_t const   )480,      (flex_int16_t const   )481,      (flex_int16_t const   )481, 
        (flex_int16_t const   )481,      (flex_int16_t const   )481,      (flex_int16_t const   )481,      (flex_int16_t const   )481, 
        (flex_int16_t const   )481,      (flex_int16_t const   )482,      (flex_int16_t const   )482,      (flex_int16_t const   )482, 
        (flex_int16_t const   )482,      (flex_int16_t const   )482,      (flex_int16_t const   )459,      (flex_int16_t const   )482, 
        (flex_int16_t const   )483,      (flex_int16_t const   )483,      (flex_int16_t const   )483,      (flex_int16_t const   )484, 
        (flex_int16_t const   )484,      (flex_int16_t const   )484,      (flex_int16_t const   )485,      (flex_int16_t const   )458, 
        (flex_int16_t const   )485,      (flex_int16_t const   )485,      (flex_int16_t const   )485,      (flex_int16_t const   )485, 
        (flex_int16_t const   )485,      (flex_int16_t const   )486,      (flex_int16_t const   )486,      (flex_int16_t const   )486, 
        (flex_int16_t const   )496,      (flex_int16_t const   )457,      (flex_int16_t const   )496,      (flex_int16_t const   )496, 
        (flex_int16_t const   )496,      (flex_int16_t const   )496,      (flex_int16_t const   )496,      (flex_int16_t const   )455, 
        (flex_int16_t const   )454,      (flex_int16_t const   )453,      (flex_int16_t const   )452,      (flex_int16_t const   )451, 
        (flex_int16_t const   )449,      (flex_int16_t const   )448,      (flex_int16_t const   )447,      (flex_int16_t const   )445, 
        (flex_int16_t const   )440,      (flex_int16_t const   )439,      (flex_int16_t const   )437,      (flex_int16_t const   )436, 
        (flex_int16_t const   )434,      (flex_int16_t const   )433,      (flex_int16_t const   )431,      (flex_int16_t const   )430, 
        (flex_int16_t const   )429,      (flex_int16_t const   )428,      (flex_int16_t const   )426,      (flex_int16_t const   )425, 
        (flex_int16_t const   )423,      (flex_int16_t const   )422,      (flex_int16_t const   )421,      (flex_int16_t const   )419, 
        (flex_int16_t const   )417,      (flex_int16_t const   )416,      (flex_int16_t const   )415,      (flex_int16_t const   )414, 
        (flex_int16_t const   )413,      (flex_int16_t const   )412,      (flex_int16_t const   )411,      (flex_int16_t const   )408, 
        (flex_int16_t const   )407,      (flex_int16_t const   )406,      (flex_int16_t const   )405,      (flex_int16_t const   )403, 
        (flex_int16_t const   )402,      (flex_int16_t const   )401,      (flex_int16_t const   )400,      (flex_int16_t const   )399, 
        (flex_int16_t const   )397,      (flex_int16_t const   )396,      (flex_int16_t const   )395,      (flex_int16_t const   )392, 
        (flex_int16_t const   )391,      (flex_int16_t const   )390,      (flex_int16_t const   )389,      (flex_int16_t const   )387, 
        (flex_int16_t const   )386,      (flex_int16_t const   )385,      (flex_int16_t const   )384,      (flex_int16_t const   )383, 
        (flex_int16_t const   )382,      (flex_int16_t const   )381,      (flex_int16_t const   )380,      (flex_int16_t const   )379, 
        (flex_int16_t const   )377,      (flex_int16_t const   )376,      (flex_int16_t const   )374,      (flex_int16_t const   )372, 
        (flex_int16_t const   )371,      (flex_int16_t const   )370,      (flex_int16_t const   )369,      (flex_int16_t const   )368, 
        (flex_int16_t const   )367,      (flex_int16_t const   )366,      (flex_int16_t const   )365,      (flex_int16_t const   )364, 
        (flex_int16_t const   )363,      (flex_int16_t const   )362,      (flex_int16_t const   )361,      (flex_int16_t const   )360, 
        (flex_int16_t const   )359,      (flex_int16_t const   )358,      (flex_int16_t const   )357,      (flex_int16_t const   )353, 
        (flex_int16_t const   )352,      (flex_int16_t const   )351,      (flex_int16_t const   )350,      (flex_int16_t const   )349, 
        (flex_int16_t const   )348,      (flex_int16_t const   )347,      (flex_int16_t const   )345,      (flex_int16_t const   )344, 
        (flex_int16_t const   )343,      (flex_int16_t const   )342,      (flex_int16_t const   )341,      (flex_int16_t const   )340, 
        (flex_int16_t const   )339,      (flex_int16_t const   )338,      (flex_int16_t const   )337,      (flex_int16_t const   )336, 
        (flex_int16_t const   )335,      (flex_int16_t const   )334,      (flex_int16_t const   )332,      (flex_int16_t const   )331, 
        (flex_int16_t const   )330,      (flex_int16_t const   )329,      (flex_int16_t const   )324,      (flex_int16_t const   )320, 
        (flex_int16_t const   )318,      (flex_int16_t const   )317,      (flex_int16_t const   )316,      (flex_int16_t const   )315, 
        (flex_int16_t const   )314,      (flex_int16_t const   )312,      (flex_int16_t const   )311,      (flex_int16_t const   )310, 
        (flex_int16_t const   )309,      (flex_int16_t const   )308,      (flex_int16_t const   )306,      (flex_int16_t const   )305, 
        (flex_int16_t const   )304,      (flex_int16_t const   )303,      (flex_int16_t const   )302,      (flex_int16_t const   )300, 
        (flex_int16_t const   )299,      (flex_int16_t const   )296,      (flex_int16_t const   )295,      (flex_int16_t const   )294, 
        (flex_int16_t const   )292,      (flex_int16_t const   )289,      (flex_int16_t const   )287,      (flex_int16_t const   )286, 
        (flex_int16_t const   )284,      (flex_int16_t const   )282,      (flex_int16_t const   )281,      (flex_int16_t const   )280, 
        (flex_int16_t const   )279,      (flex_int16_t const   )277,      (flex_int16_t const   )275,      (flex_int16_t const   )274, 
        (flex_int16_t const   )273,      (flex_int16_t const   )272,      (flex_int16_t const   )271,      (flex_int16_t const   )270, 
        (flex_int16_t const   )269,      (flex_int16_t const   )267,      (flex_int16_t const   )266,      (flex_int16_t const   )265, 
        (flex_int16_t const   )263,      (flex_int16_t const   )262,      (flex_int16_t const   )261,      (flex_int16_t const   )260, 
        (flex_int16_t const   )259,      (flex_int16_t const   )258,      (flex_int16_t const   )257,      (flex_int16_t const   )256, 
        (flex_int16_t const   )255,      (flex_int16_t const   )254,      (flex_int16_t const   )253,      (flex_int16_t const   )252, 
        (flex_int16_t const   )250,      (flex_int16_t const   )246,      (flex_int16_t const   )245,      (flex_int16_t const   )244, 
        (flex_int16_t const   )243,      (flex_int16_t const   )242,      (flex_int16_t const   )241,      (flex_int16_t const   )240, 
        (flex_int16_t const   )239,      (flex_int16_t const   )238,      (flex_int16_t const   )237,      (flex_int16_t const   )236, 
        (flex_int16_t const   )235,      (flex_int16_t const   )234,      (flex_int16_t const   )233,      (flex_int16_t const   )232, 
        (flex_int16_t const   )231,      (flex_int16_t const   )230,      (flex_int16_t const   )227,      (flex_int16_t const   )226, 
        (flex_int16_t const   )225,      (flex_int16_t const   )224,      (flex_int16_t const   )223,      (flex_int16_t const   )222, 
        (flex_int16_t const   )221,      (flex_int16_t const   )220,      (flex_int16_t const   )219,      (flex_int16_t const   )218, 
        (flex_int16_t const   )217,      (flex_int16_t const   )216,      (flex_int16_t const   )215,      (flex_int16_t const   )214, 
        (flex_int16_t const   )212,      (flex_int16_t const   )211,      (flex_int16_t const   )210,      (flex_int16_t const   )192, 
        (flex_int16_t const   )186,      (flex_int16_t const   )185,      (flex_int16_t const   )184,      (flex_int16_t const   )183, 
        (flex_int16_t const   )182,      (flex_int16_t const   )181,      (flex_int16_t const   )180,      (flex_int16_t const   )179, 
        (flex_int16_t const   )178,      (flex_int16_t const   )177,      (flex_int16_t const   )176,      (flex_int16_t const   )174, 
        (flex_int16_t const   )173,      (flex_int16_t const   )172,      (flex_int16_t const   )170,      (flex_int16_t const   )169, 
        (flex_int16_t const   )168,      (flex_int16_t const   )166,      (flex_int16_t const   )165,      (flex_int16_t const   )164, 
        (flex_int16_t const   )162,      (flex_int16_t const   )161,      (flex_int16_t const   )160,      (flex_int16_t const   )158, 
        (flex_int16_t const   )157,      (flex_int16_t const   )153,      (flex_int16_t const   )150,      (flex_int16_t const   )123, 
        (flex_int16_t const   )121,      (flex_int16_t const   )120,      (flex_int16_t const   )112,      (flex_int16_t const   )111, 
        (flex_int16_t const   )110,      (flex_int16_t const   )105,      (flex_int16_t const   )103,      (flex_int16_t const   )101, 
        (flex_int16_t const   )100,      (flex_int16_t const   )99,      (flex_int16_t const   )96,      (flex_int16_t const   )95, 
        (flex_int16_t const   )92,      (flex_int16_t const   )87,      (flex_int16_t const   )66,      (flex_int16_t const   )63, 
        (flex_int16_t const   )49,      (flex_int16_t const   )47,      (flex_int16_t const   )29,      (flex_int16_t const   )26, 
        (flex_int16_t const   )4,      (flex_int16_t const   )3,      (flex_int16_t const   )2,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473, 
        (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473,      (flex_int16_t const   )473};
#line 889 "scan-gram.c"
static yy_state_type yy_last_accepting_state___0  ;
#line 890 "scan-gram.c"
static char *yy_last_accepting_cpos___0  ;
#line 892
int gram__flex_debug ;
#line 893 "scan-gram.c"
int gram__flex_debug  =    1;
#line 895 "scan-gram.c"
static flex_int16_t const   yy_rule_linenum___0[109]  = 
#line 895
  {      (flex_int16_t const   )0,      (flex_int16_t const   )149,      (flex_int16_t const   )150,      (flex_int16_t const   )151, 
        (flex_int16_t const   )152,      (flex_int16_t const   )160,      (flex_int16_t const   )178,      (flex_int16_t const   )179, 
        (flex_int16_t const   )180,      (flex_int16_t const   )181,      (flex_int16_t const   )182,      (flex_int16_t const   )183, 
        (flex_int16_t const   )184,      (flex_int16_t const   )185,      (flex_int16_t const   )186,      (flex_int16_t const   )187, 
        (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )190,      (flex_int16_t const   )191, 
        (flex_int16_t const   )192,      (flex_int16_t const   )193,      (flex_int16_t const   )194,      (flex_int16_t const   )195, 
        (flex_int16_t const   )196,      (flex_int16_t const   )197,      (flex_int16_t const   )198,      (flex_int16_t const   )199, 
        (flex_int16_t const   )200,      (flex_int16_t const   )201,      (flex_int16_t const   )202,      (flex_int16_t const   )203, 
        (flex_int16_t const   )204,      (flex_int16_t const   )205,      (flex_int16_t const   )206,      (flex_int16_t const   )207, 
        (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )210,      (flex_int16_t const   )211, 
        (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )214,      (flex_int16_t const   )215, 
        (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )219, 
        (flex_int16_t const   )221,      (flex_int16_t const   )225,      (flex_int16_t const   )226,      (flex_int16_t const   )227, 
        (flex_int16_t const   )228,      (flex_int16_t const   )229,      (flex_int16_t const   )231,      (flex_int16_t const   )238, 
        (flex_int16_t const   )242,      (flex_int16_t const   )249,      (flex_int16_t const   )254,      (flex_int16_t const   )257, 
        (flex_int16_t const   )260,      (flex_int16_t const   )263,      (flex_int16_t const   )271,      (flex_int16_t const   )279, 
        (flex_int16_t const   )286,      (flex_int16_t const   )293,      (flex_int16_t const   )310,      (flex_int16_t const   )325, 
        (flex_int16_t const   )330,      (flex_int16_t const   )349,      (flex_int16_t const   )361,      (flex_int16_t const   )376, 
        (flex_int16_t const   )388,      (flex_int16_t const   )405,      (flex_int16_t const   )406,      (flex_int16_t const   )417, 
        (flex_int16_t const   )428,      (flex_int16_t const   )429,      (flex_int16_t const   )441,      (flex_int16_t const   )467, 
        (flex_int16_t const   )512,      (flex_int16_t const   )522,      (flex_int16_t const   )531,      (flex_int16_t const   )541, 
        (flex_int16_t const   )542,      (flex_int16_t const   )543,      (flex_int16_t const   )544,      (flex_int16_t const   )545, 
        (flex_int16_t const   )546,      (flex_int16_t const   )547,      (flex_int16_t const   )550,      (flex_int16_t const   )552, 
        (flex_int16_t const   )560,      (flex_int16_t const   )577,      (flex_int16_t const   )582,      (flex_int16_t const   )583, 
        (flex_int16_t const   )589,      (flex_int16_t const   )590,      (flex_int16_t const   )601,      (flex_int16_t const   )607, 
        (flex_int16_t const   )613,      (flex_int16_t const   )619,      (flex_int16_t const   )635,      (flex_int16_t const   )636, 
        (flex_int16_t const   )637,      (flex_int16_t const   )653,      (flex_int16_t const   )672,      (flex_int16_t const   )712, 
        (flex_int16_t const   )713};
#line 25 "/home/pronto/abs/test-suite/bison-2.5/src/flex-scanner.h"
int gram_get_lineno(void) ;
#line 26
FILE *gram_get_in(void) ;
#line 27
FILE *gram_get_out(void) ;
#line 28
int gram_get_leng(void) ;
#line 29
char *gram_get_text(void) ;
#line 30
void gram_set_lineno(int line_number ) ;
#line 31
void gram_set_in(FILE *in_str ) ;
#line 32
void gram_set_out(FILE *out_str ) ;
#line 33
int gram_get_debug(void) ;
#line 34
void gram_set_debug(int bdebug ) ;
#line 35
int gram_lex_destroy(void) ;
#line 74 "/home/pronto/abs/test-suite/bison-2.5/src/flex-scanner.h"
static struct obstack obstack_for_string___0  ;
#line 50 "/home/pronto/abs/test-suite/bison-2.5/src/location.h"
__inline static void boundary_set(boundary *b , char const   *f , int l , int c ) 
{ 


  {
#line 53
  b->file = f;
#line 54
  b->line = l;
#line 55
  b->column = c;
#line 56
  return;
}
}
#line 94
struct __anonstruct_location_36  const  empty_location ;
#line 98
void location_compute(location *loc___0 , boundary *cur , char const   *token , size_t size ) ;
#line 59 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
uniqstr current_file ;
#line 26 "/home/pronto/abs/test-suite/bison-2.5/src/scan-gram.h"
void gram_scanner_initialize(void) ;
#line 27
void gram_scanner_free(void) ;
#line 28
void gram_scanner_last_string_free(void) ;
#line 36
int gram_lex(YYSTYPE *val , location *loc___0 ) ;
#line 51 "scan-gram.l"
static boundary scanner_cursor  ;
#line 55
static size_t no_cr_read(FILE *fp , char *buf___0 , size_t size ) ;
#line 65 "scan-gram.l"
static char *gram_last_string  ;
#line 68 "scan-gram.l"
static uniqstr bracketed_id_str  =    (uniqstr )0;
#line 69 "scan-gram.l"
static location bracketed_id_loc  ;
#line 70 "scan-gram.l"
static boundary bracketed_id_start  ;
#line 71 "scan-gram.l"
static int bracketed_id_context_state  =    0;
#line 73 "scan-gram.l"
void gram_scanner_last_string_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 76
  __o = & obstack_for_string___0;
#line 76
  __obj = (void *)gram_last_string;
#line 76
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 76
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 76
      tmp = (char *)__obj;
#line 76
      __o->object_base = tmp;
#line 76
      __o->next_free = tmp;
    } else {
      {
#line 76
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 76
    obstack_free(__o, __obj);
    }
  }
#line 77
  return;
}
}
#line 79
static void handle_syncline(char *args , location loc___0 ) ;
#line 80
static unsigned long scan_integer(char const   *number , int base___0 , location loc___0 ) ;
#line 81
static int convert_ucn_to_byte(char const   *ucn ) ;
#line 82
static void unexpected_eof(boundary start , char const   *token_end ) ;
#line 83
static void unexpected_newline(boundary start , char const   *token_end ) ;
#line 1061 "scan-gram.c"
static int yy_init_globals___0(void) ;
#line 280 "scan-gram.l"
static int percent_percent_count  ;
#line 1278 "scan-gram.c"
int gram_lex(YYSTYPE *val , location *loc___0 ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  int braces_level ;
  int context_state ;
  location id_loc ;
  boundary code_start ;
  boundary token_start ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o___1 ;
  char *tmp___7 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___8 ;
  char *tmp___9 ;
  struct obstack *__o___2 ;
  void *__obj ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  boundary tmp___13 ;
  int tmp___14 ;
  int yyless_macro_arg ;
  int tmp___15 ;
  int tmp___16 ;
  int yyless_macro_arg___0 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int yyless_macro_arg___1 ;
  struct obstack *__o___3 ;
  int __len___1 ;
  struct obstack *__o___4 ;
  int __len___2 ;
  struct obstack *__o___5 ;
  int __len___3 ;
  struct obstack *__o___6 ;
  char *tmp___25 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___26 ;
  char *tmp___27 ;
  struct obstack *__o___7 ;
  char *tmp___28 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___29 ;
  char *tmp___30 ;
  struct obstack *__o___8 ;
  char *tmp___31 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  struct obstack *__o___9 ;
  void *__obj___0 ;
  char *tmp___36 ;
  struct obstack *__o___10 ;
  char *tmp___37 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  struct obstack *__o___11 ;
  void *__obj___1 ;
  char *tmp___42 ;
  char *tmp___43 ;
  unsigned long c ;
  unsigned long tmp___44 ;
  char *tmp___45 ;
  struct obstack *__o___12 ;
  char *tmp___46 ;
  unsigned long c___0 ;
  unsigned long tmp___47 ;
  char *tmp___48 ;
  struct obstack *__o___13 ;
  char *tmp___49 ;
  struct obstack *__o___14 ;
  char *tmp___50 ;
  struct obstack *__o___15 ;
  char *tmp___51 ;
  struct obstack *__o___16 ;
  char *tmp___52 ;
  struct obstack *__o___17 ;
  char *tmp___53 ;
  struct obstack *__o___18 ;
  char *tmp___54 ;
  struct obstack *__o___19 ;
  char *tmp___55 ;
  struct obstack *__o___20 ;
  char *tmp___56 ;
  struct obstack *__o___21 ;
  char *tmp___57 ;
  int c___1 ;
  int tmp___58 ;
  char *tmp___59 ;
  struct obstack *__o___22 ;
  char *tmp___60 ;
  char const   *p ;
  char *tmp___61 ;
  unsigned short const   **tmp___62 ;
  unsigned short const   **tmp___63 ;
  char *tmp___64 ;
  struct obstack *__o___23 ;
  int __len___4 ;
  struct obstack *__o___24 ;
  int __len___5 ;
  struct obstack *__o___25 ;
  int __len___6 ;
  struct obstack *__o___26 ;
  int __len___7 ;
  struct obstack *__o___27 ;
  int __len___8 ;
  struct obstack *__o___28 ;
  int __len___9 ;
  struct obstack *__o___29 ;
  int __len___10 ;
  struct obstack *__o___30 ;
  int __len___11 ;
  struct obstack *__o___31 ;
  int __len___12 ;
  struct obstack *__o___32 ;
  char *tmp___65 ;
  struct obstack *__o___33 ;
  char *tmp___66 ;
  struct obstack *__o1___4 ;
  void *__value___4 ;
  char *tmp___67 ;
  char *tmp___68 ;
  struct obstack *__o___34 ;
  int __len___13 ;
  struct obstack *__o___35 ;
  char *tmp___69 ;
  struct obstack *__o1___5 ;
  void *__value___5 ;
  char *tmp___70 ;
  char *tmp___71 ;
  struct obstack *__o___36 ;
  char *tmp___72 ;
  struct obstack *__o1___6 ;
  void *__value___6 ;
  char *tmp___73 ;
  char *tmp___74 ;
  struct obstack *__o___37 ;
  char *tmp___75 ;
  struct obstack *__o1___7 ;
  void *__value___7 ;
  char *tmp___76 ;
  char *tmp___77 ;
  struct obstack *__o___38 ;
  char *tmp___78 ;
  struct obstack *__o1___8 ;
  void *__value___8 ;
  char *tmp___79 ;
  char *tmp___80 ;
  struct obstack *__o___39 ;
  int __len___14 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___81 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;

  {
#line 123 "scan-gram.l"
  braces_level = 0;
#line 126
  context_state = 0;
#line 129
  id_loc = empty_location;
#line 134
  code_start = scanner_cursor;
#line 138
  token_start = scanner_cursor;
#line 1314
  if (! yy_init___0) {
#line 1316 "scan-gram.c"
    yy_init___0 = 1;
#line 1319
    scanner_cursor = loc___0->start;
#line 1319
    code_start = scanner_cursor;
#line 1322
    if (! yy_start___0) {
#line 1323
      yy_start___0 = 1;
    }
#line 1325
    if (! gram_in) {
#line 1327
      gram_in = stdin;
    }
#line 1332
    if (! gram_out) {
#line 1334
      gram_out = stdout;
    }
#line 1339
    if (yy_buffer_stack___0) {
#line 1339
      tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
    } else {
#line 1339
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1339
    if (! tmp) {
      {
#line 1340
      gram_ensure_buffer_stack();
#line 1341
      *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = gram__create_buffer(gram_in,
                                                                             16384);
      }
    }
    {
#line 1345
    gram__load_buffer_state();
    }
  }
  {
#line 1348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1351
    yy_cp = yy_c_buf_p___0;
#line 1354
    *yy_cp = yy_hold_char___0;
#line 1359
    yy_bp = yy_cp;
#line 1362
    yy_current_state = yy_start___0;
#line 1363
    yy_current_state += (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol;
    yy_match: 
    {
#line 1365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1367
      yy_c = (YY_CHAR )yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
#line 1368
      if (yy_accept___0[yy_current_state]) {
#line 1370
        yy_last_accepting_state___0 = yy_current_state;
#line 1371
        yy_last_accepting_cpos___0 = yy_cp;
      }
      {
#line 1373
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1373
        if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1373
          goto while_break___1;
        }
#line 1375
        yy_current_state = (int )yy_def___0[yy_current_state];
#line 1376
        if (yy_current_state >= 474) {
#line 1377
          yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1379
      yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1380
      yy_cp ++;
#line 1365
      if (! (yy_current_state != 473)) {
#line 1365
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1383
    yy_cp = yy_last_accepting_cpos___0;
#line 1384
    yy_current_state = yy_last_accepting_state___0;
    yy_find_action: 
#line 1388
    yy_act = (int )yy_accept___0[yy_current_state];
#line 1390
    gram_text = yy_bp;
#line 1390
    gram_leng = (int )((size_t )(yy_cp - yy_bp));
#line 1390
    yy_hold_char___0 = *yy_cp;
#line 1390
    *yy_cp = (char )'\000';
#line 1390
    yy_c_buf_p___0 = yy_cp;
    do_action: 
#line 1397
    if (gram__flex_debug) {
#line 1399
      if (yy_act == 0) {
        {
#line 1400
        rpl_fprintf(stderr, "--scanner backing up\n");
        }
      } else
#line 1401
      if (yy_act < 109) {
        {
#line 1402
        rpl_fprintf(stderr, "--accepting rule at line %ld (\"%s\")\n", (long )yy_rule_linenum___0[yy_act],
                    gram_text);
        }
      } else
#line 1404
      if (yy_act == 109) {
        {
#line 1405
        rpl_fprintf(stderr, "--accepting default rule (\"%s\")\n", gram_text);
        }
      } else
#line 1407
      if (yy_act == 110) {
        {
#line 1408
        rpl_fprintf(stderr, "--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 1410
        rpl_fprintf(stderr, "--EOF (start condition %d)\n", (yy_start___0 - 1) / 2);
        }
      }
    }
    {
#line 1416
    if (yy_act == 0) {
#line 1416
      goto case_0;
    }
#line 1424
    if (yy_act == 1) {
#line 1424
      goto case_1;
    }
#line 151
    if (yy_act == 3) {
#line 151 "scan-gram.l"
      goto case_3;
    }
#line 151
    if (yy_act == 2) {
#line 151
      goto case_3;
    }
#line 153
    if (yy_act == 4) {
#line 153
      goto case_4;
    }
#line 160
    if (yy_act == 5) {
#line 160
      goto case_5;
    }
#line 175
    if (yy_act == 6) {
#line 175
      goto case_6;
    }
#line 180
    if (yy_act == 7) {
#line 180
      goto case_7;
    }
#line 181
    if (yy_act == 8) {
#line 181
      goto case_8;
    }
#line 182
    if (yy_act == 9) {
#line 182
      goto case_9;
    }
#line 183
    if (yy_act == 10) {
#line 183
      goto case_10;
    }
#line 184
    if (yy_act == 11) {
#line 184
      goto case_11;
    }
#line 185
    if (yy_act == 12) {
#line 185
      goto case_12;
    }
#line 186
    if (yy_act == 13) {
#line 186
      goto case_13;
    }
#line 187
    if (yy_act == 14) {
#line 187
      goto case_14;
    }
#line 188
    if (yy_act == 15) {
#line 188
      goto case_15;
    }
#line 189
    if (yy_act == 16) {
#line 189
      goto case_16;
    }
#line 190
    if (yy_act == 17) {
#line 190
      goto case_17;
    }
#line 191
    if (yy_act == 18) {
#line 191
      goto case_18;
    }
#line 192
    if (yy_act == 19) {
#line 192
      goto case_19;
    }
#line 193
    if (yy_act == 20) {
#line 193
      goto case_20;
    }
#line 194
    if (yy_act == 21) {
#line 194
      goto case_21;
    }
#line 195
    if (yy_act == 22) {
#line 195
      goto case_22;
    }
#line 196
    if (yy_act == 23) {
#line 196
      goto case_23;
    }
#line 197
    if (yy_act == 24) {
#line 197
      goto case_24;
    }
#line 198
    if (yy_act == 25) {
#line 198
      goto case_25;
    }
#line 199
    if (yy_act == 26) {
#line 199
      goto case_26;
    }
#line 200
    if (yy_act == 27) {
#line 200
      goto case_27;
    }
#line 201
    if (yy_act == 28) {
#line 201
      goto case_28;
    }
#line 202
    if (yy_act == 29) {
#line 202
      goto case_29;
    }
#line 203
    if (yy_act == 30) {
#line 203
      goto case_30;
    }
#line 204
    if (yy_act == 31) {
#line 204
      goto case_31;
    }
#line 205
    if (yy_act == 32) {
#line 205
      goto case_32;
    }
#line 206
    if (yy_act == 33) {
#line 206
      goto case_33;
    }
#line 207
    if (yy_act == 34) {
#line 207
      goto case_34;
    }
#line 208
    if (yy_act == 35) {
#line 208
      goto case_35;
    }
#line 209
    if (yy_act == 36) {
#line 209
      goto case_36;
    }
#line 210
    if (yy_act == 37) {
#line 210
      goto case_37;
    }
#line 211
    if (yy_act == 38) {
#line 211
      goto case_38;
    }
#line 212
    if (yy_act == 39) {
#line 212
      goto case_39;
    }
#line 213
    if (yy_act == 40) {
#line 213
      goto case_40;
    }
#line 214
    if (yy_act == 41) {
#line 214
      goto case_41;
    }
#line 215
    if (yy_act == 42) {
#line 215
      goto case_42;
    }
#line 216
    if (yy_act == 43) {
#line 216
      goto case_43;
    }
#line 217
    if (yy_act == 44) {
#line 217
      goto case_44;
    }
#line 218
    if (yy_act == 45) {
#line 218
      goto case_45;
    }
#line 219
    if (yy_act == 46) {
#line 219
      goto case_46;
    }
#line 220
    if (yy_act == 47) {
#line 220
      goto case_47;
    }
#line 221
    if (yy_act == 48) {
#line 221
      goto case_48;
    }
#line 225
    if (yy_act == 49) {
#line 225
      goto case_49;
    }
#line 227
    if (yy_act == 50) {
#line 227
      goto case_50;
    }
#line 228
    if (yy_act == 51) {
#line 228
      goto case_51;
    }
#line 229
    if (yy_act == 52) {
#line 229
      goto case_52;
    }
#line 230
    if (yy_act == 53) {
#line 230
      goto case_53;
    }
#line 231
    if (yy_act == 54) {
#line 231
      goto case_54;
    }
#line 238
    if (yy_act == 55) {
#line 238
      goto case_55;
    }
#line 243
    if (yy_act == 56) {
#line 243
      goto case_56;
    }
#line 249
    if (yy_act == 57) {
#line 249
      goto case_57;
    }
#line 254
    if (yy_act == 58) {
#line 254
      goto case_58;
    }
#line 257
    if (yy_act == 59) {
#line 257
      goto case_59;
    }
#line 260
    if (yy_act == 60) {
#line 260
      goto case_60;
    }
#line 263
    if (yy_act == 61) {
#line 263
      goto case_61;
    }
#line 271
    if (yy_act == 62) {
#line 271
      goto case_62;
    }
#line 279
    if (yy_act == 63) {
#line 279
      goto case_63;
    }
#line 286
    if (yy_act == 64) {
#line 286
      goto case_64;
    }
#line 293
    if (yy_act == 65) {
#line 293
      goto case_65;
    }
#line 297
    if (yy_act == 111) {
#line 297
      goto case_111;
    }
#line 308
    if (yy_act == 66) {
#line 308
      goto case_66;
    }
#line 326
    if (yy_act == 67) {
#line 326
      goto case_67;
    }
#line 331
    if (yy_act == 68) {
#line 331
      goto case_68;
    }
#line 337
    if (yy_act == 115) {
#line 337
      goto case_115;
    }
#line 348
    if (yy_act == 69) {
#line 348
      goto case_69;
    }
#line 362
    if (yy_act == 70) {
#line 362
      goto case_70;
    }
#line 377
    if (yy_act == 71) {
#line 377
      goto case_71;
    }
#line 381
    if (yy_act == 123) {
#line 381
      goto case_123;
    }
#line 388
    if (yy_act == 72) {
#line 388
      goto case_72;
    }
#line 403
    if (yy_act == 73) {
#line 403
      goto case_73;
    }
#line 407
    if (yy_act == 74) {
#line 407
      goto case_74;
    }
#line 408
    if (yy_act == 112) {
#line 408
      goto case_112;
    }
#line 415
    if (yy_act == 75) {
#line 415
      goto case_75;
    }
#line 419
    if (yy_act == 119) {
#line 419
      goto case_119;
    }
#line 426
    if (yy_act == 76) {
#line 426
      goto case_76;
    }
#line 430
    if (yy_act == 77) {
#line 430
      goto case_77;
    }
#line 431
    if (yy_act == 120) {
#line 431
      goto case_120;
    }
#line 439
    if (yy_act == 78) {
#line 439
      goto case_78;
    }
#line 451
    if (yy_act == 113) {
#line 451
      goto case_113;
    }
#line 466
    if (yy_act == 79) {
#line 466
      goto case_79;
    }
#line 489
    if (yy_act == 114) {
#line 489
      goto case_114;
    }
#line 512
    if (yy_act == 80) {
#line 512
      goto case_80;
    }
#line 520
    if (yy_act == 81) {
#line 520
      goto case_81;
    }
#line 531
    if (yy_act == 82) {
#line 531
      goto case_82;
    }
#line 541
    if (yy_act == 83) {
#line 541
      goto case_83;
    }
#line 543
    if (yy_act == 84) {
#line 543
      goto case_84;
    }
#line 544
    if (yy_act == 85) {
#line 544
      goto case_85;
    }
#line 545
    if (yy_act == 86) {
#line 545
      goto case_86;
    }
#line 546
    if (yy_act == 87) {
#line 546
      goto case_87;
    }
#line 547
    if (yy_act == 88) {
#line 547
      goto case_88;
    }
#line 548
    if (yy_act == 89) {
#line 548
      goto case_89;
    }
#line 550
    if (yy_act == 90) {
#line 550
      goto case_90;
    }
#line 552
    if (yy_act == 91) {
#line 552
      goto case_91;
    }
#line 561
    if (yy_act == 92) {
#line 561
      goto case_92;
    }
#line 576
    if (yy_act == 93) {
#line 576
      goto case_93;
    }
#line 582
    if (yy_act == 94) {
#line 582
      goto case_94;
    }
#line 584
    if (yy_act == 95) {
#line 584
      goto case_95;
    }
#line 585
    if (yy_act == 122) {
#line 585
      goto case_122;
    }
#line 589
    if (yy_act == 96) {
#line 589
      goto case_96;
    }
#line 591
    if (yy_act == 97) {
#line 591
      goto case_97;
    }
#line 592
    if (yy_act == 121) {
#line 592
      goto case_121;
    }
#line 599
    if (yy_act == 98) {
#line 599
      goto case_98;
    }
#line 608
    if (yy_act == 99) {
#line 608
      goto case_99;
    }
#line 614
    if (yy_act == 100) {
#line 614
      goto case_100;
    }
#line 620
    if (yy_act == 101) {
#line 620
      goto case_101;
    }
#line 632
    if (yy_act == 102) {
#line 632
      goto case_102;
    }
#line 637
    if (yy_act == 103) {
#line 637
      goto case_103;
    }
#line 638
    if (yy_act == 104) {
#line 638
      goto case_104;
    }
#line 653
    if (yy_act == 105) {
#line 653
      goto case_105;
    }
#line 655
    if (yy_act == 117) {
#line 655
      goto case_117;
    }
#line 670
    if (yy_act == 106) {
#line 670
      goto case_106;
    }
#line 680
    if (yy_act == 116) {
#line 680
      goto case_116;
    }
#line 696
    if (yy_act == 118) {
#line 696
      goto case_118;
    }
#line 713
    if (yy_act == 108) {
#line 713
      goto case_108;
    }
#line 713
    if (yy_act == 107) {
#line 713
      goto case_108;
    }
#line 715
    if (yy_act == 109) {
#line 715
      goto case_109;
    }
#line 2409
    if (yy_act == 124) {
#line 2409 "scan-gram.c"
      goto case_124;
    }
#line 2412
    if (yy_act == 110) {
#line 2412
      goto case_110;
    }
#line 2536
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1418
    *yy_cp = yy_hold_char___0;
#line 1419
    yy_cp = yy_last_accepting_cpos___0;
#line 1420
    yy_current_state = yy_last_accepting_state___0;
#line 1421
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 1425
    if (gram_leng > 0) {
#line 1425
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 1425
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 149 "scan-gram.l"
    tmp___0 = gettext("stray `,\' treated as white space");
#line 149
    warn_at(*loc___0, (char const   *)tmp___0);
    }
#line 150
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 153
    if (gram_leng > 0) {
#line 153
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 153
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 152
    goto switch_break;
    case_4: /* CIL Label */ 
#line 154
    if (gram_leng > 0) {
#line 154
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 154
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 153
    token_start = loc___0->start;
#line 154
    context_state = (yy_start___0 - 1) / 2;
#line 155
    yy_start___0 = 3;
    }
#line 157
    goto switch_break;
    case_5: /* CIL Label */ 
#line 162
    if (gram_leng > 0) {
#line 162
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 162
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 161
    handle_syncline((gram_text + sizeof("#line ")) - 1, *loc___0);
    }
#line 163
    goto switch_break;
    case_6: /* CIL Label */ 
#line 176
    if (gram_leng > 0) {
#line 176
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 176
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 178
    return (267);
#line 179
    goto switch_break;
    case_7: /* CIL Label */ 
#line 181
    if (gram_leng > 0) {
#line 181
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 181
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 179
    return (271);
#line 180
    goto switch_break;
    case_8: /* CIL Label */ 
#line 182
    if (gram_leng > 0) {
#line 182
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 182
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 180
    return (272);
#line 181
    goto switch_break;
    case_9: /* CIL Label */ 
#line 183
    if (gram_leng > 0) {
#line 183
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 183
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 181
    return (273);
#line 182
    goto switch_break;
    case_10: /* CIL Label */ 
#line 184
    if (gram_leng > 0) {
#line 184
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 184
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 182
    return (274);
#line 183
    goto switch_break;
    case_11: /* CIL Label */ 
#line 185
    if (gram_leng > 0) {
#line 185
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 185
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 183
    return (275);
#line 184
    goto switch_break;
    case_12: /* CIL Label */ 
#line 186
    if (gram_leng > 0) {
#line 186
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 186
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 184
    return (263);
#line 185
    goto switch_break;
    case_13: /* CIL Label */ 
#line 187
    if (gram_leng > 0) {
#line 187
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 187
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 185
    return (269);
#line 186
    goto switch_break;
    case_14: /* CIL Label */ 
#line 188
    if (gram_leng > 0) {
#line 188
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 188
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 186
    return (276);
#line 187
    goto switch_break;
    case_15: /* CIL Label */ 
#line 189
    if (gram_leng > 0) {
#line 189
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 189
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 187
    return (277);
#line 188
    goto switch_break;
    case_16: /* CIL Label */ 
#line 190
    if (gram_leng > 0) {
#line 190
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 190
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 188
    return (278);
#line 189
    goto switch_break;
    case_17: /* CIL Label */ 
#line 191
    if (gram_leng > 0) {
#line 191
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 191
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 189
    return (279);
#line 190
    goto switch_break;
    case_18: /* CIL Label */ 
#line 192
    if (gram_leng > 0) {
#line 192
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 192
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 190
    return (297);
#line 191
    goto switch_break;
    case_19: /* CIL Label */ 
#line 193
    if (gram_leng > 0) {
#line 193
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 193
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 191
    return (281);
#line 192
    goto switch_break;
    case_20: /* CIL Label */ 
#line 194
    if (gram_leng > 0) {
#line 194
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 194
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 192
    return (280);
#line 193
    goto switch_break;
    case_21: /* CIL Label */ 
#line 195
    if (gram_leng > 0) {
#line 195
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 195
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 193
    return (282);
#line 194
    goto switch_break;
    case_22: /* CIL Label */ 
#line 196
    if (gram_leng > 0) {
#line 196
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 196
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 194
    return (265);
#line 195
    goto switch_break;
    case_23: /* CIL Label */ 
#line 197
    if (gram_leng > 0) {
#line 197
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 197
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 195
    return (283);
#line 196
    goto switch_break;
    case_24: /* CIL Label */ 
#line 198
    if (gram_leng > 0) {
#line 198
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 198
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 196
    return (284);
#line 197
    goto switch_break;
    case_25: /* CIL Label */ 
#line 199
    if (gram_leng > 0) {
#line 199
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 199
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 197
    return (270);
#line 198
    goto switch_break;
    case_26: /* CIL Label */ 
#line 200
    if (gram_leng > 0) {
#line 200
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 200
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 198
    return (285);
#line 199
    goto switch_break;
    case_27: /* CIL Label */ 
#line 201
    if (gram_leng > 0) {
#line 201
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 201
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 199
    return (286);
#line 200
    goto switch_break;
    case_28: /* CIL Label */ 
#line 202
    if (gram_leng > 0) {
#line 202
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 202
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 200
    return (287);
#line 201
    goto switch_break;
    case_29: /* CIL Label */ 
#line 203
    if (gram_leng > 0) {
#line 203
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 203
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 201
    return (267);
#line 202
    goto switch_break;
    case_30: /* CIL Label */ 
#line 204
    if (gram_leng > 0) {
#line 204
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 204
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 202
    return (288);
#line 203
    goto switch_break;
    case_31: /* CIL Label */ 
#line 205
    if (gram_leng > 0) {
#line 205
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 205
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 203
    return (261);
#line 204
    goto switch_break;
    case_32: /* CIL Label */ 
#line 206
    if (gram_leng > 0) {
#line 206
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 206
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 204
    return (289);
#line 205
    goto switch_break;
    case_33: /* CIL Label */ 
#line 207
    if (gram_leng > 0) {
#line 207
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 207
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 205
    return (290);
#line 206
    goto switch_break;
    case_34: /* CIL Label */ 
#line 208
    if (gram_leng > 0) {
#line 208
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 208
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 206
    return (268);
#line 207
    goto switch_break;
    case_35: /* CIL Label */ 
#line 209
    if (gram_leng > 0) {
#line 209
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 209
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 207
    return (264);
#line 208
    goto switch_break;
    case_36: /* CIL Label */ 
#line 210
    if (gram_leng > 0) {
#line 210
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 210
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 208
    return (291);
#line 209
    goto switch_break;
    case_37: /* CIL Label */ 
#line 211
    if (gram_leng > 0) {
#line 211
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 211
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 209
    return (292);
#line 210
    goto switch_break;
    case_38: /* CIL Label */ 
#line 212
    if (gram_leng > 0) {
#line 212
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 212
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 210
    return (266);
#line 211
    goto switch_break;
    case_39: /* CIL Label */ 
#line 213
    if (gram_leng > 0) {
#line 213
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 213
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 211
    return (293);
#line 212
    goto switch_break;
    case_40: /* CIL Label */ 
#line 214
    if (gram_leng > 0) {
#line 214
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 214
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 212
    return (294);
#line 213
    goto switch_break;
    case_41: /* CIL Label */ 
#line 215
    if (gram_leng > 0) {
#line 215
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 215
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 213
    return (260);
#line 214
    goto switch_break;
    case_42: /* CIL Label */ 
#line 216
    if (gram_leng > 0) {
#line 216
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 216
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 214
    return (260);
#line 215
    goto switch_break;
    case_43: /* CIL Label */ 
#line 217
    if (gram_leng > 0) {
#line 217
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 217
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 215
    return (295);
#line 216
    goto switch_break;
    case_44: /* CIL Label */ 
#line 218
    if (gram_leng > 0) {
#line 218
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 218
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 216
    return (262);
#line 217
    goto switch_break;
    case_45: /* CIL Label */ 
#line 219
    if (gram_leng > 0) {
#line 219
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 219
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 217
    return (312);
#line 218
    goto switch_break;
    case_46: /* CIL Label */ 
#line 220
    if (gram_leng > 0) {
#line 220
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 220
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 218
    return (296);
#line 219
    goto switch_break;
    case_47: /* CIL Label */ 
#line 221
    if (gram_leng > 0) {
#line 221
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 221
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 219
    return (297);
#line 220
    goto switch_break;
    case_48: /* CIL Label */ 
#line 222
    if (gram_leng > 0) {
#line 222
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 222
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 222
    tmp___1 = quote((char const   *)gram_text);
#line 222
    tmp___2 = gettext("invalid directive: %s");
#line 222
    complain_at(*loc___0, (char const   *)tmp___2, tmp___1);
    }
#line 224
    goto switch_break;
    case_49: /* CIL Label */ 
#line 226
    if (gram_leng > 0) {
#line 226
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 226
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 225
    return (302);
#line 226
    goto switch_break;
    case_50: /* CIL Label */ 
#line 228
    if (gram_leng > 0) {
#line 228
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 228
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 226
    return (306);
#line 227
    goto switch_break;
    case_51: /* CIL Label */ 
#line 229
    if (gram_leng > 0) {
#line 229
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 229
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 227
    return (308);
#line 228
    goto switch_break;
    case_52: /* CIL Label */ 
#line 230
    if (gram_leng > 0) {
#line 230
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 230
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 228
    return (310);
#line 229
    goto switch_break;
    case_53: /* CIL Label */ 
#line 231
    if (gram_leng > 0) {
#line 231
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 231
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 229
    return (311);
#line 230
    goto switch_break;
    case_54: /* CIL Label */ 
#line 232
    if (gram_leng > 0) {
#line 232
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 232
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 232
    val->uniqstr = uniqstr_new((char const   *)gram_text);
#line 233
    id_loc = *loc___0;
#line 234
    bracketed_id_str = (uniqstr )((void *)0);
#line 235
    yy_start___0 = 9;
    }
#line 237
    goto switch_break;
    case_55: /* CIL Label */ 
#line 239
    if (gram_leng > 0) {
#line 239
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 239
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 239
    tmp___3 = scan_integer((char const   *)gram_text, 10, *loc___0);
#line 239
    val->integer = (int )tmp___3;
    }
#line 240
    return (259);
#line 242
    goto switch_break;
    case_56: /* CIL Label */ 
#line 244
    if (gram_leng > 0) {
#line 244
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 244
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 243
    tmp___4 = scan_integer((char const   *)gram_text, 16, *loc___0);
#line 243
    val->integer = (int )tmp___4;
    }
#line 244
    return (259);
#line 246
    goto switch_break;
    case_57: /* CIL Label */ 
#line 250
    if (gram_leng > 0) {
#line 250
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 250
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 250
    tmp___5 = quote((char const   *)gram_text);
#line 250
    tmp___6 = gettext("invalid identifier: %s");
#line 250
    complain_at(*loc___0, (char const   *)tmp___6, tmp___5);
    }
#line 252
    goto switch_break;
    case_58: /* CIL Label */ 
#line 255
    if (gram_leng > 0) {
#line 255
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 255
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 254
    token_start = loc___0->start;
#line 254
    yy_start___0 = 7;
    }
#line 255
    goto switch_break;
    case_59: /* CIL Label */ 
#line 258
    if (gram_leng > 0) {
#line 258
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 258
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 257
    token_start = loc___0->start;
#line 257
    yy_start___0 = 5;
    }
#line 258
    goto switch_break;
    case_60: /* CIL Label */ 
#line 261
    if (gram_leng > 0) {
#line 261
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 261
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 260
    code_start = loc___0->start;
#line 260
    yy_start___0 = 11;
    }
#line 261
    goto switch_break;
    case_61: /* CIL Label */ 
#line 264
    if (gram_leng > 0) {
#line 264
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 264
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 264
    __o = & obstack_for_string___0;
#line 264
    __len = gram_leng;
    }
#line 264
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 264
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 264
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len);
#line 264
    __o->next_free += __len;
#line 265
    braces_level = 0;
#line 266
    code_start = loc___0->start;
#line 267
    yy_start___0 = 13;
    }
#line 269
    goto switch_break;
    case_62: /* CIL Label */ 
#line 272
    if (gram_leng > 0) {
#line 272
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 272
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 272
    __o___0 = & obstack_for_string___0;
#line 272
    __len___0 = gram_leng - 2;
    }
#line 272
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 272
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 272
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(gram_text + 1),
           (size_t )__len___0);
#line 272
    __o___0->next_free += __len___0;
    }
    {
#line 273
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 273
      __o___1 = & obstack_for_string___0;
#line 273
      if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 273
        _obstack_newchunk(__o___1, 1);
        }
      }
#line 273
      tmp___7 = __o___1->next_free;
#line 273
      (__o___1->next_free) ++;
#line 273
      *tmp___7 = (char )'\000';
#line 273
      __o1 = & obstack_for_string___0;
#line 273
      __value = (void *)__o1->object_base;
#line 273
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 273
        __o1->maybe_empty_object = 1U;
      }
#line 273
      if (sizeof(int ) < sizeof(void *)) {
#line 273
        tmp___8 = __o1->object_base;
      } else {
#line 273
        tmp___8 = (char *)0;
      }
#line 273
      if (sizeof(int ) < sizeof(void *)) {
#line 273
        tmp___9 = __o1->object_base;
      } else {
#line 273
        tmp___9 = (char *)0;
      }
#line 273
      __o1->next_free = tmp___8 + (((__o1->next_free - tmp___9) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 273
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 273
        __o1->next_free = __o1->chunk_limit;
      }
#line 273
      __o1->object_base = __o1->next_free;
#line 273
      gram_last_string = (char *)__value;
#line 273
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 274
    val->uniqstr = uniqstr_new((char const   *)gram_last_string);
#line 275
    __o___2 = & obstack_for_string___0;
#line 275
    __obj = (void *)gram_last_string;
    }
#line 275
    if ((unsigned long )__obj > (unsigned long )((void *)__o___2->chunk)) {
#line 275
      if ((unsigned long )__obj < (unsigned long )((void *)__o___2->chunk_limit)) {
#line 275
        tmp___10 = (char *)__obj;
#line 275
        __o___2->object_base = tmp___10;
#line 275
        __o___2->next_free = tmp___10;
      } else {
        {
#line 275
        obstack_free(__o___2, __obj);
        }
      }
    } else {
      {
#line 275
      obstack_free(__o___2, __obj);
      }
    }
#line 276
    return (309);
#line 278
    goto switch_break;
    case_63: /* CIL Label */ 
#line 280
    if (gram_leng > 0) {
#line 280
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 280
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 281
    percent_percent_count ++;
    }
#line 281
    if (percent_percent_count == 2) {
#line 282
      yy_start___0 = 15;
    }
#line 283
    return (305);
#line 285
    goto switch_break;
    case_64: /* CIL Label */ 
#line 287
    if (gram_leng > 0) {
#line 287
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 287
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 287
    bracketed_id_str = (uniqstr )((void *)0);
#line 288
    bracketed_id_start = loc___0->start;
#line 289
    bracketed_id_context_state = (yy_start___0 - 1) / 2;
#line 290
    yy_start___0 = 25;
    }
#line 292
    goto switch_break;
    case_65: /* CIL Label */ 
#line 294
    if (gram_leng > 0) {
#line 294
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 294
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 294
    tmp___11 = quote((char const   *)gram_text);
#line 294
    tmp___12 = gettext("invalid character: %s");
#line 294
    complain_at(*loc___0, (char const   *)tmp___12, tmp___11);
    }
#line 296
    goto switch_break;
    case_111: /* CIL Label */ 
#line 298
    tmp___13 = scanner_cursor;
#line 298
    loc___0->end = tmp___13;
#line 298
    loc___0->start = tmp___13;
#line 299
    return (0);
#line 301
    goto switch_break;
    case_66: /* CIL Label */ 
#line 309
    if (gram_leng > 0) {
#line 309
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 309
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 311
    if (bracketed_id_str) {
      {
#line 313
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 313
        tmp___14 = mbsnwidth((char const   *)gram_text, (size_t )gram_leng, 0);
#line 313
        scanner_cursor.column -= tmp___14;
        }
        {
#line 313
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 313
          yyless_macro_arg = 0;
#line 313
          *yy_cp = yy_hold_char___0;
#line 313
          yy_cp = (yy_bp + yyless_macro_arg) - 0;
#line 313
          yy_c_buf_p___0 = yy_cp;
#line 313
          gram_text = yy_bp;
#line 313
          gram_leng = (int )((size_t )(yy_cp - yy_bp));
#line 313
          yy_hold_char___0 = *yy_cp;
#line 313
          *yy_cp = (char )'\000';
#line 313
          yy_c_buf_p___0 = yy_cp;
#line 313
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 313
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 314
      yy_start___0 = 27;
#line 315
      *loc___0 = id_loc;
#line 316
      return (303);
    } else {
#line 320
      bracketed_id_start = loc___0->start;
#line 321
      bracketed_id_context_state = (yy_start___0 - 1) / 2;
#line 322
      yy_start___0 = 25;
    }
#line 325
    goto switch_break;
    case_67: /* CIL Label */ 
#line 327
    if (gram_leng > 0) {
#line 327
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 327
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 326
    if (bracketed_id_str) {
#line 326
      tmp___15 = 13;
    } else {
#line 326
      tmp___15 = 0;
    }
#line 326
    yy_start___0 = 1 + 2 * tmp___15;
#line 327
    *loc___0 = id_loc;
#line 328
    return (304);
#line 330
    goto switch_break;
    case_68: /* CIL Label */ 
#line 332
    if (gram_leng > 0) {
#line 332
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 332
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
    {
#line 331
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 331
      tmp___16 = mbsnwidth((char const   *)gram_text, (size_t )gram_leng, 0);
#line 331
      scanner_cursor.column -= tmp___16;
      }
      {
#line 331
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 331
        yyless_macro_arg___0 = 0;
#line 331
        *yy_cp = yy_hold_char___0;
#line 331
        yy_cp = (yy_bp + yyless_macro_arg___0) - 0;
#line 331
        yy_c_buf_p___0 = yy_cp;
#line 331
        gram_text = yy_bp;
#line 331
        gram_leng = (int )((size_t )(yy_cp - yy_bp));
#line 331
        yy_hold_char___0 = *yy_cp;
#line 331
        *yy_cp = (char )'\000';
#line 331
        yy_c_buf_p___0 = yy_cp;
#line 331
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 331
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 332
    if (bracketed_id_str) {
#line 332
      tmp___17 = 13;
    } else {
#line 332
      tmp___17 = 0;
    }
#line 332
    yy_start___0 = 1 + 2 * tmp___17;
#line 333
    *loc___0 = id_loc;
#line 334
    return (303);
#line 336
    goto switch_break;
    case_115: /* CIL Label */ 
#line 337
    if (bracketed_id_str) {
#line 337
      tmp___18 = 13;
    } else {
#line 337
      tmp___18 = 0;
    }
#line 337
    yy_start___0 = 1 + 2 * tmp___18;
#line 338
    *loc___0 = id_loc;
#line 339
    return (303);
#line 341
    goto switch_break;
    case_69: /* CIL Label */ 
#line 349
    if (gram_leng > 0) {
#line 349
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 349
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 350
    if (bracketed_id_str) {
      {
#line 352
      tmp___19 = quote((char const   *)gram_text);
#line 352
      tmp___20 = gettext("unexpected identifier in bracketed name: %s");
#line 352
      complain_at(*loc___0, (char const   *)tmp___20, tmp___19);
      }
    } else {
      {
#line 357
      bracketed_id_str = uniqstr_new((char const   *)gram_text);
#line 358
      bracketed_id_loc = *loc___0;
      }
    }
#line 361
    goto switch_break;
    case_70: /* CIL Label */ 
#line 363
    if (gram_leng > 0) {
#line 363
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 363
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 362
    yy_start___0 = 1 + 2 * bracketed_id_context_state;
    }
#line 363
    if (bracketed_id_str) {
#line 365
      if (0 == bracketed_id_context_state) {
#line 367
        val->uniqstr = bracketed_id_str;
#line 368
        bracketed_id_str = (uniqstr )0;
#line 369
        *loc___0 = bracketed_id_loc;
#line 370
        return (299);
      }
    } else {
      {
#line 374
      tmp___21 = gettext("an identifier expected");
#line 374
      complain_at(*loc___0, (char const   *)tmp___21);
      }
    }
#line 376
    goto switch_break;
    case_71: /* CIL Label */ 
#line 378
    if (gram_leng > 0) {
#line 378
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 378
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 377
    tmp___22 = quote((char const   *)gram_text);
#line 377
    tmp___23 = gettext("invalid character in bracketed name: %s");
#line 377
    complain_at(*loc___0, (char const   *)tmp___23, tmp___22);
    }
#line 380
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 381
    yy_start___0 = 1 + 2 * bracketed_id_context_state;
#line 382
    unexpected_eof(bracketed_id_start, "]");
    }
#line 384
    goto switch_break;
    case_72: /* CIL Label */ 
#line 389
    if (gram_leng > 0) {
#line 389
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 389
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
    {
#line 389
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 389
      tmp___24 = mbsnwidth((char const   *)gram_text, (size_t )gram_leng, 0);
#line 389
      scanner_cursor.column -= tmp___24;
      }
      {
#line 389
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 389
        yyless_macro_arg___1 = 0;
#line 389
        *yy_cp = yy_hold_char___0;
#line 389
        yy_cp = (yy_bp + yyless_macro_arg___1) - 0;
#line 389
        yy_c_buf_p___0 = yy_cp;
#line 389
        gram_text = yy_bp;
#line 389
        gram_leng = (int )((size_t )(yy_cp - yy_bp));
#line 389
        yy_hold_char___0 = *yy_cp;
#line 389
        *yy_cp = (char )'\000';
#line 389
        yy_c_buf_p___0 = yy_cp;
#line 389
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 389
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 390
    val->uniqstr = bracketed_id_str;
#line 391
    bracketed_id_str = (uniqstr )0;
#line 392
    *loc___0 = bracketed_id_loc;
#line 393
    yy_start___0 = 1;
#line 394
    return (299);
#line 396
    goto switch_break;
    case_73: /* CIL Label */ 
#line 404
    if (gram_leng > 0) {
#line 404
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 404
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 405
    yy_start___0 = 1 + 2 * context_state;
    }
#line 406
    goto switch_break;
    case_74: /* CIL Label */ 
#line 409
    if (gram_leng > 0) {
#line 409
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 409
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 407
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 407
    unexpected_eof(token_start, "*/");
#line 407
    yy_start___0 = 1 + 2 * context_state;
    }
#line 408
    goto switch_break;
    case_75: /* CIL Label */ 
#line 417
    if (gram_leng > 0) {
#line 417
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 417
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 417
    __o___3 = & obstack_for_string___0;
#line 417
    __len___1 = gram_leng;
    }
#line 417
    if ((unsigned long )(__o___3->next_free + __len___1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 417
      _obstack_newchunk(__o___3, __len___1);
      }
    }
    {
#line 417
    memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___1);
#line 417
    __o___3->next_free += __len___1;
#line 417
    yy_start___0 = 1 + 2 * context_state;
    }
#line 418
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 418
    unexpected_eof(token_start, "*/");
#line 418
    yy_start___0 = 1 + 2 * context_state;
    }
#line 419
    goto switch_break;
    case_76: /* CIL Label */ 
#line 428
    if (gram_leng > 0) {
#line 428
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 428
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 428
    __o___4 = & obstack_for_string___0;
#line 428
    __len___2 = gram_leng;
    }
#line 428
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 428
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 428
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___2);
#line 428
    __o___4->next_free += __len___2;
#line 428
    yy_start___0 = 1 + 2 * context_state;
    }
#line 429
    goto switch_break;
    case_77: /* CIL Label */ 
#line 432
    if (gram_leng > 0) {
#line 432
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 432
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 429
    __o___5 = & obstack_for_string___0;
#line 429
    __len___3 = gram_leng;
    }
#line 429
    if ((unsigned long )(__o___5->next_free + __len___3) > (unsigned long )__o___5->chunk_limit) {
      {
#line 429
      _obstack_newchunk(__o___5, __len___3);
      }
    }
    {
#line 429
    memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___3);
#line 429
    __o___5->next_free += __len___3;
    }
#line 430
    goto switch_break;
    case_120: /* CIL Label */ 
#line 430
    yy_start___0 = 1 + 2 * context_state;
#line 431
    goto switch_break;
    case_78: /* CIL Label */ 
#line 441
    if (gram_leng > 0) {
#line 441
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 441
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
#line 442
    if ((int )*(gram_text + 0) == 10) {
      {
#line 443
      unexpected_newline(token_start, "\"");
      }
    }
    {
#line 444
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 444
      __o___6 = & obstack_for_string___0;
#line 444
      if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
        {
#line 444
        _obstack_newchunk(__o___6, 1);
        }
      }
#line 444
      tmp___25 = __o___6->next_free;
#line 444
      (__o___6->next_free) ++;
#line 444
      *tmp___25 = (char )'\000';
#line 444
      __o1___0 = & obstack_for_string___0;
#line 444
      __value___0 = (void *)__o1___0->object_base;
#line 444
      if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 444
        __o1___0->maybe_empty_object = 1U;
      }
#line 444
      if (sizeof(int ) < sizeof(void *)) {
#line 444
        tmp___26 = __o1___0->object_base;
      } else {
#line 444
        tmp___26 = (char *)0;
      }
#line 444
      if (sizeof(int ) < sizeof(void *)) {
#line 444
        tmp___27 = __o1___0->object_base;
      } else {
#line 444
        tmp___27 = (char *)0;
      }
#line 444
      __o1___0->next_free = tmp___26 + (((__o1___0->next_free - tmp___27) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 444
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 444
        __o1___0->next_free = __o1___0->chunk_limit;
      }
#line 444
      __o1___0->object_base = __o1___0->next_free;
#line 444
      gram_last_string = (char *)__value___0;
#line 444
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 445
    loc___0->start = token_start;
#line 446
    val->chars = (char const   *)gram_last_string;
#line 447
    yy_start___0 = 1;
#line 448
    return (258);
#line 450
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 451
    unexpected_eof(token_start, "\"");
    }
    {
#line 452
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 452
      __o___7 = & obstack_for_string___0;
#line 452
      if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
        {
#line 452
        _obstack_newchunk(__o___7, 1);
        }
      }
#line 452
      tmp___28 = __o___7->next_free;
#line 452
      (__o___7->next_free) ++;
#line 452
      *tmp___28 = (char )'\000';
#line 452
      __o1___1 = & obstack_for_string___0;
#line 452
      __value___1 = (void *)__o1___1->object_base;
#line 452
      if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 452
        __o1___1->maybe_empty_object = 1U;
      }
#line 452
      if (sizeof(int ) < sizeof(void *)) {
#line 452
        tmp___29 = __o1___1->object_base;
      } else {
#line 452
        tmp___29 = (char *)0;
      }
#line 452
      if (sizeof(int ) < sizeof(void *)) {
#line 452
        tmp___30 = __o1___1->object_base;
      } else {
#line 452
        tmp___30 = (char *)0;
      }
#line 452
      __o1___1->next_free = tmp___29 + (((__o1___1->next_free - tmp___30) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 452
      if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 452
        __o1___1->next_free = __o1___1->chunk_limit;
      }
#line 452
      __o1___1->object_base = __o1___1->next_free;
#line 452
      gram_last_string = (char *)__value___1;
#line 452
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 453
    loc___0->start = token_start;
#line 454
    val->chars = (char const   *)gram_last_string;
#line 455
    yy_start___0 = 1;
#line 456
    return (258);
#line 458
    goto switch_break;
    case_79: /* CIL Label */ 
#line 468
    if (gram_leng > 0) {
#line 468
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 468
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
    {
#line 468
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 468
      __o___8 = & obstack_for_string___0;
#line 468
      if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
        {
#line 468
        _obstack_newchunk(__o___8, 1);
        }
      }
#line 468
      tmp___31 = __o___8->next_free;
#line 468
      (__o___8->next_free) ++;
#line 468
      *tmp___31 = (char )'\000';
#line 468
      __o1___2 = & obstack_for_string___0;
#line 468
      __value___2 = (void *)__o1___2->object_base;
#line 468
      if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 468
        __o1___2->maybe_empty_object = 1U;
      }
#line 468
      if (sizeof(int ) < sizeof(void *)) {
#line 468
        tmp___32 = __o1___2->object_base;
      } else {
#line 468
        tmp___32 = (char *)0;
      }
#line 468
      if (sizeof(int ) < sizeof(void *)) {
#line 468
        tmp___33 = __o1___2->object_base;
      } else {
#line 468
        tmp___33 = (char *)0;
      }
#line 468
      __o1___2->next_free = tmp___32 + (((__o1___2->next_free - tmp___33) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 468
      if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 468
        __o1___2->next_free = __o1___2->chunk_limit;
      }
#line 468
      __o1___2->object_base = __o1___2->next_free;
#line 468
      gram_last_string = (char *)__value___2;
#line 468
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 469
    loc___0->start = token_start;
#line 470
    val->character = (unsigned char )*(gram_last_string + 0);
#line 473
    if ((int )*(gram_last_string + 0) == 0) {
      {
#line 475
      tmp___34 = gettext("empty character literal");
#line 475
      warn_at(*loc___0, (char const   *)tmp___34);
#line 477
      val->character = (unsigned char )'\'';
      }
    } else
#line 479
    if ((int )*(gram_last_string + 1) != 0) {
      {
#line 480
      tmp___35 = gettext("extra characters in character literal");
#line 480
      warn_at(*loc___0, (char const   *)tmp___35);
      }
    }
#line 482
    if ((int )*(gram_text + 0) == 10) {
      {
#line 483
      unexpected_newline(token_start, "\'");
      }
    }
#line 484
    __o___9 = & obstack_for_string___0;
#line 484
    __obj___0 = (void *)gram_last_string;
#line 484
    if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___9->chunk)) {
#line 484
      if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___9->chunk_limit)) {
#line 484
        tmp___36 = (char *)__obj___0;
#line 484
        __o___9->object_base = tmp___36;
#line 484
        __o___9->next_free = tmp___36;
      } else {
        {
#line 484
        obstack_free(__o___9, __obj___0);
        }
      }
    } else {
      {
#line 484
      obstack_free(__o___9, __obj___0);
      }
    }
#line 485
    yy_start___0 = 1;
#line 486
    return (300);
#line 488
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 489
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 489
      __o___10 = & obstack_for_string___0;
#line 489
      if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
        {
#line 489
        _obstack_newchunk(__o___10, 1);
        }
      }
#line 489
      tmp___37 = __o___10->next_free;
#line 489
      (__o___10->next_free) ++;
#line 489
      *tmp___37 = (char )'\000';
#line 489
      __o1___3 = & obstack_for_string___0;
#line 489
      __value___3 = (void *)__o1___3->object_base;
#line 489
      if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 489
        __o1___3->maybe_empty_object = 1U;
      }
#line 489
      if (sizeof(int ) < sizeof(void *)) {
#line 489
        tmp___38 = __o1___3->object_base;
      } else {
#line 489
        tmp___38 = (char *)0;
      }
#line 489
      if (sizeof(int ) < sizeof(void *)) {
#line 489
        tmp___39 = __o1___3->object_base;
      } else {
#line 489
        tmp___39 = (char *)0;
      }
#line 489
      __o1___3->next_free = tmp___38 + (((__o1___3->next_free - tmp___39) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 489
      if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 489
        __o1___3->next_free = __o1___3->chunk_limit;
      }
#line 489
      __o1___3->object_base = __o1___3->next_free;
#line 489
      gram_last_string = (char *)__value___3;
#line 489
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 490
    loc___0->start = token_start;
#line 491
    val->character = (unsigned char )*(gram_last_string + 0);
#line 494
    if ((int )*(gram_last_string + 0) == 0) {
      {
#line 496
      tmp___40 = gettext("empty character literal");
#line 496
      warn_at(*loc___0, (char const   *)tmp___40);
#line 498
      val->character = (unsigned char )'\'';
      }
    } else
#line 500
    if ((int )*(gram_last_string + 1) != 0) {
      {
#line 501
      tmp___41 = gettext("extra characters in character literal");
#line 501
      warn_at(*loc___0, (char const   *)tmp___41);
      }
    }
    {
#line 503
    unexpected_eof(token_start, "\'");
#line 504
    __o___11 = & obstack_for_string___0;
#line 504
    __obj___1 = (void *)gram_last_string;
    }
#line 504
    if ((unsigned long )__obj___1 > (unsigned long )((void *)__o___11->chunk)) {
#line 504
      if ((unsigned long )__obj___1 < (unsigned long )((void *)__o___11->chunk_limit)) {
#line 504
        tmp___42 = (char *)__obj___1;
#line 504
        __o___11->object_base = tmp___42;
#line 504
        __o___11->next_free = tmp___42;
      } else {
        {
#line 504
        obstack_free(__o___11, __obj___1);
        }
      }
    } else {
      {
#line 504
      obstack_free(__o___11, __obj___1);
      }
    }
#line 505
    yy_start___0 = 1;
#line 506
    return (300);
#line 508
    goto switch_break;
    case_80: /* CIL Label */ 
#line 513
    if (gram_leng > 0) {
#line 513
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 513
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 512
    tmp___43 = gettext("invalid null character");
#line 512
    complain_at(*loc___0, (char const   *)tmp___43);
    }
#line 513
    goto switch_break;
    case_81: /* CIL Label */ 
#line 521
    if (gram_leng > 0) {
#line 521
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 521
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 523
    tmp___44 = strtoul((char const   */* __restrict  */)(gram_text + 1), (char **/* __restrict  */)((void *)0),
                       8);
#line 523
    c = tmp___44;
    }
#line 524
    if (! c) {
      {
#line 525
      tmp___45 = gettext("invalid number after \\-escape: %s");
#line 525
      complain_at(*loc___0, (char const   *)tmp___45, gram_text + 1);
      }
    } else
#line 524
    if (255UL < c) {
      {
#line 525
      tmp___45 = gettext("invalid number after \\-escape: %s");
#line 525
      complain_at(*loc___0, (char const   *)tmp___45, gram_text + 1);
      }
    } else {
#line 528
      __o___12 = & obstack_for_string___0;
#line 528
      if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
        {
#line 528
        _obstack_newchunk(__o___12, 1);
        }
      }
#line 528
      tmp___46 = __o___12->next_free;
#line 528
      (__o___12->next_free) ++;
#line 528
      *tmp___46 = (char )c;
    }
#line 530
    goto switch_break;
    case_82: /* CIL Label */ 
#line 532
    if (gram_leng > 0) {
#line 532
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 532
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 533
    tmp___47 = strtoul((char const   */* __restrict  */)(gram_text + 2), (char **/* __restrict  */)((void *)0),
                       16);
#line 533
    c___0 = tmp___47;
    }
#line 534
    if (! c___0) {
      {
#line 535
      tmp___48 = gettext("invalid number after \\-escape: %s");
#line 535
      complain_at(*loc___0, (char const   *)tmp___48, gram_text + 1);
      }
    } else
#line 534
    if (255UL < c___0) {
      {
#line 535
      tmp___48 = gettext("invalid number after \\-escape: %s");
#line 535
      complain_at(*loc___0, (char const   *)tmp___48, gram_text + 1);
      }
    } else {
#line 538
      __o___13 = & obstack_for_string___0;
#line 538
      if ((unsigned long )(__o___13->next_free + 1) > (unsigned long )__o___13->chunk_limit) {
        {
#line 538
        _obstack_newchunk(__o___13, 1);
        }
      }
#line 538
      tmp___49 = __o___13->next_free;
#line 538
      (__o___13->next_free) ++;
#line 538
      *tmp___49 = (char )c___0;
    }
#line 540
    goto switch_break;
    case_83: /* CIL Label */ 
#line 542
    if (gram_leng > 0) {
#line 542
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 542
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 541
    __o___14 = & obstack_for_string___0;
    }
#line 541
    if ((unsigned long )(__o___14->next_free + 1) > (unsigned long )__o___14->chunk_limit) {
      {
#line 541
      _obstack_newchunk(__o___14, 1);
      }
    }
#line 541
    tmp___50 = __o___14->next_free;
#line 541
    (__o___14->next_free) ++;
#line 541
    *tmp___50 = (char )'\a';
#line 542
    goto switch_break;
    case_84: /* CIL Label */ 
#line 544
    if (gram_leng > 0) {
#line 544
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 544
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 542
    __o___15 = & obstack_for_string___0;
    }
#line 542
    if ((unsigned long )(__o___15->next_free + 1) > (unsigned long )__o___15->chunk_limit) {
      {
#line 542
      _obstack_newchunk(__o___15, 1);
      }
    }
#line 542
    tmp___51 = __o___15->next_free;
#line 542
    (__o___15->next_free) ++;
#line 542
    *tmp___51 = (char )'\b';
#line 543
    goto switch_break;
    case_85: /* CIL Label */ 
#line 545
    if (gram_leng > 0) {
#line 545
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 545
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 543
    __o___16 = & obstack_for_string___0;
    }
#line 543
    if ((unsigned long )(__o___16->next_free + 1) > (unsigned long )__o___16->chunk_limit) {
      {
#line 543
      _obstack_newchunk(__o___16, 1);
      }
    }
#line 543
    tmp___52 = __o___16->next_free;
#line 543
    (__o___16->next_free) ++;
#line 543
    *tmp___52 = (char )'\f';
#line 544
    goto switch_break;
    case_86: /* CIL Label */ 
#line 546
    if (gram_leng > 0) {
#line 546
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 546
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 544
    __o___17 = & obstack_for_string___0;
    }
#line 544
    if ((unsigned long )(__o___17->next_free + 1) > (unsigned long )__o___17->chunk_limit) {
      {
#line 544
      _obstack_newchunk(__o___17, 1);
      }
    }
#line 544
    tmp___53 = __o___17->next_free;
#line 544
    (__o___17->next_free) ++;
#line 544
    *tmp___53 = (char )'\n';
#line 545
    goto switch_break;
    case_87: /* CIL Label */ 
#line 547
    if (gram_leng > 0) {
#line 547
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 547
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 545
    __o___18 = & obstack_for_string___0;
    }
#line 545
    if ((unsigned long )(__o___18->next_free + 1) > (unsigned long )__o___18->chunk_limit) {
      {
#line 545
      _obstack_newchunk(__o___18, 1);
      }
    }
#line 545
    tmp___54 = __o___18->next_free;
#line 545
    (__o___18->next_free) ++;
#line 545
    *tmp___54 = (char )'\r';
#line 546
    goto switch_break;
    case_88: /* CIL Label */ 
#line 548
    if (gram_leng > 0) {
#line 548
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 548
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 546
    __o___19 = & obstack_for_string___0;
    }
#line 546
    if ((unsigned long )(__o___19->next_free + 1) > (unsigned long )__o___19->chunk_limit) {
      {
#line 546
      _obstack_newchunk(__o___19, 1);
      }
    }
#line 546
    tmp___55 = __o___19->next_free;
#line 546
    (__o___19->next_free) ++;
#line 546
    *tmp___55 = (char )'\t';
#line 547
    goto switch_break;
    case_89: /* CIL Label */ 
#line 549
    if (gram_leng > 0) {
#line 549
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 549
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 547
    __o___20 = & obstack_for_string___0;
    }
#line 547
    if ((unsigned long )(__o___20->next_free + 1) > (unsigned long )__o___20->chunk_limit) {
      {
#line 547
      _obstack_newchunk(__o___20, 1);
      }
    }
#line 547
    tmp___56 = __o___20->next_free;
#line 547
    (__o___20->next_free) ++;
#line 547
    *tmp___56 = (char )'\v';
#line 548
    goto switch_break;
    case_90: /* CIL Label */ 
#line 551
    if (gram_leng > 0) {
#line 551
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 551
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 550
    __o___21 = & obstack_for_string___0;
    }
#line 550
    if ((unsigned long )(__o___21->next_free + 1) > (unsigned long )__o___21->chunk_limit) {
      {
#line 550
      _obstack_newchunk(__o___21, 1);
      }
    }
#line 550
    tmp___57 = __o___21->next_free;
#line 550
    (__o___21->next_free) ++;
#line 550
    *tmp___57 = *(gram_text + 1);
#line 551
    goto switch_break;
    case_91: /* CIL Label */ 
#line 553
    if (gram_leng > 0) {
#line 553
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 553
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 553
    tmp___58 = convert_ucn_to_byte((char const   *)gram_text);
#line 553
    c___1 = tmp___58;
    }
#line 554
    if (c___1 <= 0) {
      {
#line 555
      tmp___59 = gettext("invalid number after \\-escape: %s");
#line 555
      complain_at(*loc___0, (char const   *)tmp___59, gram_text + 1);
      }
    } else {
#line 558
      __o___22 = & obstack_for_string___0;
#line 558
      if ((unsigned long )(__o___22->next_free + 1) > (unsigned long )__o___22->chunk_limit) {
        {
#line 558
        _obstack_newchunk(__o___22, 1);
        }
      }
#line 558
      tmp___60 = __o___22->next_free;
#line 558
      (__o___22->next_free) ++;
#line 558
      *tmp___60 = (char )c___1;
    }
#line 560
    goto switch_break;
    case_92: /* CIL Label */ 
#line 563
    if (gram_leng > 0) {
#line 563
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 563
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 561
    p = (char const   *)(gram_text + 1);
#line 563
    tmp___62 = __ctype_b_loc();
    }
#line 563
    if ((int const   )*(*tmp___62 + (int )((unsigned char )*p)) & 8192) {
      {
#line 563
      tmp___63 = __ctype_b_loc();
      }
#line 563
      if ((int const   )*(*tmp___63 + (int )((unsigned char )*p)) & 16384) {
        {
#line 564
        p = quote(p);
        }
      } else {
        {
#line 566
        tmp___61 = quotearg_style_mem((enum quoting_style )5, p, (size_t )1);
#line 566
        p = (char const   *)tmp___61;
        }
      }
    } else {
      {
#line 566
      tmp___61 = quotearg_style_mem((enum quoting_style )5, p, (size_t )1);
#line 566
      p = (char const   *)tmp___61;
      }
    }
    {
#line 567
    tmp___64 = gettext("invalid character after \\-escape: %s");
#line 567
    complain_at(*loc___0, (char const   *)tmp___64, p);
    }
#line 569
    goto switch_break;
    case_93: /* CIL Label */ 
#line 578
    if (gram_leng > 0) {
#line 578
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 578
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 577
    __o___23 = & obstack_for_string___0;
#line 577
    __len___4 = gram_leng;
    }
#line 577
    if ((unsigned long )(__o___23->next_free + __len___4) > (unsigned long )__o___23->chunk_limit) {
      {
#line 577
      _obstack_newchunk(__o___23, __len___4);
      }
    }
    {
#line 577
    memcpy((void */* __restrict  */)__o___23->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___4);
#line 577
    __o___23->next_free += __len___4;
    }
#line 578
    goto switch_break;
    case_94: /* CIL Label */ 
#line 583
    if (gram_leng > 0) {
#line 583
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 583
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 582
    __o___24 = & obstack_for_string___0;
#line 582
    __len___5 = gram_leng;
    }
#line 582
    if ((unsigned long )(__o___24->next_free + __len___5) > (unsigned long )__o___24->chunk_limit) {
      {
#line 582
      _obstack_newchunk(__o___24, __len___5);
      }
    }
    {
#line 582
    memcpy((void */* __restrict  */)__o___24->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___5);
#line 582
    __o___24->next_free += __len___5;
#line 582
    yy_start___0 = 1 + 2 * context_state;
    }
#line 583
    goto switch_break;
    case_95: /* CIL Label */ 
#line 586
    if (gram_leng > 0) {
#line 586
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 586
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 583
    unexpected_newline(token_start, "\'");
#line 583
    yy_start___0 = 1 + 2 * context_state;
    }
#line 584
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 584
    unexpected_eof(token_start, "\'");
#line 584
    yy_start___0 = 1 + 2 * context_state;
    }
#line 585
    goto switch_break;
    case_96: /* CIL Label */ 
#line 590
    if (gram_leng > 0) {
#line 590
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 590
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 589
    __o___25 = & obstack_for_string___0;
#line 589
    __len___6 = gram_leng;
    }
#line 589
    if ((unsigned long )(__o___25->next_free + __len___6) > (unsigned long )__o___25->chunk_limit) {
      {
#line 589
      _obstack_newchunk(__o___25, __len___6);
      }
    }
    {
#line 589
    memcpy((void */* __restrict  */)__o___25->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___6);
#line 589
    __o___25->next_free += __len___6;
#line 589
    yy_start___0 = 1 + 2 * context_state;
    }
#line 590
    goto switch_break;
    case_97: /* CIL Label */ 
#line 593
    if (gram_leng > 0) {
#line 593
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 593
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 590
    unexpected_newline(token_start, "\"");
#line 590
    yy_start___0 = 1 + 2 * context_state;
    }
#line 591
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 591
    unexpected_eof(token_start, "\"");
#line 591
    yy_start___0 = 1 + 2 * context_state;
    }
#line 592
    goto switch_break;
    case_98: /* CIL Label */ 
#line 600
    if (gram_leng > 0) {
#line 600
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 600
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 602
    __o___26 = & obstack_for_string___0;
#line 602
    __len___7 = gram_leng;
    }
#line 602
    if ((unsigned long )(__o___26->next_free + __len___7) > (unsigned long )__o___26->chunk_limit) {
      {
#line 602
      _obstack_newchunk(__o___26, __len___7);
      }
    }
    {
#line 602
    memcpy((void */* __restrict  */)__o___26->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___7);
#line 602
    __o___26->next_free += __len___7;
#line 603
    context_state = (yy_start___0 - 1) / 2;
#line 604
    token_start = loc___0->start;
#line 605
    yy_start___0 = 23;
    }
#line 607
    goto switch_break;
    case_99: /* CIL Label */ 
#line 609
    if (gram_leng > 0) {
#line 609
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 609
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 608
    __o___27 = & obstack_for_string___0;
#line 608
    __len___8 = gram_leng;
    }
#line 608
    if ((unsigned long )(__o___27->next_free + __len___8) > (unsigned long )__o___27->chunk_limit) {
      {
#line 608
      _obstack_newchunk(__o___27, __len___8);
      }
    }
    {
#line 608
    memcpy((void */* __restrict  */)__o___27->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___8);
#line 608
    __o___27->next_free += __len___8;
#line 609
    context_state = (yy_start___0 - 1) / 2;
#line 610
    token_start = loc___0->start;
#line 611
    yy_start___0 = 21;
    }
#line 613
    goto switch_break;
    case_100: /* CIL Label */ 
#line 616
    if (gram_leng > 0) {
#line 616
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 616
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 614
    __o___28 = & obstack_for_string___0;
#line 614
    __len___9 = gram_leng;
    }
#line 614
    if ((unsigned long )(__o___28->next_free + __len___9) > (unsigned long )__o___28->chunk_limit) {
      {
#line 614
      _obstack_newchunk(__o___28, __len___9);
      }
    }
    {
#line 614
    memcpy((void */* __restrict  */)__o___28->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___9);
#line 614
    __o___28->next_free += __len___9;
#line 615
    context_state = (yy_start___0 - 1) / 2;
#line 616
    token_start = loc___0->start;
#line 617
    yy_start___0 = 17;
    }
#line 619
    goto switch_break;
    case_101: /* CIL Label */ 
#line 622
    if (gram_leng > 0) {
#line 622
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 622
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 620
    __o___29 = & obstack_for_string___0;
#line 620
    __len___10 = gram_leng;
    }
#line 620
    if ((unsigned long )(__o___29->next_free + __len___10) > (unsigned long )__o___29->chunk_limit) {
      {
#line 620
      _obstack_newchunk(__o___29, __len___10);
      }
    }
    {
#line 620
    memcpy((void */* __restrict  */)__o___29->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___10);
#line 620
    __o___29->next_free += __len___10;
#line 621
    context_state = (yy_start___0 - 1) / 2;
#line 622
    yy_start___0 = 19;
    }
#line 624
    goto switch_break;
    case_102: /* CIL Label */ 
#line 634
    if (gram_leng > 0) {
#line 634
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 634
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 635
    __o___30 = & obstack_for_string___0;
#line 635
    __len___11 = gram_leng;
    }
#line 635
    if ((unsigned long )(__o___30->next_free + __len___11) > (unsigned long )__o___30->chunk_limit) {
      {
#line 635
      _obstack_newchunk(__o___30, __len___11);
      }
    }
    {
#line 635
    memcpy((void */* __restrict  */)__o___30->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___11);
#line 635
    __o___30->next_free += __len___11;
#line 635
    braces_level ++;
    }
#line 636
    goto switch_break;
    case_103: /* CIL Label */ 
#line 639
    if (gram_leng > 0) {
#line 639
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 639
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 636
    __o___31 = & obstack_for_string___0;
#line 636
    __len___12 = gram_leng;
    }
#line 636
    if ((unsigned long )(__o___31->next_free + __len___12) > (unsigned long )__o___31->chunk_limit) {
      {
#line 636
      _obstack_newchunk(__o___31, __len___12);
      }
    }
    {
#line 636
    memcpy((void */* __restrict  */)__o___31->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___12);
#line 636
    __o___31->next_free += __len___12;
#line 636
    braces_level --;
    }
#line 637
    goto switch_break;
    case_104: /* CIL Label */ 
#line 639
    if (gram_leng > 0) {
#line 639
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 639
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 638
    __o___32 = & obstack_for_string___0;
    }
#line 638
    if ((unsigned long )(__o___32->next_free + 1) > (unsigned long )__o___32->chunk_limit) {
      {
#line 638
      _obstack_newchunk(__o___32, 1);
      }
    }
#line 638
    tmp___65 = __o___32->next_free;
#line 638
    (__o___32->next_free) ++;
#line 638
    *tmp___65 = (char )'}';
#line 640
    braces_level --;
#line 641
    if (braces_level < 0) {
      {
#line 643
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 643
        __o___33 = & obstack_for_string___0;
#line 643
        if ((unsigned long )(__o___33->next_free + 1) > (unsigned long )__o___33->chunk_limit) {
          {
#line 643
          _obstack_newchunk(__o___33, 1);
          }
        }
#line 643
        tmp___66 = __o___33->next_free;
#line 643
        (__o___33->next_free) ++;
#line 643
        *tmp___66 = (char )'\000';
#line 643
        __o1___4 = & obstack_for_string___0;
#line 643
        __value___4 = (void *)__o1___4->object_base;
#line 643
        if ((unsigned long )__o1___4->next_free == (unsigned long )__value___4) {
#line 643
          __o1___4->maybe_empty_object = 1U;
        }
#line 643
        if (sizeof(int ) < sizeof(void *)) {
#line 643
          tmp___67 = __o1___4->object_base;
        } else {
#line 643
          tmp___67 = (char *)0;
        }
#line 643
        if (sizeof(int ) < sizeof(void *)) {
#line 643
          tmp___68 = __o1___4->object_base;
        } else {
#line 643
          tmp___68 = (char *)0;
        }
#line 643
        __o1___4->next_free = tmp___67 + (((__o1___4->next_free - tmp___68) + (long )__o1___4->alignment_mask) & (long )(~ __o1___4->alignment_mask));
#line 643
        if (__o1___4->next_free - (char *)__o1___4->chunk > __o1___4->chunk_limit - (char *)__o1___4->chunk) {
#line 643
          __o1___4->next_free = __o1___4->chunk_limit;
        }
#line 643
        __o1___4->object_base = __o1___4->next_free;
#line 643
        gram_last_string = (char *)__value___4;
#line 643
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 644
      loc___0->start = code_start;
#line 645
      val->code = gram_last_string;
#line 646
      yy_start___0 = 1;
#line 647
      return (298);
    }
#line 650
    goto switch_break;
    case_105: /* CIL Label */ 
#line 655
    if (gram_leng > 0) {
#line 655
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 655
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 653
    __o___34 = & obstack_for_string___0;
#line 653
    __len___13 = gram_leng;
    }
#line 653
    if ((unsigned long )(__o___34->next_free + __len___13) > (unsigned long )__o___34->chunk_limit) {
      {
#line 653
      _obstack_newchunk(__o___34, __len___13);
      }
    }
    {
#line 653
    memcpy((void */* __restrict  */)__o___34->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___13);
#line 653
    __o___34->next_free += __len___13;
    }
#line 654
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 656
    unexpected_eof(code_start, "}");
    }
    {
#line 657
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 657
      __o___35 = & obstack_for_string___0;
#line 657
      if ((unsigned long )(__o___35->next_free + 1) > (unsigned long )__o___35->chunk_limit) {
        {
#line 657
        _obstack_newchunk(__o___35, 1);
        }
      }
#line 657
      tmp___69 = __o___35->next_free;
#line 657
      (__o___35->next_free) ++;
#line 657
      *tmp___69 = (char )'\000';
#line 657
      __o1___5 = & obstack_for_string___0;
#line 657
      __value___5 = (void *)__o1___5->object_base;
#line 657
      if ((unsigned long )__o1___5->next_free == (unsigned long )__value___5) {
#line 657
        __o1___5->maybe_empty_object = 1U;
      }
#line 657
      if (sizeof(int ) < sizeof(void *)) {
#line 657
        tmp___70 = __o1___5->object_base;
      } else {
#line 657
        tmp___70 = (char *)0;
      }
#line 657
      if (sizeof(int ) < sizeof(void *)) {
#line 657
        tmp___71 = __o1___5->object_base;
      } else {
#line 657
        tmp___71 = (char *)0;
      }
#line 657
      __o1___5->next_free = tmp___70 + (((__o1___5->next_free - tmp___71) + (long )__o1___5->alignment_mask) & (long )(~ __o1___5->alignment_mask));
#line 657
      if (__o1___5->next_free - (char *)__o1___5->chunk > __o1___5->chunk_limit - (char *)__o1___5->chunk) {
#line 657
        __o1___5->next_free = __o1___5->chunk_limit;
      }
#line 657
      __o1___5->object_base = __o1___5->next_free;
#line 657
      gram_last_string = (char *)__value___5;
#line 657
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 658
    loc___0->start = code_start;
#line 659
    val->code = gram_last_string;
#line 660
    yy_start___0 = 1;
#line 661
    return (298);
#line 663
    goto switch_break;
    case_106: /* CIL Label */ 
#line 671
    if (gram_leng > 0) {
#line 671
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 671
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
    }
    {
#line 673
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 673
      __o___36 = & obstack_for_string___0;
#line 673
      if ((unsigned long )(__o___36->next_free + 1) > (unsigned long )__o___36->chunk_limit) {
        {
#line 673
        _obstack_newchunk(__o___36, 1);
        }
      }
#line 673
      tmp___72 = __o___36->next_free;
#line 673
      (__o___36->next_free) ++;
#line 673
      *tmp___72 = (char )'\000';
#line 673
      __o1___6 = & obstack_for_string___0;
#line 673
      __value___6 = (void *)__o1___6->object_base;
#line 673
      if ((unsigned long )__o1___6->next_free == (unsigned long )__value___6) {
#line 673
        __o1___6->maybe_empty_object = 1U;
      }
#line 673
      if (sizeof(int ) < sizeof(void *)) {
#line 673
        tmp___73 = __o1___6->object_base;
      } else {
#line 673
        tmp___73 = (char *)0;
      }
#line 673
      if (sizeof(int ) < sizeof(void *)) {
#line 673
        tmp___74 = __o1___6->object_base;
      } else {
#line 673
        tmp___74 = (char *)0;
      }
#line 673
      __o1___6->next_free = tmp___73 + (((__o1___6->next_free - tmp___74) + (long )__o1___6->alignment_mask) & (long )(~ __o1___6->alignment_mask));
#line 673
      if (__o1___6->next_free - (char *)__o1___6->chunk > __o1___6->chunk_limit - (char *)__o1___6->chunk) {
#line 673
        __o1___6->next_free = __o1___6->chunk_limit;
      }
#line 673
      __o1___6->object_base = __o1___6->next_free;
#line 673
      gram_last_string = (char *)__value___6;
#line 673
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 674
    loc___0->start = code_start;
#line 675
    val->chars = (char const   *)gram_last_string;
#line 676
    yy_start___0 = 1;
#line 677
    return (307);
#line 679
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 681
    unexpected_eof(code_start, "%}");
    }
    {
#line 682
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 682
      __o___37 = & obstack_for_string___0;
#line 682
      if ((unsigned long )(__o___37->next_free + 1) > (unsigned long )__o___37->chunk_limit) {
        {
#line 682
        _obstack_newchunk(__o___37, 1);
        }
      }
#line 682
      tmp___75 = __o___37->next_free;
#line 682
      (__o___37->next_free) ++;
#line 682
      *tmp___75 = (char )'\000';
#line 682
      __o1___7 = & obstack_for_string___0;
#line 682
      __value___7 = (void *)__o1___7->object_base;
#line 682
      if ((unsigned long )__o1___7->next_free == (unsigned long )__value___7) {
#line 682
        __o1___7->maybe_empty_object = 1U;
      }
#line 682
      if (sizeof(int ) < sizeof(void *)) {
#line 682
        tmp___76 = __o1___7->object_base;
      } else {
#line 682
        tmp___76 = (char *)0;
      }
#line 682
      if (sizeof(int ) < sizeof(void *)) {
#line 682
        tmp___77 = __o1___7->object_base;
      } else {
#line 682
        tmp___77 = (char *)0;
      }
#line 682
      __o1___7->next_free = tmp___76 + (((__o1___7->next_free - tmp___77) + (long )__o1___7->alignment_mask) & (long )(~ __o1___7->alignment_mask));
#line 682
      if (__o1___7->next_free - (char *)__o1___7->chunk > __o1___7->chunk_limit - (char *)__o1___7->chunk) {
#line 682
        __o1___7->next_free = __o1___7->chunk_limit;
      }
#line 682
      __o1___7->object_base = __o1___7->next_free;
#line 682
      gram_last_string = (char *)__value___7;
#line 682
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 683
    loc___0->start = code_start;
#line 684
    val->chars = (char const   *)gram_last_string;
#line 685
    yy_start___0 = 1;
#line 686
    return (307);
#line 688
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 699
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 699
      __o___38 = & obstack_for_string___0;
#line 699
      if ((unsigned long )(__o___38->next_free + 1) > (unsigned long )__o___38->chunk_limit) {
        {
#line 699
        _obstack_newchunk(__o___38, 1);
        }
      }
#line 699
      tmp___78 = __o___38->next_free;
#line 699
      (__o___38->next_free) ++;
#line 699
      *tmp___78 = (char )'\000';
#line 699
      __o1___8 = & obstack_for_string___0;
#line 699
      __value___8 = (void *)__o1___8->object_base;
#line 699
      if ((unsigned long )__o1___8->next_free == (unsigned long )__value___8) {
#line 699
        __o1___8->maybe_empty_object = 1U;
      }
#line 699
      if (sizeof(int ) < sizeof(void *)) {
#line 699
        tmp___79 = __o1___8->object_base;
      } else {
#line 699
        tmp___79 = (char *)0;
      }
#line 699
      if (sizeof(int ) < sizeof(void *)) {
#line 699
        tmp___80 = __o1___8->object_base;
      } else {
#line 699
        tmp___80 = (char *)0;
      }
#line 699
      __o1___8->next_free = tmp___79 + (((__o1___8->next_free - tmp___80) + (long )__o1___8->alignment_mask) & (long )(~ __o1___8->alignment_mask));
#line 699
      if (__o1___8->next_free - (char *)__o1___8->chunk > __o1___8->chunk_limit - (char *)__o1___8->chunk) {
#line 699
        __o1___8->next_free = __o1___8->chunk_limit;
      }
#line 699
      __o1___8->object_base = __o1___8->next_free;
#line 699
      gram_last_string = (char *)__value___8;
#line 699
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 700
    loc___0->start = code_start;
#line 701
    val->chars = (char const   *)gram_last_string;
#line 702
    yy_start___0 = 1;
#line 703
    return (301);
#line 705
    goto switch_break;
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
#line 715
    if (gram_leng > 0) {
#line 715
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 715
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 713
    __o___39 = & obstack_for_string___0;
#line 713
    __len___14 = gram_leng;
    }
#line 713
    if ((unsigned long )(__o___39->next_free + __len___14) > (unsigned long )__o___39->chunk_limit) {
      {
#line 713
      _obstack_newchunk(__o___39, __len___14);
      }
    }
    {
#line 713
    memcpy((void */* __restrict  */)__o___39->next_free, (void const   */* __restrict  */)gram_text,
           (size_t )__len___14);
#line 713
    __o___39->next_free += __len___14;
    }
#line 714
    goto switch_break;
    case_109: /* CIL Label */ 
#line 716
    if (gram_leng > 0) {
#line 716
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol = (int )*(gram_text + (gram_leng - 1)) == 10;
    }
    {
#line 716
    location_compute(loc___0, & scanner_cursor, (char const   *)gram_text, (size_t )gram_leng);
#line 715
    yy_fatal_error___0("flex scanner jammed");
    }
#line 716
    goto switch_break;
    case_124: /* CIL Label */ 
#line 2410 "scan-gram.c"
    return (0);
    case_110: /* CIL Label */ 
#line 2415
    yy_amount_of_matched_text = (int )(yy_cp - gram_text) - 1;
#line 2418
    *yy_cp = yy_hold_char___0;
#line 2421
    if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status == 0) {
#line 2432
      yy_n_chars___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars;
#line 2433
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_input_file = gram_in;
#line 2434
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status = 1;
    }
#line 2444
    if ((unsigned long )yy_c_buf_p___0 <= (unsigned long )((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0)) {
      {
#line 2448
      yy_c_buf_p___0 = gram_text + yy_amount_of_matched_text;
#line 2450
      yy_current_state = yy_get_previous_state___0();
#line 2461
      yy_next_state = yy_try_NUL_trans___0(yy_current_state);
#line 2463
      yy_bp = gram_text + 0;
      }
#line 2465
      if (yy_next_state) {
#line 2468
        yy_c_buf_p___0 ++;
#line 2468
        yy_cp = yy_c_buf_p___0;
#line 2469
        yy_current_state = yy_next_state;
#line 2470
        goto yy_match;
      } else {
#line 2476
        yy_cp = yy_last_accepting_cpos___0;
#line 2477
        yy_current_state = yy_last_accepting_state___0;
#line 2478
        goto yy_find_action;
      }
    } else {
      {
#line 2482
      tmp___81 = yy_get_next_buffer___0();
      }
      {
#line 2484
      if (tmp___81 == 1) {
#line 2484
        goto case_1___0;
      }
#line 2513
      if (tmp___81 == 0) {
#line 2513
        goto case_0___0;
      }
#line 2523
      if (tmp___81 == 2) {
#line 2523
        goto case_2___0;
      }
#line 2482
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 2486
      yy_did_buffer_switch_on_eof___0 = 0;
#line 2499
      yy_c_buf_p___0 = gram_text + 0;
#line 2501
      yy_act = (110 + (yy_start___0 - 1) / 2) + 1;
#line 2502
      goto do_action;
#line 2510
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 2514
      yy_c_buf_p___0 = gram_text + yy_amount_of_matched_text;
#line 2517
      yy_current_state = yy_get_previous_state___0();
#line 2519
      yy_cp = yy_c_buf_p___0;
#line 2520
      yy_bp = gram_text + 0;
      }
#line 2521
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 2524
      yy_c_buf_p___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0;
#line 2527
      yy_current_state = yy_get_previous_state___0();
#line 2529
      yy_cp = yy_c_buf_p___0;
#line 2530
      yy_bp = gram_text + 0;
      }
#line 2531
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 2533
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2537
    yy_fatal_error___0("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2559 "scan-gram.c"
static int yy_get_next_buffer___0(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  size_t tmp___3 ;
  yy_size_t new_size___0 ;
  void *tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 2564
  dest = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf;
#line 2565
  source = gram_text;
#line 2569
  if ((unsigned long )yy_c_buf_p___0 > (unsigned long )((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + (yy_n_chars___0 + 1))) {
    {
#line 2570
    yy_fatal_error___0("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 2573
  if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_fill_buffer == 0) {
#line 2575
    if (yy_c_buf_p___0 - gram_text == 1L) {
#line 2580
      return (1);
    } else {
#line 2588
      return (2);
    }
  }
#line 2595
  number_to_move = (int )(yy_c_buf_p___0 - gram_text) - 1;
#line 2597
  i = 0;
  {
#line 2597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2597
    if (! (i < number_to_move)) {
#line 2597
      goto while_break;
    }
#line 2598
    tmp = dest;
#line 2598
    dest ++;
#line 2598
    tmp___0 = source;
#line 2598
    source ++;
#line 2598
    *tmp = *tmp___0;
#line 2597
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2600
  if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status == 2) {
#line 2604
    yy_n_chars___0 = 0;
#line 2604
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  } else {
#line 2608
    num_to_read = (int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 2611
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2611
      if (! (num_to_read <= 0)) {
#line 2611
        goto while_break___0;
      }
#line 2615
      if (yy_buffer_stack___0) {
#line 2615
        tmp___1 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
      } else {
#line 2615
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 2615
      b = tmp___1;
#line 2617
      yy_c_buf_p_offset = (int )(yy_c_buf_p___0 - b->yy_ch_buf);
#line 2620
      if (b->yy_is_our_buffer) {
#line 2622
        new_size = (int )(b->yy_buf_size * 2U);
#line 2624
        if (new_size <= 0) {
#line 2625
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 2627
          b->yy_buf_size *= 2U;
        }
        {
#line 2629
        tmp___2 = gram_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 2629
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 2635
        b->yy_ch_buf = (char *)0;
      }
#line 2637
      if (! b->yy_ch_buf) {
        {
#line 2638
        yy_fatal_error___0("fatal error - scanner input buffer overflow");
        }
      }
#line 2641
      yy_c_buf_p___0 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 2643
      num_to_read = (int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2648
    if (num_to_read > 8192) {
#line 2649
      num_to_read = 8192;
    }
    {
#line 2652
    tmp___3 = no_cr_read(gram_in, (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move,
                         (size_t )num_to_read);
#line 2652
    yy_n_chars___0 = (int )tmp___3;
#line 2655
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
    }
  }
#line 2658
  if (yy_n_chars___0 == 0) {
#line 2660
    if (number_to_move == 0) {
      {
#line 2662
      ret_val = 1;
#line 2663
      gram_restart(gram_in);
      }
    } else {
#line 2668
      ret_val = 2;
#line 2669
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status = 2;
    }
  } else {
#line 2675
    ret_val = 0;
  }
#line 2677
  if ((yy_size_t )(yy_n_chars___0 + number_to_move) > (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size) {
    {
#line 2679
    new_size___0 = (yy_size_t )((yy_n_chars___0 + number_to_move) + (yy_n_chars___0 >> 1));
#line 2680
    tmp___4 = gram_realloc((void *)(*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf,
                           new_size___0);
#line 2680
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf = (char *)tmp___4;
    }
#line 2681
    if (! (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf) {
      {
#line 2682
      yy_fatal_error___0("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 2685
  yy_n_chars___0 += number_to_move;
#line 2686
  *((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0) = (char)0;
#line 2687
  *((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + (yy_n_chars___0 + 1)) = (char)0;
#line 2689
  gram_text = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + 0;
#line 2691
  return (ret_val);
}
}
#line 2699 "scan-gram.c"
static yy_state_type yy_get_previous_state___0(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 2708
  yy_current_state = yy_start___0;
#line 2709
  yy_current_state += (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_at_bol;
#line 2711
  yy_cp = gram_text + 0;
  {
#line 2711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2711
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p___0)) {
#line 2711
      goto while_break;
    }
#line 2714
    if (*yy_cp) {
#line 2714
      tmp = yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 2714
      tmp = (flex_int32_t const   )56;
    }
#line 2714
    yy_c = (YY_CHAR )tmp;
#line 2715
    if (yy_accept___0[yy_current_state]) {
#line 2717
      yy_last_accepting_state___0 = yy_current_state;
#line 2718
      yy_last_accepting_cpos___0 = yy_cp;
    }
    {
#line 2720
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2720
      if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2720
        goto while_break___0;
      }
#line 2722
      yy_current_state = (int )yy_def___0[yy_current_state];
#line 2723
      if (yy_current_state >= 474) {
#line 2724
        yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2726
    yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 2711
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2729
  return (yy_current_state);
}
}
#line 2738 "scan-gram.c"
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 2745
  yy_cp = yy_c_buf_p___0;
#line 2747
  yy_c = (YY_CHAR )56;
#line 2748
  if (yy_accept___0[yy_current_state]) {
#line 2750
    yy_last_accepting_state___0 = yy_current_state;
#line 2751
    yy_last_accepting_cpos___0 = yy_cp;
  }
  {
#line 2753
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2753
    if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2753
      goto while_break;
    }
#line 2755
    yy_current_state = (int )yy_def___0[yy_current_state];
#line 2756
    if (yy_current_state >= 474) {
#line 2757
      yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2759
  yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 2760
  yy_is_jam = yy_current_state == 473;
#line 2762
  if (yy_is_jam) {
#line 2762
    tmp = 0;
  } else {
#line 2762
    tmp = yy_current_state;
  }
#line 2762
  return (tmp);
}
}
#line 2858 "scan-gram.c"
void gram_restart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2864
  if (yy_buffer_stack___0) {
#line 2864
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 2864
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2864
  if (! tmp) {
    {
#line 2865
    gram_ensure_buffer_stack();
#line 2866
    *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = gram__create_buffer(gram_in,
                                                                           16384);
    }
  }
#line 2870
  if (yy_buffer_stack___0) {
#line 2870
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 2870
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2870
  gram__init_buffer(tmp___0, input_file);
#line 2871
  gram__load_buffer_state();
  }
#line 2872
  return;
}
}
#line 2879 "scan-gram.c"
void gram__switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2890
  gram_ensure_buffer_stack();
  }
#line 2891
  if (yy_buffer_stack___0) {
#line 2891
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 2891
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2891
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 2892
    return;
  }
#line 2894
  if (yy_buffer_stack___0) {
#line 2894
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 2894
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2894
  if (tmp___0) {
#line 2897
    *yy_c_buf_p___0 = yy_hold_char___0;
#line 2898
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos = yy_c_buf_p___0;
#line 2899
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  }
  {
#line 2902
  *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = new_buffer;
#line 2903
  gram__load_buffer_state();
#line 2910
  yy_did_buffer_switch_on_eof___0 = 1;
  }
#line 2911
  return;
}
}
#line 2914 "scan-gram.c"
static void gram__load_buffer_state(void) 
{ 


  {
#line 2919
  yy_n_chars___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars;
#line 2920
  yy_c_buf_p___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos;
#line 2920
  gram_text = yy_c_buf_p___0;
#line 2921
  gram_in = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_input_file;
#line 2922
  yy_hold_char___0 = *yy_c_buf_p___0;
#line 2923
  return;
}
}
#line 2932 "scan-gram.c"
YY_BUFFER_STATE gram__create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 2939
  tmp = gram_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 2939
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2940
  if (! b) {
    {
#line 2941
    yy_fatal_error___0("out of dynamic memory in gram__create_buffer()");
    }
  }
  {
#line 2943
  b->yy_buf_size = (yy_size_t )size;
#line 2948
  tmp___0 = gram_alloc(b->yy_buf_size + 2U);
#line 2948
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 2949
  if (! b->yy_ch_buf) {
    {
#line 2950
    yy_fatal_error___0("out of dynamic memory in gram__create_buffer()");
    }
  }
  {
#line 2952
  b->yy_is_our_buffer = 1;
#line 2954
  gram__init_buffer(b, file);
  }
#line 2956
  return (b);
}
}
#line 2964 "scan-gram.c"
void gram__delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 2970
  if (! b) {
#line 2971
    return;
  }
#line 2973
  if (yy_buffer_stack___0) {
#line 2973
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 2973
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2973
  if ((unsigned long )b == (unsigned long )tmp) {
#line 2974
    *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = (YY_BUFFER_STATE )0;
  }
#line 2976
  if (b->yy_is_our_buffer) {
    {
#line 2977
    gram_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 2979
  gram_free((void *)b);
  }
#line 2980
  return;
}
}
#line 2994 "scan-gram.c"
static void gram__init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 3000
  tmp = __errno_location();
#line 3000
  oerrno = *tmp;
#line 3002
  gram__flush_buffer(b);
#line 3004
  b->yy_input_file = file;
#line 3005
  b->yy_fill_buffer = 1;
  }
#line 3011
  if (yy_buffer_stack___0) {
#line 3011
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 3011
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 3011
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 3012
    b->yy_bs_lineno = 1;
#line 3013
    b->yy_bs_column = 0;
  }
  {
#line 3018
  b->yy_is_interactive = 0;
#line 3023
  tmp___1 = __errno_location();
#line 3023
  *tmp___1 = oerrno;
  }
#line 3024
  return;
}
}
#line 3031 "scan-gram.c"
void gram__flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 3036
  if (! b) {
#line 3037
    return;
  }
#line 3039
  b->yy_n_chars = 0;
#line 3045
  *(b->yy_ch_buf + 0) = (char)0;
#line 3046
  *(b->yy_ch_buf + 1) = (char)0;
#line 3048
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 3050
  b->yy_at_bol = 1;
#line 3051
  b->yy_buffer_status = 0;
#line 3053
  if (yy_buffer_stack___0) {
#line 3053
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 3053
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3053
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 3054
    gram__load_buffer_state();
    }
  }
#line 3055
  return;
}
}
#line 3065 "scan-gram.c"
void gram_push_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 3070
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 3071
    return;
  }
  {
#line 3073
  gram_ensure_buffer_stack();
  }
#line 3076
  if (yy_buffer_stack___0) {
#line 3076
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 3076
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3076
  if (tmp) {
#line 3079
    *yy_c_buf_p___0 = yy_hold_char___0;
#line 3080
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos = yy_c_buf_p___0;
#line 3081
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  }
#line 3085
  if (yy_buffer_stack___0) {
#line 3085
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 3085
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 3085
  if (tmp___0) {
#line 3086
    yy_buffer_stack_top___0 ++;
  }
  {
#line 3087
  *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = new_buffer;
#line 3090
  gram__load_buffer_state();
#line 3091
  yy_did_buffer_switch_on_eof___0 = 1;
  }
#line 3092
  return;
}
}
#line 3101 "scan-gram.c"
void gram_pop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 3106
  if (yy_buffer_stack___0) {
#line 3106
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 3106
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3106
  if (! tmp) {
#line 3107
    return;
  }
#line 3109
  if (yy_buffer_stack___0) {
#line 3109
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 3109
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 3109
  gram__delete_buffer(tmp___0);
#line 3110
  *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = (YY_BUFFER_STATE )((void *)0);
  }
#line 3111
  if (yy_buffer_stack_top___0 > 0U) {
#line 3112
    yy_buffer_stack_top___0 --;
  }
#line 3114
  if (yy_buffer_stack___0) {
#line 3114
    tmp___1 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 3114
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 3114
  if (tmp___1) {
    {
#line 3115
    gram__load_buffer_state();
#line 3116
    yy_did_buffer_switch_on_eof___0 = 1;
    }
  }
#line 3118
  return;
}
}
#line 3126 "scan-gram.c"
static void gram_ensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 3133
  if (! yy_buffer_stack___0) {
    {
#line 3139
    num_to_alloc = 1;
#line 3140
    tmp = gram_alloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 3140
    yy_buffer_stack___0 = (struct yy_buffer_state **)tmp;
    }
#line 3143
    if (! yy_buffer_stack___0) {
      {
#line 3144
      yy_fatal_error___0("out of dynamic memory in gram_ensure_buffer_stack()");
      }
    }
    {
#line 3146
    memset((void *)yy_buffer_stack___0, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 3148
    yy_buffer_stack_max___0 = (size_t )num_to_alloc;
#line 3149
    yy_buffer_stack_top___0 = (size_t )0;
    }
#line 3150
    return;
  }
#line 3153
  if (yy_buffer_stack_top___0 >= yy_buffer_stack_max___0 - 1U) {
    {
#line 3156
    grow_size = 8;
#line 3158
    num_to_alloc = (int )(yy_buffer_stack_max___0 + (size_t )grow_size);
#line 3159
    tmp___0 = gram_realloc((void *)yy_buffer_stack___0, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 3159
    yy_buffer_stack___0 = (struct yy_buffer_state **)tmp___0;
    }
#line 3163
    if (! yy_buffer_stack___0) {
      {
#line 3164
      yy_fatal_error___0("out of dynamic memory in gram_ensure_buffer_stack()");
      }
    }
    {
#line 3167
    memset((void *)(yy_buffer_stack___0 + yy_buffer_stack_max___0), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 3168
    yy_buffer_stack_max___0 = (size_t )num_to_alloc;
    }
  }
#line 3170
  return;
}
}
#line 3180 "scan-gram.c"
YY_BUFFER_STATE gram__scan_buffer(char *base___0 , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 3184
  if (size < 2U) {
#line 3188
    return ((YY_BUFFER_STATE )0);
  } else
#line 3184
  if ((int )*(base___0 + (size - 2U)) != 0) {
#line 3188
    return ((YY_BUFFER_STATE )0);
  } else
#line 3184
  if ((int )*(base___0 + (size - 1U)) != 0) {
#line 3188
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 3190
  tmp = gram_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 3190
  b = (YY_BUFFER_STATE )tmp;
  }
#line 3191
  if (! b) {
    {
#line 3192
    yy_fatal_error___0("out of dynamic memory in gram__scan_buffer()");
    }
  }
  {
#line 3194
  b->yy_buf_size = size - 2U;
#line 3195
  tmp___0 = base___0;
#line 3195
  b->yy_ch_buf = tmp___0;
#line 3195
  b->yy_buf_pos = tmp___0;
#line 3196
  b->yy_is_our_buffer = 0;
#line 3197
  b->yy_input_file = (FILE *)0;
#line 3198
  b->yy_n_chars = (int )b->yy_buf_size;
#line 3199
  b->yy_is_interactive = 0;
#line 3200
  b->yy_at_bol = 1;
#line 3201
  b->yy_fill_buffer = 0;
#line 3202
  b->yy_buffer_status = 0;
#line 3204
  gram__switch_to_buffer(b);
  }
#line 3206
  return (b);
}
}
#line 3219 "scan-gram.c"
YY_BUFFER_STATE gram__scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 3222
  tmp = strlen(yystr);
#line 3222
  tmp___0 = gram__scan_bytes(yystr, (int )tmp);
  }
#line 3222
  return (tmp___0);
}
}
#line 3234 "scan-gram.c"
YY_BUFFER_STATE gram__scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 3242
  n = (yy_size_t )(_yybytes_len + 2);
#line 3243
  tmp = gram_alloc(n);
#line 3243
  buf___0 = (char *)tmp;
  }
#line 3244
  if (! buf___0) {
    {
#line 3245
    yy_fatal_error___0("out of dynamic memory in gram__scan_bytes()");
    }
  }
#line 3247
  i = 0;
  {
#line 3247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3247
    if (! (i < _yybytes_len)) {
#line 3247
      goto while_break;
    }
#line 3248
    *(buf___0 + i) = (char )*(yybytes + i);
#line 3247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3250
  tmp___0 = (char)0;
#line 3250
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 3250
  *(buf___0 + _yybytes_len) = tmp___0;
#line 3252
  b = gram__scan_buffer(buf___0, n);
  }
#line 3253
  if (! b) {
    {
#line 3254
    yy_fatal_error___0("bad buffer in gram__scan_bytes()");
    }
  }
#line 3259
  b->yy_is_our_buffer = 1;
#line 3261
  return (b);
}
}
#line 3270 "scan-gram.c"
static void yy_fatal_error___0(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 3272
  rpl_fprintf(stderr, "%s\n", msg);
#line 3273
  exit(2);
  }
}
}
#line 3305 "scan-gram.c"
int gram_get_lineno(void) 
{ 


  {
#line 3308
  return (gram_lineno);
}
}
#line 3314 "scan-gram.c"
FILE *gram_get_in(void) 
{ 


  {
#line 3316
  return (gram_in);
}
}
#line 3322 "scan-gram.c"
FILE *gram_get_out(void) 
{ 


  {
#line 3324
  return (gram_out);
}
}
#line 3330 "scan-gram.c"
int gram_get_leng(void) 
{ 


  {
#line 3332
  return (gram_leng);
}
}
#line 3339 "scan-gram.c"
char *gram_get_text(void) 
{ 


  {
#line 3341
  return (gram_text);
}
}
#line 3351 "scan-gram.c"
void gram_set_lineno(int line_number ) 
{ 


  {
#line 3354
  gram_lineno = line_number;
#line 3355
  return;
}
}
#line 3363 "scan-gram.c"
void gram_set_in(FILE *in_str ) 
{ 


  {
#line 3365
  gram_in = in_str;
#line 3366
  return;
}
}
#line 3368 "scan-gram.c"
void gram_set_out(FILE *out_str ) 
{ 


  {
#line 3370
  gram_out = out_str;
#line 3371
  return;
}
}
#line 3373 "scan-gram.c"
int gram_get_debug(void) 
{ 


  {
#line 3375
  return (gram__flex_debug);
}
}
#line 3378 "scan-gram.c"
void gram_set_debug(int bdebug ) 
{ 


  {
#line 3380
  gram__flex_debug = bdebug;
#line 3381
  return;
}
}
#line 3391 "scan-gram.c"
static int yy_init_globals___0(void) 
{ 


  {
#line 3397
  yy_buffer_stack___0 = (YY_BUFFER_STATE *)0;
#line 3398
  yy_buffer_stack_top___0 = (size_t )0;
#line 3399
  yy_buffer_stack_max___0 = (size_t )0;
#line 3400
  yy_c_buf_p___0 = (char *)0;
#line 3401
  yy_init___0 = 0;
#line 3402
  yy_start___0 = 0;
#line 3409
  gram_in = (FILE *)0;
#line 3410
  gram_out = (FILE *)0;
#line 3416
  return (0);
}
}
#line 3422 "scan-gram.c"
int gram_lex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 3426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3426
    if (yy_buffer_stack___0) {
#line 3426
      tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
    } else {
#line 3426
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 3426
    if (! tmp___0) {
#line 3426
      goto while_break;
    }
#line 3427
    if (yy_buffer_stack___0) {
#line 3427
      tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
    } else {
#line 3427
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 3427
    gram__delete_buffer(tmp);
#line 3428
    *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = (YY_BUFFER_STATE )((void *)0);
#line 3429
    gram_pop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3433
  gram_free((void *)yy_buffer_stack___0);
#line 3434
  yy_buffer_stack___0 = (YY_BUFFER_STATE *)((void *)0);
#line 3438
  yy_init_globals___0();
  }
#line 3442
  return (0);
}
}
#line 3470 "scan-gram.c"
void *gram_alloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 3472
  tmp = malloc(size);
  }
#line 3472
  return (tmp);
}
}
#line 3475 "scan-gram.c"
void *gram_realloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 3484
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 3484
  return (tmp);
}
}
#line 3487 "scan-gram.c"
void gram_free(void *ptr ) 
{ 


  {
  {
#line 3489
  free((void *)((char *)ptr));
  }
#line 3490
  return;
}
}
#line 722 "scan-gram.l"
static size_t no_cr_read(FILE *fp , char *buf___0 , size_t size ) 
{ 
  size_t bytes_read ;
  size_t tmp ;
  char *w ;
  void *tmp___0 ;
  char const   *r ;
  char const   *lim ;
  int ch ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 725
  tmp = fread_unlocked((void */* __restrict  */)buf___0, (size_t )1, size, (FILE */* __restrict  */)fp);
#line 725
  bytes_read = tmp;
  }
#line 726
  if (bytes_read) {
    {
#line 728
    tmp___0 = memchr((void const   *)buf___0, '\r', bytes_read);
#line 728
    w = (char *)tmp___0;
    }
#line 729
    if (w) {
#line 731
      w ++;
#line 731
      r = (char const   *)w;
#line 732
      lim = (char const   *)(buf___0 + bytes_read);
      {
#line 734
      while (1) {
        while_continue: /* CIL Label */ ;
#line 738
        *(w + -1) = (char )'\n';
#line 739
        if ((unsigned long )r == (unsigned long )lim) {
          {
#line 741
          tmp___1 = getc_unlocked(fp);
#line 741
          ch = tmp___1;
          }
#line 742
          if (ch != 10) {
            {
#line 742
            tmp___2 = ungetc(ch, fp);
            }
#line 742
            if (tmp___2 != ch) {
#line 743
              goto while_break;
            }
          }
        } else
#line 745
        if ((int const   )*r == 10) {
#line 746
          r ++;
        }
        {
#line 749
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 751
          if ((unsigned long )r == (unsigned long )lim) {
#line 752
            return ((size_t )(w - buf___0));
          }
#line 749
          tmp___3 = w;
#line 749
          w ++;
#line 749
          tmp___5 = r;
#line 749
          r ++;
#line 749
          tmp___4 = (char )*tmp___5;
#line 749
          *tmp___3 = tmp___4;
#line 749
          if (! ((int )tmp___4 != 13)) {
#line 749
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 757
      return ((size_t )(w - buf___0));
    }
  }
#line 761
  return (bytes_read);
}
}
#line 770 "scan-gram.l"
static unsigned long scan_integer(char const   *number , int base___0 , location loc___0 ) 
{ 
  unsigned long num ;
  unsigned long tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 774
  tmp = strtoul((char const   */* __restrict  */)number, (char **/* __restrict  */)((void *)0),
                base___0);
#line 774
  num = tmp;
  }
#line 776
  if (2147483647UL < num) {
    {
#line 778
    tmp___0 = quote(number);
#line 778
    tmp___1 = gettext("integer out of range: %s");
#line 778
    complain_at(loc___0, (char const   *)tmp___1, tmp___0);
#line 779
    num = 2147483647UL;
    }
  }
#line 782
  return (num);
}
}
#line 792 "scan-gram.l"
static int convert_ucn_to_byte(char const   *ucn ) 
{ 
  unsigned long code ;
  unsigned long tmp ;

  {
  {
#line 796
  tmp = strtoul((char const   */* __restrict  */)(ucn + 2), (char **/* __restrict  */)((void *)0),
                16);
#line 796
  code = tmp;
  }
#line 804
  if (255UL < code) {
#line 805
    return (-1);
  }
#line 839
  return ((int )code);
}
}
#line 847 "scan-gram.l"
static void handle_syncline(char *args , location loc___0 ) 
{ 
  char *after_num ;
  unsigned long lineno ;
  unsigned long tmp ;
  char *file ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp10 ;

  {
  {
#line 851
  tmp = strtoul((char const   */* __restrict  */)args, (char **/* __restrict  */)(& after_num),
                10);
#line 851
  lineno = tmp;
#line 852
  tmp___0 = mbschr((char const   *)after_num, '\"');
#line 852
  file = tmp___0 + 1;
#line 853
  tmp___1 = mbschr((char const   *)file, '\"');
#line 853
  *tmp___1 = (char )'\000';
  }
#line 854
  if (2147483647UL <= lineno) {
    {
#line 856
    tmp___2 = gettext("line number overflow");
#line 856
    warn_at(loc___0, (char const   *)tmp___2);
#line 857
    lineno = 2147483647UL;
    }
  }
  {
#line 859
  current_file = uniqstr_new((char const   *)file);
#line 860
  boundary_set(& scanner_cursor, current_file, (int )lineno, 1);
  }
#line 861
  return;
}
}
#line 870 "scan-gram.l"
static void unexpected_end(boundary start , char const   *msgid , char const   *token_end ) 
{ 
  location loc___0 ;
  char *tmp ;

  {
  {
#line 874
  loc___0.start = start;
#line 875
  loc___0.end = scanner_cursor;
#line 876
  tmp = gettext(msgid);
#line 876
  complain_at(loc___0, (char const   *)tmp, token_end);
  }
#line 877
  return;
}
}
#line 885 "scan-gram.l"
static void unexpected_eof(boundary start , char const   *token_end ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 888
  unexpected_end(start, "missing `%s\' at end of file", token_end);
  }
#line 889
  return;
}
}
#line 896 "scan-gram.l"
static void unexpected_newline(boundary start , char const   *token_end ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 899
  unexpected_end(start, "missing `%s\' at end of line", token_end);
  }
#line 900
  return;
}
}
#line 907 "scan-gram.l"
void gram_scanner_initialize(void) 
{ 


  {
  {
#line 910
  _obstack_begin(& obstack_for_string___0, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
  }
#line 911
  return;
}
}
#line 918 "scan-gram.l"
void gram_scanner_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 921
  __o = & obstack_for_string___0;
#line 921
  __obj = (void *)0;
#line 921
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 921
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 921
      tmp = (char *)__obj;
#line 921
      __o->object_base = tmp;
#line 921
      __o->next_free = tmp;
    } else {
      {
#line 921
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 921
    obstack_free(__o, __obj);
    }
  }
  {
#line 923
  gram_lex_destroy();
  }
#line 924
  return;
}
}
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 140 "../lib/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 227 "scan-code.c"
int code_leng  ;
#line 232
FILE *code_in ;
#line 232
FILE *code_out ;
#line 339 "scan-code.c"
static size_t yy_buffer_stack_top___1  =    (size_t )0;
#line 340 "scan-code.c"
static size_t yy_buffer_stack_max___1  =    (size_t )0;
#line 341 "scan-code.c"
static YY_BUFFER_STATE *yy_buffer_stack___1  =    (YY_BUFFER_STATE *)0;
#line 368 "scan-code.c"
static char yy_hold_char___1  ;
#line 369 "scan-code.c"
static int yy_n_chars___1  ;
#line 373 "scan-code.c"
static char *yy_c_buf_p___1  =    (char *)0;
#line 374 "scan-code.c"
static int yy_init___1  =    0;
#line 375 "scan-code.c"
static int yy_start___1  =    0;
#line 380 "scan-code.c"
static int yy_did_buffer_switch_on_eof___1  ;
#line 385
void code_restart(FILE *input_file ) ;
#line 386
void code__switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 387
YY_BUFFER_STATE code__create_buffer(FILE *file , int size ) ;
#line 388
void code__delete_buffer(YY_BUFFER_STATE b ) ;
#line 389
void code__flush_buffer(YY_BUFFER_STATE b ) ;
#line 390
void code_push_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 391
void code_pop_buffer_state(void) ;
#line 393
static void code_ensure_buffer_stack(void) ;
#line 394
static void code__load_buffer_state(void) ;
#line 395
static void code__init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 399
YY_BUFFER_STATE code__scan_buffer(char *base___0 , yy_size_t size ) ;
#line 400
YY_BUFFER_STATE code__scan_string(char const   *yystr ) ;
#line 401
YY_BUFFER_STATE code__scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 405
void *code_alloc(yy_size_t size ) ;
#line 406
void *code_realloc(void *ptr , yy_size_t size ) ;
#line 407
void code_free(void *ptr ) ;
#line 443 "scan-code.c"
FILE *code_in  =    (FILE *)0;
#line 443 "scan-code.c"
FILE *code_out  =    (FILE *)0;
#line 447
int code_lineno ;
#line 449 "scan-code.c"
int code_lineno  =    1;
#line 451 "scan-code.c"
char *code_text  ;
#line 456
static yy_state_type yy_get_previous_state___1(void) ;
#line 457
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state ) ;
#line 458
static int yy_get_next_buffer___1(void) ;
#line 459
static void yy_fatal_error___1(char const   *msg ) ;
#line 485 "scan-code.c"
static flex_int16_t const   yy_accept___1[101]  = 
#line 485
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )4, 
        (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )21, 
        (flex_int16_t const   )21,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )35, 
        (flex_int16_t const   )33,      (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )31, 
        (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )2,      (flex_int16_t const   )33, 
        (flex_int16_t const   )6,      (flex_int16_t const   )33,      (flex_int16_t const   )5,      (flex_int16_t const   )26, 
        (flex_int16_t const   )23,      (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )8, 
        (flex_int16_t const   )20,      (flex_int16_t const   )13,      (flex_int16_t const   )7,      (flex_int16_t const   )26, 
        (flex_int16_t const   )17,      (flex_int16_t const   )14,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )15,      (flex_int16_t const   )26,      (flex_int16_t const   )16,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )8,      (flex_int16_t const   )29,      (flex_int16_t const   )7, 
        (flex_int16_t const   )33,      (flex_int16_t const   )30,      (flex_int16_t const   )1,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )4, 
        (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )11,      (flex_int16_t const   )0, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )0,      (flex_int16_t const   )12, 
        (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )12,      (flex_int16_t const   )0, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )0,      (flex_int16_t const   )21, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )11,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )0, 
        (flex_int16_t const   )25,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )24, 
        (flex_int16_t const   )0};
#line 500 "scan-code.c"
static flex_int32_t const   yy_ec___1[256]  = 
#line 500
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )4, 
        (flex_int32_t const   )2,      (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )7, 
        (flex_int32_t const   )8,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )9, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )10,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )1,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )1,      (flex_int32_t const   )17,      (flex_int32_t const   )1, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )22,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )23,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )24,      (flex_int32_t const   )20,      (flex_int32_t const   )25, 
        (flex_int32_t const   )26,      (flex_int32_t const   )27,      (flex_int32_t const   )1,      (flex_int32_t const   )20, 
        (flex_int32_t const   )1,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )28, 
        (flex_int32_t const   )1,      (flex_int32_t const   )29,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 532 "scan-code.c"
static flex_int32_t const   yy_meta___1[31]  = 
#line 532
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4, 
        (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )8, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2};
#line 539 "scan-code.c"
static flex_int16_t const   yy_base___1[112]  = 
#line 539
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )21, 
        (flex_int16_t const   )41,      (flex_int16_t const   )66,      (flex_int16_t const   )0,      (flex_int16_t const   )4, 
        (flex_int16_t const   )8,      (flex_int16_t const   )12,      (flex_int16_t const   )14,      (flex_int16_t const   )93, 
        (flex_int16_t const   )0,      (flex_int16_t const   )121,      (flex_int16_t const   )0,      (flex_int16_t const   )233, 
        (flex_int16_t const   )234,      (flex_int16_t const   )234,      (flex_int16_t const   )234,      (flex_int16_t const   )234, 
        (flex_int16_t const   )234,      (flex_int16_t const   )7,      (flex_int16_t const   )234,      (flex_int16_t const   )0, 
        (flex_int16_t const   )234,      (flex_int16_t const   )39,      (flex_int16_t const   )234,      (flex_int16_t const   )234, 
        (flex_int16_t const   )234,      (flex_int16_t const   )234,      (flex_int16_t const   )234,      (flex_int16_t const   )234, 
        (flex_int16_t const   )234,      (flex_int16_t const   )140,      (flex_int16_t const   )234,      (flex_int16_t const   )34, 
        (flex_int16_t const   )234,      (flex_int16_t const   )42,      (flex_int16_t const   )0,      (flex_int16_t const   )208, 
        (flex_int16_t const   )234,      (flex_int16_t const   )33,      (flex_int16_t const   )234,      (flex_int16_t const   )234, 
        (flex_int16_t const   )234,      (flex_int16_t const   )234,      (flex_int16_t const   )223,      (flex_int16_t const   )234, 
        (flex_int16_t const   )44,      (flex_int16_t const   )222,      (flex_int16_t const   )234,      (flex_int16_t const   )59, 
        (flex_int16_t const   )69,      (flex_int16_t const   )192,      (flex_int16_t const   )234,      (flex_int16_t const   )73, 
        (flex_int16_t const   )185,      (flex_int16_t const   )76,      (flex_int16_t const   )234,      (flex_int16_t const   )189, 
        (flex_int16_t const   )0,      (flex_int16_t const   )156,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )234,      (flex_int16_t const   )234,      (flex_int16_t const   )79,      (flex_int16_t const   )234, 
        (flex_int16_t const   )155,      (flex_int16_t const   )0,      (flex_int16_t const   )143,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )132,      (flex_int16_t const   )83,      (flex_int16_t const   )124, 
        (flex_int16_t const   )234,      (flex_int16_t const   )234,      (flex_int16_t const   )86,      (flex_int16_t const   )19, 
        (flex_int16_t const   )129,      (flex_int16_t const   )133,      (flex_int16_t const   )138,      (flex_int16_t const   )141, 
        (flex_int16_t const   )123,      (flex_int16_t const   )0,      (flex_int16_t const   )129,      (flex_int16_t const   )111, 
        (flex_int16_t const   )164,      (flex_int16_t const   )145,      (flex_int16_t const   )0,      (flex_int16_t const   )101, 
        (flex_int16_t const   )106,      (flex_int16_t const   )170,      (flex_int16_t const   )48,      (flex_int16_t const   )31, 
        (flex_int16_t const   )28,      (flex_int16_t const   )30,      (flex_int16_t const   )1,      (flex_int16_t const   )0, 
        (flex_int16_t const   )234,      (flex_int16_t const   )174,      (flex_int16_t const   )182,      (flex_int16_t const   )188, 
        (flex_int16_t const   )190,      (flex_int16_t const   )194,      (flex_int16_t const   )201,      (flex_int16_t const   )205, 
        (flex_int16_t const   )209,      (flex_int16_t const   )212,      (flex_int16_t const   )216,      (flex_int16_t const   )221};
#line 556 "scan-code.c"
static flex_int16_t const   yy_def___1[112]  = 
#line 556
  {      (flex_int16_t const   )0,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )5,      (flex_int16_t const   )5, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )100, 
        (flex_int16_t const   )11,      (flex_int16_t const   )5,      (flex_int16_t const   )13,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )102,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )103,      (flex_int16_t const   )104,      (flex_int16_t const   )104, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )105,      (flex_int16_t const   )100,      (flex_int16_t const   )106,      (flex_int16_t const   )107, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )108,      (flex_int16_t const   )100,      (flex_int16_t const   )109, 
        (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )102,      (flex_int16_t const   )105,      (flex_int16_t const   )106,      (flex_int16_t const   )110, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )108,      (flex_int16_t const   )111, 
        (flex_int16_t const   )104,      (flex_int16_t const   )100,      (flex_int16_t const   )33,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )104, 
        (flex_int16_t const   )0,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100};
#line 573 "scan-code.c"
static flex_int16_t const   yy_nxt___1[265]  = 
#line 573
  {      (flex_int16_t const   )0,      (flex_int16_t const   )100,      (flex_int16_t const   )52,      (flex_int16_t const   )53, 
        (flex_int16_t const   )52,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )16, 
        (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )24,      (flex_int16_t const   )16, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )24,      (flex_int16_t const   )16, 
        (flex_int16_t const   )100,      (flex_int16_t const   )16,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )50,      (flex_int16_t const   )26,      (flex_int16_t const   )100,      (flex_int16_t const   )26, 
        (flex_int16_t const   )99,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )17,      (flex_int16_t const   )25,      (flex_int16_t const   )21, 
        (flex_int16_t const   )50,      (flex_int16_t const   )51,      (flex_int16_t const   )25,      (flex_int16_t const   )74, 
        (flex_int16_t const   )75,      (flex_int16_t const   )74,      (flex_int16_t const   )25,      (flex_int16_t const   )18, 
        (flex_int16_t const   )25,      (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )55, 
        (flex_int16_t const   )64,      (flex_int16_t const   )51,      (flex_int16_t const   )19,      (flex_int16_t const   )65, 
        (flex_int16_t const   )20,      (flex_int16_t const   )17,      (flex_int16_t const   )67,      (flex_int16_t const   )21, 
        (flex_int16_t const   )98,      (flex_int16_t const   )68,      (flex_int16_t const   )64,      (flex_int16_t const   )67, 
        (flex_int16_t const   )70,      (flex_int16_t const   )65,      (flex_int16_t const   )58,      (flex_int16_t const   )18, 
        (flex_int16_t const   )66,      (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )78, 
        (flex_int16_t const   )100,      (flex_int16_t const   )57,      (flex_int16_t const   )19,      (flex_int16_t const   )71, 
        (flex_int16_t const   )20,      (flex_int16_t const   )22,      (flex_int16_t const   )66,      (flex_int16_t const   )52, 
        (flex_int16_t const   )53,      (flex_int16_t const   )52,      (flex_int16_t const   )17,      (flex_int16_t const   )81, 
        (flex_int16_t const   )56,      (flex_int16_t const   )81,      (flex_int16_t const   )83,      (flex_int16_t const   )84, 
        (flex_int16_t const   )83,      (flex_int16_t const   )88,      (flex_int16_t const   )89,      (flex_int16_t const   )88, 
        (flex_int16_t const   )18,      (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )74, 
        (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )78,      (flex_int16_t const   )19, 
        (flex_int16_t const   )23,      (flex_int16_t const   )20,      (flex_int16_t const   )27,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )27,      (flex_int16_t const   )30,      (flex_int16_t const   )31, 
        (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )34,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )35,      (flex_int16_t const   )27, 
        (flex_int16_t const   )36,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )37, 
        (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )38, 
        (flex_int16_t const   )38,      (flex_int16_t const   )39,      (flex_int16_t const   )40,      (flex_int16_t const   )41, 
        (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )27, 
        (flex_int16_t const   )16,      (flex_int16_t const   )97,      (flex_int16_t const   )100,      (flex_int16_t const   )45, 
        (flex_int16_t const   )67,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )52, 
        (flex_int16_t const   )53,      (flex_int16_t const   )52,      (flex_int16_t const   )48,      (flex_int16_t const   )81, 
        (flex_int16_t const   )56,      (flex_int16_t const   )81,      (flex_int16_t const   )58,      (flex_int16_t const   )49, 
        (flex_int16_t const   )81,      (flex_int16_t const   )56,      (flex_int16_t const   )81,      (flex_int16_t const   )83, 
        (flex_int16_t const   )84,      (flex_int16_t const   )83,      (flex_int16_t const   )94,      (flex_int16_t const   )16, 
        (flex_int16_t const   )58,      (flex_int16_t const   )57,      (flex_int16_t const   )93,      (flex_int16_t const   )59, 
        (flex_int16_t const   )60,      (flex_int16_t const   )92,      (flex_int16_t const   )61,      (flex_int16_t const   )64, 
        (flex_int16_t const   )62,      (flex_int16_t const   )70,      (flex_int16_t const   )65,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )63,      (flex_int16_t const   )88,      (flex_int16_t const   )89, 
        (flex_int16_t const   )88,      (flex_int16_t const   )70,      (flex_int16_t const   )61,      (flex_int16_t const   )66, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )74,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )54, 
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54, 
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )69,      (flex_int16_t const   )69,      (flex_int16_t const   )69, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )86,      (flex_int16_t const   )61, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )87,      (flex_int16_t const   )82, 
        (flex_int16_t const   )87,      (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )90, 
        (flex_int16_t const   )90,      (flex_int16_t const   )91,      (flex_int16_t const   )80,      (flex_int16_t const   )91, 
        (flex_int16_t const   )95,      (flex_int16_t const   )95,      (flex_int16_t const   )95,      (flex_int16_t const   )95, 
        (flex_int16_t const   )95,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96, 
        (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )77,      (flex_int16_t const   )76, 
        (flex_int16_t const   )73,      (flex_int16_t const   )100,      (flex_int16_t const   )15,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100};
#line 606 "scan-code.c"
static flex_int16_t const   yy_chk___1[265]  = 
#line 606
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )7, 
        (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )8,      (flex_int16_t const   )9, 
        (flex_int16_t const   )0,      (flex_int16_t const   )10,      (flex_int16_t const   )1,      (flex_int16_t const   )2, 
        (flex_int16_t const   )21,      (flex_int16_t const   )9,      (flex_int16_t const   )0,      (flex_int16_t const   )10, 
        (flex_int16_t const   )98,      (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )1, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )7,      (flex_int16_t const   )3, 
        (flex_int16_t const   )79,      (flex_int16_t const   )21,      (flex_int16_t const   )8,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )9,      (flex_int16_t const   )3, 
        (flex_int16_t const   )10,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )35,      (flex_int16_t const   )79,      (flex_int16_t const   )3,      (flex_int16_t const   )35, 
        (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )37,      (flex_int16_t const   )4, 
        (flex_int16_t const   )97,      (flex_int16_t const   )37,      (flex_int16_t const   )48,      (flex_int16_t const   )96, 
        (flex_int16_t const   )37,      (flex_int16_t const   )48,      (flex_int16_t const   )95,      (flex_int16_t const   )4, 
        (flex_int16_t const   )35,      (flex_int16_t const   )51,      (flex_int16_t const   )51,      (flex_int16_t const   )51, 
        (flex_int16_t const   )94,      (flex_int16_t const   )25,      (flex_int16_t const   )4,      (flex_int16_t const   )37, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )48,      (flex_int16_t const   )52, 
        (flex_int16_t const   )52,      (flex_int16_t const   )52,      (flex_int16_t const   )5,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )57,      (flex_int16_t const   )57, 
        (flex_int16_t const   )57,      (flex_int16_t const   )66,      (flex_int16_t const   )66,      (flex_int16_t const   )66, 
        (flex_int16_t const   )5,      (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74, 
        (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )5, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )13,      (flex_int16_t const   )92,      (flex_int16_t const   )84,      (flex_int16_t const   )13, 
        (flex_int16_t const   )91,      (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )13,      (flex_int16_t const   )81, 
        (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )87,      (flex_int16_t const   )13, 
        (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )83, 
        (flex_int16_t const   )83,      (flex_int16_t const   )83,      (flex_int16_t const   )86,      (flex_int16_t const   )13, 
        (flex_int16_t const   )33,      (flex_int16_t const   )84,      (flex_int16_t const   )75,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )73,      (flex_int16_t const   )33,      (flex_int16_t const   )89, 
        (flex_int16_t const   )33,      (flex_int16_t const   )70,      (flex_int16_t const   )89,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )88,      (flex_int16_t const   )88, 
        (flex_int16_t const   )88,      (flex_int16_t const   )68,      (flex_int16_t const   )61,      (flex_int16_t const   )89, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101, 
        (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )101,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )103, 
        (flex_int16_t const   )103,      (flex_int16_t const   )103,      (flex_int16_t const   )103,      (flex_int16_t const   )103, 
        (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )105,      (flex_int16_t const   )105, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )106,      (flex_int16_t const   )59, 
        (flex_int16_t const   )106,      (flex_int16_t const   )106,      (flex_int16_t const   )106,      (flex_int16_t const   )106, 
        (flex_int16_t const   )106,      (flex_int16_t const   )106,      (flex_int16_t const   )107,      (flex_int16_t const   )56, 
        (flex_int16_t const   )107,      (flex_int16_t const   )108,      (flex_int16_t const   )108,      (flex_int16_t const   )108, 
        (flex_int16_t const   )108,      (flex_int16_t const   )109,      (flex_int16_t const   )53,      (flex_int16_t const   )109, 
        (flex_int16_t const   )110,      (flex_int16_t const   )110,      (flex_int16_t const   )110,      (flex_int16_t const   )110, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )49,      (flex_int16_t const   )46, 
        (flex_int16_t const   )39,      (flex_int16_t const   )15,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100};
#line 639 "scan-code.c"
static yy_state_type yy_last_accepting_state___1  ;
#line 640 "scan-code.c"
static char *yy_last_accepting_cpos___1  ;
#line 642
int code__flex_debug ;
#line 643 "scan-code.c"
int code__flex_debug  =    1;
#line 645 "scan-code.c"
static flex_int16_t const   yy_rule_linenum___1[34]  = 
#line 645
  {      (flex_int16_t const   )0,      (flex_int16_t const   )125,      (flex_int16_t const   )135,      (flex_int16_t const   )136, 
        (flex_int16_t const   )146,      (flex_int16_t const   )151,      (flex_int16_t const   )156,      (flex_int16_t const   )161, 
        (flex_int16_t const   )166,      (flex_int16_t const   )171,      (flex_int16_t const   )175,      (flex_int16_t const   )183, 
        (flex_int16_t const   )191,      (flex_int16_t const   )199,      (flex_int16_t const   )204,      (flex_int16_t const   )209, 
        (flex_int16_t const   )213,      (flex_int16_t const   )218,      (flex_int16_t const   )219,      (flex_int16_t const   )220, 
        (flex_int16_t const   )243,      (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )247, 
        (flex_int16_t const   )251,      (flex_int16_t const   )259,      (flex_int16_t const   )261,      (flex_int16_t const   )266, 
        (flex_int16_t const   )270,      (flex_int16_t const   )283,      (flex_int16_t const   )284,      (flex_int16_t const   )285, 
        (flex_int16_t const   )286,      (flex_int16_t const   )293};
#line 25 "/home/pronto/abs/test-suite/bison-2.5/src/flex-scanner.h"
int code_get_lineno(void) ;
#line 26
FILE *code_get_in(void) ;
#line 27
FILE *code_get_out(void) ;
#line 28
int code_get_leng(void) ;
#line 29
char *code_get_text(void) ;
#line 30
void code_set_lineno(int line_number ) ;
#line 31
void code_set_in(FILE *in_str ) ;
#line 32
void code_set_out(FILE *out_str ) ;
#line 33
int code_get_debug(void) ;
#line 34
void code_set_debug(int bdebug ) ;
#line 35
int code_lex_destroy(void) ;
#line 74 "/home/pronto/abs/test-suite/bison-2.5/src/flex-scanner.h"
static struct obstack obstack_for_string___1  ;
#line 47 "/home/pronto/abs/test-suite/bison-2.5/src/complain.h"
void ( /* format attribute */  warn_at_indent)(location loc___0 , unsigned int *indent ,
                                               char const   *message  , ...) ;
#line 62
void ( /* format attribute */  complain_at_indent)(location loc___0 , unsigned int *indent ,
                                                   char const   *message  , ...) ;
#line 33 "/home/pronto/abs/test-suite/bison-2.5/src/scan-code.h"
int max_left_semantic_context ;
#line 100
void code_props_plain_init(code_props *self , char const   *code , location code_loc ) ;
#line 135
void code_props_rule_action_init(code_props *self , char const   *code , location code_loc ,
                                 struct symbol_list *rule , named_ref *name ) ;
#line 161
void code_scanner_last_string_free(void) ;
#line 171
void code_scanner_free(void) ;
#line 63 "/home/pronto/abs/test-suite/bison-2.5/src/reader.h"
_Bool union_seen ;
#line 66
_Bool tag_seen ;
#line 33 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
int skeleton_prio ;
#line 42
_Bool locations_flag ;
#line 45
_Bool yacc_flag ;
#line 73
int language_prio ;
#line 45 "scan-code.l"
static char *code_lex(code_props *self , int sc_context ) ;
#line 49
static void handle_action_dollar(symbol_list *rule , char *text , location dollar_loc ) ;
#line 51
static void handle_action_at(symbol_list *rule , char *text , location at_loc ) ;
#line 54 "scan-code.l"
static char *ref_tail_fields  ;
#line 56 "scan-code.l"
static location the_location  ;
#line 57 "scan-code.l"
static location *loc  =    & the_location;
#line 60 "scan-code.l"
static char *code_last_string  ;
#line 63 "scan-code.l"
static _Bool untyped_var_seen  ;
#line 768 "scan-code.c"
static int yy_init_globals___1(void) ;
#line 982 "scan-code.c"
static char *code_lex(code_props *self , int sc_context ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  int braces_level ;
  _Bool need_semicolon ;
  _Bool in_cpp ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  struct obstack *__o___3 ;
  int __len___3 ;
  struct obstack *__o___4 ;
  int __len___4 ;
  struct obstack *__o___5 ;
  int __len___5 ;
  struct obstack *__o___6 ;
  int __len___6 ;
  struct obstack *__o___7 ;
  int __len___7 ;
  struct obstack *__o___8 ;
  int __len___8 ;
  struct obstack *__o___9 ;
  int __len___9 ;
  size_t tmp___0 ;
  struct obstack *__o___10 ;
  int __len___10 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  struct obstack *__o___11 ;
  int __len___11 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  struct obstack *__o___12 ;
  int __len___12 ;
  size_t tmp___5 ;
  struct obstack *__o___13 ;
  int __len___13 ;
  size_t tmp___6 ;
  struct obstack *__o___14 ;
  int __len___14 ;
  size_t tmp___7 ;
  struct obstack *__o___15 ;
  int __len___15 ;
  struct obstack *__o___16 ;
  int __len___16 ;
  _Bool outer_brace ;
  char *tmp___8 ;
  char *tmp___9 ;
  struct obstack *__o___17 ;
  char *tmp___10 ;
  struct obstack *__o___18 ;
  int __len___17 ;
  struct obstack *__o___19 ;
  int __len___18 ;
  struct obstack *__o___20 ;
  int __len___19 ;
  struct obstack *__o___21 ;
  int __len___20 ;
  struct obstack *__o___22 ;
  int __len___21 ;
  struct obstack *__o___23 ;
  int __len___22 ;
  char *tmp___11 ;
  struct obstack *__o___24 ;
  int __len___23 ;
  struct obstack *__o___25 ;
  int __len___24 ;
  struct obstack *__o___26 ;
  int __len___25 ;
  size_t tmp___12 ;
  struct obstack *__o___27 ;
  int __len___26 ;
  size_t tmp___13 ;
  struct obstack *__o___28 ;
  int __len___27 ;
  size_t tmp___14 ;
  struct obstack *__o___29 ;
  int __len___28 ;
  size_t tmp___15 ;
  struct obstack *__o___30 ;
  int __len___29 ;
  size_t tmp___16 ;
  struct obstack *__o___31 ;
  int __len___30 ;
  size_t tmp___17 ;
  struct obstack *__o___32 ;
  int __len___31 ;
  struct obstack *__o___33 ;
  char *tmp___18 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___19 ;
  char *tmp___20 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___21 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;

  {
#line 95 "scan-code.l"
  braces_level = 0;
#line 103
  need_semicolon = (_Bool)0;
#line 108
  in_cpp = (_Bool)0;
#line 113
  if (! (sc_context == 6)) {
#line 113
    if (! (sc_context == 5)) {
#line 113
      if (! (sc_context == 0)) {
        {
#line 113
        __assert_fail("sc_context == 6 || sc_context == 5 || sc_context == 0", "scan-code.l",
                      115U, "code_lex");
        }
      }
    }
  }
#line 116
  yy_start___1 = 1 + 2 * sc_context;
#line 1024
  if (! yy_init___1) {
#line 1026 "scan-code.c"
    yy_init___1 = 1;
#line 1032
    if (! yy_start___1) {
#line 1033
      yy_start___1 = 1;
    }
#line 1035
    if (! code_in) {
#line 1037
      code_in = stdin;
    }
#line 1042
    if (! code_out) {
#line 1044
      code_out = stdout;
    }
#line 1049
    if (yy_buffer_stack___1) {
#line 1049
      tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
    } else {
#line 1049
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1049
    if (! tmp) {
      {
#line 1050
      code_ensure_buffer_stack();
#line 1051
      *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = code__create_buffer(code_in,
                                                                             16384);
      }
    }
    {
#line 1055
    code__load_buffer_state();
    }
  }
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1061
    yy_cp = yy_c_buf_p___1;
#line 1064
    *yy_cp = yy_hold_char___1;
#line 1069
    yy_bp = yy_cp;
#line 1072
    yy_current_state = yy_start___1;
    yy_match: 
    {
#line 1074
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1076
      yy_c = (YY_CHAR )yy_ec___1[(unsigned int )((unsigned char )*yy_cp)];
#line 1077
      if (yy_accept___1[yy_current_state]) {
#line 1079
        yy_last_accepting_state___1 = yy_current_state;
#line 1080
        yy_last_accepting_cpos___1 = yy_cp;
      }
      {
#line 1082
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1082
        if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1082
          goto while_break___1;
        }
#line 1084
        yy_current_state = (int )yy_def___1[yy_current_state];
#line 1085
        if (yy_current_state >= 101) {
#line 1086
          yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1088
      yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1089
      yy_cp ++;
#line 1074
      if (! (yy_current_state != 100)) {
#line 1074
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1092
    yy_cp = yy_last_accepting_cpos___1;
#line 1093
    yy_current_state = yy_last_accepting_state___1;
    yy_find_action: 
#line 1097
    yy_act = (int )yy_accept___1[yy_current_state];
#line 1099
    code_text = yy_bp;
#line 1099
    code_leng = (int )((size_t )(yy_cp - yy_bp));
#line 1099
    yy_hold_char___1 = *yy_cp;
#line 1099
    *yy_cp = (char )'\000';
#line 1099
    yy_c_buf_p___1 = yy_cp;
    do_action: 
#line 1106
    if (code__flex_debug) {
#line 1108
      if (yy_act == 0) {
        {
#line 1109
        rpl_fprintf(stderr, "--scanner backing up\n");
        }
      } else
#line 1110
      if (yy_act < 34) {
        {
#line 1111
        rpl_fprintf(stderr, "--accepting rule at line %ld (\"%s\")\n", (long )yy_rule_linenum___1[yy_act],
                    code_text);
        }
      } else
#line 1113
      if (yy_act == 34) {
        {
#line 1114
        rpl_fprintf(stderr, "--accepting default rule (\"%s\")\n", code_text);
        }
      } else
#line 1116
      if (yy_act == 35) {
        {
#line 1117
        rpl_fprintf(stderr, "--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 1119
        rpl_fprintf(stderr, "--EOF (start condition %d)\n", (yy_start___1 - 1) / 2);
        }
      }
    }
    {
#line 1125
    if (yy_act == 0) {
#line 1125
      goto case_0;
    }
#line 1132
    if (yy_act == 1) {
#line 1132
      goto case_1;
    }
#line 133
    if (yy_act == 2) {
#line 133 "scan-code.l"
      goto case_2;
    }
#line 137
    if (yy_act == 3) {
#line 137
      goto case_3;
    }
#line 144
    if (yy_act == 4) {
#line 144
      goto case_4;
    }
#line 151
    if (yy_act == 5) {
#line 151
      goto case_5;
    }
#line 156
    if (yy_act == 6) {
#line 156
      goto case_6;
    }
#line 160
    if (yy_act == 7) {
#line 160
      goto case_7;
    }
#line 167
    if (yy_act == 8) {
#line 167
      goto case_8;
    }
#line 172
    if (yy_act == 9) {
#line 172
      goto case_9;
    }
#line 176
    if (yy_act == 10) {
#line 176
      goto case_10;
    }
#line 183
    if (yy_act == 11) {
#line 183
      goto case_11;
    }
#line 192
    if (yy_act == 12) {
#line 192
      goto case_12;
    }
#line 200
    if (yy_act == 13) {
#line 200
      goto case_13;
    }
#line 205
    if (yy_act == 14) {
#line 205
      goto case_14;
    }
#line 210
    if (yy_act == 15) {
#line 210
      goto case_15;
    }
#line 214
    if (yy_act == 16) {
#line 214
      goto case_16;
    }
#line 218
    if (yy_act == 17) {
#line 218
      goto case_17;
    }
#line 220
    if (yy_act == 18) {
#line 220
      goto case_18;
    }
#line 221
    if (yy_act == 19) {
#line 221
      goto case_19;
    }
#line 243
    if (yy_act == 20) {
#line 243
      goto case_20;
    }
#line 245
    if (yy_act == 21) {
#line 245
      goto case_21;
    }
#line 247
    if (yy_act == 22) {
#line 247
      goto case_22;
    }
#line 248
    if (yy_act == 23) {
#line 248
      goto case_23;
    }
#line 251
    if (yy_act == 24) {
#line 251
      goto case_24;
    }
#line 259
    if (yy_act == 25) {
#line 259
      goto case_25;
    }
#line 261
    if (yy_act == 26) {
#line 261
      goto case_26;
    }
#line 266
    if (yy_act == 27) {
#line 266
      goto case_27;
    }
#line 271
    if (yy_act == 28) {
#line 271
      goto case_28;
    }
#line 281
    if (yy_act == 29) {
#line 281
      goto case_29;
    }
#line 285
    if (yy_act == 30) {
#line 285
      goto case_30;
    }
#line 286
    if (yy_act == 31) {
#line 286
      goto case_31;
    }
#line 287
    if (yy_act == 32) {
#line 287
      goto case_32;
    }
#line 292
    if (yy_act == 33) {
#line 292
      goto case_33;
    }
#line 302
    if (yy_act == 42) {
#line 302
      goto case_42;
    }
#line 302
    if (yy_act == 41) {
#line 302
      goto case_42;
    }
#line 302
    if (yy_act == 40) {
#line 302
      goto case_42;
    }
#line 302
    if (yy_act == 39) {
#line 302
      goto case_42;
    }
#line 302
    if (yy_act == 38) {
#line 302
      goto case_42;
    }
#line 302
    if (yy_act == 37) {
#line 302
      goto case_42;
    }
#line 302
    if (yy_act == 36) {
#line 302
      goto case_42;
    }
#line 301
    if (yy_act == 34) {
#line 301
      goto case_34;
    }
#line 1440
    if (yy_act == 35) {
#line 1440 "scan-code.c"
      goto case_35;
    }
#line 1564
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1127
    *yy_cp = yy_hold_char___1;
#line 1128
    yy_cp = yy_last_accepting_cpos___1;
#line 1129
    yy_current_state = yy_last_accepting_state___1;
#line 1130
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 1134
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 125 "scan-code.l"
    __o = & obstack_for_string___1;
#line 125
    __len = code_leng;
    }
#line 125
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 125
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 125
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len);
#line 125
    __o->next_free += __len;
#line 125
    yy_start___1 = 1 + 2 * sc_context;
    }
#line 126
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 135
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 135
    __o___0 = & obstack_for_string___1;
#line 135
    __len___0 = code_leng;
    }
#line 135
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 135
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 135
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___0);
#line 135
    __o___0->next_free += __len___0;
#line 135
    yy_start___1 = 1 + 2 * sc_context;
    }
#line 136
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 139
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 136
    __o___1 = & obstack_for_string___1;
#line 136
    __len___1 = code_leng;
    }
#line 136
    if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 136
      _obstack_newchunk(__o___1, __len___1);
      }
    }
    {
#line 136
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___1);
#line 136
    __o___1->next_free += __len___1;
    }
#line 137
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 146
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 146
    __o___2 = & obstack_for_string___1;
#line 146
    __len___2 = code_leng;
    }
#line 146
    if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
      {
#line 146
      _obstack_newchunk(__o___2, __len___2);
      }
    }
    {
#line 146
    memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___2);
#line 146
    __o___2->next_free += __len___2;
    }
#line 147
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 152
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 151
    __o___3 = & obstack_for_string___1;
#line 151
    __len___3 = code_leng;
    }
#line 151
    if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
      {
#line 151
      _obstack_newchunk(__o___3, __len___3);
      }
    }
    {
#line 151
    memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___3);
#line 151
    __o___3->next_free += __len___3;
#line 151
    yy_start___1 = 1 + 2 * sc_context;
    }
#line 152
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 157
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 156
    __o___4 = & obstack_for_string___1;
#line 156
    __len___4 = code_leng;
    }
#line 156
    if ((unsigned long )(__o___4->next_free + __len___4) > (unsigned long )__o___4->chunk_limit) {
      {
#line 156
      _obstack_newchunk(__o___4, __len___4);
      }
    }
    {
#line 156
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___4);
#line 156
    __o___4->next_free += __len___4;
#line 156
    yy_start___1 = 1 + 2 * sc_context;
    }
#line 157
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 161
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 162
    __o___5 = & obstack_for_string___1;
#line 162
    __len___5 = code_leng;
    }
#line 162
    if ((unsigned long )(__o___5->next_free + __len___5) > (unsigned long )__o___5->chunk_limit) {
      {
#line 162
      _obstack_newchunk(__o___5, __len___5);
      }
    }
    {
#line 162
    memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___5);
#line 162
    __o___5->next_free += __len___5;
#line 163
    yy_start___1 = 9;
#line 164
    need_semicolon = (_Bool)1;
    }
#line 166
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 168
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 167
    __o___6 = & obstack_for_string___1;
#line 167
    __len___6 = code_leng;
    }
#line 167
    if ((unsigned long )(__o___6->next_free + __len___6) > (unsigned long )__o___6->chunk_limit) {
      {
#line 167
      _obstack_newchunk(__o___6, __len___6);
      }
    }
    {
#line 167
    memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___6);
#line 167
    __o___6->next_free += __len___6;
#line 168
    yy_start___1 = 7;
#line 169
    need_semicolon = (_Bool)1;
    }
#line 171
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 174
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 172
    __o___7 = & obstack_for_string___1;
#line 172
    __len___7 = code_leng;
    }
#line 172
    if ((unsigned long )(__o___7->next_free + __len___7) > (unsigned long )__o___7->chunk_limit) {
      {
#line 172
      _obstack_newchunk(__o___7, __len___7);
      }
    }
    {
#line 172
    memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___7);
#line 172
    __o___7->next_free += __len___7;
#line 173
    yy_start___1 = 3;
    }
#line 175
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 178
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 176
    __o___8 = & obstack_for_string___1;
#line 176
    __len___8 = code_leng;
    }
#line 176
    if ((unsigned long )(__o___8->next_free + __len___8) > (unsigned long )__o___8->chunk_limit) {
      {
#line 176
      _obstack_newchunk(__o___8, __len___8);
      }
    }
    {
#line 176
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___8);
#line 176
    __o___8->next_free += __len___8;
#line 177
    yy_start___1 = 5;
    }
#line 179
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 184
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 184
    ref_tail_fields = (char *)0;
#line 185
    handle_action_dollar(self->rule, code_text, *loc);
    }
#line 186
    if (ref_tail_fields) {
      {
#line 187
      __o___9 = & obstack_for_string___1;
#line 187
      tmp___0 = strlen((char const   *)ref_tail_fields);
#line 187
      __len___9 = (int )tmp___0;
      }
#line 187
      if ((unsigned long )(__o___9->next_free + __len___9) > (unsigned long )__o___9->chunk_limit) {
        {
#line 187
        _obstack_newchunk(__o___9, __len___9);
        }
      }
      {
#line 187
      memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)ref_tail_fields,
             (size_t )__len___9);
#line 187
      __o___9->next_free += __len___9;
      }
    }
#line 189
    need_semicolon = (_Bool)1;
#line 191
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 193
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 192
    ref_tail_fields = (char *)0;
#line 193
    handle_action_at(self->rule, code_text, *loc);
    }
#line 194
    if (ref_tail_fields) {
      {
#line 195
      __o___10 = & obstack_for_string___1;
#line 195
      tmp___1 = strlen((char const   *)ref_tail_fields);
#line 195
      __len___10 = (int )tmp___1;
      }
#line 195
      if ((unsigned long )(__o___10->next_free + __len___10) > (unsigned long )__o___10->chunk_limit) {
        {
#line 195
        _obstack_newchunk(__o___10, __len___10);
        }
      }
      {
#line 195
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)ref_tail_fields,
             (size_t )__len___10);
#line 195
      __o___10->next_free += __len___10;
      }
    }
#line 197
    need_semicolon = (_Bool)1;
#line 199
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 201
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 200
    tmp___2 = gettext("stray `$\'");
#line 200
    warn_at(*loc, (char const   *)tmp___2);
#line 201
    __o___11 = & obstack_for_string___1;
#line 201
    tmp___3 = strlen("$][");
#line 201
    __len___11 = (int )tmp___3;
    }
#line 201
    if ((unsigned long )(__o___11->next_free + __len___11) > (unsigned long )__o___11->chunk_limit) {
      {
#line 201
      _obstack_newchunk(__o___11, __len___11);
      }
    }
    {
#line 201
    memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)"$][",
           (size_t )__len___11);
#line 201
    __o___11->next_free += __len___11;
#line 202
    need_semicolon = (_Bool)1;
    }
#line 204
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 206
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 205
    tmp___4 = gettext("stray `@\'");
#line 205
    warn_at(*loc, (char const   *)tmp___4);
#line 206
    __o___12 = & obstack_for_string___1;
#line 206
    tmp___5 = strlen("@@");
#line 206
    __len___12 = (int )tmp___5;
    }
#line 206
    if ((unsigned long )(__o___12->next_free + __len___12) > (unsigned long )__o___12->chunk_limit) {
      {
#line 206
      _obstack_newchunk(__o___12, __len___12);
      }
    }
    {
#line 206
    memcpy((void */* __restrict  */)__o___12->next_free, (void const   */* __restrict  */)"@@",
           (size_t )__len___12);
#line 206
    __o___12->next_free += __len___12;
#line 207
    need_semicolon = (_Bool)1;
    }
#line 209
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 211
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 210
    __o___13 = & obstack_for_string___1;
#line 210
    tmp___6 = strlen("@{");
#line 210
    __len___13 = (int )tmp___6;
    }
#line 210
    if ((unsigned long )(__o___13->next_free + __len___13) > (unsigned long )__o___13->chunk_limit) {
      {
#line 210
      _obstack_newchunk(__o___13, __len___13);
      }
    }
    {
#line 210
    memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)"@{",
           (size_t )__len___13);
#line 210
    __o___13->next_free += __len___13;
#line 211
    need_semicolon = (_Bool)1;
    }
#line 213
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 215
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 214
    __o___14 = & obstack_for_string___1;
#line 214
    tmp___7 = strlen("@}");
#line 214
    __len___14 = (int )tmp___7;
    }
#line 214
    if ((unsigned long )(__o___14->next_free + __len___14) > (unsigned long )__o___14->chunk_limit) {
      {
#line 214
      _obstack_newchunk(__o___14, __len___14);
      }
    }
    {
#line 214
    memcpy((void */* __restrict  */)__o___14->next_free, (void const   */* __restrict  */)"@}",
           (size_t )__len___14);
#line 214
    __o___14->next_free += __len___14;
#line 215
    need_semicolon = (_Bool)1;
    }
#line 217
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 219
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 218
    __o___15 = & obstack_for_string___1;
#line 218
    __len___15 = code_leng;
    }
#line 218
    if ((unsigned long )(__o___15->next_free + __len___15) > (unsigned long )__o___15->chunk_limit) {
      {
#line 218
      _obstack_newchunk(__o___15, __len___15);
      }
    }
    {
#line 218
    memcpy((void */* __restrict  */)__o___15->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___15);
#line 218
    __o___15->next_free += __len___15;
#line 218
    need_semicolon = (_Bool)0;
    }
#line 219
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 221
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 219
    __o___16 = & obstack_for_string___1;
#line 219
    __len___16 = code_leng;
    }
#line 219
    if ((unsigned long )(__o___16->next_free + __len___16) > (unsigned long )__o___16->chunk_limit) {
      {
#line 219
      _obstack_newchunk(__o___16, __len___16);
      }
    }
    {
#line 219
    memcpy((void */* __restrict  */)__o___16->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___16);
#line 219
    __o___16->next_free += __len___16;
#line 219
    braces_level ++;
#line 219
    need_semicolon = (_Bool)0;
    }
#line 220
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 222
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 221
    braces_level --;
#line 221
    outer_brace = (_Bool )(braces_level == 0);
    }
#line 227
    if (outer_brace) {
#line 227
      if (! yacc_flag) {
#line 227
        if (language_prio == 2) {
#line 227
          if (skeleton_prio == 2) {
#line 227
            if (need_semicolon) {
#line 227
              if (! in_cpp) {
                {
#line 230
                tmp___8 = gettext("a `;\' might be needed at the end of action code");
#line 230
                warn_at(*loc, (char const   *)tmp___8);
#line 231
                tmp___9 = gettext("future versions of Bison will not add the `;\'");
#line 231
                warn_at(*loc, (char const   *)tmp___9);
#line 232
                __o___17 = & obstack_for_string___1;
                }
#line 232
                if ((unsigned long )(__o___17->next_free + 1) > (unsigned long )__o___17->chunk_limit) {
                  {
#line 232
                  _obstack_newchunk(__o___17, 1);
                  }
                }
#line 232
                tmp___10 = __o___17->next_free;
#line 232
                (__o___17->next_free) ++;
#line 232
                *tmp___10 = (char )';';
              }
            }
          }
        }
      }
    }
#line 235
    __o___18 = & obstack_for_string___1;
#line 235
    __len___17 = code_leng;
#line 235
    if ((unsigned long )(__o___18->next_free + __len___17) > (unsigned long )__o___18->chunk_limit) {
      {
#line 235
      _obstack_newchunk(__o___18, __len___17);
      }
    }
    {
#line 235
    memcpy((void */* __restrict  */)__o___18->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___17);
#line 235
    __o___18->next_free += __len___17;
#line 236
    need_semicolon = (_Bool)0;
    }
#line 238
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 244
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 243
    __o___19 = & obstack_for_string___1;
#line 243
    __len___18 = code_leng;
    }
#line 243
    if ((unsigned long )(__o___19->next_free + __len___18) > (unsigned long )__o___19->chunk_limit) {
      {
#line 243
      _obstack_newchunk(__o___19, __len___18);
      }
    }
    {
#line 243
    memcpy((void */* __restrict  */)__o___19->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___18);
#line 243
    __o___19->next_free += __len___18;
#line 243
    in_cpp = (_Bool)1;
    }
#line 244
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 247
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 245
    __o___20 = & obstack_for_string___1;
#line 245
    __len___19 = code_leng;
    }
#line 245
    if ((unsigned long )(__o___20->next_free + __len___19) > (unsigned long )__o___20->chunk_limit) {
      {
#line 245
      _obstack_newchunk(__o___20, __len___19);
      }
    }
    {
#line 245
    memcpy((void */* __restrict  */)__o___20->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___19);
#line 245
    __o___20->next_free += __len___19;
    }
#line 246
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 249
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 246
    __o___21 = & obstack_for_string___1;
#line 246
    __len___20 = code_leng;
    }
#line 246
    if ((unsigned long )(__o___21->next_free + __len___20) > (unsigned long )__o___21->chunk_limit) {
      {
#line 246
      _obstack_newchunk(__o___21, __len___20);
      }
    }
    {
#line 246
    memcpy((void */* __restrict  */)__o___21->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___20);
#line 246
    __o___21->next_free += __len___20;
    }
#line 246
    if (in_cpp) {
#line 246
      need_semicolon = (_Bool)0;
#line 246
      in_cpp = need_semicolon;
    }
#line 247
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 249
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 247
    __o___22 = & obstack_for_string___1;
#line 247
    __len___21 = code_leng;
    }
#line 247
    if ((unsigned long )(__o___22->next_free + __len___21) > (unsigned long )__o___22->chunk_limit) {
      {
#line 247
      _obstack_newchunk(__o___22, __len___21);
      }
    }
    {
#line 247
    memcpy((void */* __restrict  */)__o___22->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___21);
#line 247
    __o___22->next_free += __len___21;
    }
#line 248
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 252
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 252
    __o___23 = & obstack_for_string___1;
#line 252
    __len___22 = code_leng;
    }
#line 252
    if ((unsigned long )(__o___23->next_free + __len___22) > (unsigned long )__o___23->chunk_limit) {
      {
#line 252
      _obstack_newchunk(__o___23, __len___22);
      }
    }
    {
#line 252
    memcpy((void */* __restrict  */)__o___23->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___22);
#line 252
    __o___23->next_free += __len___22;
#line 252
    need_semicolon = (_Bool)1;
#line 253
    tmp___11 = gettext("use of YYFAIL, which is deprecated and will be removed");
#line 253
    warn_at(*loc, (char const   *)tmp___11);
    }
#line 256
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 260
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 259
    __o___24 = & obstack_for_string___1;
#line 259
    __len___23 = code_leng;
    }
#line 259
    if ((unsigned long )(__o___24->next_free + __len___23) > (unsigned long )__o___24->chunk_limit) {
      {
#line 259
      _obstack_newchunk(__o___24, __len___23);
      }
    }
    {
#line 259
    memcpy((void */* __restrict  */)__o___24->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___23);
#line 259
    __o___24->next_free += __len___23;
#line 259
    need_semicolon = (_Bool)1;
    }
#line 260
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 262
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 261
    __o___25 = & obstack_for_string___1;
#line 261
    __len___24 = code_leng;
    }
#line 261
    if ((unsigned long )(__o___25->next_free + __len___24) > (unsigned long )__o___25->chunk_limit) {
      {
#line 261
      _obstack_newchunk(__o___25, __len___24);
      }
    }
    {
#line 261
    memcpy((void */* __restrict  */)__o___25->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___24);
#line 261
    __o___25->next_free += __len___24;
#line 261
    need_semicolon = (_Bool)1;
    }
#line 262
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 267
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 267
    __o___26 = & obstack_for_string___1;
#line 267
    tmp___12 = strlen("]b4_dollar_dollar[");
#line 267
    __len___25 = (int )tmp___12;
    }
#line 267
    if ((unsigned long )(__o___26->next_free + __len___25) > (unsigned long )__o___26->chunk_limit) {
      {
#line 267
      _obstack_newchunk(__o___26, __len___25);
      }
    }
    {
#line 267
    memcpy((void */* __restrict  */)__o___26->next_free, (void const   */* __restrict  */)"]b4_dollar_dollar[",
           (size_t )__len___25);
#line 267
    __o___26->next_free += __len___25;
#line 268
    self->is_value_used = (_Bool)1;
    }
#line 270
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 272
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 271
    __o___27 = & obstack_for_string___1;
#line 271
    tmp___13 = strlen("]b4_at_dollar[");
#line 271
    __len___26 = (int )tmp___13;
    }
#line 271
    if ((unsigned long )(__o___27->next_free + __len___26) > (unsigned long )__o___27->chunk_limit) {
      {
#line 271
      _obstack_newchunk(__o___27, __len___26);
      }
    }
    {
#line 271
    memcpy((void */* __restrict  */)__o___27->next_free, (void const   */* __restrict  */)"]b4_at_dollar[",
           (size_t )__len___26);
#line 271
    __o___27->next_free += __len___26;
#line 272
    locations_flag = (_Bool)1;
    }
#line 274
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 282
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 283
    __o___28 = & obstack_for_string___1;
#line 283
    tmp___14 = strlen("$][");
#line 283
    __len___27 = (int )tmp___14;
    }
#line 283
    if ((unsigned long )(__o___28->next_free + __len___27) > (unsigned long )__o___28->chunk_limit) {
      {
#line 283
      _obstack_newchunk(__o___28, __len___27);
      }
    }
    {
#line 283
    memcpy((void */* __restrict  */)__o___28->next_free, (void const   */* __restrict  */)"$][",
           (size_t )__len___27);
#line 283
    __o___28->next_free += __len___27;
    }
#line 284
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 286
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 284
    __o___29 = & obstack_for_string___1;
#line 284
    tmp___15 = strlen("@@");
#line 284
    __len___28 = (int )tmp___15;
    }
#line 284
    if ((unsigned long )(__o___29->next_free + __len___28) > (unsigned long )__o___29->chunk_limit) {
      {
#line 284
      _obstack_newchunk(__o___29, __len___28);
      }
    }
    {
#line 284
    memcpy((void */* __restrict  */)__o___29->next_free, (void const   */* __restrict  */)"@@",
           (size_t )__len___28);
#line 284
    __o___29->next_free += __len___28;
    }
#line 285
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 287
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 285
    __o___30 = & obstack_for_string___1;
#line 285
    tmp___16 = strlen("@{");
#line 285
    __len___29 = (int )tmp___16;
    }
#line 285
    if ((unsigned long )(__o___30->next_free + __len___29) > (unsigned long )__o___30->chunk_limit) {
      {
#line 285
      _obstack_newchunk(__o___30, __len___29);
      }
    }
    {
#line 285
    memcpy((void */* __restrict  */)__o___30->next_free, (void const   */* __restrict  */)"@{",
           (size_t )__len___29);
#line 285
    __o___30->next_free += __len___29;
    }
#line 286
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 288
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 286
    __o___31 = & obstack_for_string___1;
#line 286
    tmp___17 = strlen("@}");
#line 286
    __len___30 = (int )tmp___17;
    }
#line 286
    if ((unsigned long )(__o___31->next_free + __len___30) > (unsigned long )__o___31->chunk_limit) {
      {
#line 286
      _obstack_newchunk(__o___31, __len___30);
      }
    }
    {
#line 286
    memcpy((void */* __restrict  */)__o___31->next_free, (void const   */* __restrict  */)"@}",
           (size_t )__len___30);
#line 286
    __o___31->next_free += __len___30;
    }
#line 287
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 294
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 293
    __o___32 = & obstack_for_string___1;
#line 293
    __len___31 = code_leng;
    }
#line 293
    if ((unsigned long )(__o___32->next_free + __len___31) > (unsigned long )__o___32->chunk_limit) {
      {
#line 293
      _obstack_newchunk(__o___32, __len___31);
      }
    }
    {
#line 293
    memcpy((void */* __restrict  */)__o___32->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___31);
#line 293
    __o___32->next_free += __len___31;
    }
#line 294
    goto switch_break;
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    {
#line 297
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 297
      __o___33 = & obstack_for_string___1;
#line 297
      if ((unsigned long )(__o___33->next_free + 1) > (unsigned long )__o___33->chunk_limit) {
        {
#line 297
        _obstack_newchunk(__o___33, 1);
        }
      }
#line 297
      tmp___18 = __o___33->next_free;
#line 297
      (__o___33->next_free) ++;
#line 297
      *tmp___18 = (char )'\000';
#line 297
      __o1 = & obstack_for_string___1;
#line 297
      __value = (void *)__o1->object_base;
#line 297
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 297
        __o1->maybe_empty_object = 1U;
      }
#line 297
      if (sizeof(int ) < sizeof(void *)) {
#line 297
        tmp___19 = __o1->object_base;
      } else {
#line 297
        tmp___19 = (char *)0;
      }
#line 297
      if (sizeof(int ) < sizeof(void *)) {
#line 297
        tmp___20 = __o1->object_base;
      } else {
#line 297
        tmp___20 = (char *)0;
      }
#line 297
      __o1->next_free = tmp___19 + (((__o1->next_free - tmp___20) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 297
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 297
        __o1->next_free = __o1->chunk_limit;
      }
#line 297
      __o1->object_base = __o1->next_free;
#line 297
      code_last_string = (char *)__value;
#line 297
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 298
    return (code_last_string);
#line 300
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 302
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 301
    yy_fatal_error___1("flex scanner jammed");
    }
#line 302
    goto switch_break;
    case_35: /* CIL Label */ 
#line 1443 "scan-code.c"
    yy_amount_of_matched_text = (int )(yy_cp - code_text) - 1;
#line 1446
    *yy_cp = yy_hold_char___1;
#line 1449
    if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status == 0) {
#line 1460
      yy_n_chars___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars;
#line 1461
      (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_input_file = code_in;
#line 1462
      (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status = 1;
    }
#line 1472
    if ((unsigned long )yy_c_buf_p___1 <= (unsigned long )((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + yy_n_chars___1)) {
      {
#line 1476
      yy_c_buf_p___1 = code_text + yy_amount_of_matched_text;
#line 1478
      yy_current_state = yy_get_previous_state___1();
#line 1489
      yy_next_state = yy_try_NUL_trans___1(yy_current_state);
#line 1491
      yy_bp = code_text + 0;
      }
#line 1493
      if (yy_next_state) {
#line 1496
        yy_c_buf_p___1 ++;
#line 1496
        yy_cp = yy_c_buf_p___1;
#line 1497
        yy_current_state = yy_next_state;
#line 1498
        goto yy_match;
      } else {
#line 1504
        yy_cp = yy_last_accepting_cpos___1;
#line 1505
        yy_current_state = yy_last_accepting_state___1;
#line 1506
        goto yy_find_action;
      }
    } else {
      {
#line 1510
      tmp___21 = yy_get_next_buffer___1();
      }
      {
#line 1512
      if (tmp___21 == 1) {
#line 1512
        goto case_1___0;
      }
#line 1541
      if (tmp___21 == 0) {
#line 1541
        goto case_0___0;
      }
#line 1551
      if (tmp___21 == 2) {
#line 1551
        goto case_2___0;
      }
#line 1510
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1514
      yy_did_buffer_switch_on_eof___1 = 0;
#line 1527
      yy_c_buf_p___1 = code_text + 0;
#line 1529
      yy_act = (35 + (yy_start___1 - 1) / 2) + 1;
#line 1530
      goto do_action;
#line 1538
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1542
      yy_c_buf_p___1 = code_text + yy_amount_of_matched_text;
#line 1545
      yy_current_state = yy_get_previous_state___1();
#line 1547
      yy_cp = yy_c_buf_p___1;
#line 1548
      yy_bp = code_text + 0;
      }
#line 1549
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1552
      yy_c_buf_p___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + yy_n_chars___1;
#line 1555
      yy_current_state = yy_get_previous_state___1();
#line 1557
      yy_cp = yy_c_buf_p___1;
#line 1558
      yy_bp = code_text + 0;
      }
#line 1559
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1561
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1565
    yy_fatal_error___1("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1587 "scan-code.c"
static int yy_get_next_buffer___1(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1592
  dest = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf;
#line 1593
  source = code_text;
#line 1597
  if ((unsigned long )yy_c_buf_p___1 > (unsigned long )((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + (yy_n_chars___1 + 1))) {
    {
#line 1598
    yy_fatal_error___1("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1601
  if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_fill_buffer == 0) {
#line 1603
    if (yy_c_buf_p___1 - code_text == 1L) {
#line 1608
      return (1);
    } else {
#line 1616
      return (2);
    }
  }
#line 1623
  number_to_move = (int )(yy_c_buf_p___1 - code_text) - 1;
#line 1625
  i = 0;
  {
#line 1625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if (! (i < number_to_move)) {
#line 1625
      goto while_break;
    }
#line 1626
    tmp = dest;
#line 1626
    dest ++;
#line 1626
    tmp___0 = source;
#line 1626
    source ++;
#line 1626
    *tmp = *tmp___0;
#line 1625
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1628
  if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status == 2) {
#line 1632
    yy_n_chars___1 = 0;
#line 1632
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  } else {
#line 1636
    num_to_read = (int )(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1639
      if (! (num_to_read <= 0)) {
#line 1639
        goto while_break___0;
      }
#line 1643
      if (yy_buffer_stack___1) {
#line 1643
        tmp___1 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
      } else {
#line 1643
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1643
      b = tmp___1;
#line 1645
      yy_c_buf_p_offset = (int )(yy_c_buf_p___1 - b->yy_ch_buf);
#line 1648
      if (b->yy_is_our_buffer) {
#line 1650
        new_size = (int )(b->yy_buf_size * 2U);
#line 1652
        if (new_size <= 0) {
#line 1653
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1655
          b->yy_buf_size *= 2U;
        }
        {
#line 1657
        tmp___2 = code_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1657
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1663
        b->yy_ch_buf = (char *)0;
      }
#line 1665
      if (! b->yy_ch_buf) {
        {
#line 1666
        yy_fatal_error___1("fatal error - scanner input buffer overflow");
        }
      }
#line 1669
      yy_c_buf_p___1 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1671
      num_to_read = (int )(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1676
    if (num_to_read > 8192) {
#line 1677
      num_to_read = 8192;
    }
#line 1680
    if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_is_interactive) {
#line 1680
      c = '*';
#line 1680
      n = (size_t )0;
      {
#line 1680
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1680
        if (n < (size_t )num_to_read) {
          {
#line 1680
          c = getc_unlocked(code_in);
          }
#line 1680
          if (c != -1) {
#line 1680
            if (! (c != 10)) {
#line 1680
              goto while_break___1;
            }
          } else {
#line 1680
            goto while_break___1;
          }
        } else {
#line 1680
          goto while_break___1;
        }
#line 1680
        *(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1680
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1680
      if (c == 10) {
#line 1680
        tmp___3 = n;
#line 1680
        n ++;
#line 1680
        *(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1680
      if (c == -1) {
        {
#line 1680
        tmp___4 = ferror_unlocked(code_in);
        }
#line 1680
        if (tmp___4) {
          {
#line 1680
          yy_fatal_error___1("input in flex scanner failed");
          }
        }
      }
#line 1680
      yy_n_chars___1 = (int )n;
    } else {
      {
#line 1680
      tmp___5 = __errno_location();
#line 1680
      *tmp___5 = 0;
      }
      {
#line 1680
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1680
        tmp___8 = fread_unlocked((void */* __restrict  */)((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move),
                                 (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)code_in);
#line 1680
        yy_n_chars___1 = (int )tmp___8;
        }
#line 1680
        if (yy_n_chars___1 == 0) {
          {
#line 1680
          tmp___9 = ferror_unlocked(code_in);
          }
#line 1680
          if (! tmp___9) {
#line 1680
            goto while_break___2;
          }
        } else {
#line 1680
          goto while_break___2;
        }
        {
#line 1680
        tmp___6 = __errno_location();
        }
#line 1680
        if (*tmp___6 != 4) {
          {
#line 1680
          yy_fatal_error___1("input in flex scanner failed");
          }
#line 1680
          goto while_break___2;
        }
        {
#line 1680
        tmp___7 = __errno_location();
#line 1680
        *tmp___7 = 0;
#line 1680
        clearerr_unlocked(code_in);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1683
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  }
#line 1686
  if (yy_n_chars___1 == 0) {
#line 1688
    if (number_to_move == 0) {
      {
#line 1690
      ret_val = 1;
#line 1691
      code_restart(code_in);
      }
    } else {
#line 1696
      ret_val = 2;
#line 1697
      (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status = 2;
    }
  } else {
#line 1703
    ret_val = 0;
  }
#line 1705
  if ((yy_size_t )(yy_n_chars___1 + number_to_move) > (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size) {
    {
#line 1707
    new_size___0 = (yy_size_t )((yy_n_chars___1 + number_to_move) + (yy_n_chars___1 >> 1));
#line 1708
    tmp___10 = code_realloc((void *)(*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf,
                            new_size___0);
#line 1708
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf = (char *)tmp___10;
    }
#line 1709
    if (! (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf) {
      {
#line 1710
      yy_fatal_error___1("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1713
  yy_n_chars___1 += number_to_move;
#line 1714
  *((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + yy_n_chars___1) = (char)0;
#line 1715
  *((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + (yy_n_chars___1 + 1)) = (char)0;
#line 1717
  code_text = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + 0;
#line 1719
  return (ret_val);
}
}
#line 1727 "scan-code.c"
static yy_state_type yy_get_previous_state___1(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1736
  yy_current_state = yy_start___1;
#line 1738
  yy_cp = code_text + 0;
  {
#line 1738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1738
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p___1)) {
#line 1738
      goto while_break;
    }
#line 1741
    if (*yy_cp) {
#line 1741
      tmp = yy_ec___1[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1741
      tmp = (flex_int32_t const   )30;
    }
#line 1741
    yy_c = (YY_CHAR )tmp;
#line 1742
    if (yy_accept___1[yy_current_state]) {
#line 1744
      yy_last_accepting_state___1 = yy_current_state;
#line 1745
      yy_last_accepting_cpos___1 = yy_cp;
    }
    {
#line 1747
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1747
      if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1747
        goto while_break___0;
      }
#line 1749
      yy_current_state = (int )yy_def___1[yy_current_state];
#line 1750
      if (yy_current_state >= 101) {
#line 1751
        yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1753
    yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1738
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1756
  return (yy_current_state);
}
}
#line 1765 "scan-code.c"
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1772
  yy_cp = yy_c_buf_p___1;
#line 1774
  yy_c = (YY_CHAR )30;
#line 1775
  if (yy_accept___1[yy_current_state]) {
#line 1777
    yy_last_accepting_state___1 = yy_current_state;
#line 1778
    yy_last_accepting_cpos___1 = yy_cp;
  }
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1780
    if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1780
      goto while_break;
    }
#line 1782
    yy_current_state = (int )yy_def___1[yy_current_state];
#line 1783
    if (yy_current_state >= 101) {
#line 1784
      yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1786
  yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1787
  yy_is_jam = yy_current_state == 100;
#line 1789
  if (yy_is_jam) {
#line 1789
    tmp = 0;
  } else {
#line 1789
    tmp = yy_current_state;
  }
#line 1789
  return (tmp);
}
}
#line 1884 "scan-code.c"
void code_restart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1890
  if (yy_buffer_stack___1) {
#line 1890
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1890
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1890
  if (! tmp) {
    {
#line 1891
    code_ensure_buffer_stack();
#line 1892
    *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = code__create_buffer(code_in,
                                                                           16384);
    }
  }
#line 1896
  if (yy_buffer_stack___1) {
#line 1896
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1896
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1896
  code__init_buffer(tmp___0, input_file);
#line 1897
  code__load_buffer_state();
  }
#line 1898
  return;
}
}
#line 1905 "scan-code.c"
void code__switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1916
  code_ensure_buffer_stack();
  }
#line 1917
  if (yy_buffer_stack___1) {
#line 1917
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1917
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1917
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1918
    return;
  }
#line 1920
  if (yy_buffer_stack___1) {
#line 1920
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1920
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1920
  if (tmp___0) {
#line 1923
    *yy_c_buf_p___1 = yy_hold_char___1;
#line 1924
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_pos = yy_c_buf_p___1;
#line 1925
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  }
  {
#line 1928
  *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = new_buffer;
#line 1929
  code__load_buffer_state();
#line 1936
  yy_did_buffer_switch_on_eof___1 = 1;
  }
#line 1937
  return;
}
}
#line 1940 "scan-code.c"
static void code__load_buffer_state(void) 
{ 


  {
#line 1945
  yy_n_chars___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars;
#line 1946
  yy_c_buf_p___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_pos;
#line 1946
  code_text = yy_c_buf_p___1;
#line 1947
  code_in = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_input_file;
#line 1948
  yy_hold_char___1 = *yy_c_buf_p___1;
#line 1949
  return;
}
}
#line 1958 "scan-code.c"
YY_BUFFER_STATE code__create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1965
  tmp = code_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1965
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1966
  if (! b) {
    {
#line 1967
    yy_fatal_error___1("out of dynamic memory in code__create_buffer()");
    }
  }
  {
#line 1969
  b->yy_buf_size = (yy_size_t )size;
#line 1974
  tmp___0 = code_alloc(b->yy_buf_size + 2U);
#line 1974
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1975
  if (! b->yy_ch_buf) {
    {
#line 1976
    yy_fatal_error___1("out of dynamic memory in code__create_buffer()");
    }
  }
  {
#line 1978
  b->yy_is_our_buffer = 1;
#line 1980
  code__init_buffer(b, file);
  }
#line 1982
  return (b);
}
}
#line 1990 "scan-code.c"
void code__delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1996
  if (! b) {
#line 1997
    return;
  }
#line 1999
  if (yy_buffer_stack___1) {
#line 1999
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1999
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1999
  if ((unsigned long )b == (unsigned long )tmp) {
#line 2000
    *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = (YY_BUFFER_STATE )0;
  }
#line 2002
  if (b->yy_is_our_buffer) {
    {
#line 2003
    code_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 2005
  code_free((void *)b);
  }
#line 2006
  return;
}
}
#line 2020 "scan-code.c"
static void code__init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 2026
  tmp = __errno_location();
#line 2026
  oerrno = *tmp;
#line 2028
  code__flush_buffer(b);
#line 2030
  b->yy_input_file = file;
#line 2031
  b->yy_fill_buffer = 1;
  }
#line 2037
  if (yy_buffer_stack___1) {
#line 2037
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 2037
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2037
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 2038
    b->yy_bs_lineno = 1;
#line 2039
    b->yy_bs_column = 0;
  }
  {
#line 2044
  b->yy_is_interactive = 0;
#line 2049
  tmp___1 = __errno_location();
#line 2049
  *tmp___1 = oerrno;
  }
#line 2050
  return;
}
}
#line 2057 "scan-code.c"
void code__flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 2062
  if (! b) {
#line 2063
    return;
  }
#line 2065
  b->yy_n_chars = 0;
#line 2071
  *(b->yy_ch_buf + 0) = (char)0;
#line 2072
  *(b->yy_ch_buf + 1) = (char)0;
#line 2074
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2076
  b->yy_at_bol = 1;
#line 2077
  b->yy_buffer_status = 0;
#line 2079
  if (yy_buffer_stack___1) {
#line 2079
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 2079
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2079
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2080
    code__load_buffer_state();
    }
  }
#line 2081
  return;
}
}
#line 2091 "scan-code.c"
void code_push_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2096
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2097
    return;
  }
  {
#line 2099
  code_ensure_buffer_stack();
  }
#line 2102
  if (yy_buffer_stack___1) {
#line 2102
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 2102
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2102
  if (tmp) {
#line 2105
    *yy_c_buf_p___1 = yy_hold_char___1;
#line 2106
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_pos = yy_c_buf_p___1;
#line 2107
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  }
#line 2111
  if (yy_buffer_stack___1) {
#line 2111
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 2111
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2111
  if (tmp___0) {
#line 2112
    yy_buffer_stack_top___1 ++;
  }
  {
#line 2113
  *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = new_buffer;
#line 2116
  code__load_buffer_state();
#line 2117
  yy_did_buffer_switch_on_eof___1 = 1;
  }
#line 2118
  return;
}
}
#line 2127 "scan-code.c"
void code_pop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2132
  if (yy_buffer_stack___1) {
#line 2132
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 2132
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2132
  if (! tmp) {
#line 2133
    return;
  }
#line 2135
  if (yy_buffer_stack___1) {
#line 2135
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 2135
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2135
  code__delete_buffer(tmp___0);
#line 2136
  *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2137
  if (yy_buffer_stack_top___1 > 0U) {
#line 2138
    yy_buffer_stack_top___1 --;
  }
#line 2140
  if (yy_buffer_stack___1) {
#line 2140
    tmp___1 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 2140
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2140
  if (tmp___1) {
    {
#line 2141
    code__load_buffer_state();
#line 2142
    yy_did_buffer_switch_on_eof___1 = 1;
    }
  }
#line 2144
  return;
}
}
#line 2152 "scan-code.c"
static void code_ensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2159
  if (! yy_buffer_stack___1) {
    {
#line 2165
    num_to_alloc = 1;
#line 2166
    tmp = code_alloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2166
    yy_buffer_stack___1 = (struct yy_buffer_state **)tmp;
    }
#line 2169
    if (! yy_buffer_stack___1) {
      {
#line 2170
      yy_fatal_error___1("out of dynamic memory in code_ensure_buffer_stack()");
      }
    }
    {
#line 2172
    memset((void *)yy_buffer_stack___1, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2174
    yy_buffer_stack_max___1 = (size_t )num_to_alloc;
#line 2175
    yy_buffer_stack_top___1 = (size_t )0;
    }
#line 2176
    return;
  }
#line 2179
  if (yy_buffer_stack_top___1 >= yy_buffer_stack_max___1 - 1U) {
    {
#line 2182
    grow_size = 8;
#line 2184
    num_to_alloc = (int )(yy_buffer_stack_max___1 + (size_t )grow_size);
#line 2185
    tmp___0 = code_realloc((void *)yy_buffer_stack___1, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2185
    yy_buffer_stack___1 = (struct yy_buffer_state **)tmp___0;
    }
#line 2189
    if (! yy_buffer_stack___1) {
      {
#line 2190
      yy_fatal_error___1("out of dynamic memory in code_ensure_buffer_stack()");
      }
    }
    {
#line 2193
    memset((void *)(yy_buffer_stack___1 + yy_buffer_stack_max___1), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 2194
    yy_buffer_stack_max___1 = (size_t )num_to_alloc;
    }
  }
#line 2196
  return;
}
}
#line 2206 "scan-code.c"
YY_BUFFER_STATE code__scan_buffer(char *base___0 , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 2210
  if (size < 2U) {
#line 2214
    return ((YY_BUFFER_STATE )0);
  } else
#line 2210
  if ((int )*(base___0 + (size - 2U)) != 0) {
#line 2214
    return ((YY_BUFFER_STATE )0);
  } else
#line 2210
  if ((int )*(base___0 + (size - 1U)) != 0) {
#line 2214
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2216
  tmp = code_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 2216
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2217
  if (! b) {
    {
#line 2218
    yy_fatal_error___1("out of dynamic memory in code__scan_buffer()");
    }
  }
  {
#line 2220
  b->yy_buf_size = size - 2U;
#line 2221
  tmp___0 = base___0;
#line 2221
  b->yy_ch_buf = tmp___0;
#line 2221
  b->yy_buf_pos = tmp___0;
#line 2222
  b->yy_is_our_buffer = 0;
#line 2223
  b->yy_input_file = (FILE *)0;
#line 2224
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2225
  b->yy_is_interactive = 0;
#line 2226
  b->yy_at_bol = 1;
#line 2227
  b->yy_fill_buffer = 0;
#line 2228
  b->yy_buffer_status = 0;
#line 2230
  code__switch_to_buffer(b);
  }
#line 2232
  return (b);
}
}
#line 2245 "scan-code.c"
YY_BUFFER_STATE code__scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2248
  tmp = strlen(yystr);
#line 2248
  tmp___0 = code__scan_bytes(yystr, (int )tmp);
  }
#line 2248
  return (tmp___0);
}
}
#line 2260 "scan-code.c"
YY_BUFFER_STATE code__scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2268
  n = (yy_size_t )(_yybytes_len + 2);
#line 2269
  tmp = code_alloc(n);
#line 2269
  buf___0 = (char *)tmp;
  }
#line 2270
  if (! buf___0) {
    {
#line 2271
    yy_fatal_error___1("out of dynamic memory in code__scan_bytes()");
    }
  }
#line 2273
  i = 0;
  {
#line 2273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2273
    if (! (i < _yybytes_len)) {
#line 2273
      goto while_break;
    }
#line 2274
    *(buf___0 + i) = (char )*(yybytes + i);
#line 2273
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2276
  tmp___0 = (char)0;
#line 2276
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 2276
  *(buf___0 + _yybytes_len) = tmp___0;
#line 2278
  b = code__scan_buffer(buf___0, n);
  }
#line 2279
  if (! b) {
    {
#line 2280
    yy_fatal_error___1("bad buffer in code__scan_bytes()");
    }
  }
#line 2285
  b->yy_is_our_buffer = 1;
#line 2287
  return (b);
}
}
#line 2296 "scan-code.c"
static void yy_fatal_error___1(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 2298
  rpl_fprintf(stderr, "%s\n", msg);
#line 2299
  exit(2);
  }
}
}
#line 2331 "scan-code.c"
int code_get_lineno(void) 
{ 


  {
#line 2334
  return (code_lineno);
}
}
#line 2340 "scan-code.c"
FILE *code_get_in(void) 
{ 


  {
#line 2342
  return (code_in);
}
}
#line 2348 "scan-code.c"
FILE *code_get_out(void) 
{ 


  {
#line 2350
  return (code_out);
}
}
#line 2356 "scan-code.c"
int code_get_leng(void) 
{ 


  {
#line 2358
  return (code_leng);
}
}
#line 2365 "scan-code.c"
char *code_get_text(void) 
{ 


  {
#line 2367
  return (code_text);
}
}
#line 2377 "scan-code.c"
void code_set_lineno(int line_number ) 
{ 


  {
#line 2380
  code_lineno = line_number;
#line 2381
  return;
}
}
#line 2389 "scan-code.c"
void code_set_in(FILE *in_str ) 
{ 


  {
#line 2391
  code_in = in_str;
#line 2392
  return;
}
}
#line 2394 "scan-code.c"
void code_set_out(FILE *out_str ) 
{ 


  {
#line 2396
  code_out = out_str;
#line 2397
  return;
}
}
#line 2399 "scan-code.c"
int code_get_debug(void) 
{ 


  {
#line 2401
  return (code__flex_debug);
}
}
#line 2404 "scan-code.c"
void code_set_debug(int bdebug ) 
{ 


  {
#line 2406
  code__flex_debug = bdebug;
#line 2407
  return;
}
}
#line 2417 "scan-code.c"
static int yy_init_globals___1(void) 
{ 


  {
#line 2423
  yy_buffer_stack___1 = (YY_BUFFER_STATE *)0;
#line 2424
  yy_buffer_stack_top___1 = (size_t )0;
#line 2425
  yy_buffer_stack_max___1 = (size_t )0;
#line 2426
  yy_c_buf_p___1 = (char *)0;
#line 2427
  yy_init___1 = 0;
#line 2428
  yy_start___1 = 0;
#line 2435
  code_in = (FILE *)0;
#line 2436
  code_out = (FILE *)0;
#line 2442
  return (0);
}
}
#line 2448 "scan-code.c"
int code_lex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2452
    if (yy_buffer_stack___1) {
#line 2452
      tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
    } else {
#line 2452
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2452
    if (! tmp___0) {
#line 2452
      goto while_break;
    }
#line 2453
    if (yy_buffer_stack___1) {
#line 2453
      tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
    } else {
#line 2453
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2453
    code__delete_buffer(tmp);
#line 2454
    *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = (YY_BUFFER_STATE )((void *)0);
#line 2455
    code_pop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2459
  code_free((void *)yy_buffer_stack___1);
#line 2460
  yy_buffer_stack___1 = (YY_BUFFER_STATE *)((void *)0);
#line 2464
  yy_init_globals___1();
  }
#line 2468
  return (0);
}
}
#line 2496 "scan-code.c"
void *code_alloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2498
  tmp = malloc(size);
  }
#line 2498
  return (tmp);
}
}
#line 2501 "scan-code.c"
void *code_realloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2510
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2510
  return (tmp);
}
}
#line 2513 "scan-code.c"
void code_free(void *ptr ) 
{ 


  {
  {
#line 2515
  free((void *)((char *)ptr));
  }
#line 2516
  return;
}
}
#line 304 "scan-code.l"
__inline static _Bool is_dot_or_dash(char ch ) 
{ 
  int tmp ;

  {
#line 307
  if ((int )ch == 46) {
#line 307
    tmp = 1;
  } else
#line 307
  if ((int )ch == 45) {
#line 307
    tmp = 1;
  } else {
#line 307
    tmp = 0;
  }
#line 307
  return ((_Bool )tmp);
}
}
#line 310 "scan-code.l"
__inline static _Bool contains_dot_or_dash(char const   *p ) 
{ 
  _Bool tmp ;

  {
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! *p) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = is_dot_or_dash((char )*p);
    }
#line 314
    if (tmp) {
#line 315
      return ((_Bool)1);
    }
#line 313
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return ((_Bool)0);
}
}
#line 349 "scan-code.l"
static variant *variant_table  =    (variant *)0;
#line 350 "scan-code.l"
static unsigned int variant_table_size  =    0U;
#line 351 "scan-code.l"
static unsigned int variant_count  =    0U;
#line 353 "scan-code.l"
static variant *variant_table_grow(void) 
{ 
  void *tmp ;

  {
#line 356
  variant_count ++;
#line 357
  if (variant_count > variant_table_size) {
    {
#line 359
    while (1) {
      while_continue: /* CIL Label */ ;
#line 359
      if (! (variant_count > variant_table_size)) {
#line 359
        goto while_break;
      }
#line 360
      variant_table_size = 2U * variant_table_size + 3U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 361
    tmp = xnrealloc((void *)variant_table, variant_table_size, (size_t )sizeof(*variant_table));
#line 361
    variant_table = (variant *)tmp;
    }
  }
#line 364
  return (variant_table + (variant_count - 1U));
}
}
#line 367 "scan-code.l"
static void variant_table_free(void) 
{ 


  {
  {
#line 370
  free((void *)variant_table);
#line 371
  variant_table = (variant *)0;
#line 372
  variant_count = 0U;
#line 372
  variant_table_size = variant_count;
  }
#line 373
  return;
}
}
#line 375 "scan-code.l"
static char *find_prefix_end(char const   *prefix , char *begin , char *end ) 
{ 
  char *ptr ;

  {
#line 378
  ptr = begin;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (*prefix) {
#line 380
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 380
        goto while_break;
      }
    } else {
#line 380
      goto while_break;
    }
#line 381
    if ((int const   )*prefix != (int const   )*ptr) {
#line 382
      return ((char *)0);
    }
#line 380
    prefix ++;
#line 380
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  if (*prefix) {
#line 385
    return ((char *)0);
  }
#line 387
  return (ptr);
}
}
#line 390 "scan-code.l"
static variant *variant_add(uniqstr id , location id_loc , unsigned int symbol_index ,
                            char *cp , char *cp_end , _Bool explicit_bracketing ) 
{ 
  char *prefix_end ;
  variant *r ;
  variant *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 396
  prefix_end = find_prefix_end(id, cp, cp_end);
  }
#line 397
  if (prefix_end) {
#line 397
    if ((unsigned long )prefix_end == (unsigned long )cp_end) {
#line 397
      goto _L;
    } else
#line 397
    if (! explicit_bracketing) {
      {
#line 397
      tmp___0 = is_dot_or_dash(*prefix_end);
      }
#line 397
      if (tmp___0) {
        _L: /* CIL Label */ 
        {
#line 401
        tmp = variant_table_grow();
#line 401
        r = tmp;
#line 402
        r->symbol_index = symbol_index;
#line 403
        r->id = id;
#line 404
        r->loc = id_loc;
#line 405
        r->hidden_by = (named_ref *)((void *)0);
#line 406
        r->err = 0U;
        }
#line 407
        return (r);
      } else {
#line 410
        return ((variant *)((void *)0));
      }
    } else {
#line 410
      return ((variant *)((void *)0));
    }
  } else {
#line 410
    return ((variant *)((void *)0));
  }
}
}
#line 416 "scan-code.l"
static char at_buf[20]  ;
#line 413 "scan-code.l"
static char const   *get_at_spec(unsigned int symbol_index ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 417
  if (symbol_index == 0U) {
    {
#line 418
    strcpy((char */* __restrict  */)(at_buf), (char const   */* __restrict  */)"$$");
    }
  } else {
    {
#line 420
    rpl_snprintf(at_buf, (size_t )sizeof(at_buf), "$%u", symbol_index);
    }
  }
#line 421
  return ((char const   *)(at_buf));
}
}
#line 447 "scan-code.l"
static struct obstack msg_buf  ;
#line 424 "scan-code.l"
static void show_sub_messages(char const   *cp , _Bool explicit_bracketing , int midrule_rhs_index ,
                              char dollar_or_at , _Bool is_warning , unsigned int indent ) 
{ 
  unsigned int i ;
  variant const   *var ;
  char const   *at_spec ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tail ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *id ;
  char const   *tmp___4 ;
  location id_loc ;
  location tmp___5 ;
  char buf___0[4096] ;
  char *tmp___6 ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___7 ;
  char buf___1[4096] ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___8 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___9 ;
  _Bool tmp___10 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___11 ;
  char buf___2[4096] ;
  char *tmp___12 ;
  struct obstack *__o___3 ;
  int __len___3 ;
  size_t tmp___13 ;
  char buf___3[4096] ;
  struct obstack *__o___4 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___5 ;
  int __len___5 ;
  size_t tmp___15 ;
  _Bool tmp___16 ;
  struct obstack *__o___6 ;
  int __len___6 ;
  size_t tmp___17 ;
  char buf___4[4096] ;
  char *tmp___18 ;
  struct obstack *__o___7 ;
  int __len___7 ;
  size_t tmp___19 ;
  char const   *format ;
  char *tmp___20 ;
  char buf___5[4096] ;
  struct obstack *__o___8 ;
  int __len___8 ;
  size_t tmp___21 ;
  struct obstack *__o___9 ;
  char *tmp___22 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___23 ;
  char *tmp___24 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___25 ;
  char *tmp___26 ;
  struct obstack *__o___10 ;
  void *__obj ;
  char *tmp___27 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;

  {
#line 431
  i = 0U;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (i < variant_count)) {
#line 431
      goto while_break;
    }
    {
#line 433
    var = (variant const   *)(variant_table + i);
#line 434
    tmp = get_at_spec((unsigned int )var->symbol_index);
#line 434
    at_spec = tmp;
    }
#line 436
    if (var->err == 0U) {
#line 438
      if (is_warning) {
        {
#line 439
        tmp___0 = gettext("refers to: %c%s at %s");
#line 439
        warn_at_indent((location )var->loc, & indent, (char const   *)tmp___0, (int )dollar_or_at,
                       var->id, at_spec);
        }
      } else {
        {
#line 442
        tmp___1 = gettext("refers to: %c%s at %s");
#line 442
        complain_at_indent((location )var->loc, & indent, (char const   *)tmp___1,
                           (int )dollar_or_at, var->id, at_spec);
        }
      }
    } else {
#line 448
      if (explicit_bracketing) {
#line 448
        tmp___3 = "";
      } else {
        {
#line 448
        tmp___2 = strlen((char const   *)var->id);
#line 448
        tmp___3 = cp + tmp___2;
        }
      }
#line 448
      tail = tmp___3;
#line 450
      if (var->hidden_by) {
#line 450
        tmp___4 = (char const   */* const  */)(var->hidden_by)->id;
      } else {
#line 450
        tmp___4 = var->id;
      }
#line 450
      id = (char const   *)tmp___4;
#line 452
      if (var->hidden_by) {
#line 452
        tmp___5 = (var->hidden_by)->loc;
      } else {
#line 452
        tmp___5 = (location )var->loc;
      }
      {
#line 452
      id_loc = tmp___5;
#line 456
      _obstack_begin(& msg_buf, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
      }
      {
#line 458
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 458
        tmp___6 = gettext("possibly meant: %c");
#line 458
        rpl_sprintf(buf___0, (char const   *)tmp___6, (int )dollar_or_at);
#line 458
        __o = & msg_buf;
#line 458
        tmp___7 = strlen((char const   *)(buf___0));
#line 458
        __len = (int )tmp___7;
        }
#line 458
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 458
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 458
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
               (size_t )__len);
#line 458
        __o->next_free += __len;
        }
#line 458
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 459
      tmp___10 = contains_dot_or_dash(id);
      }
#line 459
      if (tmp___10) {
        {
#line 460
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 460
          rpl_sprintf(buf___1, "[%s]", id);
#line 460
          __o___0 = & msg_buf;
#line 460
          tmp___8 = strlen((char const   *)(buf___1));
#line 460
          __len___0 = (int )tmp___8;
          }
#line 460
          if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
            {
#line 460
            _obstack_newchunk(__o___0, __len___0);
            }
          }
          {
#line 460
          memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(buf___1),
                 (size_t )__len___0);
#line 460
          __o___0->next_free += __len___0;
          }
#line 460
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 462
        __o___1 = & msg_buf;
#line 462
        tmp___9 = strlen(id);
#line 462
        __len___1 = (int )tmp___9;
        }
#line 462
        if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
          {
#line 462
          _obstack_newchunk(__o___1, __len___1);
          }
        }
        {
#line 462
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)id,
               (size_t )__len___1);
#line 462
        __o___1->next_free += __len___1;
        }
      }
      {
#line 463
      __o___2 = & msg_buf;
#line 463
      tmp___11 = strlen(tail);
#line 463
      __len___2 = (int )tmp___11;
      }
#line 463
      if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
        {
#line 463
        _obstack_newchunk(__o___2, __len___2);
        }
      }
      {
#line 463
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)tail,
             (size_t )__len___2);
#line 463
      __o___2->next_free += __len___2;
      }
#line 465
      if (var->err & 1U) {
        {
#line 467
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 467
          tmp___12 = gettext(", hiding %c");
#line 467
          rpl_sprintf(buf___2, (char const   *)tmp___12, (int )dollar_or_at);
#line 467
          __o___3 = & msg_buf;
#line 467
          tmp___13 = strlen((char const   *)(buf___2));
#line 467
          __len___3 = (int )tmp___13;
          }
#line 467
          if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
            {
#line 467
            _obstack_newchunk(__o___3, __len___3);
            }
          }
          {
#line 467
          memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___2),
                 (size_t )__len___3);
#line 467
          __o___3->next_free += __len___3;
          }
#line 467
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 468
        tmp___16 = contains_dot_or_dash((char const   *)var->id);
        }
#line 468
        if (tmp___16) {
          {
#line 469
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 469
            rpl_sprintf(buf___3, "[%s]", var->id);
#line 469
            __o___4 = & msg_buf;
#line 469
            tmp___14 = strlen((char const   *)(buf___3));
#line 469
            __len___4 = (int )tmp___14;
            }
#line 469
            if ((unsigned long )(__o___4->next_free + __len___4) > (unsigned long )__o___4->chunk_limit) {
              {
#line 469
              _obstack_newchunk(__o___4, __len___4);
              }
            }
            {
#line 469
            memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___3),
                   (size_t )__len___4);
#line 469
            __o___4->next_free += __len___4;
            }
#line 469
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
          {
#line 471
          __o___5 = & msg_buf;
#line 471
          tmp___15 = strlen((char const   *)var->id);
#line 471
          __len___5 = (int )tmp___15;
          }
#line 471
          if ((unsigned long )(__o___5->next_free + __len___5) > (unsigned long )__o___5->chunk_limit) {
            {
#line 471
            _obstack_newchunk(__o___5, __len___5);
            }
          }
          {
#line 471
          memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)var->id,
                 (size_t )__len___5);
#line 471
          __o___5->next_free += __len___5;
          }
        }
        {
#line 472
        __o___6 = & msg_buf;
#line 472
        tmp___17 = strlen(tail);
#line 472
        __len___6 = (int )tmp___17;
        }
#line 472
        if ((unsigned long )(__o___6->next_free + __len___6) > (unsigned long )__o___6->chunk_limit) {
          {
#line 472
          _obstack_newchunk(__o___6, __len___6);
          }
        }
        {
#line 472
        memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)tail,
               (size_t )__len___6);
#line 472
        __o___6->next_free += __len___6;
        }
      }
      {
#line 475
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 475
        tmp___18 = gettext(" at %s");
#line 475
        rpl_sprintf(buf___4, (char const   *)tmp___18, at_spec);
#line 475
        __o___7 = & msg_buf;
#line 475
        tmp___19 = strlen((char const   *)(buf___4));
#line 475
        __len___7 = (int )tmp___19;
        }
#line 475
        if ((unsigned long )(__o___7->next_free + __len___7) > (unsigned long )__o___7->chunk_limit) {
          {
#line 475
          _obstack_newchunk(__o___7, __len___7);
          }
        }
        {
#line 475
        memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)(buf___4),
               (size_t )__len___7);
#line 475
        __o___7->next_free += __len___7;
        }
#line 475
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 477
      if (var->err & (unsigned int const   )(1 << 2)) {
        {
#line 479
        tmp___20 = gettext(", cannot be accessed from mid-rule action at $%d");
#line 479
        format = (char const   *)tmp___20;
        }
        {
#line 481
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 481
          rpl_sprintf(buf___5, format, midrule_rhs_index);
#line 481
          __o___8 = & msg_buf;
#line 481
          tmp___21 = strlen((char const   *)(buf___5));
#line 481
          __len___8 = (int )tmp___21;
          }
#line 481
          if ((unsigned long )(__o___8->next_free + __len___8) > (unsigned long )__o___8->chunk_limit) {
            {
#line 481
            _obstack_newchunk(__o___8, __len___8);
            }
          }
          {
#line 481
          memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___5),
                 (size_t )__len___8);
#line 481
          __o___8->next_free += __len___8;
          }
#line 481
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 484
      __o___9 = & msg_buf;
#line 484
      if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
        {
#line 484
        _obstack_newchunk(__o___9, 1);
        }
      }
#line 484
      tmp___22 = __o___9->next_free;
#line 484
      (__o___9->next_free) ++;
#line 484
      *tmp___22 = (char )'\000';
#line 485
      if (is_warning) {
#line 487
        __o1 = & msg_buf;
#line 487
        __value = (void *)__o1->object_base;
#line 487
        if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 487
          __o1->maybe_empty_object = 1U;
        }
#line 487
        if (sizeof(int ) < sizeof(void *)) {
#line 487
          tmp___23 = __o1->object_base;
        } else {
#line 487
          tmp___23 = (char *)0;
        }
#line 487
        if (sizeof(int ) < sizeof(void *)) {
#line 487
          tmp___24 = __o1->object_base;
        } else {
#line 487
          tmp___24 = (char *)0;
        }
#line 487
        __o1->next_free = tmp___23 + (((__o1->next_free - tmp___24) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 487
        if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 487
          __o1->next_free = __o1->chunk_limit;
        }
        {
#line 487
        __o1->object_base = __o1->next_free;
#line 487
        warn_at_indent(id_loc, & indent, "%s", (char *)__value);
        }
      } else {
#line 490
        __o1___0 = & msg_buf;
#line 490
        __value___0 = (void *)__o1___0->object_base;
#line 490
        if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 490
          __o1___0->maybe_empty_object = 1U;
        }
#line 490
        if (sizeof(int ) < sizeof(void *)) {
#line 490
          tmp___25 = __o1___0->object_base;
        } else {
#line 490
          tmp___25 = (char *)0;
        }
#line 490
        if (sizeof(int ) < sizeof(void *)) {
#line 490
          tmp___26 = __o1___0->object_base;
        } else {
#line 490
          tmp___26 = (char *)0;
        }
#line 490
        __o1___0->next_free = tmp___25 + (((__o1___0->next_free - tmp___26) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 490
        if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 490
          __o1___0->next_free = __o1___0->chunk_limit;
        }
        {
#line 490
        __o1___0->object_base = __o1___0->next_free;
#line 490
        complain_at_indent(id_loc, & indent, "%s", (char *)__value___0);
        }
      }
#line 491
      __o___10 = & msg_buf;
#line 491
      __obj = (void *)0;
#line 491
      if ((unsigned long )__obj > (unsigned long )((void *)__o___10->chunk)) {
#line 491
        if ((unsigned long )__obj < (unsigned long )((void *)__o___10->chunk_limit)) {
#line 491
          tmp___27 = (char *)__obj;
#line 491
          __o___10->object_base = tmp___27;
#line 491
          __o___10->next_free = tmp___27;
        } else {
          {
#line 491
          obstack_free(__o___10, __obj);
          }
        }
      } else {
        {
#line 491
        obstack_free(__o___10, __obj);
        }
      }
    }
#line 431
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  return;
}
}
#line 510 "scan-code.l"
static long parse_ref(char *cp , symbol_list *rule , int rule_length , int midrule_rhs_index ,
                      char *text , location text_loc , char dollar_or_at ) 
{ 
  symbol_list *l ;
  char *cp_end ;
  _Bool explicit_bracketing ;
  unsigned int i ;
  unsigned int valid_variants ;
  unsigned int valid_variant_index ;
  long num ;
  long tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char *p ;
  char *p___0 ;
  _Bool tmp___4 ;
  unsigned int symbol_index ;
  variant *var ;
  _Bool tmp___5 ;
  variant *var___0 ;
  unsigned int symbol_index___0 ;
  _Bool tmp___6 ;
  unsigned int len ;
  long tmp___7 ;
  unsigned int indent ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  location sym_loc ;
  char const   *format ;
  char *tmp___10 ;
  char const   *format___0 ;
  char *tmp___11 ;
  char const   *format___1 ;
  char *tmp___12 ;
  unsigned int indent___0 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  unsigned int symbol_index___1 ;
  unsigned int tmp___15 ;
  unsigned int indent___1 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
#line 519
  valid_variants = 0U;
#line 520
  valid_variant_index = 0U;
#line 522
  if (36 == (int )*cp) {
#line 523
    return (-2147483647L);
  }
  {
#line 525
  tmp___2 = c_isdigit((int )*cp);
  }
#line 525
  if (tmp___2) {
#line 525
    goto _L;
  } else
#line 525
  if ((int )*cp == 45) {
    {
#line 525
    tmp___3 = c_isdigit((int )*(cp + 1));
    }
#line 525
    if (tmp___3) {
      _L: /* CIL Label */ 
      {
#line 527
      tmp = strtol((char const   */* __restrict  */)cp, (char **/* __restrict  */)(& cp),
                   10);
#line 527
      num = tmp;
      }
#line 528
      if ((long )(-2147483646 + rule_length) <= num) {
#line 528
        if (num <= (long )rule_length) {
#line 529
          return (num);
        } else {
          {
#line 532
          tmp___0 = quote((char const   *)text);
#line 532
          tmp___1 = gettext("integer out of range: %s");
#line 532
          complain_at(text_loc, (char const   *)tmp___1, tmp___0);
          }
#line 534
          return ((-0x7FFFFFFF-1));
        }
      } else {
        {
#line 532
        tmp___0 = quote((char const   *)text);
#line 532
        tmp___1 = gettext("integer out of range: %s");
#line 532
        complain_at(text_loc, (char const   *)tmp___1, tmp___0);
        }
#line 534
        return ((-0x7FFFFFFF-1));
      }
    }
  }
#line 538
  if (91 == (int )*cp) {
#line 542
    cp ++;
#line 542
    p = cp;
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
#line 542
      if (! ((int )*p != 93)) {
#line 542
        goto while_break;
      }
#line 543
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 542
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 544
    cp_end = p;
#line 546
    explicit_bracketing = (_Bool)1;
  } else {
#line 552
    p___0 = cp;
    {
#line 552
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 552
      if (! *p___0) {
#line 552
        goto while_break___0;
      }
      {
#line 553
      tmp___4 = is_dot_or_dash(*p___0);
      }
#line 553
      if (tmp___4) {
#line 555
        ref_tail_fields = p___0;
#line 556
        goto while_break___0;
      }
#line 552
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 558
    p___0 = cp;
    {
#line 558
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 558
      if (! *p___0) {
#line 558
        goto while_break___1;
      }
#line 559
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 558
      p___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 560
    cp_end = p___0;
#line 562
    explicit_bracketing = (_Bool)0;
  }
#line 568
  variant_count = 0U;
#line 569
  symbol_index = 0U;
#line 569
  l = rule;
  {
#line 569
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 569
    tmp___5 = symbol_list_null(l);
    }
#line 569
    if (tmp___5) {
#line 569
      goto while_break___2;
    }
#line 573
    if ((unsigned int )l->content_type != 0U) {
#line 574
      goto __Cont___1;
    }
    {
#line 576
    var = variant_add((l->content.sym)->tag, l->sym_loc, symbol_index, cp, cp_end,
                      explicit_bracketing);
    }
#line 578
    if (var) {
#line 578
      if (l->named_ref) {
#line 579
        var->hidden_by = l->named_ref;
      }
    }
#line 581
    if (l->named_ref) {
      {
#line 582
      variant_add((l->named_ref)->id, (l->named_ref)->loc, symbol_index, cp, cp_end,
                  explicit_bracketing);
      }
    }
    __Cont___1: /* CIL Label */ 
#line 569
    symbol_index ++;
#line 569
    l = l->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 588
  i = 0U;
  {
#line 588
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 588
    if (! (i < variant_count)) {
#line 588
      goto while_break___3;
    }
#line 590
    var___0 = variant_table + i;
#line 591
    symbol_index___0 = var___0->symbol_index;
#line 594
    if (midrule_rhs_index != 0) {
#line 594
      if (symbol_index___0 == 0U) {
#line 596
        var___0->err |= (unsigned int )(1 << 2);
      } else
#line 594
      if ((unsigned int )midrule_rhs_index < symbol_index___0) {
#line 596
        var___0->err |= (unsigned int )(1 << 2);
      }
    }
#line 599
    if (! explicit_bracketing) {
      {
#line 599
      tmp___6 = contains_dot_or_dash(var___0->id);
      }
#line 599
      if (tmp___6) {
#line 600
        var___0->err |= (unsigned int )(1 << 1);
      }
    }
#line 603
    if (var___0->hidden_by) {
#line 604
      var___0->err |= 1U;
    }
#line 606
    if (! var___0->err) {
#line 608
      valid_variant_index = i;
#line 609
      valid_variants ++;
    }
#line 588
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 615
  if (valid_variants == 0U) {
#line 615
    goto case_0;
  }
#line 654
  if (valid_variants == 1U) {
#line 654
    goto case_1;
  }
#line 671
  goto switch_default;
  case_0: /* CIL Label */ 
#line 617
  if (explicit_bracketing) {
#line 617
    tmp___7 = cp_end - cp;
  } else
#line 617
  if (! ref_tail_fields) {
#line 617
    tmp___7 = cp_end - cp;
  } else {
#line 617
    tmp___7 = ref_tail_fields - cp;
  }
  {
#line 617
  len = (unsigned int )tmp___7;
#line 619
  indent = 0U;
#line 621
  tmp___8 = quote((char const   *)text);
#line 621
  tmp___9 = gettext("invalid reference: %s");
#line 621
  complain_at_indent(text_loc, & indent, (char const   *)tmp___9, tmp___8);
#line 623
  indent += 4U;
  }
#line 624
  if (len == 0U) {
    {
#line 626
    sym_loc = text_loc;
#line 627
    (sym_loc.start.column) ++;
#line 628
    sym_loc.end = sym_loc.start;
#line 629
    tmp___10 = gettext("syntax error after `%c\', expecting integer, letter, `_\', `[\', or `$\'");
#line 629
    format = (char const   *)tmp___10;
#line 632
    complain_at_indent(sym_loc, & indent, format, (int )dollar_or_at);
    }
  } else
#line 634
  if (midrule_rhs_index) {
    {
#line 636
    tmp___11 = gettext("symbol not found in production before $%d: %.*s");
#line 636
    format___0 = (char const   *)tmp___11;
#line 638
    complain_at_indent(rule->location, & indent, format___0, midrule_rhs_index, len,
                       cp);
    }
  } else {
    {
#line 643
    tmp___12 = gettext("symbol not found in production: %.*s");
#line 643
    format___1 = (char const   *)tmp___12;
#line 645
    complain_at_indent(rule->location, & indent, format___1, len, cp);
    }
  }
#line 649
  if (variant_count > 0U) {
    {
#line 650
    show_sub_messages((char const   *)cp, explicit_bracketing, midrule_rhs_index,
                      dollar_or_at, (_Bool)0, indent);
    }
  }
#line 652
  return ((-0x7FFFFFFF-1));
  case_1: /* CIL Label */ 
#line 656
  indent___0 = 0U;
#line 657
  if (variant_count > 1U) {
    {
#line 659
    tmp___13 = quote((char const   *)text);
#line 659
    tmp___14 = gettext("misleading reference: %s");
#line 659
    warn_at_indent(text_loc, & indent___0, (char const   *)tmp___14, tmp___13);
#line 661
    show_sub_messages((char const   *)cp, explicit_bracketing, midrule_rhs_index,
                      dollar_or_at, (_Bool)1, indent___0 + 4U);
    }
  }
#line 665
  symbol_index___1 = (variant_table + valid_variant_index)->symbol_index;
#line 667
  if (symbol_index___1 == (unsigned int )midrule_rhs_index) {
#line 667
    tmp___15 = 2147483649U;
  } else {
#line 667
    tmp___15 = symbol_index___1;
  }
#line 667
  return ((long )tmp___15);
  switch_default: /* CIL Label */ 
  {
#line 673
  indent___1 = 0U;
#line 674
  tmp___16 = quote((char const   *)text);
#line 674
  tmp___17 = gettext("ambiguous reference: %s");
#line 674
  complain_at_indent(text_loc, & indent___1, (char const   *)tmp___17, tmp___16);
#line 676
  show_sub_messages((char const   *)cp, explicit_bracketing, midrule_rhs_index, dollar_or_at,
                    (_Bool)0, indent___1 + 4U);
  }
#line 678
  return ((-0x7FFFFFFF-1));
  switch_break: /* CIL Label */ ;
  }
#line 683
  return ((-0x7FFFFFFF-1));
}
}
#line 689 "scan-code.l"
int max_left_semantic_context  =    0;
#line 700 "scan-code.l"
static void handle_action_dollar(symbol_list *rule , char *text , location dollar_loc ) 
{ 
  char const   *type_name ;
  char *cp ;
  char *gt_ptr ;
  symbol_list *effective_rule ;
  int effective_rule_length ;
  int n ;
  char *tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char buf___1[4096] ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___5 ;
  symbol_list *tmp___6 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 703
  type_name = (char const   *)((void *)0);
#line 704
  cp = text + 1;
#line 705
  gt_ptr = (char *)0;
#line 710
  if (rule->midrule_parent_rule) {
#line 712
    effective_rule = rule->midrule_parent_rule;
#line 713
    effective_rule_length = rule->midrule_parent_rhs_index - 1;
  } else {
    {
#line 717
    effective_rule = rule;
#line 718
    effective_rule_length = symbol_list_length((symbol_list const   *)rule->next);
    }
  }
#line 722
  if ((int )*cp == 60) {
#line 724
    cp ++;
#line 724
    type_name = (char const   *)cp;
    {
#line 725
    while (1) {
      while_continue: /* CIL Label */ ;
#line 725
      if (! ((int )*cp != 62)) {
#line 725
        goto while_break;
      }
#line 726
      cp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 730
    gt_ptr = cp;
#line 731
    cp ++;
#line 732
    if (untyped_var_seen) {
      {
#line 733
      tmp = gettext("explicit type given in untyped grammar");
#line 733
      complain_at(dollar_loc, (char const   *)tmp);
      }
    }
#line 734
    tag_seen = (_Bool)1;
  }
  {
#line 737
  tmp___0 = parse_ref(cp, effective_rule, effective_rule_length, rule->midrule_parent_rhs_index,
                      text, dollar_loc, (char )'$');
#line 737
  n = (int )tmp___0;
  }
#line 740
  if (gt_ptr) {
#line 741
    *gt_ptr = (char )'\000';
  }
  {
#line 745
  if (n == (-0x7FFFFFFF-1)) {
#line 745
    goto case_neg_2147483648;
  }
#line 748
  if (n == -2147483647) {
#line 748
    goto case_neg_2147483647;
  }
#line 776
  goto switch_default;
  case_neg_2147483648: /* CIL Label */ 
#line 746
  goto switch_break;
  case_neg_2147483647: /* CIL Label */ 
#line 749
  if (! type_name) {
    {
#line 750
    type_name = symbol_list_n_type_name_get(rule, dollar_loc, 0);
    }
  }
#line 752
  if (! type_name) {
#line 754
    if ((int )union_seen | (int )tag_seen) {
#line 756
      if (rule->midrule_parent_rule) {
        {
#line 757
        tmp___1 = gettext("$$ for the midrule at $%d of `%s\' has no declared type");
#line 757
        complain_at(dollar_loc, (char const   *)tmp___1, rule->midrule_parent_rhs_index,
                    (effective_rule->content.sym)->tag);
        }
      } else {
        {
#line 763
        tmp___2 = gettext("$$ of `%s\' has no declared type");
#line 763
        complain_at(dollar_loc, (char const   *)tmp___2, (rule->content.sym)->tag);
        }
      }
    } else {
#line 767
      untyped_var_seen = (_Bool)1;
    }
#line 768
    type_name = "";
  }
  {
#line 771
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 771
    rpl_sprintf(buf___0, "]b4_lhs_value([%s])[", type_name);
#line 771
    __o = & obstack_for_string___1;
#line 771
    tmp___3 = strlen((char const   *)(buf___0));
#line 771
    __len = (int )tmp___3;
    }
#line 771
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 771
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 771
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 771
    __o->next_free += __len;
    }
#line 771
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 773
  rule->action_props.is_value_used = (_Bool)1;
#line 774
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 777
  if (max_left_semantic_context < 1 - n) {
#line 778
    max_left_semantic_context = 1 - n;
  }
#line 779
  if (! type_name) {
#line 779
    if (0 < n) {
      {
#line 780
      type_name = symbol_list_n_type_name_get(effective_rule, dollar_loc, n);
      }
    }
  }
#line 782
  if (! type_name) {
#line 784
    if ((int )union_seen | (int )tag_seen) {
      {
#line 785
      tmp___4 = gettext("$%s of `%s\' has no declared type");
#line 785
      complain_at(dollar_loc, (char const   *)tmp___4, cp, (effective_rule->content.sym)->tag);
      }
    } else {
#line 788
      untyped_var_seen = (_Bool)1;
    }
#line 789
    type_name = "";
  }
  {
#line 792
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 792
    rpl_sprintf(buf___1, "]b4_rhs_value(%d, %d, [%s])[", effective_rule_length, n,
                type_name);
#line 792
    __o___0 = & obstack_for_string___1;
#line 792
    tmp___5 = strlen((char const   *)(buf___1));
#line 792
    __len___0 = (int )tmp___5;
    }
#line 792
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 792
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 792
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(buf___1),
           (size_t )__len___0);
#line 792
    __o___0->next_free += __len___0;
    }
#line 792
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 795
  if (n > 0) {
    {
#line 796
    tmp___6 = symbol_list_n_get(effective_rule, n);
#line 796
    tmp___6->action_props.is_value_used = (_Bool)1;
    }
  }
#line 798
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 800
  return;
}
}
#line 808 "scan-code.l"
static void handle_action_at(symbol_list *rule , char *text , location at_loc ) 
{ 
  char *cp ;
  symbol_list *effective_rule ;
  int effective_rule_length ;
  int n ;
  long tmp ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  char buf___0[4096] ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___1 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 811
  cp = text + 1;
#line 816
  if (rule->midrule_parent_rule) {
#line 818
    effective_rule = rule->midrule_parent_rule;
#line 819
    effective_rule_length = rule->midrule_parent_rhs_index - 1;
  } else {
    {
#line 823
    effective_rule = rule;
#line 824
    effective_rule_length = symbol_list_length((symbol_list const   *)rule->next);
    }
  }
  {
#line 827
  locations_flag = (_Bool)1;
#line 829
  tmp = parse_ref(cp, effective_rule, effective_rule_length, rule->midrule_parent_rhs_index,
                  text, at_loc, (char )'@');
#line 829
  n = (int )tmp;
  }
  {
#line 833
  if (n == (-0x7FFFFFFF-1)) {
#line 833
    goto case_neg_2147483648;
  }
#line 836
  if (n == -2147483647) {
#line 836
    goto case_neg_2147483647;
  }
#line 840
  goto switch_default;
  case_neg_2147483648: /* CIL Label */ 
#line 834
  goto switch_break;
  case_neg_2147483647: /* CIL Label */ 
  {
#line 837
  __o = & obstack_for_string___1;
#line 837
  tmp___0 = strlen("]b4_lhs_location[");
#line 837
  __len = (int )tmp___0;
  }
#line 837
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 837
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 837
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"]b4_lhs_location[",
         (size_t )__len);
#line 837
  __o->next_free += __len;
  }
#line 838
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 841
    rpl_sprintf(buf___0, "]b4_rhs_location(%d, %d)[", effective_rule_length, n);
#line 841
    __o___0 = & obstack_for_string___1;
#line 841
    tmp___1 = strlen((char const   *)(buf___0));
#line 841
    __len___0 = (int )tmp___1;
    }
#line 841
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 841
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 841
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len___0);
#line 841
    __o___0->next_free += __len___0;
    }
#line 841
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 843
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 845
  return;
}
}
#line 859
static char const   *translate_action(code_props *self , int sc_context ) ;
#line 859 "scan-code.l"
static _Bool initialized___0  =    (_Bool)0;
#line 855 "scan-code.l"
static char const   *translate_action(code_props *self , int sc_context ) 
{ 
  char *res ;
  boundary tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 860
  if (! initialized___0) {
    {
#line 862
    _obstack_begin(& obstack_for_string___1, 0, 0, (void *(*)(long  ))(& xmalloc),
                   & free);
#line 863
    code__flex_debug = 0;
#line 864
    initialized___0 = (_Bool)1;
    }
  }
  {
#line 867
  tmp = self->location.start;
#line 867
  loc->end = tmp;
#line 867
  loc->start = tmp;
#line 868
  tmp___0 = code__scan_string(self->code);
#line 868
  code__switch_to_buffer(tmp___0);
#line 869
  res = code_lex(self, sc_context);
  }
#line 870
  if (yy_buffer_stack___1) {
#line 870
    tmp___1 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 870
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 870
  code__delete_buffer(tmp___1);
  }
#line 872
  return ((char const   *)res);
}
}
#line 879 "scan-code.l"
void code_props_none_init(code_props *self ) 
{ 


  {
#line 882
  *self = (code_props )code_props_none;
#line 883
  return;
}
}
#line 885 "scan-code.l"
struct code_props  const  code_props_none  =    {(enum __anonenum_kind_36 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0), (named_ref *)((void *)0)};
#line 887 "scan-code.l"
void code_props_plain_init(code_props *self , char const   *code , location code_loc ) 
{ 


  {
#line 891
  self->kind = (enum __anonenum_kind_38 )1;
#line 892
  self->code = code;
#line 893
  self->location = code_loc;
#line 894
  self->is_value_used = (_Bool)0;
#line 895
  self->rule = (struct symbol_list *)((void *)0);
#line 896
  self->named_ref = (named_ref *)((void *)0);
#line 897
  return;
}
}
#line 899 "scan-code.l"
void code_props_symbol_action_init(code_props *self , char const   *code , location code_loc ) 
{ 


  {
#line 903
  self->kind = (enum __anonenum_kind_38 )2;
#line 904
  self->code = code;
#line 905
  self->location = code_loc;
#line 906
  self->is_value_used = (_Bool)0;
#line 907
  self->rule = (struct symbol_list *)((void *)0);
#line 908
  self->named_ref = (named_ref *)((void *)0);
#line 909
  return;
}
}
#line 911 "scan-code.l"
void code_props_rule_action_init(code_props *self , char const   *code , location code_loc ,
                                 struct symbol_list *rule , named_ref *name ) 
{ 


  {
#line 916
  self->kind = (enum __anonenum_kind_38 )3;
#line 917
  self->code = code;
#line 918
  self->location = code_loc;
#line 919
  self->is_value_used = (_Bool)0;
#line 920
  self->rule = rule;
#line 921
  self->named_ref = name;
#line 922
  return;
}
}
#line 924 "scan-code.l"
void code_props_translate_code(code_props *self ) 
{ 


  {
  {
#line 929
  if ((unsigned int )self->kind == 0U) {
#line 929
    goto case_0;
  }
#line 931
  if ((unsigned int )self->kind == 1U) {
#line 931
    goto case_1;
  }
#line 934
  if ((unsigned int )self->kind == 2U) {
#line 934
    goto case_2;
  }
#line 937
  if ((unsigned int )self->kind == 3U) {
#line 937
    goto case_3;
  }
#line 927
  goto switch_break;
  case_0: /* CIL Label */ 
#line 930
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 932
  self->code = translate_action(self, 0);
  }
#line 933
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 935
  self->code = translate_action(self, 6);
  }
#line 936
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 938
  self->code = translate_action(self, 5);
  }
#line 939
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 941
  return;
}
}
#line 943 "scan-code.l"
void code_scanner_last_string_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 946
  __o = & obstack_for_string___1;
#line 946
  __obj = (void *)code_last_string;
#line 946
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 946
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 946
      tmp = (char *)__obj;
#line 946
      __o->object_base = tmp;
#line 946
      __o->next_free = tmp;
    } else {
      {
#line 946
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 946
    obstack_free(__o, __obj);
    }
  }
#line 947
  return;
}
}
#line 949 "scan-code.l"
void code_scanner_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 952
  __o = & obstack_for_string___1;
#line 952
  __obj = (void *)0;
#line 952
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 952
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 952
      tmp = (char *)__obj;
#line 952
      __o->object_base = tmp;
#line 952
      __o->next_free = tmp;
    } else {
      {
#line 952
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 952
    obstack_free(__o, __obj);
    }
  }
  {
#line 953
  variant_table_free();
#line 956
  code_lex_destroy();
  }
#line 957
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 37 "/home/pronto/abs/test-suite/bison-2.5/src/relation.h"
void relation_print(relation r , relation_node size , FILE *out ) ;
#line 44
void relation_digraph(relation r , relation_node size , bitsetv *function ) ;
#line 47
void relation_transpose(relation *R_arg , relation_node n ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
void relation_print(relation r , relation_node size , FILE *out ) 
{ 
  relation_node i ;
  relation_node j ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 35
  i = (relation_node )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    rpl_fprintf(out, "%3lu: ", (unsigned long )i);
    }
#line 38
    if (*(r + i)) {
#line 39
      j = (relation_node )0;
      {
#line 39
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 39
        if (! (*(*(r + i) + j) != 4294967295U)) {
#line 39
          goto while_break___0;
        }
        {
#line 40
        rpl_fprintf(out, "%3lu ", (unsigned long )*(*(r + i) + j));
#line 39
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 41
    fputc_unlocked('\n', out);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  fputc_unlocked('\n', out);
  }
#line 44
  return;
}
}
#line 54 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
static relation R  ;
#line 55 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
static relation_nodes INDEX  ;
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
static relation_nodes VERTICES  ;
#line 57 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
static relation_node top  ;
#line 58 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
static relation_node infinity  ;
#line 59 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
static bitsetv F  ;
#line 61 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
static void traverse(relation_node i ) 
{ 
  relation_node j ;
  relation_node height ;
  relation_node tmp ;

  {
#line 67
  top ++;
#line 67
  *(VERTICES + top) = i;
#line 68
  height = top;
#line 68
  *(INDEX + i) = height;
#line 70
  if (*(R + i)) {
#line 71
    j = (relation_node )0;
    {
#line 71
    while (1) {
      while_continue: /* CIL Label */ ;
#line 71
      if (! (*(*(R + i) + j) != 4294967295U)) {
#line 71
        goto while_break;
      }
#line 73
      if (*(INDEX + *(*(R + i) + j)) == 0U) {
        {
#line 74
        traverse(*(*(R + i) + j));
        }
      }
#line 76
      if (*(INDEX + i) > *(INDEX + *(*(R + i) + j))) {
#line 77
        *(INDEX + i) = *(INDEX + *(*(R + i) + j));
      }
      {
#line 79
      (*(((*(F + i))->b.vtable)->or_))(*(F + i), *(F + i), *(F + *(*(R + i) + j)));
#line 71
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 82
  if (*(INDEX + i) == height) {
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 85
      tmp = top;
#line 85
      top --;
#line 85
      j = *(VERTICES + tmp);
#line 86
      *(INDEX + j) = infinity;
#line 88
      if (i == j) {
#line 89
        goto while_break___0;
      }
      {
#line 91
      (*(((*(F + i))->b.vtable)->copy))(*(F + j), *(F + i));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 93
  return;
}
}
#line 96 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
void relation_digraph(relation r , relation_node size , bitsetv *function ) 
{ 
  relation_node i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 101
  infinity = size + 2U;
#line 102
  tmp = xcalloc(size + 10, (size_t )sizeof(*INDEX));
#line 102
  INDEX = (relation_nodes )tmp;
#line 103
  tmp___0 = xnmalloc(size + 1U, (size_t )sizeof(*VERTICES));
#line 103
  VERTICES = (relation_nodes )tmp___0;
#line 104
  top = (relation_node )0;
#line 106
  R = r;
#line 107
  F = *function;
#line 109
  i = (relation_node )0;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < size)) {
#line 109
      goto while_break;
    }
#line 110
    if (*(INDEX + i) == 0U) {
#line 110
      if (*(R + i)) {
        {
#line 111
        traverse(i);
        }
      }
    }
#line 109
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  free((void *)INDEX);
#line 114
  free((void *)VERTICES);
#line 116
  *function = F;
  }
#line 117
  return;
}
}
#line 124 "/home/pronto/abs/test-suite/bison-2.5/src/relation.c"
void relation_transpose(relation *R_arg , relation_node n ) 
{ 
  relation r ;
  relation new_R ;
  void *tmp ;
  relation end_R ;
  void *tmp___0 ;
  size_t *nedges ;
  void *tmp___1 ;
  relation_node i ;
  relation_node j ;
  relation_node *sp ;
  void *tmp___2 ;
  relation_nodes tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 127
  r = *R_arg;
#line 129
  tmp = xnmalloc(n, (size_t )sizeof(*new_R));
#line 129
  new_R = (relation )tmp;
#line 131
  tmp___0 = xnmalloc(n, (size_t )sizeof(*end_R));
#line 131
  end_R = (relation )tmp___0;
#line 133
  tmp___1 = xcalloc(n, (size_t )sizeof(*nedges));
#line 133
  nedges = (size_t *)tmp___1;
  }
#line 137
  if (trace_flag & 8) {
    {
#line 139
    fputs_unlocked((char const   */* __restrict  */)"relation_transpose: input\n",
                   (FILE */* __restrict  */)stderr);
#line 140
    relation_print(r, n, stderr);
    }
  }
#line 144
  i = (relation_node )0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < n)) {
#line 144
      goto while_break;
    }
#line 145
    if (*(r + i)) {
#line 146
      j = (relation_node )0;
      {
#line 146
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 146
        if (! (*(*(r + i) + j) != 4294967295U)) {
#line 146
          goto while_break___0;
        }
#line 147
        (*(nedges + *(*(r + i) + j))) ++;
#line 146
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  i = (relation_node )0;
  {
#line 150
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 150
    if (! (i < n)) {
#line 150
      goto while_break___1;
    }
#line 152
    sp = (relation_node *)((void *)0);
#line 153
    if (*(nedges + i) > 0U) {
      {
#line 155
      tmp___2 = xnmalloc(*(nedges + i) + 1U, (size_t )sizeof(*sp));
#line 155
      sp = (relation_node *)tmp___2;
#line 156
      *(sp + *(nedges + i)) = (relation_node )-1;
      }
    }
#line 158
    *(new_R + i) = sp;
#line 159
    *(end_R + i) = sp;
#line 150
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 163
  i = (relation_node )0;
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 163
    if (! (i < n)) {
#line 163
      goto while_break___2;
    }
#line 164
    if (*(r + i)) {
#line 165
      j = (relation_node )0;
      {
#line 165
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 165
        if (! (*(*(r + i) + j) != 4294967295U)) {
#line 165
          goto while_break___3;
        }
#line 166
        tmp___3 = *(end_R + *(*(r + i) + j));
#line 166
        (*(end_R + *(*(r + i) + j))) ++;
#line 166
        *tmp___3 = i;
#line 165
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 163
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 168
  free((void *)nedges);
#line 169
  free((void *)end_R);
#line 172
  i = (relation_node )0;
  }
  {
#line 172
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 172
    if (! (i < n)) {
#line 172
      goto while_break___4;
    }
    {
#line 173
    free((void *)*(r + i));
#line 172
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 174
  free((void *)r);
  }
#line 176
  if (trace_flag & 8) {
    {
#line 178
    fputs_unlocked((char const   */* __restrict  */)"relation_transpose: output\n",
                   (FILE */* __restrict  */)stderr);
#line 179
    relation_print(new_R, n, stderr);
    }
  }
#line 182
  *R_arg = new_R;
#line 183
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 62 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *ngettext(char const   *__msgid1 , char const   *__msgid2 ,
                                                    unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 118 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
unsigned int nritems ;
#line 128 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
__inline static item_number symbol_number_as_item_number(symbol_number sym ) 
{ 


  {
#line 131
  return (sym);
}
}
#line 213
_Bool rule_useless_in_grammar_p(rule *r ) ;
#line 226
int rule_rhs_length(rule *r ) ;
#line 255
void grammar_rules_partial_print(FILE *out , char const   *title , _Bool (*filter)(rule * ) ) ;
#line 264
void grammar_dump(FILE *out , char const   *title ) ;
#line 270
void grammar_rules_useless_report(char const   *message ) ;
#line 24 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.h"
void reduce_grammar(void) ;
#line 25
void reduce_output(FILE *out ) ;
#line 26
_Bool reduce_token_unused_in_grammar(symbol_number i ) ;
#line 27
_Bool reduce_nonterminal_useless_in_grammar(symbol_number i ) ;
#line 28
void reduce_free(void) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.h"
symbol_number nuseless_nonterminals  ;
#line 31 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.h"
rule_number nuseless_productions  ;
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static bitset N  ;
#line 47 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static bitset P  ;
#line 50 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static bitset V  ;
#line 54 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static bitset V1  ;
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static rule_number nuseful_productions  ;
#line 58 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static int nuseful_nonterminals  ;
#line 67 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static _Bool useful_production(rule_number r , bitset N0 ) 
{ 
  item_number *rhsp ;
  _Bool tmp ;

  {
#line 75
  rhsp = (rules + r)->rhs;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (*rhsp >= 0)) {
#line 75
      goto while_break;
    }
#line 76
    if (*rhsp >= ntokens) {
      {
#line 76
      tmp = bitset_test(N0, (bitset_bindex )(*rhsp - ntokens));
      }
#line 76
      if (! tmp) {
#line 77
        return ((_Bool)0);
      }
    }
#line 75
    rhsp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return ((_Bool)1);
}
}
#line 86 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static void useless_nonterminals(void) 
{ 
  bitset Np ;
  bitset Ns ;
  rule_number r ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 95
  Np = bitset_create((bitset_bindex )nvars, (bitset_attrs )1);
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    (*((N->b.vtable)->copy))(Np, N);
#line 117
    r = 0;
    }
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (r < nrules)) {
#line 117
        goto while_break___0;
      }
      {
#line 118
      tmp = bitset_test(P, (bitset_bindex )r);
      }
#line 118
      if (! tmp) {
        {
#line 118
        tmp___0 = useful_production(r, N);
        }
#line 118
        if (tmp___0) {
          {
#line 121
          bitset_set(Np, (bitset_bindex )(((rules + r)->lhs)->number - ntokens));
#line 122
          bitset_set(P, (bitset_bindex )r);
          }
        }
      }
#line 117
      r ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 124
    tmp___1 = (*((Np->b.vtable)->equal_p))(N, Np);
    }
#line 124
    if (tmp___1) {
#line 125
      goto while_break;
    }
#line 126
    Ns = Np;
#line 127
    Np = N;
#line 128
    N = Ns;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  bitset_free(N);
#line 131
  N = Np;
  }
#line 132
  return;
}
}
#line 135 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static void inaccessable_symbols(void) 
{ 
  bitset Vp ;
  bitset Vs ;
  bitset Pp ;
  rule_number r ;
  item_number *rhsp ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  bitset_bindex tmp___5 ;
  symbol_number i ;
  _Bool tmp___6 ;
  rule_number r___0 ;

  {
  {
#line 163
  Vp = bitset_create((bitset_bindex )nsyms, (bitset_attrs )1);
#line 164
  Pp = bitset_create((bitset_bindex )nrules, (bitset_attrs )1);
#line 167
  tmp___4 = bitset_test(N, (bitset_bindex )(accept->number - ntokens));
  }
#line 167
  if (tmp___4) {
    {
#line 169
    bitset_set(V, (bitset_bindex )accept->number);
    }
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 174
      (*((V->b.vtable)->copy))(Vp, V);
#line 175
      r = 0;
      }
      {
#line 175
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 175
        if (! (r < nrules)) {
#line 175
          goto while_break___0;
        }
        {
#line 177
        tmp___0 = bitset_test(Pp, (bitset_bindex )r);
        }
#line 177
        if (! tmp___0) {
          {
#line 177
          tmp___1 = bitset_test(P, (bitset_bindex )r);
          }
#line 177
          if (tmp___1) {
            {
#line 177
            tmp___2 = bitset_test(V, (bitset_bindex )((rules + r)->lhs)->number);
            }
#line 177
            if (tmp___2) {
#line 182
              rhsp = (rules + r)->rhs;
              {
#line 182
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 182
                if (! (*rhsp >= 0)) {
#line 182
                  goto while_break___1;
                }
#line 183
                if (*rhsp < ntokens) {
                  {
#line 184
                  bitset_set(Vp, (bitset_bindex )*rhsp);
                  }
                } else {
                  {
#line 183
                  tmp = bitset_test(N, (bitset_bindex )(*rhsp - ntokens));
                  }
#line 183
                  if (tmp) {
                    {
#line 184
                    bitset_set(Vp, (bitset_bindex )*rhsp);
                    }
                  }
                }
#line 182
                rhsp ++;
              }
              while_break___1: /* CIL Label */ ;
              }
              {
#line 185
              bitset_set(Pp, (bitset_bindex )r);
              }
            }
          }
        }
#line 175
        r ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 188
      tmp___3 = (*((Vp->b.vtable)->equal_p))(V, Vp);
      }
#line 188
      if (tmp___3) {
#line 189
        goto while_break;
      }
#line 190
      Vs = Vp;
#line 191
      Vp = V;
#line 192
      V = Vs;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 196
  bitset_free(V);
#line 197
  V = Vp;
#line 200
  bitset_set(V, (bitset_bindex )endtoken->number);
#line 201
  bitset_set(V, (bitset_bindex )errtoken->number);
#line 202
  bitset_set(V, (bitset_bindex )undeftoken->number);
#line 204
  bitset_free(P);
#line 205
  P = Pp;
#line 207
  tmp___5 = (*((P->b.vtable)->count))(P);
#line 207
  nuseful_productions = (rule_number )tmp___5;
#line 208
  nuseless_productions = nrules - nuseful_productions;
#line 210
  nuseful_nonterminals = 0;
#line 213
  i = ntokens;
  }
  {
#line 213
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 213
    if (! (i < nsyms)) {
#line 213
      goto while_break___2;
    }
    {
#line 214
    tmp___6 = bitset_test(V, (bitset_bindex )i);
    }
#line 214
    if (tmp___6) {
#line 215
      nuseful_nonterminals ++;
    }
#line 213
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 217
  nuseless_nonterminals = nvars - nuseful_nonterminals;
#line 222
  r___0 = 0;
  {
#line 222
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 222
    if (! (r___0 < nrules)) {
#line 222
      goto while_break___3;
    }
#line 223
    if ((unsigned long )(rules + r___0)->precsym != (unsigned long )((symbol *)0)) {
      {
#line 224
      bitset_set(V1, (bitset_bindex )((rules + r___0)->precsym)->number);
      }
    }
#line 222
    r___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 234 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static void reduce_grammar_tables(void) 
{ 
  rule_number r ;
  char *tmp ;
  int useful ;
  int useless ;
  rule *rules_sorted ;
  void *tmp___0 ;
  rule_number r___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  item_number *rhsp ;
  rule_number r___1 ;
  int length ;
  char *__cil_tmp14 ;

  {
#line 240
  r = 0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (r < nrules)) {
#line 240
      goto while_break;
    }
    {
#line 241
    (rules + r)->useful = bitset_test(P, (bitset_bindex )r);
#line 240
    r ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  tmp = gettext("rule useless in grammar");
#line 242
  grammar_rules_useless_report((char const   *)tmp);
#line 248
  useful = 0;
#line 249
  useless = nrules - nuseless_productions;
#line 250
  tmp___0 = xnmalloc((size_t )nrules, (size_t )sizeof(*rules_sorted));
#line 250
  rules_sorted = (rule *)tmp___0;
#line 252
  r___0 = 0;
  }
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 252
    if (! (r___0 < nrules)) {
#line 252
      goto while_break___0;
    }
#line 253
    if ((rules + r___0)->useful) {
#line 253
      tmp___1 = useful;
#line 253
      useful ++;
#line 253
      tmp___3 = tmp___1;
    } else {
#line 253
      tmp___2 = useless;
#line 253
      useless ++;
#line 253
      tmp___3 = tmp___2;
    }
#line 253
    *(rules_sorted + tmp___3) = *(rules + r___0);
#line 252
    r___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 254
  free((void *)rules);
#line 255
  rules = rules_sorted;
#line 258
  r___0 = 0;
  }
  {
#line 258
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 258
    if (! (r___0 < nrules)) {
#line 258
      goto while_break___1;
    }
#line 260
    rhsp = (rules + r___0)->rhs;
    {
#line 261
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 261
      if (! (*rhsp >= 0)) {
#line 261
        goto while_break___2;
      }
#line 261
      rhsp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 263
    *rhsp = rule_number_as_item_number(r___0);
#line 264
    (rules + r___0)->number = r___0;
#line 258
    r___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 266
  nrules -= nuseless_productions;
#line 273
  r___1 = nrules;
  {
#line 273
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 273
    if (! (r___1 < nrules + nuseless_productions)) {
#line 273
      goto while_break___3;
    }
    {
#line 275
    length = rule_rhs_length(rules + r___1);
#line 276
    nritems -= (unsigned int )(length + 1);
#line 273
    r___1 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 286 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static void nonterminals_reduce(void) 
{ 
  symbol_number i ;
  symbol_number n ;
  symbol_number *nontermmap ;
  void *tmp ;
  symbol_number tmp___0 ;
  _Bool tmp___1 ;
  symbol_number tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  symbol **symbols_sorted___0 ;
  void *tmp___5 ;
  rule_number r ;
  item_number *rhsp ;
  char *__cil_tmp14 ;

  {
  {
#line 294
  tmp = xnmalloc((size_t )nvars, (size_t )sizeof(*nontermmap));
#line 294
  nontermmap = (symbol_number *)tmp;
#line 295
  n = ntokens;
#line 296
  i = ntokens;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < nsyms)) {
#line 296
      goto while_break;
    }
    {
#line 297
    tmp___1 = bitset_test(V, (bitset_bindex )i);
    }
#line 297
    if (tmp___1) {
#line 298
      tmp___0 = n;
#line 298
      n ++;
#line 298
      *(nontermmap + (i - ntokens)) = tmp___0;
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  i = ntokens;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i < nsyms)) {
#line 299
      goto while_break___0;
    }
    {
#line 300
    tmp___4 = bitset_test(V, (bitset_bindex )i);
    }
#line 300
    if (! tmp___4) {
      {
#line 302
      tmp___2 = n;
#line 302
      n ++;
#line 302
      *(nontermmap + (i - ntokens)) = tmp___2;
#line 303
      tmp___3 = gettext("nonterminal useless in grammar: %s");
#line 303
      warn_at((*(symbols + i))->location, (char const   *)tmp___3, (*(symbols + i))->tag);
      }
    }
#line 299
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 310
  tmp___5 = xnmalloc((size_t )nvars, (size_t )sizeof(*symbols_sorted___0));
#line 310
  symbols_sorted___0 = (symbol **)tmp___5;
#line 312
  i = ntokens;
  }
  {
#line 312
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 312
    if (! (i < nsyms)) {
#line 312
      goto while_break___1;
    }
#line 313
    (*(symbols + i))->number = *(nontermmap + (i - ntokens));
#line 312
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 314
  i = ntokens;
  {
#line 314
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 314
    if (! (i < nsyms)) {
#line 314
      goto while_break___2;
    }
#line 315
    *(symbols_sorted___0 + (*(nontermmap + (i - ntokens)) - ntokens)) = *(symbols + i);
#line 314
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 316
  i = ntokens;
  {
#line 316
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 316
    if (! (i < nsyms)) {
#line 316
      goto while_break___3;
    }
#line 317
    *(symbols + i) = *(symbols_sorted___0 + (i - ntokens));
#line 316
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 318
  free((void *)symbols_sorted___0);
#line 323
  r = 0;
  }
  {
#line 323
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 323
    if (! (r < nrules)) {
#line 323
      goto while_break___4;
    }
#line 326
    rhsp = (rules + r)->rhs;
    {
#line 326
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 326
      if (! (*rhsp >= 0)) {
#line 326
        goto while_break___5;
      }
#line 327
      if (*rhsp >= ntokens) {
        {
#line 328
        *rhsp = symbol_number_as_item_number(*(nontermmap + (*rhsp - ntokens)));
        }
      }
#line 326
      rhsp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 323
    r ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 331
  accept->number = *(nontermmap + (accept->number - ntokens));
#line 334
  nsyms -= nuseless_nonterminals;
#line 335
  nvars -= nuseless_nonterminals;
#line 337
  free((void *)nontermmap);
  }
#line 338
  return;
}
}
#line 345 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
void reduce_output(FILE *out ) 
{ 
  int i ;
  char *tmp ;
  _Bool b ;
  int i___0 ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 348
  if (nuseless_nonterminals > 0) {
    {
#line 351
    tmp = gettext("Nonterminals useless in grammar");
#line 351
    rpl_fprintf(out, "%s\n\n", tmp);
#line 352
    i = 0;
    }
    {
#line 352
    while (1) {
      while_continue: /* CIL Label */ ;
#line 352
      if (! (i < nuseless_nonterminals)) {
#line 352
        goto while_break;
      }
      {
#line 353
      rpl_fprintf(out, "   %s\n", (*(symbols + (nsyms + i)))->tag);
#line 352
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 354
    fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
    }
  }
#line 358
  b = (_Bool)0;
#line 360
  i___0 = 0;
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! (i___0 < ntokens)) {
#line 360
      goto while_break___0;
    }
    {
#line 361
    tmp___1 = reduce_token_unused_in_grammar(i___0);
    }
#line 361
    if (tmp___1) {
#line 363
      if (! b) {
        {
#line 364
        tmp___0 = gettext("Terminals unused in grammar");
#line 364
        rpl_fprintf(out, "%s\n\n", tmp___0);
        }
      }
      {
#line 365
      b = (_Bool)1;
#line 366
      rpl_fprintf(out, "   %s\n", (*(symbols + i___0))->tag);
      }
    }
#line 360
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 368
  if (b) {
    {
#line 369
    fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
    }
  }
#line 372
  if (nuseless_productions > 0) {
    {
#line 373
    tmp___2 = gettext("Rules useless in grammar");
#line 373
    grammar_rules_partial_print(out, (char const   *)tmp___2, & rule_useless_in_grammar_p);
    }
  }
#line 375
  return;
}
}
#line 382 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
static void reduce_print(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 385
  if (nuseless_nonterminals > 0) {
    {
#line 386
    tmp = ngettext("%d nonterminal useless in grammar", "%d nonterminals useless in grammar",
                   (unsigned long )nuseless_nonterminals);
#line 386
    warn((char const   *)tmp, nuseless_nonterminals);
    }
  }
#line 390
  if (nuseless_productions > 0) {
    {
#line 391
    tmp___0 = ngettext("%d rule useless in grammar", "%d rules useless in grammar",
                       (unsigned long )nuseless_productions);
#line 391
    warn((char const   *)tmp___0, nuseless_productions);
    }
  }
#line 395
  return;
}
}
#line 397 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
void reduce_grammar(void) 
{ 
  _Bool reduced ;
  char *tmp ;
  _Bool tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 404
  N = bitset_create((bitset_bindex )nvars, (bitset_attrs )1);
#line 405
  P = bitset_create((bitset_bindex )nrules, (bitset_attrs )1);
#line 406
  V = bitset_create((bitset_bindex )nsyms, (bitset_attrs )1);
#line 407
  V1 = bitset_create((bitset_bindex )nsyms, (bitset_attrs )1);
#line 409
  useless_nonterminals();
#line 410
  inaccessable_symbols();
#line 412
  reduced = (_Bool )(nuseless_nonterminals + nuseless_productions > 0);
  }
#line 413
  if (! reduced) {
#line 414
    return;
  }
  {
#line 416
  reduce_print();
#line 418
  tmp___0 = bitset_test(N, (bitset_bindex )(accept->number - ntokens));
  }
#line 418
  if (! tmp___0) {
    {
#line 419
    tmp = gettext("start symbol %s does not derive any sentence");
#line 419
    fatal_at(startsymbol_location, (char const   *)tmp, startsymbol->tag);
    }
  }
#line 426
  if (nuseless_nonterminals > 0) {
    {
#line 427
    nonterminals_reduce();
    }
  }
#line 428
  if (nuseless_productions > 0) {
    {
#line 429
    reduce_grammar_tables();
    }
  }
#line 431
  if (trace_flag & 128) {
    {
#line 433
    grammar_dump(stderr, "Reduced Grammar");
#line 435
    rpl_fprintf(stderr, "reduced %s defines %d terminals, %d nonterminals, and %d productions.\n",
                grammar_file, ntokens, nvars, nrules);
    }
  }
#line 439
  return;
}
}
#line 441 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
_Bool reduce_token_unused_in_grammar(symbol_number i ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 444
  if (! (i < ntokens)) {
    {
#line 444
    __assert_fail("i < ntokens", "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c",
                  444U, "reduce_token_unused_in_grammar");
    }
  }
  {
#line 445
  tmp = bitset_test(V, (bitset_bindex )i);
  }
#line 445
  if (tmp) {
#line 445
    tmp___1 = 0;
  } else {
    {
#line 445
    tmp___0 = bitset_test(V1, (bitset_bindex )i);
    }
#line 445
    if (tmp___0) {
#line 445
      tmp___1 = 0;
    } else {
#line 445
      tmp___1 = 1;
    }
  }
#line 445
  return ((_Bool )tmp___1);
}
}
#line 448 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
_Bool reduce_nonterminal_useless_in_grammar(symbol_number i ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 451
  if (ntokens <= i) {
#line 451
    if (! (i < nsyms + nuseless_nonterminals)) {
      {
#line 451
      __assert_fail("ntokens <= i && i < nsyms + nuseless_nonterminals", "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c",
                    451U, "reduce_nonterminal_useless_in_grammar");
      }
    }
  } else {
    {
#line 451
    __assert_fail("ntokens <= i && i < nsyms + nuseless_nonterminals", "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c",
                  451U, "reduce_nonterminal_useless_in_grammar");
    }
  }
#line 452
  return ((_Bool )(nsyms <= i));
}
}
#line 459 "/home/pronto/abs/test-suite/bison-2.5/src/reduce.c"
void reduce_free(void) 
{ 


  {
  {
#line 462
  bitset_free(N);
#line 463
  bitset_free(V);
#line 464
  bitset_free(V1);
#line 465
  bitset_free(P);
  }
#line 466
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 75 "/home/pronto/abs/test-suite/bison-2.5/src/complain.h"
void ( /* format attribute */  midrule_value_at)(location loc___0 , char const   *message 
                                                 , ...) ;
#line 87
_Bool complaint_issued ;
#line 41 "/home/pronto/abs/test-suite/bison-2.5/src/named-ref.h"
named_ref *named_ref_copy(named_ref const   *r ) ;
#line 117 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
item_number *ritem ;
#line 249
void ritem_print(FILE *out ) ;
#line 54 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool glr_parser ;
#line 188 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.h"
void muscle_percent_define_default(char const   *variable , char const   *value ) ;
#line 201
void muscle_percent_define_check_values(char const   * const  *values___0 ) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/reader.h"
int gram_debug ;
#line 40
int gram_parse(void) ;
#line 45
void grammar_start_symbol_set(symbol *sym , location loc___0 ) ;
#line 46
void grammar_current_rule_begin(symbol *lhs , location loc___0 , named_ref *lhs_name ) ;
#line 48
void grammar_current_rule_end(location loc___0 ) ;
#line 49
void grammar_midrule_action(void) ;
#line 50
void grammar_current_rule_prec_set(symbol *precsym , location loc___0 ) ;
#line 51
void grammar_current_rule_dprec_set(int dprec , location loc___0 ) ;
#line 52
void grammar_current_rule_merge_set(uniqstr name , location loc___0 ) ;
#line 53
void grammar_current_rule_symbol_append(symbol *sym , location loc___0 , named_ref *name ) ;
#line 55
void grammar_current_rule_action_append(char const   *action , location loc___0 ,
                                        named_ref *name ) ;
#line 57
void reader(void) ;
#line 58
void free_merger_functions(void) ;
#line 60 "/home/pronto/abs/test-suite/bison-2.5/src/reader.h"
merger_list *merge_functions  ;
#line 69
_Bool default_prec ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static void prepare_percent_define_front_end_variables(void) ;
#line 40
static void check_and_convert_grammar(void) ;
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static symbol_list *grammar  =    (symbol_list *)((void *)0);
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static _Bool start_flag  =    (_Bool)0;
#line 47 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
_Bool union_seen  =    (_Bool)0;
#line 50 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
_Bool tag_seen  =    (_Bool)0;
#line 53 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
_Bool default_prec  =    (_Bool)1;
#line 59 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void grammar_start_symbol_set(symbol *sym , location loc___0 ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 62
  if (start_flag) {
    {
#line 63
    tmp = gettext("multiple %s declarations");
#line 63
    complain_at(loc___0, (char const   *)tmp, "%start");
    }
  } else {
#line 66
    start_flag = (_Bool)1;
#line 67
    startsymbol = sym;
#line 68
    startsymbol_location = loc___0;
  }
#line 70
  return;
}
}
#line 79 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static int get_merge_function(uniqstr name ) 
{ 
  merger_list *syms ;
  merger_list head ;
  int n ;
  void *tmp ;

  {
#line 86
  if (! glr_parser) {
#line 87
    return (0);
  }
#line 89
  head.next = merge_functions;
#line 90
  syms = & head;
#line 90
  n = 1;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! syms->next) {
#line 90
      goto while_break;
    }
#line 91
    if ((unsigned long )name == (unsigned long )(syms->next)->name) {
#line 92
      goto while_break;
    }
#line 90
    syms = syms->next;
#line 90
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if ((unsigned long )syms->next == (unsigned long )((void *)0)) {
    {
#line 95
    tmp = xmalloc((size_t )sizeof(*(syms->next + 0)));
#line 95
    syms->next = (struct merger_list *)tmp;
#line 96
    (syms->next)->name = uniqstr_new(name);
#line 99
    (syms->next)->type = (uniqstr )((void *)0);
#line 100
    (syms->next)->next = (struct merger_list *)((void *)0);
#line 101
    merge_functions = head.next;
    }
  }
#line 103
  return (n);
}
}
#line 112 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static void record_merge_function_type(int merger , uniqstr type , location declaration_loc ) 
{ 
  int merger_find ;
  merger_list *merge_function ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 118
  if (merger <= 0) {
#line 119
    return;
  }
#line 121
  if ((unsigned long )type == (unsigned long )((void *)0)) {
    {
#line 122
    type = uniqstr_new("");
    }
  }
#line 124
  merger_find = 1;
#line 125
  merge_function = merge_functions;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if ((unsigned long )merge_function != (unsigned long )((void *)0)) {
#line 125
      if (! (merger_find != merger)) {
#line 125
        goto while_break;
      }
    } else {
#line 125
      goto while_break;
    }
#line 128
    merger_find ++;
#line 125
    merge_function = merge_function->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  if ((unsigned long )merge_function != (unsigned long )((void *)0)) {
#line 129
    if (! (merger_find == merger)) {
      {
#line 129
      __assert_fail("merge_function != ((void *)0) && merger_find == merger", "/home/pronto/abs/test-suite/bison-2.5/src/reader.c",
                    129U, "record_merge_function_type");
      }
    }
  } else {
    {
#line 129
    __assert_fail("merge_function != ((void *)0) && merger_find == merger", "/home/pronto/abs/test-suite/bison-2.5/src/reader.c",
                  129U, "record_merge_function_type");
    }
  }
#line 130
  if ((unsigned long )merge_function->type != (unsigned long )((void *)0)) {
#line 130
    if (! ((unsigned long )merge_function->type == (unsigned long )type)) {
      {
#line 132
      tmp = gettext("result type clash on merge function `%s\': <%s> != <%s>");
#line 132
      complain_at(declaration_loc, (char const   *)tmp, merge_function->name, type,
                  merge_function->type);
#line 135
      tmp___0 = gettext("previous declaration");
#line 135
      complain_at(merge_function->type_declaration_location, (char const   *)tmp___0);
      }
    }
  }
  {
#line 138
  merge_function->type = uniqstr_new(type);
#line 139
  merge_function->type_declaration_location = declaration_loc;
  }
#line 140
  return;
}
}
#line 146 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void free_merger_functions(void) 
{ 
  merger_list *L0 ;
  merger_list *L1 ;

  {
#line 149
  L0 = merge_functions;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! L0) {
#line 150
      goto while_break;
    }
    {
#line 152
    L1 = L0->next;
#line 153
    free((void *)L0);
#line 154
    L0 = L1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 171 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static symbol_list *grammar_end  =    (symbol_list *)((void *)0);
#line 174 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static symbol_list *grammar_symbol_append(symbol *sym , location loc___0 ) 
{ 
  symbol_list *p ;
  symbol_list *tmp ;

  {
  {
#line 177
  tmp = symbol_list_sym_new(sym, loc___0);
#line 177
  p = tmp;
  }
#line 179
  if (grammar_end) {
#line 180
    grammar_end->next = p;
  } else {
#line 182
    grammar = p;
  }
#line 184
  grammar_end = p;
#line 188
  if (sym) {
#line 189
    nritems ++;
  }
#line 191
  return (p);
}
}
#line 194 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static void assign_named_ref(symbol_list *p , named_ref *name ) 
{ 
  symbol *sym ;
  char const   *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 197
  sym = p->content.sym;
#line 199
  if ((unsigned long )name->id == (unsigned long )sym->tag) {
    {
#line 201
    tmp = quote(sym->tag);
#line 201
    tmp___0 = gettext("duplicated symbol name for %s ignored");
#line 201
    warn_at(name->loc, (char const   *)tmp___0, tmp);
#line 204
    named_ref_free(name);
    }
  } else {
#line 207
    p->named_ref = name;
  }
#line 208
  return;
}
}
#line 214 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static symbol_list *current_rule  =    (symbol_list *)((void *)0);
#line 215 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static symbol_list *previous_rule_end  =    (symbol_list *)((void *)0);
#line 222 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void grammar_current_rule_begin(symbol *lhs , location loc___0 , named_ref *lhs_name ) 
{ 
  symbol_list *p ;
  named_ref *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 229
  nrules ++;
#line 230
  previous_rule_end = grammar_end;
#line 232
  p = grammar_symbol_append(lhs, loc___0);
  }
#line 233
  if (lhs_name) {
    {
#line 234
    tmp = named_ref_copy((named_ref const   *)lhs_name);
#line 234
    assign_named_ref(p, tmp);
    }
  }
#line 236
  current_rule = grammar_end;
#line 239
  if ((unsigned int )lhs->class == 0U) {
#line 241
    lhs->class = (symbol_class )2;
#line 242
    lhs->number = nvars;
#line 243
    nvars ++;
  } else
#line 245
  if ((unsigned int )lhs->class == 1U) {
    {
#line 246
    tmp___0 = gettext("rule given for %s, which is a token");
#line 246
    complain_at(loc___0, (char const   *)tmp___0, lhs->tag);
    }
  }
#line 247
  return;
}
}
#line 258 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static _Bool symbol_should_be_used(symbol_list const   *s , _Bool *midrule_warning ) 
{ 
  code_props const   *tmp ;
  symbol_list *tmp___0 ;

  {
  {
#line 261
  tmp = symbol_destructor_get((symbol const   *)s->content.sym);
  }
#line 261
  if (tmp->code) {
#line 262
    return ((_Bool)1);
  }
#line 263
  if (s->midrule) {
#line 263
    if ((s->midrule)->action_props.is_value_used) {
#line 269
      *midrule_warning = (_Bool)1;
#line 270
      return ((_Bool)1);
    } else {
#line 263
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 263
  if (s->midrule_parent_rule) {
    {
#line 263
    tmp___0 = symbol_list_n_get((symbol_list *)s->midrule_parent_rule, (int )s->midrule_parent_rhs_index);
    }
#line 263
    if (tmp___0->action_props.is_value_used) {
#line 269
      *midrule_warning = (_Bool)1;
#line 270
      return ((_Bool)1);
    }
  }
#line 272
  return ((_Bool)0);
}
}
#line 280 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static void grammar_rule_check(symbol_list const   *r ) 
{ 
  symbol *first_rhs ;
  char const   *lhs_type ;
  char const   *rhs_type ;
  uniqstr tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  symbol_list const   *l ;
  int n ;
  _Bool midrule_warning ;
  void (*warn_at_ptr)(location  , char const   *  , ...) ;
  void ( /* format attribute */  (*tmp___2))(location loc , char const   *format 
                                             , ...) ;
  char *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 290
  if (! r->action_props.code) {
#line 290
    if ((r->content.sym)->type_name) {
#line 292
      first_rhs = (r->next)->content.sym;
#line 294
      if (first_rhs) {
#line 296
        lhs_type = (r->content.sym)->type_name;
#line 297
        if (first_rhs->type_name) {
#line 297
          tmp = first_rhs->type_name;
        } else {
#line 297
          tmp = "";
        }
#line 297
        rhs_type = tmp;
#line 299
        if (! ((unsigned long )lhs_type == (unsigned long )rhs_type)) {
          {
#line 300
          tmp___0 = gettext("type clash on default action: <%s> != <%s>");
#line 300
          warn_at((location )r->location, (char const   *)tmp___0, lhs_type, rhs_type);
          }
        }
      } else {
        {
#line 306
        tmp___1 = gettext("empty rule for typed nonterminal, and no action");
#line 306
        warn_at((location )r->location, (char const   *)tmp___1);
        }
      }
    }
  }
#line 312
  l = r;
#line 313
  n = 0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (l) {
#line 314
      if (! l->content.sym) {
#line 314
        goto while_break;
      }
    } else {
#line 314
      goto while_break;
    }
#line 316
    midrule_warning = (_Bool)0;
#line 317
    if (! l->action_props.is_value_used) {
      {
#line 317
      tmp___5 = symbol_should_be_used(l, & midrule_warning);
      }
#line 317
      if (tmp___5) {
#line 317
        if (r->action_props.code) {
#line 317
          goto _L;
        } else
#line 317
        if (n != 0) {
#line 317
          if (n != 1) {
            _L: /* CIL Label */ 
#line 322
            if (midrule_warning) {
#line 322
              tmp___2 = & midrule_value_at;
            } else {
#line 322
              tmp___2 = & warn_at;
            }
#line 322
            warn_at_ptr = (void (*)(location  , char const   *  , ...))tmp___2;
#line 324
            if (n) {
              {
#line 325
              tmp___3 = gettext("unused value: $%d");
#line 325
              (*warn_at_ptr)((location )r->location, (char const   *)tmp___3, n);
              }
            } else {
              {
#line 327
              tmp___4 = gettext("unset value: $$");
#line 327
              (*warn_at_ptr)((location )r->location, (char const   *)tmp___4);
              }
            }
          }
        }
      }
    }
#line 314
    l = (symbol_list const   *)l->next;
#line 314
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  if (r->ruleprec) {
#line 335
    if ((int const   )*((r->ruleprec)->tag + 0) != 39) {
#line 335
      if ((int const   )*((r->ruleprec)->tag + 0) != 34) {
#line 335
        if (! (r->ruleprec)->declared) {
#line 335
          if (! (r->ruleprec)->prec) {
            {
#line 338
            tmp___6 = gettext("token for %%prec is not defined: %s");
#line 338
            warn_at((location )r->location, (char const   *)tmp___6, (r->ruleprec)->tag);
            }
          }
        }
      }
    }
  }
#line 340
  return;
}
}
#line 347 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void grammar_current_rule_end(location loc___0 ) 
{ 


  {
  {
#line 351
  grammar_symbol_append((symbol *)((void *)0), grammar_end->location);
#line 352
  current_rule->location = loc___0;
  }
#line 353
  return;
}
}
#line 363 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void grammar_midrule_action(void) 
{ 
  location dummy_location ;
  symbol *dummy ;
  symbol *tmp ;
  symbol_list *midrule ;
  symbol_list *tmp___0 ;
  named_ref *action_name ;

  {
  {
#line 372
  dummy_location = current_rule->action_props.location;
#line 373
  tmp = dummy_symbol_get(dummy_location);
#line 373
  dummy = tmp;
#line 374
  tmp___0 = symbol_list_sym_new(dummy, dummy_location);
#line 374
  midrule = tmp___0;
#line 377
  action_name = current_rule->action_props.named_ref;
#line 381
  nrules ++;
#line 382
  nritems ++;
#line 384
  midrule->location = dummy_location;
#line 385
  code_props_rule_action_init(& midrule->action_props, current_rule->action_props.code,
                              current_rule->action_props.location, midrule, (named_ref *)0);
#line 389
  code_props_none_init(& current_rule->action_props);
  }
#line 391
  if (previous_rule_end) {
#line 392
    previous_rule_end->next = midrule;
  } else {
#line 394
    grammar = midrule;
  }
  {
#line 397
  midrule->next = symbol_list_sym_new((symbol *)((void *)0), dummy_location);
#line 398
  (midrule->next)->next = current_rule;
#line 400
  previous_rule_end = midrule->next;
#line 404
  grammar_current_rule_symbol_append(dummy, dummy_location, action_name);
#line 406
  grammar_end->midrule = midrule;
#line 407
  midrule->midrule_parent_rule = current_rule;
#line 408
  midrule->midrule_parent_rhs_index = symbol_list_length((symbol_list const   *)current_rule->next);
  }
#line 409
  return;
}
}
#line 413 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void grammar_current_rule_prec_set(symbol *precsym , location loc___0 ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 426
  symbol_class_set(precsym, (symbol_class )1, loc___0, (_Bool)0);
  }
#line 427
  if (current_rule->ruleprec) {
    {
#line 428
    tmp = gettext("only one %s allowed per rule");
#line 428
    complain_at(loc___0, (char const   *)tmp, "%prec");
    }
  }
#line 429
  current_rule->ruleprec = precsym;
#line 430
  return;
}
}
#line 434 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void grammar_current_rule_dprec_set(int dprec , location loc___0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 437
  if (! glr_parser) {
    {
#line 438
    tmp = gettext("%s affects only GLR parsers");
#line 438
    warn_at(loc___0, (char const   *)tmp, "%dprec");
    }
  }
#line 439
  if (dprec <= 0) {
    {
#line 440
    tmp___0 = gettext("%s must be followed by positive number");
#line 440
    complain_at(loc___0, (char const   *)tmp___0, "%dprec");
    }
  } else
#line 441
  if (current_rule->dprec != 0) {
    {
#line 442
    tmp___1 = gettext("only one %s allowed per rule");
#line 442
    complain_at(loc___0, (char const   *)tmp___1, "%dprec");
    }
  }
#line 443
  current_rule->dprec = dprec;
#line 444
  return;
}
}
#line 449 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void grammar_current_rule_merge_set(uniqstr name , location loc___0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 452
  if (! glr_parser) {
    {
#line 453
    tmp = gettext("%s affects only GLR parsers");
#line 453
    warn_at(loc___0, (char const   *)tmp, "%merge");
    }
  }
#line 454
  if (current_rule->merger != 0) {
    {
#line 455
    tmp___0 = gettext("only one %s allowed per rule");
#line 455
    complain_at(loc___0, (char const   *)tmp___0, "%merge");
    }
  }
  {
#line 456
  current_rule->merger = get_merge_function(name);
#line 457
  current_rule->merger_declaration_location = loc___0;
  }
#line 458
  return;
}
}
#line 463 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void grammar_current_rule_symbol_append(symbol *sym , location loc___0 , named_ref *name ) 
{ 
  symbol_list *p ;

  {
#line 468
  if (current_rule->action_props.code) {
    {
#line 469
    grammar_midrule_action();
    }
  }
  {
#line 470
  p = grammar_symbol_append(sym, loc___0);
  }
#line 471
  if (name) {
    {
#line 472
    assign_named_ref(p, name);
    }
  }
#line 473
  return;
}
}
#line 477 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void grammar_current_rule_action_append(char const   *action , location loc___0 ,
                                        named_ref *name ) 
{ 


  {
#line 481
  if (current_rule->action_props.code) {
    {
#line 482
    grammar_midrule_action();
    }
  }
  {
#line 485
  code_props_rule_action_init(& current_rule->action_props, action, loc___0, current_rule,
                              name);
  }
#line 487
  return;
}
}
#line 495 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static void packgram(void) 
{ 
  unsigned int itemno ;
  rule_number ruleno ;
  symbol_list *p ;
  void *tmp ;
  item_number *tmp___0 ;
  void *tmp___1 ;
  int rule_length ;
  symbol *ruleprec ;
  symbol_list *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 498
  itemno = 0U;
#line 499
  ruleno = 0;
#line 500
  p = grammar;
#line 502
  tmp = xnmalloc(nritems + 1U, (size_t )sizeof(*ritem));
#line 502
  ritem = (item_number *)tmp;
#line 505
  tmp___0 = ritem;
#line 505
  ritem ++;
#line 505
  *tmp___0 = 0;
#line 507
  tmp___1 = xnmalloc((size_t )nrules, (size_t )sizeof(*rules));
#line 507
  rules = (rule *)tmp___1;
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! p) {
#line 509
      goto while_break;
    }
    {
#line 511
    rule_length = 0;
#line 512
    ruleprec = p->ruleprec;
#line 513
    record_merge_function_type(p->merger, (p->content.sym)->type_name, p->merger_declaration_location);
#line 515
    (rules + ruleno)->user_number = ruleno;
#line 516
    (rules + ruleno)->number = ruleno;
#line 517
    (rules + ruleno)->lhs = p->content.sym;
#line 518
    (rules + ruleno)->rhs = ritem + itemno;
#line 519
    (rules + ruleno)->prec = (symbol *)((void *)0);
#line 520
    (rules + ruleno)->dprec = p->dprec;
#line 521
    (rules + ruleno)->merger = p->merger;
#line 522
    (rules + ruleno)->precsym = (symbol *)((void *)0);
#line 523
    (rules + ruleno)->location = p->location;
#line 524
    (rules + ruleno)->useful = (_Bool)1;
#line 525
    (rules + ruleno)->action = p->action_props.code;
#line 526
    (rules + ruleno)->action_location = p->action_props.location;
    }
#line 531
    if (p->midrule_parent_rule) {
#line 531
      if (p->action_props.is_value_used) {
#line 536
        ((p->content.sym)->tag) ++;
      } else {
        {
#line 531
        tmp___2 = symbol_list_n_get(p->midrule_parent_rule, p->midrule_parent_rhs_index);
        }
#line 531
        if (tmp___2->action_props.is_value_used) {
#line 536
          ((p->content.sym)->tag) ++;
        }
      }
    }
#line 541
    if ((unsigned long )p != (unsigned long )grammar) {
      {
#line 542
      grammar_rule_check((symbol_list const   *)p);
      }
    }
#line 544
    p = p->next;
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (p) {
#line 544
        if (! p->content.sym) {
#line 544
          goto while_break___0;
        }
      } else {
#line 544
        goto while_break___0;
      }
#line 546
      rule_length ++;
#line 550
      if (rule_length == 2147483647) {
        {
#line 551
        tmp___3 = gettext("rule is too long");
#line 551
        fatal_at((rules + ruleno)->location, (char const   *)tmp___3);
        }
      }
      {
#line 555
      tmp___4 = itemno;
#line 555
      itemno ++;
#line 555
      *(ritem + tmp___4) = symbol_number_as_item_number((p->content.sym)->number);
      }
#line 559
      if ((unsigned int )(p->content.sym)->class == 1U) {
#line 559
        if (default_prec) {
#line 560
          (rules + ruleno)->prec = p->content.sym;
        }
      }
#line 544
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 565
    if (ruleprec) {
#line 567
      (rules + ruleno)->precsym = ruleprec;
#line 568
      (rules + ruleno)->prec = ruleprec;
    }
    {
#line 571
    tmp___5 = itemno;
#line 571
    itemno ++;
#line 571
    *(ritem + tmp___5) = rule_number_as_item_number(ruleno);
    }
#line 572
    if (! (itemno < 2147483647U)) {
      {
#line 572
      __assert_fail("itemno < 2147483647", "/home/pronto/abs/test-suite/bison-2.5/src/reader.c",
                    572U, "packgram");
      }
    }
#line 573
    ruleno ++;
#line 574
    if (! (ruleno < 2147483647)) {
      {
#line 574
      __assert_fail("ruleno < 2147483647", "/home/pronto/abs/test-suite/bison-2.5/src/reader.c",
                    574U, "packgram");
      }
    }
#line 576
    if (p) {
#line 577
      p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  if (! (itemno == nritems)) {
    {
#line 580
    __assert_fail("itemno == nritems", "/home/pronto/abs/test-suite/bison-2.5/src/reader.c",
                  580U, "packgram");
    }
  }
#line 582
  if (trace_flag & 8) {
    {
#line 583
    ritem_print(stderr);
    }
  }
#line 584
  return;
}
}
#line 593 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
void reader(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 597
  symbols_new();
#line 600
  accept = symbol_get("$accept", (location )empty_location);
#line 601
  accept->class = (symbol_class )2;
#line 602
  tmp = nvars;
#line 602
  nvars ++;
#line 602
  accept->number = tmp;
#line 605
  errtoken = symbol_get("error", (location )empty_location);
#line 606
  errtoken->class = (symbol_class )1;
#line 607
  tmp___0 = ntokens;
#line 607
  ntokens ++;
#line 607
  errtoken->number = tmp___0;
#line 611
  undeftoken = symbol_get("$undefined", (location )empty_location);
#line 612
  undeftoken->class = (symbol_class )1;
#line 613
  tmp___1 = ntokens;
#line 613
  ntokens ++;
#line 613
  undeftoken->number = tmp___1;
#line 615
  gram_in = xfopen(grammar_file, "r");
#line 617
  gram__flex_debug = trace_flag & 1;
#line 618
  gram_debug = trace_flag & 2;
#line 619
  gram_scanner_initialize();
#line 620
  gram_parse();
#line 621
  prepare_percent_define_front_end_variables();
  }
#line 623
  if (! complaint_issued) {
    {
#line 624
    check_and_convert_grammar();
    }
  }
  {
#line 626
  xfclose(gram_in);
  }
#line 627
  return;
}
}
#line 649 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static char const   * const  values[11]  = 
#line 649
  {      (char const   */* const  */)"lr.type",      (char const   */* const  */)"lalr",      (char const   */* const  */)"ielr",      (char const   */* const  */)"canonical-lr", 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)"lr.default-reductions",      (char const   */* const  */)"most",      (char const   */* const  */)"consistent", 
        (char const   */* const  */)"accepting",      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0)};
#line 629 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static void prepare_percent_define_front_end_variables(void) 
{ 
  char *lr_type ;
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 633
  muscle_percent_define_default("lr.keep-unreachable-states", "false");
#line 638
  muscle_percent_define_default("lr.type", "lalr");
#line 639
  lr_type = muscle_percent_define_get("lr.type");
#line 640
  tmp = strcmp((char const   *)lr_type, "canonical-lr");
  }
#line 640
  if (0 != tmp) {
    {
#line 641
    muscle_percent_define_default("lr.default-reductions", "most");
    }
  } else {
    {
#line 643
    muscle_percent_define_default("lr.default-reductions", "accepting");
    }
  }
  {
#line 644
  free((void *)lr_type);
#line 654
  muscle_percent_define_check_values(values);
  }
#line 656
  return;
}
}
#line 664 "/home/pronto/abs/test-suite/bison-2.5/src/reader.c"
static void check_and_convert_grammar(void) 
{ 
  char *tmp ;
  symbol_list *node ;
  _Bool tmp___0 ;
  symbol_list *p ;
  symbol_list *tmp___1 ;
  symbol_list *sym ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 668
  if (nrules == 0) {
    {
#line 669
    tmp = gettext("no rules in the input grammar");
#line 669
    fatal((char const   *)tmp);
    }
  }
#line 672
  if (! endtoken) {
    {
#line 674
    endtoken = symbol_get("$end", (location )empty_location);
#line 675
    endtoken->class = (symbol_class )1;
#line 676
    endtoken->number = 0;
#line 678
    endtoken->user_token_number = 0;
    }
  }
  {
#line 682
  symbols_check_defined();
  }
#line 685
  if (! start_flag) {
#line 688
    node = grammar;
    {
#line 688
    while (1) {
      while_continue: /* CIL Label */ ;
#line 688
      if ((unsigned long )node != (unsigned long )((void *)0)) {
        {
#line 688
        tmp___0 = symbol_is_dummy((symbol const   *)node->content.sym);
        }
#line 688
        if (! tmp___0) {
#line 688
          goto while_break;
        }
      } else {
#line 688
        goto while_break;
      }
#line 692
      node = node->next;
      {
#line 692
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 692
        if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 692
          if (! ((unsigned long )node->content.sym != (unsigned long )((void *)0))) {
#line 692
            goto while_break___0;
          }
        } else {
#line 692
          goto while_break___0;
        }
#line 692
        node = node->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 688
      node = node->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 697
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
      {
#line 697
      __assert_fail("node != ((void *)0)", "/home/pronto/abs/test-suite/bison-2.5/src/reader.c",
                    697U, "check_and_convert_grammar");
      }
    }
    {
#line 698
    grammar_start_symbol_set(node->content.sym, (node->content.sym)->location);
    }
  }
  {
#line 707
  tmp___1 = symbol_list_sym_new(accept, (location )empty_location);
#line 707
  p = tmp___1;
#line 708
  p->location = grammar->location;
#line 709
  p->next = symbol_list_sym_new(startsymbol, (location )empty_location);
#line 710
  (p->next)->next = symbol_list_sym_new(endtoken, (location )empty_location);
#line 711
  ((p->next)->next)->next = symbol_list_sym_new((symbol *)((void *)0), (location )empty_location);
#line 712
  (((p->next)->next)->next)->next = grammar;
#line 713
  nrules ++;
#line 714
  nritems += 3U;
#line 715
  grammar = p;
  }
#line 718
  if (nsyms <= 2147483647) {
#line 718
    if (! (nsyms == ntokens + nvars)) {
      {
#line 718
      __assert_fail("nsyms <= 2147483647 && nsyms == ntokens + nvars", "/home/pronto/abs/test-suite/bison-2.5/src/reader.c",
                    718U, "check_and_convert_grammar");
      }
    }
  } else {
    {
#line 718
    __assert_fail("nsyms <= 2147483647 && nsyms == ntokens + nvars", "/home/pronto/abs/test-suite/bison-2.5/src/reader.c",
                  718U, "check_and_convert_grammar");
    }
  }
  {
#line 722
  symbols_pack();
#line 737
  sym = grammar;
  }
  {
#line 737
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 737
    if (! sym) {
#line 737
      goto while_break___1;
    }
    {
#line 738
    code_props_translate_code(& sym->action_props);
#line 737
    sym = sym->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 742
  packgram();
#line 745
  symbol_list_free(grammar);
  }
#line 746
  return;
}
}
#line 569 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) stpcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 163 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
__inline static _Bool item_number_is_rule_number(item_number i ) 
{ 


  {
#line 166
  return ((_Bool )(i < 0));
}
}
#line 261
void grammar_rules_print_xml(FILE *out , int level ) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/closure.h"
void new_closure(unsigned int n ) ;
#line 47
void closure(item_number *core , size_t n ) ;
#line 52
void free_closure(void) ;
#line 54
item_number *itemset ;
#line 55
size_t nitemset ;
#line 45 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
char *spec_xml_file ;
#line 23 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.h"
void xml_indent(FILE *out , int level ) ;
#line 26
char const   *xml_escape_n(int n , char const   *str ) ;
#line 28
void print_xml(void) ;
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static bitset no_reduce_set  ;
#line 49 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static struct escape_buf escape_bufs[3]  ;
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static void print_core(FILE *out , int level , state *s ) 
{ 
  size_t i ;
  item_number *sitems ;
  size_t snritems ;
  _Bool printed ;
  item_number *sp ;
  item_number *sp1 ;
  rule_number r ;
  reductions *reds ;
  int red ;
  int tmp ;
  _Bool tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 60
  sitems = s->items;
#line 61
  snritems = s->nitems;
#line 64
  closure(sitems, snritems);
#line 65
  sitems = itemset;
#line 66
  snritems = nitemset;
  }
#line 68
  if (! snritems) {
    {
#line 69
    xml_puts(out, level, "<itemset/>");
    }
#line 70
    return;
  }
  {
#line 73
  xml_puts(out, level, "<itemset>");
#line 75
  i = (size_t )0;
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < snritems)) {
#line 75
      goto while_break;
    }
#line 77
    printed = (_Bool)0;
#line 82
    sp = ritem + *(sitems + i);
#line 82
    sp1 = sp;
    {
#line 84
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 84
      if (! (*sp >= 0)) {
#line 84
        goto while_break___0;
      }
#line 85
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 87
    r = item_number_as_rule_number(*sp);
#line 88
    sp = (rules + r)->rhs;
#line 91
    tmp___0 = item_number_is_rule_number(*sp1);
    }
#line 91
    if (tmp___0) {
      {
#line 93
      reds = s->reductions;
#line 94
      tmp = state_reduction_find(s, rules + r);
#line 94
      red = tmp;
      }
#line 96
      if (reds->lookahead_tokens) {
#line 96
        if (red != -1) {
          {
#line 98
          xml_printf(out, level + 1, "<item rule-number=\"%d\" point=\"%d\">", (rules + r)->number,
                     sp1 - sp);
#line 101
          state_rule_lookahead_tokens_print_xml(s, rules + r, out, level + 2);
#line 103
          xml_puts(out, level + 1, "</item>");
#line 104
          printed = (_Bool)1;
          }
        }
      }
    }
#line 108
    if (! printed) {
      {
#line 110
      xml_printf(out, level + 1, "<item rule-number=\"%d\" point=\"%d\"/>", (rules + r)->number,
                 sp1 - sp);
      }
    }
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  xml_puts(out, level, "</itemset>");
  }
#line 117
  return;
}
}
#line 125 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static void print_transitions(state *s , FILE *out , int level ) 
{ 
  transitions *trans ;
  int n ;
  int i ;
  symbol *sym ;
  char const   *tag ;
  state *s1 ;
  char const   *tmp ;
  symbol *sym___0 ;
  char const   *tag___0 ;
  state *s1___0 ;
  char const   *tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 128
  trans = s->transitions;
#line 129
  n = 0;
#line 132
  i = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < trans->num)) {
#line 132
      goto while_break;
    }
#line 133
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 135
      n ++;
    }
#line 132
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (! n) {
    {
#line 140
    xml_puts(out, level, "<transitions/>");
    }
#line 141
    return;
  }
  {
#line 145
  xml_puts(out, level, "<transitions>");
#line 147
  i = 0;
  }
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! (i < trans->num)) {
#line 147
      goto while_break___0;
    }
#line 148
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 148
      if ((trans->states[i])->accessing_symbol < ntokens) {
        {
#line 151
        sym = *(symbols + (trans->states[i])->accessing_symbol);
#line 152
        tag = sym->tag;
#line 153
        s1 = trans->states[i];
#line 155
        tmp = xml_escape(tag);
#line 155
        xml_printf(out, level + 1, "<transition type=\"shift\" symbol=\"%s\" state=\"%d\"/>",
                   tmp, s1->number);
        }
      }
    }
#line 147
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  i = 0;
  {
#line 160
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 160
    if (! (i < trans->num)) {
#line 160
      goto while_break___1;
    }
#line 161
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 161
      if (! ((trans->states[i])->accessing_symbol < ntokens)) {
        {
#line 164
        sym___0 = *(symbols + (trans->states[i])->accessing_symbol);
#line 165
        tag___0 = sym___0->tag;
#line 166
        s1___0 = trans->states[i];
#line 168
        tmp___0 = xml_escape(tag___0);
#line 168
        xml_printf(out, level + 1, "<transition type=\"goto\" symbol=\"%s\" state=\"%d\"/>",
                   tmp___0, s1___0->number);
        }
      }
    }
#line 160
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 173
  xml_puts(out, level, "</transitions>");
  }
#line 174
  return;
}
}
#line 181 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static void print_errs(FILE *out , int level , state *s ) 
{ 
  errs *errp ;
  _Bool count ;
  int i ;
  char const   *tag ;
  char const   *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 184
  errp = s->errs;
#line 185
  count = (_Bool)0;
#line 188
  i = 0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < errp->num)) {
#line 188
      goto while_break;
    }
#line 189
    if (errp->symbols[i]) {
#line 190
      count = (_Bool)1;
    }
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (! count) {
    {
#line 194
    xml_puts(out, level, "<errors/>");
    }
#line 195
    return;
  }
  {
#line 199
  xml_puts(out, level, "<errors>");
#line 200
  i = 0;
  }
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (! (i < errp->num)) {
#line 200
      goto while_break___0;
    }
#line 201
    if (errp->symbols[i]) {
      {
#line 203
      tag = (errp->symbols[i])->tag;
#line 204
      tmp = xml_escape(tag);
#line 204
      xml_printf(out, level + 1, "<error symbol=\"%s\">nonassociative</error>", tmp);
      }
    }
#line 200
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 208
  xml_puts(out, level, "</errors>");
  }
#line 209
  return;
}
}
#line 218 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static void print_reduction(FILE *out , int level , char const   *lookahead_token ,
                            rule *r , _Bool enabled ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 222
  if (r->number) {
#line 223
    if (enabled) {
#line 223
      tmp = "true";
    } else {
#line 223
      tmp = "false";
    }
    {
#line 223
    tmp___0 = xml_escape(lookahead_token);
#line 223
    xml_printf(out, level, "<reduction symbol=\"%s\" rule=\"%d\" enabled=\"%s\"/>",
               tmp___0, r->number, tmp);
    }
  } else {
#line 229
    if (enabled) {
#line 229
      tmp___1 = "true";
    } else {
#line 229
      tmp___1 = "false";
    }
    {
#line 229
    tmp___2 = xml_escape(lookahead_token);
#line 229
    xml_printf(out, level, "<reduction symbol=\"%s\" rule=\"accept\" enabled=\"%s\"/>",
               tmp___2, tmp___1);
    }
  }
#line 233
  return;
}
}
#line 240 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static void print_reductions(FILE *out , int level , state *s ) 
{ 
  transitions *trans ;
  reductions *reds ;
  rule *default_reduction ;
  int report ;
  int i ;
  int j ;
  _Bool count ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool defaulted ;
  _Bool count___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 243
  trans = s->transitions;
#line 244
  reds = s->reductions;
#line 245
  default_reduction = (rule *)((void *)0);
#line 246
  report = 0;
#line 249
  if (reds->num == 0) {
    {
#line 251
    xml_puts(out, level, "<reductions/>");
    }
#line 252
    return;
  }
#line 255
  if (*(yydefact + s->number) != 0) {
#line 256
    default_reduction = rules + (*(yydefact + s->number) - 1);
  }
  {
#line 258
  (*((no_reduce_set->b.vtable)->zero))(no_reduce_set);
#line 259
  i = 0;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (i < trans->num) {
#line 259
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 259
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 259
          goto while_break;
        }
      }
    } else {
#line 259
      goto while_break;
    }
#line 259
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
      {
#line 260
      bitset_set(no_reduce_set, (bitset_bindex )(trans->states[i])->accessing_symbol);
      }
    }
#line 259
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 261
    if (! (i < (s->errs)->num)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((s->errs)->symbols[i]) {
      {
#line 263
      bitset_set(no_reduce_set, (bitset_bindex )((s->errs)->symbols[i])->number);
      }
    }
#line 261
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 265
  if (default_reduction) {
#line 266
    report = 1;
  }
#line 268
  if (reds->lookahead_tokens) {
#line 269
    i = 0;
    {
#line 269
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 269
      if (! (i < ntokens)) {
#line 269
        goto while_break___1;
      }
      {
#line 271
      tmp = bitset_test(no_reduce_set, (bitset_bindex )i);
#line 271
      count = tmp;
#line 273
      j = 0;
      }
      {
#line 273
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 273
        if (! (j < reds->num)) {
#line 273
          goto while_break___2;
        }
        {
#line 274
        tmp___0 = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
        }
#line 274
        if (tmp___0) {
#line 276
          if (! count) {
#line 278
            if ((unsigned long )reds->rules[j] != (unsigned long )default_reduction) {
#line 279
              report = 1;
            }
#line 280
            count = (_Bool)1;
          } else {
#line 284
            report = 1;
          }
        }
#line 273
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 269
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 290
  if (! report) {
    {
#line 291
    xml_puts(out, level, "<reductions/>");
    }
#line 292
    return;
  }
  {
#line 295
  xml_puts(out, level, "<reductions>");
  }
#line 298
  if (reds->lookahead_tokens) {
#line 299
    i = 0;
    {
#line 299
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 299
      if (! (i < ntokens)) {
#line 299
        goto while_break___3;
      }
      {
#line 301
      defaulted = (_Bool)0;
#line 302
      tmp___1 = bitset_test(no_reduce_set, (bitset_bindex )i);
#line 302
      count___0 = tmp___1;
#line 304
      j = 0;
      }
      {
#line 304
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 304
        if (! (j < reds->num)) {
#line 304
          goto while_break___4;
        }
        {
#line 305
        tmp___2 = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
        }
#line 305
        if (tmp___2) {
#line 307
          if (! count___0) {
#line 309
            if ((unsigned long )reds->rules[j] != (unsigned long )default_reduction) {
              {
#line 310
              print_reduction(out, level + 1, (*(symbols + i))->tag, reds->rules[j],
                              (_Bool)1);
              }
            } else {
#line 313
              defaulted = (_Bool)1;
            }
#line 314
            count___0 = (_Bool)1;
          } else {
#line 318
            if (defaulted) {
              {
#line 319
              print_reduction(out, level + 1, (*(symbols + i))->tag, default_reduction,
                              (_Bool)1);
              }
            }
            {
#line 321
            defaulted = (_Bool)0;
#line 322
            print_reduction(out, level + 1, (*(symbols + i))->tag, reds->rules[j],
                            (_Bool)0);
            }
          }
        }
#line 304
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 299
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 328
  if (default_reduction) {
    {
#line 329
    print_reduction(out, level + 1, "$default", default_reduction, (_Bool)1);
    }
  }
  {
#line 332
  xml_puts(out, level, "</reductions>");
  }
#line 333
  return;
}
}
#line 341 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static void print_actions(FILE *out , int level , state *s ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 344
  xml_puts(out, level, "<actions>");
#line 345
  print_transitions(s, out, level + 1);
#line 346
  print_errs(out, level + 1, s);
#line 347
  print_reductions(out, level + 1, s);
#line 348
  xml_puts(out, level, "</actions>");
  }
#line 349
  return;
}
}
#line 356 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static void print_state(FILE *out , int level , state *s ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 359
  fputc_unlocked('\n', out);
#line 360
  xml_printf(out, level, "<state number=\"%d\">", s->number);
#line 361
  print_core(out, level + 1, s);
#line 362
  print_actions(out, level + 1, s);
  }
#line 363
  if (s->solved_conflicts_xml) {
    {
#line 365
    xml_puts(out, level + 1, "<solved-conflicts>");
#line 366
    fputs_unlocked((char const   */* __restrict  */)s->solved_conflicts_xml, (FILE */* __restrict  */)out);
#line 367
    xml_puts(out, level + 1, "</solved-conflicts>");
    }
  } else {
    {
#line 370
    xml_puts(out, level + 1, "<solved-conflicts/>");
    }
  }
  {
#line 371
  xml_puts(out, level, "</state>");
  }
#line 372
  return;
}
}
#line 379 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static void print_grammar(FILE *out , int level ) 
{ 
  symbol_number i ;
  char const   *tag ;
  int precedence ;
  assoc associativity ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tag___0 ;
  char const   *tmp___5 ;
  _Bool tmp___6 ;
  char const   *tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 384
  fputc_unlocked('\n', out);
#line 385
  xml_puts(out, level, "<grammar>");
#line 386
  grammar_rules_print_xml(out, level);
#line 389
  xml_puts(out, level + 1, "<terminals>");
#line 390
  i = 0;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < max_user_token_number + 1)) {
#line 390
      goto while_break;
    }
#line 391
    if (*(token_translations + i) != undeftoken->number) {
      {
#line 393
      tag = (*(symbols + *(token_translations + i)))->tag;
#line 394
      precedence = (*(symbols + *(token_translations + i)))->prec;
#line 395
      associativity = (*(symbols + *(token_translations + i)))->assoc;
#line 396
      xml_indent(out, level + 2);
#line 397
      tmp___1 = reduce_token_unused_in_grammar(*(token_translations + i));
      }
#line 397
      if (tmp___1) {
#line 397
        tmp___0 = "unused-in-grammar";
      } else {
#line 397
        tmp___0 = "useful";
      }
      {
#line 397
      tmp___2 = xml_escape(tag);
#line 397
      rpl_fprintf(out, "<terminal symbol-number=\"%d\" token-number=\"%d\" name=\"%s\" usefulness=\"%s\"",
                  *(token_translations + i), i, tmp___2, tmp___0);
      }
#line 403
      if (precedence) {
        {
#line 404
        rpl_fprintf(out, " prec=\"%d\"", precedence);
        }
      }
#line 405
      if ((unsigned int )associativity != 0U) {
        {
#line 406
        tmp___3 = assoc_to_string(associativity);
#line 406
        rpl_fprintf(out, " assoc=\"%s\"", tmp___3 + 1);
        }
      }
      {
#line 407
      fputs_unlocked((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)out);
      }
    }
#line 390
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  xml_puts(out, level + 1, "</terminals>");
#line 412
  xml_puts(out, level + 1, "<nonterminals>");
#line 413
  i = ntokens;
  }
  {
#line 413
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 413
    if (! (i < nsyms + nuseless_nonterminals)) {
#line 413
      goto while_break___0;
    }
    {
#line 415
    tag___0 = (*(symbols + i))->tag;
#line 416
    tmp___6 = reduce_nonterminal_useless_in_grammar(i);
    }
#line 416
    if (tmp___6) {
#line 416
      tmp___5 = "useless-in-grammar";
    } else {
#line 416
      tmp___5 = "useful";
    }
    {
#line 416
    tmp___7 = xml_escape(tag___0);
#line 416
    xml_printf(out, level + 2, "<nonterminal symbol-number=\"%d\" name=\"%s\" usefulness=\"%s\"/>",
               i, tmp___7, tmp___5);
#line 413
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 423
  xml_puts(out, level + 1, "</nonterminals>");
#line 424
  xml_puts(out, level, "</grammar>");
  }
#line 425
  return;
}
}
#line 427 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
void xml_indent(FILE *out , int level ) 
{ 
  int i ;
  char *__cil_tmp4 ;

  {
#line 431
  i = 0;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (i < level)) {
#line 431
      goto while_break;
    }
    {
#line 432
    fputs_unlocked((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)out);
#line 431
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  return;
}
}
#line 435 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
void xml_puts(FILE *out , int level , char const   *s ) 
{ 


  {
  {
#line 438
  xml_indent(out, level);
#line 439
  fputs_unlocked((char const   */* __restrict  */)s, (FILE */* __restrict  */)out);
#line 440
  fputc_unlocked('\n', out);
  }
#line 441
  return;
}
}
#line 443 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
void xml_printf(FILE *out , int level , char const   *fmt  , ...) 
{ 
  va_list arglist ;

  {
  {
#line 448
  xml_indent(out, level);
#line 450
  __builtin_va_start(arglist, fmt);
#line 451
  rpl_vfprintf(out, fmt, arglist);
#line 452
  __builtin_va_end(arglist);
#line 454
  fputc_unlocked('\n', out);
  }
#line 455
  return;
}
}
#line 457 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
static char const   *xml_escape_string(struct escape_buf *buf___0 , char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t max_expansion ;
  char *p ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 460
  tmp = strlen(str);
#line 460
  len = tmp;
#line 461
  max_expansion = (size_t )(sizeof("&quot;") - 1UL);
  }
#line 464
  if (buf___0->size <= max_expansion * len) {
    {
#line 466
    buf___0->size = max_expansion * len + 1U;
#line 467
    tmp___0 = x2realloc((void *)buf___0->ptr, & buf___0->size);
#line 467
    buf___0->ptr = (char *)tmp___0;
    }
  }
#line 469
  p = buf___0->ptr;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! *str) {
#line 471
      goto while_break;
    }
    {
#line 475
    if ((int const   )*str == 38) {
#line 475
      goto case_38;
    }
#line 476
    if ((int const   )*str == 60) {
#line 476
      goto case_60;
    }
#line 477
    if ((int const   )*str == 62) {
#line 477
      goto case_62;
    }
#line 478
    if ((int const   )*str == 34) {
#line 478
      goto case_34;
    }
#line 474
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 474
    tmp___1 = p;
#line 474
    p ++;
#line 474
    *tmp___1 = (char )*str;
#line 474
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 475
    p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"&amp;");
    }
#line 475
    goto switch_break;
    case_60: /* CIL Label */ 
    {
#line 476
    p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"&lt;");
    }
#line 476
    goto switch_break;
    case_62: /* CIL Label */ 
    {
#line 477
    p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"&gt;");
    }
#line 477
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 478
    p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"&quot;");
    }
#line 478
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 471
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  *p = (char )'\000';
#line 482
  return ((char const   *)buf___0->ptr);
}
}
#line 485 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
char const   *xml_escape_n(int n , char const   *str ) 
{ 
  char const   *tmp ;

  {
  {
#line 488
  tmp = xml_escape_string(escape_bufs + n, str);
  }
#line 488
  return (tmp);
}
}
#line 491 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
char const   *xml_escape(char const   *str ) 
{ 
  char const   *tmp ;

  {
  {
#line 494
  tmp = xml_escape_n(0, str);
  }
#line 494
  return (tmp);
}
}
#line 497 "/home/pronto/abs/test-suite/bison-2.5/src/print-xml.c"
void print_xml(void) 
{ 
  state_number i ;
  int level ;
  FILE *out ;
  FILE *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 501
  level = 0;
#line 503
  tmp = xfopen((char const   *)spec_xml_file, "w");
#line 503
  out = tmp;
#line 505
  fputs_unlocked((char const   */* __restrict  */)"<?xml version=\"1.0\"?>\n\n", (FILE */* __restrict  */)out);
#line 506
  tmp___0 = xml_escape_n(2, "http://www.gnu.org/software/bison/");
#line 506
  tmp___1 = xml_escape_n(1, "bug-bison@gnu.org");
#line 506
  tmp___2 = xml_escape_n(0, "2.5");
#line 506
  xml_printf(out, level, "<bison-xml-report version=\"%s\" bug-report=\"%s\" url=\"%s\">",
             tmp___2, tmp___1, tmp___0);
#line 513
  fputc_unlocked('\n', out);
#line 514
  tmp___3 = xml_escape(grammar_file);
#line 514
  xml_printf(out, level + 1, "<filename>%s</filename>", tmp___3);
#line 518
  print_grammar(out, level + 1);
#line 520
  new_closure(nritems);
#line 521
  no_reduce_set = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 524
  fputc_unlocked('\n', out);
#line 525
  xml_puts(out, level + 1, "<automaton>");
#line 526
  i = 0;
  }
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if (! (i < nstates)) {
#line 526
      goto while_break;
    }
    {
#line 527
    print_state(out, level + 2, *(states + i));
#line 526
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 528
  xml_puts(out, level + 1, "</automaton>");
#line 530
  bitset_free(no_reduce_set);
#line 531
  free_closure();
#line 533
  xml_puts(out, 0, "</bison-xml-report>");
#line 535
  free((void *)escape_bufs[0].ptr);
#line 536
  free((void *)escape_bufs[1].ptr);
#line 538
  xfclose(out);
  }
#line 539
  return;
}
}
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
char *spec_graph_file ;
#line 90 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
int report_flag ;
#line 23 "/home/pronto/abs/test-suite/bison-2.5/src/print_graph.h"
void print_graph(void) ;
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/print_graph.c"
static void print_core___0(struct obstack *oout , state *s ) 
{ 
  size_t i ;
  item_number *sitems ;
  size_t snritems ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  item_number *sp ;
  item_number *sp1 ;
  rule_number r ;
  char buf___1[4096] ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  char buf___2[4096] ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  char *tmp___2 ;
  char buf___3[4096] ;
  struct obstack *__o___3 ;
  int __len___2 ;
  size_t tmp___3 ;
  reductions *reds ;
  int redno ;
  int tmp___4 ;
  bitset_iterator biter ;
  int k ;
  char const   *sep ;
  struct obstack *__o___4 ;
  int __len___3 ;
  size_t tmp___5 ;
  char buf___4[4096] ;
  struct obstack *__o___5 ;
  int __len___4 ;
  size_t tmp___6 ;
  struct obstack *__o___6 ;
  int __len___5 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 48
  sitems = s->items;
#line 49
  snritems = s->nitems;
#line 52
  if (report_flag & 2) {
    {
#line 54
    closure(sitems, snritems);
#line 55
    sitems = itemset;
#line 56
    snritems = nitemset;
    }
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    rpl_sprintf(buf___0, "%d", s->number);
#line 59
    __o = oout;
#line 59
    tmp = strlen((char const   *)(buf___0));
#line 59
    __len = (int )tmp;
    }
#line 59
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 59
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 59
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 59
    __o->next_free += __len;
    }
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  i = (size_t )0;
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 60
    if (! (i < snritems)) {
#line 60
      goto while_break___0;
    }
#line 66
    sp = ritem + *(sitems + i);
#line 66
    sp1 = sp;
    {
#line 68
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 68
      if (! (*sp >= 0)) {
#line 68
        goto while_break___1;
      }
#line 69
      sp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 71
    r = item_number_as_rule_number(*sp);
    }
    {
#line 73
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 73
      rpl_sprintf(buf___1, "\n%s -> ", ((rules + r)->lhs)->tag);
#line 73
      __o___0 = oout;
#line 73
      tmp___0 = strlen((char const   *)(buf___1));
#line 73
      __len___0 = (int )tmp___0;
      }
#line 73
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 73
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 73
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 73
      __o___0->next_free += __len___0;
      }
#line 73
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 75
    sp = (rules + r)->rhs;
    {
#line 75
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 75
      if (! ((unsigned long )sp < (unsigned long )sp1)) {
#line 75
        goto while_break___3;
      }
      {
#line 76
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 76
        rpl_sprintf(buf___2, "%s ", (*(symbols + *sp))->tag);
#line 76
        __o___1 = oout;
#line 76
        tmp___1 = strlen((char const   *)(buf___2));
#line 76
        __len___1 = (int )tmp___1;
        }
#line 76
        if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
          {
#line 76
          _obstack_newchunk(__o___1, __len___1);
          }
        }
        {
#line 76
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___2),
               (size_t )__len___1);
#line 76
        __o___1->next_free += __len___1;
        }
#line 76
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 75
      sp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 78
    __o___2 = oout;
#line 78
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 78
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 78
    tmp___2 = __o___2->next_free;
#line 78
    (__o___2->next_free) ++;
#line 78
    *tmp___2 = (char )'.';
    {
#line 80
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 80
      if (! (*sp >= 0)) {
#line 80
        goto while_break___5;
      }
      {
#line 81
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 81
        rpl_sprintf(buf___3, " %s", (*(symbols + *sp))->tag);
#line 81
        __o___3 = oout;
#line 81
        tmp___3 = strlen((char const   *)(buf___3));
#line 81
        __len___2 = (int )tmp___3;
        }
#line 81
        if ((unsigned long )(__o___3->next_free + __len___2) > (unsigned long )__o___3->chunk_limit) {
          {
#line 81
          _obstack_newchunk(__o___3, __len___2);
          }
        }
        {
#line 81
        memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___3),
               (size_t )__len___2);
#line 81
        __o___3->next_free += __len___2;
        }
#line 81
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 80
      sp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 84
    if (report_flag & 4) {
      {
#line 84
      tmp___8 = item_number_is_rule_number(*sp1);
      }
#line 84
      if (tmp___8) {
        {
#line 88
        reds = s->reductions;
#line 89
        tmp___4 = state_reduction_find(s, rules + r);
#line 89
        redno = tmp___4;
        }
#line 92
        if (reds->lookahead_tokens) {
#line 92
          if (redno != -1) {
            {
#line 96
            sep = "";
#line 97
            __o___4 = oout;
#line 97
            tmp___5 = strlen("[");
#line 97
            __len___3 = (int )tmp___5;
            }
#line 97
            if ((unsigned long )(__o___4->next_free + __len___3) > (unsigned long )__o___4->chunk_limit) {
              {
#line 97
              _obstack_newchunk(__o___4, __len___3);
              }
            }
            {
#line 97
            memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)"[",
                   (size_t )__len___3);
#line 97
            __o___4->next_free += __len___3;
#line 98
            biter.next = (bitset_bindex )0;
#line 98
            biter.num = (bitset_bindex )1024;
            }
            {
#line 98
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 98
              if (biter.num == 1024U) {
                {
#line 98
                biter.num = (*(((*(reds->lookahead_tokens + redno))->b.vtable)->list))(*(reds->lookahead_tokens + redno),
                                                                                       biter.list,
                                                                                       (bitset_bindex )1024,
                                                                                       & biter.next);
                }
#line 98
                if (! biter.num) {
#line 98
                  goto while_break___7;
                }
              } else {
#line 98
                goto while_break___7;
              }
#line 98
              biter.i = (bitset_bindex )0;
              {
#line 98
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 98
                if (biter.i < biter.num) {
#line 98
                  k = (int )biter.list[biter.i];
                } else {
#line 98
                  goto while_break___8;
                }
                {
#line 100
                while (1) {
                  while_continue___9: /* CIL Label */ ;
                  {
#line 100
                  rpl_sprintf(buf___4, "%s%s", sep, (*(symbols + k))->tag);
#line 100
                  __o___5 = oout;
#line 100
                  tmp___6 = strlen((char const   *)(buf___4));
#line 100
                  __len___4 = (int )tmp___6;
                  }
#line 100
                  if ((unsigned long )(__o___5->next_free + __len___4) > (unsigned long )__o___5->chunk_limit) {
                    {
#line 100
                    _obstack_newchunk(__o___5, __len___4);
                    }
                  }
                  {
#line 100
                  memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___4),
                         (size_t )__len___4);
#line 100
                  __o___5->next_free += __len___4;
                  }
#line 100
                  goto while_break___9;
                }
                while_break___9: /* CIL Label */ ;
                }
#line 101
                sep = ", ";
#line 98
                (biter.i) ++;
              }
              while_break___8: /* CIL Label */ ;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 103
            __o___6 = oout;
#line 103
            tmp___7 = strlen("]");
#line 103
            __len___5 = (int )tmp___7;
            }
#line 103
            if ((unsigned long )(__o___6->next_free + __len___5) > (unsigned long )__o___6->chunk_limit) {
              {
#line 103
              _obstack_newchunk(__o___6, __len___5);
              }
            }
            {
#line 103
            memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)"]",
                   (size_t )__len___5);
#line 103
            __o___6->next_free += __len___5;
            }
          }
        }
      }
    }
#line 60
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 115 "/home/pronto/abs/test-suite/bison-2.5/src/print_graph.c"
static void print_actions___0(state const   *s , FILE *fgraph ) 
{ 
  int i ;
  transitions const   *trans ;
  state *s1 ;
  symbol_number sym ;
  char const   *style ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  uniqstr tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 120
  trans = (transitions const   *)s->transitions;
#line 122
  if (! trans->num) {
#line 122
    if (! s->reductions) {
#line 123
      return;
    }
  }
#line 125
  i = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i < (int )trans->num)) {
#line 125
      goto while_break;
    }
#line 126
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 128
      s1 = trans->states[i];
#line 129
      sym = s1->accessing_symbol;
#line 132
      if ((trans->states[i])->accessing_symbol == errtoken->number) {
#line 132
        tmp___0 = "dotted";
      } else {
#line 132
        if ((trans->states[i])->accessing_symbol < ntokens) {
#line 132
          tmp = "solid";
        } else {
#line 132
          tmp = "dashed";
        }
#line 132
        tmp___0 = tmp;
      }
#line 132
      style = tmp___0;
#line 137
      if ((trans->states[i])->accessing_symbol == errtoken->number) {
        {
#line 137
        tmp___1 = strcmp((*(symbols + sym))->tag, "error");
        }
#line 137
        if (tmp___1 != 0) {
          {
#line 139
          abort();
          }
        }
      }
#line 140
      if ((trans->states[i])->accessing_symbol == errtoken->number) {
#line 140
        tmp___2 = (uniqstr )((void *)0);
      } else {
#line 140
        tmp___2 = (*(symbols + sym))->tag;
      }
      {
#line 140
      output_edge((int )s->number, s1->number, tmp___2, style, fgraph);
      }
    }
#line 125
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 152 "/home/pronto/abs/test-suite/bison-2.5/src/print_graph.c"
static void print_state___0(state *s , FILE *fgraph ) 
{ 
  struct obstack node_obstack ;
  struct obstack *__o ;
  char *tmp ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___2 ;

  {
  {
#line 158
  _obstack_begin(& node_obstack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 159
  print_core___0(& node_obstack, s);
#line 160
  __o = & node_obstack;
  }
#line 160
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 160
    _obstack_newchunk(__o, 1);
    }
  }
#line 160
  tmp = __o->next_free;
#line 160
  (__o->next_free) ++;
#line 160
  *tmp = (char )'\000';
#line 161
  __o1 = & node_obstack;
#line 161
  __value = (void *)__o1->object_base;
#line 161
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 161
    __o1->maybe_empty_object = 1U;
  }
#line 161
  if (sizeof(int ) < sizeof(void *)) {
#line 161
    tmp___0 = __o1->object_base;
  } else {
#line 161
    tmp___0 = (char *)0;
  }
#line 161
  if (sizeof(int ) < sizeof(void *)) {
#line 161
    tmp___1 = __o1->object_base;
  } else {
#line 161
    tmp___1 = (char *)0;
  }
#line 161
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 161
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 161
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 161
  __o1->object_base = __o1->next_free;
#line 161
  output_node(s->number, (char const   *)__value, fgraph);
#line 162
  __o___0 = & node_obstack;
#line 162
  __obj = (void *)0;
  }
#line 162
  if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 162
    if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 162
      tmp___2 = (char *)__obj;
#line 162
      __o___0->object_base = tmp___2;
#line 162
      __o___0->next_free = tmp___2;
    } else {
      {
#line 162
      obstack_free(__o___0, __obj);
      }
    }
  } else {
    {
#line 162
    obstack_free(__o___0, __obj);
    }
  }
  {
#line 165
  print_actions___0((state const   *)s, fgraph);
  }
#line 166
  return;
}
}
#line 169 "/home/pronto/abs/test-suite/bison-2.5/src/print_graph.c"
void print_graph(void) 
{ 
  state_number i ;
  FILE *fgraph ;
  FILE *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 173
  tmp = xfopen((char const   *)spec_graph_file, "w");
#line 173
  fgraph = tmp;
#line 174
  start_graph(fgraph);
#line 177
  new_closure(nritems);
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < nstates)) {
#line 178
      goto while_break;
    }
    {
#line 179
    print_state___0(*(states + i), fgraph);
#line 178
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  free_closure();
#line 182
  finish_graph(fgraph);
#line 183
  xfclose(fgraph);
  }
#line 184
  return;
}
}
#line 134 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
__inline static symbol_number item_number_as_symbol_number(item_number i ) 
{ 


  {
#line 137
  return (i);
}
}
#line 217
_Bool rule_useless_in_parser_p(rule *r ) ;
#line 222
void rule_lhs_print(rule *r , symbol *previous_lhs , FILE *out ) ;
#line 259
void grammar_rules_print(FILE *out ) ;
#line 41 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.h"
void conflicts_output(FILE *out ) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
char *spec_verbose_file ;
#line 23 "/home/pronto/abs/test-suite/bison-2.5/src/print.h"
void print_results(void) ;
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static bitset no_reduce_set___0  ;
#line 58 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static void max_length(size_t *width___0 , char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;

  {
  {
#line 61
  tmp = strlen(str);
#line 61
  len = tmp;
  }
#line 62
  if (len > *width___0) {
#line 63
    *width___0 = len;
  }
#line 64
  return;
}
}
#line 70 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static void print_core___1(FILE *out , state *s ) 
{ 
  size_t i ;
  item_number *sitems ;
  size_t snritems ;
  symbol *previous_lhs ;
  item_number *sp ;
  item_number *sp1 ;
  rule_number r ;
  _Bool tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 74
  sitems = s->items;
#line 75
  snritems = s->nitems;
#line 76
  previous_lhs = (symbol *)((void *)0);
#line 79
  if (report_flag & 2) {
    {
#line 81
    closure(sitems, snritems);
#line 82
    sitems = itemset;
#line 83
    snritems = nitemset;
    }
  }
#line 86
  if (! snritems) {
#line 87
    return;
  }
  {
#line 89
  fputc_unlocked('\n', out);
#line 91
  i = (size_t )0;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < snritems)) {
#line 91
      goto while_break;
    }
#line 97
    sp = ritem + *(sitems + i);
#line 97
    sp1 = sp;
    {
#line 99
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 99
      if (! (*sp >= 0)) {
#line 99
        goto while_break___0;
      }
#line 100
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 102
    r = item_number_as_rule_number(*sp);
#line 104
    rule_lhs_print(rules + r, previous_lhs, out);
#line 105
    previous_lhs = (rules + r)->lhs;
#line 107
    sp = (rules + r)->rhs;
    }
    {
#line 107
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 107
      if (! ((unsigned long )sp < (unsigned long )sp1)) {
#line 107
        goto while_break___1;
      }
      {
#line 108
      rpl_fprintf(out, " %s", (*(symbols + *sp))->tag);
#line 107
      sp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 109
    fputs_unlocked((char const   */* __restrict  */)" .", (FILE */* __restrict  */)out);
    }
    {
#line 110
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 110
      if (! (*sp >= 0)) {
#line 110
        goto while_break___2;
      }
      {
#line 111
      rpl_fprintf(out, " %s", (*(symbols + *sp))->tag);
#line 110
      sp ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 114
    if (report_flag & 4) {
      {
#line 114
      tmp = item_number_is_rule_number(*sp1);
      }
#line 114
      if (tmp) {
        {
#line 116
        state_rule_lookahead_tokens_print(s, rules + r, out);
        }
      }
    }
    {
#line 118
    fputc_unlocked('\n', out);
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 128 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static void print_transitions___0(state *s , FILE *out , _Bool display_transitions_p ) 
{ 
  transitions *trans ;
  size_t width___0 ;
  int i ;
  symbol *sym ;
  symbol *sym___0 ;
  char const   *tag ;
  state *s1 ;
  int j ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 131
  trans = s->transitions;
#line 132
  width___0 = (size_t )0;
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < trans->num)) {
#line 136
      goto while_break;
    }
#line 137
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 137
      if (((trans->states[i])->accessing_symbol < ntokens) == (int )display_transitions_p) {
        {
#line 140
        sym = *(symbols + (trans->states[i])->accessing_symbol);
#line 141
        max_length(& width___0, sym->tag);
        }
      }
    }
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  if (! width___0) {
#line 146
    return;
  }
  {
#line 148
  fputc_unlocked('\n', out);
#line 149
  width___0 += 2U;
#line 152
  i = 0;
  }
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (! (i < trans->num)) {
#line 152
      goto while_break___0;
    }
#line 153
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 153
      if (((trans->states[i])->accessing_symbol < ntokens) == (int )display_transitions_p) {
        {
#line 156
        sym___0 = *(symbols + (trans->states[i])->accessing_symbol);
#line 157
        tag = sym___0->tag;
#line 158
        s1 = trans->states[i];
#line 161
        rpl_fprintf(out, "    %s", tag);
#line 162
        tmp = strlen(tag);
#line 162
        j = (int )(width___0 - tmp);
        }
        {
#line 162
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 162
          if (! (j > 0)) {
#line 162
            goto while_break___1;
          }
          {
#line 163
          fputc_unlocked(' ', out);
#line 162
          j --;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 164
        if (display_transitions_p) {
          {
#line 165
          tmp___0 = gettext("shift, and go to state %d\n");
#line 165
          rpl_fprintf(out, (char const   *)tmp___0, s1->number);
          }
        } else {
          {
#line 167
          tmp___1 = gettext("go to state %d\n");
#line 167
          rpl_fprintf(out, (char const   *)tmp___1, s1->number);
          }
        }
      }
    }
#line 152
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 169
  return;
}
}
#line 176 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static void print_errs___0(FILE *out , state *s ) 
{ 
  errs *errp ;
  size_t width___0 ;
  int i ;
  char const   *tag ;
  int j ;
  size_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 179
  errp = s->errs;
#line 180
  width___0 = (size_t )0;
#line 184
  i = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i < errp->num)) {
#line 184
      goto while_break;
    }
#line 185
    if (errp->symbols[i]) {
      {
#line 186
      max_length(& width___0, (errp->symbols[i])->tag);
      }
    }
#line 184
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if (! width___0) {
#line 190
    return;
  }
  {
#line 192
  fputc_unlocked('\n', out);
#line 193
  width___0 += 2U;
#line 196
  i = 0;
  }
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 196
    if (! (i < errp->num)) {
#line 196
      goto while_break___0;
    }
#line 197
    if (errp->symbols[i]) {
      {
#line 199
      tag = (errp->symbols[i])->tag;
#line 201
      rpl_fprintf(out, "    %s", tag);
#line 202
      tmp = strlen(tag);
#line 202
      j = (int )(width___0 - tmp);
      }
      {
#line 202
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 202
        if (! (j > 0)) {
#line 202
          goto while_break___1;
        }
        {
#line 203
        fputc_unlocked(' ', out);
#line 202
        j --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 204
      tmp___0 = gettext("error (nonassociative)\n");
#line 204
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)out);
      }
    }
#line 196
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 215 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static void print_reduction___0(FILE *out , size_t width___0 , char const   *lookahead_token ,
                                rule *r , _Bool enabled ) 
{ 
  int j ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 221
  rpl_fprintf(out, "    %s", lookahead_token);
#line 222
  tmp = strlen(lookahead_token);
#line 222
  j = (int )(width___0 - tmp);
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (j > 0)) {
#line 222
      goto while_break;
    }
    {
#line 223
    fputc_unlocked(' ', out);
#line 222
    j --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  if (! enabled) {
    {
#line 225
    fputc_unlocked('[', out);
    }
  }
#line 226
  if (r->number) {
    {
#line 227
    tmp___0 = gettext("reduce using rule %d (%s)");
#line 227
    rpl_fprintf(out, (char const   *)tmp___0, r->number, (r->lhs)->tag);
    }
  } else {
    {
#line 229
    tmp___1 = gettext("accept");
#line 229
    rpl_fprintf(out, (char const   *)tmp___1);
    }
  }
#line 230
  if (! enabled) {
    {
#line 231
    fputc_unlocked(']', out);
    }
  }
  {
#line 232
  fputc_unlocked('\n', out);
  }
#line 233
  return;
}
}
#line 240 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static void print_reductions___0(FILE *out , state *s ) 
{ 
  transitions *trans ;
  reductions *reds ;
  rule *default_reduction ;
  size_t width___0 ;
  int i ;
  int j ;
  _Bool default_reduction_only ;
  char *tmp ;
  _Bool count ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool defaulted ;
  _Bool count___0 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char *default_reductions ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 243
  trans = s->transitions;
#line 244
  reds = s->reductions;
#line 245
  default_reduction = (rule *)((void *)0);
#line 246
  width___0 = (size_t )0;
#line 248
  default_reduction_only = (_Bool)1;
#line 250
  if (reds->num == 0) {
#line 251
    return;
  }
#line 253
  if (*(yydefact + s->number) != 0) {
#line 254
    default_reduction = rules + (*(yydefact + s->number) - 1);
  }
  {
#line 256
  (*((no_reduce_set___0->b.vtable)->zero))(no_reduce_set___0);
#line 257
  i = 0;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (i < trans->num) {
#line 257
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 257
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 257
          goto while_break;
        }
      }
    } else {
#line 257
      goto while_break;
    }
#line 257
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
      {
#line 258
      bitset_set(no_reduce_set___0, (bitset_bindex )(trans->states[i])->accessing_symbol);
      }
    }
#line 257
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  i = 0;
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 259
    if (! (i < (s->errs)->num)) {
#line 259
      goto while_break___0;
    }
#line 260
    if ((s->errs)->symbols[i]) {
      {
#line 261
      bitset_set(no_reduce_set___0, (bitset_bindex )((s->errs)->symbols[i])->number);
      }
    }
#line 259
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 264
  if (default_reduction) {
    {
#line 265
    tmp = gettext("$default");
#line 265
    width___0 = strlen((char const   *)tmp);
    }
  }
#line 267
  if (reds->lookahead_tokens) {
#line 268
    i = 0;
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      if (! (i < ntokens)) {
#line 268
        goto while_break___1;
      }
      {
#line 270
      tmp___0 = bitset_test(no_reduce_set___0, (bitset_bindex )i);
#line 270
      count = tmp___0;
#line 272
      j = 0;
      }
      {
#line 272
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 272
        if (! (j < reds->num)) {
#line 272
          goto while_break___2;
        }
        {
#line 273
        tmp___1 = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
        }
#line 273
        if (tmp___1) {
#line 275
          if (! count) {
#line 277
            if ((unsigned long )reds->rules[j] != (unsigned long )default_reduction) {
              {
#line 278
              max_length(& width___0, (*(symbols + i))->tag);
              }
            }
#line 279
            count = (_Bool)1;
          } else {
            {
#line 283
            max_length(& width___0, (*(symbols + i))->tag);
            }
          }
        }
#line 272
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 268
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 289
  if (! width___0) {
#line 290
    return;
  }
  {
#line 292
  fputc_unlocked('\n', out);
#line 293
  width___0 += 2U;
  }
#line 296
  if (reds->lookahead_tokens) {
#line 297
    i = 0;
    {
#line 297
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 297
      if (! (i < ntokens)) {
#line 297
        goto while_break___3;
      }
      {
#line 299
      defaulted = (_Bool)0;
#line 300
      tmp___2 = bitset_test(no_reduce_set___0, (bitset_bindex )i);
#line 300
      count___0 = tmp___2;
      }
#line 301
      if (count___0) {
#line 302
        default_reduction_only = (_Bool)0;
      }
#line 304
      j = 0;
      {
#line 304
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 304
        if (! (j < reds->num)) {
#line 304
          goto while_break___4;
        }
        {
#line 305
        tmp___3 = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
        }
#line 305
        if (tmp___3) {
#line 307
          if (! count___0) {
#line 309
            if ((unsigned long )reds->rules[j] != (unsigned long )default_reduction) {
              {
#line 311
              default_reduction_only = (_Bool)0;
#line 312
              print_reduction___0(out, width___0, (*(symbols + i))->tag, reds->rules[j],
                                  (_Bool)1);
              }
            } else {
#line 317
              defaulted = (_Bool)1;
            }
#line 318
            count___0 = (_Bool)1;
          } else {
#line 322
            default_reduction_only = (_Bool)0;
#line 323
            if (defaulted) {
              {
#line 324
              print_reduction___0(out, width___0, (*(symbols + i))->tag, default_reduction,
                                  (_Bool)1);
              }
            }
            {
#line 327
            defaulted = (_Bool)0;
#line 328
            print_reduction___0(out, width___0, (*(symbols + i))->tag, reds->rules[j],
                                (_Bool)0);
            }
          }
        }
#line 304
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 297
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 335
  if (default_reduction) {
    {
#line 337
    tmp___4 = muscle_percent_define_get("lr.default-reductions");
#line 337
    default_reductions = tmp___4;
#line 339
    tmp___5 = gettext("$default");
#line 339
    print_reduction___0(out, width___0, (char const   *)tmp___5, default_reduction,
                        (_Bool)1);
#line 340
    tmp___6 = strcmp((char const   *)default_reductions, "most");
    }
#line 340
    if (! (0 == tmp___6)) {
      {
#line 340
      tmp___7 = strcmp((char const   *)default_reductions, "consistent");
      }
#line 340
      if (0 == tmp___7) {
#line 340
        if (! default_reduction_only) {
#line 340
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 340
      if (reds->num == 1) {
#line 340
        if (! ((reds->rules[0])->number == 0)) {
          {
#line 340
          __assert_fail("0 == strcmp (default_reductions, \"most\") || (0 == strcmp (default_reductions, \"consistent\") && default_reduction_only) || (reds->num == 1 && reds->rules[0]->number == 0)",
                        "/home/pronto/abs/test-suite/bison-2.5/src/print.c", 343U,
                        "print_reductions");
          }
        }
      } else {
        {
#line 340
        __assert_fail("0 == strcmp (default_reductions, \"most\") || (0 == strcmp (default_reductions, \"consistent\") && default_reduction_only) || (reds->num == 1 && reds->rules[0]->number == 0)",
                      "/home/pronto/abs/test-suite/bison-2.5/src/print.c", 343U, "print_reductions");
        }
      }
    }
    {
#line 344
    free((void *)default_reductions);
    }
  }
#line 346
  return;
}
}
#line 354 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static void print_actions___1(FILE *out , state *s ) 
{ 


  {
  {
#line 358
  print_transitions___0(s, out, (_Bool)1);
#line 359
  print_errs___0(out, s);
#line 360
  print_reductions___0(out, s);
#line 362
  print_transitions___0(s, out, (_Bool)0);
  }
#line 363
  return;
}
}
#line 370 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static void print_state___1(FILE *out , state *s ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 373
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
#line 374
  tmp = gettext("state %d");
#line 374
  rpl_fprintf(out, (char const   *)tmp, s->number);
#line 375
  fputc_unlocked('\n', out);
#line 376
  print_core___1(out, s);
#line 377
  print_actions___1(out, s);
  }
#line 378
  if (report_flag & 8) {
#line 378
    if (s->solved_conflicts) {
      {
#line 380
      fputc_unlocked('\n', out);
#line 381
      fputs_unlocked((char const   */* __restrict  */)s->solved_conflicts, (FILE */* __restrict  */)out);
      }
    }
  }
#line 383
  return;
}
}
#line 400 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
static void print_grammar___0(FILE *out ) 
{ 
  symbol_number i ;
  char buffer[90] ;
  int column ;
  char *tmp ;
  char const   *tag ;
  rule_number r ;
  item_number *rhsp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  symbol_number tmp___4 ;
  char *tmp___5 ;
  int left_count ;
  int right_count ;
  rule_number r___0 ;
  char const   *tag___0 ;
  item_number *rhsp___0 ;
  symbol_number tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  item_number *rhsp___1 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  symbol_number tmp___20 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
  {
#line 405
  column = 0;
#line 407
  grammar_rules_print(out);
#line 410
  tmp = gettext("Terminals, with rules where they appear");
#line 410
  rpl_fprintf(out, "%s\n\n", tmp);
#line 411
  i = 0;
  }
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (i < max_user_token_number + 1)) {
#line 411
      goto while_break;
    }
#line 412
    if (*(token_translations + i) != undeftoken->number) {
      {
#line 414
      tag = (*(symbols + *(token_translations + i)))->tag;
#line 418
      buffer[0] = (char)0;
#line 419
      tmp___0 = strlen(tag);
#line 419
      column = (int )tmp___0;
#line 420
      fputs_unlocked((char const   */* __restrict  */)tag, (FILE */* __restrict  */)out);
      }
      {
#line 421
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 421
        tmp___1 = strlen((char const   *)(buffer));
        }
#line 421
        if ((size_t )column + tmp___1 > 65U) {
          {
#line 421
          rpl_fprintf(out, "%s\n   ", buffer);
#line 421
          column = 3;
#line 421
          buffer[0] = (char)0;
          }
        }
#line 421
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 422
      rpl_sprintf(buffer, " (%d)", i);
#line 424
      r = 0;
      }
      {
#line 424
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 424
        if (! (r < nrules)) {
#line 424
          goto while_break___1;
        }
#line 425
        rhsp = (rules + r)->rhs;
        {
#line 425
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 425
          if (! (*rhsp >= 0)) {
#line 425
            goto while_break___2;
          }
          {
#line 426
          tmp___4 = item_number_as_symbol_number(*rhsp);
          }
#line 426
          if (tmp___4 == *(token_translations + i)) {
            {
#line 428
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 428
              tmp___2 = strlen((char const   *)(buffer));
              }
#line 428
              if ((size_t )column + tmp___2 > 65U) {
                {
#line 428
                rpl_fprintf(out, "%s\n   ", buffer);
#line 428
                column = 3;
#line 428
                buffer[0] = (char)0;
                }
              }
#line 428
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 429
            tmp___3 = strlen((char const   *)(buffer));
#line 429
            rpl_sprintf(buffer + tmp___3, " %d", r);
            }
#line 430
            goto while_break___2;
          }
#line 425
          rhsp ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 424
        r ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 432
      rpl_fprintf(out, "%s\n", buffer);
      }
    }
#line 411
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
#line 437
  tmp___5 = gettext("Nonterminals, with rules where they appear");
#line 437
  rpl_fprintf(out, "%s\n\n", tmp___5);
#line 438
  i = ntokens;
  }
  {
#line 438
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 438
    if (! (i < nsyms)) {
#line 438
      goto while_break___4;
    }
#line 440
    left_count = 0;
#line 440
    right_count = 0;
#line 442
    tag___0 = (*(symbols + i))->tag;
#line 444
    r___0 = 0;
    {
#line 444
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 444
      if (! (r___0 < nrules)) {
#line 444
        goto while_break___5;
      }
#line 447
      if (((rules + r___0)->lhs)->number == i) {
#line 448
        left_count ++;
      }
#line 449
      rhsp___0 = (rules + r___0)->rhs;
      {
#line 449
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 449
        if (! (*rhsp___0 >= 0)) {
#line 449
          goto while_break___6;
        }
        {
#line 450
        tmp___6 = item_number_as_symbol_number(*rhsp___0);
        }
#line 450
        if (tmp___6 == i) {
#line 452
          right_count ++;
#line 453
          goto while_break___6;
        }
#line 449
        rhsp___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 444
      r___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 457
    buffer[0] = (char)0;
#line 458
    fputs_unlocked((char const   */* __restrict  */)tag___0, (FILE */* __restrict  */)out);
#line 459
    tmp___7 = strlen(tag___0);
#line 459
    column = (int )tmp___7;
#line 460
    rpl_sprintf(buffer, " (%d)", i);
    }
    {
#line 461
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 461
      tmp___8 = strlen((char const   *)(buffer));
      }
#line 461
      if ((size_t )column + tmp___8 > 0U) {
        {
#line 461
        rpl_fprintf(out, "%s\n   ", buffer);
#line 461
        column = 3;
#line 461
        buffer[0] = (char)0;
        }
      }
#line 461
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 463
    if (left_count > 0) {
      {
#line 465
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 465
        tmp___9 = strlen((char const   *)(buffer));
        }
#line 465
        if ((size_t )column + tmp___9 > 65U) {
          {
#line 465
          rpl_fprintf(out, "%s\n   ", buffer);
#line 465
          column = 3;
#line 465
          buffer[0] = (char)0;
          }
        }
#line 465
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 466
      tmp___10 = gettext(" on left:");
#line 466
      tmp___11 = strlen((char const   *)(buffer));
#line 466
      rpl_sprintf(buffer + tmp___11, (char const   *)tmp___10);
#line 468
      r___0 = 0;
      }
      {
#line 468
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 468
        if (! (r___0 < nrules)) {
#line 468
          goto while_break___9;
        }
#line 470
        if (((rules + r___0)->lhs)->number == i) {
          {
#line 472
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 472
            tmp___12 = strlen((char const   *)(buffer));
            }
#line 472
            if ((size_t )column + tmp___12 > 65U) {
              {
#line 472
              rpl_fprintf(out, "%s\n   ", buffer);
#line 472
              column = 3;
#line 472
              buffer[0] = (char)0;
              }
            }
#line 472
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 473
          tmp___13 = strlen((char const   *)(buffer));
#line 473
          rpl_sprintf(buffer + tmp___13, " %d", r___0);
          }
        }
#line 468
        r___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 478
    if (right_count > 0) {
#line 480
      if (left_count > 0) {
        {
#line 481
        tmp___14 = strlen((char const   *)(buffer));
#line 481
        rpl_sprintf(buffer + tmp___14, ",");
        }
      }
      {
#line 482
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 482
        tmp___15 = strlen((char const   *)(buffer));
        }
#line 482
        if ((size_t )column + tmp___15 > 65U) {
          {
#line 482
          rpl_fprintf(out, "%s\n   ", buffer);
#line 482
          column = 3;
#line 482
          buffer[0] = (char)0;
          }
        }
#line 482
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 483
      tmp___16 = gettext(" on right:");
#line 483
      tmp___17 = strlen((char const   *)(buffer));
#line 483
      rpl_sprintf(buffer + tmp___17, (char const   *)tmp___16);
#line 484
      r___0 = 0;
      }
      {
#line 484
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 484
        if (! (r___0 < nrules)) {
#line 484
          goto while_break___12;
        }
#line 487
        rhsp___1 = (rules + r___0)->rhs;
        {
#line 487
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 487
          if (! (*rhsp___1 >= 0)) {
#line 487
            goto while_break___13;
          }
          {
#line 488
          tmp___20 = item_number_as_symbol_number(*rhsp___1);
          }
#line 488
          if (tmp___20 == i) {
            {
#line 490
            while (1) {
              while_continue___14: /* CIL Label */ ;
              {
#line 490
              tmp___18 = strlen((char const   *)(buffer));
              }
#line 490
              if ((size_t )column + tmp___18 > 65U) {
                {
#line 490
                rpl_fprintf(out, "%s\n   ", buffer);
#line 490
                column = 3;
#line 490
                buffer[0] = (char)0;
                }
              }
#line 490
              goto while_break___14;
            }
            while_break___14: /* CIL Label */ ;
            }
            {
#line 491
            tmp___19 = strlen((char const   *)(buffer));
#line 491
            rpl_sprintf(buffer + tmp___19, " %d", r___0);
            }
#line 492
            goto while_break___13;
          }
#line 487
          rhsp___1 ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 484
        r___0 ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
    {
#line 496
    rpl_fprintf(out, "%s\n", buffer);
#line 438
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 498
  return;
}
}
#line 500 "/home/pronto/abs/test-suite/bison-2.5/src/print.c"
void print_results(void) 
{ 
  state_number i ;
  FILE *out ;
  FILE *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 507
  tmp = xfopen((char const   *)spec_verbose_file, "w");
#line 507
  out = tmp;
#line 509
  reduce_output(out);
#line 510
  tmp___0 = gettext("Rules useless in parser due to conflicts");
#line 510
  grammar_rules_partial_print(out, (char const   *)tmp___0, & rule_useless_in_parser_p);
#line 513
  conflicts_output(out);
#line 515
  print_grammar___0(out);
  }
#line 519
  if (report_flag & 2) {
    {
#line 520
    new_closure(nritems);
    }
  }
  {
#line 522
  no_reduce_set___0 = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 523
  i = 0;
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (i < nstates)) {
#line 523
      goto while_break;
    }
    {
#line 524
    print_state___1(out, *(states + i));
#line 523
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 525
  bitset_free(no_reduce_set___0);
  }
#line 526
  if (report_flag & 2) {
    {
#line 527
    free_closure();
    }
  }
  {
#line 529
  xfclose(out);
  }
#line 530
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strverscmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 45 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 72 "/home/pronto/abs/test-suite/bison-2.5/src/location.h"
__inline static _Bool equal_boundaries(boundary a , boundary b ) 
{ 
  int tmp ;

  {
#line 75
  if (a.column == b.column) {
#line 75
    if (a.line == b.line) {
#line 75
      if ((unsigned long )a.file == (unsigned long )b.file) {
#line 75
        tmp = 1;
      } else {
#line 75
        tmp = 0;
      }
    } else {
#line 75
      tmp = 0;
    }
  } else {
#line 75
    tmp = 0;
  }
#line 75
  return ((_Bool )tmp);
}
}
#line 103
unsigned int location_print(FILE *out , location loc___0 ) ;
#line 38 "/home/pronto/abs/test-suite/bison-2.5/src/named-ref.h"
named_ref *named_ref_new(uniqstr id , location loc___0 ) ;
#line 45 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.h"
int expected_sr_conflicts ;
#line 46
int expected_rr_conflicts ;
#line 27 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
char const   *spec_outfile ;
#line 33
char const   *spec_name_prefix ;
#line 36
char const   *spec_file_prefix ;
#line 48
char *spec_defines_file ;
#line 38 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool debug_flag ;
#line 39
_Bool defines_flag ;
#line 43
_Bool no_lines_flag ;
#line 44
_Bool token_table_flag ;
#line 47
_Bool error_verbose ;
#line 143
void language_argmatch(char const   *arg , int prio , location loc___0 ) ;
#line 144
void skeleton_arg(char const   *arg , int prio , location loc___0 ) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.h"
char const   *muscle_find_const(char const   *key ) ;
#line 103
void muscle_code_grow(char const   *key , char const   *val , location loc___0 ) ;
#line 110
void muscle_pair_list_grow(char const   *muscle , char const   *a1 , char const   *a2 ) ;
#line 143
void muscle_percent_define_insert(char const   *variable , location variable_loc ,
                                  char const   *value , muscle_percent_define_how how ) ;
#line 182
_Bool muscle_percent_define_flag_if(char const   *variable ) ;
#line 207
void muscle_percent_code_grow(char const   *qualifier , location qualifier_loc , char const   *code ,
                              location code_loc ) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/reader.h"
int gram_debug  ;
#line 41
char const   *token_name(int type ) ;
#line 37 "parse-gram.y"
static location lloc_default(location const   *rhs , int n ) ;
#line 42
static void version_check(location const   *loc___0 , char const   *version___0 ) ;
#line 49
static void gram_error(location const   *loc___0 , char const   *msg ) ;
#line 51
static char const   *char_name(char c ) ;
#line 59
static void add_param(char const   *type , char *decl , location loc___0 ) ;
#line 62 "parse-gram.y"
static symbol_class current_class  =    (symbol_class )0;
#line 63 "parse-gram.y"
static uniqstr current_type  =    (uniqstr )((void *)0);
#line 64 "parse-gram.y"
static symbol *current_lhs_symbol  ;
#line 65 "parse-gram.y"
static location current_lhs_location  ;
#line 66 "parse-gram.y"
static named_ref *current_lhs_named_ref  ;
#line 67 "parse-gram.y"
static int current_prec  =    0;
#line 72 "parse-gram.y"
static void current_lhs(symbol *sym , location loc___0 , named_ref *ref ) 
{ 


  {
  {
#line 76
  current_lhs_symbol = sym;
#line 77
  current_lhs_location = loc___0;
#line 83
  free((void *)current_lhs_named_ref);
#line 84
  current_lhs_named_ref = ref;
  }
#line 85
  return;
}
}
#line 580 "parse-gram.c"
static yytype_uint8 const   yytranslate[313]  = 
#line 580 "parse-gram.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57};
#line 619 "parse-gram.c"
static yytype_uint16 const   yyprhs[109]  = 
#line 619
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )3,      (yytype_uint16 const   )8, 
        (yytype_uint16 const   )9,      (yytype_uint16 const   )12,      (yytype_uint16 const   )14,      (yytype_uint16 const   )16, 
        (yytype_uint16 const   )18,      (yytype_uint16 const   )22,      (yytype_uint16 const   )24,      (yytype_uint16 const   )27, 
        (yytype_uint16 const   )29,      (yytype_uint16 const   )32,      (yytype_uint16 const   )35,      (yytype_uint16 const   )38, 
        (yytype_uint16 const   )42,      (yytype_uint16 const   )44,      (yytype_uint16 const   )47,      (yytype_uint16 const   )50, 
        (yytype_uint16 const   )53,      (yytype_uint16 const   )55,      (yytype_uint16 const   )58,      (yytype_uint16 const   )62, 
        (yytype_uint16 const   )64,      (yytype_uint16 const   )66,      (yytype_uint16 const   )69,      (yytype_uint16 const   )73, 
        (yytype_uint16 const   )76,      (yytype_uint16 const   )78,      (yytype_uint16 const   )81,      (yytype_uint16 const   )84, 
        (yytype_uint16 const   )86,      (yytype_uint16 const   )88,      (yytype_uint16 const   )90,      (yytype_uint16 const   )92, 
        (yytype_uint16 const   )94,      (yytype_uint16 const   )96,      (yytype_uint16 const   )99,      (yytype_uint16 const   )103, 
        (yytype_uint16 const   )107,      (yytype_uint16 const   )109,      (yytype_uint16 const   )111,      (yytype_uint16 const   )114, 
        (yytype_uint16 const   )118,      (yytype_uint16 const   )119,      (yytype_uint16 const   )121,      (yytype_uint16 const   )125, 
        (yytype_uint16 const   )126,      (yytype_uint16 const   )130,      (yytype_uint16 const   )131,      (yytype_uint16 const   )135, 
        (yytype_uint16 const   )139,      (yytype_uint16 const   )143,      (yytype_uint16 const   )145,      (yytype_uint16 const   )147, 
        (yytype_uint16 const   )149,      (yytype_uint16 const   )150,      (yytype_uint16 const   )152,      (yytype_uint16 const   )154, 
        (yytype_uint16 const   )157,      (yytype_uint16 const   )159,      (yytype_uint16 const   )162,      (yytype_uint16 const   )164, 
        (yytype_uint16 const   )167,      (yytype_uint16 const   )169,      (yytype_uint16 const   )172,      (yytype_uint16 const   )174, 
        (yytype_uint16 const   )176,      (yytype_uint16 const   )178,      (yytype_uint16 const   )180,      (yytype_uint16 const   )182, 
        (yytype_uint16 const   )184,      (yytype_uint16 const   )187,      (yytype_uint16 const   )190,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )199,      (yytype_uint16 const   )201,      (yytype_uint16 const   )204, 
        (yytype_uint16 const   )206,      (yytype_uint16 const   )209,      (yytype_uint16 const   )212,      (yytype_uint16 const   )213, 
        (yytype_uint16 const   )218,      (yytype_uint16 const   )220,      (yytype_uint16 const   )224,      (yytype_uint16 const   )227, 
        (yytype_uint16 const   )228,      (yytype_uint16 const   )232,      (yytype_uint16 const   )236,      (yytype_uint16 const   )240, 
        (yytype_uint16 const   )244,      (yytype_uint16 const   )248,      (yytype_uint16 const   )249,      (yytype_uint16 const   )251, 
        (yytype_uint16 const   )253,      (yytype_uint16 const   )255,      (yytype_uint16 const   )256,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )260,      (yytype_uint16 const   )262,      (yytype_uint16 const   )264,      (yytype_uint16 const   )266, 
        (yytype_uint16 const   )268,      (yytype_uint16 const   )270,      (yytype_uint16 const   )272,      (yytype_uint16 const   )274, 
        (yytype_uint16 const   )275};
#line 635 "parse-gram.c"
static yytype_int8 const   yyrhs[278]  = 
#line 635
  {      (yytype_int8 const   )59,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )60, 
        (yytype_int8 const   )50,      (yytype_int8 const   )77,      (yytype_int8 const   )91,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )60,      (yytype_int8 const   )61,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )62,      (yytype_int8 const   )-1,      (yytype_int8 const   )52,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-1,      (yytype_int8 const   )19,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )-1,      (yytype_int8 const   )20,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )21, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )22,      (yytype_int8 const   )4,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )23,      (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )24, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )47, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )25,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )26,      (yytype_int8 const   )43,      (yytype_int8 const   )-1,      (yytype_int8 const   )27, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )28,      (yytype_int8 const   )43, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )29,      (yytype_int8 const   )-1,      (yytype_int8 const   )30, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )47, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )32,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )33,      (yytype_int8 const   )-1,      (yytype_int8 const   )34,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )34,      (yytype_int8 const   )47,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )35,      (yytype_int8 const   )43,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )36,      (yytype_int8 const   )-1,      (yytype_int8 const   )37,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )38,      (yytype_int8 const   )3,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )40,      (yytype_int8 const   )-1,      (yytype_int8 const   )41,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )42,      (yytype_int8 const   )-1,      (yytype_int8 const   )53,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )67,      (yytype_int8 const   )-1,      (yytype_int8 const   )64,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )39,      (yytype_int8 const   )89,      (yytype_int8 const   )-1,      (yytype_int8 const   )8, 
        (yytype_int8 const   )43,      (yytype_int8 const   )73,      (yytype_int8 const   )-1,      (yytype_int8 const   )9, 
        (yytype_int8 const   )43,      (yytype_int8 const   )73,      (yytype_int8 const   )-1,      (yytype_int8 const   )18, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )16, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-1,      (yytype_int8 const   )16,      (yytype_int8 const   )48, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )48, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )57,      (yytype_int8 const   )63,      (yytype_int8 const   )86, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )6,      (yytype_int8 const   )65, 
        (yytype_int8 const   )76,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )5, 
        (yytype_int8 const   )66,      (yytype_int8 const   )76,      (yytype_int8 const   )-1,      (yytype_int8 const   )7, 
        (yytype_int8 const   )54,      (yytype_int8 const   )72,      (yytype_int8 const   )-1,      (yytype_int8 const   )68, 
        (yytype_int8 const   )69,      (yytype_int8 const   )70,      (yytype_int8 const   )-1,      (yytype_int8 const   )10, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )11,      (yytype_int8 const   )-1,      (yytype_int8 const   )12, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )54,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-1,      (yytype_int8 const   )70,      (yytype_int8 const   )71, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )89,      (yytype_int8 const   )-1,      (yytype_int8 const   )89, 
        (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )89,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )72,      (yytype_int8 const   )89,      (yytype_int8 const   )-1,      (yytype_int8 const   )74, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )89,      (yytype_int8 const   )-1,      (yytype_int8 const   )54,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )55,      (yytype_int8 const   )-1,      (yytype_int8 const   )56,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )54,      (yytype_int8 const   )-1,      (yytype_int8 const   )87,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )87,      (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )87, 
        (yytype_int8 const   )90,      (yytype_int8 const   )-1,      (yytype_int8 const   )87,      (yytype_int8 const   )4, 
        (yytype_int8 const   )90,      (yytype_int8 const   )-1,      (yytype_int8 const   )75,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )76,      (yytype_int8 const   )75,      (yytype_int8 const   )-1,      (yytype_int8 const   )78, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )77,      (yytype_int8 const   )78,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )79,      (yytype_int8 const   )-1,      (yytype_int8 const   )62,      (yytype_int8 const   )53, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )1,      (yytype_int8 const   )53,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )88,      (yytype_int8 const   )83,      (yytype_int8 const   )80, 
        (yytype_int8 const   )81,      (yytype_int8 const   )-1,      (yytype_int8 const   )82,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )81,      (yytype_int8 const   )51,      (yytype_int8 const   )82,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )81,      (yytype_int8 const   )53,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )82,      (yytype_int8 const   )89,      (yytype_int8 const   )83,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )82,      (yytype_int8 const   )43,      (yytype_int8 const   )83,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )82,      (yytype_int8 const   )13,      (yytype_int8 const   )89,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )82,      (yytype_int8 const   )14,      (yytype_int8 const   )4,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )82,      (yytype_int8 const   )15,      (yytype_int8 const   )54,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )44,      (yytype_int8 const   )-1,      (yytype_int8 const   )48, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )48,      (yytype_int8 const   )-1,      (yytype_int8 const   )3,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )43,      (yytype_int8 const   )-1,      (yytype_int8 const   )48,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )45,      (yytype_int8 const   )-1,      (yytype_int8 const   )49,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )87,      (yytype_int8 const   )-1,      (yytype_int8 const   )90,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )50, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-1};
#line 668 "parse-gram.c"
static yytype_uint16 const   yyrline[109]  = 
#line 668
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )228,      (yytype_uint16 const   )228,      (yytype_uint16 const   )236, 
        (yytype_uint16 const   )238,      (yytype_uint16 const   )242,      (yytype_uint16 const   )243,      (yytype_uint16 const   )253, 
        (yytype_uint16 const   )254,      (yytype_uint16 const   )259,      (yytype_uint16 const   )260,      (yytype_uint16 const   )265, 
        (yytype_uint16 const   )266,      (yytype_uint16 const   )267,      (yytype_uint16 const   )268,      (yytype_uint16 const   )269, 
        (yytype_uint16 const   )270,      (yytype_uint16 const   )275,      (yytype_uint16 const   )284,      (yytype_uint16 const   )285, 
        (yytype_uint16 const   )286,      (yytype_uint16 const   )287,      (yytype_uint16 const   )288,      (yytype_uint16 const   )289, 
        (yytype_uint16 const   )290,      (yytype_uint16 const   )291,      (yytype_uint16 const   )292,      (yytype_uint16 const   )293, 
        (yytype_uint16 const   )294,      (yytype_uint16 const   )309,      (yytype_uint16 const   )310,      (yytype_uint16 const   )334, 
        (yytype_uint16 const   )335,      (yytype_uint16 const   )336,      (yytype_uint16 const   )337,      (yytype_uint16 const   )341, 
        (yytype_uint16 const   )342,      (yytype_uint16 const   )343,      (yytype_uint16 const   )347,      (yytype_uint16 const   )354, 
        (yytype_uint16 const   )361,      (yytype_uint16 const   )365,      (yytype_uint16 const   )369,      (yytype_uint16 const   )376, 
        (yytype_uint16 const   )391,      (yytype_uint16 const   )392,      (yytype_uint16 const   )396,      (yytype_uint16 const   )408, 
        (yytype_uint16 const   )408,      (yytype_uint16 const   )413,      (yytype_uint16 const   )413,      (yytype_uint16 const   )418, 
        (yytype_uint16 const   )429,      (yytype_uint16 const   )444,      (yytype_uint16 const   )445,      (yytype_uint16 const   )446, 
        (yytype_uint16 const   )450,      (yytype_uint16 const   )451,      (yytype_uint16 const   )456,      (yytype_uint16 const   )458, 
        (yytype_uint16 const   )463,      (yytype_uint16 const   )464,      (yytype_uint16 const   )469,      (yytype_uint16 const   )471, 
        (yytype_uint16 const   )476,      (yytype_uint16 const   )477,      (yytype_uint16 const   )481,      (yytype_uint16 const   )482, 
        (yytype_uint16 const   )483,      (yytype_uint16 const   )484,      (yytype_uint16 const   )489,      (yytype_uint16 const   )494, 
        (yytype_uint16 const   )499,      (yytype_uint16 const   )505,      (yytype_uint16 const   )511,      (yytype_uint16 const   )522, 
        (yytype_uint16 const   )523,      (yytype_uint16 const   )532,      (yytype_uint16 const   )533,      (yytype_uint16 const   )539, 
        (yytype_uint16 const   )540,      (yytype_uint16 const   )541,      (yytype_uint16 const   )548,      (yytype_uint16 const   )548, 
        (yytype_uint16 const   )556,      (yytype_uint16 const   )557,      (yytype_uint16 const   )558,      (yytype_uint16 const   )563, 
        (yytype_uint16 const   )565,      (yytype_uint16 const   )567,      (yytype_uint16 const   )569,      (yytype_uint16 const   )571, 
        (yytype_uint16 const   )573,      (yytype_uint16 const   )578,      (yytype_uint16 const   )580,      (yytype_uint16 const   )591, 
        (yytype_uint16 const   )592,      (yytype_uint16 const   )597,      (yytype_uint16 const   )598,      (yytype_uint16 const   )599, 
        (yytype_uint16 const   )608,      (yytype_uint16 const   )628,      (yytype_uint16 const   )630,      (yytype_uint16 const   )639, 
        (yytype_uint16 const   )644,      (yytype_uint16 const   )645,      (yytype_uint16 const   )650,      (yytype_uint16 const   )657, 
        (yytype_uint16 const   )659};
#line 687 "parse-gram.c"
static char const   * const  yytname[93]  = 
#line 687
  {      (char const   */* const  */)"\"end of file\"",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"\"string\"", 
        (char const   */* const  */)"\"integer\"",      (char const   */* const  */)"\"%token\"",      (char const   */* const  */)"\"%nterm\"",      (char const   */* const  */)"\"%type\"", 
        (char const   */* const  */)"\"%destructor\"",      (char const   */* const  */)"\"%printer\"",      (char const   */* const  */)"\"%left\"",      (char const   */* const  */)"\"%right\"", 
        (char const   */* const  */)"\"%nonassoc\"",      (char const   */* const  */)"\"%prec\"",      (char const   */* const  */)"\"%dprec\"",      (char const   */* const  */)"\"%merge\"", 
        (char const   */* const  */)"\"%code\"",      (char const   */* const  */)"\"%debug\"",      (char const   */* const  */)"\"%default-prec\"",      (char const   */* const  */)"\"%define\"", 
        (char const   */* const  */)"\"%defines\"",      (char const   */* const  */)"\"%error-verbose\"",      (char const   */* const  */)"\"%expect\"",      (char const   */* const  */)"\"%expect-rr\"", 
        (char const   */* const  */)"\"%file-prefix\"",      (char const   */* const  */)"\"%glr-parser\"",      (char const   */* const  */)"\"%initial-action\"",      (char const   */* const  */)"\"%language\"", 
        (char const   */* const  */)"\"%lex-param\"",      (char const   */* const  */)"\"%locations\"",      (char const   */* const  */)"\"%name-prefix\"",      (char const   */* const  */)"\"%no-default-prec\"", 
        (char const   */* const  */)"\"%no-lines\"",      (char const   */* const  */)"\"%nondeterministic-parser\"",      (char const   */* const  */)"\"%output\"",      (char const   */* const  */)"\"%parse-param\"", 
        (char const   */* const  */)"\"%pure-parser\"",      (char const   */* const  */)"\"%require\"",      (char const   */* const  */)"\"%skeleton\"",      (char const   */* const  */)"\"%start\"", 
        (char const   */* const  */)"\"%token-table\"",      (char const   */* const  */)"\"%verbose\"",      (char const   */* const  */)"\"%yacc\"",      (char const   */* const  */)"\"{...}\"", 
        (char const   */* const  */)"\"[identifier]\"",      (char const   */* const  */)"\"char\"",      (char const   */* const  */)"\"epilogue\"",      (char const   */* const  */)"\"=\"", 
        (char const   */* const  */)"\"identifier\"",      (char const   */* const  */)"\"identifier:\"",      (char const   */* const  */)"\"%%\"",      (char const   */* const  */)"\"|\"", 
        (char const   */* const  */)"\"%{...%}\"",      (char const   */* const  */)"\";\"",      (char const   */* const  */)"\"type\"",      (char const   */* const  */)"\"<*>\"", 
        (char const   */* const  */)"\"<>\"",      (char const   */* const  */)"\"%union\"",      (char const   */* const  */)"$accept",      (char const   */* const  */)"input", 
        (char const   */* const  */)"prologue_declarations",      (char const   */* const  */)"prologue_declaration",      (char const   */* const  */)"grammar_declaration",      (char const   */* const  */)"union_name", 
        (char const   */* const  */)"symbol_declaration",      (char const   */* const  */)"$@1",      (char const   */* const  */)"$@2",      (char const   */* const  */)"precedence_declaration", 
        (char const   */* const  */)"precedence_declarator",      (char const   */* const  */)"type.opt",      (char const   */* const  */)"symbols.prec",      (char const   */* const  */)"symbol.prec", 
        (char const   */* const  */)"symbols.1",      (char const   */* const  */)"generic_symlist",      (char const   */* const  */)"generic_symlist_item",      (char const   */* const  */)"symbol_def", 
        (char const   */* const  */)"symbol_defs.1",      (char const   */* const  */)"grammar",      (char const   */* const  */)"rules_or_grammar_declaration",      (char const   */* const  */)"rules", 
        (char const   */* const  */)"$@3",      (char const   */* const  */)"rhses.1",      (char const   */* const  */)"rhs",      (char const   */* const  */)"named_ref.opt", 
        (char const   */* const  */)"variable",      (char const   */* const  */)"content.opt",      (char const   */* const  */)"braceless",      (char const   */* const  */)"id", 
        (char const   */* const  */)"id_colon",      (char const   */* const  */)"symbol",      (char const   */* const  */)"string_as_id",      (char const   */* const  */)"epilogue.opt", 
        (char const   */* const  */)0};
#line 729 "parse-gram.c"
static yytype_uint8 const   yyr1[109]  = 
#line 729
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )63,      (yytype_uint8 const   )62,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )66,      (yytype_uint8 const   )64,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )76,      (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )80,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )81,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )91};
#line 745 "parse-gram.c"
static yytype_uint8 const   yyr2[109]  = 
#line 745
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2};
#line 763 "parse-gram.c"
static yytype_uint8 const   yydefact___0[148]  = 
#line 763
  {      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )47,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )40,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )11,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )16,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )34,      (yytype_uint8 const   )44,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )36,      (yytype_uint8 const   )35,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )100,      (yytype_uint8 const   )0,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )96,      (yytype_uint8 const   )95,      (yytype_uint8 const   )97,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )25,      (yytype_uint8 const   )0,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )106,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )104,      (yytype_uint8 const   )37,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )103,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )79,      (yytype_uint8 const   )93,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )57,      (yytype_uint8 const   )0,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )50,      (yytype_uint8 const   )71,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )62,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )38,      (yytype_uint8 const   )64,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )43,      (yytype_uint8 const   )99,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )15,      (yytype_uint8 const   )22,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )80,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )94,      (yytype_uint8 const   )82,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )58,      (yytype_uint8 const   )60,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )63,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )87,      (yytype_uint8 const   )59,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )93,      (yytype_uint8 const   )85,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )89,      (yytype_uint8 const   )88};
#line 783 "parse-gram.c"
static yytype_int16 const   yydefgoto___0[34]  = 
#line 783
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )2,      (yytype_int16 const   )43, 
        (yytype_int16 const   )82,      (yytype_int16 const   )88,      (yytype_int16 const   )45,      (yytype_int16 const   )49, 
        (yytype_int16 const   )48,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )90, 
        (yytype_int16 const   )120,      (yytype_int16 const   )121,      (yytype_int16 const   )96,      (yytype_int16 const   )101, 
        (yytype_int16 const   )102,      (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )83, 
        (yytype_int16 const   )84,      (yytype_int16 const   )85,      (yytype_int16 const   )129,      (yytype_int16 const   )133, 
        (yytype_int16 const   )134,      (yytype_int16 const   )118,      (yytype_int16 const   )58,      (yytype_int16 const   )108, 
        (yytype_int16 const   )55,      (yytype_int16 const   )77,      (yytype_int16 const   )86,      (yytype_int16 const   )103, 
        (yytype_int16 const   )79,      (yytype_int16 const   )116};
#line 794 "parse-gram.c"
static yytype_int16 const   yypact[148]  = 
#line 794
  {      (yytype_int16 const   )-91,      (yytype_int16 const   )3,      (yytype_int16 const   )103,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-36,      (yytype_int16 const   )2, 
        (yytype_int16 const   )10,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )9,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )32, 
        (yytype_int16 const   )60,      (yytype_int16 const   )-91,      (yytype_int16 const   )65,      (yytype_int16 const   )67, 
        (yytype_int16 const   )27,      (yytype_int16 const   )-91,      (yytype_int16 const   )41,      (yytype_int16 const   )73, 
        (yytype_int16 const   )51,      (yytype_int16 const   )-91,      (yytype_int16 const   )39,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )40,      (yytype_int16 const   )52, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )93,      (yytype_int16 const   )95,      (yytype_int16 const   )33, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )15, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )53,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )46, 
        (yytype_int16 const   )43,      (yytype_int16 const   )43,      (yytype_int16 const   )33,      (yytype_int16 const   )11, 
        (yytype_int16 const   )11,      (yytype_int16 const   )-91,      (yytype_int16 const   )61,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )35,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )100, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )102,      (yytype_int16 const   )-91,      (yytype_int16 const   )113,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )64,      (yytype_int16 const   )-91,      (yytype_int16 const   )94,      (yytype_int16 const   )1, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )62,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )61,      (yytype_int16 const   )-91,      (yytype_int16 const   )33,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )43,      (yytype_int16 const   )86,      (yytype_int16 const   )43, 
        (yytype_int16 const   )33,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )11,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )11,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )72,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )33,      (yytype_int16 const   )-91,      (yytype_int16 const   )142,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )145,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )17,      (yytype_int16 const   )34,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )33,      (yytype_int16 const   )146,      (yytype_int16 const   )97, 
        (yytype_int16 const   )62,      (yytype_int16 const   )62,      (yytype_int16 const   )34,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91};
#line 814 "parse-gram.c"
static yytype_int16 const   yypgoto[34]  = 
#line 814
  {      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )147,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )37,      (yytype_int16 const   )-91,      (yytype_int16 const   )106, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-33,      (yytype_int16 const   )105,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )24,      (yytype_int16 const   )-48,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-49,      (yytype_int16 const   )-20,      (yytype_int16 const   )-91,      (yytype_int16 const   )-35, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-91};
#line 826 "parse-gram.c"
static yytype_int16 const   yytable[161]  = 
#line 826
  {      (yytype_int16 const   )78,      (yytype_int16 const   )-107,      (yytype_int16 const   )80,      (yytype_int16 const   )3, 
        (yytype_int16 const   )125,      (yytype_int16 const   )105,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )74,      (yytype_int16 const   )97, 
        (yytype_int16 const   )80,      (yytype_int16 const   )12,      (yytype_int16 const   )50,      (yytype_int16 const   )14, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )94,      (yytype_int16 const   )94,      (yytype_int16 const   )62,      (yytype_int16 const   )12, 
        (yytype_int16 const   )27,      (yytype_int16 const   )14,      (yytype_int16 const   )132,      (yytype_int16 const   )56, 
        (yytype_int16 const   )74,      (yytype_int16 const   )74,      (yytype_int16 const   )106,      (yytype_int16 const   )119, 
        (yytype_int16 const   )35,      (yytype_int16 const   )127,      (yytype_int16 const   )67,      (yytype_int16 const   )69, 
        (yytype_int16 const   )127,      (yytype_int16 const   )51,      (yytype_int16 const   )27,      (yytype_int16 const   )137, 
        (yytype_int16 const   )138,      (yytype_int16 const   )139,      (yytype_int16 const   )81,      (yytype_int16 const   )114, 
        (yytype_int16 const   )53,      (yytype_int16 const   )52,      (yytype_int16 const   )35,      (yytype_int16 const   )122, 
        (yytype_int16 const   )75,      (yytype_int16 const   )54,      (yytype_int16 const   )42,      (yytype_int16 const   )76, 
        (yytype_int16 const   )123,      (yytype_int16 const   )126,      (yytype_int16 const   )123,      (yytype_int16 const   )59, 
        (yytype_int16 const   )81,      (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )100, 
        (yytype_int16 const   )135,      (yytype_int16 const   )60,      (yytype_int16 const   )136,      (yytype_int16 const   )61, 
        (yytype_int16 const   )42,      (yytype_int16 const   )94,      (yytype_int16 const   )63,      (yytype_int16 const   )94, 
        (yytype_int16 const   )65,      (yytype_int16 const   )140,      (yytype_int16 const   )75,      (yytype_int16 const   )75, 
        (yytype_int16 const   )57,      (yytype_int16 const   )76,      (yytype_int16 const   )76,      (yytype_int16 const   )107, 
        (yytype_int16 const   )64,      (yytype_int16 const   )122,      (yytype_int16 const   )68,      (yytype_int16 const   )70, 
        (yytype_int16 const   )75,      (yytype_int16 const   )74,      (yytype_int16 const   )124,      (yytype_int16 const   )76, 
        (yytype_int16 const   )146,      (yytype_int16 const   )147,      (yytype_int16 const   )66,      (yytype_int16 const   )71, 
        (yytype_int16 const   )72,      (yytype_int16 const   )91,      (yytype_int16 const   )73,      (yytype_int16 const   )141, 
        (yytype_int16 const   )89,      (yytype_int16 const   )87,      (yytype_int16 const   )143,      (yytype_int16 const   )109, 
        (yytype_int16 const   )53,      (yytype_int16 const   )110,      (yytype_int16 const   )117,      (yytype_int16 const   )141, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )111,      (yytype_int16 const   )112,      (yytype_int16 const   )128,      (yytype_int16 const   )12, 
        (yytype_int16 const   )13,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )131,      (yytype_int16 const   )113, 
        (yytype_int16 const   )74,      (yytype_int16 const   )44,      (yytype_int16 const   )144,      (yytype_int16 const   )145, 
        (yytype_int16 const   )115,      (yytype_int16 const   )39,      (yytype_int16 const   )95,      (yytype_int16 const   )40, 
        (yytype_int16 const   )41,      (yytype_int16 const   )130,      (yytype_int16 const   )104,      (yytype_int16 const   )142, 
        (yytype_int16 const   )42};
#line 853 "parse-gram.c"
static yytype_uint8 const   yycheck[161]  = 
#line 853
  {      (yytype_uint8 const   )35,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )54,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )3,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )16,      (yytype_uint8 const   )54,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )3,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )18,      (yytype_uint8 const   )124,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )101,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )43,      (yytype_uint8 const   )31,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )43,      (yytype_uint8 const   )39,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )48,      (yytype_uint8 const   )57,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )96,      (yytype_uint8 const   )95,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )4,      (yytype_uint8 const   )53,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )93,      (yytype_uint8 const   )47,      (yytype_uint8 const   )95, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )43,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )120,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )140,      (yytype_uint8 const   )141,      (yytype_uint8 const   )43,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )54,      (yytype_uint8 const   )3,      (yytype_uint8 const   )134, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )48,      (yytype_uint8 const   )137,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )3,      (yytype_uint8 const   )44,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )53,      (yytype_uint8 const   )46,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )4,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )50,      (yytype_uint8 const   )49,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )120,      (yytype_uint8 const   )52,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )57};
#line 876 "parse-gram.c"
static yytype_uint8 const   yystos[148]  = 
#line 876
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )57,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )64,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )65,      (yytype_uint8 const   )54,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )43,      (yytype_uint8 const   )48,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )48,      (yytype_uint8 const   )84,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )3,      (yytype_uint8 const   )43,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )3,      (yytype_uint8 const   )47,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )87,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )49,      (yytype_uint8 const   )62,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )88,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )54,      (yytype_uint8 const   )69,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )87,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )89,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )86,      (yytype_uint8 const   )3,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )53,      (yytype_uint8 const   )50,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )44,      (yytype_uint8 const   )83,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )89,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )90,      (yytype_uint8 const   )89,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )80,      (yytype_uint8 const   )71,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )89,      (yytype_uint8 const   )82,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )54,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83};
#line 1027 "parse-gram.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ,
                                  location const   * const  yylocationp ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1038
  if (! yyvaluep) {
#line 1039
    return;
  }
  {
#line 1049
  if (yytype == 3) {
#line 1049
    goto case_3;
  }
#line 1058
  if (yytype == 4) {
#line 1058
    goto case_4;
  }
#line 1067
  if (yytype == 43) {
#line 1067
    goto case_43;
  }
#line 1076
  if (yytype == 44) {
#line 1076
    goto case_44;
  }
#line 1085
  if (yytype == 45) {
#line 1085
    goto case_45;
  }
#line 1094
  if (yytype == 46) {
#line 1094
    goto case_46;
  }
#line 1103
  if (yytype == 48) {
#line 1103
    goto case_48;
  }
#line 1112
  if (yytype == 49) {
#line 1112
    goto case_49;
  }
#line 1121
  if (yytype == 52) {
#line 1121
    goto case_52;
  }
#line 1130
  if (yytype == 54) {
#line 1130
    goto case_54;
  }
#line 1139
  if (yytype == 71) {
#line 1139
    goto case_71;
  }
#line 1148
  if (yytype == 84) {
#line 1148
    goto case_84;
  }
#line 1157
  if (yytype == 85) {
#line 1157
    goto case_85;
  }
#line 1166
  if (yytype == 86) {
#line 1166
    goto case_86;
  }
#line 1175
  if (yytype == 87) {
#line 1175
    goto case_87;
  }
#line 1184
  if (yytype == 88) {
#line 1184
    goto case_88;
  }
#line 1193
  if (yytype == 89) {
#line 1193
    goto case_89;
  }
#line 1202
  if (yytype == 90) {
#line 1202
    goto case_90;
  }
#line 1211
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 203 "parse-gram.y"
  tmp = quotearg_style((enum quoting_style )3, (char const   *)yyvaluep->chars);
#line 203
  fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
  }
#line 1057 "parse-gram.c"
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 215 "parse-gram.y"
  rpl_fprintf(stderr, "%d", yyvaluep->integer);
  }
#line 1066 "parse-gram.c"
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 205 "parse-gram.y"
  rpl_fprintf(stderr, "{\n%s\n}", yyvaluep->code);
  }
#line 1075 "parse-gram.c"
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 210 "parse-gram.y"
  rpl_fprintf(stderr, "[%s]", yyvaluep->uniqstr);
  }
#line 1084 "parse-gram.c"
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 197 "parse-gram.y"
  tmp___0 = char_name((char )yyvaluep->character);
#line 197
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
  }
#line 1093 "parse-gram.c"
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 205 "parse-gram.y"
  rpl_fprintf(stderr, "{\n%s\n}", yyvaluep->chars);
  }
#line 1102 "parse-gram.c"
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 209 "parse-gram.y"
  fputs_unlocked((char const   */* __restrict  */)yyvaluep->uniqstr, (FILE */* __restrict  */)stderr);
  }
#line 1111 "parse-gram.c"
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 211 "parse-gram.y"
  rpl_fprintf(stderr, "%s:", yyvaluep->uniqstr);
  }
#line 1120 "parse-gram.c"
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 205 "parse-gram.y"
  rpl_fprintf(stderr, "{\n%s\n}", yyvaluep->chars);
  }
#line 1129 "parse-gram.c"
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 212 "parse-gram.y"
  rpl_fprintf(stderr, "<%s>", yyvaluep->uniqstr);
  }
#line 1138 "parse-gram.c"
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 218 "parse-gram.y"
  rpl_fprintf(stderr, "%s", (yyvaluep->symbol)->tag);
  }
#line 1147 "parse-gram.c"
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 209 "parse-gram.y"
  fputs_unlocked((char const   */* __restrict  */)yyvaluep->uniqstr, (FILE */* __restrict  */)stderr);
  }
#line 1156 "parse-gram.c"
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 205 "parse-gram.y"
  rpl_fprintf(stderr, "{\n%s\n}", yyvaluep->chars);
  }
#line 1165 "parse-gram.c"
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 205 "parse-gram.y"
  rpl_fprintf(stderr, "{\n%s\n}", yyvaluep->chars);
  }
#line 1174 "parse-gram.c"
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 218 "parse-gram.y"
  rpl_fprintf(stderr, "%s", (yyvaluep->symbol)->tag);
  }
#line 1183 "parse-gram.c"
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 219 "parse-gram.y"
  rpl_fprintf(stderr, "%s:", (yyvaluep->symbol)->tag);
  }
#line 1192 "parse-gram.c"
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 218 "parse-gram.y"
  rpl_fprintf(stderr, "%s", (yyvaluep->symbol)->tag);
  }
#line 1201 "parse-gram.c"
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 218 "parse-gram.y"
  rpl_fprintf(stderr, "%s", (yyvaluep->symbol)->tag);
  }
#line 1210 "parse-gram.c"
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1212
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1214
  return;
}
}
#line 1223 "parse-gram.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ,
                            location const   * const  yylocationp ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1234
  if (yytype < 58) {
    {
#line 1235
    rpl_fprintf(yyoutput, "token %s (", yytname[yytype]);
    }
  } else {
    {
#line 1237
    rpl_fprintf(yyoutput, "nterm %s (", yytname[yytype]);
    }
  }
  {
#line 1239
  location_print(yyoutput, (location )*yylocationp);
#line 1240
  rpl_fprintf(yyoutput, ": ");
#line 1241
  yy_symbol_value_print(yyoutput, yytype, yyvaluep, yylocationp);
#line 1242
  rpl_fprintf(yyoutput, ")");
  }
#line 1243
  return;
}
}
#line 1252 "parse-gram.c"
static void yy_stack_print(yytype_int16 *yybottom , yytype_int16 *yytop ) 
{ 
  int yybot ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1261
  rpl_fprintf(stderr, "Stack now");
  }
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1262
    if (! ((unsigned long )yybottom <= (unsigned long )yytop)) {
#line 1262
      goto while_break;
    }
    {
#line 1264
    yybot = *yybottom;
#line 1265
    rpl_fprintf(stderr, " %d", yybot);
#line 1262
    yybottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1267
  rpl_fprintf(stderr, "\n");
  }
#line 1268
  return;
}
}
#line 1283 "parse-gram.c"
static void yy_reduce_print(YYSTYPE *yyvsp , location *yylsp , int yyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1293
  yynrhs = (int )yyr2[yyrule];
#line 1295
  yylno = (unsigned long )yyrline[yyrule];
#line 1296
  rpl_fprintf(stderr, "Reducing stack by rule %d (line %lu):\n", yyrule - 1, yylno);
#line 1299
  yyi = 0;
  }
  {
#line 1299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1299
    if (! (yyi < yynrhs)) {
#line 1299
      goto while_break;
    }
    {
#line 1301
    rpl_fprintf(stderr, "   $%d = ", yyi + 1);
#line 1302
    yy_symbol_print(stderr, (int )yyrhs[yyprhs[yyrule] + (yytype_uint16 const   )yyi],
                    (YYSTYPE const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)),
                    (location const   */* const  */)(yylsp + ((yyi + 1) - yynrhs)));
#line 1305
    rpl_fprintf(stderr, "\n");
#line 1299
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1307
  return;
}
}
#line 1352 "parse-gram.c"
static int yy_lac_stack_realloc(unsigned int *yycapacity , unsigned int yyadd , char const   *yydebug_prefix ,
                                char const   *yydebug_suffix , yytype_int16 **yybottom ,
                                yytype_int16 *yybottom_no_free , yytype_int16 **yytop ,
                                yytype_int16 *yytop_empty ) 
{ 
  unsigned int yysize_old ;
  long tmp ;
  unsigned int yysize_new ;
  unsigned int yyalloc ;
  yytype_int16 *yybottom_new ;
  void *tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1362
  if ((unsigned long )*yytop == (unsigned long )yytop_empty) {
#line 1362
    tmp = 0L;
  } else {
#line 1362
    tmp = (*yytop - *yybottom) + 1L;
  }
#line 1362
  yysize_old = (unsigned int )tmp;
#line 1364
  yysize_new = yysize_old + yyadd;
#line 1365
  if (*yycapacity < yysize_new) {
#line 1367
    yyalloc = 2U * yysize_new;
#line 1372
    if (10000U < yysize_new) {
      {
#line 1374
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1374
        if (gram_debug) {
          {
#line 1374
          rpl_fprintf(stderr, "%smax size exceeded%s", yydebug_prefix, yydebug_suffix);
          }
        }
#line 1374
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1376
      return (1);
    }
#line 1378
    if (10000U < yyalloc) {
#line 1379
      yyalloc = 10000U;
    }
    {
#line 1380
    tmp___0 = malloc((size_t )((unsigned long )yyalloc * sizeof(*yybottom_new)));
#line 1380
    yybottom_new = (yytype_int16 *)tmp___0;
    }
#line 1382
    if (! yybottom_new) {
      {
#line 1384
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1384
        if (gram_debug) {
          {
#line 1384
          rpl_fprintf(stderr, "%srealloc failed%s", yydebug_prefix, yydebug_suffix);
          }
        }
#line 1384
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1386
      return (1);
    }
#line 1388
    if ((unsigned long )*yytop != (unsigned long )yytop_empty) {
      {
#line 1390
      __builtin_memcpy((void *)yybottom_new, (void const   *)*yybottom, (unsigned long )yysize_old * sizeof(*(*yybottom)));
#line 1391
      *yytop = yybottom_new + (yysize_old - 1U);
      }
    }
#line 1393
    if ((unsigned long )*yybottom != (unsigned long )yybottom_no_free) {
      {
#line 1394
      free((void *)*yybottom);
      }
    }
#line 1395
    *yybottom = yybottom_new;
#line 1396
    *yycapacity = yyalloc;
  }
#line 1398
  return (0);
}
}
#line 1480 "parse-gram.c"
static int yy_lac(yytype_int16 *yyesa , yytype_int16 **yyes , unsigned int *yyes_capacity ,
                  yytype_int16 *yyssp , int yytoken ) 
{ 
  yytype_int16 *yyes_prev ;
  yytype_int16 *yyesp ;
  int yyrule ;
  unsigned int yylen ;
  unsigned int yysize ;
  int yystate ;
  int yylhs ;
  int tmp ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 1484
  yyes_prev = yyssp;
#line 1485
  yyesp = yyes_prev;
  {
#line 1486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1486
    if (gram_debug) {
      {
#line 1486
      rpl_fprintf(stderr, "LAC: checking lookahead %s:", yytname[yytoken]);
      }
    }
#line 1486
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1487
  if (yytoken == 2) {
    {
#line 1489
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1489
      if (gram_debug) {
        {
#line 1489
        rpl_fprintf(stderr, " Always Err\n");
        }
      }
#line 1489
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1490
    return (1);
  }
  {
#line 1492
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1494
    yyrule = (int )yypact[*yyesp];
#line 1495
    if (yyrule == -91) {
#line 1495
      goto _L;
    } else {
#line 1495
      yyrule += yytoken;
#line 1495
      if (yyrule < 0) {
#line 1495
        goto _L;
      } else
#line 1495
      if (160 < yyrule) {
#line 1495
        goto _L;
      } else
#line 1495
      if ((int const   )yycheck[yyrule] != (int const   )yytoken) {
        _L: /* CIL Label */ 
#line 1499
        yyrule = (int )yydefact___0[*yyesp];
#line 1500
        if (yyrule == 0) {
          {
#line 1502
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1502
            if (gram_debug) {
              {
#line 1502
              rpl_fprintf(stderr, " Err\n");
              }
            }
#line 1502
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1503
          return (1);
        }
      } else {
#line 1508
        yyrule = (int )yytable[yyrule];
#line 1514
        if (0 < yyrule) {
          {
#line 1516
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1516
            if (gram_debug) {
              {
#line 1516
              rpl_fprintf(stderr, " S%d\n", yyrule);
              }
            }
#line 1516
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1517
          return (0);
        }
#line 1519
        yyrule = - yyrule;
      }
    }
#line 1522
    yylen = (unsigned int )yyr2[yyrule];
    {
#line 1523
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1523
      if (gram_debug) {
        {
#line 1523
        rpl_fprintf(stderr, " R%d", yyrule - 1);
        }
      }
#line 1523
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1524
    if ((unsigned long )yyesp != (unsigned long )yyes_prev) {
#line 1526
      yysize = (unsigned int )((yyesp - *yyes) + 1L);
#line 1527
      if (yylen < yysize) {
#line 1529
        yyesp -= yylen;
#line 1530
        yylen = 0U;
      } else {
#line 1534
        yylen -= yysize;
#line 1535
        yyesp = yyes_prev;
      }
    }
#line 1538
    if (yylen) {
#line 1539
      yyes_prev -= yylen;
#line 1539
      yyesp = yyes_prev;
    }
#line 1544
    yylhs = (int )((int const   )yyr1[yyrule] - 58);
#line 1545
    yystate = (int )(yypgoto[yylhs] + (yytype_int16 const   )*yyesp);
#line 1546
    if (yystate < 0) {
#line 1548
      yystate = (int )yydefgoto___0[yylhs];
    } else
#line 1546
    if (160 < yystate) {
#line 1548
      yystate = (int )yydefgoto___0[yylhs];
    } else
#line 1546
    if ((int const   )yycheck[yystate] != (int const   )*yyesp) {
#line 1548
      yystate = (int )yydefgoto___0[yylhs];
    } else {
#line 1550
      yystate = (int )yytable[yystate];
    }
#line 1552
    if ((unsigned long )yyesp == (unsigned long )yyes_prev) {
#line 1554
      yyesp = *yyes;
#line 1555
      *yyesp = yystate;
    } else {
      {
#line 1559
      tmp = yy_lac_stack_realloc(yyes_capacity, 1U, " (", ")", yyes, yyesa, & yyesp,
                                 yyes_prev);
      }
#line 1559
      if (tmp) {
        {
#line 1565
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1565
          if (gram_debug) {
            {
#line 1565
            rpl_fprintf(stderr, "\n");
            }
          }
#line 1565
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1566
        return (2);
      }
#line 1568
      yyesp ++;
#line 1568
      *yyesp = yystate;
    }
    {
#line 1570
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1570
      if (gram_debug) {
        {
#line 1570
        rpl_fprintf(stderr, " G%d", yystate);
        }
      }
#line 1570
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 1637 "parse-gram.c"
static unsigned int yytnamerr(char *yyres , char const   *yystr ) 
{ 
  unsigned int yyn ;
  char const   *yyp ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 1640
  if ((int const   )*yystr == 34) {
#line 1642
    yyn = 0U;
#line 1643
    yyp = yystr;
    {
#line 1645
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1646
      yyp ++;
      {
#line 1649
      if ((int const   )*yyp == 44) {
#line 1649
        goto case_44;
      }
#line 1649
      if ((int const   )*yyp == 39) {
#line 1649
        goto case_44;
      }
#line 1652
      if ((int const   )*yyp == 92) {
#line 1652
        goto case_92;
      }
#line 1662
      if ((int const   )*yyp == 34) {
#line 1662
        goto case_34;
      }
#line 1656
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 1650
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 1653
      yyp ++;
#line 1653
      if ((int const   )*yyp != 92) {
#line 1654
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 1657
      if (yyres) {
#line 1658
        *(yyres + yyn) = (char )*yyp;
      }
#line 1659
      yyn ++;
#line 1660
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1663
      if (yyres) {
#line 1664
        *(yyres + yyn) = (char )'\000';
      }
#line 1665
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 1670
  if (! yyres) {
    {
#line 1671
    tmp = strlen(yystr);
    }
#line 1671
    return (tmp);
  }
  {
#line 1673
  tmp___0 = stpcpy((char */* __restrict  */)yyres, (char const   */* __restrict  */)yystr);
  }
#line 1673
  return ((unsigned int )(tmp___0 - yyres));
}
}
#line 1687 "parse-gram.c"
static int yysyntax_error(unsigned int *yymsg_alloc , char **yymsg , yytype_int16 *yyesa ,
                          yytype_int16 **yyes , unsigned int *yyes_capacity , yytype_int16 *yyssp ,
                          int yytoken ) 
{ 
  unsigned int yysize0 ;
  unsigned int tmp ;
  unsigned int yysize ;
  unsigned int yysize1 ;
  char const   *yyformat ;
  char const   *yyarg[5] ;
  int yycount ;
  int yyn ;
  int tmp___0 ;
  int yyx ;
  int yy_lac_status ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *yyp ;
  int yyi ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  char tmp___13 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 1692
  tmp = yytnamerr((char *)0, (char const   *)yytname[yytoken]);
#line 1692
  yysize0 = tmp;
#line 1693
  yysize = yysize0;
#line 1697
  yyformat = (char const   *)0;
#line 1702
  yycount = 0;
  }
#line 1728
  if (yytoken != -2) {
#line 1730
    yyn = (int )yypact[*yyssp];
    {
#line 1731
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1731
      if (gram_debug) {
        {
#line 1731
        rpl_fprintf(stderr, "Constructing syntax error message\n");
        }
      }
#line 1731
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1732
    tmp___0 = yycount;
#line 1732
    yycount ++;
#line 1732
    yyarg[tmp___0] = (char const   *)yytname[yytoken];
#line 1733
    if (! (yyn == -91)) {
#line 1737
      yyx = 0;
      {
#line 1737
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1737
        if (! (yyx < 58)) {
#line 1737
          goto while_break___0;
        }
#line 1738
        if (yyx != 1) {
#line 1738
          if (yyx != 2) {
            {
#line 1741
            tmp___1 = yy_lac(yyesa, yyes, yyes_capacity, yyssp, yyx);
#line 1741
            yy_lac_status = tmp___1;
            }
#line 1743
            if (yy_lac_status == 2) {
#line 1744
              return (2);
            }
#line 1745
            if (yy_lac_status == 1) {
#line 1746
              goto __Cont;
            }
#line 1748
            if (yycount == 5) {
#line 1750
              yycount = 1;
#line 1751
              yysize = yysize0;
#line 1752
              goto while_break___0;
            }
            {
#line 1754
            tmp___2 = yycount;
#line 1754
            yycount ++;
#line 1754
            yyarg[tmp___2] = (char const   *)yytname[yyx];
#line 1755
            tmp___3 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 1755
            yysize1 = yysize + tmp___3;
            }
#line 1756
            if (yysize <= yysize1) {
#line 1756
              if (! (yysize1 <= 4294967295U)) {
#line 1758
                return (2);
              }
            } else {
#line 1758
              return (2);
            }
#line 1759
            yysize = yysize1;
          }
        }
        __Cont: /* CIL Label */ 
#line 1737
        yyx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 1763
    if (gram_debug) {
      {
#line 1764
      rpl_fprintf(stderr, "No expected tokens.\n");
      }
    }
  }
  {
#line 1774
  if (yycount == 0) {
#line 1774
    goto case_0;
  }
#line 1775
  if (yycount == 1) {
#line 1775
    goto case_1;
  }
#line 1776
  if (yycount == 2) {
#line 1776
    goto case_2;
  }
#line 1777
  if (yycount == 3) {
#line 1777
    goto case_3;
  }
#line 1778
  if (yycount == 4) {
#line 1778
    goto case_4;
  }
#line 1779
  if (yycount == 5) {
#line 1779
    goto case_5;
  }
#line 1768
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1774
  tmp___4 = dgettext("bison-runtime", "syntax error");
#line 1774
  yyformat = (char const   *)tmp___4;
  }
#line 1774
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1775
  tmp___5 = dgettext("bison-runtime", "syntax error, unexpected %s");
#line 1775
  yyformat = (char const   *)tmp___5;
  }
#line 1775
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1776
  tmp___6 = dgettext("bison-runtime", "syntax error, unexpected %s, expecting %s");
#line 1776
  yyformat = (char const   *)tmp___6;
  }
#line 1776
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1777
  tmp___7 = dgettext("bison-runtime", "syntax error, unexpected %s, expecting %s or %s");
#line 1777
  yyformat = (char const   *)tmp___7;
  }
#line 1777
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1778
  tmp___8 = dgettext("bison-runtime", "syntax error, unexpected %s, expecting %s or %s or %s");
#line 1778
  yyformat = (char const   *)tmp___8;
  }
#line 1778
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1779
  tmp___9 = dgettext("bison-runtime", "syntax error, unexpected %s, expecting %s or %s or %s or %s");
#line 1779
  yyformat = (char const   *)tmp___9;
  }
#line 1779
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1783
  tmp___10 = strlen(yyformat);
#line 1783
  yysize1 = yysize + tmp___10;
  }
#line 1784
  if (yysize <= yysize1) {
#line 1784
    if (! (yysize1 <= 4294967295U)) {
#line 1785
      return (2);
    }
  } else {
#line 1785
    return (2);
  }
#line 1786
  yysize = yysize1;
#line 1788
  if (*yymsg_alloc < yysize) {
#line 1790
    *yymsg_alloc = 2U * yysize;
#line 1791
    if (yysize <= *yymsg_alloc) {
#line 1791
      if (! (*yymsg_alloc <= 4294967295U)) {
#line 1793
        *yymsg_alloc = 4294967295U;
      }
    } else {
#line 1793
      *yymsg_alloc = 4294967295U;
    }
#line 1794
    return (1);
  }
#line 1801
  yyp = *yymsg;
#line 1802
  yyi = 0;
  {
#line 1803
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1803
    tmp___13 = (char )*yyformat;
#line 1803
    *yyp = tmp___13;
#line 1803
    if (! ((int )tmp___13 != 0)) {
#line 1803
      goto while_break___1;
    }
#line 1804
    if ((int )*yyp == 37) {
#line 1804
      if ((int const   )*(yyformat + 1) == 115) {
#line 1804
        if (yyi < yycount) {
          {
#line 1806
          tmp___11 = yyi;
#line 1806
          yyi ++;
#line 1806
          tmp___12 = yytnamerr(yyp, yyarg[tmp___11]);
#line 1806
          yyp += tmp___12;
#line 1807
          yyformat += 2;
          }
        } else {
#line 1811
          yyp ++;
#line 1812
          yyformat ++;
        }
      } else {
#line 1811
        yyp ++;
#line 1812
        yyformat ++;
      }
    } else {
#line 1811
      yyp ++;
#line 1812
      yyformat ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1815
  return (0);
}
}
#line 1826 "parse-gram.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , location *yylocationp ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1840
  if (! yymsg) {
#line 1841
    yymsg = "Deleting";
  }
  {
#line 1842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1842
    if (gram_debug) {
      {
#line 1842
      rpl_fprintf(stderr, "%s ", yymsg);
#line 1842
      yy_symbol_print(stderr, yytype, (YYSTYPE const   */* const  */)yyvaluep, (location const   */* const  */)yylocationp);
#line 1842
      rpl_fprintf(stderr, "\n");
      }
    }
#line 1842
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1847
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1848
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1850
  return;
}
}
#line 1886 "parse-gram.c"
int gram_parse(void) 
{ 
  int gram_char ;
  YYSTYPE gram_lval ;
  location gram_lloc ;
  int gram_nerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  location yylsa[200] ;
  location *yyls ;
  location *yylsp ;
  location yyerror_range[3] ;
  unsigned int yystacksize ;
  yytype_int16 yyesa[20] ;
  yytype_int16 *yyes ;
  unsigned int yyes_capacity ;
  int yy_lac_established ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  location yyloc ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned int yymsg_alloc ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  unsigned int yynewbytes___1 ;
  int yy_lac_status ;
  int tmp___0 ;
  int yy_lac_status___0 ;
  int tmp___1 ;
  int yychar_backup ;
  code_props plain_code ;
  char const   *tmp___2 ;
  code_props action ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  char const   *skeleton_user ;
  size_t dir_length ;
  size_t tmp___5 ;
  char *skeleton_build ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  symbol_list *list ;
  symbol_list *list___0 ;
  symbol_list *list___1 ;
  symbol_list *list___2 ;
  symbol_list *tmp___10 ;
  symbol_list *tmp___11 ;
  code_props plain_code___0 ;
  size_t tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  code_props plain_code___1 ;
  int tmp___15 ;
  char const   *yymsgp ;
  char *tmp___16 ;
  int yysyntax_error_status ;
  int yy_lac_status___1 ;
  int tmp___17 ;
  void *tmp___18 ;
  char *tmp___19 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;

  {
#line 1943
  yy_lac_established = 0;
#line 1956
  yymsg = yymsgbuf;
#line 1957
  yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
#line 1964
  yylen = 0;
#line 1966
  yytoken = 0;
#line 1967
  yyss = yyssa;
#line 1968
  yyvs = yyvsa;
#line 1969
  yyls = yylsa;
#line 1970
  yystacksize = 200U;
#line 1972
  yyes = yyesa;
#line 1973
  yyes_capacity = (unsigned int )(sizeof(yyesa) / sizeof(*yyes));
#line 1974
  if (10000U < yyes_capacity) {
#line 1975
    yyes_capacity = 10000U;
  }
  {
#line 1977
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1977
    if (gram_debug) {
      {
#line 1977
      rpl_fprintf(stderr, "Starting parse\n");
      }
    }
#line 1977
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1979
  yystate = 0;
#line 1980
  yyerrstatus = 0;
#line 1981
  gram_nerrs = 0;
#line 1982
  gram_char = -2;
#line 1988
  yyssp = yyss;
#line 1989
  yyvsp = yyvs;
#line 1990
  yylsp = yyls;
#line 108 "parse-gram.y"
  boundary_set(& gram_lloc.start, current_file, 1, 1);
#line 109
  boundary_set(& gram_lloc.end, current_file, 1, 1);
#line 2011 "parse-gram.c"
  *(yylsp + 0) = gram_lloc;
  }
#line 2013
  goto yysetstate;
  yynewstate: 
#line 2021
  yyssp ++;
  yysetstate: 
#line 2024
  *yyssp = yystate;
#line 2026
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 2029
    yysize = (unsigned int )((yyssp - yyss) + 1L);
#line 2059
    if (10000U <= yystacksize) {
#line 2060
      goto yyexhaustedlab;
    }
#line 2061
    yystacksize *= 2U;
#line 2062
    if (10000U < yystacksize) {
#line 2063
      yystacksize = 10000U;
    }
    {
#line 2066
    yyss1 = yyss;
#line 2067
    tmp = malloc((size_t )((unsigned long )yystacksize * ((sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + sizeof(location )) + 2UL * (sizeof(union yyalloc ) - 1UL)));
#line 2067
    yyptr = (union yyalloc *)tmp;
    }
#line 2069
    if (! yyptr) {
#line 2070
      goto yyexhaustedlab;
    }
    {
#line 2071
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2071
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
#line 2071
      yyss = & yyptr->yyss_alloc;
#line 2071
      yynewbytes = (unsigned int )((unsigned long )yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL));
#line 2071
      yyptr += (unsigned long )yynewbytes / sizeof(*yyptr);
      }
#line 2071
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2072
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2072
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
#line 2072
      yyvs = & yyptr->yyvs_alloc;
#line 2072
      yynewbytes___0 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL));
#line 2072
      yyptr += (unsigned long )yynewbytes___0 / sizeof(*yyptr);
      }
#line 2072
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2073
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 2073
      __builtin_memcpy((void *)(& yyptr->yyls_alloc), (void const   *)yyls, (unsigned long )yysize * sizeof(*yyls));
#line 2073
      yyls = & yyptr->yyls_alloc;
#line 2073
      yynewbytes___1 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyls) + (sizeof(union yyalloc ) - 1UL));
#line 2073
      yyptr += (unsigned long )yynewbytes___1 / sizeof(*yyptr);
      }
#line 2073
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2075
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 2076
      free((void *)yyss1);
      }
    }
#line 2081
    yyssp = (yyss + yysize) - 1;
#line 2082
    yyvsp = (yyvs + yysize) - 1;
#line 2083
    yylsp = (yyls + yysize) - 1;
    {
#line 2085
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2085
      if (gram_debug) {
        {
#line 2085
        rpl_fprintf(stderr, "Stack size increased to %lu\n", (unsigned long )yystacksize);
        }
      }
#line 2085
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2088
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 2089
      goto yyabortlab;
    }
  }
  {
#line 2092
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2092
    if (gram_debug) {
      {
#line 2092
      rpl_fprintf(stderr, "Entering state %d\n", yystate);
      }
    }
#line 2092
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2094
  if (yystate == 3) {
#line 2095
    goto yyacceptlab;
  }
#line 2097
  goto yybackup;
  yybackup: 
#line 2108
  yyn = (int )yypact[yystate];
#line 2109
  if (yyn == -91) {
#line 2110
    goto yydefault;
  }
#line 2115
  if (gram_char == -2) {
    {
#line 2117
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2117
      if (gram_debug) {
        {
#line 2117
        rpl_fprintf(stderr, "Reading a token: ");
        }
      }
#line 2117
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 2118
    gram_char = gram_lex(& gram_lval, & gram_lloc);
    }
  }
#line 2121
  if (gram_char <= 0) {
#line 2123
    yytoken = 0;
#line 2123
    gram_char = yytoken;
    {
#line 2124
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2124
      if (gram_debug) {
        {
#line 2124
        rpl_fprintf(stderr, "Now at end of input.\n");
        }
      }
#line 2124
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
#line 2128
    if ((unsigned int )gram_char <= 312U) {
#line 2128
      yytoken = (int )yytranslate[gram_char];
    } else {
#line 2128
      yytoken = 2;
    }
    {
#line 2129
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2129
      if (gram_debug) {
        {
#line 2129
        rpl_fprintf(stderr, "%s ", "Next token is");
#line 2129
        yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& gram_lval),
                        (location const   */* const  */)(& gram_lloc));
#line 2129
        rpl_fprintf(stderr, "\n");
        }
      }
#line 2129
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 2134
  yyn += yytoken;
#line 2135
  if (yyn < 0) {
#line 2135
    goto _L;
  } else
#line 2135
  if (160 < yyn) {
#line 2135
    goto _L;
  } else
#line 2135
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
    _L: /* CIL Label */ 
    {
#line 2137
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2137
      if (! yy_lac_established) {
        {
#line 2137
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2137
          if (gram_debug) {
            {
#line 2137
            rpl_fprintf(stderr, "LAC: initial context established for %s\n", yytname[yytoken]);
            }
          }
#line 2137
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 2137
        yy_lac_established = 1;
#line 2137
        tmp___0 = yy_lac(yyesa, & yyes, & yyes_capacity, yyssp, yytoken);
#line 2137
        yy_lac_status = tmp___0;
        }
#line 2137
        if (yy_lac_status == 2) {
#line 2137
          goto yyexhaustedlab;
        }
#line 2137
        if (yy_lac_status == 1) {
#line 2137
          goto yyerrlab;
        }
      }
#line 2137
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2138
    goto yydefault;
  }
#line 2140
  yyn = (int )yytable[yyn];
#line 2141
  if (yyn <= 0) {
    {
#line 2145
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 2145
      if (! yy_lac_established) {
        {
#line 2145
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 2145
          if (gram_debug) {
            {
#line 2145
            rpl_fprintf(stderr, "LAC: initial context established for %s\n", yytname[yytoken]);
            }
          }
#line 2145
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 2145
        yy_lac_established = 1;
#line 2145
        tmp___1 = yy_lac(yyesa, & yyes, & yyes_capacity, yyssp, yytoken);
#line 2145
        yy_lac_status___0 = tmp___1;
        }
#line 2145
        if (yy_lac_status___0 == 2) {
#line 2145
          goto yyexhaustedlab;
        }
#line 2145
        if (yy_lac_status___0 == 1) {
#line 2145
          goto yyerrlab;
        }
      }
#line 2145
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2146
    yyn = - yyn;
#line 2147
    goto yyreduce;
  }
#line 2152
  if (yyerrstatus) {
#line 2153
    yyerrstatus --;
  }
  {
#line 2156
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2156
    if (gram_debug) {
      {
#line 2156
      rpl_fprintf(stderr, "%s ", "Shifting");
#line 2156
      yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& gram_lval),
                      (location const   */* const  */)(& gram_lloc));
#line 2156
      rpl_fprintf(stderr, "\n");
      }
    }
#line 2156
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2159
  gram_char = -2;
  {
#line 2160
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 2160
    if (yy_lac_established) {
#line 2160
      if (gram_debug) {
        {
#line 2160
        rpl_fprintf(stderr, "LAC: initial context discarded due to shift\n");
        }
      }
#line 2160
      yy_lac_established = 0;
    }
#line 2160
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 2162
  yystate = yyn;
#line 2163
  yyvsp ++;
#line 2163
  *yyvsp = gram_lval;
#line 2164
  yylsp ++;
#line 2164
  *yylsp = gram_lloc;
#line 2165
  goto yynewstate;
  yydefault: 
#line 2172
  yyn = (int )yydefact___0[yystate];
#line 2173
  if (yyn == 0) {
#line 2174
    goto yyerrlab;
  }
#line 2175
  goto yyreduce;
  yyreduce: 
  {
#line 2183
  yylen = (int )yyr2[yyn];
#line 2193
  yyval = *(yyvsp + (1 - yylen));
#line 2196
  yyloc = lloc_default((location const   *)(yylsp - yylen), yylen);
  }
  {
#line 2197
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 2197
    if (gram_debug) {
      {
#line 2197
      yy_reduce_print(yyvsp, yylsp, yyn);
      }
    }
#line 2197
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 2199
  yychar_backup = gram_char;
  {
#line 2202
  if (yyn == 6) {
#line 2202
    goto case_6;
  }
#line 255
  if (yyn == 7) {
#line 255 "parse-gram.y"
    goto case_7;
  }
#line 256
  if (yyn == 8) {
#line 256
    goto case_8;
  }
#line 261
  if (yyn == 9) {
#line 261
    goto case_9;
  }
#line 262
  if (yyn == 10) {
#line 262
    goto case_10;
  }
#line 267
  if (yyn == 11) {
#line 267
    goto case_11;
  }
#line 268
  if (yyn == 12) {
#line 268
    goto case_12;
  }
#line 269
  if (yyn == 13) {
#line 269
    goto case_13;
  }
#line 270
  if (yyn == 14) {
#line 270
    goto case_14;
  }
#line 271
  if (yyn == 15) {
#line 271
    goto case_15;
  }
#line 272
  if (yyn == 16) {
#line 272
    goto case_16;
  }
#line 277
  if (yyn == 17) {
#line 277
    goto case_17;
  }
#line 286
  if (yyn == 18) {
#line 286
    goto case_18;
  }
#line 287
  if (yyn == 19) {
#line 287
    goto case_19;
  }
#line 288
  if (yyn == 20) {
#line 288
    goto case_20;
  }
#line 289
  if (yyn == 21) {
#line 289
    goto case_21;
  }
#line 290
  if (yyn == 22) {
#line 290
    goto case_22;
  }
#line 291
  if (yyn == 23) {
#line 291
    goto case_23;
  }
#line 292
  if (yyn == 24) {
#line 292
    goto case_24;
  }
#line 293
  if (yyn == 25) {
#line 293
    goto case_25;
  }
#line 294
  if (yyn == 26) {
#line 294
    goto case_26;
  }
#line 295
  if (yyn == 27) {
#line 295
    goto case_27;
  }
#line 296
  if (yyn == 28) {
#line 296
    goto case_28;
  }
#line 311
  if (yyn == 29) {
#line 311
    goto case_29;
  }
#line 312
  if (yyn == 30) {
#line 312
    goto case_30;
  }
#line 336
  if (yyn == 31) {
#line 336
    goto case_31;
  }
#line 337
  if (yyn == 32) {
#line 337
    goto case_32;
  }
#line 338
  if (yyn == 33) {
#line 338
    goto case_33;
  }
#line 339
  if (yyn == 37) {
#line 339
    goto case_37;
  }
#line 349
  if (yyn == 38) {
#line 349
    goto case_38;
  }
#line 356
  if (yyn == 39) {
#line 356
    goto case_39;
  }
#line 363
  if (yyn == 40) {
#line 363
    goto case_40;
  }
#line 367
  if (yyn == 41) {
#line 367
    goto case_41;
  }
#line 371
  if (yyn == 42) {
#line 371
    goto case_42;
  }
#line 378
  if (yyn == 43) {
#line 378
    goto case_43;
  }
#line 383
  if (yyn == 44) {
#line 383
    goto case_44;
  }
#line 394
  if (yyn == 45) {
#line 394
    goto case_45;
  }
#line 395
  if (yyn == 46) {
#line 395
    goto case_46;
  }
#line 404
  if (yyn == 47) {
#line 404
    goto case_47;
  }
#line 411
  if (yyn == 48) {
#line 411
    goto case_48;
  }
#line 415
  if (yyn == 49) {
#line 415
    goto case_49;
  }
#line 416
  if (yyn == 50) {
#line 416
    goto case_50;
  }
#line 420
  if (yyn == 51) {
#line 420
    goto case_51;
  }
#line 428
  if (yyn == 52) {
#line 428
    goto case_52;
  }
#line 443
  if (yyn == 53) {
#line 443
    goto case_53;
  }
#line 447
  if (yyn == 54) {
#line 447
    goto case_54;
  }
#line 448
  if (yyn == 55) {
#line 448
    goto case_55;
  }
#line 449
  if (yyn == 56) {
#line 449
    goto case_56;
  }
#line 453
  if (yyn == 57) {
#line 453
    goto case_57;
  }
#line 454
  if (yyn == 58) {
#line 454
    goto case_58;
  }
#line 460
  if (yyn == 59) {
#line 460
    goto case_59;
  }
#line 462
  if (yyn == 60) {
#line 462
    goto case_60;
  }
#line 466
  if (yyn == 61) {
#line 466
    goto case_61;
  }
#line 467
  if (yyn == 62) {
#line 467
    goto case_62;
  }
#line 473
  if (yyn == 63) {
#line 473
    goto case_63;
  }
#line 475
  if (yyn == 64) {
#line 475
    goto case_64;
  }
#line 479
  if (yyn == 65) {
#line 479
    goto case_65;
  }
#line 480
  if (yyn == 66) {
#line 480
    goto case_66;
  }
#line 484
  if (yyn == 67) {
#line 484
    goto case_67;
  }
#line 485
  if (yyn == 68) {
#line 485
    goto case_68;
  }
#line 486
  if (yyn == 69) {
#line 486
    goto case_69;
  }
#line 487
  if (yyn == 70) {
#line 487
    goto case_70;
  }
#line 496
  if (yyn == 71) {
#line 496
    goto case_71;
  }
#line 501
  if (yyn == 72) {
#line 501
    goto case_72;
  }
#line 507
  if (yyn == 73) {
#line 507
    goto case_73;
  }
#line 513
  if (yyn == 74) {
#line 513
    goto case_74;
  }
#line 520
  if (yyn == 81) {
#line 520
    goto case_81;
  }
#line 547
  if (yyn == 82) {
#line 547
    goto case_82;
  }
#line 551
  if (yyn == 83) {
#line 551
    goto case_83;
  }
#line 555
  if (yyn == 84) {
#line 555
    goto case_84;
  }
#line 559
  if (yyn == 85) {
#line 559
    goto case_85;
  }
#line 560
  if (yyn == 87) {
#line 560
    goto case_87;
  }
#line 567
  if (yyn == 88) {
#line 567
    goto case_88;
  }
#line 569
  if (yyn == 89) {
#line 569
    goto case_89;
  }
#line 571
  if (yyn == 90) {
#line 571
    goto case_90;
  }
#line 573
  if (yyn == 91) {
#line 573
    goto case_91;
  }
#line 575
  if (yyn == 92) {
#line 575
    goto case_92;
  }
#line 577
  if (yyn == 93) {
#line 577
    goto case_93;
  }
#line 581
  if (yyn == 94) {
#line 581
    goto case_94;
  }
#line 583
  if (yyn == 96) {
#line 583
    goto case_96;
  }
#line 595
  if (yyn == 97) {
#line 595
    goto case_97;
  }
#line 600
  if (yyn == 98) {
#line 600
    goto case_98;
  }
#line 601
  if (yyn == 100) {
#line 601
    goto case_100;
  }
#line 619
  if (yyn == 101) {
#line 619
    goto case_101;
  }
#line 632
  if (yyn == 102) {
#line 632
    goto case_102;
  }
#line 638
  if (yyn == 103) {
#line 638
    goto case_103;
  }
#line 642
  if (yyn == 106) {
#line 642
    goto case_106;
  }
#line 657
  if (yyn == 108) {
#line 657
    goto case_108;
  }
#line 2977 "parse-gram.c"
  goto switch_default;
  case_6: /* CIL Label */ 
  {
#line 246 "parse-gram.y"
  code_props_plain_init(& plain_code, (yyvsp + 0)->chars, *(yylsp + 0));
#line 247
  code_props_translate_code(& plain_code);
#line 248
  gram_scanner_last_string_free();
  }
#line 249
  if (union_seen) {
#line 249
    tmp___2 = "post_prologue";
  } else {
#line 249
    tmp___2 = "pre_prologue";
  }
  {
#line 249
  muscle_code_grow(tmp___2, plain_code.code, *(yylsp + 0));
#line 251
  code_scanner_last_string_free();
  }
#line 253
  goto switch_break;
  case_7: /* CIL Label */ 
#line 253
  debug_flag = (_Bool)1;
#line 254
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 256
  muscle_percent_define_insert((yyvsp + -1)->uniqstr, *(yylsp + -1), (yyvsp + 0)->chars,
                               (muscle_percent_define_how )2);
  }
#line 259
  goto switch_break;
  case_9: /* CIL Label */ 
#line 259
  defines_flag = (_Bool)1;
#line 260
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 262
  defines_flag = (_Bool)1;
#line 263
  spec_defines_file = xstrdup((yyvsp + 0)->chars);
  }
#line 265
  goto switch_break;
  case_11: /* CIL Label */ 
#line 265
  error_verbose = (_Bool)1;
#line 266
  goto switch_break;
  case_12: /* CIL Label */ 
#line 266
  expected_sr_conflicts = (yyvsp + 0)->integer;
#line 267
  goto switch_break;
  case_13: /* CIL Label */ 
#line 267
  expected_rr_conflicts = (yyvsp + 0)->integer;
#line 268
  goto switch_break;
  case_14: /* CIL Label */ 
#line 268
  spec_file_prefix = (yyvsp + 0)->chars;
#line 269
  goto switch_break;
  case_15: /* CIL Label */ 
#line 269
  spec_file_prefix = (yyvsp + 0)->chars;
#line 270
  goto switch_break;
  case_16: /* CIL Label */ 
#line 272
  nondeterministic_parser = (_Bool)1;
#line 273
  glr_parser = (_Bool)1;
#line 275
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 278
  code_props_symbol_action_init(& action, (char const   *)(yyvsp + 0)->code, *(yylsp + 0));
#line 279
  code_props_translate_code(& action);
#line 280
  gram_scanner_last_string_free();
#line 281
  muscle_code_grow("initial_action", action.code, *(yylsp + 0));
#line 282
  code_scanner_last_string_free();
  }
#line 284
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 284
  language_argmatch((yyvsp + 0)->chars, 1, *(yylsp + -1));
  }
#line 285
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 285
  add_param("lex_param", (yyvsp + 0)->code, *(yylsp + 0));
  }
#line 286
  goto switch_break;
  case_20: /* CIL Label */ 
#line 286
  locations_flag = (_Bool)1;
#line 287
  goto switch_break;
  case_21: /* CIL Label */ 
#line 287
  spec_name_prefix = (yyvsp + 0)->chars;
#line 288
  goto switch_break;
  case_22: /* CIL Label */ 
#line 288
  spec_name_prefix = (yyvsp + 0)->chars;
#line 289
  goto switch_break;
  case_23: /* CIL Label */ 
#line 289
  no_lines_flag = (_Bool)1;
#line 290
  goto switch_break;
  case_24: /* CIL Label */ 
#line 290
  nondeterministic_parser = (_Bool)1;
#line 291
  goto switch_break;
  case_25: /* CIL Label */ 
#line 291
  spec_outfile = (yyvsp + 0)->chars;
#line 292
  goto switch_break;
  case_26: /* CIL Label */ 
#line 292
  spec_outfile = (yyvsp + 0)->chars;
#line 293
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 293
  add_param("parse_param", (yyvsp + 0)->code, *(yylsp + 0));
  }
#line 294
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 299
  tmp___3 = muscle_find_const("percent_define(api.pure)");
  }
#line 299
  if (! tmp___3) {
    {
#line 300
    muscle_percent_define_insert("api.pure", *(yylsp + 0), "", (muscle_percent_define_how )2);
    }
  }
  {
#line 305
  tmp___4 = muscle_percent_define_flag_if("api.pure");
  }
#line 305
  if (! tmp___4) {
    {
#line 306
    muscle_percent_define_insert("api.pure", *(yylsp + 0), "", (muscle_percent_define_how )2);
    }
  }
#line 309
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 309
  version_check((location const   *)(yylsp + 0), (yyvsp + 0)->chars);
  }
#line 310
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 312
  skeleton_user = (yyvsp + 0)->chars;
#line 313
  tmp___9 = mbschr(skeleton_user, '/');
  }
#line 313
  if (tmp___9) {
    {
#line 315
    tmp___5 = strlen(current_file);
#line 315
    dir_length = tmp___5;
    }
    {
#line 317
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 317
      if (dir_length) {
#line 317
        if (! ((int const   )*(current_file + (dir_length - 1U)) != 47)) {
#line 317
          goto while_break___15;
        }
      } else {
#line 317
        goto while_break___15;
      }
#line 318
      dir_length --;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 319
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 319
      if (dir_length) {
#line 319
        if (! ((int const   )*(current_file + (dir_length - 1U)) == 47)) {
#line 319
          goto while_break___16;
        }
      } else {
#line 319
        goto while_break___16;
      }
#line 320
      dir_length --;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 321
    tmp___6 = strlen(skeleton_user);
#line 321
    tmp___7 = xmalloc(((dir_length + 1U) + tmp___6) + 1U);
#line 321
    skeleton_build = (char *)tmp___7;
    }
#line 323
    if (dir_length > 0U) {
      {
#line 325
      strncpy((char */* __restrict  */)skeleton_build, (char const   */* __restrict  */)current_file,
              dir_length);
#line 326
      tmp___8 = dir_length;
#line 326
      dir_length ++;
#line 326
      *(skeleton_build + tmp___8) = (char )'/';
      }
    }
    {
#line 328
    strcpy((char */* __restrict  */)(skeleton_build + dir_length), (char const   */* __restrict  */)skeleton_user);
#line 329
    skeleton_user = uniqstr_new((char const   *)skeleton_build);
#line 330
    free((void *)skeleton_build);
    }
  }
  {
#line 332
  skeleton_arg(skeleton_user, 1, *(yylsp + -1));
  }
#line 334
  goto switch_break;
  case_31: /* CIL Label */ 
#line 334
  token_table_flag = (_Bool)1;
#line 335
  goto switch_break;
  case_32: /* CIL Label */ 
#line 335
  report_flag |= 1;
#line 336
  goto switch_break;
  case_33: /* CIL Label */ 
#line 336
  yacc_flag = (_Bool)1;
#line 337
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 345
  grammar_start_symbol_set((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 347
  goto switch_break;
  case_38: /* CIL Label */ 
#line 350
  list = (yyvsp + 0)->list;
  {
#line 350
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 350
    if (! list) {
#line 350
      goto while_break___17;
    }
    {
#line 351
    symbol_list_destructor_set(list, (char const   *)(yyvsp + -1)->code, *(yylsp + -1));
#line 350
    list = list->next;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 352
  symbol_list_free((yyvsp + 0)->list);
  }
#line 354
  goto switch_break;
  case_39: /* CIL Label */ 
#line 357
  list___0 = (yyvsp + 0)->list;
  {
#line 357
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 357
    if (! list___0) {
#line 357
      goto while_break___18;
    }
    {
#line 358
    symbol_list_printer_set(list___0, (char const   *)(yyvsp + -1)->code, *(yylsp + -1));
#line 357
    list___0 = list___0->next;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 359
  symbol_list_free((yyvsp + 0)->list);
  }
#line 361
  goto switch_break;
  case_40: /* CIL Label */ 
#line 363
  default_prec = (_Bool)1;
#line 365
  goto switch_break;
  case_41: /* CIL Label */ 
#line 367
  default_prec = (_Bool)0;
#line 369
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 373
  muscle_code_grow("percent_code()", (yyvsp + 0)->chars, *(yylsp + 0));
#line 374
  code_scanner_last_string_free();
  }
#line 376
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 378
  muscle_percent_code_grow((yyvsp + -1)->uniqstr, *(yylsp + -1), (yyvsp + 0)->chars,
                           *(yylsp + 0));
#line 379
  code_scanner_last_string_free();
  }
#line 381
  goto switch_break;
  case_44: /* CIL Label */ ;
#line 392
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 392
  muscle_code_grow("union_name", (yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 393
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 398
  union_seen = (_Bool)1;
#line 399
  muscle_code_grow("stype", (yyvsp + 0)->chars, *(yylsp + 0));
#line 400
  code_scanner_last_string_free();
  }
#line 402
  goto switch_break;
  case_47: /* CIL Label */ 
#line 408
  current_class = (symbol_class )2;
#line 409
  goto switch_break;
  case_48: /* CIL Label */ 
#line 410
  current_class = (symbol_class )0;
#line 411
  current_type = (uniqstr )((void *)0);
#line 413
  goto switch_break;
  case_49: /* CIL Label */ 
#line 413
  current_class = (symbol_class )1;
#line 414
  goto switch_break;
  case_50: /* CIL Label */ 
#line 415
  current_class = (symbol_class )0;
#line 416
  current_type = (uniqstr )((void *)0);
#line 418
  goto switch_break;
  case_51: /* CIL Label */ 
#line 421
  tag_seen = (_Bool)1;
#line 422
  list___1 = (yyvsp + 0)->list;
  {
#line 422
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 422
    if (! list___1) {
#line 422
      goto while_break___19;
    }
    {
#line 423
    symbol_type_set(list___1->content.sym, (yyvsp + -1)->uniqstr, *(yylsp + -1));
#line 422
    list___1 = list___1->next;
    }
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 424
  symbol_list_free((yyvsp + 0)->list);
  }
#line 426
  goto switch_break;
  case_52: /* CIL Label */ 
#line 432
  current_prec ++;
#line 433
  list___2 = (yyvsp + 0)->list;
  {
#line 433
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 433
    if (! list___2) {
#line 433
      goto while_break___20;
    }
    {
#line 435
    symbol_type_set(list___2->content.sym, current_type, *(yylsp + -1));
#line 436
    symbol_precedence_set(list___2->content.sym, current_prec, (yyvsp + -2)->assoc,
                          *(yylsp + -2));
#line 433
    list___2 = list___2->next;
    }
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 438
  symbol_list_free((yyvsp + 0)->list);
#line 439
  current_type = (uniqstr )((void *)0);
  }
#line 441
  goto switch_break;
  case_53: /* CIL Label */ 
#line 444
  yyval.assoc = (assoc )2;
#line 445
  goto switch_break;
  case_54: /* CIL Label */ 
#line 445
  yyval.assoc = (assoc )1;
#line 446
  goto switch_break;
  case_55: /* CIL Label */ 
#line 446
  yyval.assoc = (assoc )3;
#line 447
  goto switch_break;
  case_56: /* CIL Label */ 
#line 450
  current_type = (uniqstr )((void *)0);
#line 451
  goto switch_break;
  case_57: /* CIL Label */ 
#line 451
  current_type = (yyvsp + 0)->uniqstr;
#line 451
  tag_seen = (_Bool)1;
#line 452
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 457
  yyval.list = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 458
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 459
  tmp___10 = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
#line 459
  yyval.list = symbol_list_prepend((yyvsp + -1)->list, tmp___10);
  }
#line 460
  goto switch_break;
  case_60: /* CIL Label */ 
#line 463
  yyval.symbol = (yyvsp + 0)->symbol;
#line 464
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 464
  yyval.symbol = (yyvsp + -1)->symbol;
#line 464
  symbol_user_token_number_set((yyvsp + -1)->symbol, (yyvsp + 0)->integer, *(yylsp + 0));
  }
#line 465
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 470
  yyval.list = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 471
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 472
  tmp___11 = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
#line 472
  yyval.list = symbol_list_prepend((yyvsp + -1)->list, tmp___11);
  }
#line 473
  goto switch_break;
  case_64: /* CIL Label */ 
#line 476
  yyval.list = (yyvsp + 0)->list;
#line 477
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 477
  yyval.list = symbol_list_prepend((yyvsp + -1)->list, (yyvsp + 0)->list);
  }
#line 478
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 481
  yyval.list = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 482
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 482
  yyval.list = symbol_list_type_new((yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 483
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 483
  yyval.list = symbol_list_default_tagged_new(*(yylsp + 0));
  }
#line 484
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 484
  yyval.list = symbol_list_default_tagless_new(*(yylsp + 0));
  }
#line 485
  goto switch_break;
  case_70: /* CIL Label */ 
#line 491
  current_type = (yyvsp + 0)->uniqstr;
#line 492
  tag_seen = (_Bool)1;
#line 494
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 496
  symbol_class_set((yyvsp + 0)->symbol, current_class, *(yylsp + 0), (_Bool)1);
#line 497
  symbol_type_set((yyvsp + 0)->symbol, current_type, *(yylsp + 0));
  }
#line 499
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 501
  symbol_class_set((yyvsp + -1)->symbol, current_class, *(yylsp + -1), (_Bool)1);
#line 502
  symbol_type_set((yyvsp + -1)->symbol, current_type, *(yylsp + -1));
#line 503
  symbol_user_token_number_set((yyvsp + -1)->symbol, (yyvsp + 0)->integer, *(yylsp + 0));
  }
#line 505
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 507
  symbol_class_set((yyvsp + -1)->symbol, current_class, *(yylsp + -1), (_Bool)1);
#line 508
  symbol_type_set((yyvsp + -1)->symbol, current_type, *(yylsp + -1));
#line 509
  symbol_make_alias((yyvsp + -1)->symbol, (yyvsp + 0)->symbol, yyloc);
  }
#line 511
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 513
  symbol_class_set((yyvsp + -2)->symbol, current_class, *(yylsp + -2), (_Bool)1);
#line 514
  symbol_type_set((yyvsp + -2)->symbol, current_type, *(yylsp + -2));
#line 515
  symbol_user_token_number_set((yyvsp + -2)->symbol, (yyvsp + -1)->integer, *(yylsp + -1));
#line 516
  symbol_make_alias((yyvsp + -2)->symbol, (yyvsp + 0)->symbol, yyloc);
  }
#line 518
  goto switch_break;
  case_81: /* CIL Label */ 
#line 543
  yyerrstatus = 0;
#line 545
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 548
  current_lhs((yyvsp + -1)->symbol, *(yylsp + -1), (yyvsp + 0)->named_ref);
  }
#line 549
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 551
  current_lhs((symbol *)0, *(yylsp + -3), (named_ref *)0);
  }
#line 553
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 556
  grammar_current_rule_end(*(yylsp + 0));
  }
#line 557
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 557
  grammar_current_rule_end(*(yylsp + 0));
  }
#line 558
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 563
  grammar_current_rule_begin(current_lhs_symbol, current_lhs_location, current_lhs_named_ref);
  }
#line 565
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 566
  grammar_current_rule_symbol_append((yyvsp + -1)->symbol, *(yylsp + -1), (yyvsp + 0)->named_ref);
  }
#line 567
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 568
  grammar_current_rule_action_append((char const   *)(yyvsp + -1)->code, *(yylsp + -1),
                                     (yyvsp + 0)->named_ref);
  }
#line 569
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 570
  grammar_current_rule_prec_set((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 571
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 572
  grammar_current_rule_dprec_set((yyvsp + 0)->integer, *(yylsp + 0));
  }
#line 573
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 574
  grammar_current_rule_merge_set((yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 575
  goto switch_break;
  case_93: /* CIL Label */ 
#line 578
  yyval.named_ref = (named_ref *)0;
#line 579
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 580
  yyval.named_ref = named_ref_new((yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 581
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 592
  yyval.uniqstr = uniqstr_new((yyvsp + 0)->chars);
  }
#line 593
  goto switch_break;
  case_97: /* CIL Label */ 
#line 597
  yyval.chars = "";
#line 598
  goto switch_break;
  case_98: /* CIL Label */ 
#line 598
  yyval.chars = (yyvsp + 0)->uniqstr;
#line 599
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 611
  tmp___12 = strlen((char const   *)(yyvsp + 0)->code);
#line 611
  *((yyvsp + 0)->code + (tmp___12 - 1U)) = (char )'\n';
#line 612
  code_props_plain_init(& plain_code___0, (char const   *)((yyvsp + 0)->code + 1),
                        *(yylsp + 0));
#line 613
  code_props_translate_code(& plain_code___0);
#line 614
  gram_scanner_last_string_free();
#line 615
  yyval.chars = plain_code___0.code;
  }
#line 617
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 629
  yyval.symbol = symbol_from_uniqstr((uniqstr const   )(yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 630
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 632
  tmp___13 = char_name((char )(yyvsp + 0)->character);
#line 632
  yyval.symbol = symbol_get(tmp___13, *(yylsp + 0));
#line 633
  symbol_class_set(yyval.symbol, (symbol_class )1, *(yylsp + 0), (_Bool)0);
#line 634
  symbol_user_token_number_set(yyval.symbol, (int )(yyvsp + 0)->character, *(yylsp + 0));
  }
#line 636
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 639
  yyval.symbol = symbol_from_uniqstr((uniqstr const   )(yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 640
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 652
  tmp___14 = quotearg_style((enum quoting_style )3, (yyvsp + 0)->chars);
#line 652
  yyval.symbol = symbol_get((char const   *)tmp___14, *(yylsp + 0));
#line 653
  symbol_class_set(yyval.symbol, (symbol_class )1, *(yylsp + 0), (_Bool)0);
  }
#line 655
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 662
  code_props_plain_init(& plain_code___1, (yyvsp + 0)->chars, *(yylsp + 0));
#line 663
  code_props_translate_code(& plain_code___1);
#line 664
  gram_scanner_last_string_free();
#line 665
  muscle_code_grow("epilogue", plain_code___1.code, *(yylsp + 0));
#line 666
  code_scanner_last_string_free();
  }
#line 668
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2977 "parse-gram.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2979
  if (yychar_backup != gram_char) {
    {
#line 2980
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 2980
      if (yy_lac_established) {
#line 2980
        if (gram_debug) {
          {
#line 2980
          rpl_fprintf(stderr, "LAC: initial context discarded due to yychar change\n");
          }
        }
#line 2980
        yy_lac_established = 0;
      }
#line 2980
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
  }
  {
#line 2993
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 2993
    if (gram_debug) {
      {
#line 2993
      rpl_fprintf(stderr, "%s ", "-> $$ =");
#line 2993
      yy_symbol_print(stderr, (int )yyr1[yyn], (YYSTYPE const   */* const  */)(& yyval),
                      (location const   */* const  */)(& yyloc));
#line 2993
      rpl_fprintf(stderr, "\n");
      }
    }
#line 2993
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 2995
  yyvsp -= yylen;
#line 2995
  yyssp -= yylen;
#line 2995
  yylsp -= yylen;
#line 2996
  yylen = 0;
  {
#line 2997
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 2997
    if (gram_debug) {
      {
#line 2997
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2997
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 2999
  yyvsp ++;
#line 2999
  *yyvsp = yyval;
#line 3000
  yylsp ++;
#line 3000
  *yylsp = yyloc;
#line 3006
  yyn = (int )yyr1[yyn];
#line 3008
  yystate = (int )(yypgoto[yyn - 58] + (yytype_int16 const   )*yyssp);
#line 3009
  if (0 <= yystate) {
#line 3009
    if (yystate <= 160) {
#line 3009
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 3010
        yystate = (int )yytable[yystate];
      } else {
#line 3012
        yystate = (int )yydefgoto___0[yyn - 58];
      }
    } else {
#line 3012
      yystate = (int )yydefgoto___0[yyn - 58];
    }
  } else {
#line 3012
    yystate = (int )yydefgoto___0[yyn - 58];
  }
#line 3014
  goto yynewstate;
  yyerrlab: 
#line 3023
  if (gram_char == -2) {
#line 3023
    yytoken = -2;
  } else {
#line 3023
    if ((unsigned int )gram_char <= 312U) {
#line 3023
      tmp___15 = (int const   )yytranslate[gram_char];
    } else {
#line 3023
      tmp___15 = (int const   )2;
    }
#line 3023
    yytoken = (int )tmp___15;
  }
#line 3026
  if (! yyerrstatus) {
    {
#line 3028
    gram_nerrs ++;
#line 3036
    tmp___16 = dgettext("bison-runtime", "syntax error");
#line 3036
    yymsgp = (char const   *)tmp___16;
    }
#line 3038
    if (gram_char != -2) {
      {
#line 3039
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 3039
        if (! yy_lac_established) {
          {
#line 3039
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 3039
            if (gram_debug) {
              {
#line 3039
              rpl_fprintf(stderr, "LAC: initial context established for %s\n", yytname[yytoken]);
              }
            }
#line 3039
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
          {
#line 3039
          yy_lac_established = 1;
#line 3039
          tmp___17 = yy_lac(yyesa, & yyes, & yyes_capacity, yyssp, yytoken);
#line 3039
          yy_lac_status___1 = tmp___17;
          }
#line 3039
          if (yy_lac_status___1 == 2) {
#line 3039
            goto yyexhaustedlab;
          }
#line 3039
          if (yy_lac_status___1 == 1) {
#line 3039
            goto yyerrlab;
          }
        }
#line 3039
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
    }
    {
#line 3040
    yysyntax_error_status = yysyntax_error(& yymsg_alloc, & yymsg, yyesa, & yyes,
                                           & yyes_capacity, yyssp, yytoken);
    }
#line 3041
    if (yysyntax_error_status == 0) {
#line 3042
      yymsgp = (char const   *)yymsg;
    } else
#line 3043
    if (yysyntax_error_status == 1) {
#line 3045
      if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
        {
#line 3046
        free((void *)yymsg);
        }
      }
      {
#line 3047
      tmp___18 = malloc(yymsg_alloc);
#line 3047
      yymsg = (char *)tmp___18;
      }
#line 3048
      if (! yymsg) {
#line 3050
        yymsg = yymsgbuf;
#line 3051
        yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
#line 3052
        yysyntax_error_status = 2;
      } else {
        {
#line 3056
        yysyntax_error_status = yysyntax_error(& yymsg_alloc, & yymsg, yyesa, & yyes,
                                               & yyes_capacity, yyssp, yytoken);
#line 3057
        yymsgp = (char const   *)yymsg;
        }
      }
    }
    {
#line 3060
    gram_error((location const   *)(& gram_lloc), yymsgp);
    }
#line 3061
    if (yysyntax_error_status == 2) {
#line 3062
      goto yyexhaustedlab;
    }
  }
#line 3068
  yyerror_range[1] = gram_lloc;
#line 3070
  if (yyerrstatus == 3) {
#line 3075
    if (gram_char <= 0) {
#line 3078
      if (gram_char == 0) {
#line 3079
        goto yyabortlab;
      }
    } else {
      {
#line 3083
      yydestruct("Error: discarding", yytoken, & gram_lval, & gram_lloc);
#line 3085
      gram_char = -2;
      }
    }
  }
#line 3091
  goto yyerrlab1;
#line 3105
  yyerror_range[1] = *(yylsp + (1 - yylen));
#line 3108
  yyvsp -= yylen;
#line 3108
  yyssp -= yylen;
#line 3108
  yylsp -= yylen;
#line 3109
  yylen = 0;
  {
#line 3110
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 3110
    if (gram_debug) {
      {
#line 3110
      yy_stack_print(yyss, yyssp);
      }
    }
#line 3110
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 3111
  yystate = *yyssp;
#line 3112
  goto yyerrlab1;
  yyerrlab1: 
#line 3119
  yyerrstatus = 3;
  {
#line 3121
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 3123
    yyn = (int )yypact[yystate];
#line 3124
    if (! (yyn == -91)) {
#line 3126
      yyn ++;
#line 3127
      if (0 <= yyn) {
#line 3127
        if (yyn <= 160) {
#line 3127
          if ((int const   )yycheck[yyn] == 1) {
#line 3129
            yyn = (int )yytable[yyn];
#line 3130
            if (0 < yyn) {
#line 3131
              goto while_break___27;
            }
          }
        }
      }
    }
#line 3136
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 3137
      goto yyabortlab;
    }
    {
#line 3139
    yyerror_range[1] = *yylsp;
#line 3140
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, yylsp);
#line 3142
    yyvsp --;
#line 3142
    yyssp --;
#line 3142
    yylsp --;
#line 3143
    yystate = *yyssp;
    }
    {
#line 3144
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 3144
      if (gram_debug) {
        {
#line 3144
        yy_stack_print(yyss, yyssp);
        }
      }
#line 3144
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 3149
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 3149
    if (yy_lac_established) {
#line 3149
      if (gram_debug) {
        {
#line 3149
        rpl_fprintf(stderr, "LAC: initial context discarded due to error recovery\n");
        }
      }
#line 3149
      yy_lac_established = 0;
    }
#line 3149
    goto while_break___29;
  }
  while_break___29: /* CIL Label */ ;
  }
  {
#line 3151
  yyvsp ++;
#line 3151
  *yyvsp = gram_lval;
#line 3153
  yyerror_range[2] = gram_lloc;
#line 3156
  yyloc = lloc_default((location const   *)(yyerror_range), 2);
#line 3157
  yylsp ++;
#line 3157
  *yylsp = yyloc;
  }
  {
#line 3160
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 3160
    if (gram_debug) {
      {
#line 3160
      rpl_fprintf(stderr, "%s ", "Shifting");
#line 3160
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE const   */* const  */)yyvsp,
                      (location const   */* const  */)yylsp);
#line 3160
      rpl_fprintf(stderr, "\n");
      }
    }
#line 3160
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 3162
  yystate = yyn;
#line 3163
  goto yynewstate;
  yyacceptlab: 
#line 3170
  yyresult = 0;
#line 3171
  goto yyreturn;
  yyabortlab: 
#line 3177
  yyresult = 1;
#line 3178
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 3185
  tmp___19 = dgettext("bison-runtime", "memory exhausted");
#line 3185
  gram_error((location const   *)(& gram_lloc), (char const   *)tmp___19);
#line 3186
  yyresult = 2;
  }
  yyreturn: 
#line 3191
  if (gram_char != -2) {
#line 3195
    if ((unsigned int )gram_char <= 312U) {
#line 3195
      yytoken = (int )yytranslate[gram_char];
    } else {
#line 3195
      yytoken = 2;
    }
    {
#line 3196
    yydestruct("Cleanup: discarding lookahead", yytoken, & gram_lval, & gram_lloc);
    }
  }
#line 3201
  yyvsp -= yylen;
#line 3201
  yyssp -= yylen;
#line 3201
  yylsp -= yylen;
  {
#line 3202
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 3202
    if (gram_debug) {
      {
#line 3202
      yy_stack_print(yyss, yyssp);
      }
    }
#line 3202
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
  {
#line 3203
  while (1) {
    while_continue___32: /* CIL Label */ ;
#line 3203
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 3203
      goto while_break___32;
    }
    {
#line 3205
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, yylsp);
#line 3207
    yyvsp --;
#line 3207
    yyssp --;
#line 3207
    yylsp --;
    }
  }
  while_break___32: /* CIL Label */ ;
  }
#line 3210
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 3211
    free((void *)yyss);
    }
  }
#line 3213
  if ((unsigned long )yyes != (unsigned long )(yyesa)) {
    {
#line 3214
    free((void *)yyes);
    }
  }
#line 3216
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 3217
    free((void *)yymsg);
    }
  }
#line 3220
  return (yyresult);
}
}
#line 678 "parse-gram.y"
static location lloc_default(location const   *rhs , int n ) 
{ 
  int i ;
  location loc___0 ;
  _Bool tmp ;

  {
#line 686
  loc___0.start = (boundary )(rhs + n)->end;
#line 687
  loc___0.end = (boundary )(rhs + n)->end;
#line 692
  i = 1;
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    if (! (i <= n)) {
#line 692
      goto while_break;
    }
    {
#line 693
    tmp = equal_boundaries((boundary )(rhs + i)->start, (boundary )(rhs + i)->end);
    }
#line 693
    if (! tmp) {
#line 695
      loc___0.start = (boundary )(rhs + i)->start;
#line 696
      goto while_break;
    }
#line 692
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  return (loc___0);
}
}
#line 709 "parse-gram.y"
static char const   alphanum[63]  = 
#line 709
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'_',      (char const   )'0',      (char const   )'1',      (char const   )'2', 
        (char const   )'3',      (char const   )'4',      (char const   )'5',      (char const   )'6', 
        (char const   )'7',      (char const   )'8',      (char const   )'9'};
#line 706 "parse-gram.y"
static void add_param(char const   *type , char *decl , location loc___0 ) 
{ 
  char const   *name_start ;
  char *p ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *name ;
  size_t name_len ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp13 ;

  {
#line 714
  name_start = (char const   *)((void *)0);
#line 718
  p = decl;
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 718
    if (! *(p + 1)) {
#line 718
      goto while_break;
    }
#line 719
    if ((unsigned long )p == (unsigned long )decl) {
#line 719
      goto _L;
    } else {
      {
#line 719
      tmp = memchr((void const   *)(alphanum), (int )*(p + -1), (size_t )sizeof(alphanum));
      }
#line 719
      if (! tmp) {
        _L: /* CIL Label */ 
        {
#line 719
        tmp___0 = memchr((void const   *)(alphanum), (int )*(p + 0), (size_t )(sizeof(alphanum) - 10UL));
        }
#line 719
        if (tmp___0) {
#line 722
          name_start = (char const   *)p;
        }
      }
    }
#line 718
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 726
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 726
    p --;
#line 726
    if (! ((int )*p == 32)) {
#line 726
      if (! ((int )*p == 9)) {
#line 726
        goto while_break___0;
      }
    }
#line 727
    goto while_continue___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 728
  *(p + 1) = (char )'\000';
  {
#line 729
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 729
    decl ++;
#line 729
    if (! ((int )*decl == 32)) {
#line 729
      if (! ((int )*decl == 9)) {
#line 729
        goto while_break___1;
      }
    }
#line 730
    goto while_continue___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  if (! name_start) {
    {
#line 733
    tmp___1 = gettext("missing identifier in parameter declaration");
#line 733
    complain_at(loc___0, (char const   *)tmp___1);
    }
  } else {
#line 739
    name_len = (size_t )1;
    {
#line 739
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 739
      tmp___2 = memchr((void const   *)(alphanum), (int )*(name_start + name_len),
                       (size_t )sizeof(alphanum));
      }
#line 739
      if (! tmp___2) {
#line 739
        goto while_break___2;
      }
#line 742
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 739
      name_len ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 744
    tmp___3 = xmalloc(name_len + 1U);
#line 744
    name = (char *)tmp___3;
#line 745
    memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)name_start,
           name_len);
#line 746
    *(name + name_len) = (char )'\000';
#line 747
    muscle_pair_list_grow(type, (char const   *)decl, (char const   *)name);
#line 748
    free((void *)name);
    }
  }
  {
#line 751
  gram_scanner_last_string_free();
  }
#line 752
  return;
}
}
#line 755 "parse-gram.y"
static void version_check(location const   *loc___0 , char const   *version___0 ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 758
  tmp = strverscmp(version___0, "2.5");
  }
#line 758
  if (tmp > 0) {
    {
#line 760
    complain_at((location )*loc___0, "require bison %s, but have %s", version___0,
                "2.5");
#line 762
    exit(63);
    }
  }
#line 764
  return;
}
}
#line 766 "parse-gram.y"
static void gram_error(location const   *loc___0 , char const   *msg ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 769
  complain_at((location )*loc___0, "%s", msg);
  }
#line 770
  return;
}
}
#line 772 "parse-gram.y"
char const   *token_name(int type ) 
{ 
  int tmp ;

  {
#line 775
  if ((unsigned int )type <= 312U) {
#line 775
    tmp = (int const   )yytranslate[type];
  } else {
#line 775
    tmp = (int const   )2;
  }
#line 775
  return ((char const   *)yytname[tmp]);
}
}
#line 778 "parse-gram.y"
static char const   *char_name(char c ) 
{ 
  char buf___0[4] ;
  char *tmp ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 781
  if ((int )c == 39) {
#line 782
    return ("\'\\\'\'");
  } else {
    {
#line 786
    buf___0[0] = (char )'\'';
#line 786
    buf___0[1] = c;
#line 786
    buf___0[2] = (char )'\'';
#line 786
    buf___0[3] = (char )'\000';
#line 787
    tmp = quotearg_style((enum quoting_style )5, (char const   *)(buf___0));
    }
#line 787
    return ((char const   *)tmp);
  }
}
}
#line 809 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
char *parser_file_name ;
#line 62
char *all_but_ext ;
#line 32 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
char const   *skeleton ;
#line 74
struct bison_language  const  *language ;
#line 27 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.h"
void muscle_insert(char const   *key , char const   *value ) ;
#line 34
struct obstack muscle_obstack ;
#line 210
void muscles_m4_output(FILE *out ) ;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/src/output.h"
void output(void) ;
#line 26
char const   *compute_pkgdatadir(void) ;
#line 46 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static struct obstack format_obstack  ;
#line 104 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void muscle_insert_unsigned_int_table(char const   *name , unsigned int *table_data ,
                                             unsigned int first , int begin , int end ) 
{ 
  unsigned int min ;
  unsigned int max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
#line 104
  min = first;
#line 104
  max = first;
#line 104
  j = 1;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    rpl_sprintf(buf___0, "%6d", first);
#line 104
    __o = & format_obstack;
#line 104
    tmp = strlen((char const   *)(buf___0));
#line 104
    __len = (int )tmp;
    }
#line 104
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 104
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 104
    __o->next_free += __len;
    }
#line 104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  i = begin;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (i < end)) {
#line 104
      goto while_break___0;
    }
#line 104
    __o___0 = & format_obstack;
#line 104
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 104
    tmp___0 = __o___0->next_free;
#line 104
    (__o___0->next_free) ++;
#line 104
    *tmp___0 = (char )',';
#line 104
    if (j >= 10) {
      {
#line 104
      __o___1 = & format_obstack;
#line 104
      tmp___1 = strlen("\n  ");
#line 104
      __len___0 = (int )tmp___1;
      }
#line 104
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 104
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 104
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 104
      __o___1->next_free += __len___0;
#line 104
      j = 1;
      }
    } else {
#line 104
      j ++;
    }
    {
#line 104
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 104
      rpl_sprintf(buf___1, "%6d", *(table_data + i));
#line 104
      __o___2 = & format_obstack;
#line 104
      tmp___2 = strlen((char const   *)(buf___1));
#line 104
      __len___1 = (int )tmp___2;
      }
#line 104
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 104
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 104
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 104
      __o___2->next_free += __len___1;
      }
#line 104
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 104
    if (*(table_data + i) < min) {
#line 104
      min = *(table_data + i);
    }
#line 104
    if (max < *(table_data + i)) {
#line 104
      max = *(table_data + i);
    }
#line 104
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 104
  __o___3 = & format_obstack;
#line 104
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 104
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 104
  tmp___3 = __o___3->next_free;
#line 104
  (__o___3->next_free) ++;
#line 104
  *tmp___3 = (char)0;
#line 104
  __o1 = & format_obstack;
#line 104
  __value = (void *)__o1->object_base;
#line 104
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 104
    __o1->maybe_empty_object = 1U;
  }
#line 104
  if (sizeof(int ) < sizeof(void *)) {
#line 104
    tmp___4 = __o1->object_base;
  } else {
#line 104
    tmp___4 = (char *)0;
  }
#line 104
  if (sizeof(int ) < sizeof(void *)) {
#line 104
    tmp___5 = __o1->object_base;
  } else {
#line 104
    tmp___5 = (char *)0;
  }
#line 104
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 104
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 104
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 104
  __o1->object_base = __o1->next_free;
#line 104
  muscle_insert(name, (char const   *)__value);
#line 104
  lmin = (long )min;
#line 104
  lmax = (long )max;
  }
  {
#line 104
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 104
    rpl_sprintf(buf___2, "%s_min", name);
#line 104
    __o___4 = & format_obstack;
#line 104
    tmp___6 = strlen((char const   *)(buf___2));
#line 104
    __len___2 = (int )tmp___6;
    }
#line 104
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 104
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 104
    __o___4->next_free += __len___2;
    }
#line 104
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 104
  __o___5 = & format_obstack;
#line 104
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 104
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 104
  tmp___7 = __o___5->next_free;
#line 104
  (__o___5->next_free) ++;
#line 104
  *tmp___7 = (char)0;
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 104
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 104
      rpl_sprintf(buf___3, "%ld", lmin);
#line 104
      __o___6 = & muscle_obstack;
#line 104
      tmp___8 = strlen((char const   *)(buf___3));
#line 104
      __len___3 = (int )tmp___8;
      }
#line 104
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 104
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 104
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 104
      __o___6->next_free += __len___3;
      }
#line 104
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 104
    __o___7 = & muscle_obstack;
#line 104
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 104
    tmp___9 = __o___7->next_free;
#line 104
    (__o___7->next_free) ++;
#line 104
    *tmp___9 = (char)0;
#line 104
    __o1___0 = & muscle_obstack;
#line 104
    __value___0 = (void *)__o1___0->object_base;
#line 104
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 104
      __o1___0->maybe_empty_object = 1U;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___10 = __o1___0->object_base;
    } else {
#line 104
      tmp___10 = (char *)0;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___11 = __o1___0->object_base;
    } else {
#line 104
      tmp___11 = (char *)0;
    }
#line 104
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 104
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 104
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 104
    __o1___0->object_base = __o1___0->next_free;
#line 104
    __o1___1 = & format_obstack;
#line 104
    __value___1 = (void *)__o1___1->object_base;
#line 104
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 104
      __o1___1->maybe_empty_object = 1U;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___12 = __o1___1->object_base;
    } else {
#line 104
      tmp___12 = (char *)0;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___13 = __o1___1->object_base;
    } else {
#line 104
      tmp___13 = (char *)0;
    }
#line 104
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 104
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 104
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 104
    __o1___1->object_base = __o1___1->next_free;
#line 104
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 104
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 104
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 104
    rpl_sprintf(buf___4, "%s_max", name);
#line 104
    __o___8 = & format_obstack;
#line 104
    tmp___14 = strlen((char const   *)(buf___4));
#line 104
    __len___4 = (int )tmp___14;
    }
#line 104
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 104
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 104
    __o___8->next_free += __len___4;
    }
#line 104
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 104
  __o___9 = & format_obstack;
#line 104
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 104
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 104
  tmp___15 = __o___9->next_free;
#line 104
  (__o___9->next_free) ++;
#line 104
  *tmp___15 = (char)0;
  {
#line 104
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 104
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 104
      rpl_sprintf(buf___5, "%ld", lmax);
#line 104
      __o___10 = & muscle_obstack;
#line 104
      tmp___16 = strlen((char const   *)(buf___5));
#line 104
      __len___5 = (int )tmp___16;
      }
#line 104
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 104
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 104
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 104
      __o___10->next_free += __len___5;
      }
#line 104
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 104
    __o___11 = & muscle_obstack;
#line 104
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 104
    tmp___17 = __o___11->next_free;
#line 104
    (__o___11->next_free) ++;
#line 104
    *tmp___17 = (char)0;
#line 104
    __o1___2 = & muscle_obstack;
#line 104
    __value___2 = (void *)__o1___2->object_base;
#line 104
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 104
      __o1___2->maybe_empty_object = 1U;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___18 = __o1___2->object_base;
    } else {
#line 104
      tmp___18 = (char *)0;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___19 = __o1___2->object_base;
    } else {
#line 104
      tmp___19 = (char *)0;
    }
#line 104
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 104
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 104
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 104
    __o1___2->object_base = __o1___2->next_free;
#line 104
    __o1___3 = & format_obstack;
#line 104
    __value___3 = (void *)__o1___3->object_base;
#line 104
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 104
      __o1___3->maybe_empty_object = 1U;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___20 = __o1___3->object_base;
    } else {
#line 104
      tmp___20 = (char *)0;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___21 = __o1___3->object_base;
    } else {
#line 104
      tmp___21 = (char *)0;
    }
#line 104
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 104
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 104
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 104
    __o1___3->object_base = __o1___3->next_free;
#line 104
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 104
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 105 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void muscle_insert_int_table(char const   *name , int *table_data , int first ,
                                    int begin , int end ) 
{ 
  int min ;
  int max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
#line 105
  min = first;
#line 105
  max = first;
#line 105
  j = 1;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 105
    rpl_sprintf(buf___0, "%6d", first);
#line 105
    __o = & format_obstack;
#line 105
    tmp = strlen((char const   *)(buf___0));
#line 105
    __len = (int )tmp;
    }
#line 105
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 105
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 105
    __o->next_free += __len;
    }
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = begin;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! (i < end)) {
#line 105
      goto while_break___0;
    }
#line 105
    __o___0 = & format_obstack;
#line 105
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 105
    tmp___0 = __o___0->next_free;
#line 105
    (__o___0->next_free) ++;
#line 105
    *tmp___0 = (char )',';
#line 105
    if (j >= 10) {
      {
#line 105
      __o___1 = & format_obstack;
#line 105
      tmp___1 = strlen("\n  ");
#line 105
      __len___0 = (int )tmp___1;
      }
#line 105
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 105
      __o___1->next_free += __len___0;
#line 105
      j = 1;
      }
    } else {
#line 105
      j ++;
    }
    {
#line 105
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 105
      rpl_sprintf(buf___1, "%6d", *(table_data + i));
#line 105
      __o___2 = & format_obstack;
#line 105
      tmp___2 = strlen((char const   *)(buf___1));
#line 105
      __len___1 = (int )tmp___2;
      }
#line 105
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 105
      __o___2->next_free += __len___1;
      }
#line 105
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 105
    if (*(table_data + i) < min) {
#line 105
      min = *(table_data + i);
    }
#line 105
    if (max < *(table_data + i)) {
#line 105
      max = *(table_data + i);
    }
#line 105
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  __o___3 = & format_obstack;
#line 105
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 105
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 105
  tmp___3 = __o___3->next_free;
#line 105
  (__o___3->next_free) ++;
#line 105
  *tmp___3 = (char)0;
#line 105
  __o1 = & format_obstack;
#line 105
  __value = (void *)__o1->object_base;
#line 105
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 105
    __o1->maybe_empty_object = 1U;
  }
#line 105
  if (sizeof(int ) < sizeof(void *)) {
#line 105
    tmp___4 = __o1->object_base;
  } else {
#line 105
    tmp___4 = (char *)0;
  }
#line 105
  if (sizeof(int ) < sizeof(void *)) {
#line 105
    tmp___5 = __o1->object_base;
  } else {
#line 105
    tmp___5 = (char *)0;
  }
#line 105
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 105
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 105
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 105
  __o1->object_base = __o1->next_free;
#line 105
  muscle_insert(name, (char const   *)__value);
#line 105
  lmin = (long )min;
#line 105
  lmax = (long )max;
  }
  {
#line 105
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 105
    rpl_sprintf(buf___2, "%s_min", name);
#line 105
    __o___4 = & format_obstack;
#line 105
    tmp___6 = strlen((char const   *)(buf___2));
#line 105
    __len___2 = (int )tmp___6;
    }
#line 105
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 105
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 105
    __o___4->next_free += __len___2;
    }
#line 105
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 105
  __o___5 = & format_obstack;
#line 105
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 105
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 105
  tmp___7 = __o___5->next_free;
#line 105
  (__o___5->next_free) ++;
#line 105
  *tmp___7 = (char)0;
  {
#line 105
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 105
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 105
      rpl_sprintf(buf___3, "%ld", lmin);
#line 105
      __o___6 = & muscle_obstack;
#line 105
      tmp___8 = strlen((char const   *)(buf___3));
#line 105
      __len___3 = (int )tmp___8;
      }
#line 105
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 105
      __o___6->next_free += __len___3;
      }
#line 105
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 105
    __o___7 = & muscle_obstack;
#line 105
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 105
    tmp___9 = __o___7->next_free;
#line 105
    (__o___7->next_free) ++;
#line 105
    *tmp___9 = (char)0;
#line 105
    __o1___0 = & muscle_obstack;
#line 105
    __value___0 = (void *)__o1___0->object_base;
#line 105
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 105
      __o1___0->maybe_empty_object = 1U;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___10 = __o1___0->object_base;
    } else {
#line 105
      tmp___10 = (char *)0;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___11 = __o1___0->object_base;
    } else {
#line 105
      tmp___11 = (char *)0;
    }
#line 105
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 105
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 105
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 105
    __o1___0->object_base = __o1___0->next_free;
#line 105
    __o1___1 = & format_obstack;
#line 105
    __value___1 = (void *)__o1___1->object_base;
#line 105
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 105
      __o1___1->maybe_empty_object = 1U;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___12 = __o1___1->object_base;
    } else {
#line 105
      tmp___12 = (char *)0;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___13 = __o1___1->object_base;
    } else {
#line 105
      tmp___13 = (char *)0;
    }
#line 105
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 105
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 105
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 105
    __o1___1->object_base = __o1___1->next_free;
#line 105
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 105
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 105
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 105
    rpl_sprintf(buf___4, "%s_max", name);
#line 105
    __o___8 = & format_obstack;
#line 105
    tmp___14 = strlen((char const   *)(buf___4));
#line 105
    __len___4 = (int )tmp___14;
    }
#line 105
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 105
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 105
    __o___8->next_free += __len___4;
    }
#line 105
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 105
  __o___9 = & format_obstack;
#line 105
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 105
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 105
  tmp___15 = __o___9->next_free;
#line 105
  (__o___9->next_free) ++;
#line 105
  *tmp___15 = (char)0;
  {
#line 105
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 105
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 105
      rpl_sprintf(buf___5, "%ld", lmax);
#line 105
      __o___10 = & muscle_obstack;
#line 105
      tmp___16 = strlen((char const   *)(buf___5));
#line 105
      __len___5 = (int )tmp___16;
      }
#line 105
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 105
      __o___10->next_free += __len___5;
      }
#line 105
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 105
    __o___11 = & muscle_obstack;
#line 105
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 105
    tmp___17 = __o___11->next_free;
#line 105
    (__o___11->next_free) ++;
#line 105
    *tmp___17 = (char)0;
#line 105
    __o1___2 = & muscle_obstack;
#line 105
    __value___2 = (void *)__o1___2->object_base;
#line 105
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 105
      __o1___2->maybe_empty_object = 1U;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___18 = __o1___2->object_base;
    } else {
#line 105
      tmp___18 = (char *)0;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___19 = __o1___2->object_base;
    } else {
#line 105
      tmp___19 = (char *)0;
    }
#line 105
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 105
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 105
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 105
    __o1___2->object_base = __o1___2->next_free;
#line 105
    __o1___3 = & format_obstack;
#line 105
    __value___3 = (void *)__o1___3->object_base;
#line 105
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 105
      __o1___3->maybe_empty_object = 1U;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___20 = __o1___3->object_base;
    } else {
#line 105
      tmp___20 = (char *)0;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___21 = __o1___3->object_base;
    } else {
#line 105
      tmp___21 = (char *)0;
    }
#line 105
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 105
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 105
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 105
    __o1___3->object_base = __o1___3->next_free;
#line 105
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 105
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 106 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void muscle_insert_base_table(char const   *name , base_number *table_data ,
                                     base_number first , int begin , int end ) 
{ 
  base_number min ;
  base_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
#line 106
  min = first;
#line 106
  max = first;
#line 106
  j = 1;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    rpl_sprintf(buf___0, "%6d", first);
#line 106
    __o = & format_obstack;
#line 106
    tmp = strlen((char const   *)(buf___0));
#line 106
    __len = (int )tmp;
    }
#line 106
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 106
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 106
    __o->next_free += __len;
    }
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  i = begin;
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (i < end)) {
#line 106
      goto while_break___0;
    }
#line 106
    __o___0 = & format_obstack;
#line 106
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 106
    tmp___0 = __o___0->next_free;
#line 106
    (__o___0->next_free) ++;
#line 106
    *tmp___0 = (char )',';
#line 106
    if (j >= 10) {
      {
#line 106
      __o___1 = & format_obstack;
#line 106
      tmp___1 = strlen("\n  ");
#line 106
      __len___0 = (int )tmp___1;
      }
#line 106
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 106
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 106
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 106
      __o___1->next_free += __len___0;
#line 106
      j = 1;
      }
    } else {
#line 106
      j ++;
    }
    {
#line 106
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 106
      rpl_sprintf(buf___1, "%6d", *(table_data + i));
#line 106
      __o___2 = & format_obstack;
#line 106
      tmp___2 = strlen((char const   *)(buf___1));
#line 106
      __len___1 = (int )tmp___2;
      }
#line 106
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 106
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 106
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 106
      __o___2->next_free += __len___1;
      }
#line 106
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 106
    if (*(table_data + i) < min) {
#line 106
      min = *(table_data + i);
    }
#line 106
    if (max < *(table_data + i)) {
#line 106
      max = *(table_data + i);
    }
#line 106
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 106
  __o___3 = & format_obstack;
#line 106
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 106
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 106
  tmp___3 = __o___3->next_free;
#line 106
  (__o___3->next_free) ++;
#line 106
  *tmp___3 = (char)0;
#line 106
  __o1 = & format_obstack;
#line 106
  __value = (void *)__o1->object_base;
#line 106
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 106
    __o1->maybe_empty_object = 1U;
  }
#line 106
  if (sizeof(int ) < sizeof(void *)) {
#line 106
    tmp___4 = __o1->object_base;
  } else {
#line 106
    tmp___4 = (char *)0;
  }
#line 106
  if (sizeof(int ) < sizeof(void *)) {
#line 106
    tmp___5 = __o1->object_base;
  } else {
#line 106
    tmp___5 = (char *)0;
  }
#line 106
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 106
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 106
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 106
  __o1->object_base = __o1->next_free;
#line 106
  muscle_insert(name, (char const   *)__value);
#line 106
  lmin = (long )min;
#line 106
  lmax = (long )max;
  }
  {
#line 106
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 106
    rpl_sprintf(buf___2, "%s_min", name);
#line 106
    __o___4 = & format_obstack;
#line 106
    tmp___6 = strlen((char const   *)(buf___2));
#line 106
    __len___2 = (int )tmp___6;
    }
#line 106
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 106
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 106
    __o___4->next_free += __len___2;
    }
#line 106
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 106
  __o___5 = & format_obstack;
#line 106
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 106
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 106
  tmp___7 = __o___5->next_free;
#line 106
  (__o___5->next_free) ++;
#line 106
  *tmp___7 = (char)0;
  {
#line 106
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 106
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 106
      rpl_sprintf(buf___3, "%ld", lmin);
#line 106
      __o___6 = & muscle_obstack;
#line 106
      tmp___8 = strlen((char const   *)(buf___3));
#line 106
      __len___3 = (int )tmp___8;
      }
#line 106
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 106
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 106
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 106
      __o___6->next_free += __len___3;
      }
#line 106
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 106
    __o___7 = & muscle_obstack;
#line 106
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 106
    tmp___9 = __o___7->next_free;
#line 106
    (__o___7->next_free) ++;
#line 106
    *tmp___9 = (char)0;
#line 106
    __o1___0 = & muscle_obstack;
#line 106
    __value___0 = (void *)__o1___0->object_base;
#line 106
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 106
      __o1___0->maybe_empty_object = 1U;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___10 = __o1___0->object_base;
    } else {
#line 106
      tmp___10 = (char *)0;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___11 = __o1___0->object_base;
    } else {
#line 106
      tmp___11 = (char *)0;
    }
#line 106
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 106
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 106
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 106
    __o1___0->object_base = __o1___0->next_free;
#line 106
    __o1___1 = & format_obstack;
#line 106
    __value___1 = (void *)__o1___1->object_base;
#line 106
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 106
      __o1___1->maybe_empty_object = 1U;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___12 = __o1___1->object_base;
    } else {
#line 106
      tmp___12 = (char *)0;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___13 = __o1___1->object_base;
    } else {
#line 106
      tmp___13 = (char *)0;
    }
#line 106
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 106
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 106
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 106
    __o1___1->object_base = __o1___1->next_free;
#line 106
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 106
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 106
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 106
    rpl_sprintf(buf___4, "%s_max", name);
#line 106
    __o___8 = & format_obstack;
#line 106
    tmp___14 = strlen((char const   *)(buf___4));
#line 106
    __len___4 = (int )tmp___14;
    }
#line 106
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 106
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 106
    __o___8->next_free += __len___4;
    }
#line 106
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 106
  __o___9 = & format_obstack;
#line 106
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 106
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 106
  tmp___15 = __o___9->next_free;
#line 106
  (__o___9->next_free) ++;
#line 106
  *tmp___15 = (char)0;
  {
#line 106
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 106
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 106
      rpl_sprintf(buf___5, "%ld", lmax);
#line 106
      __o___10 = & muscle_obstack;
#line 106
      tmp___16 = strlen((char const   *)(buf___5));
#line 106
      __len___5 = (int )tmp___16;
      }
#line 106
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 106
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 106
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 106
      __o___10->next_free += __len___5;
      }
#line 106
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 106
    __o___11 = & muscle_obstack;
#line 106
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 106
    tmp___17 = __o___11->next_free;
#line 106
    (__o___11->next_free) ++;
#line 106
    *tmp___17 = (char)0;
#line 106
    __o1___2 = & muscle_obstack;
#line 106
    __value___2 = (void *)__o1___2->object_base;
#line 106
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 106
      __o1___2->maybe_empty_object = 1U;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___18 = __o1___2->object_base;
    } else {
#line 106
      tmp___18 = (char *)0;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___19 = __o1___2->object_base;
    } else {
#line 106
      tmp___19 = (char *)0;
    }
#line 106
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 106
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 106
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 106
    __o1___2->object_base = __o1___2->next_free;
#line 106
    __o1___3 = & format_obstack;
#line 106
    __value___3 = (void *)__o1___3->object_base;
#line 106
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 106
      __o1___3->maybe_empty_object = 1U;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___20 = __o1___3->object_base;
    } else {
#line 106
      tmp___20 = (char *)0;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___21 = __o1___3->object_base;
    } else {
#line 106
      tmp___21 = (char *)0;
    }
#line 106
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 106
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 106
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 106
    __o1___3->object_base = __o1___3->next_free;
#line 106
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 106
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 107 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void muscle_insert_rule_number_table(char const   *name , rule_number *table_data ,
                                            rule_number first , int begin , int end ) 
{ 
  rule_number min ;
  rule_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
#line 107
  min = first;
#line 107
  max = first;
#line 107
  j = 1;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    rpl_sprintf(buf___0, "%6d", first);
#line 107
    __o = & format_obstack;
#line 107
    tmp = strlen((char const   *)(buf___0));
#line 107
    __len = (int )tmp;
    }
#line 107
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 107
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 107
    __o->next_free += __len;
    }
#line 107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  i = begin;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (i < end)) {
#line 107
      goto while_break___0;
    }
#line 107
    __o___0 = & format_obstack;
#line 107
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 107
    tmp___0 = __o___0->next_free;
#line 107
    (__o___0->next_free) ++;
#line 107
    *tmp___0 = (char )',';
#line 107
    if (j >= 10) {
      {
#line 107
      __o___1 = & format_obstack;
#line 107
      tmp___1 = strlen("\n  ");
#line 107
      __len___0 = (int )tmp___1;
      }
#line 107
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 107
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 107
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 107
      __o___1->next_free += __len___0;
#line 107
      j = 1;
      }
    } else {
#line 107
      j ++;
    }
    {
#line 107
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 107
      rpl_sprintf(buf___1, "%6d", *(table_data + i));
#line 107
      __o___2 = & format_obstack;
#line 107
      tmp___2 = strlen((char const   *)(buf___1));
#line 107
      __len___1 = (int )tmp___2;
      }
#line 107
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 107
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 107
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 107
      __o___2->next_free += __len___1;
      }
#line 107
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 107
    if (*(table_data + i) < min) {
#line 107
      min = *(table_data + i);
    }
#line 107
    if (max < *(table_data + i)) {
#line 107
      max = *(table_data + i);
    }
#line 107
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  __o___3 = & format_obstack;
#line 107
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 107
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 107
  tmp___3 = __o___3->next_free;
#line 107
  (__o___3->next_free) ++;
#line 107
  *tmp___3 = (char)0;
#line 107
  __o1 = & format_obstack;
#line 107
  __value = (void *)__o1->object_base;
#line 107
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 107
    __o1->maybe_empty_object = 1U;
  }
#line 107
  if (sizeof(int ) < sizeof(void *)) {
#line 107
    tmp___4 = __o1->object_base;
  } else {
#line 107
    tmp___4 = (char *)0;
  }
#line 107
  if (sizeof(int ) < sizeof(void *)) {
#line 107
    tmp___5 = __o1->object_base;
  } else {
#line 107
    tmp___5 = (char *)0;
  }
#line 107
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 107
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 107
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 107
  __o1->object_base = __o1->next_free;
#line 107
  muscle_insert(name, (char const   *)__value);
#line 107
  lmin = (long )min;
#line 107
  lmax = (long )max;
  }
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 107
    rpl_sprintf(buf___2, "%s_min", name);
#line 107
    __o___4 = & format_obstack;
#line 107
    tmp___6 = strlen((char const   *)(buf___2));
#line 107
    __len___2 = (int )tmp___6;
    }
#line 107
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 107
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 107
    __o___4->next_free += __len___2;
    }
#line 107
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 107
  __o___5 = & format_obstack;
#line 107
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 107
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 107
  tmp___7 = __o___5->next_free;
#line 107
  (__o___5->next_free) ++;
#line 107
  *tmp___7 = (char)0;
  {
#line 107
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 107
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 107
      rpl_sprintf(buf___3, "%ld", lmin);
#line 107
      __o___6 = & muscle_obstack;
#line 107
      tmp___8 = strlen((char const   *)(buf___3));
#line 107
      __len___3 = (int )tmp___8;
      }
#line 107
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 107
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 107
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 107
      __o___6->next_free += __len___3;
      }
#line 107
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 107
    __o___7 = & muscle_obstack;
#line 107
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 107
    tmp___9 = __o___7->next_free;
#line 107
    (__o___7->next_free) ++;
#line 107
    *tmp___9 = (char)0;
#line 107
    __o1___0 = & muscle_obstack;
#line 107
    __value___0 = (void *)__o1___0->object_base;
#line 107
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 107
      __o1___0->maybe_empty_object = 1U;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___10 = __o1___0->object_base;
    } else {
#line 107
      tmp___10 = (char *)0;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___11 = __o1___0->object_base;
    } else {
#line 107
      tmp___11 = (char *)0;
    }
#line 107
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 107
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 107
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 107
    __o1___0->object_base = __o1___0->next_free;
#line 107
    __o1___1 = & format_obstack;
#line 107
    __value___1 = (void *)__o1___1->object_base;
#line 107
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 107
      __o1___1->maybe_empty_object = 1U;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___12 = __o1___1->object_base;
    } else {
#line 107
      tmp___12 = (char *)0;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___13 = __o1___1->object_base;
    } else {
#line 107
      tmp___13 = (char *)0;
    }
#line 107
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 107
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 107
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 107
    __o1___1->object_base = __o1___1->next_free;
#line 107
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 107
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 107
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 107
    rpl_sprintf(buf___4, "%s_max", name);
#line 107
    __o___8 = & format_obstack;
#line 107
    tmp___14 = strlen((char const   *)(buf___4));
#line 107
    __len___4 = (int )tmp___14;
    }
#line 107
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 107
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 107
    __o___8->next_free += __len___4;
    }
#line 107
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 107
  __o___9 = & format_obstack;
#line 107
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 107
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 107
  tmp___15 = __o___9->next_free;
#line 107
  (__o___9->next_free) ++;
#line 107
  *tmp___15 = (char)0;
  {
#line 107
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 107
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 107
      rpl_sprintf(buf___5, "%ld", lmax);
#line 107
      __o___10 = & muscle_obstack;
#line 107
      tmp___16 = strlen((char const   *)(buf___5));
#line 107
      __len___5 = (int )tmp___16;
      }
#line 107
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 107
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 107
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 107
      __o___10->next_free += __len___5;
      }
#line 107
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 107
    __o___11 = & muscle_obstack;
#line 107
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 107
    tmp___17 = __o___11->next_free;
#line 107
    (__o___11->next_free) ++;
#line 107
    *tmp___17 = (char)0;
#line 107
    __o1___2 = & muscle_obstack;
#line 107
    __value___2 = (void *)__o1___2->object_base;
#line 107
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 107
      __o1___2->maybe_empty_object = 1U;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___18 = __o1___2->object_base;
    } else {
#line 107
      tmp___18 = (char *)0;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___19 = __o1___2->object_base;
    } else {
#line 107
      tmp___19 = (char *)0;
    }
#line 107
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 107
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 107
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 107
    __o1___2->object_base = __o1___2->next_free;
#line 107
    __o1___3 = & format_obstack;
#line 107
    __value___3 = (void *)__o1___3->object_base;
#line 107
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 107
      __o1___3->maybe_empty_object = 1U;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___20 = __o1___3->object_base;
    } else {
#line 107
      tmp___20 = (char *)0;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___21 = __o1___3->object_base;
    } else {
#line 107
      tmp___21 = (char *)0;
    }
#line 107
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 107
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 107
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 107
    __o1___3->object_base = __o1___3->next_free;
#line 107
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 107
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 108 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void muscle_insert_symbol_number_table(char const   *name , symbol_number *table_data ,
                                              symbol_number first , int begin , int end ) 
{ 
  symbol_number min ;
  symbol_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
#line 108
  min = first;
#line 108
  max = first;
#line 108
  j = 1;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    rpl_sprintf(buf___0, "%6d", first);
#line 108
    __o = & format_obstack;
#line 108
    tmp = strlen((char const   *)(buf___0));
#line 108
    __len = (int )tmp;
    }
#line 108
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 108
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 108
    __o->next_free += __len;
    }
#line 108
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  i = begin;
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! (i < end)) {
#line 108
      goto while_break___0;
    }
#line 108
    __o___0 = & format_obstack;
#line 108
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 108
    tmp___0 = __o___0->next_free;
#line 108
    (__o___0->next_free) ++;
#line 108
    *tmp___0 = (char )',';
#line 108
    if (j >= 10) {
      {
#line 108
      __o___1 = & format_obstack;
#line 108
      tmp___1 = strlen("\n  ");
#line 108
      __len___0 = (int )tmp___1;
      }
#line 108
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 108
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 108
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 108
      __o___1->next_free += __len___0;
#line 108
      j = 1;
      }
    } else {
#line 108
      j ++;
    }
    {
#line 108
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 108
      rpl_sprintf(buf___1, "%6d", *(table_data + i));
#line 108
      __o___2 = & format_obstack;
#line 108
      tmp___2 = strlen((char const   *)(buf___1));
#line 108
      __len___1 = (int )tmp___2;
      }
#line 108
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 108
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 108
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 108
      __o___2->next_free += __len___1;
      }
#line 108
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 108
    if (*(table_data + i) < min) {
#line 108
      min = *(table_data + i);
    }
#line 108
    if (max < *(table_data + i)) {
#line 108
      max = *(table_data + i);
    }
#line 108
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  __o___3 = & format_obstack;
#line 108
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 108
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 108
  tmp___3 = __o___3->next_free;
#line 108
  (__o___3->next_free) ++;
#line 108
  *tmp___3 = (char)0;
#line 108
  __o1 = & format_obstack;
#line 108
  __value = (void *)__o1->object_base;
#line 108
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 108
    __o1->maybe_empty_object = 1U;
  }
#line 108
  if (sizeof(int ) < sizeof(void *)) {
#line 108
    tmp___4 = __o1->object_base;
  } else {
#line 108
    tmp___4 = (char *)0;
  }
#line 108
  if (sizeof(int ) < sizeof(void *)) {
#line 108
    tmp___5 = __o1->object_base;
  } else {
#line 108
    tmp___5 = (char *)0;
  }
#line 108
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 108
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 108
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 108
  __o1->object_base = __o1->next_free;
#line 108
  muscle_insert(name, (char const   *)__value);
#line 108
  lmin = (long )min;
#line 108
  lmax = (long )max;
  }
  {
#line 108
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 108
    rpl_sprintf(buf___2, "%s_min", name);
#line 108
    __o___4 = & format_obstack;
#line 108
    tmp___6 = strlen((char const   *)(buf___2));
#line 108
    __len___2 = (int )tmp___6;
    }
#line 108
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 108
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 108
    __o___4->next_free += __len___2;
    }
#line 108
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 108
  __o___5 = & format_obstack;
#line 108
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 108
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 108
  tmp___7 = __o___5->next_free;
#line 108
  (__o___5->next_free) ++;
#line 108
  *tmp___7 = (char)0;
  {
#line 108
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 108
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 108
      rpl_sprintf(buf___3, "%ld", lmin);
#line 108
      __o___6 = & muscle_obstack;
#line 108
      tmp___8 = strlen((char const   *)(buf___3));
#line 108
      __len___3 = (int )tmp___8;
      }
#line 108
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 108
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 108
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 108
      __o___6->next_free += __len___3;
      }
#line 108
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 108
    __o___7 = & muscle_obstack;
#line 108
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 108
    tmp___9 = __o___7->next_free;
#line 108
    (__o___7->next_free) ++;
#line 108
    *tmp___9 = (char)0;
#line 108
    __o1___0 = & muscle_obstack;
#line 108
    __value___0 = (void *)__o1___0->object_base;
#line 108
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 108
      __o1___0->maybe_empty_object = 1U;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___10 = __o1___0->object_base;
    } else {
#line 108
      tmp___10 = (char *)0;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___11 = __o1___0->object_base;
    } else {
#line 108
      tmp___11 = (char *)0;
    }
#line 108
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 108
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 108
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 108
    __o1___0->object_base = __o1___0->next_free;
#line 108
    __o1___1 = & format_obstack;
#line 108
    __value___1 = (void *)__o1___1->object_base;
#line 108
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 108
      __o1___1->maybe_empty_object = 1U;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___12 = __o1___1->object_base;
    } else {
#line 108
      tmp___12 = (char *)0;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___13 = __o1___1->object_base;
    } else {
#line 108
      tmp___13 = (char *)0;
    }
#line 108
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 108
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 108
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 108
    __o1___1->object_base = __o1___1->next_free;
#line 108
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 108
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 108
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 108
    rpl_sprintf(buf___4, "%s_max", name);
#line 108
    __o___8 = & format_obstack;
#line 108
    tmp___14 = strlen((char const   *)(buf___4));
#line 108
    __len___4 = (int )tmp___14;
    }
#line 108
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 108
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 108
    __o___8->next_free += __len___4;
    }
#line 108
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 108
  __o___9 = & format_obstack;
#line 108
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 108
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 108
  tmp___15 = __o___9->next_free;
#line 108
  (__o___9->next_free) ++;
#line 108
  *tmp___15 = (char)0;
  {
#line 108
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 108
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 108
      rpl_sprintf(buf___5, "%ld", lmax);
#line 108
      __o___10 = & muscle_obstack;
#line 108
      tmp___16 = strlen((char const   *)(buf___5));
#line 108
      __len___5 = (int )tmp___16;
      }
#line 108
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 108
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 108
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 108
      __o___10->next_free += __len___5;
      }
#line 108
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 108
    __o___11 = & muscle_obstack;
#line 108
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 108
    tmp___17 = __o___11->next_free;
#line 108
    (__o___11->next_free) ++;
#line 108
    *tmp___17 = (char)0;
#line 108
    __o1___2 = & muscle_obstack;
#line 108
    __value___2 = (void *)__o1___2->object_base;
#line 108
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 108
      __o1___2->maybe_empty_object = 1U;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___18 = __o1___2->object_base;
    } else {
#line 108
      tmp___18 = (char *)0;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___19 = __o1___2->object_base;
    } else {
#line 108
      tmp___19 = (char *)0;
    }
#line 108
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 108
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 108
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 108
    __o1___2->object_base = __o1___2->next_free;
#line 108
    __o1___3 = & format_obstack;
#line 108
    __value___3 = (void *)__o1___3->object_base;
#line 108
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 108
      __o1___3->maybe_empty_object = 1U;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___20 = __o1___3->object_base;
    } else {
#line 108
      tmp___20 = (char *)0;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___21 = __o1___3->object_base;
    } else {
#line 108
      tmp___21 = (char *)0;
    }
#line 108
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 108
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 108
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 108
    __o1___3->object_base = __o1___3->next_free;
#line 108
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 108
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 109 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void muscle_insert_item_number_table(char const   *name , item_number *table_data ,
                                            item_number first , int begin , int end ) 
{ 
  item_number min ;
  item_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
#line 109
  min = first;
#line 109
  max = first;
#line 109
  j = 1;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 109
    rpl_sprintf(buf___0, "%6d", first);
#line 109
    __o = & format_obstack;
#line 109
    tmp = strlen((char const   *)(buf___0));
#line 109
    __len = (int )tmp;
    }
#line 109
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 109
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 109
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 109
    __o->next_free += __len;
    }
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  i = begin;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (i < end)) {
#line 109
      goto while_break___0;
    }
#line 109
    __o___0 = & format_obstack;
#line 109
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 109
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 109
    tmp___0 = __o___0->next_free;
#line 109
    (__o___0->next_free) ++;
#line 109
    *tmp___0 = (char )',';
#line 109
    if (j >= 10) {
      {
#line 109
      __o___1 = & format_obstack;
#line 109
      tmp___1 = strlen("\n  ");
#line 109
      __len___0 = (int )tmp___1;
      }
#line 109
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 109
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 109
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 109
      __o___1->next_free += __len___0;
#line 109
      j = 1;
      }
    } else {
#line 109
      j ++;
    }
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 109
      rpl_sprintf(buf___1, "%6d", *(table_data + i));
#line 109
      __o___2 = & format_obstack;
#line 109
      tmp___2 = strlen((char const   *)(buf___1));
#line 109
      __len___1 = (int )tmp___2;
      }
#line 109
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 109
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 109
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 109
      __o___2->next_free += __len___1;
      }
#line 109
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 109
    if (*(table_data + i) < min) {
#line 109
      min = *(table_data + i);
    }
#line 109
    if (max < *(table_data + i)) {
#line 109
      max = *(table_data + i);
    }
#line 109
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  __o___3 = & format_obstack;
#line 109
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 109
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 109
  tmp___3 = __o___3->next_free;
#line 109
  (__o___3->next_free) ++;
#line 109
  *tmp___3 = (char)0;
#line 109
  __o1 = & format_obstack;
#line 109
  __value = (void *)__o1->object_base;
#line 109
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 109
    __o1->maybe_empty_object = 1U;
  }
#line 109
  if (sizeof(int ) < sizeof(void *)) {
#line 109
    tmp___4 = __o1->object_base;
  } else {
#line 109
    tmp___4 = (char *)0;
  }
#line 109
  if (sizeof(int ) < sizeof(void *)) {
#line 109
    tmp___5 = __o1->object_base;
  } else {
#line 109
    tmp___5 = (char *)0;
  }
#line 109
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 109
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 109
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 109
  __o1->object_base = __o1->next_free;
#line 109
  muscle_insert(name, (char const   *)__value);
#line 109
  lmin = (long )min;
#line 109
  lmax = (long )max;
  }
  {
#line 109
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 109
    rpl_sprintf(buf___2, "%s_min", name);
#line 109
    __o___4 = & format_obstack;
#line 109
    tmp___6 = strlen((char const   *)(buf___2));
#line 109
    __len___2 = (int )tmp___6;
    }
#line 109
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 109
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 109
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 109
    __o___4->next_free += __len___2;
    }
#line 109
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 109
  __o___5 = & format_obstack;
#line 109
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 109
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 109
  tmp___7 = __o___5->next_free;
#line 109
  (__o___5->next_free) ++;
#line 109
  *tmp___7 = (char)0;
  {
#line 109
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 109
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 109
      rpl_sprintf(buf___3, "%ld", lmin);
#line 109
      __o___6 = & muscle_obstack;
#line 109
      tmp___8 = strlen((char const   *)(buf___3));
#line 109
      __len___3 = (int )tmp___8;
      }
#line 109
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 109
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 109
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 109
      __o___6->next_free += __len___3;
      }
#line 109
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 109
    __o___7 = & muscle_obstack;
#line 109
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 109
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 109
    tmp___9 = __o___7->next_free;
#line 109
    (__o___7->next_free) ++;
#line 109
    *tmp___9 = (char)0;
#line 109
    __o1___0 = & muscle_obstack;
#line 109
    __value___0 = (void *)__o1___0->object_base;
#line 109
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 109
      __o1___0->maybe_empty_object = 1U;
    }
#line 109
    if (sizeof(int ) < sizeof(void *)) {
#line 109
      tmp___10 = __o1___0->object_base;
    } else {
#line 109
      tmp___10 = (char *)0;
    }
#line 109
    if (sizeof(int ) < sizeof(void *)) {
#line 109
      tmp___11 = __o1___0->object_base;
    } else {
#line 109
      tmp___11 = (char *)0;
    }
#line 109
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 109
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 109
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 109
    __o1___0->object_base = __o1___0->next_free;
#line 109
    __o1___1 = & format_obstack;
#line 109
    __value___1 = (void *)__o1___1->object_base;
#line 109
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 109
      __o1___1->maybe_empty_object = 1U;
    }
#line 109
    if (sizeof(int ) < sizeof(void *)) {
#line 109
      tmp___12 = __o1___1->object_base;
    } else {
#line 109
      tmp___12 = (char *)0;
    }
#line 109
    if (sizeof(int ) < sizeof(void *)) {
#line 109
      tmp___13 = __o1___1->object_base;
    } else {
#line 109
      tmp___13 = (char *)0;
    }
#line 109
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 109
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 109
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 109
    __o1___1->object_base = __o1___1->next_free;
#line 109
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 109
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 109
    rpl_sprintf(buf___4, "%s_max", name);
#line 109
    __o___8 = & format_obstack;
#line 109
    tmp___14 = strlen((char const   *)(buf___4));
#line 109
    __len___4 = (int )tmp___14;
    }
#line 109
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 109
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 109
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 109
    __o___8->next_free += __len___4;
    }
#line 109
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 109
  __o___9 = & format_obstack;
#line 109
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 109
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 109
  tmp___15 = __o___9->next_free;
#line 109
  (__o___9->next_free) ++;
#line 109
  *tmp___15 = (char)0;
  {
#line 109
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 109
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 109
      rpl_sprintf(buf___5, "%ld", lmax);
#line 109
      __o___10 = & muscle_obstack;
#line 109
      tmp___16 = strlen((char const   *)(buf___5));
#line 109
      __len___5 = (int )tmp___16;
      }
#line 109
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 109
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 109
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 109
      __o___10->next_free += __len___5;
      }
#line 109
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 109
    __o___11 = & muscle_obstack;
#line 109
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 109
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 109
    tmp___17 = __o___11->next_free;
#line 109
    (__o___11->next_free) ++;
#line 109
    *tmp___17 = (char)0;
#line 109
    __o1___2 = & muscle_obstack;
#line 109
    __value___2 = (void *)__o1___2->object_base;
#line 109
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 109
      __o1___2->maybe_empty_object = 1U;
    }
#line 109
    if (sizeof(int ) < sizeof(void *)) {
#line 109
      tmp___18 = __o1___2->object_base;
    } else {
#line 109
      tmp___18 = (char *)0;
    }
#line 109
    if (sizeof(int ) < sizeof(void *)) {
#line 109
      tmp___19 = __o1___2->object_base;
    } else {
#line 109
      tmp___19 = (char *)0;
    }
#line 109
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 109
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 109
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 109
    __o1___2->object_base = __o1___2->next_free;
#line 109
    __o1___3 = & format_obstack;
#line 109
    __value___3 = (void *)__o1___3->object_base;
#line 109
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 109
      __o1___3->maybe_empty_object = 1U;
    }
#line 109
    if (sizeof(int ) < sizeof(void *)) {
#line 109
      tmp___20 = __o1___3->object_base;
    } else {
#line 109
      tmp___20 = (char *)0;
    }
#line 109
    if (sizeof(int ) < sizeof(void *)) {
#line 109
      tmp___21 = __o1___3->object_base;
    } else {
#line 109
      tmp___21 = (char *)0;
    }
#line 109
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 109
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 109
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 109
    __o1___3->object_base = __o1___3->next_free;
#line 109
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 109
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 110 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void muscle_insert_state_number_table(char const   *name , state_number *table_data ,
                                             state_number first , int begin , int end ) 
{ 
  state_number min ;
  state_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
#line 110
  min = first;
#line 110
  max = first;
#line 110
  j = 1;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 110
    rpl_sprintf(buf___0, "%6d", first);
#line 110
    __o = & format_obstack;
#line 110
    tmp = strlen((char const   *)(buf___0));
#line 110
    __len = (int )tmp;
    }
#line 110
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 110
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 110
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 110
    __o->next_free += __len;
    }
#line 110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  i = begin;
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    if (! (i < end)) {
#line 110
      goto while_break___0;
    }
#line 110
    __o___0 = & format_obstack;
#line 110
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 110
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 110
    tmp___0 = __o___0->next_free;
#line 110
    (__o___0->next_free) ++;
#line 110
    *tmp___0 = (char )',';
#line 110
    if (j >= 10) {
      {
#line 110
      __o___1 = & format_obstack;
#line 110
      tmp___1 = strlen("\n  ");
#line 110
      __len___0 = (int )tmp___1;
      }
#line 110
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 110
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 110
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 110
      __o___1->next_free += __len___0;
#line 110
      j = 1;
      }
    } else {
#line 110
      j ++;
    }
    {
#line 110
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 110
      rpl_sprintf(buf___1, "%6d", *(table_data + i));
#line 110
      __o___2 = & format_obstack;
#line 110
      tmp___2 = strlen((char const   *)(buf___1));
#line 110
      __len___1 = (int )tmp___2;
      }
#line 110
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 110
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 110
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 110
      __o___2->next_free += __len___1;
      }
#line 110
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 110
    if (*(table_data + i) < min) {
#line 110
      min = *(table_data + i);
    }
#line 110
    if (max < *(table_data + i)) {
#line 110
      max = *(table_data + i);
    }
#line 110
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  __o___3 = & format_obstack;
#line 110
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 110
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 110
  tmp___3 = __o___3->next_free;
#line 110
  (__o___3->next_free) ++;
#line 110
  *tmp___3 = (char)0;
#line 110
  __o1 = & format_obstack;
#line 110
  __value = (void *)__o1->object_base;
#line 110
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 110
    __o1->maybe_empty_object = 1U;
  }
#line 110
  if (sizeof(int ) < sizeof(void *)) {
#line 110
    tmp___4 = __o1->object_base;
  } else {
#line 110
    tmp___4 = (char *)0;
  }
#line 110
  if (sizeof(int ) < sizeof(void *)) {
#line 110
    tmp___5 = __o1->object_base;
  } else {
#line 110
    tmp___5 = (char *)0;
  }
#line 110
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 110
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 110
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 110
  __o1->object_base = __o1->next_free;
#line 110
  muscle_insert(name, (char const   *)__value);
#line 110
  lmin = (long )min;
#line 110
  lmax = (long )max;
  }
  {
#line 110
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 110
    rpl_sprintf(buf___2, "%s_min", name);
#line 110
    __o___4 = & format_obstack;
#line 110
    tmp___6 = strlen((char const   *)(buf___2));
#line 110
    __len___2 = (int )tmp___6;
    }
#line 110
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 110
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 110
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 110
    __o___4->next_free += __len___2;
    }
#line 110
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 110
  __o___5 = & format_obstack;
#line 110
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 110
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 110
  tmp___7 = __o___5->next_free;
#line 110
  (__o___5->next_free) ++;
#line 110
  *tmp___7 = (char)0;
  {
#line 110
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 110
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 110
      rpl_sprintf(buf___3, "%ld", lmin);
#line 110
      __o___6 = & muscle_obstack;
#line 110
      tmp___8 = strlen((char const   *)(buf___3));
#line 110
      __len___3 = (int )tmp___8;
      }
#line 110
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 110
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 110
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 110
      __o___6->next_free += __len___3;
      }
#line 110
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 110
    __o___7 = & muscle_obstack;
#line 110
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 110
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 110
    tmp___9 = __o___7->next_free;
#line 110
    (__o___7->next_free) ++;
#line 110
    *tmp___9 = (char)0;
#line 110
    __o1___0 = & muscle_obstack;
#line 110
    __value___0 = (void *)__o1___0->object_base;
#line 110
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 110
      __o1___0->maybe_empty_object = 1U;
    }
#line 110
    if (sizeof(int ) < sizeof(void *)) {
#line 110
      tmp___10 = __o1___0->object_base;
    } else {
#line 110
      tmp___10 = (char *)0;
    }
#line 110
    if (sizeof(int ) < sizeof(void *)) {
#line 110
      tmp___11 = __o1___0->object_base;
    } else {
#line 110
      tmp___11 = (char *)0;
    }
#line 110
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 110
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 110
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 110
    __o1___0->object_base = __o1___0->next_free;
#line 110
    __o1___1 = & format_obstack;
#line 110
    __value___1 = (void *)__o1___1->object_base;
#line 110
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 110
      __o1___1->maybe_empty_object = 1U;
    }
#line 110
    if (sizeof(int ) < sizeof(void *)) {
#line 110
      tmp___12 = __o1___1->object_base;
    } else {
#line 110
      tmp___12 = (char *)0;
    }
#line 110
    if (sizeof(int ) < sizeof(void *)) {
#line 110
      tmp___13 = __o1___1->object_base;
    } else {
#line 110
      tmp___13 = (char *)0;
    }
#line 110
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 110
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 110
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 110
    __o1___1->object_base = __o1___1->next_free;
#line 110
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 110
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 110
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 110
    rpl_sprintf(buf___4, "%s_max", name);
#line 110
    __o___8 = & format_obstack;
#line 110
    tmp___14 = strlen((char const   *)(buf___4));
#line 110
    __len___4 = (int )tmp___14;
    }
#line 110
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 110
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 110
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 110
    __o___8->next_free += __len___4;
    }
#line 110
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 110
  __o___9 = & format_obstack;
#line 110
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 110
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 110
  tmp___15 = __o___9->next_free;
#line 110
  (__o___9->next_free) ++;
#line 110
  *tmp___15 = (char)0;
  {
#line 110
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 110
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 110
      rpl_sprintf(buf___5, "%ld", lmax);
#line 110
      __o___10 = & muscle_obstack;
#line 110
      tmp___16 = strlen((char const   *)(buf___5));
#line 110
      __len___5 = (int )tmp___16;
      }
#line 110
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 110
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 110
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 110
      __o___10->next_free += __len___5;
      }
#line 110
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 110
    __o___11 = & muscle_obstack;
#line 110
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 110
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 110
    tmp___17 = __o___11->next_free;
#line 110
    (__o___11->next_free) ++;
#line 110
    *tmp___17 = (char)0;
#line 110
    __o1___2 = & muscle_obstack;
#line 110
    __value___2 = (void *)__o1___2->object_base;
#line 110
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 110
      __o1___2->maybe_empty_object = 1U;
    }
#line 110
    if (sizeof(int ) < sizeof(void *)) {
#line 110
      tmp___18 = __o1___2->object_base;
    } else {
#line 110
      tmp___18 = (char *)0;
    }
#line 110
    if (sizeof(int ) < sizeof(void *)) {
#line 110
      tmp___19 = __o1___2->object_base;
    } else {
#line 110
      tmp___19 = (char *)0;
    }
#line 110
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 110
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 110
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 110
    __o1___2->object_base = __o1___2->next_free;
#line 110
    __o1___3 = & format_obstack;
#line 110
    __value___3 = (void *)__o1___3->object_base;
#line 110
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 110
      __o1___3->maybe_empty_object = 1U;
    }
#line 110
    if (sizeof(int ) < sizeof(void *)) {
#line 110
      tmp___20 = __o1___3->object_base;
    } else {
#line 110
      tmp___20 = (char *)0;
    }
#line 110
    if (sizeof(int ) < sizeof(void *)) {
#line 110
      tmp___21 = __o1___3->object_base;
    } else {
#line 110
      tmp___21 = (char *)0;
    }
#line 110
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 110
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 110
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 110
    __o1___3->object_base = __o1___3->next_free;
#line 110
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 110
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 117 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void escaped_output(FILE *out , char const   *string ) 
{ 
  char const   *p ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 121
  rpl_fprintf(out, "[[");
#line 123
  tmp = quotearg_style((enum quoting_style )3, string);
#line 123
  p = (char const   *)tmp;
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! *p) {
#line 123
      goto while_break;
    }
    {
#line 126
    if ((int const   )*p == 36) {
#line 126
      goto case_36;
    }
#line 127
    if ((int const   )*p == 64) {
#line 127
      goto case_64;
    }
#line 128
    if ((int const   )*p == 91) {
#line 128
      goto case_91;
    }
#line 129
    if ((int const   )*p == 93) {
#line 129
      goto case_93;
    }
#line 130
    goto switch_default;
    case_36: /* CIL Label */ 
    {
#line 126
    fputs_unlocked((char const   */* __restrict  */)"$][", (FILE */* __restrict  */)out);
    }
#line 126
    goto switch_break;
    case_64: /* CIL Label */ 
    {
#line 127
    fputs_unlocked((char const   */* __restrict  */)"@@", (FILE */* __restrict  */)out);
    }
#line 127
    goto switch_break;
    case_91: /* CIL Label */ 
    {
#line 128
    fputs_unlocked((char const   */* __restrict  */)"@{", (FILE */* __restrict  */)out);
    }
#line 128
    goto switch_break;
    case_93: /* CIL Label */ 
    {
#line 129
    fputs_unlocked((char const   */* __restrict  */)"@}", (FILE */* __restrict  */)out);
    }
#line 129
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 130
    fputc_unlocked((int )*p, out);
    }
#line 130
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 123
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  rpl_fprintf(out, "]]");
  }
#line 134
  return;
}
}
#line 142 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void prepare_symbols(void) 
{ 
  int v ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___3 ;
  struct obstack *__o___2 ;
  char *tmp___4 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char buf___2[4096] ;
  struct obstack *__o___3 ;
  int __len___1 ;
  size_t tmp___7 ;
  struct obstack *__o___4 ;
  char *tmp___8 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char buf___3[4096] ;
  struct obstack *__o___5 ;
  int __len___2 ;
  size_t tmp___11 ;
  struct obstack *__o___6 ;
  char *tmp___12 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char buf___4[4096] ;
  struct obstack *__o___7 ;
  int __len___3 ;
  size_t tmp___15 ;
  struct obstack *__o___8 ;
  char *tmp___16 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int i ;
  int j ;
  struct quoting_options *qo ;
  struct quoting_options *tmp___19 ;
  char *cp ;
  char *tmp___20 ;
  int width___0 ;
  size_t tmp___21 ;
  struct obstack *__o___9 ;
  int __len___4 ;
  size_t tmp___22 ;
  struct obstack *__o___10 ;
  char *tmp___23 ;
  char const   *p ;
  struct obstack *__o___11 ;
  int __len___5 ;
  size_t tmp___24 ;
  struct obstack *__o___12 ;
  int __len___6 ;
  size_t tmp___25 ;
  struct obstack *__o___13 ;
  int __len___7 ;
  size_t tmp___26 ;
  struct obstack *__o___14 ;
  int __len___8 ;
  size_t tmp___27 ;
  struct obstack *__o___15 ;
  char *tmp___28 ;
  struct obstack *__o___16 ;
  char *tmp___29 ;
  struct obstack *__o___17 ;
  int __len___9 ;
  size_t tmp___30 ;
  struct obstack *__o___18 ;
  char *tmp___31 ;
  struct obstack *__o1___4 ;
  void *__value___4 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int i___0 ;
  int *values___0 ;
  void *tmp___34 ;
  void *__cil_tmp94 ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  void *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    v = (int )token_table_flag;
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 145
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 145
        rpl_sprintf(buf___0, "%d", v);
#line 145
        __o = & muscle_obstack;
#line 145
        tmp = strlen((char const   *)(buf___0));
#line 145
        __len = (int )tmp;
        }
#line 145
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 145
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 145
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
               (size_t )__len);
#line 145
        __o->next_free += __len;
        }
#line 145
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 145
      __o___0 = & muscle_obstack;
#line 145
      if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
        {
#line 145
        _obstack_newchunk(__o___0, 1);
        }
      }
#line 145
      tmp___0 = __o___0->next_free;
#line 145
      (__o___0->next_free) ++;
#line 145
      *tmp___0 = (char)0;
#line 145
      __o1 = & muscle_obstack;
#line 145
      __value = (void *)__o1->object_base;
#line 145
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 145
        __o1->maybe_empty_object = 1U;
      }
#line 145
      if (sizeof(int ) < sizeof(void *)) {
#line 145
        tmp___1 = __o1->object_base;
      } else {
#line 145
        tmp___1 = (char *)0;
      }
#line 145
      if (sizeof(int ) < sizeof(void *)) {
#line 145
        tmp___2 = __o1->object_base;
      } else {
#line 145
        tmp___2 = (char *)0;
      }
#line 145
      __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 145
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 145
        __o1->next_free = __o1->chunk_limit;
      }
      {
#line 145
      __o1->object_base = __o1->next_free;
#line 145
      muscle_insert("token_table", (char const   *)__value);
      }
#line 145
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 146
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 146
      rpl_sprintf(buf___1, "%d", ntokens);
#line 146
      __o___1 = & muscle_obstack;
#line 146
      tmp___3 = strlen((char const   *)(buf___1));
#line 146
      __len___0 = (int )tmp___3;
      }
#line 146
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 146
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 146
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 146
      __o___1->next_free += __len___0;
      }
#line 146
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 146
    __o___2 = & muscle_obstack;
#line 146
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 146
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 146
    tmp___4 = __o___2->next_free;
#line 146
    (__o___2->next_free) ++;
#line 146
    *tmp___4 = (char)0;
#line 146
    __o1___0 = & muscle_obstack;
#line 146
    __value___0 = (void *)__o1___0->object_base;
#line 146
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 146
      __o1___0->maybe_empty_object = 1U;
    }
#line 146
    if (sizeof(int ) < sizeof(void *)) {
#line 146
      tmp___5 = __o1___0->object_base;
    } else {
#line 146
      tmp___5 = (char *)0;
    }
#line 146
    if (sizeof(int ) < sizeof(void *)) {
#line 146
      tmp___6 = __o1___0->object_base;
    } else {
#line 146
      tmp___6 = (char *)0;
    }
#line 146
    __o1___0->next_free = tmp___5 + (((__o1___0->next_free - tmp___6) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 146
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 146
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 146
    __o1___0->object_base = __o1___0->next_free;
#line 146
    muscle_insert("tokens_number", (char const   *)__value___0);
    }
#line 146
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 147
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 147
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 147
      rpl_sprintf(buf___2, "%d", nvars);
#line 147
      __o___3 = & muscle_obstack;
#line 147
      tmp___7 = strlen((char const   *)(buf___2));
#line 147
      __len___1 = (int )tmp___7;
      }
#line 147
      if ((unsigned long )(__o___3->next_free + __len___1) > (unsigned long )__o___3->chunk_limit) {
        {
#line 147
        _obstack_newchunk(__o___3, __len___1);
        }
      }
      {
#line 147
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___2),
             (size_t )__len___1);
#line 147
      __o___3->next_free += __len___1;
      }
#line 147
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 147
    __o___4 = & muscle_obstack;
#line 147
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 147
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 147
    tmp___8 = __o___4->next_free;
#line 147
    (__o___4->next_free) ++;
#line 147
    *tmp___8 = (char)0;
#line 147
    __o1___1 = & muscle_obstack;
#line 147
    __value___1 = (void *)__o1___1->object_base;
#line 147
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 147
      __o1___1->maybe_empty_object = 1U;
    }
#line 147
    if (sizeof(int ) < sizeof(void *)) {
#line 147
      tmp___9 = __o1___1->object_base;
    } else {
#line 147
      tmp___9 = (char *)0;
    }
#line 147
    if (sizeof(int ) < sizeof(void *)) {
#line 147
      tmp___10 = __o1___1->object_base;
    } else {
#line 147
      tmp___10 = (char *)0;
    }
#line 147
    __o1___1->next_free = tmp___9 + (((__o1___1->next_free - tmp___10) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 147
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 147
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 147
    __o1___1->object_base = __o1___1->next_free;
#line 147
    muscle_insert("nterms_number", (char const   *)__value___1);
    }
#line 147
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 148
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 148
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 148
      rpl_sprintf(buf___3, "%d", undeftoken->number);
#line 148
      __o___5 = & muscle_obstack;
#line 148
      tmp___11 = strlen((char const   *)(buf___3));
#line 148
      __len___2 = (int )tmp___11;
      }
#line 148
      if ((unsigned long )(__o___5->next_free + __len___2) > (unsigned long )__o___5->chunk_limit) {
        {
#line 148
        _obstack_newchunk(__o___5, __len___2);
        }
      }
      {
#line 148
      memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___2);
#line 148
      __o___5->next_free += __len___2;
      }
#line 148
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 148
    __o___6 = & muscle_obstack;
#line 148
    if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
      {
#line 148
      _obstack_newchunk(__o___6, 1);
      }
    }
#line 148
    tmp___12 = __o___6->next_free;
#line 148
    (__o___6->next_free) ++;
#line 148
    *tmp___12 = (char)0;
#line 148
    __o1___2 = & muscle_obstack;
#line 148
    __value___2 = (void *)__o1___2->object_base;
#line 148
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 148
      __o1___2->maybe_empty_object = 1U;
    }
#line 148
    if (sizeof(int ) < sizeof(void *)) {
#line 148
      tmp___13 = __o1___2->object_base;
    } else {
#line 148
      tmp___13 = (char *)0;
    }
#line 148
    if (sizeof(int ) < sizeof(void *)) {
#line 148
      tmp___14 = __o1___2->object_base;
    } else {
#line 148
      tmp___14 = (char *)0;
    }
#line 148
    __o1___2->next_free = tmp___13 + (((__o1___2->next_free - tmp___14) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 148
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 148
      __o1___2->next_free = __o1___2->chunk_limit;
    }
    {
#line 148
    __o1___2->object_base = __o1___2->next_free;
#line 148
    muscle_insert("undef_token_number", (char const   *)__value___2);
    }
#line 148
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 149
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 149
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 149
      rpl_sprintf(buf___4, "%d", max_user_token_number);
#line 149
      __o___7 = & muscle_obstack;
#line 149
      tmp___15 = strlen((char const   *)(buf___4));
#line 149
      __len___3 = (int )tmp___15;
      }
#line 149
      if ((unsigned long )(__o___7->next_free + __len___3) > (unsigned long )__o___7->chunk_limit) {
        {
#line 149
        _obstack_newchunk(__o___7, __len___3);
        }
      }
      {
#line 149
      memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)(buf___4),
             (size_t )__len___3);
#line 149
      __o___7->next_free += __len___3;
      }
#line 149
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 149
    __o___8 = & muscle_obstack;
#line 149
    if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
      {
#line 149
      _obstack_newchunk(__o___8, 1);
      }
    }
#line 149
    tmp___16 = __o___8->next_free;
#line 149
    (__o___8->next_free) ++;
#line 149
    *tmp___16 = (char)0;
#line 149
    __o1___3 = & muscle_obstack;
#line 149
    __value___3 = (void *)__o1___3->object_base;
#line 149
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 149
      __o1___3->maybe_empty_object = 1U;
    }
#line 149
    if (sizeof(int ) < sizeof(void *)) {
#line 149
      tmp___17 = __o1___3->object_base;
    } else {
#line 149
      tmp___17 = (char *)0;
    }
#line 149
    if (sizeof(int ) < sizeof(void *)) {
#line 149
      tmp___18 = __o1___3->object_base;
    } else {
#line 149
      tmp___18 = (char *)0;
    }
#line 149
    __o1___3->next_free = tmp___17 + (((__o1___3->next_free - tmp___18) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 149
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 149
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 149
    __o1___3->object_base = __o1___3->next_free;
#line 149
    muscle_insert("user_token_number_max", (char const   *)__value___3);
    }
#line 149
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 151
  muscle_insert_symbol_number_table("translate", token_translations, *(token_translations + 0),
                                    1, max_user_token_number + 1);
#line 160
  j = 2;
#line 161
  tmp___19 = clone_quoting_options((struct quoting_options *)0);
#line 161
  qo = tmp___19;
#line 162
  set_quoting_style(qo, (enum quoting_style )3);
#line 163
  set_quoting_flags(qo, 4);
#line 164
  i = 0;
  }
  {
#line 164
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 164
    if (! (i < nsyms)) {
#line 164
      goto while_break___10;
    }
    {
#line 166
    tmp___20 = quotearg_alloc((*(symbols + i))->tag, (size_t )-1, (struct quoting_options  const  *)qo);
#line 166
    cp = tmp___20;
#line 169
    tmp___21 = strlen((char const   *)cp);
#line 169
    width___0 = (int )(tmp___21 + 2U);
    }
#line 171
    if (j + width___0 > 75) {
      {
#line 173
      __o___9 = & format_obstack;
#line 173
      tmp___22 = strlen("\n ");
#line 173
      __len___4 = (int )tmp___22;
      }
#line 173
      if ((unsigned long )(__o___9->next_free + __len___4) > (unsigned long )__o___9->chunk_limit) {
        {
#line 173
        _obstack_newchunk(__o___9, __len___4);
        }
      }
      {
#line 173
      memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)"\n ",
             (size_t )__len___4);
#line 173
      __o___9->next_free += __len___4;
#line 174
      j = 1;
      }
    }
#line 177
    if (i) {
#line 178
      __o___10 = & format_obstack;
#line 178
      if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
        {
#line 178
        _obstack_newchunk(__o___10, 1);
        }
      }
#line 178
      tmp___23 = __o___10->next_free;
#line 178
      (__o___10->next_free) ++;
#line 178
      *tmp___23 = (char )' ';
    }
    {
#line 179
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 179
      p = (char const   *)cp;
      {
#line 179
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 179
        if (! *p) {
#line 179
          goto while_break___12;
        }
        {
#line 179
        if ((int const   )*p == 36) {
#line 179
          goto case_36;
        }
#line 179
        if ((int const   )*p == 64) {
#line 179
          goto case_64;
        }
#line 179
        if ((int const   )*p == 91) {
#line 179
          goto case_91;
        }
#line 179
        if ((int const   )*p == 93) {
#line 179
          goto case_93;
        }
#line 179
        goto switch_default;
        case_36: /* CIL Label */ 
        {
#line 179
        __o___11 = & format_obstack;
#line 179
        tmp___24 = strlen("$][");
#line 179
        __len___5 = (int )tmp___24;
        }
#line 179
        if ((unsigned long )(__o___11->next_free + __len___5) > (unsigned long )__o___11->chunk_limit) {
          {
#line 179
          _obstack_newchunk(__o___11, __len___5);
          }
        }
        {
#line 179
        memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___5);
#line 179
        __o___11->next_free += __len___5;
        }
#line 179
        goto switch_break;
        case_64: /* CIL Label */ 
        {
#line 179
        __o___12 = & format_obstack;
#line 179
        tmp___25 = strlen("@@");
#line 179
        __len___6 = (int )tmp___25;
        }
#line 179
        if ((unsigned long )(__o___12->next_free + __len___6) > (unsigned long )__o___12->chunk_limit) {
          {
#line 179
          _obstack_newchunk(__o___12, __len___6);
          }
        }
        {
#line 179
        memcpy((void */* __restrict  */)__o___12->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___6);
#line 179
        __o___12->next_free += __len___6;
        }
#line 179
        goto switch_break;
        case_91: /* CIL Label */ 
        {
#line 179
        __o___13 = & format_obstack;
#line 179
        tmp___26 = strlen("@{");
#line 179
        __len___7 = (int )tmp___26;
        }
#line 179
        if ((unsigned long )(__o___13->next_free + __len___7) > (unsigned long )__o___13->chunk_limit) {
          {
#line 179
          _obstack_newchunk(__o___13, __len___7);
          }
        }
        {
#line 179
        memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___7);
#line 179
        __o___13->next_free += __len___7;
        }
#line 179
        goto switch_break;
        case_93: /* CIL Label */ 
        {
#line 179
        __o___14 = & format_obstack;
#line 179
        tmp___27 = strlen("@}");
#line 179
        __len___8 = (int )tmp___27;
        }
#line 179
        if ((unsigned long )(__o___14->next_free + __len___8) > (unsigned long )__o___14->chunk_limit) {
          {
#line 179
          _obstack_newchunk(__o___14, __len___8);
          }
        }
        {
#line 179
        memcpy((void */* __restrict  */)__o___14->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___8);
#line 179
        __o___14->next_free += __len___8;
        }
#line 179
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 179
        __o___15 = & format_obstack;
#line 179
        if ((unsigned long )(__o___15->next_free + 1) > (unsigned long )__o___15->chunk_limit) {
          {
#line 179
          _obstack_newchunk(__o___15, 1);
          }
        }
#line 179
        tmp___28 = __o___15->next_free;
#line 179
        (__o___15->next_free) ++;
#line 179
        *tmp___28 = (char )*p;
#line 179
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 179
        p ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 179
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 180
    free((void *)cp);
#line 181
    __o___16 = & format_obstack;
    }
#line 181
    if ((unsigned long )(__o___16->next_free + 1) > (unsigned long )__o___16->chunk_limit) {
      {
#line 181
      _obstack_newchunk(__o___16, 1);
      }
    }
#line 181
    tmp___29 = __o___16->next_free;
#line 181
    (__o___16->next_free) ++;
#line 181
    *tmp___29 = (char )',';
#line 182
    j += width___0;
#line 164
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 184
  free((void *)qo);
#line 185
  __o___17 = & format_obstack;
#line 185
  tmp___30 = strlen(" ]b4_null[");
#line 185
  __len___9 = (int )tmp___30;
  }
#line 185
  if ((unsigned long )(__o___17->next_free + __len___9) > (unsigned long )__o___17->chunk_limit) {
    {
#line 185
    _obstack_newchunk(__o___17, __len___9);
    }
  }
  {
#line 185
  memcpy((void */* __restrict  */)__o___17->next_free, (void const   */* __restrict  */)" ]b4_null[",
         (size_t )__len___9);
#line 185
  __o___17->next_free += __len___9;
#line 188
  __o___18 = & format_obstack;
  }
#line 188
  if ((unsigned long )(__o___18->next_free + 1) > (unsigned long )__o___18->chunk_limit) {
    {
#line 188
    _obstack_newchunk(__o___18, 1);
    }
  }
#line 188
  tmp___31 = __o___18->next_free;
#line 188
  (__o___18->next_free) ++;
#line 188
  *tmp___31 = (char)0;
#line 189
  __o1___4 = & format_obstack;
#line 189
  __value___4 = (void *)__o1___4->object_base;
#line 189
  if ((unsigned long )__o1___4->next_free == (unsigned long )__value___4) {
#line 189
    __o1___4->maybe_empty_object = 1U;
  }
#line 189
  if (sizeof(int ) < sizeof(void *)) {
#line 189
    tmp___32 = __o1___4->object_base;
  } else {
#line 189
    tmp___32 = (char *)0;
  }
#line 189
  if (sizeof(int ) < sizeof(void *)) {
#line 189
    tmp___33 = __o1___4->object_base;
  } else {
#line 189
    tmp___33 = (char *)0;
  }
#line 189
  __o1___4->next_free = tmp___32 + (((__o1___4->next_free - tmp___33) + (long )__o1___4->alignment_mask) & (long )(~ __o1___4->alignment_mask));
#line 189
  if (__o1___4->next_free - (char *)__o1___4->chunk > __o1___4->chunk_limit - (char *)__o1___4->chunk) {
#line 189
    __o1___4->next_free = __o1___4->chunk_limit;
  }
  {
#line 189
  __o1___4->object_base = __o1___4->next_free;
#line 189
  muscle_insert("tname", (char const   *)__value___4);
#line 195
  tmp___34 = xnmalloc((size_t )ntokens, (size_t )sizeof(*values___0));
#line 195
  values___0 = (int *)tmp___34;
#line 196
  i___0 = 0;
  }
  {
#line 196
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 196
    if (! (i___0 < ntokens)) {
#line 196
      goto while_break___13;
    }
#line 197
    *(values___0 + i___0) = (*(symbols + i___0))->user_token_number;
#line 196
    i___0 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 198
  muscle_insert_int_table("toknum", values___0, *(values___0 + 0), 1, ntokens);
#line 200
  free((void *)values___0);
  }
#line 202
  return;
}
}
#line 210 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void prepare_rules(void) 
{ 
  rule_number r ;
  unsigned int i ;
  item_number *rhs ;
  void *tmp ;
  unsigned int *prhs ;
  void *tmp___0 ;
  unsigned int *rline ;
  void *tmp___1 ;
  symbol_number *r1 ;
  void *tmp___2 ;
  unsigned int *r2 ;
  void *tmp___3 ;
  int *dprec ;
  void *tmp___4 ;
  int *merger ;
  void *tmp___5 ;
  item_number *rhsp ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___8 ;
  struct obstack *__o___0 ;
  char *tmp___9 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___10 ;
  char *tmp___11 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___12 ;
  struct obstack *__o___2 ;
  char *tmp___13 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___14 ;
  char *tmp___15 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
  {
#line 214
  i = 0U;
#line 215
  tmp = xnmalloc(nritems, (size_t )sizeof(*rhs));
#line 215
  rhs = (item_number *)tmp;
#line 216
  tmp___0 = xnmalloc((size_t )nrules, (size_t )sizeof(*prhs));
#line 216
  prhs = (unsigned int *)tmp___0;
#line 217
  tmp___1 = xnmalloc((size_t )nrules, (size_t )sizeof(*rline));
#line 217
  rline = (unsigned int *)tmp___1;
#line 218
  tmp___2 = xnmalloc((size_t )nrules, (size_t )sizeof(*r1));
#line 218
  r1 = (symbol_number *)tmp___2;
#line 219
  tmp___3 = xnmalloc((size_t )nrules, (size_t )sizeof(*r2));
#line 219
  r2 = (unsigned int *)tmp___3;
#line 220
  tmp___4 = xnmalloc((size_t )nrules, (size_t )sizeof(*dprec));
#line 220
  dprec = (int *)tmp___4;
#line 221
  tmp___5 = xnmalloc((size_t )nrules, (size_t )sizeof(*merger));
#line 221
  merger = (int *)tmp___5;
#line 223
  r = 0;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (r < nrules)) {
#line 223
      goto while_break;
    }
#line 225
    rhsp = (item_number *)((void *)0);
#line 227
    *(prhs + r) = i;
#line 229
    rhsp = (rules + r)->rhs;
    {
#line 229
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 229
      if (! (*rhsp >= 0)) {
#line 229
        goto while_break___0;
      }
#line 230
      tmp___6 = i;
#line 230
      i ++;
#line 230
      *(rhs + tmp___6) = *rhsp;
#line 229
      rhsp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 232
    *(r1 + r) = ((rules + r)->lhs)->number;
#line 234
    *(r2 + r) = i - *(prhs + r);
#line 236
    tmp___7 = i;
#line 236
    i ++;
#line 236
    *(rhs + tmp___7) = -1;
#line 238
    *(rline + r) = (unsigned int )(rules + r)->location.start.line;
#line 240
    *(dprec + r) = (rules + r)->dprec;
#line 242
    *(merger + r) = (rules + r)->merger;
#line 223
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  if (! (i == nritems)) {
    {
#line 244
    __assert_fail("i == nritems", "/home/pronto/abs/test-suite/bison-2.5/src/output.c",
                  244U, "prepare_rules");
    }
  }
  {
#line 246
  muscle_insert_item_number_table("rhs", rhs, *(ritem + 0), 1, (int )nritems);
#line 247
  muscle_insert_unsigned_int_table("prhs", prhs, 0U, 0, nrules);
#line 248
  muscle_insert_unsigned_int_table("rline", rline, 0U, 0, nrules);
#line 249
  muscle_insert_symbol_number_table("r1", r1, 0, 0, nrules);
#line 250
  muscle_insert_unsigned_int_table("r2", r2, 0U, 0, nrules);
#line 251
  muscle_insert_int_table("dprec", dprec, 0, 0, nrules);
#line 252
  muscle_insert_int_table("merger", merger, 0, 0, nrules);
  }
  {
#line 254
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 254
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 254
      rpl_sprintf(buf___0, "%d", nrules);
#line 254
      __o = & muscle_obstack;
#line 254
      tmp___8 = strlen((char const   *)(buf___0));
#line 254
      __len = (int )tmp___8;
      }
#line 254
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 254
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 254
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len);
#line 254
      __o->next_free += __len;
      }
#line 254
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 254
    __o___0 = & muscle_obstack;
#line 254
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 254
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 254
    tmp___9 = __o___0->next_free;
#line 254
    (__o___0->next_free) ++;
#line 254
    *tmp___9 = (char)0;
#line 254
    __o1 = & muscle_obstack;
#line 254
    __value = (void *)__o1->object_base;
#line 254
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 254
      __o1->maybe_empty_object = 1U;
    }
#line 254
    if (sizeof(int ) < sizeof(void *)) {
#line 254
      tmp___10 = __o1->object_base;
    } else {
#line 254
      tmp___10 = (char *)0;
    }
#line 254
    if (sizeof(int ) < sizeof(void *)) {
#line 254
      tmp___11 = __o1->object_base;
    } else {
#line 254
      tmp___11 = (char *)0;
    }
#line 254
    __o1->next_free = tmp___10 + (((__o1->next_free - tmp___11) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 254
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 254
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 254
    __o1->object_base = __o1->next_free;
#line 254
    muscle_insert("rules_number", (char const   *)__value);
    }
#line 254
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 255
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 255
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 255
      rpl_sprintf(buf___1, "%d", max_left_semantic_context);
#line 255
      __o___1 = & muscle_obstack;
#line 255
      tmp___12 = strlen((char const   *)(buf___1));
#line 255
      __len___0 = (int )tmp___12;
      }
#line 255
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 255
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 255
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 255
      __o___1->next_free += __len___0;
      }
#line 255
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 255
    __o___2 = & muscle_obstack;
#line 255
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 255
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 255
    tmp___13 = __o___2->next_free;
#line 255
    (__o___2->next_free) ++;
#line 255
    *tmp___13 = (char)0;
#line 255
    __o1___0 = & muscle_obstack;
#line 255
    __value___0 = (void *)__o1___0->object_base;
#line 255
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 255
      __o1___0->maybe_empty_object = 1U;
    }
#line 255
    if (sizeof(int ) < sizeof(void *)) {
#line 255
      tmp___14 = __o1___0->object_base;
    } else {
#line 255
      tmp___14 = (char *)0;
    }
#line 255
    if (sizeof(int ) < sizeof(void *)) {
#line 255
      tmp___15 = __o1___0->object_base;
    } else {
#line 255
      tmp___15 = (char *)0;
    }
#line 255
    __o1___0->next_free = tmp___14 + (((__o1___0->next_free - tmp___15) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 255
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 255
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 255
    __o1___0->object_base = __o1___0->next_free;
#line 255
    muscle_insert("max_left_semantic_context", (char const   *)__value___0);
    }
#line 255
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 257
  free((void *)rhs);
#line 258
  free((void *)prhs);
#line 259
  free((void *)rline);
#line 260
  free((void *)r1);
#line 261
  free((void *)r2);
#line 262
  free((void *)dprec);
#line 263
  free((void *)merger);
  }
#line 264
  return;
}
}
#line 270 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void prepare_states(void) 
{ 
  state_number i ;
  symbol_number *values___0 ;
  void *tmp ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  struct obstack *__o___0 ;
  char *tmp___1 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___4 ;
  struct obstack *__o___2 ;
  char *tmp___5 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char buf___2[4096] ;
  struct obstack *__o___3 ;
  int __len___1 ;
  size_t tmp___8 ;
  struct obstack *__o___4 ;
  char *tmp___9 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___10 ;
  char *tmp___11 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 274
  tmp = xnmalloc((size_t )nstates, (size_t )sizeof(*values___0));
#line 274
  values___0 = (symbol_number *)tmp;
#line 275
  i = 0;
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! (i < nstates)) {
#line 275
      goto while_break;
    }
#line 276
    *(values___0 + i) = (*(states + i))->accessing_symbol;
#line 275
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 277
  muscle_insert_symbol_number_table("stos", values___0, 0, 1, nstates);
#line 279
  free((void *)values___0);
  }
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 281
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 281
      rpl_sprintf(buf___0, "%d", high);
#line 281
      __o = & muscle_obstack;
#line 281
      tmp___0 = strlen((char const   *)(buf___0));
#line 281
      __len = (int )tmp___0;
      }
#line 281
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 281
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 281
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len);
#line 281
      __o->next_free += __len;
      }
#line 281
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 281
    __o___0 = & muscle_obstack;
#line 281
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 281
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 281
    tmp___1 = __o___0->next_free;
#line 281
    (__o___0->next_free) ++;
#line 281
    *tmp___1 = (char)0;
#line 281
    __o1 = & muscle_obstack;
#line 281
    __value = (void *)__o1->object_base;
#line 281
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 281
      __o1->maybe_empty_object = 1U;
    }
#line 281
    if (sizeof(int ) < sizeof(void *)) {
#line 281
      tmp___2 = __o1->object_base;
    } else {
#line 281
      tmp___2 = (char *)0;
    }
#line 281
    if (sizeof(int ) < sizeof(void *)) {
#line 281
      tmp___3 = __o1->object_base;
    } else {
#line 281
      tmp___3 = (char *)0;
    }
#line 281
    __o1->next_free = tmp___2 + (((__o1->next_free - tmp___3) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 281
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 281
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 281
    __o1->object_base = __o1->next_free;
#line 281
    muscle_insert("last", (char const   *)__value);
    }
#line 281
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 282
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 282
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 282
      rpl_sprintf(buf___1, "%d", final_state->number);
#line 282
      __o___1 = & muscle_obstack;
#line 282
      tmp___4 = strlen((char const   *)(buf___1));
#line 282
      __len___0 = (int )tmp___4;
      }
#line 282
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 282
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 282
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 282
      __o___1->next_free += __len___0;
      }
#line 282
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 282
    __o___2 = & muscle_obstack;
#line 282
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 282
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 282
    tmp___5 = __o___2->next_free;
#line 282
    (__o___2->next_free) ++;
#line 282
    *tmp___5 = (char)0;
#line 282
    __o1___0 = & muscle_obstack;
#line 282
    __value___0 = (void *)__o1___0->object_base;
#line 282
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 282
      __o1___0->maybe_empty_object = 1U;
    }
#line 282
    if (sizeof(int ) < sizeof(void *)) {
#line 282
      tmp___6 = __o1___0->object_base;
    } else {
#line 282
      tmp___6 = (char *)0;
    }
#line 282
    if (sizeof(int ) < sizeof(void *)) {
#line 282
      tmp___7 = __o1___0->object_base;
    } else {
#line 282
      tmp___7 = (char *)0;
    }
#line 282
    __o1___0->next_free = tmp___6 + (((__o1___0->next_free - tmp___7) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 282
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 282
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 282
    __o1___0->object_base = __o1___0->next_free;
#line 282
    muscle_insert("final_state_number", (char const   *)__value___0);
    }
#line 282
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 283
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 283
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 283
      rpl_sprintf(buf___2, "%d", nstates);
#line 283
      __o___3 = & muscle_obstack;
#line 283
      tmp___8 = strlen((char const   *)(buf___2));
#line 283
      __len___1 = (int )tmp___8;
      }
#line 283
      if ((unsigned long )(__o___3->next_free + __len___1) > (unsigned long )__o___3->chunk_limit) {
        {
#line 283
        _obstack_newchunk(__o___3, __len___1);
        }
      }
      {
#line 283
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___2),
             (size_t )__len___1);
#line 283
      __o___3->next_free += __len___1;
      }
#line 283
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 283
    __o___4 = & muscle_obstack;
#line 283
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 283
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 283
    tmp___9 = __o___4->next_free;
#line 283
    (__o___4->next_free) ++;
#line 283
    *tmp___9 = (char)0;
#line 283
    __o1___1 = & muscle_obstack;
#line 283
    __value___1 = (void *)__o1___1->object_base;
#line 283
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 283
      __o1___1->maybe_empty_object = 1U;
    }
#line 283
    if (sizeof(int ) < sizeof(void *)) {
#line 283
      tmp___10 = __o1___1->object_base;
    } else {
#line 283
      tmp___10 = (char *)0;
    }
#line 283
    if (sizeof(int ) < sizeof(void *)) {
#line 283
      tmp___11 = __o1___1->object_base;
    } else {
#line 283
      tmp___11 = (char *)0;
    }
#line 283
    __o1___1->next_free = tmp___10 + (((__o1___1->next_free - tmp___11) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 283
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 283
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 283
    __o1___1->object_base = __o1___1->next_free;
#line 283
    muscle_insert("states_number", (char const   *)__value___1);
    }
#line 283
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 284
  return;
}
}
#line 292 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void user_actions_output(FILE *out ) 
{ 
  rule_number r ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 297
  fputs_unlocked((char const   */* __restrict  */)"m4_define([b4_actions], \n[", (FILE */* __restrict  */)out);
#line 298
  r = 0;
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (r < nrules)) {
#line 298
      goto while_break;
    }
#line 299
    if ((rules + r)->action) {
      {
#line 301
      rpl_fprintf(out, "b4_case(%d, [b4_syncline(%d, ", r + 1, (rules + r)->action_location.start.line);
#line 303
      escaped_output(out, (rules + r)->action_location.start.file);
#line 304
      rpl_fprintf(out, ")\n[    %s]])\n\n", (rules + r)->action);
      }
    }
#line 298
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 306
  fputs_unlocked((char const   */* __restrict  */)"])\n\n", (FILE */* __restrict  */)out);
  }
#line 307
  return;
}
}
#line 313 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void merger_output(FILE *out ) 
{ 
  int n ;
  merger_list *p ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 319
  fputs_unlocked((char const   */* __restrict  */)"m4_define([b4_mergers], \n[[",
                 (FILE */* __restrict  */)out);
#line 320
  n = 1;
#line 320
  p = merge_functions;
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 320
      goto while_break;
    }
#line 322
    if ((int const   )*(p->type + 0) == 0) {
      {
#line 323
      rpl_fprintf(out, "  case %d: *yy0 = %s (*yy0, *yy1); break;\n", n, p->name);
      }
    } else {
      {
#line 326
      rpl_fprintf(out, "  case %d: yy0->%s = %s (*yy0, *yy1); break;\n", n, p->type,
                  p->name);
      }
    }
#line 320
    n ++;
#line 320
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 329
  fputs_unlocked((char const   */* __restrict  */)"]])\n\n", (FILE */* __restrict  */)out);
  }
#line 330
  return;
}
}
#line 336 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void token_definitions_output(FILE *out ) 
{ 
  int i ;
  char const   *sep ;
  symbol *sym ;
  int number ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 340
  sep = "";
#line 342
  fputs_unlocked((char const   */* __restrict  */)"m4_define([b4_tokens], \n[", (FILE */* __restrict  */)out);
#line 343
  i = 0;
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (i < ntokens)) {
#line 343
      goto while_break;
    }
#line 345
    sym = *(symbols + i);
#line 346
    number = sym->user_token_number;
#line 351
    if (! (number != -9991)) {
      {
#line 351
      __assert_fail("number != -9991", "/home/pronto/abs/test-suite/bison-2.5/src/output.c",
                    351U, "token_definitions_output");
      }
    }
#line 354
    if ((unsigned long )sym == (unsigned long )errtoken) {
#line 355
      goto __Cont;
    }
#line 359
    if (sym->alias) {
#line 360
      sym = sym->alias;
    }
#line 365
    if ((int const   )*(sym->tag + 0) == 39) {
#line 366
      goto __Cont;
    } else
#line 365
    if ((int const   )*(sym->tag + 0) == 34) {
#line 366
      goto __Cont;
    }
    {
#line 370
    tmp = mbschr(sym->tag, '.');
    }
#line 370
    if (tmp) {
#line 373
      goto __Cont;
    } else {
      {
#line 370
      tmp___0 = mbschr(sym->tag, '-');
      }
#line 370
      if (tmp___0) {
#line 373
        goto __Cont;
      } else {
        {
#line 370
        tmp___1 = mbschr(sym->tag, '$');
        }
#line 370
        if (tmp___1) {
#line 373
          goto __Cont;
        }
      }
    }
    {
#line 375
    rpl_fprintf(out, "%s[[[%s]], %d]", sep, sym->tag, number);
#line 377
    sep = ",\n";
    }
    __Cont: /* CIL Label */ 
#line 343
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 379
  fputs_unlocked((char const   */* __restrict  */)"])\n\n", (FILE */* __restrict  */)out);
  }
#line 380
  return;
}
}
#line 387 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void symbol_code_props_output(FILE *out , char const   *what , code_props const   *(*get)(symbol const   * ) ) 
{ 
  int i ;
  char const   *sep ;
  symbol *sym ;
  char const   *code ;
  code_props const   *tmp ;
  location loc___0 ;
  code_props const   *tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 392
  sep = "";
#line 394
  fputs_unlocked((char const   */* __restrict  */)"m4_define([b4_symbol_", (FILE */* __restrict  */)out);
#line 395
  fputs_unlocked((char const   */* __restrict  */)what, (FILE */* __restrict  */)out);
#line 396
  fputs_unlocked((char const   */* __restrict  */)"], \n[", (FILE */* __restrict  */)out);
#line 397
  i = 0;
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! (i < nsyms)) {
#line 397
      goto while_break;
    }
    {
#line 399
    sym = *(symbols + i);
#line 400
    tmp = (*get)((symbol const   *)sym);
#line 400
    code = (char const   *)tmp->code;
    }
#line 401
    if (code) {
      {
#line 403
      tmp___0 = (*get)((symbol const   *)sym);
#line 403
      loc___0 = tmp___0->location;
#line 407
      rpl_fprintf(out, "%s[", sep);
#line 408
      sep = ",\n";
#line 409
      escaped_output(out, loc___0.start.file);
#line 410
      rpl_fprintf(out, ", %d, ", loc___0.start.line);
#line 411
      escaped_output(out, sym->tag);
#line 412
      rpl_fprintf(out, ", %d, [[%s]]", sym->number, code);
      }
#line 413
      if (sym->type_name) {
        {
#line 414
        rpl_fprintf(out, ", [[%s]]", sym->type_name);
        }
      }
      {
#line 415
      fputc_unlocked(']', out);
      }
    }
#line 397
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  fputs_unlocked((char const   */* __restrict  */)"])\n\n", (FILE */* __restrict  */)out);
  }
#line 419
  return;
}
}
#line 422 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void prepare_actions(void) 
{ 
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___3 ;
  struct obstack *__o___2 ;
  char *tmp___4 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 428
  muscle_insert_rule_number_table("defact", yydefact, *(yydefact + 0), 1, nstates);
#line 434
  muscle_insert_state_number_table("defgoto", yydefgoto, *(yydefgoto + 0), 1, nsyms - ntokens);
#line 439
  muscle_insert_base_table("pact", base, *(base + 0), 1, nstates);
  }
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 441
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 441
      rpl_sprintf(buf___0, "%d", base_ninf);
#line 441
      __o = & muscle_obstack;
#line 441
      tmp = strlen((char const   *)(buf___0));
#line 441
      __len = (int )tmp;
      }
#line 441
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 441
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 441
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len);
#line 441
      __o->next_free += __len;
      }
#line 441
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 441
    __o___0 = & muscle_obstack;
#line 441
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 441
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 441
    tmp___0 = __o___0->next_free;
#line 441
    (__o___0->next_free) ++;
#line 441
    *tmp___0 = (char)0;
#line 441
    __o1 = & muscle_obstack;
#line 441
    __value = (void *)__o1->object_base;
#line 441
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 441
      __o1->maybe_empty_object = 1U;
    }
#line 441
    if (sizeof(int ) < sizeof(void *)) {
#line 441
      tmp___1 = __o1->object_base;
    } else {
#line 441
      tmp___1 = (char *)0;
    }
#line 441
    if (sizeof(int ) < sizeof(void *)) {
#line 441
      tmp___2 = __o1->object_base;
    } else {
#line 441
      tmp___2 = (char *)0;
    }
#line 441
    __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 441
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 441
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 441
    __o1->object_base = __o1->next_free;
#line 441
    muscle_insert("pact_ninf", (char const   *)__value);
    }
#line 441
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  muscle_insert_base_table("pgoto", base, *(base + nstates), nstates + 1, nvectors);
#line 447
  muscle_insert_base_table("table", table, *(table + 0), 1, high + 1);
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 449
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 449
      rpl_sprintf(buf___1, "%d", table_ninf);
#line 449
      __o___1 = & muscle_obstack;
#line 449
      tmp___3 = strlen((char const   *)(buf___1));
#line 449
      __len___0 = (int )tmp___3;
      }
#line 449
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 449
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 449
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 449
      __o___1->next_free += __len___0;
      }
#line 449
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 449
    __o___2 = & muscle_obstack;
#line 449
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 449
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 449
    tmp___4 = __o___2->next_free;
#line 449
    (__o___2->next_free) ++;
#line 449
    *tmp___4 = (char)0;
#line 449
    __o1___0 = & muscle_obstack;
#line 449
    __value___0 = (void *)__o1___0->object_base;
#line 449
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 449
      __o1___0->maybe_empty_object = 1U;
    }
#line 449
    if (sizeof(int ) < sizeof(void *)) {
#line 449
      tmp___5 = __o1___0->object_base;
    } else {
#line 449
      tmp___5 = (char *)0;
    }
#line 449
    if (sizeof(int ) < sizeof(void *)) {
#line 449
      tmp___6 = __o1___0->object_base;
    } else {
#line 449
      tmp___6 = (char *)0;
    }
#line 449
    __o1___0->next_free = tmp___5 + (((__o1___0->next_free - tmp___6) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 449
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 449
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 449
    __o1___0->object_base = __o1___0->next_free;
#line 449
    muscle_insert("table_ninf", (char const   *)__value___0);
    }
#line 449
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 451
  muscle_insert_base_table("check", check, *(check + 0), 1, high + 1);
#line 463
  muscle_insert_unsigned_int_table("conflict_list_heads", conflict_table, *(conflict_table + 0),
                                   1, high + 1);
#line 465
  muscle_insert_unsigned_int_table("conflicting_rules", conflict_list, 0U, 1, conflict_list_cnt);
  }
#line 467
  return;
}
}
#line 473 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void muscles_output(FILE *out ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 476
  fputs_unlocked((char const   */* __restrict  */)"m4_init()\n", (FILE */* __restrict  */)out);
#line 478
  user_actions_output(out);
#line 479
  merger_output(out);
#line 480
  token_definitions_output(out);
#line 481
  symbol_code_props_output(out, "destructors", & symbol_destructor_get);
#line 482
  symbol_code_props_output(out, "printers", & symbol_printer_get);
#line 484
  muscles_m4_output(out);
  }
#line 485
  return;
}
}
#line 491 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void output_skeleton(void) 
{ 
  FILE *in ;
  int filter_fd[2] ;
  char const   *argv[10] ;
  pid_t pid ;
  char m4sugar[19] ;
  char m4bison[9] ;
  char *full_m4sugar ;
  char *full_m4bison ;
  char *full_skeleton ;
  char const   *p ;
  char const   *m4 ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *pkgdatadir ;
  char const   *tmp___2 ;
  size_t skeleton_size ;
  size_t tmp___3 ;
  size_t pkgdatadirlen ;
  size_t tmp___4 ;
  unsigned long tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  FILE *tmp___8 ;
  int i ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  FILE *out ;
  FILE *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
  {
#line 500
  m4sugar[0] = (char )'m';
#line 500
  m4sugar[1] = (char )'4';
#line 500
  m4sugar[2] = (char )'s';
#line 500
  m4sugar[3] = (char )'u';
#line 500
  m4sugar[4] = (char )'g';
#line 500
  m4sugar[5] = (char )'a';
#line 500
  m4sugar[6] = (char )'r';
#line 500
  m4sugar[7] = (char )'/';
#line 500
  m4sugar[8] = (char )'m';
#line 500
  m4sugar[9] = (char )'4';
#line 500
  m4sugar[10] = (char )'s';
#line 500
  m4sugar[11] = (char )'u';
#line 500
  m4sugar[12] = (char )'g';
#line 500
  m4sugar[13] = (char )'a';
#line 500
  m4sugar[14] = (char )'r';
#line 500
  m4sugar[15] = (char )'.';
#line 500
  m4sugar[16] = (char )'m';
#line 500
  m4sugar[17] = (char )'4';
#line 500
  m4sugar[18] = (char )'\000';
#line 501
  m4bison[0] = (char )'b';
#line 501
  m4bison[1] = (char )'i';
#line 501
  m4bison[2] = (char )'s';
#line 501
  m4bison[3] = (char )'o';
#line 501
  m4bison[4] = (char )'n';
#line 501
  m4bison[5] = (char )'.';
#line 501
  m4bison[6] = (char )'m';
#line 501
  m4bison[7] = (char )'4';
#line 501
  m4bison[8] = (char )'\000';
#line 506
  tmp___1 = getenv("M4");
#line 506
  p = (char const   *)tmp___1;
  }
#line 506
  if (p) {
#line 506
    tmp___0 = p;
  } else {
#line 506
    tmp___0 = "/usr/bin/m4";
  }
  {
#line 506
  m4 = tmp___0;
#line 507
  tmp___2 = compute_pkgdatadir();
#line 507
  pkgdatadir = tmp___2;
#line 508
  tmp___3 = strlen(skeleton);
#line 508
  skeleton_size = tmp___3 + 1U;
#line 509
  tmp___4 = strlen(pkgdatadir);
#line 509
  pkgdatadirlen = tmp___4;
  }
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (pkgdatadirlen) {
#line 510
      if (! ((int const   )*(pkgdatadir + (pkgdatadirlen - 1U)) == 47)) {
#line 510
        goto while_break;
      }
    } else {
#line 510
      goto while_break;
    }
#line 511
    pkgdatadirlen --;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  if ((unsigned long )skeleton_size < sizeof(m4sugar)) {
#line 512
    tmp___5 = sizeof(m4sugar);
  } else {
#line 512
    tmp___5 = (unsigned long )skeleton_size;
  }
  {
#line 512
  tmp___6 = xmalloc((size_t )((unsigned long )(pkgdatadirlen + 1U) + tmp___5));
#line 512
  full_skeleton = (char *)tmp___6;
#line 515
  strncpy((char */* __restrict  */)full_skeleton, (char const   */* __restrict  */)pkgdatadir,
          pkgdatadirlen);
#line 516
  *(full_skeleton + pkgdatadirlen) = (char )'/';
#line 517
  strcpy((char */* __restrict  */)((full_skeleton + pkgdatadirlen) + 1), (char const   */* __restrict  */)(m4sugar));
#line 518
  full_m4sugar = xstrdup((char const   *)full_skeleton);
#line 519
  strcpy((char */* __restrict  */)((full_skeleton + pkgdatadirlen) + 1), (char const   */* __restrict  */)(m4bison));
#line 520
  full_m4bison = xstrdup((char const   *)full_skeleton);
#line 521
  tmp___7 = mbschr(skeleton, '/');
  }
#line 521
  if (tmp___7) {
    {
#line 522
    strcpy((char */* __restrict  */)full_skeleton, (char const   */* __restrict  */)skeleton);
    }
  } else {
    {
#line 524
    strcpy((char */* __restrict  */)((full_skeleton + pkgdatadirlen) + 1), (char const   */* __restrict  */)skeleton);
    }
  }
  {
#line 529
  tmp___8 = xfopen((char const   *)full_m4sugar, "r");
#line 529
  xfclose(tmp___8);
  }
#line 533
  if (trace_flag & 32) {
    {
#line 534
    rpl_fprintf(stderr, "running: %s %s - %s %s\n", m4, full_m4sugar, full_m4bison,
                full_skeleton);
    }
  }
#line 545
  i = 0;
#line 546
  tmp___9 = i;
#line 546
  i ++;
#line 546
  argv[tmp___9] = m4;
#line 557
  if (*"") {
#line 558
    tmp___10 = i;
#line 558
    i ++;
#line 558
    argv[tmp___10] = "";
  }
#line 560
  tmp___11 = i;
#line 560
  i ++;
#line 560
  argv[tmp___11] = "-I";
#line 561
  tmp___12 = i;
#line 561
  i ++;
#line 561
  argv[tmp___12] = pkgdatadir;
#line 562
  if (trace_flag & 1024) {
#line 563
    tmp___13 = i;
#line 563
    i ++;
#line 563
    argv[tmp___13] = "-dV";
  }
#line 564
  tmp___14 = i;
#line 564
  i ++;
#line 564
  argv[tmp___14] = (char const   *)full_m4sugar;
#line 565
  tmp___15 = i;
#line 565
  i ++;
#line 565
  argv[tmp___15] = "-";
#line 566
  tmp___16 = i;
#line 566
  i ++;
#line 566
  argv[tmp___16] = (char const   *)full_m4bison;
#line 567
  tmp___17 = i;
#line 567
  i ++;
#line 567
  argv[tmp___17] = (char const   *)full_skeleton;
#line 568
  tmp___18 = i;
#line 568
  i ++;
#line 568
  argv[tmp___18] = (char const   *)((void *)0);
#line 569
  if (! ((unsigned long )i <= sizeof(argv) / sizeof(argv[0]))) {
    {
#line 569
    __assert_fail("i <= (sizeof (argv) / sizeof *(argv))", "/home/pronto/abs/test-suite/bison-2.5/src/output.c",
                  569U, "output_skeleton");
    }
  }
  {
#line 573
  pid = create_pipe_bidi("m4", m4, (char **)((void *)(argv)), (_Bool)0, (_Bool)1,
                         (_Bool)1, (int *)(filter_fd));
#line 575
  free((void *)full_m4sugar);
#line 576
  free((void *)full_m4bison);
#line 577
  free((void *)full_skeleton);
  }
#line 579
  if (trace_flag & 2048) {
    {
#line 580
    muscles_output(stderr);
    }
  }
  {
#line 582
  tmp___19 = fdopen(filter_fd[1], "w");
#line 582
  out = tmp___19;
  }
#line 583
  if (! out) {
    {
#line 584
    tmp___20 = get_errno();
#line 584
    error(1, tmp___20, "fdopen");
    }
  }
  {
#line 586
  muscles_output(out);
#line 587
  xfclose(out);
#line 591
  timevar_push((timevar_id_t )18);
#line 592
  in = fdopen(filter_fd[0], "r");
  }
#line 593
  if (! in) {
    {
#line 594
    tmp___21 = get_errno();
#line 594
    error(1, tmp___21, "fdopen");
    }
  }
  {
#line 596
  scan_skel(in);
#line 600
  tmp___22 = feof_unlocked(in);
  }
#line 600
  if (! tmp___22) {
    {
#line 600
    __assert_fail("feof_unlocked (in)", "/home/pronto/abs/test-suite/bison-2.5/src/output.c",
                  600U, "output_skeleton");
    }
  }
  {
#line 601
  xfclose(in);
#line 602
  wait_subprocess(pid, "m4", (_Bool)0, (_Bool)0, (_Bool)1, (_Bool)1, (int *)((void *)0));
#line 603
  timevar_pop((timevar_id_t )18);
  }
#line 604
  return;
}
}
#line 606 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
static void prepare(void) 
{ 
  char const   *use_push_for_pull_env ;
  char *tmp ;
  _Bool use_push_for_pull_flag ;
  int tmp___0 ;
  int v ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___1 ;
  struct obstack *__o___0 ;
  char *tmp___2 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___3 ;
  char *tmp___4 ;
  int v___0 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___5 ;
  struct obstack *__o___2 ;
  char *tmp___6 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int v___1 ;
  char buf___2[4096] ;
  struct obstack *__o___3 ;
  int __len___1 ;
  size_t tmp___9 ;
  struct obstack *__o___4 ;
  char *tmp___10 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int v___2 ;
  char buf___3[4096] ;
  struct obstack *__o___5 ;
  int __len___2 ;
  size_t tmp___13 ;
  struct obstack *__o___6 ;
  char *tmp___14 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int v___3 ;
  char buf___4[4096] ;
  struct obstack *__o___7 ;
  int __len___3 ;
  size_t tmp___17 ;
  struct obstack *__o___8 ;
  char *tmp___18 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int v___4 ;
  char buf___5[4096] ;
  struct obstack *__o___9 ;
  int __len___4 ;
  size_t tmp___21 ;
  struct obstack *__o___10 ;
  char *tmp___22 ;
  struct obstack *__o1___4 ;
  void *__value___4 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int v___5 ;
  char buf___6[4096] ;
  struct obstack *__o___11 ;
  int __len___5 ;
  size_t tmp___25 ;
  struct obstack *__o___12 ;
  char *tmp___26 ;
  struct obstack *__o1___5 ;
  void *__value___5 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int v___6 ;
  char buf___7[4096] ;
  struct obstack *__o___13 ;
  int __len___6 ;
  size_t tmp___29 ;
  struct obstack *__o___14 ;
  char *tmp___30 ;
  struct obstack *__o1___6 ;
  void *__value___6 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int v___7 ;
  char buf___8[4096] ;
  struct obstack *__o___15 ;
  int __len___7 ;
  size_t tmp___33 ;
  struct obstack *__o___16 ;
  char *tmp___34 ;
  struct obstack *__o1___7 ;
  void *__value___7 ;
  char *tmp___35 ;
  char *tmp___36 ;
  int v___8 ;
  char buf___9[4096] ;
  struct obstack *__o___17 ;
  int __len___8 ;
  size_t tmp___37 ;
  struct obstack *__o___18 ;
  char *tmp___38 ;
  struct obstack *__o1___8 ;
  void *__value___8 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char const   *p ;
  struct obstack *__o___19 ;
  int __len___9 ;
  size_t tmp___41 ;
  struct obstack *__o___20 ;
  int __len___10 ;
  size_t tmp___42 ;
  struct obstack *__o___21 ;
  int __len___11 ;
  size_t tmp___43 ;
  struct obstack *__o___22 ;
  int __len___12 ;
  size_t tmp___44 ;
  struct obstack *__o___23 ;
  char *tmp___45 ;
  struct obstack *__o___24 ;
  char *tmp___46 ;
  struct obstack *__o1___9 ;
  void *__value___9 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char const   *p___0 ;
  struct obstack *__o___25 ;
  int __len___13 ;
  size_t tmp___49 ;
  struct obstack *__o___26 ;
  int __len___14 ;
  size_t tmp___50 ;
  struct obstack *__o___27 ;
  int __len___15 ;
  size_t tmp___51 ;
  struct obstack *__o___28 ;
  int __len___16 ;
  size_t tmp___52 ;
  struct obstack *__o___29 ;
  char *tmp___53 ;
  struct obstack *__o___30 ;
  char *tmp___54 ;
  struct obstack *__o1___10 ;
  void *__value___10 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char const   *p___1 ;
  struct obstack *__o___31 ;
  int __len___17 ;
  size_t tmp___57 ;
  struct obstack *__o___32 ;
  int __len___18 ;
  size_t tmp___58 ;
  struct obstack *__o___33 ;
  int __len___19 ;
  size_t tmp___59 ;
  struct obstack *__o___34 ;
  int __len___20 ;
  size_t tmp___60 ;
  struct obstack *__o___35 ;
  char *tmp___61 ;
  struct obstack *__o___36 ;
  char *tmp___62 ;
  struct obstack *__o1___11 ;
  void *__value___11 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char const   *p___2 ;
  struct obstack *__o___37 ;
  int __len___21 ;
  size_t tmp___65 ;
  struct obstack *__o___38 ;
  int __len___22 ;
  size_t tmp___66 ;
  struct obstack *__o___39 ;
  int __len___23 ;
  size_t tmp___67 ;
  struct obstack *__o___40 ;
  int __len___24 ;
  size_t tmp___68 ;
  struct obstack *__o___41 ;
  char *tmp___69 ;
  struct obstack *__o___42 ;
  char *tmp___70 ;
  struct obstack *__o1___12 ;
  void *__value___12 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char const   *p___3 ;
  struct obstack *__o___43 ;
  int __len___25 ;
  size_t tmp___73 ;
  struct obstack *__o___44 ;
  int __len___26 ;
  size_t tmp___74 ;
  struct obstack *__o___45 ;
  int __len___27 ;
  size_t tmp___75 ;
  struct obstack *__o___46 ;
  int __len___28 ;
  size_t tmp___76 ;
  struct obstack *__o___47 ;
  char *tmp___77 ;
  struct obstack *__o___48 ;
  char *tmp___78 ;
  struct obstack *__o1___13 ;
  void *__value___13 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char const   *p___4 ;
  struct obstack *__o___49 ;
  int __len___29 ;
  size_t tmp___81 ;
  struct obstack *__o___50 ;
  int __len___30 ;
  size_t tmp___82 ;
  struct obstack *__o___51 ;
  int __len___31 ;
  size_t tmp___83 ;
  struct obstack *__o___52 ;
  int __len___32 ;
  size_t tmp___84 ;
  struct obstack *__o___53 ;
  char *tmp___85 ;
  struct obstack *__o___54 ;
  char *tmp___86 ;
  struct obstack *__o1___14 ;
  void *__value___14 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char const   *p___5 ;
  struct obstack *__o___55 ;
  int __len___33 ;
  size_t tmp___89 ;
  struct obstack *__o___56 ;
  int __len___34 ;
  size_t tmp___90 ;
  struct obstack *__o___57 ;
  int __len___35 ;
  size_t tmp___91 ;
  struct obstack *__o___58 ;
  int __len___36 ;
  size_t tmp___92 ;
  struct obstack *__o___59 ;
  char *tmp___93 ;
  struct obstack *__o___60 ;
  char *tmp___94 ;
  struct obstack *__o1___15 ;
  void *__value___15 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char const   *p___6 ;
  struct obstack *__o___61 ;
  int __len___37 ;
  size_t tmp___97 ;
  struct obstack *__o___62 ;
  int __len___38 ;
  size_t tmp___98 ;
  struct obstack *__o___63 ;
  int __len___39 ;
  size_t tmp___99 ;
  struct obstack *__o___64 ;
  int __len___40 ;
  size_t tmp___100 ;
  struct obstack *__o___65 ;
  char *tmp___101 ;
  struct obstack *__o___66 ;
  char *tmp___102 ;
  struct obstack *__o1___16 ;
  void *__value___16 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char const   *p___7 ;
  struct obstack *__o___67 ;
  int __len___41 ;
  size_t tmp___105 ;
  struct obstack *__o___68 ;
  int __len___42 ;
  size_t tmp___106 ;
  struct obstack *__o___69 ;
  int __len___43 ;
  size_t tmp___107 ;
  struct obstack *__o___70 ;
  int __len___44 ;
  size_t tmp___108 ;
  struct obstack *__o___71 ;
  char *tmp___109 ;
  struct obstack *__o___72 ;
  char *tmp___110 ;
  struct obstack *__o1___17 ;
  void *__value___17 ;
  char *tmp___111 ;
  char *tmp___112 ;
  char const   *p___8 ;
  struct obstack *__o___73 ;
  int __len___45 ;
  size_t tmp___113 ;
  struct obstack *__o___74 ;
  int __len___46 ;
  size_t tmp___114 ;
  struct obstack *__o___75 ;
  int __len___47 ;
  size_t tmp___115 ;
  struct obstack *__o___76 ;
  int __len___48 ;
  size_t tmp___116 ;
  struct obstack *__o___77 ;
  char *tmp___117 ;
  struct obstack *__o___78 ;
  char *tmp___118 ;
  struct obstack *__o1___18 ;
  void *__value___18 ;
  char *tmp___119 ;
  char *tmp___120 ;
  char const   *p___9 ;
  char *tmp___121 ;
  struct obstack *__o___79 ;
  int __len___49 ;
  size_t tmp___122 ;
  struct obstack *__o___80 ;
  int __len___50 ;
  size_t tmp___123 ;
  struct obstack *__o___81 ;
  int __len___51 ;
  size_t tmp___124 ;
  struct obstack *__o___82 ;
  int __len___52 ;
  size_t tmp___125 ;
  struct obstack *__o___83 ;
  char *tmp___126 ;
  struct obstack *__o___84 ;
  char *tmp___127 ;
  struct obstack *__o1___19 ;
  void *__value___19 ;
  char *tmp___128 ;
  char *tmp___129 ;
  struct obstack *__o___85 ;
  int __len___53 ;
  char const   *tmp___130 ;
  size_t tmp___131 ;
  char const   *tmp___132 ;
  struct obstack *__o___86 ;
  char *tmp___133 ;
  struct obstack *__o1___20 ;
  void *__value___20 ;
  char *tmp___134 ;
  char *tmp___135 ;
  void *__cil_tmp358 ;
  void *__cil_tmp359 ;
  void *__cil_tmp360 ;
  void *__cil_tmp361 ;
  void *__cil_tmp362 ;
  void *__cil_tmp363 ;
  void *__cil_tmp364 ;
  void *__cil_tmp365 ;
  void *__cil_tmp366 ;
  void *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;
  char *__cil_tmp402 ;
  char *__cil_tmp403 ;
  char *__cil_tmp404 ;
  char *__cil_tmp405 ;
  char *__cil_tmp406 ;
  char *__cil_tmp407 ;
  char *__cil_tmp408 ;
  char *__cil_tmp409 ;
  char *__cil_tmp410 ;
  char *__cil_tmp411 ;
  char *__cil_tmp412 ;
  char *__cil_tmp413 ;
  char *__cil_tmp414 ;
  char *__cil_tmp415 ;
  char *__cil_tmp416 ;
  char *__cil_tmp417 ;
  char *__cil_tmp418 ;
  char *__cil_tmp419 ;
  char *__cil_tmp420 ;
  char *__cil_tmp421 ;
  char *__cil_tmp422 ;
  char *__cil_tmp423 ;
  char *__cil_tmp424 ;
  char *__cil_tmp425 ;
  char *__cil_tmp426 ;
  char *__cil_tmp427 ;
  char *__cil_tmp428 ;
  char *__cil_tmp429 ;
  char *__cil_tmp430 ;
  char *__cil_tmp431 ;
  char *__cil_tmp432 ;
  char *__cil_tmp433 ;
  char *__cil_tmp434 ;
  char *__cil_tmp435 ;
  char *__cil_tmp436 ;
  char *__cil_tmp437 ;
  char *__cil_tmp438 ;
  char *__cil_tmp439 ;
  char *__cil_tmp440 ;
  char *__cil_tmp441 ;
  char *__cil_tmp442 ;
  char *__cil_tmp443 ;
  char *__cil_tmp444 ;
  char *__cil_tmp445 ;
  char *__cil_tmp446 ;
  char *__cil_tmp447 ;
  char *__cil_tmp448 ;
  char *__cil_tmp449 ;
  char *__cil_tmp450 ;
  char *__cil_tmp451 ;
  char *__cil_tmp452 ;
  char *__cil_tmp453 ;
  char *__cil_tmp454 ;
  char *__cil_tmp455 ;
  char *__cil_tmp456 ;
  char *__cil_tmp457 ;
  char *__cil_tmp458 ;
  char *__cil_tmp459 ;
  char *__cil_tmp460 ;
  char *__cil_tmp461 ;
  char *__cil_tmp462 ;
  char *__cil_tmp463 ;
  char *__cil_tmp464 ;
  char *__cil_tmp465 ;
  char *__cil_tmp466 ;
  char *__cil_tmp467 ;
  char *__cil_tmp468 ;
  char *__cil_tmp469 ;
  char *__cil_tmp470 ;
  char *__cil_tmp471 ;
  char *__cil_tmp472 ;
  char *__cil_tmp473 ;
  char *__cil_tmp474 ;
  char *__cil_tmp475 ;
  char *__cil_tmp476 ;
  char *__cil_tmp477 ;
  char *__cil_tmp478 ;
  char *__cil_tmp479 ;
  char *__cil_tmp480 ;
  char *__cil_tmp481 ;
  char *__cil_tmp482 ;
  char *__cil_tmp483 ;
  char *__cil_tmp484 ;
  char *__cil_tmp485 ;
  char *__cil_tmp486 ;
  char *__cil_tmp487 ;
  char *__cil_tmp488 ;
  char *__cil_tmp489 ;
  char *__cil_tmp490 ;
  char *__cil_tmp491 ;
  char *__cil_tmp492 ;
  char *__cil_tmp493 ;
  char *__cil_tmp494 ;
  char *__cil_tmp495 ;
  char *__cil_tmp496 ;
  char *__cil_tmp497 ;

  {
  {
#line 611
  tmp = getenv("BISON_USE_PUSH_FOR_PULL");
#line 611
  use_push_for_pull_env = (char const   *)tmp;
#line 612
  use_push_for_pull_flag = (_Bool)0;
  }
#line 613
  if ((unsigned long )use_push_for_pull_env != (unsigned long )((void *)0)) {
#line 613
    if ((int const   )*(use_push_for_pull_env + 0) != 0) {
      {
#line 613
      tmp___0 = strcmp(use_push_for_pull_env, "0");
      }
#line 613
      if (0 != tmp___0) {
#line 616
        use_push_for_pull_flag = (_Bool)1;
      }
    }
  }
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    v = (int )debug_flag;
    {
#line 619
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 619
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 619
        rpl_sprintf(buf___0, "%d", v);
#line 619
        __o = & muscle_obstack;
#line 619
        tmp___1 = strlen((char const   *)(buf___0));
#line 619
        __len = (int )tmp___1;
        }
#line 619
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 619
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 619
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
               (size_t )__len);
#line 619
        __o->next_free += __len;
        }
#line 619
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 619
      __o___0 = & muscle_obstack;
#line 619
      if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
        {
#line 619
        _obstack_newchunk(__o___0, 1);
        }
      }
#line 619
      tmp___2 = __o___0->next_free;
#line 619
      (__o___0->next_free) ++;
#line 619
      *tmp___2 = (char)0;
#line 619
      __o1 = & muscle_obstack;
#line 619
      __value = (void *)__o1->object_base;
#line 619
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 619
        __o1->maybe_empty_object = 1U;
      }
#line 619
      if (sizeof(int ) < sizeof(void *)) {
#line 619
        tmp___3 = __o1->object_base;
      } else {
#line 619
        tmp___3 = (char *)0;
      }
#line 619
      if (sizeof(int ) < sizeof(void *)) {
#line 619
        tmp___4 = __o1->object_base;
      } else {
#line 619
        tmp___4 = (char *)0;
      }
#line 619
      __o1->next_free = tmp___3 + (((__o1->next_free - tmp___4) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 619
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 619
        __o1->next_free = __o1->chunk_limit;
      }
      {
#line 619
      __o1->object_base = __o1->next_free;
#line 619
      muscle_insert("debug_flag", (char const   *)__value);
      }
#line 619
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 619
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 620
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 620
    v___0 = (int )defines_flag;
    {
#line 620
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 620
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 620
        rpl_sprintf(buf___1, "%d", v___0);
#line 620
        __o___1 = & muscle_obstack;
#line 620
        tmp___5 = strlen((char const   *)(buf___1));
#line 620
        __len___0 = (int )tmp___5;
        }
#line 620
        if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
          {
#line 620
          _obstack_newchunk(__o___1, __len___0);
          }
        }
        {
#line 620
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
               (size_t )__len___0);
#line 620
        __o___1->next_free += __len___0;
        }
#line 620
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 620
      __o___2 = & muscle_obstack;
#line 620
      if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 620
        _obstack_newchunk(__o___2, 1);
        }
      }
#line 620
      tmp___6 = __o___2->next_free;
#line 620
      (__o___2->next_free) ++;
#line 620
      *tmp___6 = (char)0;
#line 620
      __o1___0 = & muscle_obstack;
#line 620
      __value___0 = (void *)__o1___0->object_base;
#line 620
      if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 620
        __o1___0->maybe_empty_object = 1U;
      }
#line 620
      if (sizeof(int ) < sizeof(void *)) {
#line 620
        tmp___7 = __o1___0->object_base;
      } else {
#line 620
        tmp___7 = (char *)0;
      }
#line 620
      if (sizeof(int ) < sizeof(void *)) {
#line 620
        tmp___8 = __o1___0->object_base;
      } else {
#line 620
        tmp___8 = (char *)0;
      }
#line 620
      __o1___0->next_free = tmp___7 + (((__o1___0->next_free - tmp___8) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 620
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 620
        __o1___0->next_free = __o1___0->chunk_limit;
      }
      {
#line 620
      __o1___0->object_base = __o1___0->next_free;
#line 620
      muscle_insert("defines_flag", (char const   *)__value___0);
      }
#line 620
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 620
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 621
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 621
    v___1 = (int )error_verbose;
    {
#line 621
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 621
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 621
        rpl_sprintf(buf___2, "%d", v___1);
#line 621
        __o___3 = & muscle_obstack;
#line 621
        tmp___9 = strlen((char const   *)(buf___2));
#line 621
        __len___1 = (int )tmp___9;
        }
#line 621
        if ((unsigned long )(__o___3->next_free + __len___1) > (unsigned long )__o___3->chunk_limit) {
          {
#line 621
          _obstack_newchunk(__o___3, __len___1);
          }
        }
        {
#line 621
        memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___2),
               (size_t )__len___1);
#line 621
        __o___3->next_free += __len___1;
        }
#line 621
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 621
      __o___4 = & muscle_obstack;
#line 621
      if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
        {
#line 621
        _obstack_newchunk(__o___4, 1);
        }
      }
#line 621
      tmp___10 = __o___4->next_free;
#line 621
      (__o___4->next_free) ++;
#line 621
      *tmp___10 = (char)0;
#line 621
      __o1___1 = & muscle_obstack;
#line 621
      __value___1 = (void *)__o1___1->object_base;
#line 621
      if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 621
        __o1___1->maybe_empty_object = 1U;
      }
#line 621
      if (sizeof(int ) < sizeof(void *)) {
#line 621
        tmp___11 = __o1___1->object_base;
      } else {
#line 621
        tmp___11 = (char *)0;
      }
#line 621
      if (sizeof(int ) < sizeof(void *)) {
#line 621
        tmp___12 = __o1___1->object_base;
      } else {
#line 621
        tmp___12 = (char *)0;
      }
#line 621
      __o1___1->next_free = tmp___11 + (((__o1___1->next_free - tmp___12) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 621
      if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 621
        __o1___1->next_free = __o1___1->chunk_limit;
      }
      {
#line 621
      __o1___1->object_base = __o1___1->next_free;
#line 621
      muscle_insert("error_verbose_flag", (char const   *)__value___1);
      }
#line 621
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 621
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 622
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 622
    v___2 = (int )glr_parser;
    {
#line 622
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 622
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 622
        rpl_sprintf(buf___3, "%d", v___2);
#line 622
        __o___5 = & muscle_obstack;
#line 622
        tmp___13 = strlen((char const   *)(buf___3));
#line 622
        __len___2 = (int )tmp___13;
        }
#line 622
        if ((unsigned long )(__o___5->next_free + __len___2) > (unsigned long )__o___5->chunk_limit) {
          {
#line 622
          _obstack_newchunk(__o___5, __len___2);
          }
        }
        {
#line 622
        memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___3),
               (size_t )__len___2);
#line 622
        __o___5->next_free += __len___2;
        }
#line 622
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 622
      __o___6 = & muscle_obstack;
#line 622
      if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
        {
#line 622
        _obstack_newchunk(__o___6, 1);
        }
      }
#line 622
      tmp___14 = __o___6->next_free;
#line 622
      (__o___6->next_free) ++;
#line 622
      *tmp___14 = (char)0;
#line 622
      __o1___2 = & muscle_obstack;
#line 622
      __value___2 = (void *)__o1___2->object_base;
#line 622
      if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 622
        __o1___2->maybe_empty_object = 1U;
      }
#line 622
      if (sizeof(int ) < sizeof(void *)) {
#line 622
        tmp___15 = __o1___2->object_base;
      } else {
#line 622
        tmp___15 = (char *)0;
      }
#line 622
      if (sizeof(int ) < sizeof(void *)) {
#line 622
        tmp___16 = __o1___2->object_base;
      } else {
#line 622
        tmp___16 = (char *)0;
      }
#line 622
      __o1___2->next_free = tmp___15 + (((__o1___2->next_free - tmp___16) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 622
      if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 622
        __o1___2->next_free = __o1___2->chunk_limit;
      }
      {
#line 622
      __o1___2->object_base = __o1___2->next_free;
#line 622
      muscle_insert("glr_flag", (char const   *)__value___2);
      }
#line 622
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 622
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 623
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 623
    v___3 = (int )locations_flag;
    {
#line 623
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 623
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 623
        rpl_sprintf(buf___4, "%d", v___3);
#line 623
        __o___7 = & muscle_obstack;
#line 623
        tmp___17 = strlen((char const   *)(buf___4));
#line 623
        __len___3 = (int )tmp___17;
        }
#line 623
        if ((unsigned long )(__o___7->next_free + __len___3) > (unsigned long )__o___7->chunk_limit) {
          {
#line 623
          _obstack_newchunk(__o___7, __len___3);
          }
        }
        {
#line 623
        memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)(buf___4),
               (size_t )__len___3);
#line 623
        __o___7->next_free += __len___3;
        }
#line 623
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 623
      __o___8 = & muscle_obstack;
#line 623
      if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
        {
#line 623
        _obstack_newchunk(__o___8, 1);
        }
      }
#line 623
      tmp___18 = __o___8->next_free;
#line 623
      (__o___8->next_free) ++;
#line 623
      *tmp___18 = (char)0;
#line 623
      __o1___3 = & muscle_obstack;
#line 623
      __value___3 = (void *)__o1___3->object_base;
#line 623
      if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 623
        __o1___3->maybe_empty_object = 1U;
      }
#line 623
      if (sizeof(int ) < sizeof(void *)) {
#line 623
        tmp___19 = __o1___3->object_base;
      } else {
#line 623
        tmp___19 = (char *)0;
      }
#line 623
      if (sizeof(int ) < sizeof(void *)) {
#line 623
        tmp___20 = __o1___3->object_base;
      } else {
#line 623
        tmp___20 = (char *)0;
      }
#line 623
      __o1___3->next_free = tmp___19 + (((__o1___3->next_free - tmp___20) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 623
      if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 623
        __o1___3->next_free = __o1___3->chunk_limit;
      }
      {
#line 623
      __o1___3->object_base = __o1___3->next_free;
#line 623
      muscle_insert("locations_flag", (char const   *)__value___3);
      }
#line 623
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 623
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 624
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 624
    v___4 = (int )nondeterministic_parser;
    {
#line 624
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 624
      while (1) {
        while_continue___16: /* CIL Label */ ;
        {
#line 624
        rpl_sprintf(buf___5, "%d", v___4);
#line 624
        __o___9 = & muscle_obstack;
#line 624
        tmp___21 = strlen((char const   *)(buf___5));
#line 624
        __len___4 = (int )tmp___21;
        }
#line 624
        if ((unsigned long )(__o___9->next_free + __len___4) > (unsigned long )__o___9->chunk_limit) {
          {
#line 624
          _obstack_newchunk(__o___9, __len___4);
          }
        }
        {
#line 624
        memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)(buf___5),
               (size_t )__len___4);
#line 624
        __o___9->next_free += __len___4;
        }
#line 624
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 624
      __o___10 = & muscle_obstack;
#line 624
      if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
        {
#line 624
        _obstack_newchunk(__o___10, 1);
        }
      }
#line 624
      tmp___22 = __o___10->next_free;
#line 624
      (__o___10->next_free) ++;
#line 624
      *tmp___22 = (char)0;
#line 624
      __o1___4 = & muscle_obstack;
#line 624
      __value___4 = (void *)__o1___4->object_base;
#line 624
      if ((unsigned long )__o1___4->next_free == (unsigned long )__value___4) {
#line 624
        __o1___4->maybe_empty_object = 1U;
      }
#line 624
      if (sizeof(int ) < sizeof(void *)) {
#line 624
        tmp___23 = __o1___4->object_base;
      } else {
#line 624
        tmp___23 = (char *)0;
      }
#line 624
      if (sizeof(int ) < sizeof(void *)) {
#line 624
        tmp___24 = __o1___4->object_base;
      } else {
#line 624
        tmp___24 = (char *)0;
      }
#line 624
      __o1___4->next_free = tmp___23 + (((__o1___4->next_free - tmp___24) + (long )__o1___4->alignment_mask) & (long )(~ __o1___4->alignment_mask));
#line 624
      if (__o1___4->next_free - (char *)__o1___4->chunk > __o1___4->chunk_limit - (char *)__o1___4->chunk) {
#line 624
        __o1___4->next_free = __o1___4->chunk_limit;
      }
      {
#line 624
      __o1___4->object_base = __o1___4->next_free;
#line 624
      muscle_insert("nondeterministic_flag", (char const   *)__value___4);
      }
#line 624
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 624
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 625
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 625
    v___5 = ! no_lines_flag;
    {
#line 625
    while (1) {
      while_continue___18: /* CIL Label */ ;
      {
#line 625
      while (1) {
        while_continue___19: /* CIL Label */ ;
        {
#line 625
        rpl_sprintf(buf___6, "%d", v___5);
#line 625
        __o___11 = & muscle_obstack;
#line 625
        tmp___25 = strlen((char const   *)(buf___6));
#line 625
        __len___5 = (int )tmp___25;
        }
#line 625
        if ((unsigned long )(__o___11->next_free + __len___5) > (unsigned long )__o___11->chunk_limit) {
          {
#line 625
          _obstack_newchunk(__o___11, __len___5);
          }
        }
        {
#line 625
        memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)(buf___6),
               (size_t )__len___5);
#line 625
        __o___11->next_free += __len___5;
        }
#line 625
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 625
      __o___12 = & muscle_obstack;
#line 625
      if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
        {
#line 625
        _obstack_newchunk(__o___12, 1);
        }
      }
#line 625
      tmp___26 = __o___12->next_free;
#line 625
      (__o___12->next_free) ++;
#line 625
      *tmp___26 = (char)0;
#line 625
      __o1___5 = & muscle_obstack;
#line 625
      __value___5 = (void *)__o1___5->object_base;
#line 625
      if ((unsigned long )__o1___5->next_free == (unsigned long )__value___5) {
#line 625
        __o1___5->maybe_empty_object = 1U;
      }
#line 625
      if (sizeof(int ) < sizeof(void *)) {
#line 625
        tmp___27 = __o1___5->object_base;
      } else {
#line 625
        tmp___27 = (char *)0;
      }
#line 625
      if (sizeof(int ) < sizeof(void *)) {
#line 625
        tmp___28 = __o1___5->object_base;
      } else {
#line 625
        tmp___28 = (char *)0;
      }
#line 625
      __o1___5->next_free = tmp___27 + (((__o1___5->next_free - tmp___28) + (long )__o1___5->alignment_mask) & (long )(~ __o1___5->alignment_mask));
#line 625
      if (__o1___5->next_free - (char *)__o1___5->chunk > __o1___5->chunk_limit - (char *)__o1___5->chunk) {
#line 625
        __o1___5->next_free = __o1___5->chunk_limit;
      }
      {
#line 625
      __o1___5->object_base = __o1___5->next_free;
#line 625
      muscle_insert("synclines_flag", (char const   *)__value___5);
      }
#line 625
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 625
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 626
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 626
    v___6 = (int )tag_seen;
    {
#line 626
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 626
      while (1) {
        while_continue___22: /* CIL Label */ ;
        {
#line 626
        rpl_sprintf(buf___7, "%d", v___6);
#line 626
        __o___13 = & muscle_obstack;
#line 626
        tmp___29 = strlen((char const   *)(buf___7));
#line 626
        __len___6 = (int )tmp___29;
        }
#line 626
        if ((unsigned long )(__o___13->next_free + __len___6) > (unsigned long )__o___13->chunk_limit) {
          {
#line 626
          _obstack_newchunk(__o___13, __len___6);
          }
        }
        {
#line 626
        memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)(buf___7),
               (size_t )__len___6);
#line 626
        __o___13->next_free += __len___6;
        }
#line 626
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 626
      __o___14 = & muscle_obstack;
#line 626
      if ((unsigned long )(__o___14->next_free + 1) > (unsigned long )__o___14->chunk_limit) {
        {
#line 626
        _obstack_newchunk(__o___14, 1);
        }
      }
#line 626
      tmp___30 = __o___14->next_free;
#line 626
      (__o___14->next_free) ++;
#line 626
      *tmp___30 = (char)0;
#line 626
      __o1___6 = & muscle_obstack;
#line 626
      __value___6 = (void *)__o1___6->object_base;
#line 626
      if ((unsigned long )__o1___6->next_free == (unsigned long )__value___6) {
#line 626
        __o1___6->maybe_empty_object = 1U;
      }
#line 626
      if (sizeof(int ) < sizeof(void *)) {
#line 626
        tmp___31 = __o1___6->object_base;
      } else {
#line 626
        tmp___31 = (char *)0;
      }
#line 626
      if (sizeof(int ) < sizeof(void *)) {
#line 626
        tmp___32 = __o1___6->object_base;
      } else {
#line 626
        tmp___32 = (char *)0;
      }
#line 626
      __o1___6->next_free = tmp___31 + (((__o1___6->next_free - tmp___32) + (long )__o1___6->alignment_mask) & (long )(~ __o1___6->alignment_mask));
#line 626
      if (__o1___6->next_free - (char *)__o1___6->chunk > __o1___6->chunk_limit - (char *)__o1___6->chunk) {
#line 626
        __o1___6->next_free = __o1___6->chunk_limit;
      }
      {
#line 626
      __o1___6->object_base = __o1___6->next_free;
#line 626
      muscle_insert("tag_seen_flag", (char const   *)__value___6);
      }
#line 626
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 626
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 627
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 627
    v___7 = (int )use_push_for_pull_flag;
    {
#line 627
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 627
      while (1) {
        while_continue___25: /* CIL Label */ ;
        {
#line 627
        rpl_sprintf(buf___8, "%d", v___7);
#line 627
        __o___15 = & muscle_obstack;
#line 627
        tmp___33 = strlen((char const   *)(buf___8));
#line 627
        __len___7 = (int )tmp___33;
        }
#line 627
        if ((unsigned long )(__o___15->next_free + __len___7) > (unsigned long )__o___15->chunk_limit) {
          {
#line 627
          _obstack_newchunk(__o___15, __len___7);
          }
        }
        {
#line 627
        memcpy((void */* __restrict  */)__o___15->next_free, (void const   */* __restrict  */)(buf___8),
               (size_t )__len___7);
#line 627
        __o___15->next_free += __len___7;
        }
#line 627
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
#line 627
      __o___16 = & muscle_obstack;
#line 627
      if ((unsigned long )(__o___16->next_free + 1) > (unsigned long )__o___16->chunk_limit) {
        {
#line 627
        _obstack_newchunk(__o___16, 1);
        }
      }
#line 627
      tmp___34 = __o___16->next_free;
#line 627
      (__o___16->next_free) ++;
#line 627
      *tmp___34 = (char)0;
#line 627
      __o1___7 = & muscle_obstack;
#line 627
      __value___7 = (void *)__o1___7->object_base;
#line 627
      if ((unsigned long )__o1___7->next_free == (unsigned long )__value___7) {
#line 627
        __o1___7->maybe_empty_object = 1U;
      }
#line 627
      if (sizeof(int ) < sizeof(void *)) {
#line 627
        tmp___35 = __o1___7->object_base;
      } else {
#line 627
        tmp___35 = (char *)0;
      }
#line 627
      if (sizeof(int ) < sizeof(void *)) {
#line 627
        tmp___36 = __o1___7->object_base;
      } else {
#line 627
        tmp___36 = (char *)0;
      }
#line 627
      __o1___7->next_free = tmp___35 + (((__o1___7->next_free - tmp___36) + (long )__o1___7->alignment_mask) & (long )(~ __o1___7->alignment_mask));
#line 627
      if (__o1___7->next_free - (char *)__o1___7->chunk > __o1___7->chunk_limit - (char *)__o1___7->chunk) {
#line 627
        __o1___7->next_free = __o1___7->chunk_limit;
      }
      {
#line 627
      __o1___7->object_base = __o1___7->next_free;
#line 627
      muscle_insert("use_push_for_pull_flag", (char const   *)__value___7);
      }
#line 627
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
#line 627
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 628
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 628
    v___8 = (int )yacc_flag;
    {
#line 628
    while (1) {
      while_continue___27: /* CIL Label */ ;
      {
#line 628
      while (1) {
        while_continue___28: /* CIL Label */ ;
        {
#line 628
        rpl_sprintf(buf___9, "%d", v___8);
#line 628
        __o___17 = & muscle_obstack;
#line 628
        tmp___37 = strlen((char const   *)(buf___9));
#line 628
        __len___8 = (int )tmp___37;
        }
#line 628
        if ((unsigned long )(__o___17->next_free + __len___8) > (unsigned long )__o___17->chunk_limit) {
          {
#line 628
          _obstack_newchunk(__o___17, __len___8);
          }
        }
        {
#line 628
        memcpy((void */* __restrict  */)__o___17->next_free, (void const   */* __restrict  */)(buf___9),
               (size_t )__len___8);
#line 628
        __o___17->next_free += __len___8;
        }
#line 628
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 628
      __o___18 = & muscle_obstack;
#line 628
      if ((unsigned long )(__o___18->next_free + 1) > (unsigned long )__o___18->chunk_limit) {
        {
#line 628
        _obstack_newchunk(__o___18, 1);
        }
      }
#line 628
      tmp___38 = __o___18->next_free;
#line 628
      (__o___18->next_free) ++;
#line 628
      *tmp___38 = (char)0;
#line 628
      __o1___8 = & muscle_obstack;
#line 628
      __value___8 = (void *)__o1___8->object_base;
#line 628
      if ((unsigned long )__o1___8->next_free == (unsigned long )__value___8) {
#line 628
        __o1___8->maybe_empty_object = 1U;
      }
#line 628
      if (sizeof(int ) < sizeof(void *)) {
#line 628
        tmp___39 = __o1___8->object_base;
      } else {
#line 628
        tmp___39 = (char *)0;
      }
#line 628
      if (sizeof(int ) < sizeof(void *)) {
#line 628
        tmp___40 = __o1___8->object_base;
      } else {
#line 628
        tmp___40 = (char *)0;
      }
#line 628
      __o1___8->next_free = tmp___39 + (((__o1___8->next_free - tmp___40) + (long )__o1___8->alignment_mask) & (long )(~ __o1___8->alignment_mask));
#line 628
      if (__o1___8->next_free - (char *)__o1___8->chunk > __o1___8->chunk_limit - (char *)__o1___8->chunk) {
#line 628
        __o1___8->next_free = __o1___8->chunk_limit;
      }
      {
#line 628
      __o1___8->object_base = __o1___8->next_free;
#line 628
      muscle_insert("yacc_flag", (char const   *)__value___8);
      }
#line 628
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 628
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 631
  if (spec_name_prefix) {
    {
#line 632
    while (1) {
      while_continue___29: /* CIL Label */ ;
      {
#line 632
      while (1) {
        while_continue___30: /* CIL Label */ ;
#line 632
        p = spec_name_prefix;
        {
#line 632
        while (1) {
          while_continue___31: /* CIL Label */ ;
#line 632
          if (! *p) {
#line 632
            goto while_break___31;
          }
          {
#line 632
          if ((int const   )*p == 36) {
#line 632
            goto case_36;
          }
#line 632
          if ((int const   )*p == 64) {
#line 632
            goto case_64;
          }
#line 632
          if ((int const   )*p == 91) {
#line 632
            goto case_91;
          }
#line 632
          if ((int const   )*p == 93) {
#line 632
            goto case_93;
          }
#line 632
          goto switch_default;
          case_36: /* CIL Label */ 
          {
#line 632
          __o___19 = & muscle_obstack;
#line 632
          tmp___41 = strlen("$][");
#line 632
          __len___9 = (int )tmp___41;
          }
#line 632
          if ((unsigned long )(__o___19->next_free + __len___9) > (unsigned long )__o___19->chunk_limit) {
            {
#line 632
            _obstack_newchunk(__o___19, __len___9);
            }
          }
          {
#line 632
          memcpy((void */* __restrict  */)__o___19->next_free, (void const   */* __restrict  */)"$][",
                 (size_t )__len___9);
#line 632
          __o___19->next_free += __len___9;
          }
#line 632
          goto switch_break;
          case_64: /* CIL Label */ 
          {
#line 632
          __o___20 = & muscle_obstack;
#line 632
          tmp___42 = strlen("@@");
#line 632
          __len___10 = (int )tmp___42;
          }
#line 632
          if ((unsigned long )(__o___20->next_free + __len___10) > (unsigned long )__o___20->chunk_limit) {
            {
#line 632
            _obstack_newchunk(__o___20, __len___10);
            }
          }
          {
#line 632
          memcpy((void */* __restrict  */)__o___20->next_free, (void const   */* __restrict  */)"@@",
                 (size_t )__len___10);
#line 632
          __o___20->next_free += __len___10;
          }
#line 632
          goto switch_break;
          case_91: /* CIL Label */ 
          {
#line 632
          __o___21 = & muscle_obstack;
#line 632
          tmp___43 = strlen("@{");
#line 632
          __len___11 = (int )tmp___43;
          }
#line 632
          if ((unsigned long )(__o___21->next_free + __len___11) > (unsigned long )__o___21->chunk_limit) {
            {
#line 632
            _obstack_newchunk(__o___21, __len___11);
            }
          }
          {
#line 632
          memcpy((void */* __restrict  */)__o___21->next_free, (void const   */* __restrict  */)"@{",
                 (size_t )__len___11);
#line 632
          __o___21->next_free += __len___11;
          }
#line 632
          goto switch_break;
          case_93: /* CIL Label */ 
          {
#line 632
          __o___22 = & muscle_obstack;
#line 632
          tmp___44 = strlen("@}");
#line 632
          __len___12 = (int )tmp___44;
          }
#line 632
          if ((unsigned long )(__o___22->next_free + __len___12) > (unsigned long )__o___22->chunk_limit) {
            {
#line 632
            _obstack_newchunk(__o___22, __len___12);
            }
          }
          {
#line 632
          memcpy((void */* __restrict  */)__o___22->next_free, (void const   */* __restrict  */)"@}",
                 (size_t )__len___12);
#line 632
          __o___22->next_free += __len___12;
          }
#line 632
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 632
          __o___23 = & muscle_obstack;
#line 632
          if ((unsigned long )(__o___23->next_free + 1) > (unsigned long )__o___23->chunk_limit) {
            {
#line 632
            _obstack_newchunk(__o___23, 1);
            }
          }
#line 632
          tmp___45 = __o___23->next_free;
#line 632
          (__o___23->next_free) ++;
#line 632
          *tmp___45 = (char )*p;
#line 632
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 632
          p ++;
        }
        while_break___31: /* CIL Label */ ;
        }
#line 632
        goto while_break___30;
      }
      while_break___30: /* CIL Label */ ;
      }
#line 632
      __o___24 = & muscle_obstack;
#line 632
      if ((unsigned long )(__o___24->next_free + 1) > (unsigned long )__o___24->chunk_limit) {
        {
#line 632
        _obstack_newchunk(__o___24, 1);
        }
      }
#line 632
      tmp___46 = __o___24->next_free;
#line 632
      (__o___24->next_free) ++;
#line 632
      *tmp___46 = (char)0;
#line 632
      __o1___9 = & muscle_obstack;
#line 632
      __value___9 = (void *)__o1___9->object_base;
#line 632
      if ((unsigned long )__o1___9->next_free == (unsigned long )__value___9) {
#line 632
        __o1___9->maybe_empty_object = 1U;
      }
#line 632
      if (sizeof(int ) < sizeof(void *)) {
#line 632
        tmp___47 = __o1___9->object_base;
      } else {
#line 632
        tmp___47 = (char *)0;
      }
#line 632
      if (sizeof(int ) < sizeof(void *)) {
#line 632
        tmp___48 = __o1___9->object_base;
      } else {
#line 632
        tmp___48 = (char *)0;
      }
#line 632
      __o1___9->next_free = tmp___47 + (((__o1___9->next_free - tmp___48) + (long )__o1___9->alignment_mask) & (long )(~ __o1___9->alignment_mask));
#line 632
      if (__o1___9->next_free - (char *)__o1___9->chunk > __o1___9->chunk_limit - (char *)__o1___9->chunk) {
#line 632
        __o1___9->next_free = __o1___9->chunk_limit;
      }
      {
#line 632
      __o1___9->object_base = __o1___9->next_free;
#line 632
      muscle_insert("prefix", (char const   *)__value___9);
      }
#line 632
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
  }
  {
#line 634
  while (1) {
    while_continue___32: /* CIL Label */ ;
    {
#line 634
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 634
      p___0 = (char const   *)all_but_ext;
      {
#line 634
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 634
        if (! *p___0) {
#line 634
          goto while_break___34;
        }
        {
#line 634
        if ((int const   )*p___0 == 36) {
#line 634
          goto case_36___0;
        }
#line 634
        if ((int const   )*p___0 == 64) {
#line 634
          goto case_64___0;
        }
#line 634
        if ((int const   )*p___0 == 91) {
#line 634
          goto case_91___0;
        }
#line 634
        if ((int const   )*p___0 == 93) {
#line 634
          goto case_93___0;
        }
#line 634
        goto switch_default___0;
        case_36___0: /* CIL Label */ 
        {
#line 634
        __o___25 = & muscle_obstack;
#line 634
        tmp___49 = strlen("$][");
#line 634
        __len___13 = (int )tmp___49;
        }
#line 634
        if ((unsigned long )(__o___25->next_free + __len___13) > (unsigned long )__o___25->chunk_limit) {
          {
#line 634
          _obstack_newchunk(__o___25, __len___13);
          }
        }
        {
#line 634
        memcpy((void */* __restrict  */)__o___25->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___13);
#line 634
        __o___25->next_free += __len___13;
        }
#line 634
        goto switch_break___0;
        case_64___0: /* CIL Label */ 
        {
#line 634
        __o___26 = & muscle_obstack;
#line 634
        tmp___50 = strlen("@@");
#line 634
        __len___14 = (int )tmp___50;
        }
#line 634
        if ((unsigned long )(__o___26->next_free + __len___14) > (unsigned long )__o___26->chunk_limit) {
          {
#line 634
          _obstack_newchunk(__o___26, __len___14);
          }
        }
        {
#line 634
        memcpy((void */* __restrict  */)__o___26->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___14);
#line 634
        __o___26->next_free += __len___14;
        }
#line 634
        goto switch_break___0;
        case_91___0: /* CIL Label */ 
        {
#line 634
        __o___27 = & muscle_obstack;
#line 634
        tmp___51 = strlen("@{");
#line 634
        __len___15 = (int )tmp___51;
        }
#line 634
        if ((unsigned long )(__o___27->next_free + __len___15) > (unsigned long )__o___27->chunk_limit) {
          {
#line 634
          _obstack_newchunk(__o___27, __len___15);
          }
        }
        {
#line 634
        memcpy((void */* __restrict  */)__o___27->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___15);
#line 634
        __o___27->next_free += __len___15;
        }
#line 634
        goto switch_break___0;
        case_93___0: /* CIL Label */ 
        {
#line 634
        __o___28 = & muscle_obstack;
#line 634
        tmp___52 = strlen("@}");
#line 634
        __len___16 = (int )tmp___52;
        }
#line 634
        if ((unsigned long )(__o___28->next_free + __len___16) > (unsigned long )__o___28->chunk_limit) {
          {
#line 634
          _obstack_newchunk(__o___28, __len___16);
          }
        }
        {
#line 634
        memcpy((void */* __restrict  */)__o___28->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___16);
#line 634
        __o___28->next_free += __len___16;
        }
#line 634
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 634
        __o___29 = & muscle_obstack;
#line 634
        if ((unsigned long )(__o___29->next_free + 1) > (unsigned long )__o___29->chunk_limit) {
          {
#line 634
          _obstack_newchunk(__o___29, 1);
          }
        }
#line 634
        tmp___53 = __o___29->next_free;
#line 634
        (__o___29->next_free) ++;
#line 634
        *tmp___53 = (char )*p___0;
#line 634
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 634
        p___0 ++;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 634
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
#line 634
    __o___30 = & muscle_obstack;
#line 634
    if ((unsigned long )(__o___30->next_free + 1) > (unsigned long )__o___30->chunk_limit) {
      {
#line 634
      _obstack_newchunk(__o___30, 1);
      }
    }
#line 634
    tmp___54 = __o___30->next_free;
#line 634
    (__o___30->next_free) ++;
#line 634
    *tmp___54 = (char)0;
#line 634
    __o1___10 = & muscle_obstack;
#line 634
    __value___10 = (void *)__o1___10->object_base;
#line 634
    if ((unsigned long )__o1___10->next_free == (unsigned long )__value___10) {
#line 634
      __o1___10->maybe_empty_object = 1U;
    }
#line 634
    if (sizeof(int ) < sizeof(void *)) {
#line 634
      tmp___55 = __o1___10->object_base;
    } else {
#line 634
      tmp___55 = (char *)0;
    }
#line 634
    if (sizeof(int ) < sizeof(void *)) {
#line 634
      tmp___56 = __o1___10->object_base;
    } else {
#line 634
      tmp___56 = (char *)0;
    }
#line 634
    __o1___10->next_free = tmp___55 + (((__o1___10->next_free - tmp___56) + (long )__o1___10->alignment_mask) & (long )(~ __o1___10->alignment_mask));
#line 634
    if (__o1___10->next_free - (char *)__o1___10->chunk > __o1___10->chunk_limit - (char *)__o1___10->chunk) {
#line 634
      __o1___10->next_free = __o1___10->chunk_limit;
    }
    {
#line 634
    __o1___10->object_base = __o1___10->next_free;
#line 634
    muscle_insert("file_name_all_but_ext", (char const   *)__value___10);
    }
#line 634
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
  {
#line 637
  while (1) {
    while_continue___35: /* CIL Label */ ;
    {
#line 637
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 637
      if (dir_prefix) {
#line 637
        p___1 = (char const   *)dir_prefix;
      } else {
#line 637
        p___1 = "";
      }
      {
#line 637
      while (1) {
        while_continue___37: /* CIL Label */ ;
#line 637
        if (! *p___1) {
#line 637
          goto while_break___37;
        }
        {
#line 637
        if ((int const   )*p___1 == 36) {
#line 637
          goto case_36___1;
        }
#line 637
        if ((int const   )*p___1 == 64) {
#line 637
          goto case_64___1;
        }
#line 637
        if ((int const   )*p___1 == 91) {
#line 637
          goto case_91___1;
        }
#line 637
        if ((int const   )*p___1 == 93) {
#line 637
          goto case_93___1;
        }
#line 637
        goto switch_default___1;
        case_36___1: /* CIL Label */ 
        {
#line 637
        __o___31 = & muscle_obstack;
#line 637
        tmp___57 = strlen("$][");
#line 637
        __len___17 = (int )tmp___57;
        }
#line 637
        if ((unsigned long )(__o___31->next_free + __len___17) > (unsigned long )__o___31->chunk_limit) {
          {
#line 637
          _obstack_newchunk(__o___31, __len___17);
          }
        }
        {
#line 637
        memcpy((void */* __restrict  */)__o___31->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___17);
#line 637
        __o___31->next_free += __len___17;
        }
#line 637
        goto switch_break___1;
        case_64___1: /* CIL Label */ 
        {
#line 637
        __o___32 = & muscle_obstack;
#line 637
        tmp___58 = strlen("@@");
#line 637
        __len___18 = (int )tmp___58;
        }
#line 637
        if ((unsigned long )(__o___32->next_free + __len___18) > (unsigned long )__o___32->chunk_limit) {
          {
#line 637
          _obstack_newchunk(__o___32, __len___18);
          }
        }
        {
#line 637
        memcpy((void */* __restrict  */)__o___32->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___18);
#line 637
        __o___32->next_free += __len___18;
        }
#line 637
        goto switch_break___1;
        case_91___1: /* CIL Label */ 
        {
#line 637
        __o___33 = & muscle_obstack;
#line 637
        tmp___59 = strlen("@{");
#line 637
        __len___19 = (int )tmp___59;
        }
#line 637
        if ((unsigned long )(__o___33->next_free + __len___19) > (unsigned long )__o___33->chunk_limit) {
          {
#line 637
          _obstack_newchunk(__o___33, __len___19);
          }
        }
        {
#line 637
        memcpy((void */* __restrict  */)__o___33->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___19);
#line 637
        __o___33->next_free += __len___19;
        }
#line 637
        goto switch_break___1;
        case_93___1: /* CIL Label */ 
        {
#line 637
        __o___34 = & muscle_obstack;
#line 637
        tmp___60 = strlen("@}");
#line 637
        __len___20 = (int )tmp___60;
        }
#line 637
        if ((unsigned long )(__o___34->next_free + __len___20) > (unsigned long )__o___34->chunk_limit) {
          {
#line 637
          _obstack_newchunk(__o___34, __len___20);
          }
        }
        {
#line 637
        memcpy((void */* __restrict  */)__o___34->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___20);
#line 637
        __o___34->next_free += __len___20;
        }
#line 637
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
#line 637
        __o___35 = & muscle_obstack;
#line 637
        if ((unsigned long )(__o___35->next_free + 1) > (unsigned long )__o___35->chunk_limit) {
          {
#line 637
          _obstack_newchunk(__o___35, 1);
          }
        }
#line 637
        tmp___61 = __o___35->next_free;
#line 637
        (__o___35->next_free) ++;
#line 637
        *tmp___61 = (char )*p___1;
#line 637
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 637
        p___1 ++;
      }
      while_break___37: /* CIL Label */ ;
      }
#line 637
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
#line 637
    __o___36 = & muscle_obstack;
#line 637
    if ((unsigned long )(__o___36->next_free + 1) > (unsigned long )__o___36->chunk_limit) {
      {
#line 637
      _obstack_newchunk(__o___36, 1);
      }
    }
#line 637
    tmp___62 = __o___36->next_free;
#line 637
    (__o___36->next_free) ++;
#line 637
    *tmp___62 = (char)0;
#line 637
    __o1___11 = & muscle_obstack;
#line 637
    __value___11 = (void *)__o1___11->object_base;
#line 637
    if ((unsigned long )__o1___11->next_free == (unsigned long )__value___11) {
#line 637
      __o1___11->maybe_empty_object = 1U;
    }
#line 637
    if (sizeof(int ) < sizeof(void *)) {
#line 637
      tmp___63 = __o1___11->object_base;
    } else {
#line 637
      tmp___63 = (char *)0;
    }
#line 637
    if (sizeof(int ) < sizeof(void *)) {
#line 637
      tmp___64 = __o1___11->object_base;
    } else {
#line 637
      tmp___64 = (char *)0;
    }
#line 637
    __o1___11->next_free = tmp___63 + (((__o1___11->next_free - tmp___64) + (long )__o1___11->alignment_mask) & (long )(~ __o1___11->alignment_mask));
#line 637
    if (__o1___11->next_free - (char *)__o1___11->chunk > __o1___11->chunk_limit - (char *)__o1___11->chunk) {
#line 637
      __o1___11->next_free = __o1___11->chunk_limit;
    }
    {
#line 637
    __o1___11->object_base = __o1___11->next_free;
#line 637
    muscle_insert("dir_prefix", (char const   *)__value___11);
    }
#line 637
    goto while_break___35;
  }
  while_break___35: /* CIL Label */ ;
  }
  {
#line 638
  while (1) {
    while_continue___38: /* CIL Label */ ;
    {
#line 638
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 638
      if (parser_file_name) {
#line 638
        p___2 = (char const   *)parser_file_name;
      } else {
#line 638
        p___2 = "";
      }
      {
#line 638
      while (1) {
        while_continue___40: /* CIL Label */ ;
#line 638
        if (! *p___2) {
#line 638
          goto while_break___40;
        }
        {
#line 638
        if ((int const   )*p___2 == 36) {
#line 638
          goto case_36___2;
        }
#line 638
        if ((int const   )*p___2 == 64) {
#line 638
          goto case_64___2;
        }
#line 638
        if ((int const   )*p___2 == 91) {
#line 638
          goto case_91___2;
        }
#line 638
        if ((int const   )*p___2 == 93) {
#line 638
          goto case_93___2;
        }
#line 638
        goto switch_default___2;
        case_36___2: /* CIL Label */ 
        {
#line 638
        __o___37 = & muscle_obstack;
#line 638
        tmp___65 = strlen("$][");
#line 638
        __len___21 = (int )tmp___65;
        }
#line 638
        if ((unsigned long )(__o___37->next_free + __len___21) > (unsigned long )__o___37->chunk_limit) {
          {
#line 638
          _obstack_newchunk(__o___37, __len___21);
          }
        }
        {
#line 638
        memcpy((void */* __restrict  */)__o___37->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___21);
#line 638
        __o___37->next_free += __len___21;
        }
#line 638
        goto switch_break___2;
        case_64___2: /* CIL Label */ 
        {
#line 638
        __o___38 = & muscle_obstack;
#line 638
        tmp___66 = strlen("@@");
#line 638
        __len___22 = (int )tmp___66;
        }
#line 638
        if ((unsigned long )(__o___38->next_free + __len___22) > (unsigned long )__o___38->chunk_limit) {
          {
#line 638
          _obstack_newchunk(__o___38, __len___22);
          }
        }
        {
#line 638
        memcpy((void */* __restrict  */)__o___38->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___22);
#line 638
        __o___38->next_free += __len___22;
        }
#line 638
        goto switch_break___2;
        case_91___2: /* CIL Label */ 
        {
#line 638
        __o___39 = & muscle_obstack;
#line 638
        tmp___67 = strlen("@{");
#line 638
        __len___23 = (int )tmp___67;
        }
#line 638
        if ((unsigned long )(__o___39->next_free + __len___23) > (unsigned long )__o___39->chunk_limit) {
          {
#line 638
          _obstack_newchunk(__o___39, __len___23);
          }
        }
        {
#line 638
        memcpy((void */* __restrict  */)__o___39->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___23);
#line 638
        __o___39->next_free += __len___23;
        }
#line 638
        goto switch_break___2;
        case_93___2: /* CIL Label */ 
        {
#line 638
        __o___40 = & muscle_obstack;
#line 638
        tmp___68 = strlen("@}");
#line 638
        __len___24 = (int )tmp___68;
        }
#line 638
        if ((unsigned long )(__o___40->next_free + __len___24) > (unsigned long )__o___40->chunk_limit) {
          {
#line 638
          _obstack_newchunk(__o___40, __len___24);
          }
        }
        {
#line 638
        memcpy((void */* __restrict  */)__o___40->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___24);
#line 638
        __o___40->next_free += __len___24;
        }
#line 638
        goto switch_break___2;
        switch_default___2: /* CIL Label */ 
#line 638
        __o___41 = & muscle_obstack;
#line 638
        if ((unsigned long )(__o___41->next_free + 1) > (unsigned long )__o___41->chunk_limit) {
          {
#line 638
          _obstack_newchunk(__o___41, 1);
          }
        }
#line 638
        tmp___69 = __o___41->next_free;
#line 638
        (__o___41->next_free) ++;
#line 638
        *tmp___69 = (char )*p___2;
#line 638
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 638
        p___2 ++;
      }
      while_break___40: /* CIL Label */ ;
      }
#line 638
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
#line 638
    __o___42 = & muscle_obstack;
#line 638
    if ((unsigned long )(__o___42->next_free + 1) > (unsigned long )__o___42->chunk_limit) {
      {
#line 638
      _obstack_newchunk(__o___42, 1);
      }
    }
#line 638
    tmp___70 = __o___42->next_free;
#line 638
    (__o___42->next_free) ++;
#line 638
    *tmp___70 = (char)0;
#line 638
    __o1___12 = & muscle_obstack;
#line 638
    __value___12 = (void *)__o1___12->object_base;
#line 638
    if ((unsigned long )__o1___12->next_free == (unsigned long )__value___12) {
#line 638
      __o1___12->maybe_empty_object = 1U;
    }
#line 638
    if (sizeof(int ) < sizeof(void *)) {
#line 638
      tmp___71 = __o1___12->object_base;
    } else {
#line 638
      tmp___71 = (char *)0;
    }
#line 638
    if (sizeof(int ) < sizeof(void *)) {
#line 638
      tmp___72 = __o1___12->object_base;
    } else {
#line 638
      tmp___72 = (char *)0;
    }
#line 638
    __o1___12->next_free = tmp___71 + (((__o1___12->next_free - tmp___72) + (long )__o1___12->alignment_mask) & (long )(~ __o1___12->alignment_mask));
#line 638
    if (__o1___12->next_free - (char *)__o1___12->chunk > __o1___12->chunk_limit - (char *)__o1___12->chunk) {
#line 638
      __o1___12->next_free = __o1___12->chunk_limit;
    }
    {
#line 638
    __o1___12->object_base = __o1___12->next_free;
#line 638
    muscle_insert("parser_file_name", (char const   *)__value___12);
    }
#line 638
    goto while_break___38;
  }
  while_break___38: /* CIL Label */ ;
  }
  {
#line 639
  while (1) {
    while_continue___41: /* CIL Label */ ;
    {
#line 639
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 639
      if (spec_defines_file) {
#line 639
        p___3 = (char const   *)spec_defines_file;
      } else {
#line 639
        p___3 = "";
      }
      {
#line 639
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 639
        if (! *p___3) {
#line 639
          goto while_break___43;
        }
        {
#line 639
        if ((int const   )*p___3 == 36) {
#line 639
          goto case_36___3;
        }
#line 639
        if ((int const   )*p___3 == 64) {
#line 639
          goto case_64___3;
        }
#line 639
        if ((int const   )*p___3 == 91) {
#line 639
          goto case_91___3;
        }
#line 639
        if ((int const   )*p___3 == 93) {
#line 639
          goto case_93___3;
        }
#line 639
        goto switch_default___3;
        case_36___3: /* CIL Label */ 
        {
#line 639
        __o___43 = & muscle_obstack;
#line 639
        tmp___73 = strlen("$][");
#line 639
        __len___25 = (int )tmp___73;
        }
#line 639
        if ((unsigned long )(__o___43->next_free + __len___25) > (unsigned long )__o___43->chunk_limit) {
          {
#line 639
          _obstack_newchunk(__o___43, __len___25);
          }
        }
        {
#line 639
        memcpy((void */* __restrict  */)__o___43->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___25);
#line 639
        __o___43->next_free += __len___25;
        }
#line 639
        goto switch_break___3;
        case_64___3: /* CIL Label */ 
        {
#line 639
        __o___44 = & muscle_obstack;
#line 639
        tmp___74 = strlen("@@");
#line 639
        __len___26 = (int )tmp___74;
        }
#line 639
        if ((unsigned long )(__o___44->next_free + __len___26) > (unsigned long )__o___44->chunk_limit) {
          {
#line 639
          _obstack_newchunk(__o___44, __len___26);
          }
        }
        {
#line 639
        memcpy((void */* __restrict  */)__o___44->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___26);
#line 639
        __o___44->next_free += __len___26;
        }
#line 639
        goto switch_break___3;
        case_91___3: /* CIL Label */ 
        {
#line 639
        __o___45 = & muscle_obstack;
#line 639
        tmp___75 = strlen("@{");
#line 639
        __len___27 = (int )tmp___75;
        }
#line 639
        if ((unsigned long )(__o___45->next_free + __len___27) > (unsigned long )__o___45->chunk_limit) {
          {
#line 639
          _obstack_newchunk(__o___45, __len___27);
          }
        }
        {
#line 639
        memcpy((void */* __restrict  */)__o___45->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___27);
#line 639
        __o___45->next_free += __len___27;
        }
#line 639
        goto switch_break___3;
        case_93___3: /* CIL Label */ 
        {
#line 639
        __o___46 = & muscle_obstack;
#line 639
        tmp___76 = strlen("@}");
#line 639
        __len___28 = (int )tmp___76;
        }
#line 639
        if ((unsigned long )(__o___46->next_free + __len___28) > (unsigned long )__o___46->chunk_limit) {
          {
#line 639
          _obstack_newchunk(__o___46, __len___28);
          }
        }
        {
#line 639
        memcpy((void */* __restrict  */)__o___46->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___28);
#line 639
        __o___46->next_free += __len___28;
        }
#line 639
        goto switch_break___3;
        switch_default___3: /* CIL Label */ 
#line 639
        __o___47 = & muscle_obstack;
#line 639
        if ((unsigned long )(__o___47->next_free + 1) > (unsigned long )__o___47->chunk_limit) {
          {
#line 639
          _obstack_newchunk(__o___47, 1);
          }
        }
#line 639
        tmp___77 = __o___47->next_free;
#line 639
        (__o___47->next_free) ++;
#line 639
        *tmp___77 = (char )*p___3;
#line 639
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
#line 639
        p___3 ++;
      }
      while_break___43: /* CIL Label */ ;
      }
#line 639
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 639
    __o___48 = & muscle_obstack;
#line 639
    if ((unsigned long )(__o___48->next_free + 1) > (unsigned long )__o___48->chunk_limit) {
      {
#line 639
      _obstack_newchunk(__o___48, 1);
      }
    }
#line 639
    tmp___78 = __o___48->next_free;
#line 639
    (__o___48->next_free) ++;
#line 639
    *tmp___78 = (char)0;
#line 639
    __o1___13 = & muscle_obstack;
#line 639
    __value___13 = (void *)__o1___13->object_base;
#line 639
    if ((unsigned long )__o1___13->next_free == (unsigned long )__value___13) {
#line 639
      __o1___13->maybe_empty_object = 1U;
    }
#line 639
    if (sizeof(int ) < sizeof(void *)) {
#line 639
      tmp___79 = __o1___13->object_base;
    } else {
#line 639
      tmp___79 = (char *)0;
    }
#line 639
    if (sizeof(int ) < sizeof(void *)) {
#line 639
      tmp___80 = __o1___13->object_base;
    } else {
#line 639
      tmp___80 = (char *)0;
    }
#line 639
    __o1___13->next_free = tmp___79 + (((__o1___13->next_free - tmp___80) + (long )__o1___13->alignment_mask) & (long )(~ __o1___13->alignment_mask));
#line 639
    if (__o1___13->next_free - (char *)__o1___13->chunk > __o1___13->chunk_limit - (char *)__o1___13->chunk) {
#line 639
      __o1___13->next_free = __o1___13->chunk_limit;
    }
    {
#line 639
    __o1___13->object_base = __o1___13->next_free;
#line 639
    muscle_insert("spec_defines_file", (char const   *)__value___13);
    }
#line 639
    goto while_break___41;
  }
  while_break___41: /* CIL Label */ ;
  }
  {
#line 640
  while (1) {
    while_continue___44: /* CIL Label */ ;
    {
#line 640
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 640
      if (spec_file_prefix) {
#line 640
        p___4 = spec_file_prefix;
      } else {
#line 640
        p___4 = "";
      }
      {
#line 640
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 640
        if (! *p___4) {
#line 640
          goto while_break___46;
        }
        {
#line 640
        if ((int const   )*p___4 == 36) {
#line 640
          goto case_36___4;
        }
#line 640
        if ((int const   )*p___4 == 64) {
#line 640
          goto case_64___4;
        }
#line 640
        if ((int const   )*p___4 == 91) {
#line 640
          goto case_91___4;
        }
#line 640
        if ((int const   )*p___4 == 93) {
#line 640
          goto case_93___4;
        }
#line 640
        goto switch_default___4;
        case_36___4: /* CIL Label */ 
        {
#line 640
        __o___49 = & muscle_obstack;
#line 640
        tmp___81 = strlen("$][");
#line 640
        __len___29 = (int )tmp___81;
        }
#line 640
        if ((unsigned long )(__o___49->next_free + __len___29) > (unsigned long )__o___49->chunk_limit) {
          {
#line 640
          _obstack_newchunk(__o___49, __len___29);
          }
        }
        {
#line 640
        memcpy((void */* __restrict  */)__o___49->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___29);
#line 640
        __o___49->next_free += __len___29;
        }
#line 640
        goto switch_break___4;
        case_64___4: /* CIL Label */ 
        {
#line 640
        __o___50 = & muscle_obstack;
#line 640
        tmp___82 = strlen("@@");
#line 640
        __len___30 = (int )tmp___82;
        }
#line 640
        if ((unsigned long )(__o___50->next_free + __len___30) > (unsigned long )__o___50->chunk_limit) {
          {
#line 640
          _obstack_newchunk(__o___50, __len___30);
          }
        }
        {
#line 640
        memcpy((void */* __restrict  */)__o___50->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___30);
#line 640
        __o___50->next_free += __len___30;
        }
#line 640
        goto switch_break___4;
        case_91___4: /* CIL Label */ 
        {
#line 640
        __o___51 = & muscle_obstack;
#line 640
        tmp___83 = strlen("@{");
#line 640
        __len___31 = (int )tmp___83;
        }
#line 640
        if ((unsigned long )(__o___51->next_free + __len___31) > (unsigned long )__o___51->chunk_limit) {
          {
#line 640
          _obstack_newchunk(__o___51, __len___31);
          }
        }
        {
#line 640
        memcpy((void */* __restrict  */)__o___51->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___31);
#line 640
        __o___51->next_free += __len___31;
        }
#line 640
        goto switch_break___4;
        case_93___4: /* CIL Label */ 
        {
#line 640
        __o___52 = & muscle_obstack;
#line 640
        tmp___84 = strlen("@}");
#line 640
        __len___32 = (int )tmp___84;
        }
#line 640
        if ((unsigned long )(__o___52->next_free + __len___32) > (unsigned long )__o___52->chunk_limit) {
          {
#line 640
          _obstack_newchunk(__o___52, __len___32);
          }
        }
        {
#line 640
        memcpy((void */* __restrict  */)__o___52->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___32);
#line 640
        __o___52->next_free += __len___32;
        }
#line 640
        goto switch_break___4;
        switch_default___4: /* CIL Label */ 
#line 640
        __o___53 = & muscle_obstack;
#line 640
        if ((unsigned long )(__o___53->next_free + 1) > (unsigned long )__o___53->chunk_limit) {
          {
#line 640
          _obstack_newchunk(__o___53, 1);
          }
        }
#line 640
        tmp___85 = __o___53->next_free;
#line 640
        (__o___53->next_free) ++;
#line 640
        *tmp___85 = (char )*p___4;
#line 640
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
#line 640
        p___4 ++;
      }
      while_break___46: /* CIL Label */ ;
      }
#line 640
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
#line 640
    __o___54 = & muscle_obstack;
#line 640
    if ((unsigned long )(__o___54->next_free + 1) > (unsigned long )__o___54->chunk_limit) {
      {
#line 640
      _obstack_newchunk(__o___54, 1);
      }
    }
#line 640
    tmp___86 = __o___54->next_free;
#line 640
    (__o___54->next_free) ++;
#line 640
    *tmp___86 = (char)0;
#line 640
    __o1___14 = & muscle_obstack;
#line 640
    __value___14 = (void *)__o1___14->object_base;
#line 640
    if ((unsigned long )__o1___14->next_free == (unsigned long )__value___14) {
#line 640
      __o1___14->maybe_empty_object = 1U;
    }
#line 640
    if (sizeof(int ) < sizeof(void *)) {
#line 640
      tmp___87 = __o1___14->object_base;
    } else {
#line 640
      tmp___87 = (char *)0;
    }
#line 640
    if (sizeof(int ) < sizeof(void *)) {
#line 640
      tmp___88 = __o1___14->object_base;
    } else {
#line 640
      tmp___88 = (char *)0;
    }
#line 640
    __o1___14->next_free = tmp___87 + (((__o1___14->next_free - tmp___88) + (long )__o1___14->alignment_mask) & (long )(~ __o1___14->alignment_mask));
#line 640
    if (__o1___14->next_free - (char *)__o1___14->chunk > __o1___14->chunk_limit - (char *)__o1___14->chunk) {
#line 640
      __o1___14->next_free = __o1___14->chunk_limit;
    }
    {
#line 640
    __o1___14->object_base = __o1___14->next_free;
#line 640
    muscle_insert("spec_file_prefix", (char const   *)__value___14);
    }
#line 640
    goto while_break___44;
  }
  while_break___44: /* CIL Label */ ;
  }
  {
#line 641
  while (1) {
    while_continue___47: /* CIL Label */ ;
    {
#line 641
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 641
      if (spec_graph_file) {
#line 641
        p___5 = (char const   *)spec_graph_file;
      } else {
#line 641
        p___5 = "";
      }
      {
#line 641
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 641
        if (! *p___5) {
#line 641
          goto while_break___49;
        }
        {
#line 641
        if ((int const   )*p___5 == 36) {
#line 641
          goto case_36___5;
        }
#line 641
        if ((int const   )*p___5 == 64) {
#line 641
          goto case_64___5;
        }
#line 641
        if ((int const   )*p___5 == 91) {
#line 641
          goto case_91___5;
        }
#line 641
        if ((int const   )*p___5 == 93) {
#line 641
          goto case_93___5;
        }
#line 641
        goto switch_default___5;
        case_36___5: /* CIL Label */ 
        {
#line 641
        __o___55 = & muscle_obstack;
#line 641
        tmp___89 = strlen("$][");
#line 641
        __len___33 = (int )tmp___89;
        }
#line 641
        if ((unsigned long )(__o___55->next_free + __len___33) > (unsigned long )__o___55->chunk_limit) {
          {
#line 641
          _obstack_newchunk(__o___55, __len___33);
          }
        }
        {
#line 641
        memcpy((void */* __restrict  */)__o___55->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___33);
#line 641
        __o___55->next_free += __len___33;
        }
#line 641
        goto switch_break___5;
        case_64___5: /* CIL Label */ 
        {
#line 641
        __o___56 = & muscle_obstack;
#line 641
        tmp___90 = strlen("@@");
#line 641
        __len___34 = (int )tmp___90;
        }
#line 641
        if ((unsigned long )(__o___56->next_free + __len___34) > (unsigned long )__o___56->chunk_limit) {
          {
#line 641
          _obstack_newchunk(__o___56, __len___34);
          }
        }
        {
#line 641
        memcpy((void */* __restrict  */)__o___56->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___34);
#line 641
        __o___56->next_free += __len___34;
        }
#line 641
        goto switch_break___5;
        case_91___5: /* CIL Label */ 
        {
#line 641
        __o___57 = & muscle_obstack;
#line 641
        tmp___91 = strlen("@{");
#line 641
        __len___35 = (int )tmp___91;
        }
#line 641
        if ((unsigned long )(__o___57->next_free + __len___35) > (unsigned long )__o___57->chunk_limit) {
          {
#line 641
          _obstack_newchunk(__o___57, __len___35);
          }
        }
        {
#line 641
        memcpy((void */* __restrict  */)__o___57->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___35);
#line 641
        __o___57->next_free += __len___35;
        }
#line 641
        goto switch_break___5;
        case_93___5: /* CIL Label */ 
        {
#line 641
        __o___58 = & muscle_obstack;
#line 641
        tmp___92 = strlen("@}");
#line 641
        __len___36 = (int )tmp___92;
        }
#line 641
        if ((unsigned long )(__o___58->next_free + __len___36) > (unsigned long )__o___58->chunk_limit) {
          {
#line 641
          _obstack_newchunk(__o___58, __len___36);
          }
        }
        {
#line 641
        memcpy((void */* __restrict  */)__o___58->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___36);
#line 641
        __o___58->next_free += __len___36;
        }
#line 641
        goto switch_break___5;
        switch_default___5: /* CIL Label */ 
#line 641
        __o___59 = & muscle_obstack;
#line 641
        if ((unsigned long )(__o___59->next_free + 1) > (unsigned long )__o___59->chunk_limit) {
          {
#line 641
          _obstack_newchunk(__o___59, 1);
          }
        }
#line 641
        tmp___93 = __o___59->next_free;
#line 641
        (__o___59->next_free) ++;
#line 641
        *tmp___93 = (char )*p___5;
#line 641
        goto switch_break___5;
        switch_break___5: /* CIL Label */ ;
        }
#line 641
        p___5 ++;
      }
      while_break___49: /* CIL Label */ ;
      }
#line 641
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
#line 641
    __o___60 = & muscle_obstack;
#line 641
    if ((unsigned long )(__o___60->next_free + 1) > (unsigned long )__o___60->chunk_limit) {
      {
#line 641
      _obstack_newchunk(__o___60, 1);
      }
    }
#line 641
    tmp___94 = __o___60->next_free;
#line 641
    (__o___60->next_free) ++;
#line 641
    *tmp___94 = (char)0;
#line 641
    __o1___15 = & muscle_obstack;
#line 641
    __value___15 = (void *)__o1___15->object_base;
#line 641
    if ((unsigned long )__o1___15->next_free == (unsigned long )__value___15) {
#line 641
      __o1___15->maybe_empty_object = 1U;
    }
#line 641
    if (sizeof(int ) < sizeof(void *)) {
#line 641
      tmp___95 = __o1___15->object_base;
    } else {
#line 641
      tmp___95 = (char *)0;
    }
#line 641
    if (sizeof(int ) < sizeof(void *)) {
#line 641
      tmp___96 = __o1___15->object_base;
    } else {
#line 641
      tmp___96 = (char *)0;
    }
#line 641
    __o1___15->next_free = tmp___95 + (((__o1___15->next_free - tmp___96) + (long )__o1___15->alignment_mask) & (long )(~ __o1___15->alignment_mask));
#line 641
    if (__o1___15->next_free - (char *)__o1___15->chunk > __o1___15->chunk_limit - (char *)__o1___15->chunk) {
#line 641
      __o1___15->next_free = __o1___15->chunk_limit;
    }
    {
#line 641
    __o1___15->object_base = __o1___15->next_free;
#line 641
    muscle_insert("spec_graph_file", (char const   *)__value___15);
    }
#line 641
    goto while_break___47;
  }
  while_break___47: /* CIL Label */ ;
  }
  {
#line 642
  while (1) {
    while_continue___50: /* CIL Label */ ;
    {
#line 642
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 642
      if (spec_name_prefix) {
#line 642
        p___6 = spec_name_prefix;
      } else {
#line 642
        p___6 = "";
      }
      {
#line 642
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 642
        if (! *p___6) {
#line 642
          goto while_break___52;
        }
        {
#line 642
        if ((int const   )*p___6 == 36) {
#line 642
          goto case_36___6;
        }
#line 642
        if ((int const   )*p___6 == 64) {
#line 642
          goto case_64___6;
        }
#line 642
        if ((int const   )*p___6 == 91) {
#line 642
          goto case_91___6;
        }
#line 642
        if ((int const   )*p___6 == 93) {
#line 642
          goto case_93___6;
        }
#line 642
        goto switch_default___6;
        case_36___6: /* CIL Label */ 
        {
#line 642
        __o___61 = & muscle_obstack;
#line 642
        tmp___97 = strlen("$][");
#line 642
        __len___37 = (int )tmp___97;
        }
#line 642
        if ((unsigned long )(__o___61->next_free + __len___37) > (unsigned long )__o___61->chunk_limit) {
          {
#line 642
          _obstack_newchunk(__o___61, __len___37);
          }
        }
        {
#line 642
        memcpy((void */* __restrict  */)__o___61->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___37);
#line 642
        __o___61->next_free += __len___37;
        }
#line 642
        goto switch_break___6;
        case_64___6: /* CIL Label */ 
        {
#line 642
        __o___62 = & muscle_obstack;
#line 642
        tmp___98 = strlen("@@");
#line 642
        __len___38 = (int )tmp___98;
        }
#line 642
        if ((unsigned long )(__o___62->next_free + __len___38) > (unsigned long )__o___62->chunk_limit) {
          {
#line 642
          _obstack_newchunk(__o___62, __len___38);
          }
        }
        {
#line 642
        memcpy((void */* __restrict  */)__o___62->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___38);
#line 642
        __o___62->next_free += __len___38;
        }
#line 642
        goto switch_break___6;
        case_91___6: /* CIL Label */ 
        {
#line 642
        __o___63 = & muscle_obstack;
#line 642
        tmp___99 = strlen("@{");
#line 642
        __len___39 = (int )tmp___99;
        }
#line 642
        if ((unsigned long )(__o___63->next_free + __len___39) > (unsigned long )__o___63->chunk_limit) {
          {
#line 642
          _obstack_newchunk(__o___63, __len___39);
          }
        }
        {
#line 642
        memcpy((void */* __restrict  */)__o___63->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___39);
#line 642
        __o___63->next_free += __len___39;
        }
#line 642
        goto switch_break___6;
        case_93___6: /* CIL Label */ 
        {
#line 642
        __o___64 = & muscle_obstack;
#line 642
        tmp___100 = strlen("@}");
#line 642
        __len___40 = (int )tmp___100;
        }
#line 642
        if ((unsigned long )(__o___64->next_free + __len___40) > (unsigned long )__o___64->chunk_limit) {
          {
#line 642
          _obstack_newchunk(__o___64, __len___40);
          }
        }
        {
#line 642
        memcpy((void */* __restrict  */)__o___64->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___40);
#line 642
        __o___64->next_free += __len___40;
        }
#line 642
        goto switch_break___6;
        switch_default___6: /* CIL Label */ 
#line 642
        __o___65 = & muscle_obstack;
#line 642
        if ((unsigned long )(__o___65->next_free + 1) > (unsigned long )__o___65->chunk_limit) {
          {
#line 642
          _obstack_newchunk(__o___65, 1);
          }
        }
#line 642
        tmp___101 = __o___65->next_free;
#line 642
        (__o___65->next_free) ++;
#line 642
        *tmp___101 = (char )*p___6;
#line 642
        goto switch_break___6;
        switch_break___6: /* CIL Label */ ;
        }
#line 642
        p___6 ++;
      }
      while_break___52: /* CIL Label */ ;
      }
#line 642
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
#line 642
    __o___66 = & muscle_obstack;
#line 642
    if ((unsigned long )(__o___66->next_free + 1) > (unsigned long )__o___66->chunk_limit) {
      {
#line 642
      _obstack_newchunk(__o___66, 1);
      }
    }
#line 642
    tmp___102 = __o___66->next_free;
#line 642
    (__o___66->next_free) ++;
#line 642
    *tmp___102 = (char)0;
#line 642
    __o1___16 = & muscle_obstack;
#line 642
    __value___16 = (void *)__o1___16->object_base;
#line 642
    if ((unsigned long )__o1___16->next_free == (unsigned long )__value___16) {
#line 642
      __o1___16->maybe_empty_object = 1U;
    }
#line 642
    if (sizeof(int ) < sizeof(void *)) {
#line 642
      tmp___103 = __o1___16->object_base;
    } else {
#line 642
      tmp___103 = (char *)0;
    }
#line 642
    if (sizeof(int ) < sizeof(void *)) {
#line 642
      tmp___104 = __o1___16->object_base;
    } else {
#line 642
      tmp___104 = (char *)0;
    }
#line 642
    __o1___16->next_free = tmp___103 + (((__o1___16->next_free - tmp___104) + (long )__o1___16->alignment_mask) & (long )(~ __o1___16->alignment_mask));
#line 642
    if (__o1___16->next_free - (char *)__o1___16->chunk > __o1___16->chunk_limit - (char *)__o1___16->chunk) {
#line 642
      __o1___16->next_free = __o1___16->chunk_limit;
    }
    {
#line 642
    __o1___16->object_base = __o1___16->next_free;
#line 642
    muscle_insert("spec_name_prefix", (char const   *)__value___16);
    }
#line 642
    goto while_break___50;
  }
  while_break___50: /* CIL Label */ ;
  }
  {
#line 643
  while (1) {
    while_continue___53: /* CIL Label */ ;
    {
#line 643
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 643
      if (spec_outfile) {
#line 643
        p___7 = spec_outfile;
      } else {
#line 643
        p___7 = "";
      }
      {
#line 643
      while (1) {
        while_continue___55: /* CIL Label */ ;
#line 643
        if (! *p___7) {
#line 643
          goto while_break___55;
        }
        {
#line 643
        if ((int const   )*p___7 == 36) {
#line 643
          goto case_36___7;
        }
#line 643
        if ((int const   )*p___7 == 64) {
#line 643
          goto case_64___7;
        }
#line 643
        if ((int const   )*p___7 == 91) {
#line 643
          goto case_91___7;
        }
#line 643
        if ((int const   )*p___7 == 93) {
#line 643
          goto case_93___7;
        }
#line 643
        goto switch_default___7;
        case_36___7: /* CIL Label */ 
        {
#line 643
        __o___67 = & muscle_obstack;
#line 643
        tmp___105 = strlen("$][");
#line 643
        __len___41 = (int )tmp___105;
        }
#line 643
        if ((unsigned long )(__o___67->next_free + __len___41) > (unsigned long )__o___67->chunk_limit) {
          {
#line 643
          _obstack_newchunk(__o___67, __len___41);
          }
        }
        {
#line 643
        memcpy((void */* __restrict  */)__o___67->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___41);
#line 643
        __o___67->next_free += __len___41;
        }
#line 643
        goto switch_break___7;
        case_64___7: /* CIL Label */ 
        {
#line 643
        __o___68 = & muscle_obstack;
#line 643
        tmp___106 = strlen("@@");
#line 643
        __len___42 = (int )tmp___106;
        }
#line 643
        if ((unsigned long )(__o___68->next_free + __len___42) > (unsigned long )__o___68->chunk_limit) {
          {
#line 643
          _obstack_newchunk(__o___68, __len___42);
          }
        }
        {
#line 643
        memcpy((void */* __restrict  */)__o___68->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___42);
#line 643
        __o___68->next_free += __len___42;
        }
#line 643
        goto switch_break___7;
        case_91___7: /* CIL Label */ 
        {
#line 643
        __o___69 = & muscle_obstack;
#line 643
        tmp___107 = strlen("@{");
#line 643
        __len___43 = (int )tmp___107;
        }
#line 643
        if ((unsigned long )(__o___69->next_free + __len___43) > (unsigned long )__o___69->chunk_limit) {
          {
#line 643
          _obstack_newchunk(__o___69, __len___43);
          }
        }
        {
#line 643
        memcpy((void */* __restrict  */)__o___69->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___43);
#line 643
        __o___69->next_free += __len___43;
        }
#line 643
        goto switch_break___7;
        case_93___7: /* CIL Label */ 
        {
#line 643
        __o___70 = & muscle_obstack;
#line 643
        tmp___108 = strlen("@}");
#line 643
        __len___44 = (int )tmp___108;
        }
#line 643
        if ((unsigned long )(__o___70->next_free + __len___44) > (unsigned long )__o___70->chunk_limit) {
          {
#line 643
          _obstack_newchunk(__o___70, __len___44);
          }
        }
        {
#line 643
        memcpy((void */* __restrict  */)__o___70->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___44);
#line 643
        __o___70->next_free += __len___44;
        }
#line 643
        goto switch_break___7;
        switch_default___7: /* CIL Label */ 
#line 643
        __o___71 = & muscle_obstack;
#line 643
        if ((unsigned long )(__o___71->next_free + 1) > (unsigned long )__o___71->chunk_limit) {
          {
#line 643
          _obstack_newchunk(__o___71, 1);
          }
        }
#line 643
        tmp___109 = __o___71->next_free;
#line 643
        (__o___71->next_free) ++;
#line 643
        *tmp___109 = (char )*p___7;
#line 643
        goto switch_break___7;
        switch_break___7: /* CIL Label */ ;
        }
#line 643
        p___7 ++;
      }
      while_break___55: /* CIL Label */ ;
      }
#line 643
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
#line 643
    __o___72 = & muscle_obstack;
#line 643
    if ((unsigned long )(__o___72->next_free + 1) > (unsigned long )__o___72->chunk_limit) {
      {
#line 643
      _obstack_newchunk(__o___72, 1);
      }
    }
#line 643
    tmp___110 = __o___72->next_free;
#line 643
    (__o___72->next_free) ++;
#line 643
    *tmp___110 = (char)0;
#line 643
    __o1___17 = & muscle_obstack;
#line 643
    __value___17 = (void *)__o1___17->object_base;
#line 643
    if ((unsigned long )__o1___17->next_free == (unsigned long )__value___17) {
#line 643
      __o1___17->maybe_empty_object = 1U;
    }
#line 643
    if (sizeof(int ) < sizeof(void *)) {
#line 643
      tmp___111 = __o1___17->object_base;
    } else {
#line 643
      tmp___111 = (char *)0;
    }
#line 643
    if (sizeof(int ) < sizeof(void *)) {
#line 643
      tmp___112 = __o1___17->object_base;
    } else {
#line 643
      tmp___112 = (char *)0;
    }
#line 643
    __o1___17->next_free = tmp___111 + (((__o1___17->next_free - tmp___112) + (long )__o1___17->alignment_mask) & (long )(~ __o1___17->alignment_mask));
#line 643
    if (__o1___17->next_free - (char *)__o1___17->chunk > __o1___17->chunk_limit - (char *)__o1___17->chunk) {
#line 643
      __o1___17->next_free = __o1___17->chunk_limit;
    }
    {
#line 643
    __o1___17->object_base = __o1___17->next_free;
#line 643
    muscle_insert("spec_outfile", (char const   *)__value___17);
    }
#line 643
    goto while_break___53;
  }
  while_break___53: /* CIL Label */ ;
  }
  {
#line 644
  while (1) {
    while_continue___56: /* CIL Label */ ;
    {
#line 644
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 644
      if (spec_verbose_file) {
#line 644
        p___8 = (char const   *)spec_verbose_file;
      } else {
#line 644
        p___8 = "";
      }
      {
#line 644
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 644
        if (! *p___8) {
#line 644
          goto while_break___58;
        }
        {
#line 644
        if ((int const   )*p___8 == 36) {
#line 644
          goto case_36___8;
        }
#line 644
        if ((int const   )*p___8 == 64) {
#line 644
          goto case_64___8;
        }
#line 644
        if ((int const   )*p___8 == 91) {
#line 644
          goto case_91___8;
        }
#line 644
        if ((int const   )*p___8 == 93) {
#line 644
          goto case_93___8;
        }
#line 644
        goto switch_default___8;
        case_36___8: /* CIL Label */ 
        {
#line 644
        __o___73 = & muscle_obstack;
#line 644
        tmp___113 = strlen("$][");
#line 644
        __len___45 = (int )tmp___113;
        }
#line 644
        if ((unsigned long )(__o___73->next_free + __len___45) > (unsigned long )__o___73->chunk_limit) {
          {
#line 644
          _obstack_newchunk(__o___73, __len___45);
          }
        }
        {
#line 644
        memcpy((void */* __restrict  */)__o___73->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___45);
#line 644
        __o___73->next_free += __len___45;
        }
#line 644
        goto switch_break___8;
        case_64___8: /* CIL Label */ 
        {
#line 644
        __o___74 = & muscle_obstack;
#line 644
        tmp___114 = strlen("@@");
#line 644
        __len___46 = (int )tmp___114;
        }
#line 644
        if ((unsigned long )(__o___74->next_free + __len___46) > (unsigned long )__o___74->chunk_limit) {
          {
#line 644
          _obstack_newchunk(__o___74, __len___46);
          }
        }
        {
#line 644
        memcpy((void */* __restrict  */)__o___74->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___46);
#line 644
        __o___74->next_free += __len___46;
        }
#line 644
        goto switch_break___8;
        case_91___8: /* CIL Label */ 
        {
#line 644
        __o___75 = & muscle_obstack;
#line 644
        tmp___115 = strlen("@{");
#line 644
        __len___47 = (int )tmp___115;
        }
#line 644
        if ((unsigned long )(__o___75->next_free + __len___47) > (unsigned long )__o___75->chunk_limit) {
          {
#line 644
          _obstack_newchunk(__o___75, __len___47);
          }
        }
        {
#line 644
        memcpy((void */* __restrict  */)__o___75->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___47);
#line 644
        __o___75->next_free += __len___47;
        }
#line 644
        goto switch_break___8;
        case_93___8: /* CIL Label */ 
        {
#line 644
        __o___76 = & muscle_obstack;
#line 644
        tmp___116 = strlen("@}");
#line 644
        __len___48 = (int )tmp___116;
        }
#line 644
        if ((unsigned long )(__o___76->next_free + __len___48) > (unsigned long )__o___76->chunk_limit) {
          {
#line 644
          _obstack_newchunk(__o___76, __len___48);
          }
        }
        {
#line 644
        memcpy((void */* __restrict  */)__o___76->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___48);
#line 644
        __o___76->next_free += __len___48;
        }
#line 644
        goto switch_break___8;
        switch_default___8: /* CIL Label */ 
#line 644
        __o___77 = & muscle_obstack;
#line 644
        if ((unsigned long )(__o___77->next_free + 1) > (unsigned long )__o___77->chunk_limit) {
          {
#line 644
          _obstack_newchunk(__o___77, 1);
          }
        }
#line 644
        tmp___117 = __o___77->next_free;
#line 644
        (__o___77->next_free) ++;
#line 644
        *tmp___117 = (char )*p___8;
#line 644
        goto switch_break___8;
        switch_break___8: /* CIL Label */ ;
        }
#line 644
        p___8 ++;
      }
      while_break___58: /* CIL Label */ ;
      }
#line 644
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
#line 644
    __o___78 = & muscle_obstack;
#line 644
    if ((unsigned long )(__o___78->next_free + 1) > (unsigned long )__o___78->chunk_limit) {
      {
#line 644
      _obstack_newchunk(__o___78, 1);
      }
    }
#line 644
    tmp___118 = __o___78->next_free;
#line 644
    (__o___78->next_free) ++;
#line 644
    *tmp___118 = (char)0;
#line 644
    __o1___18 = & muscle_obstack;
#line 644
    __value___18 = (void *)__o1___18->object_base;
#line 644
    if ((unsigned long )__o1___18->next_free == (unsigned long )__value___18) {
#line 644
      __o1___18->maybe_empty_object = 1U;
    }
#line 644
    if (sizeof(int ) < sizeof(void *)) {
#line 644
      tmp___119 = __o1___18->object_base;
    } else {
#line 644
      tmp___119 = (char *)0;
    }
#line 644
    if (sizeof(int ) < sizeof(void *)) {
#line 644
      tmp___120 = __o1___18->object_base;
    } else {
#line 644
      tmp___120 = (char *)0;
    }
#line 644
    __o1___18->next_free = tmp___119 + (((__o1___18->next_free - tmp___120) + (long )__o1___18->alignment_mask) & (long )(~ __o1___18->alignment_mask));
#line 644
    if (__o1___18->next_free - (char *)__o1___18->chunk > __o1___18->chunk_limit - (char *)__o1___18->chunk) {
#line 644
      __o1___18->next_free = __o1___18->chunk_limit;
    }
    {
#line 644
    __o1___18->object_base = __o1___18->next_free;
#line 644
    muscle_insert("spec_verbose_file", (char const   *)__value___18);
    }
#line 644
    goto while_break___56;
  }
  while_break___56: /* CIL Label */ ;
  }
#line 648
  if (skeleton) {
    {
#line 649
    while (1) {
      while_continue___59: /* CIL Label */ ;
      {
#line 649
      while (1) {
        while_continue___60: /* CIL Label */ ;
        {
#line 649
        tmp___121 = quotearg_style((enum quoting_style )3, skeleton);
#line 649
        p___9 = (char const   *)tmp___121;
        }
        {
#line 649
        while (1) {
          while_continue___61: /* CIL Label */ ;
#line 649
          if (! *p___9) {
#line 649
            goto while_break___61;
          }
          {
#line 649
          if ((int const   )*p___9 == 36) {
#line 649
            goto case_36___9;
          }
#line 649
          if ((int const   )*p___9 == 64) {
#line 649
            goto case_64___9;
          }
#line 649
          if ((int const   )*p___9 == 91) {
#line 649
            goto case_91___9;
          }
#line 649
          if ((int const   )*p___9 == 93) {
#line 649
            goto case_93___9;
          }
#line 649
          goto switch_default___9;
          case_36___9: /* CIL Label */ 
          {
#line 649
          __o___79 = & muscle_obstack;
#line 649
          tmp___122 = strlen("$][");
#line 649
          __len___49 = (int )tmp___122;
          }
#line 649
          if ((unsigned long )(__o___79->next_free + __len___49) > (unsigned long )__o___79->chunk_limit) {
            {
#line 649
            _obstack_newchunk(__o___79, __len___49);
            }
          }
          {
#line 649
          memcpy((void */* __restrict  */)__o___79->next_free, (void const   */* __restrict  */)"$][",
                 (size_t )__len___49);
#line 649
          __o___79->next_free += __len___49;
          }
#line 649
          goto switch_break___9;
          case_64___9: /* CIL Label */ 
          {
#line 649
          __o___80 = & muscle_obstack;
#line 649
          tmp___123 = strlen("@@");
#line 649
          __len___50 = (int )tmp___123;
          }
#line 649
          if ((unsigned long )(__o___80->next_free + __len___50) > (unsigned long )__o___80->chunk_limit) {
            {
#line 649
            _obstack_newchunk(__o___80, __len___50);
            }
          }
          {
#line 649
          memcpy((void */* __restrict  */)__o___80->next_free, (void const   */* __restrict  */)"@@",
                 (size_t )__len___50);
#line 649
          __o___80->next_free += __len___50;
          }
#line 649
          goto switch_break___9;
          case_91___9: /* CIL Label */ 
          {
#line 649
          __o___81 = & muscle_obstack;
#line 649
          tmp___124 = strlen("@{");
#line 649
          __len___51 = (int )tmp___124;
          }
#line 649
          if ((unsigned long )(__o___81->next_free + __len___51) > (unsigned long )__o___81->chunk_limit) {
            {
#line 649
            _obstack_newchunk(__o___81, __len___51);
            }
          }
          {
#line 649
          memcpy((void */* __restrict  */)__o___81->next_free, (void const   */* __restrict  */)"@{",
                 (size_t )__len___51);
#line 649
          __o___81->next_free += __len___51;
          }
#line 649
          goto switch_break___9;
          case_93___9: /* CIL Label */ 
          {
#line 649
          __o___82 = & muscle_obstack;
#line 649
          tmp___125 = strlen("@}");
#line 649
          __len___52 = (int )tmp___125;
          }
#line 649
          if ((unsigned long )(__o___82->next_free + __len___52) > (unsigned long )__o___82->chunk_limit) {
            {
#line 649
            _obstack_newchunk(__o___82, __len___52);
            }
          }
          {
#line 649
          memcpy((void */* __restrict  */)__o___82->next_free, (void const   */* __restrict  */)"@}",
                 (size_t )__len___52);
#line 649
          __o___82->next_free += __len___52;
          }
#line 649
          goto switch_break___9;
          switch_default___9: /* CIL Label */ 
#line 649
          __o___83 = & muscle_obstack;
#line 649
          if ((unsigned long )(__o___83->next_free + 1) > (unsigned long )__o___83->chunk_limit) {
            {
#line 649
            _obstack_newchunk(__o___83, 1);
            }
          }
#line 649
          tmp___126 = __o___83->next_free;
#line 649
          (__o___83->next_free) ++;
#line 649
          *tmp___126 = (char )*p___9;
#line 649
          goto switch_break___9;
          switch_break___9: /* CIL Label */ ;
          }
#line 649
          p___9 ++;
        }
        while_break___61: /* CIL Label */ ;
        }
#line 649
        goto while_break___60;
      }
      while_break___60: /* CIL Label */ ;
      }
#line 649
      __o___84 = & muscle_obstack;
#line 649
      if ((unsigned long )(__o___84->next_free + 1) > (unsigned long )__o___84->chunk_limit) {
        {
#line 649
        _obstack_newchunk(__o___84, 1);
        }
      }
#line 649
      tmp___127 = __o___84->next_free;
#line 649
      (__o___84->next_free) ++;
#line 649
      *tmp___127 = (char)0;
#line 649
      __o1___19 = & muscle_obstack;
#line 649
      __value___19 = (void *)__o1___19->object_base;
#line 649
      if ((unsigned long )__o1___19->next_free == (unsigned long )__value___19) {
#line 649
        __o1___19->maybe_empty_object = 1U;
      }
#line 649
      if (sizeof(int ) < sizeof(void *)) {
#line 649
        tmp___128 = __o1___19->object_base;
      } else {
#line 649
        tmp___128 = (char *)0;
      }
#line 649
      if (sizeof(int ) < sizeof(void *)) {
#line 649
        tmp___129 = __o1___19->object_base;
      } else {
#line 649
        tmp___129 = (char *)0;
      }
#line 649
      __o1___19->next_free = tmp___128 + (((__o1___19->next_free - tmp___129) + (long )__o1___19->alignment_mask) & (long )(~ __o1___19->alignment_mask));
#line 649
      if (__o1___19->next_free - (char *)__o1___19->chunk > __o1___19->chunk_limit - (char *)__o1___19->chunk) {
#line 649
        __o1___19->next_free = __o1___19->chunk_limit;
      }
      {
#line 649
      __o1___19->object_base = __o1___19->next_free;
#line 649
      muscle_insert("skeleton", (char const   *)__value___19);
      }
#line 649
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
  } else {
#line 651
    skeleton = (char const   *)(language->skeleton);
  }
  {
#line 658
  while (1) {
    while_continue___62: /* CIL Label */ ;
    {
#line 658
    __o___85 = & muscle_obstack;
#line 658
    tmp___130 = compute_pkgdatadir();
#line 658
    tmp___131 = strlen(tmp___130);
#line 658
    __len___53 = (int )tmp___131;
    }
#line 658
    if ((unsigned long )(__o___85->next_free + __len___53) > (unsigned long )__o___85->chunk_limit) {
      {
#line 658
      _obstack_newchunk(__o___85, __len___53);
      }
    }
    {
#line 658
    tmp___132 = compute_pkgdatadir();
#line 658
    memcpy((void */* __restrict  */)__o___85->next_free, (void const   */* __restrict  */)tmp___132,
           (size_t )__len___53);
#line 658
    __o___85->next_free += __len___53;
#line 658
    __o___86 = & muscle_obstack;
    }
#line 658
    if ((unsigned long )(__o___86->next_free + 1) > (unsigned long )__o___86->chunk_limit) {
      {
#line 658
      _obstack_newchunk(__o___86, 1);
      }
    }
#line 658
    tmp___133 = __o___86->next_free;
#line 658
    (__o___86->next_free) ++;
#line 658
    *tmp___133 = (char)0;
#line 658
    __o1___20 = & muscle_obstack;
#line 658
    __value___20 = (void *)__o1___20->object_base;
#line 658
    if ((unsigned long )__o1___20->next_free == (unsigned long )__value___20) {
#line 658
      __o1___20->maybe_empty_object = 1U;
    }
#line 658
    if (sizeof(int ) < sizeof(void *)) {
#line 658
      tmp___134 = __o1___20->object_base;
    } else {
#line 658
      tmp___134 = (char *)0;
    }
#line 658
    if (sizeof(int ) < sizeof(void *)) {
#line 658
      tmp___135 = __o1___20->object_base;
    } else {
#line 658
      tmp___135 = (char *)0;
    }
#line 658
    __o1___20->next_free = tmp___134 + (((__o1___20->next_free - tmp___135) + (long )__o1___20->alignment_mask) & (long )(~ __o1___20->alignment_mask));
#line 658
    if (__o1___20->next_free - (char *)__o1___20->chunk > __o1___20->chunk_limit - (char *)__o1___20->chunk) {
#line 658
      __o1___20->next_free = __o1___20->chunk_limit;
    }
    {
#line 658
    __o1___20->object_base = __o1___20->next_free;
#line 658
    muscle_insert("pkgdatadir", (char const   *)__value___20);
    }
#line 658
    goto while_break___62;
  }
  while_break___62: /* CIL Label */ ;
  }
#line 660
  return;
}
}
#line 667 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
void output(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
  {
#line 670
  _obstack_begin(& format_obstack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 672
  prepare_symbols();
#line 673
  prepare_rules();
#line 674
  prepare_states();
#line 675
  prepare_actions();
#line 677
  prepare();
#line 680
  output_skeleton();
#line 682
  __o = & format_obstack;
#line 682
  __obj = (void *)0;
  }
#line 682
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 682
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 682
      tmp = (char *)__obj;
#line 682
      __o->object_base = tmp;
#line 682
      __o->next_free = tmp;
    } else {
      {
#line 682
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 682
    obstack_free(__o, __obj);
    }
  }
#line 683
  return;
}
}
#line 685 "/home/pronto/abs/test-suite/bison-2.5/src/output.c"
char const   *compute_pkgdatadir(void) 
{ 
  char const   *pkgdatadir ;
  char *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 688
  tmp = getenv("BISON_PKGDATADIR");
#line 688
  pkgdatadir = (char const   *)tmp;
  }
#line 689
  if (pkgdatadir) {
#line 689
    tmp___0 = pkgdatadir;
  } else {
#line 689
    tmp___0 = "/usr/local/share/bison";
  }
#line 689
  return (tmp___0);
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/src/nullable.h"
_Bool *nullable ;
#line 28
void nullable_compute(void) ;
#line 31
void nullable_free(void) ;
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/nullable.c"
_Bool *nullable  =    (_Bool *)((void *)0);
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/nullable.c"
static void nullable_print(FILE *out ) 
{ 
  int i ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 48
  fputs_unlocked((char const   */* __restrict  */)"NULLABLE\n", (FILE */* __restrict  */)out);
#line 49
  i = ntokens;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i < nsyms)) {
#line 49
      goto while_break;
    }
#line 50
    if (*(nullable + (i - ntokens))) {
#line 50
      tmp = "yes";
    } else {
#line 50
      tmp = "no";
    }
    {
#line 50
    rpl_fprintf(out, "\t%s: %s\n", (*(symbols + i))->tag, tmp);
#line 49
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
  }
#line 53
  return;
}
}
#line 55 "/home/pronto/abs/test-suite/bison-2.5/src/nullable.c"
void nullable_compute(void) 
{ 
  rule_number ruleno ;
  symbol_number *s1 ;
  symbol_number *s2 ;
  rule_list *p ;
  symbol_number *squeue ;
  void *tmp ;
  size_t *rcount ;
  void *tmp___0 ;
  rule_list **rsets ;
  void *tmp___1 ;
  rule_list *relts ;
  void *tmp___2 ;
  void *tmp___3 ;
  rule *rules_ruleno ;
  item_number *rp ;
  _Bool any_tokens ;
  rule_number tmp___4 ;
  symbol_number *tmp___5 ;
  symbol_number *tmp___6 ;
  rule *r ;
  symbol_number *tmp___7 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 63
  tmp = xnmalloc((size_t )nvars, (size_t )sizeof(*squeue));
#line 63
  squeue = (symbol_number *)tmp;
#line 64
  tmp___0 = xcalloc((size_t )nrules, (size_t )sizeof(*rcount));
#line 64
  rcount = (size_t *)tmp___0;
#line 67
  tmp___1 = xcalloc((size_t )nvars, (size_t )sizeof(*rsets));
#line 67
  rsets = (rule_list **)tmp___1;
#line 70
  tmp___2 = xnmalloc((nritems + (unsigned int )nvars) + 1U, (size_t )sizeof(*relts));
#line 70
  relts = (rule_list *)tmp___2;
#line 72
  tmp___3 = xcalloc((size_t )nvars, (size_t )sizeof(*nullable));
#line 72
  nullable = (_Bool *)tmp___3;
#line 74
  s2 = squeue;
#line 74
  s1 = s2;
#line 75
  p = relts;
#line 77
  ruleno = 0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (ruleno < nrules)) {
#line 77
      goto while_break;
    }
#line 78
    if ((rules + ruleno)->useful) {
#line 80
      rules_ruleno = rules + ruleno;
#line 81
      if (*(rules_ruleno->rhs + 0) >= 0) {
#line 84
        rp = (item_number *)((void *)0);
#line 85
        any_tokens = (_Bool)0;
#line 86
        rp = rules_ruleno->rhs;
        {
#line 86
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 86
          if (! (*rp >= 0)) {
#line 86
            goto while_break___0;
          }
#line 87
          if (*rp < ntokens) {
#line 88
            any_tokens = (_Bool)1;
          }
#line 86
          rp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 92
        if (! any_tokens) {
#line 93
          rp = rules_ruleno->rhs;
          {
#line 93
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 93
            if (! (*rp >= 0)) {
#line 93
              goto while_break___1;
            }
#line 95
            (*(rcount + ruleno)) ++;
#line 96
            p->next = *(rsets + (*rp - ntokens));
#line 97
            p->value = rules_ruleno;
#line 98
            *(rsets + (*rp - ntokens)) = p;
#line 99
            p ++;
#line 93
            rp ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 105
        tmp___4 = item_number_as_rule_number(*(rules_ruleno->rhs + 0));
        }
#line 105
        if (! (tmp___4 == ruleno)) {
          {
#line 105
          __assert_fail("item_number_as_rule_number (rules_ruleno->rhs[0]) == ruleno",
                        "/home/pronto/abs/test-suite/bison-2.5/src/nullable.c", 106U,
                        "nullable_compute");
          }
        }
#line 107
        if (rules_ruleno->useful) {
#line 107
          if (! *(nullable + ((rules_ruleno->lhs)->number - ntokens))) {
#line 110
            *(nullable + ((rules_ruleno->lhs)->number - ntokens)) = (_Bool)1;
#line 111
            tmp___5 = s2;
#line 111
            s2 ++;
#line 111
            *tmp___5 = (rules_ruleno->lhs)->number;
          }
        }
      }
    }
#line 77
    ruleno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )s1 < (unsigned long )s2)) {
#line 116
      goto while_break___2;
    }
#line 117
    tmp___6 = s1;
#line 117
    s1 ++;
#line 117
    p = *(rsets + (*tmp___6 - ntokens));
    {
#line 117
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 117
      if (! p) {
#line 117
        goto while_break___3;
      }
#line 119
      r = p->value;
#line 120
      (*(rcount + r->number)) --;
#line 120
      if (*(rcount + r->number) == 0U) {
#line 121
        if (r->useful) {
#line 121
          if (! *(nullable + ((r->lhs)->number - ntokens))) {
#line 123
            *(nullable + ((r->lhs)->number - ntokens)) = (_Bool)1;
#line 124
            tmp___7 = s2;
#line 124
            s2 ++;
#line 124
            *tmp___7 = (r->lhs)->number;
          }
        }
      }
#line 117
      p = p->next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 128
  free((void *)squeue);
#line 129
  free((void *)rcount);
#line 130
  free((void *)rsets);
#line 131
  free((void *)relts);
  }
#line 133
  if (trace_flag & 8) {
    {
#line 134
    nullable_print(stderr);
    }
  }
#line 135
  return;
}
}
#line 138 "/home/pronto/abs/test-suite/bison-2.5/src/nullable.c"
void nullable_free(void) 
{ 


  {
  {
#line 141
  free((void *)nullable);
  }
#line 142
  return;
}
}
#line 25 "/home/pronto/abs/test-suite/bison-2.5/src/named-ref.c"
named_ref *named_ref_new(uniqstr id , location loc___0 ) 
{ 
  named_ref *res ;
  void *tmp ;

  {
  {
#line 28
  tmp = xmalloc((size_t )sizeof(*res));
#line 28
  res = (named_ref *)tmp;
#line 30
  res->id = id;
#line 31
  res->loc = loc___0;
  }
#line 33
  return (res);
}
}
#line 36 "/home/pronto/abs/test-suite/bison-2.5/src/named-ref.c"
named_ref *named_ref_copy(named_ref const   *r ) 
{ 
  named_ref *tmp ;

  {
  {
#line 39
  tmp = named_ref_new((uniqstr )r->id, (location )r->loc);
  }
#line 39
  return (tmp);
}
}
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/named-ref.c"
void named_ref_free(named_ref *r ) 
{ 


  {
  {
#line 45
  free((void *)r);
  }
#line 46
  return;
}
}
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 26 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.h"
void muscle_init(void) ;
#line 29
char *muscle_find(char const   *key ) ;
#line 30
void muscle_free(void) ;
#line 34 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.h"
struct obstack muscle_obstack  ;
#line 97
void muscle_grow(char const   *key , char const   *val , char const   *separator ) ;
#line 115
void muscle_location_grow(char const   *key , location loc___0 ) ;
#line 119
void muscle_boundary_grow(char const   *key , boundary bound ) ;
#line 124
void muscle_user_name_list_grow(char const   *key , char const   *user_name , location loc___0 ) ;
#line 160
location muscle_percent_define_get_loc(char const   *variable ) ;
#line 168
char const   *muscle_percent_define_get_syncline(char const   *variable ) ;
#line 174
_Bool muscle_percent_define_ifdef(char const   *variable ) ;
#line 147 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
void tr(char *s , char from , char to ) ;
#line 46 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
static struct hash_table *muscle_table  =    (struct hash_table *)((void *)0);
#line 48 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
static _Bool hash_compare_muscles(void const   *x , void const   *y ) 
{ 
  muscle_entry const   *m1 ;
  muscle_entry const   *m2 ;
  int tmp ;

  {
  {
#line 51
  m1 = (muscle_entry const   *)x;
#line 52
  m2 = (muscle_entry const   *)y;
#line 53
  tmp = strcmp((char const   *)m1->key, (char const   *)m2->key);
  }
#line 53
  return ((_Bool )(tmp == 0));
}
}
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
static size_t hash_muscle(void const   *x , size_t tablesize ) 
{ 
  muscle_entry const   *m ;
  size_t tmp ;

  {
  {
#line 59
  m = (muscle_entry const   *)x;
#line 60
  tmp = hash_string((char const   *)m->key, tablesize);
  }
#line 60
  return (tmp);
}
}
#line 68 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
static void muscle_entry_free(void *entry ) 
{ 
  muscle_entry *mentry ;

  {
  {
#line 71
  mentry = (muscle_entry *)entry;
#line 72
  free((void *)mentry->storage);
#line 73
  free((void *)mentry);
  }
#line 74
  return;
}
}
#line 76 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_init(void) 
{ 
  char const   *p ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o___4 ;
  char *tmp___4 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 80
  _obstack_begin(& muscle_obstack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 82
  muscle_table = hash_initialize((size_t )257, (Hash_tuning const   *)((void *)0),
                                 & hash_muscle, & hash_compare_muscles, & muscle_entry_free);
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 86
      p = "2.5";
      {
#line 86
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 86
        if (! *p) {
#line 86
          goto while_break___1;
        }
        {
#line 86
        if ((int const   )*p == 36) {
#line 86
          goto case_36;
        }
#line 86
        if ((int const   )*p == 64) {
#line 86
          goto case_64;
        }
#line 86
        if ((int const   )*p == 91) {
#line 86
          goto case_91;
        }
#line 86
        if ((int const   )*p == 93) {
#line 86
          goto case_93;
        }
#line 86
        goto switch_default;
        case_36: /* CIL Label */ 
        {
#line 86
        __o = & muscle_obstack;
#line 86
        tmp = strlen("$][");
#line 86
        __len = (int )tmp;
        }
#line 86
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 86
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 86
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len);
#line 86
        __o->next_free += __len;
        }
#line 86
        goto switch_break;
        case_64: /* CIL Label */ 
        {
#line 86
        __o___0 = & muscle_obstack;
#line 86
        tmp___0 = strlen("@@");
#line 86
        __len___0 = (int )tmp___0;
        }
#line 86
        if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
          {
#line 86
          _obstack_newchunk(__o___0, __len___0);
          }
        }
        {
#line 86
        memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___0);
#line 86
        __o___0->next_free += __len___0;
        }
#line 86
        goto switch_break;
        case_91: /* CIL Label */ 
        {
#line 86
        __o___1 = & muscle_obstack;
#line 86
        tmp___1 = strlen("@{");
#line 86
        __len___1 = (int )tmp___1;
        }
#line 86
        if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
          {
#line 86
          _obstack_newchunk(__o___1, __len___1);
          }
        }
        {
#line 86
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___1);
#line 86
        __o___1->next_free += __len___1;
        }
#line 86
        goto switch_break;
        case_93: /* CIL Label */ 
        {
#line 86
        __o___2 = & muscle_obstack;
#line 86
        tmp___2 = strlen("@}");
#line 86
        __len___2 = (int )tmp___2;
        }
#line 86
        if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
          {
#line 86
          _obstack_newchunk(__o___2, __len___2);
          }
        }
        {
#line 86
        memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___2);
#line 86
        __o___2->next_free += __len___2;
        }
#line 86
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 86
        __o___3 = & muscle_obstack;
#line 86
        if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
          {
#line 86
          _obstack_newchunk(__o___3, 1);
          }
        }
#line 86
        tmp___3 = __o___3->next_free;
#line 86
        (__o___3->next_free) ++;
#line 86
        *tmp___3 = (char )*p;
#line 86
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 86
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 86
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 86
    __o___4 = & muscle_obstack;
#line 86
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 86
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 86
    tmp___4 = __o___4->next_free;
#line 86
    (__o___4->next_free) ++;
#line 86
    *tmp___4 = (char)0;
#line 86
    __o1 = & muscle_obstack;
#line 86
    __value = (void *)__o1->object_base;
#line 86
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 86
      __o1->maybe_empty_object = 1U;
    }
#line 86
    if (sizeof(int ) < sizeof(void *)) {
#line 86
      tmp___5 = __o1->object_base;
    } else {
#line 86
      tmp___5 = (char *)0;
    }
#line 86
    if (sizeof(int ) < sizeof(void *)) {
#line 86
      tmp___6 = __o1->object_base;
    } else {
#line 86
      tmp___6 = (char *)0;
    }
#line 86
    __o1->next_free = tmp___5 + (((__o1->next_free - tmp___6) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 86
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 86
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 86
    __o1->object_base = __o1->next_free;
#line 86
    muscle_insert("version", (char const   *)__value);
    }
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 94 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
  {
#line 97
  hash_free(muscle_table);
#line 98
  __o = & muscle_obstack;
#line 98
  __obj = (void *)0;
  }
#line 98
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 98
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 98
      tmp = (char *)__obj;
#line 98
      __o->object_base = tmp;
#line 98
      __o->next_free = tmp;
    } else {
      {
#line 98
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 98
    obstack_free(__o, __obj);
    }
  }
#line 99
  return;
}
}
#line 108 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_insert(char const   *key , char const   *value ) 
{ 
  muscle_entry probe ;
  muscle_entry *entry ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 114
  probe.key = key;
#line 115
  tmp = hash_lookup((Hash_table const   *)muscle_table, (void const   *)(& probe));
#line 115
  entry = (muscle_entry *)tmp;
  }
#line 117
  if (! entry) {
    {
#line 120
    tmp___0 = xmalloc((size_t )sizeof(*entry));
#line 120
    entry = (muscle_entry *)tmp___0;
#line 121
    entry->key = key;
#line 122
    tmp___1 = hash_insert(muscle_table, (void const   *)entry);
    }
#line 122
    if (! tmp___1) {
      {
#line 123
      xalloc_die();
      }
    }
  } else {
    {
#line 126
    free((void *)entry->storage);
    }
  }
#line 127
  entry->value = value;
#line 128
  entry->storage = (char *)((void *)0);
#line 129
  return;
}
}
#line 138 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_grow(char const   *key , char const   *val , char const   *separator ) 
{ 
  muscle_entry probe ;
  muscle_entry *entry ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *new_val ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___3 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___4 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___5 ;
  struct obstack *__o___2 ;
  char *tmp___6 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  struct obstack *__o___3 ;
  void *__obj ;
  char *tmp___10 ;

  {
  {
#line 142
  entry = (muscle_entry *)((void *)0);
#line 144
  probe.key = key;
#line 145
  tmp = hash_lookup((Hash_table const   *)muscle_table, (void const   *)(& probe));
#line 145
  entry = (muscle_entry *)tmp;
  }
#line 147
  if (! entry) {
    {
#line 150
    tmp___0 = xmalloc((size_t )sizeof(*entry));
#line 150
    entry = (muscle_entry *)tmp___0;
#line 151
    entry->key = key;
#line 152
    tmp___1 = hash_insert(muscle_table, (void const   *)entry);
    }
#line 152
    if (! tmp___1) {
      {
#line 153
      xalloc_die();
      }
    }
    {
#line 154
    tmp___2 = xstrdup(val);
#line 154
    entry->storage = tmp___2;
#line 154
    entry->value = (char const   *)tmp___2;
    }
  } else {
    {
#line 160
    __o = & muscle_obstack;
#line 160
    tmp___3 = strlen(entry->value);
#line 160
    __len = (int )tmp___3;
    }
#line 160
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 160
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 160
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)entry->value,
           (size_t )__len);
#line 160
    __o->next_free += __len;
#line 161
    free((void *)entry->storage);
#line 162
    __o___0 = & muscle_obstack;
#line 162
    tmp___4 = strlen(separator);
#line 162
    __len___0 = (int )tmp___4;
    }
#line 162
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 162
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 162
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)separator,
           (size_t )__len___0);
#line 162
    __o___0->next_free += __len___0;
#line 163
    __o___1 = & muscle_obstack;
#line 163
    tmp___5 = strlen(val);
#line 163
    __len___1 = (int )tmp___5;
    }
#line 163
    if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 163
      _obstack_newchunk(__o___1, __len___1);
      }
    }
    {
#line 163
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)val,
           (size_t )__len___1);
#line 163
    __o___1->next_free += __len___1;
#line 164
    __o___2 = & muscle_obstack;
    }
#line 164
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 164
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 164
    tmp___6 = __o___2->next_free;
#line 164
    (__o___2->next_free) ++;
#line 164
    *tmp___6 = (char)0;
#line 165
    __o1 = & muscle_obstack;
#line 165
    __value = (void *)__o1->object_base;
#line 165
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 165
      __o1->maybe_empty_object = 1U;
    }
#line 165
    if (sizeof(int ) < sizeof(void *)) {
#line 165
      tmp___7 = __o1->object_base;
    } else {
#line 165
      tmp___7 = (char *)0;
    }
#line 165
    if (sizeof(int ) < sizeof(void *)) {
#line 165
      tmp___8 = __o1->object_base;
    } else {
#line 165
      tmp___8 = (char *)0;
    }
#line 165
    __o1->next_free = tmp___7 + (((__o1->next_free - tmp___8) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 165
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 165
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 165
    __o1->object_base = __o1->next_free;
#line 165
    new_val = (char *)__value;
#line 166
    tmp___9 = xstrdup((char const   *)new_val);
#line 166
    entry->storage = tmp___9;
#line 166
    entry->value = (char const   *)tmp___9;
#line 167
    __o___3 = & muscle_obstack;
#line 167
    __obj = (void *)new_val;
    }
#line 167
    if ((unsigned long )__obj > (unsigned long )((void *)__o___3->chunk)) {
#line 167
      if ((unsigned long )__obj < (unsigned long )((void *)__o___3->chunk_limit)) {
#line 167
        tmp___10 = (char *)__obj;
#line 167
        __o___3->object_base = tmp___10;
#line 167
        __o___3->next_free = tmp___10;
      } else {
        {
#line 167
        obstack_free(__o___3, __obj);
        }
      }
    } else {
      {
#line 167
      obstack_free(__o___3, __obj);
      }
    }
  }
#line 169
  return;
}
}
#line 176 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
static void muscle_syncline_grow(char const   *key , location loc___0 ) 
{ 
  char *extension ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  char const   *p ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___1 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___3 ;
  struct obstack *__o___3 ;
  int __len___3 ;
  size_t tmp___4 ;
  struct obstack *__o___4 ;
  char *tmp___5 ;
  struct obstack *__o___5 ;
  int __len___4 ;
  size_t tmp___6 ;
  struct obstack *__o___6 ;
  char *tmp___7 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___8 ;
  char *tmp___9 ;
  struct obstack *__o___7 ;
  void *__obj ;
  char *tmp___10 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 179
  extension = (char *)((void *)0);
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 180
    rpl_sprintf(buf___0, "]b4_syncline(%d, [[", loc___0.start.line);
#line 180
    __o = & muscle_obstack;
#line 180
    tmp = strlen((char const   *)(buf___0));
#line 180
    __len = (int )tmp;
    }
#line 180
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 180
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 180
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 180
    __o->next_free += __len;
    }
#line 180
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 181
    tmp___0 = quotearg_style((enum quoting_style )3, loc___0.start.file);
#line 181
    p = (char const   *)tmp___0;
    }
    {
#line 181
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 181
      if (! *p) {
#line 181
        goto while_break___1;
      }
      {
#line 181
      if ((int const   )*p == 36) {
#line 181
        goto case_36;
      }
#line 181
      if ((int const   )*p == 64) {
#line 181
        goto case_64;
      }
#line 181
      if ((int const   )*p == 91) {
#line 181
        goto case_91;
      }
#line 181
      if ((int const   )*p == 93) {
#line 181
        goto case_93;
      }
#line 181
      goto switch_default;
      case_36: /* CIL Label */ 
      {
#line 181
      __o___0 = & muscle_obstack;
#line 181
      tmp___1 = strlen("$][");
#line 181
      __len___0 = (int )tmp___1;
      }
#line 181
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 181
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"$][",
             (size_t )__len___0);
#line 181
      __o___0->next_free += __len___0;
      }
#line 181
      goto switch_break;
      case_64: /* CIL Label */ 
      {
#line 181
      __o___1 = & muscle_obstack;
#line 181
      tmp___2 = strlen("@@");
#line 181
      __len___1 = (int )tmp___2;
      }
#line 181
      if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___1, __len___1);
        }
      }
      {
#line 181
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@@",
             (size_t )__len___1);
#line 181
      __o___1->next_free += __len___1;
      }
#line 181
      goto switch_break;
      case_91: /* CIL Label */ 
      {
#line 181
      __o___2 = & muscle_obstack;
#line 181
      tmp___3 = strlen("@{");
#line 181
      __len___2 = (int )tmp___3;
      }
#line 181
      if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___2, __len___2);
        }
      }
      {
#line 181
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@{",
             (size_t )__len___2);
#line 181
      __o___2->next_free += __len___2;
      }
#line 181
      goto switch_break;
      case_93: /* CIL Label */ 
      {
#line 181
      __o___3 = & muscle_obstack;
#line 181
      tmp___4 = strlen("@}");
#line 181
      __len___3 = (int )tmp___4;
      }
#line 181
      if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___3, __len___3);
        }
      }
      {
#line 181
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)"@}",
             (size_t )__len___3);
#line 181
      __o___3->next_free += __len___3;
      }
#line 181
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 181
      __o___4 = & muscle_obstack;
#line 181
      if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___4, 1);
        }
      }
#line 181
      tmp___5 = __o___4->next_free;
#line 181
      (__o___4->next_free) ++;
#line 181
      *tmp___5 = (char )*p;
#line 181
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 181
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 181
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 183
  __o___5 = & muscle_obstack;
#line 183
  tmp___6 = strlen("]])[");
#line 183
  __len___4 = (int )tmp___6;
  }
#line 183
  if ((unsigned long )(__o___5->next_free + __len___4) > (unsigned long )__o___5->chunk_limit) {
    {
#line 183
    _obstack_newchunk(__o___5, __len___4);
    }
  }
  {
#line 183
  memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)"]])[",
         (size_t )__len___4);
#line 183
  __o___5->next_free += __len___4;
#line 184
  __o___6 = & muscle_obstack;
  }
#line 184
  if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
    {
#line 184
    _obstack_newchunk(__o___6, 1);
    }
  }
#line 184
  tmp___7 = __o___6->next_free;
#line 184
  (__o___6->next_free) ++;
#line 184
  *tmp___7 = (char)0;
#line 185
  __o1 = & muscle_obstack;
#line 185
  __value = (void *)__o1->object_base;
#line 185
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 185
    __o1->maybe_empty_object = 1U;
  }
#line 185
  if (sizeof(int ) < sizeof(void *)) {
#line 185
    tmp___8 = __o1->object_base;
  } else {
#line 185
    tmp___8 = (char *)0;
  }
#line 185
  if (sizeof(int ) < sizeof(void *)) {
#line 185
    tmp___9 = __o1->object_base;
  } else {
#line 185
    tmp___9 = (char *)0;
  }
#line 185
  __o1->next_free = tmp___8 + (((__o1->next_free - tmp___9) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 185
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 185
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 185
  __o1->object_base = __o1->next_free;
#line 185
  extension = (char *)__value;
#line 186
  muscle_grow(key, (char const   *)extension, "");
#line 187
  __o___7 = & muscle_obstack;
#line 187
  __obj = (void *)extension;
  }
#line 187
  if ((unsigned long )__obj > (unsigned long )((void *)__o___7->chunk)) {
#line 187
    if ((unsigned long )__obj < (unsigned long )((void *)__o___7->chunk_limit)) {
#line 187
      tmp___10 = (char *)__obj;
#line 187
      __o___7->object_base = tmp___10;
#line 187
      __o___7->next_free = tmp___10;
    } else {
      {
#line 187
      obstack_free(__o___7, __obj);
      }
    }
  } else {
    {
#line 187
    obstack_free(__o___7, __obj);
    }
  }
#line 188
  return;
}
}
#line 196 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_code_grow(char const   *key , char const   *val , location loc___0 ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 199
  muscle_syncline_grow(key, loc___0);
#line 200
  muscle_grow(key, val, "\n");
  }
#line 201
  return;
}
}
#line 204 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_pair_list_grow(char const   *muscle , char const   *a1 , char const   *a2 ) 
{ 
  char *pair ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  char const   *p ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  int __len___3 ;
  size_t tmp___3 ;
  struct obstack *__o___4 ;
  char *tmp___4 ;
  struct obstack *__o___5 ;
  int __len___4 ;
  size_t tmp___5 ;
  char const   *p___0 ;
  struct obstack *__o___6 ;
  int __len___5 ;
  size_t tmp___6 ;
  struct obstack *__o___7 ;
  int __len___6 ;
  size_t tmp___7 ;
  struct obstack *__o___8 ;
  int __len___7 ;
  size_t tmp___8 ;
  struct obstack *__o___9 ;
  int __len___8 ;
  size_t tmp___9 ;
  struct obstack *__o___10 ;
  char *tmp___10 ;
  struct obstack *__o___11 ;
  int __len___9 ;
  size_t tmp___11 ;
  struct obstack *__o___12 ;
  char *tmp___12 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___13 ;
  char *tmp___14 ;
  struct obstack *__o___13 ;
  void *__obj ;
  char *tmp___15 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;

  {
  {
#line 208
  __o = & muscle_obstack;
#line 208
  tmp = strlen("[[[");
#line 208
  __len = (int )tmp;
  }
#line 208
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 208
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 208
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"[[[",
         (size_t )__len);
#line 208
  __o->next_free += __len;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    p = a1;
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if (! *p) {
#line 209
        goto while_break___0;
      }
      {
#line 209
      if ((int const   )*p == 36) {
#line 209
        goto case_36;
      }
#line 209
      if ((int const   )*p == 64) {
#line 209
        goto case_64;
      }
#line 209
      if ((int const   )*p == 91) {
#line 209
        goto case_91;
      }
#line 209
      if ((int const   )*p == 93) {
#line 209
        goto case_93;
      }
#line 209
      goto switch_default;
      case_36: /* CIL Label */ 
      {
#line 209
      __o___0 = & muscle_obstack;
#line 209
      tmp___0 = strlen("$][");
#line 209
      __len___0 = (int )tmp___0;
      }
#line 209
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 209
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"$][",
             (size_t )__len___0);
#line 209
      __o___0->next_free += __len___0;
      }
#line 209
      goto switch_break;
      case_64: /* CIL Label */ 
      {
#line 209
      __o___1 = & muscle_obstack;
#line 209
      tmp___1 = strlen("@@");
#line 209
      __len___1 = (int )tmp___1;
      }
#line 209
      if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___1, __len___1);
        }
      }
      {
#line 209
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@@",
             (size_t )__len___1);
#line 209
      __o___1->next_free += __len___1;
      }
#line 209
      goto switch_break;
      case_91: /* CIL Label */ 
      {
#line 209
      __o___2 = & muscle_obstack;
#line 209
      tmp___2 = strlen("@{");
#line 209
      __len___2 = (int )tmp___2;
      }
#line 209
      if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___2, __len___2);
        }
      }
      {
#line 209
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@{",
             (size_t )__len___2);
#line 209
      __o___2->next_free += __len___2;
      }
#line 209
      goto switch_break;
      case_93: /* CIL Label */ 
      {
#line 209
      __o___3 = & muscle_obstack;
#line 209
      tmp___3 = strlen("@}");
#line 209
      __len___3 = (int )tmp___3;
      }
#line 209
      if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___3, __len___3);
        }
      }
      {
#line 209
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)"@}",
             (size_t )__len___3);
#line 209
      __o___3->next_free += __len___3;
      }
#line 209
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 209
      __o___4 = & muscle_obstack;
#line 209
      if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___4, 1);
        }
      }
#line 209
      tmp___4 = __o___4->next_free;
#line 209
      (__o___4->next_free) ++;
#line 209
      *tmp___4 = (char )*p;
#line 209
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 209
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 209
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  __o___5 = & muscle_obstack;
#line 210
  tmp___5 = strlen("]], [[");
#line 210
  __len___4 = (int )tmp___5;
  }
#line 210
  if ((unsigned long )(__o___5->next_free + __len___4) > (unsigned long )__o___5->chunk_limit) {
    {
#line 210
    _obstack_newchunk(__o___5, __len___4);
    }
  }
  {
#line 210
  memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)"]], [[",
         (size_t )__len___4);
#line 210
  __o___5->next_free += __len___4;
  }
  {
#line 211
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 211
    p___0 = a2;
    {
#line 211
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 211
      if (! *p___0) {
#line 211
        goto while_break___2;
      }
      {
#line 211
      if ((int const   )*p___0 == 36) {
#line 211
        goto case_36___0;
      }
#line 211
      if ((int const   )*p___0 == 64) {
#line 211
        goto case_64___0;
      }
#line 211
      if ((int const   )*p___0 == 91) {
#line 211
        goto case_91___0;
      }
#line 211
      if ((int const   )*p___0 == 93) {
#line 211
        goto case_93___0;
      }
#line 211
      goto switch_default___0;
      case_36___0: /* CIL Label */ 
      {
#line 211
      __o___6 = & muscle_obstack;
#line 211
      tmp___6 = strlen("$][");
#line 211
      __len___5 = (int )tmp___6;
      }
#line 211
      if ((unsigned long )(__o___6->next_free + __len___5) > (unsigned long )__o___6->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___6, __len___5);
        }
      }
      {
#line 211
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)"$][",
             (size_t )__len___5);
#line 211
      __o___6->next_free += __len___5;
      }
#line 211
      goto switch_break___0;
      case_64___0: /* CIL Label */ 
      {
#line 211
      __o___7 = & muscle_obstack;
#line 211
      tmp___7 = strlen("@@");
#line 211
      __len___6 = (int )tmp___7;
      }
#line 211
      if ((unsigned long )(__o___7->next_free + __len___6) > (unsigned long )__o___7->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___7, __len___6);
        }
      }
      {
#line 211
      memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)"@@",
             (size_t )__len___6);
#line 211
      __o___7->next_free += __len___6;
      }
#line 211
      goto switch_break___0;
      case_91___0: /* CIL Label */ 
      {
#line 211
      __o___8 = & muscle_obstack;
#line 211
      tmp___8 = strlen("@{");
#line 211
      __len___7 = (int )tmp___8;
      }
#line 211
      if ((unsigned long )(__o___8->next_free + __len___7) > (unsigned long )__o___8->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___8, __len___7);
        }
      }
      {
#line 211
      memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)"@{",
             (size_t )__len___7);
#line 211
      __o___8->next_free += __len___7;
      }
#line 211
      goto switch_break___0;
      case_93___0: /* CIL Label */ 
      {
#line 211
      __o___9 = & muscle_obstack;
#line 211
      tmp___9 = strlen("@}");
#line 211
      __len___8 = (int )tmp___9;
      }
#line 211
      if ((unsigned long )(__o___9->next_free + __len___8) > (unsigned long )__o___9->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___9, __len___8);
        }
      }
      {
#line 211
      memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)"@}",
             (size_t )__len___8);
#line 211
      __o___9->next_free += __len___8;
      }
#line 211
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 211
      __o___10 = & muscle_obstack;
#line 211
      if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___10, 1);
        }
      }
#line 211
      tmp___10 = __o___10->next_free;
#line 211
      (__o___10->next_free) ++;
#line 211
      *tmp___10 = (char )*p___0;
#line 211
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 211
      p___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 211
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 212
  __o___11 = & muscle_obstack;
#line 212
  tmp___11 = strlen("]]]");
#line 212
  __len___9 = (int )tmp___11;
  }
#line 212
  if ((unsigned long )(__o___11->next_free + __len___9) > (unsigned long )__o___11->chunk_limit) {
    {
#line 212
    _obstack_newchunk(__o___11, __len___9);
    }
  }
  {
#line 212
  memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)"]]]",
         (size_t )__len___9);
#line 212
  __o___11->next_free += __len___9;
#line 213
  __o___12 = & muscle_obstack;
  }
#line 213
  if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
    {
#line 213
    _obstack_newchunk(__o___12, 1);
    }
  }
#line 213
  tmp___12 = __o___12->next_free;
#line 213
  (__o___12->next_free) ++;
#line 213
  *tmp___12 = (char)0;
#line 214
  __o1 = & muscle_obstack;
#line 214
  __value = (void *)__o1->object_base;
#line 214
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 214
    __o1->maybe_empty_object = 1U;
  }
#line 214
  if (sizeof(int ) < sizeof(void *)) {
#line 214
    tmp___13 = __o1->object_base;
  } else {
#line 214
    tmp___13 = (char *)0;
  }
#line 214
  if (sizeof(int ) < sizeof(void *)) {
#line 214
    tmp___14 = __o1->object_base;
  } else {
#line 214
    tmp___14 = (char *)0;
  }
#line 214
  __o1->next_free = tmp___13 + (((__o1->next_free - tmp___14) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 214
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 214
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 214
  __o1->object_base = __o1->next_free;
#line 214
  pair = (char *)__value;
#line 215
  muscle_grow(muscle, (char const   *)pair, ",\n");
#line 216
  __o___13 = & muscle_obstack;
#line 216
  __obj = (void *)pair;
  }
#line 216
  if ((unsigned long )__obj > (unsigned long )((void *)__o___13->chunk)) {
#line 216
    if ((unsigned long )__obj < (unsigned long )((void *)__o___13->chunk_limit)) {
#line 216
      tmp___15 = (char *)__obj;
#line 216
      __o___13->object_base = tmp___15;
#line 216
      __o___13->next_free = tmp___15;
    } else {
      {
#line 216
      obstack_free(__o___13, __obj);
      }
    }
  } else {
    {
#line 216
    obstack_free(__o___13, __obj);
    }
  }
#line 217
  return;
}
}
#line 225 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
char const   *muscle_find_const(char const   *key ) 
{ 
  muscle_entry probe ;
  muscle_entry *result ;
  void *tmp ;

  {
  {
#line 229
  result = (muscle_entry *)((void *)0);
#line 231
  probe.key = key;
#line 232
  tmp = hash_lookup((Hash_table const   *)muscle_table, (void const   *)(& probe));
#line 232
  result = (muscle_entry *)tmp;
  }
#line 233
  if (result) {
#line 234
    return (result->value);
  }
#line 235
  return ((char const   *)((void *)0));
}
}
#line 245 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
char *muscle_find(char const   *key ) 
{ 
  muscle_entry probe ;
  muscle_entry *result ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 249
  result = (muscle_entry *)((void *)0);
#line 251
  probe.key = key;
#line 252
  tmp = hash_lookup((Hash_table const   *)muscle_table, (void const   *)(& probe));
#line 252
  result = (muscle_entry *)tmp;
  }
#line 253
  if (result) {
#line 255
    if (! ((unsigned long )result->value == (unsigned long )result->storage)) {
      {
#line 255
      __assert_fail("result->value == result->storage", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                    255U, "muscle_find");
      }
    }
#line 256
    return (result->storage);
  }
#line 258
  return ((char *)((void *)0));
}
}
#line 262 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_boundary_grow(char const   *key , boundary bound ) 
{ 
  char *extension ;
  char const   *p ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o___4 ;
  char *tmp___4 ;
  char buf___0[4096] ;
  struct obstack *__o___5 ;
  int __len___3 ;
  size_t tmp___5 ;
  struct obstack *__o___6 ;
  char *tmp___6 ;
  char buf___1[4096] ;
  struct obstack *__o___7 ;
  int __len___4 ;
  size_t tmp___7 ;
  struct obstack *__o___8 ;
  char *tmp___8 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct obstack *__o___9 ;
  void *__obj ;
  char *tmp___11 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    p = bound.file;
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (! *p) {
#line 266
        goto while_break___0;
      }
      {
#line 266
      if ((int const   )*p == 36) {
#line 266
        goto case_36;
      }
#line 266
      if ((int const   )*p == 64) {
#line 266
        goto case_64;
      }
#line 266
      if ((int const   )*p == 91) {
#line 266
        goto case_91;
      }
#line 266
      if ((int const   )*p == 93) {
#line 266
        goto case_93;
      }
#line 266
      goto switch_default;
      case_36: /* CIL Label */ 
      {
#line 266
      __o = & muscle_obstack;
#line 266
      tmp = strlen("$][");
#line 266
      __len = (int )tmp;
      }
#line 266
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 266
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$][",
             (size_t )__len);
#line 266
      __o->next_free += __len;
      }
#line 266
      goto switch_break;
      case_64: /* CIL Label */ 
      {
#line 266
      __o___0 = & muscle_obstack;
#line 266
      tmp___0 = strlen("@@");
#line 266
      __len___0 = (int )tmp___0;
      }
#line 266
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 266
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@@",
             (size_t )__len___0);
#line 266
      __o___0->next_free += __len___0;
      }
#line 266
      goto switch_break;
      case_91: /* CIL Label */ 
      {
#line 266
      __o___1 = & muscle_obstack;
#line 266
      tmp___1 = strlen("@{");
#line 266
      __len___1 = (int )tmp___1;
      }
#line 266
      if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o___1, __len___1);
        }
      }
      {
#line 266
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@{",
             (size_t )__len___1);
#line 266
      __o___1->next_free += __len___1;
      }
#line 266
      goto switch_break;
      case_93: /* CIL Label */ 
      {
#line 266
      __o___2 = & muscle_obstack;
#line 266
      tmp___2 = strlen("@}");
#line 266
      __len___2 = (int )tmp___2;
      }
#line 266
      if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o___2, __len___2);
        }
      }
      {
#line 266
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@}",
             (size_t )__len___2);
#line 266
      __o___2->next_free += __len___2;
      }
#line 266
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 266
      __o___3 = & muscle_obstack;
#line 266
      if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o___3, 1);
        }
      }
#line 266
      tmp___3 = __o___3->next_free;
#line 266
      (__o___3->next_free) ++;
#line 266
      *tmp___3 = (char )*p;
#line 266
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 266
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 266
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  __o___4 = & muscle_obstack;
#line 267
  if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
    {
#line 267
    _obstack_newchunk(__o___4, 1);
    }
  }
#line 267
  tmp___4 = __o___4->next_free;
#line 267
  (__o___4->next_free) ++;
#line 267
  *tmp___4 = (char )':';
  {
#line 268
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 268
    rpl_sprintf(buf___0, "%d", bound.line);
#line 268
    __o___5 = & muscle_obstack;
#line 268
    tmp___5 = strlen((char const   *)(buf___0));
#line 268
    __len___3 = (int )tmp___5;
    }
#line 268
    if ((unsigned long )(__o___5->next_free + __len___3) > (unsigned long )__o___5->chunk_limit) {
      {
#line 268
      _obstack_newchunk(__o___5, __len___3);
      }
    }
    {
#line 268
    memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len___3);
#line 268
    __o___5->next_free += __len___3;
    }
#line 268
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 269
  __o___6 = & muscle_obstack;
#line 269
  if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
    {
#line 269
    _obstack_newchunk(__o___6, 1);
    }
  }
#line 269
  tmp___6 = __o___6->next_free;
#line 269
  (__o___6->next_free) ++;
#line 269
  *tmp___6 = (char )'.';
  {
#line 270
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 270
    rpl_sprintf(buf___1, "%d", bound.column);
#line 270
    __o___7 = & muscle_obstack;
#line 270
    tmp___7 = strlen((char const   *)(buf___1));
#line 270
    __len___4 = (int )tmp___7;
    }
#line 270
    if ((unsigned long )(__o___7->next_free + __len___4) > (unsigned long )__o___7->chunk_limit) {
      {
#line 270
      _obstack_newchunk(__o___7, __len___4);
      }
    }
    {
#line 270
    memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)(buf___1),
           (size_t )__len___4);
#line 270
    __o___7->next_free += __len___4;
    }
#line 270
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 271
  __o___8 = & muscle_obstack;
#line 271
  if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
    {
#line 271
    _obstack_newchunk(__o___8, 1);
    }
  }
#line 271
  tmp___8 = __o___8->next_free;
#line 271
  (__o___8->next_free) ++;
#line 271
  *tmp___8 = (char )'\000';
#line 272
  __o1 = & muscle_obstack;
#line 272
  __value = (void *)__o1->object_base;
#line 272
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 272
    __o1->maybe_empty_object = 1U;
  }
#line 272
  if (sizeof(int ) < sizeof(void *)) {
#line 272
    tmp___9 = __o1->object_base;
  } else {
#line 272
    tmp___9 = (char *)0;
  }
#line 272
  if (sizeof(int ) < sizeof(void *)) {
#line 272
    tmp___10 = __o1->object_base;
  } else {
#line 272
    tmp___10 = (char *)0;
  }
#line 272
  __o1->next_free = tmp___9 + (((__o1->next_free - tmp___10) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 272
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 272
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 272
  __o1->object_base = __o1->next_free;
#line 272
  extension = (char *)__value;
#line 273
  muscle_grow(key, (char const   *)extension, "");
#line 274
  __o___9 = & muscle_obstack;
#line 274
  __obj = (void *)extension;
  }
#line 274
  if ((unsigned long )__obj > (unsigned long )((void *)__o___9->chunk)) {
#line 274
    if ((unsigned long )__obj < (unsigned long )((void *)__o___9->chunk_limit)) {
#line 274
      tmp___11 = (char *)__obj;
#line 274
      __o___9->object_base = tmp___11;
#line 274
      __o___9->next_free = tmp___11;
    } else {
      {
#line 274
      obstack_free(__o___9, __obj);
      }
    }
  } else {
    {
#line 274
    obstack_free(__o___9, __obj);
    }
  }
#line 275
  return;
}
}
#line 277 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_location_grow(char const   *key , location loc___0 ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 280
  muscle_grow(key, "[[", "");
#line 281
  muscle_boundary_grow(key, loc___0.start);
#line 282
  muscle_grow(key, "]], [[", "");
#line 283
  muscle_boundary_grow(key, loc___0.end);
#line 284
  muscle_grow(key, "]]", "");
  }
#line 285
  return;
}
}
#line 307 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
static char *muscle_string_decode(char const   *key ) 
{ 
  char const   *value ;
  char *value_decoded ;
  char *result ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct obstack *__o___4 ;
  void *__obj ;
  char *tmp___7 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 314
  value = muscle_find_const(key);
  }
#line 315
  if (! value) {
#line 316
    return ((char *)((void *)0));
  }
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 320
    if ((int const   )*value == 36) {
#line 320
      goto case_36;
    }
#line 320
    if ((int const   )*value == 64) {
#line 320
      goto case_64;
    }
#line 322
    if ((int const   )*value == 93) {
#line 322
      goto case_93;
    }
#line 322
    if ((int const   )*value == 91) {
#line 322
      goto case_93;
    }
#line 320
    goto switch_default___0;
    case_36: /* CIL Label */ 
#line 320
    value ++;
#line 320
    if (! ((int const   )*value == 93)) {
      {
#line 320
      __assert_fail("*++(value) == \']\'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                    320U, "muscle_string_decode");
      }
    }
#line 320
    value ++;
#line 320
    if (! ((int const   )*value == 91)) {
      {
#line 320
      __assert_fail("*++(value) == \'[\'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                    320U, "muscle_string_decode");
      }
    }
    {
#line 320
    __o = & muscle_obstack;
#line 320
    tmp = strlen("$");
#line 320
    __len = (int )tmp;
    }
#line 320
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 320
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$",
           (size_t )__len);
#line 320
    __o->next_free += __len;
    }
#line 320
    goto switch_break;
    case_64: /* CIL Label */ 
#line 320
    value ++;
    {
#line 320
    if ((int const   )*value == 64) {
#line 320
      goto case_64___0;
    }
#line 320
    if ((int const   )*value == 123) {
#line 320
      goto case_123;
    }
#line 320
    if ((int const   )*value == 125) {
#line 320
      goto case_125;
    }
#line 320
    goto switch_default;
    case_64___0: /* CIL Label */ 
    {
#line 320
    __o___0 = & muscle_obstack;
#line 320
    tmp___0 = strlen("@");
#line 320
    __len___0 = (int )tmp___0;
    }
#line 320
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 320
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@",
           (size_t )__len___0);
#line 320
    __o___0->next_free += __len___0;
    }
#line 320
    goto switch_break___0;
    case_123: /* CIL Label */ 
    {
#line 320
    __o___1 = & muscle_obstack;
#line 320
    tmp___1 = strlen("[");
#line 320
    __len___1 = (int )tmp___1;
    }
#line 320
    if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o___1, __len___1);
      }
    }
    {
#line 320
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"[",
           (size_t )__len___1);
#line 320
    __o___1->next_free += __len___1;
    }
#line 320
    goto switch_break___0;
    case_125: /* CIL Label */ 
    {
#line 320
    __o___2 = & muscle_obstack;
#line 320
    tmp___2 = strlen("]");
#line 320
    __len___2 = (int )tmp___2;
    }
#line 320
    if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o___2, __len___2);
      }
    }
    {
#line 320
    memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"]",
           (size_t )__len___2);
#line 320
    __o___2->next_free += __len___2;
    }
#line 320
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 320
    __assert_fail("0", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c", 320U,
                  "muscle_string_decode");
    }
#line 320
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 320
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 320
    __o___3 = & muscle_obstack;
#line 320
    if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o___3, 1);
      }
    }
#line 320
    tmp___3 = __o___3->next_free;
#line 320
    (__o___3->next_free) ++;
#line 320
    *tmp___3 = (char )*value;
#line 320
    goto switch_break;
    case_93: /* CIL Label */ 
    case_91: /* CIL Label */ 
    {
#line 323
    __assert_fail("0", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c", 323U,
                  "muscle_string_decode");
    }
#line 324
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 317
    tmp___4 = value;
#line 317
    value ++;
#line 317
    if (! *tmp___4) {
#line 317
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  __o1 = & muscle_obstack;
#line 327
  __value = (void *)__o1->object_base;
#line 327
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 327
    __o1->maybe_empty_object = 1U;
  }
#line 327
  if (sizeof(int ) < sizeof(void *)) {
#line 327
    tmp___5 = __o1->object_base;
  } else {
#line 327
    tmp___5 = (char *)0;
  }
#line 327
  if (sizeof(int ) < sizeof(void *)) {
#line 327
    tmp___6 = __o1->object_base;
  } else {
#line 327
    tmp___6 = (char *)0;
  }
#line 327
  __o1->next_free = tmp___5 + (((__o1->next_free - tmp___6) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 327
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 327
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 327
  __o1->object_base = __o1->next_free;
#line 327
  value_decoded = (char *)__value;
#line 328
  result = xstrdup((char const   *)value_decoded);
#line 329
  __o___4 = & muscle_obstack;
#line 329
  __obj = (void *)value_decoded;
  }
#line 329
  if ((unsigned long )__obj > (unsigned long )((void *)__o___4->chunk)) {
#line 329
    if ((unsigned long )__obj < (unsigned long )((void *)__o___4->chunk_limit)) {
#line 329
      tmp___7 = (char *)__obj;
#line 329
      __o___4->object_base = tmp___7;
#line 329
      __o___4->next_free = tmp___7;
    } else {
      {
#line 329
      obstack_free(__o___4, __obj);
      }
    }
  } else {
    {
#line 329
    obstack_free(__o___4, __obj);
    }
  }
#line 330
  return (result);
}
}
#line 334 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
static location muscle_location_decode(char const   *key ) 
{ 
  location loc___0 ;
  char const   *value ;
  char const   *tmp ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___1 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___3 ;
  struct obstack *__o___3 ;
  char *tmp___4 ;
  char *boundary_str ;
  struct obstack *__o___4 ;
  char *tmp___5 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct obstack *__o___5 ;
  void *__obj ;
  char *tmp___8 ;
  struct obstack *__o___6 ;
  void *__obj___0 ;
  char *tmp___9 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;

  {
  {
#line 338
  tmp = muscle_find_const(key);
#line 338
  value = tmp;
  }
#line 339
  if (! value) {
    {
#line 339
    __assert_fail("value", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                  339U, "muscle_location_decode");
    }
  }
#line 340
  if (! ((int const   )*value == 91)) {
    {
#line 340
    __assert_fail("*value == \'[\'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                  340U, "muscle_location_decode");
    }
  }
#line 341
  value ++;
#line 341
  if (! ((int const   )*value == 91)) {
    {
#line 341
    __assert_fail("*++value == \'[\'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                  341U, "muscle_location_decode");
    }
  }
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    value ++;
#line 342
    if (! *value) {
#line 342
      goto while_break;
    }
    {
#line 345
    if ((int const   )*value == 36) {
#line 345
      goto case_36;
    }
#line 345
    if ((int const   )*value == 64) {
#line 345
      goto case_64;
    }
#line 346
    if ((int const   )*value == 91) {
#line 346
      goto case_91;
    }
#line 349
    if ((int const   )*value == 93) {
#line 349
      goto case_93;
    }
#line 345
    goto switch_default___0;
    case_36: /* CIL Label */ 
#line 345
    value ++;
#line 345
    if (! ((int const   )*value == 93)) {
      {
#line 345
      __assert_fail("*++(value) == \']\'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                    345U, "muscle_location_decode");
      }
    }
#line 345
    value ++;
#line 345
    if (! ((int const   )*value == 91)) {
      {
#line 345
      __assert_fail("*++(value) == \'[\'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                    345U, "muscle_location_decode");
      }
    }
    {
#line 345
    __o = & muscle_obstack;
#line 345
    tmp___0 = strlen("$");
#line 345
    __len = (int )tmp___0;
    }
#line 345
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 345
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$",
           (size_t )__len);
#line 345
    __o->next_free += __len;
    }
#line 345
    goto switch_break;
    case_64: /* CIL Label */ 
#line 345
    value ++;
    {
#line 345
    if ((int const   )*value == 64) {
#line 345
      goto case_64___0;
    }
#line 345
    if ((int const   )*value == 123) {
#line 345
      goto case_123;
    }
#line 345
    if ((int const   )*value == 125) {
#line 345
      goto case_125;
    }
#line 345
    goto switch_default;
    case_64___0: /* CIL Label */ 
    {
#line 345
    __o___0 = & muscle_obstack;
#line 345
    tmp___1 = strlen("@");
#line 345
    __len___0 = (int )tmp___1;
    }
#line 345
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 345
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@",
           (size_t )__len___0);
#line 345
    __o___0->next_free += __len___0;
    }
#line 345
    goto switch_break___0;
    case_123: /* CIL Label */ 
    {
#line 345
    __o___1 = & muscle_obstack;
#line 345
    tmp___2 = strlen("[");
#line 345
    __len___1 = (int )tmp___2;
    }
#line 345
    if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o___1, __len___1);
      }
    }
    {
#line 345
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"[",
           (size_t )__len___1);
#line 345
    __o___1->next_free += __len___1;
    }
#line 345
    goto switch_break___0;
    case_125: /* CIL Label */ 
    {
#line 345
    __o___2 = & muscle_obstack;
#line 345
    tmp___3 = strlen("]");
#line 345
    __len___2 = (int )tmp___3;
    }
#line 345
    if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o___2, __len___2);
      }
    }
    {
#line 345
    memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"]",
           (size_t )__len___2);
#line 345
    __o___2->next_free += __len___2;
    }
#line 345
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 345
    __assert_fail("0", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c", 345U,
                  "muscle_location_decode");
    }
#line 345
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 345
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 345
    __o___3 = & muscle_obstack;
#line 345
    if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o___3, 1);
      }
    }
#line 345
    tmp___4 = __o___3->next_free;
#line 345
    (__o___3->next_free) ++;
#line 345
    *tmp___4 = (char )*value;
#line 345
    goto switch_break;
    case_91: /* CIL Label */ 
    {
#line 347
    __assert_fail("0", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c", 347U,
                  "muscle_location_decode");
    }
#line 348
    goto switch_break;
    case_93: /* CIL Label */ 
#line 352
    value ++;
#line 352
    if (! ((int const   )*value == 93)) {
      {
#line 352
      __assert_fail("*++value == \']\'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                    352U, "muscle_location_decode");
      }
    }
#line 353
    __o___4 = & muscle_obstack;
#line 353
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 353
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 353
    tmp___5 = __o___4->next_free;
#line 353
    (__o___4->next_free) ++;
#line 353
    *tmp___5 = (char )'\000';
#line 354
    __o1 = & muscle_obstack;
#line 354
    __value = (void *)__o1->object_base;
#line 354
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 354
      __o1->maybe_empty_object = 1U;
    }
#line 354
    if (sizeof(int ) < sizeof(void *)) {
#line 354
      tmp___6 = __o1->object_base;
    } else {
#line 354
      tmp___6 = (char *)0;
    }
#line 354
    if (sizeof(int ) < sizeof(void *)) {
#line 354
      tmp___7 = __o1->object_base;
    } else {
#line 354
      tmp___7 = (char *)0;
    }
#line 354
    __o1->next_free = tmp___6 + (((__o1->next_free - tmp___7) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 354
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 354
      __o1->next_free = __o1->chunk_limit;
    }
#line 354
    __o1->object_base = __o1->next_free;
#line 354
    boundary_str = (char *)__value;
#line 355
    value ++;
    {
#line 357
    if ((int const   )*value == 44) {
#line 357
      goto case_44;
    }
#line 364
    if ((int const   )*value == 0) {
#line 364
      goto case_0;
    }
#line 369
    goto switch_default___1;
    case_44: /* CIL Label */ 
    {
#line 358
    boundary_set_from_string(& loc___0.start, boundary_str);
#line 359
    __o___5 = & muscle_obstack;
#line 359
    __obj = (void *)boundary_str;
    }
#line 359
    if ((unsigned long )__obj > (unsigned long )((void *)__o___5->chunk)) {
#line 359
      if ((unsigned long )__obj < (unsigned long )((void *)__o___5->chunk_limit)) {
#line 359
        tmp___8 = (char *)__obj;
#line 359
        __o___5->object_base = tmp___8;
#line 359
        __o___5->next_free = tmp___8;
      } else {
        {
#line 359
        obstack_free(__o___5, __obj);
        }
      }
    } else {
      {
#line 359
      obstack_free(__o___5, __obj);
      }
    }
#line 360
    value ++;
#line 360
    if (! ((int const   )*value == 32)) {
      {
#line 360
      __assert_fail("*++value == \' \'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                    360U, "muscle_location_decode");
      }
    }
#line 361
    value ++;
#line 361
    if (! ((int const   )*value == 91)) {
      {
#line 361
      __assert_fail("*++value == \'[\'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                    361U, "muscle_location_decode");
      }
    }
#line 362
    value ++;
#line 362
    if (! ((int const   )*value == 91)) {
      {
#line 362
      __assert_fail("*++value == \'[\'", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c",
                    362U, "muscle_location_decode");
      }
    }
#line 363
    goto switch_break___1;
    case_0: /* CIL Label */ 
    {
#line 365
    boundary_set_from_string(& loc___0.end, boundary_str);
#line 366
    __o___6 = & muscle_obstack;
#line 366
    __obj___0 = (void *)boundary_str;
    }
#line 366
    if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___6->chunk)) {
#line 366
      if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___6->chunk_limit)) {
#line 366
        tmp___9 = (char *)__obj___0;
#line 366
        __o___6->object_base = tmp___9;
#line 366
        __o___6->next_free = tmp___9;
      } else {
        {
#line 366
        obstack_free(__o___6, __obj___0);
        }
      }
    } else {
      {
#line 366
      obstack_free(__o___6, __obj___0);
      }
    }
#line 367
    return (loc___0);
#line 368
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 370
    __assert_fail("0", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c", 370U,
                  "muscle_location_decode");
    }
#line 371
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 374
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  __assert_fail("0", "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c", 376U,
                "muscle_location_decode");
  }
#line 377
  return (loc___0);
}
}
#line 380 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_user_name_list_grow(char const   *key , char const   *user_name , location loc___0 ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 384
  muscle_grow(key, "[[[[", ",");
#line 385
  muscle_grow(key, user_name, "");
#line 386
  muscle_grow(key, "]], ", "");
#line 387
  muscle_location_grow(key, loc___0);
#line 388
  muscle_grow(key, "]]", "");
  }
#line 389
  return;
}
}
#line 391 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_percent_define_insert(char const   *variable , location variable_loc ,
                                  char const   *value , muscle_percent_define_how how ) 
{ 
  char *variable_tr ;
  char const   *name ;
  char const   *loc_name ;
  char const   *syncline_name ;
  char const   *how_name ;
  int tmp ;
  int tmp___0 ;
  muscle_percent_define_how how_old ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  location tmp___5 ;
  char const   *tmp___6 ;
  char const   *p ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___7 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___8 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___9 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___10 ;
  struct obstack *__o___3 ;
  char *tmp___11 ;
  struct obstack *__o___4 ;
  char *tmp___12 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___13 ;
  char *tmp___14 ;
  char buf___0[4096] ;
  struct obstack *__o___5 ;
  int __len___3 ;
  size_t tmp___15 ;
  struct obstack *__o___6 ;
  char *tmp___16 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___17 ;
  char *tmp___18 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;

  {
  {
#line 396
  variable_tr = (char *)((void *)0);
#line 403
  tmp = strcmp(variable, "api.push_pull");
  }
#line 403
  if (0 == tmp) {
    {
#line 406
    variable_tr = strdup(variable);
#line 407
    tr(variable_tr, (char )'_', (char )'-');
#line 408
    variable = (char const   *)variable_tr;
    }
  } else {
    {
#line 403
    tmp___0 = strcmp(variable, "lr.keep_unreachable_states");
    }
#line 403
    if (0 == tmp___0) {
      {
#line 406
      variable_tr = strdup(variable);
#line 407
      tr(variable_tr, (char )'_', (char )'-');
#line 408
      variable = (char const   *)variable_tr;
      }
    }
  }
  {
#line 411
  name = uniqstr_vsprintf("%s%s%s", "percent_define(", variable, ")");
#line 412
  loc_name = uniqstr_vsprintf("%s%s%s", "percent_define_loc(", variable, ")");
#line 413
  syncline_name = uniqstr_vsprintf("%s%s%s", "percent_define_syncline(", variable,
                                   ")");
#line 415
  how_name = uniqstr_vsprintf("%s%s%s", "percent_define_how(", variable, ")");
  }
#line 418
  if ((unsigned int )how == 2U) {
    {
#line 418
    tmp___6 = muscle_find_const(name);
    }
#line 418
    if (tmp___6) {
      {
#line 421
      tmp___1 = muscle_find_const(how_name);
#line 421
      tmp___2 = atoi(tmp___1);
#line 421
      how_old = (muscle_percent_define_how )tmp___2;
      }
#line 423
      if ((unsigned int )how_old == 1U) {
        {
#line 425
        free((void *)variable_tr);
        }
#line 426
        return;
      }
      {
#line 428
      tmp___3 = gettext("%%define variable `%s\' redefined");
#line 428
      complain_at(variable_loc, (char const   *)tmp___3, variable);
#line 430
      tmp___4 = gettext("previous definition");
#line 430
      tmp___5 = muscle_percent_define_get_loc(variable);
#line 430
      complain_at(tmp___5, (char const   *)tmp___4);
      }
    }
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 434
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 434
      p = value;
      {
#line 434
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 434
        if (! *p) {
#line 434
          goto while_break___1;
        }
        {
#line 434
        if ((int const   )*p == 36) {
#line 434
          goto case_36;
        }
#line 434
        if ((int const   )*p == 64) {
#line 434
          goto case_64;
        }
#line 434
        if ((int const   )*p == 91) {
#line 434
          goto case_91;
        }
#line 434
        if ((int const   )*p == 93) {
#line 434
          goto case_93;
        }
#line 434
        goto switch_default;
        case_36: /* CIL Label */ 
        {
#line 434
        __o = & muscle_obstack;
#line 434
        tmp___7 = strlen("$][");
#line 434
        __len = (int )tmp___7;
        }
#line 434
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 434
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 434
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len);
#line 434
        __o->next_free += __len;
        }
#line 434
        goto switch_break;
        case_64: /* CIL Label */ 
        {
#line 434
        __o___0 = & muscle_obstack;
#line 434
        tmp___8 = strlen("@@");
#line 434
        __len___0 = (int )tmp___8;
        }
#line 434
        if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
          {
#line 434
          _obstack_newchunk(__o___0, __len___0);
          }
        }
        {
#line 434
        memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___0);
#line 434
        __o___0->next_free += __len___0;
        }
#line 434
        goto switch_break;
        case_91: /* CIL Label */ 
        {
#line 434
        __o___1 = & muscle_obstack;
#line 434
        tmp___9 = strlen("@{");
#line 434
        __len___1 = (int )tmp___9;
        }
#line 434
        if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
          {
#line 434
          _obstack_newchunk(__o___1, __len___1);
          }
        }
        {
#line 434
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___1);
#line 434
        __o___1->next_free += __len___1;
        }
#line 434
        goto switch_break;
        case_93: /* CIL Label */ 
        {
#line 434
        __o___2 = & muscle_obstack;
#line 434
        tmp___10 = strlen("@}");
#line 434
        __len___2 = (int )tmp___10;
        }
#line 434
        if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
          {
#line 434
          _obstack_newchunk(__o___2, __len___2);
          }
        }
        {
#line 434
        memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___2);
#line 434
        __o___2->next_free += __len___2;
        }
#line 434
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 434
        __o___3 = & muscle_obstack;
#line 434
        if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
          {
#line 434
          _obstack_newchunk(__o___3, 1);
          }
        }
#line 434
        tmp___11 = __o___3->next_free;
#line 434
        (__o___3->next_free) ++;
#line 434
        *tmp___11 = (char )*p;
#line 434
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 434
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 434
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 434
    __o___4 = & muscle_obstack;
#line 434
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 434
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 434
    tmp___12 = __o___4->next_free;
#line 434
    (__o___4->next_free) ++;
#line 434
    *tmp___12 = (char)0;
#line 434
    __o1 = & muscle_obstack;
#line 434
    __value = (void *)__o1->object_base;
#line 434
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 434
      __o1->maybe_empty_object = 1U;
    }
#line 434
    if (sizeof(int ) < sizeof(void *)) {
#line 434
      tmp___13 = __o1->object_base;
    } else {
#line 434
      tmp___13 = (char *)0;
    }
#line 434
    if (sizeof(int ) < sizeof(void *)) {
#line 434
      tmp___14 = __o1->object_base;
    } else {
#line 434
      tmp___14 = (char *)0;
    }
#line 434
    __o1->next_free = tmp___13 + (((__o1->next_free - tmp___14) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 434
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 434
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 434
    __o1->object_base = __o1->next_free;
#line 434
    muscle_insert(name, (char const   *)__value);
    }
#line 434
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 435
  muscle_insert(loc_name, "");
#line 436
  muscle_location_grow(loc_name, variable_loc);
#line 437
  muscle_insert(syncline_name, "");
#line 438
  muscle_syncline_grow(syncline_name, variable_loc);
#line 439
  muscle_user_name_list_grow("percent_define_user_variables", variable, variable_loc);
  }
  {
#line 441
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 441
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 441
      rpl_sprintf(buf___0, "%d", (unsigned int )how);
#line 441
      __o___5 = & muscle_obstack;
#line 441
      tmp___15 = strlen((char const   *)(buf___0));
#line 441
      __len___3 = (int )tmp___15;
      }
#line 441
      if ((unsigned long )(__o___5->next_free + __len___3) > (unsigned long )__o___5->chunk_limit) {
        {
#line 441
        _obstack_newchunk(__o___5, __len___3);
        }
      }
      {
#line 441
      memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len___3);
#line 441
      __o___5->next_free += __len___3;
      }
#line 441
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 441
    __o___6 = & muscle_obstack;
#line 441
    if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
      {
#line 441
      _obstack_newchunk(__o___6, 1);
      }
    }
#line 441
    tmp___16 = __o___6->next_free;
#line 441
    (__o___6->next_free) ++;
#line 441
    *tmp___16 = (char)0;
#line 441
    __o1___0 = & muscle_obstack;
#line 441
    __value___0 = (void *)__o1___0->object_base;
#line 441
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 441
      __o1___0->maybe_empty_object = 1U;
    }
#line 441
    if (sizeof(int ) < sizeof(void *)) {
#line 441
      tmp___17 = __o1___0->object_base;
    } else {
#line 441
      tmp___17 = (char *)0;
    }
#line 441
    if (sizeof(int ) < sizeof(void *)) {
#line 441
      tmp___18 = __o1___0->object_base;
    } else {
#line 441
      tmp___18 = (char *)0;
    }
#line 441
    __o1___0->next_free = tmp___17 + (((__o1___0->next_free - tmp___18) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 441
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 441
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 441
    __o1___0->object_base = __o1___0->next_free;
#line 441
    muscle_insert(how_name, (char const   *)__value___0);
    }
#line 441
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 443
  free((void *)variable_tr);
  }
#line 444
  return;
}
}
#line 446 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
char *muscle_percent_define_get(char const   *variable ) 
{ 
  char const   *name ;
  char const   *usage_name ;
  char *value ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 453
  name = uniqstr_vsprintf("%s%s%s", "percent_define(", variable, ")");
#line 454
  usage_name = uniqstr_vsprintf("%s%s%s", "percent_define_bison_variables(", variable,
                                ")");
#line 457
  muscle_insert(usage_name, "");
#line 458
  value = muscle_string_decode(name);
  }
#line 459
  if (! value) {
    {
#line 460
    value = xstrdup("");
    }
  }
#line 461
  return (value);
}
}
#line 464 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
location muscle_percent_define_get_loc(char const   *variable ) 
{ 
  char const   *loc_name ;
  char *tmp ;
  char const   *tmp___0 ;
  location tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 468
  loc_name = uniqstr_vsprintf("%s%s%s", "percent_define_loc(", variable, ")");
#line 469
  tmp___0 = muscle_find_const(loc_name);
  }
#line 469
  if (! tmp___0) {
    {
#line 470
    tmp = gettext("undefined %%define variable `%s\' passed to muscle_percent_define_get_loc");
#line 470
    fatal((char const   *)tmp, variable);
    }
  }
  {
#line 472
  tmp___1 = muscle_location_decode(loc_name);
  }
#line 472
  return (tmp___1);
}
}
#line 475 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
char const   *muscle_percent_define_get_syncline(char const   *variable ) 
{ 
  char const   *syncline_name ;
  char const   *syncline ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 480
  syncline_name = uniqstr_vsprintf("%s%s%s", "percent_define_syncline(", variable,
                                   ")");
#line 482
  syncline = muscle_find_const(syncline_name);
  }
#line 483
  if (! syncline) {
    {
#line 484
    tmp = gettext("undefined %%define variable `%s\' passed to muscle_percent_define_get_syncline");
#line 484
    fatal((char const   *)tmp, variable);
    }
  }
#line 486
  return (syncline);
}
}
#line 489 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
_Bool muscle_percent_define_ifdef(char const   *variable ) 
{ 
  char const   *name ;
  char const   *usage_name ;
  char const   *value ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 496
  name = uniqstr_vsprintf("%s%s%s", "percent_define(", variable, ")");
#line 497
  usage_name = uniqstr_vsprintf("%s%s%s", "percent_define_bison_variables(", variable,
                                ")");
#line 500
  value = muscle_find_const(name);
  }
#line 501
  if (value) {
    {
#line 503
    muscle_insert(usage_name, "");
    }
#line 504
    return ((_Bool)1);
  }
#line 507
  return ((_Bool)0);
}
}
#line 510 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
_Bool muscle_percent_define_flag_if(char const   *variable ) 
{ 
  char const   *invalid_boolean_name ;
  _Bool result ;
  char *value ;
  char *tmp ;
  char *tmp___0 ;
  location tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 514
  result = (_Bool)0;
#line 516
  invalid_boolean_name = uniqstr_vsprintf("%s%s%s", "percent_define_invalid_boolean(",
                                          variable, ")");
#line 519
  tmp___6 = muscle_percent_define_ifdef(variable);
  }
#line 519
  if (tmp___6) {
    {
#line 521
    tmp = muscle_percent_define_get(variable);
#line 521
    value = tmp;
    }
#line 522
    if ((int )*(value + 0) == 0) {
#line 523
      result = (_Bool)1;
    } else {
      {
#line 522
      tmp___4 = strcmp((char const   *)value, "true");
      }
#line 522
      if (0 == tmp___4) {
#line 523
        result = (_Bool)1;
      } else {
        {
#line 524
        tmp___3 = strcmp((char const   *)value, "false");
        }
#line 524
        if (0 == tmp___3) {
#line 525
          result = (_Bool)0;
        } else {
          {
#line 526
          tmp___2 = muscle_find_const(invalid_boolean_name);
          }
#line 526
          if (! tmp___2) {
            {
#line 528
            muscle_insert(invalid_boolean_name, "");
#line 529
            tmp___0 = gettext("invalid value for %%define Boolean variable `%s\'");
#line 529
            tmp___1 = muscle_percent_define_get_loc(variable);
#line 529
            complain_at(tmp___1, (char const   *)tmp___0, variable);
            }
          }
        }
      }
    }
    {
#line 533
    free((void *)value);
    }
  } else {
    {
#line 536
    tmp___5 = gettext("undefined %%define variable `%s\' passed to muscle_percent_define_flag_if");
#line 536
    fatal((char const   *)tmp___5, variable);
    }
  }
#line 539
  return (result);
}
}
#line 542 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_percent_define_default(char const   *variable , char const   *value ) 
{ 
  char const   *name ;
  char const   *loc_name ;
  char const   *syncline_name ;
  location loc___0 ;
  char const   *p ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o___4 ;
  char *tmp___4 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 548
  name = uniqstr_vsprintf("%s%s%s", "percent_define(", variable, ")");
#line 549
  loc_name = uniqstr_vsprintf("%s%s%s", "percent_define_loc(", variable, ")");
#line 550
  syncline_name = uniqstr_vsprintf("%s%s%s", "percent_define_syncline(", variable,
                                   ")");
#line 552
  tmp___7 = muscle_find_const(name);
  }
#line 552
  if (! tmp___7) {
    {
#line 555
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 555
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 555
        p = value;
        {
#line 555
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 555
          if (! *p) {
#line 555
            goto while_break___1;
          }
          {
#line 555
          if ((int const   )*p == 36) {
#line 555
            goto case_36;
          }
#line 555
          if ((int const   )*p == 64) {
#line 555
            goto case_64;
          }
#line 555
          if ((int const   )*p == 91) {
#line 555
            goto case_91;
          }
#line 555
          if ((int const   )*p == 93) {
#line 555
            goto case_93;
          }
#line 555
          goto switch_default;
          case_36: /* CIL Label */ 
          {
#line 555
          __o = & muscle_obstack;
#line 555
          tmp = strlen("$][");
#line 555
          __len = (int )tmp;
          }
#line 555
          if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
            {
#line 555
            _obstack_newchunk(__o, __len);
            }
          }
          {
#line 555
          memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$][",
                 (size_t )__len);
#line 555
          __o->next_free += __len;
          }
#line 555
          goto switch_break;
          case_64: /* CIL Label */ 
          {
#line 555
          __o___0 = & muscle_obstack;
#line 555
          tmp___0 = strlen("@@");
#line 555
          __len___0 = (int )tmp___0;
          }
#line 555
          if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
            {
#line 555
            _obstack_newchunk(__o___0, __len___0);
            }
          }
          {
#line 555
          memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@@",
                 (size_t )__len___0);
#line 555
          __o___0->next_free += __len___0;
          }
#line 555
          goto switch_break;
          case_91: /* CIL Label */ 
          {
#line 555
          __o___1 = & muscle_obstack;
#line 555
          tmp___1 = strlen("@{");
#line 555
          __len___1 = (int )tmp___1;
          }
#line 555
          if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
            {
#line 555
            _obstack_newchunk(__o___1, __len___1);
            }
          }
          {
#line 555
          memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@{",
                 (size_t )__len___1);
#line 555
          __o___1->next_free += __len___1;
          }
#line 555
          goto switch_break;
          case_93: /* CIL Label */ 
          {
#line 555
          __o___2 = & muscle_obstack;
#line 555
          tmp___2 = strlen("@}");
#line 555
          __len___2 = (int )tmp___2;
          }
#line 555
          if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
            {
#line 555
            _obstack_newchunk(__o___2, __len___2);
            }
          }
          {
#line 555
          memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@}",
                 (size_t )__len___2);
#line 555
          __o___2->next_free += __len___2;
          }
#line 555
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 555
          __o___3 = & muscle_obstack;
#line 555
          if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
            {
#line 555
            _obstack_newchunk(__o___3, 1);
            }
          }
#line 555
          tmp___3 = __o___3->next_free;
#line 555
          (__o___3->next_free) ++;
#line 555
          *tmp___3 = (char )*p;
#line 555
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 555
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 555
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 555
      __o___4 = & muscle_obstack;
#line 555
      if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
        {
#line 555
        _obstack_newchunk(__o___4, 1);
        }
      }
#line 555
      tmp___4 = __o___4->next_free;
#line 555
      (__o___4->next_free) ++;
#line 555
      *tmp___4 = (char)0;
#line 555
      __o1 = & muscle_obstack;
#line 555
      __value = (void *)__o1->object_base;
#line 555
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 555
        __o1->maybe_empty_object = 1U;
      }
#line 555
      if (sizeof(int ) < sizeof(void *)) {
#line 555
        tmp___5 = __o1->object_base;
      } else {
#line 555
        tmp___5 = (char *)0;
      }
#line 555
      if (sizeof(int ) < sizeof(void *)) {
#line 555
        tmp___6 = __o1->object_base;
      } else {
#line 555
        tmp___6 = (char *)0;
      }
#line 555
      __o1->next_free = tmp___5 + (((__o1->next_free - tmp___6) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 555
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 555
        __o1->next_free = __o1->chunk_limit;
      }
      {
#line 555
      __o1->object_base = __o1->next_free;
#line 555
      muscle_insert(name, (char const   *)__value);
      }
#line 555
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 556
    loc___0.end.file = "<default value>";
#line 556
    loc___0.start.file = loc___0.end.file;
#line 557
    loc___0.end.line = -1;
#line 557
    loc___0.start.line = loc___0.end.line;
#line 558
    loc___0.end.column = -1;
#line 558
    loc___0.start.column = loc___0.end.column;
#line 559
    muscle_insert(loc_name, "");
#line 560
    muscle_location_grow(loc_name, loc___0);
#line 561
    muscle_insert(syncline_name, "");
    }
  }
#line 563
  return;
}
}
#line 565 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_percent_define_check_values(char const   * const  *values___0 ) 
{ 
  char const   * const  *variablep ;
  char const   *name ;
  char *value ;
  int tmp ;
  location loc___0 ;
  location tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 568
    if (! *values___0) {
#line 568
      goto while_break;
    }
    {
#line 570
    variablep = values___0;
#line 574
    name = uniqstr_vsprintf("%s%s%s", "percent_define(", *variablep, ")");
#line 576
    value = muscle_string_decode(name);
    }
#line 577
    if (value) {
#line 579
      values___0 ++;
      {
#line 579
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 579
        if (! *values___0) {
#line 579
          goto while_break___0;
        }
        {
#line 581
        tmp = strcmp((char const   *)value, (char const   *)*values___0);
        }
#line 581
        if (0 == tmp) {
#line 582
          goto while_break___0;
        }
#line 579
        values___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 584
      if (! *values___0) {
        {
#line 586
        tmp___0 = muscle_percent_define_get_loc((char const   *)*variablep);
#line 586
        loc___0 = tmp___0;
#line 587
        tmp___1 = gettext("invalid value for %%define variable `%s\': `%s\'");
#line 587
        complain_at(loc___0, (char const   *)tmp___1, *variablep, value);
#line 590
        values___0 = variablep + 1;
        }
        {
#line 590
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 590
          if (! *values___0) {
#line 590
            goto while_break___1;
          }
          {
#line 591
          tmp___2 = gettext("accepted value: `%s\'");
#line 591
          complain_at(loc___0, (char const   *)tmp___2, *values___0);
#line 590
          values___0 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 595
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 595
          if (! *values___0) {
#line 595
            goto while_break___2;
          }
#line 596
          values___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 598
      free((void *)value);
      }
    } else {
      {
#line 601
      tmp___3 = gettext("undefined %%define variable `%s\' passed to muscle_percent_define_check_values");
#line 601
      fatal((char const   *)tmp___3, *variablep);
      }
    }
#line 568
    values___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  return;
}
}
#line 607 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscle_percent_code_grow(char const   *qualifier , location qualifier_loc , char const   *code ,
                              location code_loc ) 
{ 
  char const   *name ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 612
  name = uniqstr_vsprintf("%s%s%s", "percent_code(", qualifier, ")");
#line 613
  muscle_code_grow(name, code, code_loc);
#line 614
  muscle_user_name_list_grow("percent_code_user_qualifiers", qualifier, qualifier_loc);
  }
#line 616
  return;
}
}
#line 623 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
__inline static _Bool muscle_m4_output(muscle_entry *entry , FILE *out ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 626
  rpl_fprintf(out, "m4_define([b4_%s],\n", entry->key);
#line 627
  rpl_fprintf(out, "[[%s]])\n\n\n", entry->value);
  }
#line 628
  return ((_Bool)1);
}
}
#line 631 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
static _Bool muscle_m4_output_processor(void *entry , void *out ) 
{ 
  _Bool tmp ;

  {
  {
#line 634
  tmp = muscle_m4_output((muscle_entry *)entry, (FILE *)out);
  }
#line 634
  return (tmp);
}
}
#line 643 "/home/pronto/abs/test-suite/bison-2.5/src/muscle-tab.c"
void muscles_m4_output(FILE *out ) 
{ 


  {
  {
#line 646
  hash_do_for_each((Hash_table const   *)muscle_table, & muscle_m4_output_processor,
                   (void *)out);
  }
#line 647
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 273 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
void grammar_free(void) ;
#line 26 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.h"
void generate_states(void) ;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.h"
void conflicts_solve(void) ;
#line 36
void conflicts_update_state_numbers(state_number *old_to_new , state_number nstates_old ) ;
#line 39
void conflicts_print(void) ;
#line 42
void conflicts_free(void) ;
#line 32 "/home/pronto/abs/test-suite/bison-2.5/src/derives.h"
void derives_compute(void) ;
#line 33
void derives_free(void) ;
#line 64 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
void compute_output_file_names(void) ;
#line 65
void output_file_names_free(void) ;
#line 26 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
char *program_name ;
#line 40
_Bool graph_flag ;
#line 41
_Bool xml_flag ;
#line 140
void getargs(int argc , char **argv ) ;
#line 71 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.h"
void lalr_update_state_numbers(state_number *old_to_new , state_number nstates_old ) ;
#line 78
void lalr_free(void) ;
#line 40 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.h"
void ielr(void) ;
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/main.c"
int main(int argc , char **argv ) 
{ 
  state_number *old_to_new ;
  void *tmp ;
  state_number nstates_old ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 59
  program_name = *(argv + 0);
#line 60
  setlocale(6, "");
#line 61
  bindtextdomain("bison", "/usr/local/share/locale");
#line 62
  bindtextdomain("bison-runtime", "/usr/local/share/locale");
#line 63
  textdomain("bison");
#line 65
  uniqstrs_new();
#line 66
  muscle_init();
#line 68
  getargs(argc, argv);
#line 70
  timevar_report = trace_flag & 256;
#line 71
  init_timevar();
#line 72
  timevar_start((timevar_id_t )0);
  }
#line 74
  if (trace_flag & 16) {
    {
#line 75
    bitset_stats_enable();
    }
  }
  {
#line 81
  timevar_push((timevar_id_t )1);
#line 82
  reader();
#line 83
  timevar_pop((timevar_id_t )1);
  }
#line 85
  if (complaint_issued) {
#line 86
    goto finish;
  }
  {
#line 89
  timevar_push((timevar_id_t )4);
#line 90
  reduce_grammar();
#line 91
  timevar_pop((timevar_id_t )4);
#line 95
  timevar_push((timevar_id_t )5);
#line 96
  derives_compute();
#line 97
  nullable_compute();
#line 98
  timevar_pop((timevar_id_t )5);
#line 101
  timevar_push((timevar_id_t )6);
#line 102
  generate_states();
#line 103
  timevar_pop((timevar_id_t )6);
#line 108
  ielr();
#line 114
  timevar_push((timevar_id_t )12);
#line 115
  conflicts_solve();
#line 116
  tmp___0 = muscle_percent_define_flag_if("lr.keep-unreachable-states");
  }
#line 116
  if (! tmp___0) {
    {
#line 118
    tmp = xnmalloc((size_t )nstates, (size_t )sizeof(*old_to_new));
#line 118
    old_to_new = (state_number *)tmp;
#line 119
    nstates_old = nstates;
#line 120
    state_remove_unreachable_states(old_to_new);
#line 121
    lalr_update_state_numbers(old_to_new, nstates_old);
#line 122
    conflicts_update_state_numbers(old_to_new, nstates_old);
#line 123
    free((void *)old_to_new);
    }
  }
  {
#line 125
  conflicts_print();
#line 126
  timevar_pop((timevar_id_t )12);
#line 129
  timevar_push((timevar_id_t )16);
#line 130
  tables_generate();
#line 131
  timevar_pop((timevar_id_t )16);
#line 133
  tmp___1 = gettext("rule useless in parser due to conflicts");
#line 133
  grammar_rules_useless_report((char const   *)tmp___1);
#line 137
  compute_output_file_names();
  }
#line 140
  if (report_flag) {
    {
#line 142
    timevar_push((timevar_id_t )13);
#line 143
    print_results();
#line 144
    timevar_pop((timevar_id_t )13);
    }
  }
#line 148
  if (graph_flag) {
    {
#line 150
    timevar_push((timevar_id_t )14);
#line 151
    print_graph();
#line 152
    timevar_pop((timevar_id_t )14);
    }
  }
#line 156
  if (xml_flag) {
    {
#line 158
    timevar_push((timevar_id_t )15);
#line 159
    print_xml();
#line 160
    timevar_pop((timevar_id_t )15);
    }
  }
#line 165
  if (complaint_issued) {
#line 166
    goto finish;
  }
  {
#line 169
  timevar_push((timevar_id_t )19);
#line 170
  lalr_free();
#line 171
  timevar_pop((timevar_id_t )19);
#line 174
  timevar_push((timevar_id_t )17);
#line 175
  output();
#line 176
  timevar_pop((timevar_id_t )17);
#line 178
  timevar_push((timevar_id_t )19);
#line 179
  nullable_free();
#line 180
  derives_free();
#line 181
  tables_free();
#line 182
  states_free();
#line 183
  reduce_free();
#line 184
  conflicts_free();
#line 185
  grammar_free();
#line 186
  output_file_names_free();
#line 190
  gram_scanner_free();
#line 191
  muscle_free();
#line 192
  uniqstrs_free();
#line 193
  code_scanner_free();
#line 194
  skel_scanner_free();
#line 195
  quotearg_free();
#line 196
  timevar_pop((timevar_id_t )19);
  }
#line 198
  if (trace_flag & 16) {
    {
#line 199
    bitset_stats_dump(stderr);
    }
  }
  finish: 
  {
#line 204
  timevar_stop((timevar_id_t )0);
#line 205
  timevar_print(stderr);
  }
#line 207
  if (complaint_issued) {
#line 207
    tmp___2 = 1;
  } else {
#line 207
    tmp___2 = 0;
  }
#line 207
  return (tmp___2);
}
}
#line 29 "/home/pronto/abs/test-suite/bison-2.5/src/location.c"
struct __anonstruct_location_36  const  empty_location  =    {{(uniqstr )((void *)0), 0, 0}, {(uniqstr )((void *)0), 0, 0}};
#line 36 "/home/pronto/abs/test-suite/bison-2.5/src/location.c"
__inline static int add_column_width(int column , char const   *buf___0 , size_t bufsize ) 
{ 
  size_t width___0 ;
  unsigned int remaining_columns ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 40
  remaining_columns = (unsigned int )(2147483647 - column);
#line 42
  if (buf___0) {
#line 44
    if (1073741823U <= bufsize) {
#line 45
      return (2147483647);
    }
    {
#line 46
    tmp = mbsnwidth(buf___0, bufsize, 0);
#line 46
    width___0 = (size_t )tmp;
    }
  } else {
#line 49
    width___0 = bufsize;
  }
#line 51
  if (width___0 <= remaining_columns) {
#line 51
    tmp___0 = (size_t )column + width___0;
  } else {
#line 51
    tmp___0 = (size_t )2147483647;
  }
#line 51
  return ((int )tmp___0);
}
}
#line 57 "/home/pronto/abs/test-suite/bison-2.5/src/location.c"
void location_compute(location *loc___0 , boundary *cur , char const   *token , size_t size ) 
{ 
  int line ;
  int column ;
  char const   *p0 ;
  char const   *p ;
  char const   *lim ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 60
  line = cur->line;
#line 61
  column = cur->column;
#line 62
  p0 = token;
#line 63
  p = token;
#line 64
  lim = token + size;
#line 66
  loc___0->start = *cur;
#line 68
  p = token;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 68
      goto while_break;
    }
    {
#line 71
    if ((int const   )*p == 10) {
#line 71
      goto case_10;
    }
#line 77
    if ((int const   )*p == 9) {
#line 77
      goto case_9;
    }
#line 83
    goto switch_default;
    case_10: /* CIL Label */ 
#line 72
    line += line < 2147483647;
#line 73
    column = 1;
#line 74
    p0 = p + 1;
#line 75
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 78
    column = add_column_width(column, p0, (size_t )(p - p0));
#line 79
    column = add_column_width(column, (char const   *)((void *)0), (size_t )(8 - ((column - 1) & 7)));
#line 80
    p0 = p + 1;
    }
#line 81
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 84
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 68
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  cur->line = line;
#line 88
  column = add_column_width(column, p0, (size_t )(p - p0));
#line 88
  cur->column = column;
#line 90
  loc___0->end = *cur;
  }
#line 92
  if (line == 2147483647) {
#line 92
    if (loc___0->start.line != 2147483647) {
      {
#line 93
      tmp = gettext("line number overflow");
#line 93
      warn_at(*loc___0, (char const   *)tmp);
      }
    }
  }
#line 94
  if (column == 2147483647) {
#line 94
    if (loc___0->start.column != 2147483647) {
      {
#line 95
      tmp___0 = gettext("column number overflow");
#line 95
      warn_at(*loc___0, (char const   *)tmp___0);
      }
    }
  }
#line 96
  return;
}
}
#line 101 "/home/pronto/abs/test-suite/bison-2.5/src/location.c"
unsigned int location_print(FILE *out , location loc___0 ) 
{ 
  unsigned int res ;
  int end_col ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 104
  res = 0U;
#line 105
  if (0 != loc___0.end.column) {
#line 105
    tmp = loc___0.end.column - 1;
  } else {
#line 105
    tmp = 0;
  }
  {
#line 105
  end_col = tmp;
#line 106
  tmp___0 = quotearg_n_style(3, (enum quoting_style )5, loc___0.start.file);
#line 106
  tmp___1 = rpl_fprintf(out, "%s", tmp___0);
#line 106
  res += (unsigned int )tmp___1;
  }
#line 108
  if (0 <= loc___0.start.line) {
    {
#line 110
    tmp___2 = rpl_fprintf(out, ":%d", loc___0.start.line);
#line 110
    res += (unsigned int )tmp___2;
    }
#line 111
    if (0 <= loc___0.start.column) {
      {
#line 112
      tmp___3 = rpl_fprintf(out, ".%d", loc___0.start.column);
#line 112
      res += (unsigned int )tmp___3;
      }
    }
  }
#line 114
  if ((unsigned long )loc___0.start.file != (unsigned long )loc___0.end.file) {
    {
#line 116
    tmp___4 = quotearg_n_style(3, (enum quoting_style )5, loc___0.end.file);
#line 116
    tmp___5 = rpl_fprintf(out, "-%s", tmp___4);
#line 116
    res += (unsigned int )tmp___5;
    }
#line 119
    if (0 <= loc___0.end.line) {
      {
#line 121
      tmp___6 = rpl_fprintf(out, ":%d", loc___0.end.line);
#line 121
      res += (unsigned int )tmp___6;
      }
#line 122
      if (0 <= end_col) {
        {
#line 123
        tmp___7 = rpl_fprintf(out, ".%d", end_col);
#line 123
        res += (unsigned int )tmp___7;
        }
      }
    }
  } else
#line 126
  if (0 <= loc___0.end.line) {
#line 128
    if (loc___0.start.line < loc___0.end.line) {
      {
#line 130
      tmp___8 = rpl_fprintf(out, "-%d", loc___0.end.line);
#line 130
      res += (unsigned int )tmp___8;
      }
#line 131
      if (0 <= end_col) {
        {
#line 132
        tmp___9 = rpl_fprintf(out, ".%d", end_col);
#line 132
        res += (unsigned int )tmp___9;
        }
      }
    } else
#line 134
    if (0 <= end_col) {
#line 134
      if (loc___0.start.column < end_col) {
        {
#line 135
        tmp___10 = rpl_fprintf(out, "-%d", end_col);
#line 135
        res += (unsigned int )tmp___10;
        }
      }
    }
  }
#line 138
  return (res);
}
}
#line 141 "/home/pronto/abs/test-suite/bison-2.5/src/location.c"
void boundary_set_from_string(boundary *bound , char *loc_str ) 
{ 
  char *delim ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 146
  tmp = mbsrchr((char const   *)loc_str, '.');
#line 146
  delim = tmp;
  }
#line 147
  if (! delim) {
    {
#line 147
    __assert_fail("delim", "/home/pronto/abs/test-suite/bison-2.5/src/location.c",
                  147U, "boundary_set_from_string");
    }
  }
  {
#line 148
  *delim = (char )'\000';
#line 149
  bound->column = atoi((char const   *)(delim + 1));
#line 150
  delim = mbsrchr((char const   *)loc_str, ':');
  }
#line 151
  if (! delim) {
    {
#line 151
    __assert_fail("delim", "/home/pronto/abs/test-suite/bison-2.5/src/location.c",
                  151U, "boundary_set_from_string");
    }
  }
  {
#line 152
  *delim = (char )'\000';
#line 153
  bound->line = atoi((char const   *)(delim + 1));
#line 154
  bound->file = uniqstr_new((char const   *)loc_str);
  }
#line 155
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 140
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 140 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
__inline static _Bool item_number_is_symbol_number(item_number i ) 
{ 


  {
#line 143
  return ((_Bool )(i >= 0));
}
}
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.h"
_Bool ielr_item_has_lookahead(state *s , symbol_number lhs , size_t item , symbol_number lookahead ,
                              state ***predecessors , bitset **item_lookahead_sets ) ;
#line 51 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.h"
int const   ContributionIndex__none ;
#line 121
void InadequacyList__delete(InadequacyList *self ) ;
#line 108 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.h"
void AnnotationList__compute_from_inadequacies(state *s , bitsetv follow_kernel_items ,
                                               bitsetv always_follows , state ***predecessors ,
                                               bitset **item_lookahead_sets , InadequacyList **inadequacy_lists ,
                                               AnnotationList **annotation_lists ,
                                               AnnotationIndex *annotation_counts ,
                                               ContributionIndex *max_contributionsp ,
                                               struct obstack *annotations_obstackp ,
                                               InadequacyListNodeCount *inadequacy_list_node_count ) ;
#line 127
void AnnotationList__debug(AnnotationList const   *self , size_t nitems , int spaces ) ;
#line 141
void AnnotationList__computeLookaheadFilter(AnnotationList const   *self , size_t nitems ,
                                            bitsetv lookahead_filter ) ;
#line 177
ContributionIndex AnnotationList__computeDominantContribution(AnnotationList const   *self ,
                                                              size_t nitems , bitset *lookaheads ,
                                                              _Bool require_split_stable ) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.5/src/derives.h"
rule ***derives ;
#line 45 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.h"
void lalr(void) ;
#line 51
void initialize_LA(void) ;
#line 60
void set_goto_map(void) ;
#line 91
goto_number ngotos ;
#line 100
goto_number map_goto(state_number s0 , symbol_number sym ) ;
#line 103
bitsetv goto_follows ;
#line 48 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static bitset ielr_compute_ritem_sees_lookahead_set(void) 
{ 
  bitset result ;
  bitset tmp ;
  unsigned int i ;
  unsigned int tmp___0 ;
  _Bool tmp___1 ;
  symbol_number tmp___2 ;
  unsigned int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 51
  tmp = bitset_create(nritems, (bitset_attrs )1);
#line 51
  result = tmp;
#line 52
  i = nritems - 1U;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i > 0U)) {
#line 53
      goto while_break;
    }
#line 55
    i --;
    {
#line 56
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 56
      tmp___1 = item_number_is_rule_number(*(ritem + i));
      }
#line 56
      if (tmp___1) {
#line 56
        goto while_break___0;
      } else
#line 56
      if (*(ritem + i) >= ntokens) {
        {
#line 56
        tmp___2 = item_number_as_symbol_number(*(ritem + i));
        }
#line 56
        if (! *(nullable + (tmp___2 - ntokens))) {
#line 56
          goto while_break___0;
        }
      } else {
#line 56
        goto while_break___0;
      }
      {
#line 59
      tmp___0 = i;
#line 59
      i --;
#line 59
      bitset_set(result, tmp___0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 60
    tmp___4 = item_number_is_rule_number(*(ritem + i));
    }
#line 60
    if (! tmp___4) {
#line 60
      if (*(ritem + i) >= ntokens) {
        {
#line 61
        tmp___3 = i;
#line 61
        i --;
#line 61
        bitset_set(result, tmp___3);
        }
      }
    }
    {
#line 62
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 62
      tmp___5 = item_number_is_rule_number(*(ritem + i));
      }
#line 62
      if (tmp___5) {
#line 62
        goto while_break___1;
      } else
#line 62
      if (! (i > 0U)) {
#line 62
        goto while_break___1;
      }
#line 63
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if (trace_flag & 4096) {
    {
#line 67
    rpl_fprintf(stderr, "ritem_sees_lookahead_set:\n");
#line 68
    debug_bitset(result);
#line 69
    rpl_fprintf(stderr, "\n");
    }
  }
#line 71
  return (result);
}
}
#line 96 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static void ielr_compute_internal_follow_edges(bitset ritem_sees_lookahead_set , goto_number ***edgesp ,
                                               int **edge_countsp ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  bitset sources ;
  bitset tmp___1 ;
  goto_number i ;
  int nsources ;
  rule **rulep ;
  goto_number source ;
  symbol_number tmp___2 ;
  goto_number tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  void *tmp___6 ;
  bitset_iterator biter_source ;
  bitset_bindex source___0 ;
  int j ;
  int tmp___7 ;
  char *__cil_tmp21 ;

  {
  {
#line 100
  tmp = xnmalloc(ngotos, (size_t )sizeof(*(*edgesp)));
#line 100
  *edgesp = (goto_number **)tmp;
#line 101
  tmp___0 = xnmalloc(ngotos, (size_t )sizeof(*(*edge_countsp)));
#line 101
  *edge_countsp = (int *)tmp___0;
#line 103
  tmp___1 = bitset_create(ngotos, (bitset_attrs )1);
#line 103
  sources = tmp___1;
#line 105
  i = (goto_number )0;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < ngotos)) {
#line 105
      goto while_break;
    }
#line 106
    *(*edge_countsp + i) = 0;
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  i = (goto_number )0;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (i < ngotos)) {
#line 107
      goto while_break___0;
    }
#line 109
    nsources = 0;
#line 112
    rulep = *(derives + ((*(states + *(to_state + i)))->accessing_symbol - ntokens));
    {
#line 112
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 112
      if (! *rulep) {
#line 112
        goto while_break___1;
      }
      {
#line 135
      tmp___5 = bitset_test(ritem_sees_lookahead_set, (bitset_bindex )((*rulep)->rhs - ritem));
      }
#line 135
      if (tmp___5) {
        {
#line 138
        tmp___2 = item_number_as_symbol_number(*((*rulep)->rhs));
#line 138
        tmp___3 = map_goto(*(from_state + i), tmp___2);
#line 138
        source = tmp___3;
        }
#line 141
        if (i != source) {
          {
#line 141
          tmp___4 = bitset_test(sources, source);
          }
#line 141
          if (! tmp___4) {
            {
#line 143
            bitset_set(sources, source);
#line 144
            nsources ++;
#line 145
            (*(*edge_countsp + source)) ++;
            }
          }
        }
      }
#line 112
      rulep ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 150
    if (nsources == 0) {
#line 151
      *(*edgesp + i) = (goto_number *)((void *)0);
    } else {
      {
#line 154
      tmp___6 = xnmalloc((size_t )(nsources + 1), (size_t )sizeof(*(*(*edgesp + i))));
#line 154
      *(*edgesp + i) = (goto_number *)tmp___6;
#line 158
      j = 0;
#line 159
      biter_source.next = (bitset_bindex )0;
#line 159
      biter_source.num = (bitset_bindex )1024;
      }
      {
#line 159
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 159
        if (biter_source.num == 1024U) {
          {
#line 159
          biter_source.num = (*((sources->b.vtable)->list))(sources, biter_source.list,
                                                            (bitset_bindex )1024,
                                                            & biter_source.next);
          }
#line 159
          if (! biter_source.num) {
#line 159
            goto while_break___2;
          }
        } else {
#line 159
          goto while_break___2;
        }
#line 159
        biter_source.i = (bitset_bindex )0;
        {
#line 159
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 159
          if (biter_source.i < biter_source.num) {
#line 159
            source___0 = biter_source.list[biter_source.i];
          } else {
#line 159
            goto while_break___3;
          }
#line 160
          tmp___7 = j;
#line 160
          j ++;
#line 160
          *(*(*edgesp + i) + tmp___7) = source___0;
#line 159
          (biter_source.i) ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 162
      *(*(*edgesp + i) + nsources) = (relation_node )-1;
    }
    {
#line 164
    (*((sources->b.vtable)->zero))(sources);
#line 107
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 166
  bitset_free(sources);
#line 169
  relation_transpose(edgesp, ngotos);
  }
#line 171
  if (trace_flag & 4096) {
    {
#line 173
    rpl_fprintf(stderr, "internal_follow_edges:\n");
#line 174
    relation_print(*edgesp, ngotos, stderr);
    }
  }
#line 176
  return;
}
}
#line 194 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static void ielr_compute_follow_kernel_items(bitset ritem_sees_lookahead_set , goto_number **internal_follow_edges ,
                                             bitsetv *follow_kernel_itemsp ) 
{ 
  size_t max_nitems ;
  state_number i ;
  goto_number i___0 ;
  size_t nitems ;
  item_number *items ;
  size_t j ;
  _Bool tmp ;
  symbol_number tmp___0 ;
  _Bool tmp___1 ;
  char *__cil_tmp13 ;

  {
#line 200
  max_nitems = (size_t )0;
#line 202
  i = 0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (i < nstates)) {
#line 202
      goto while_break;
    }
#line 203
    if ((*(states + i))->nitems > max_nitems) {
#line 204
      max_nitems = (*(states + i))->nitems;
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  *follow_kernel_itemsp = bitsetv_create(ngotos, max_nitems, 1U);
#line 209
  i___0 = (goto_number )0;
  }
  {
#line 209
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 209
    if (! (i___0 < ngotos)) {
#line 209
      goto while_break___0;
    }
#line 211
    nitems = (*(states + *(from_state + i___0)))->nitems;
#line 212
    items = (*(states + *(from_state + i___0)))->items;
#line 214
    j = (size_t )0;
    {
#line 214
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 214
      if (! (j < nitems)) {
#line 214
        goto while_break___1;
      }
      {
#line 218
      tmp = item_number_is_symbol_number(*(ritem + *(items + j)));
      }
#line 218
      if (tmp) {
        {
#line 218
        tmp___0 = item_number_as_symbol_number(*(ritem + *(items + j)));
        }
#line 218
        if (tmp___0 == (*(states + *(to_state + i___0)))->accessing_symbol) {
          {
#line 218
          tmp___1 = bitset_test(ritem_sees_lookahead_set, (bitset_bindex )*(items + j));
          }
#line 218
          if (tmp___1) {
            {
#line 222
            bitset_set(*(*follow_kernel_itemsp + i___0), j);
            }
          }
        }
      }
#line 214
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 209
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 225
  relation_digraph(internal_follow_edges, ngotos, follow_kernel_itemsp);
  }
#line 227
  if (trace_flag & 4096) {
    {
#line 229
    rpl_fprintf(stderr, "follow_kernel_items:\n");
#line 230
    debug_bitsetv(*follow_kernel_itemsp);
    }
  }
#line 232
  return;
}
}
#line 247 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static void ielr_compute_always_follows(goto_number ***edgesp , int const   *edge_counts ,
                                        bitsetv *always_followsp ) 
{ 
  goto_number *edge_array ;
  void *tmp ;
  goto_number i ;
  goto_number nedges ;
  int j ;
  transitions *trans ;
  symbol_number sym ;
  goto_number tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 252
  *always_followsp = bitsetv_create(ngotos, (bitset_bindex )ntokens, 1U);
#line 254
  tmp = xnmalloc(ngotos, (size_t )sizeof(*edge_array));
#line 254
  edge_array = (goto_number *)tmp;
#line 256
  i = (goto_number )0;
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (i < ngotos)) {
#line 256
      goto while_break;
    }
#line 258
    nedges = (goto_number )*(edge_counts + i);
#line 261
    trans = (*(states + *(to_state + i)))->transitions;
#line 262
    j = 0;
    {
#line 262
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 262
      if (j < trans->num) {
#line 262
        if (! ((unsigned long )trans->states[j] == (unsigned long )((void *)0))) {
#line 262
          if (! ((trans->states[j])->accessing_symbol < ntokens)) {
#line 262
            goto while_break___0;
          }
        }
      } else {
#line 262
        goto while_break___0;
      }
#line 262
      if (! ((unsigned long )trans->states[j] == (unsigned long )((void *)0))) {
        {
#line 263
        bitset_set(*(*always_followsp + i), (bitset_bindex )(trans->states[j])->accessing_symbol);
        }
      }
#line 262
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 264
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 264
      if (! (j < trans->num)) {
#line 264
        goto while_break___1;
      }
#line 266
      sym = (trans->states[j])->accessing_symbol;
#line 267
      if (*(nullable + (sym - ntokens))) {
        {
#line 268
        tmp___0 = nedges;
#line 268
        nedges ++;
#line 268
        *(edge_array + tmp___0) = map_goto(*(to_state + i), sym);
        }
      }
#line 264
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 271
    if (nedges - (goto_number )*(edge_counts + i)) {
      {
#line 273
      tmp___1 = xnrealloc((void *)*(*edgesp + i), nedges + 1U, (size_t )sizeof(*(*(*edgesp + i))));
#line 273
      *(*edgesp + i) = (goto_number *)tmp___1;
#line 275
      memcpy((void */* __restrict  */)(*(*edgesp + i) + *(edge_counts + i)), (void const   */* __restrict  */)(edge_array + *(edge_counts + i)),
             (size_t )((unsigned long )(nedges - (goto_number )*(edge_counts + i)) * sizeof(*(*(*edgesp + i)))));
#line 277
      *(*(*edgesp + i) + nedges) = (relation_node )-1;
      }
    }
#line 256
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  free((void *)edge_array);
#line 282
  relation_digraph(*edgesp, ngotos, always_followsp);
  }
#line 284
  if (trace_flag & 4096) {
    {
#line 286
    rpl_fprintf(stderr, "always follow edges:\n");
#line 287
    relation_print(*edgesp, ngotos, stderr);
#line 288
    rpl_fprintf(stderr, "always_follows:\n");
#line 289
    debug_bitsetv(*always_followsp);
    }
  }
#line 291
  return;
}
}
#line 300 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static state ***ielr_compute_predecessors(void) 
{ 
  state_number i ;
  int *predecessor_counts ;
  void *tmp ;
  state ***result ;
  void *tmp___0 ;
  int j ;
  void *tmp___1 ;
  int j___0 ;
  state_number k ;
  int tmp___2 ;

  {
  {
#line 304
  tmp = xnmalloc((size_t )nstates + 10, (size_t )sizeof(*predecessor_counts));
#line 304
  predecessor_counts = (int *)tmp;
#line 305
  tmp___0 = xnmalloc((size_t )nstates+10, (size_t )sizeof(*result));
#line 305
  result = (state ***)tmp___0;
#line 306
  i = 0;
  }
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i < nstates)) {
#line 306
      goto while_break;
    }
#line 307
    *(predecessor_counts + i) = 0;
#line 306
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 308
    if (! (i < nstates)) {
#line 308
      goto while_break___0;
    }
#line 311
    j = 0;
    {
#line 311
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 311
      if (! (j < ((*(states + i))->transitions)->num)) {
#line 311
        goto while_break___1;
      }
#line 312
      (*(predecessor_counts + (((*(states + i))->transitions)->states[j])->number)) ++;
#line 311
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 308
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 314
    if (! (i < nstates)) {
#line 314
      goto while_break___2;
    }
    {
#line 316
    tmp___1 = xnmalloc((size_t )(*(predecessor_counts + i) + 1), (size_t )sizeof(*(*(result + i))));
#line 316
    *(result + i) = (state **)tmp___1;
#line 317
    *(*(result + i) + *(predecessor_counts + i)) = (state *)((void *)0);
#line 318
    *(predecessor_counts + i) = 0;
#line 314
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 320
  i = 0;
  {
#line 320
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 320
    if (! (i < nstates)) {
#line 320
      goto while_break___3;
    }
#line 323
    j___0 = 0;
    {
#line 323
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 323
      if (! (j___0 < ((*(states + i))->transitions)->num)) {
#line 323
        goto while_break___4;
      }
#line 325
      k = (((*(states + i))->transitions)->states[j___0])->number;
#line 326
      tmp___2 = *(predecessor_counts + k);
#line 326
      (*(predecessor_counts + k)) ++;
#line 326
      *(*(result + k) + tmp___2) = *(states + i);
#line 323
      j___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 320
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 329
  free((void *)predecessor_counts);
  }
#line 330
  return (result);
}
}
#line 341 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static void ielr_compute_auxiliary_tables(bitsetv *follow_kernel_itemsp , bitsetv *always_followsp ,
                                          state ****predecessorsp ) 
{ 
  goto_number **edges ;
  int *edge_counts ;
  bitset ritem_sees_lookahead_set ;
  bitset tmp ;
  int i ;

  {
  {
#line 349
  tmp = ielr_compute_ritem_sees_lookahead_set();
#line 349
  ritem_sees_lookahead_set = tmp;
#line 350
  ielr_compute_internal_follow_edges(ritem_sees_lookahead_set, & edges, & edge_counts);
#line 352
  ielr_compute_follow_kernel_items(ritem_sees_lookahead_set, edges, follow_kernel_itemsp);
#line 354
  bitset_free(ritem_sees_lookahead_set);
#line 356
  ielr_compute_always_follows(& edges, (int const   *)edge_counts, always_followsp);
#line 359
  i = 0;
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! ((goto_number )i < ngotos)) {
#line 359
      goto while_break;
    }
    {
#line 360
    free((void *)*(edges + i));
#line 359
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 362
  free((void *)edges);
#line 363
  free((void *)edge_counts);
  }
#line 364
  if (predecessorsp) {
    {
#line 365
    *predecessorsp = ielr_compute_predecessors();
    }
  }
#line 366
  return;
}
}
#line 377 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
_Bool ielr_item_has_lookahead(state *s , symbol_number lhs , size_t item , symbol_number lookahead ,
                              state ***predecessors , bitset **item_lookahead_sets ) 
{ 
  size_t i ;
  void *tmp ;
  unsigned int i___0 ;
  _Bool tmp___0 ;
  rule_number tmp___1 ;
  state **predecessor ;
  goto_number tmp___2 ;
  state **predecessor___0 ;
  size_t predecessor_item ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 382
  if (! *(item_lookahead_sets + s->number)) {
    {
#line 385
    tmp = xnmalloc(s->nitems, (size_t )sizeof(*(*(item_lookahead_sets + s->number) + 0)));
#line 385
    *(item_lookahead_sets + s->number) = (bitset *)tmp;
#line 387
    i = (size_t )0;
    }
    {
#line 387
    while (1) {
      while_continue: /* CIL Label */ ;
#line 387
      if (! (i < s->nitems)) {
#line 387
        goto while_break;
      }
#line 388
      *(*(item_lookahead_sets + s->number) + i) = (bitset )((void *)0);
#line 387
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 390
  if (! *(*(item_lookahead_sets + s->number) + item)) {
    {
#line 392
    *(*(item_lookahead_sets + s->number) + item) = bitset_create((bitset_bindex )ntokens,
                                                                 (bitset_attrs )1);
    }
#line 409
    if (s->items[item] > 1) {
#line 413
      if (! lhs) {
#line 416
        i___0 = (unsigned int )s->items[item];
        {
#line 416
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 416
          tmp___0 = item_number_is_rule_number(*(ritem + i___0));
          }
#line 416
          if (tmp___0) {
#line 416
            goto while_break___0;
          }
#line 416
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 420
        tmp___1 = item_number_as_rule_number(*(ritem + i___0));
#line 420
        lhs = ((rules + tmp___1)->lhs)->number;
        }
      }
      {
#line 424
      tmp___3 = item_number_is_rule_number(*(ritem + (s->items[item] - 2)));
      }
#line 424
      if (tmp___3) {
#line 427
        if (! (lhs != accept->number)) {
          {
#line 427
          __assert_fail("lhs != accept->number", "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c",
                        427U, "ielr_item_has_lookahead");
          }
        }
#line 428
        predecessor = *(predecessors + s->number);
        {
#line 428
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 428
          if (! *predecessor) {
#line 428
            goto while_break___1;
          }
          {
#line 431
          tmp___2 = map_goto((*predecessor)->number, lhs);
#line 431
          (*(((*(*(item_lookahead_sets + s->number) + item))->b.vtable)->or_))(*(*(item_lookahead_sets + s->number) + item),
                                                                               *(*(item_lookahead_sets + s->number) + item),
                                                                               *(goto_follows + tmp___2));
#line 428
          predecessor ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 441
        predecessor___0 = *(predecessors + s->number);
        {
#line 441
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 441
          if (! *predecessor___0) {
#line 441
            goto while_break___2;
          }
#line 446
          predecessor_item = (size_t )0;
          {
#line 446
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 446
            if (! (predecessor_item < (*predecessor___0)->nitems)) {
#line 446
              goto while_break___3;
            }
#line 449
            if ((*predecessor___0)->items[predecessor_item] == s->items[item] - 1) {
#line 451
              goto while_break___3;
            }
#line 446
            predecessor_item ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 452
          if (! (predecessor_item != (*predecessor___0)->nitems)) {
            {
#line 452
            __assert_fail("predecessor_item != (*predecessor)->nitems", "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c",
                          452U, "ielr_item_has_lookahead");
            }
          }
          {
#line 453
          ielr_item_has_lookahead(*predecessor___0, lhs, predecessor_item, 0, predecessors,
                                  item_lookahead_sets);
#line 456
          (*(((*(*(item_lookahead_sets + s->number) + item))->b.vtable)->or_))(*(*(item_lookahead_sets + s->number) + item),
                                                                               *(*(item_lookahead_sets + s->number) + item),
                                                                               *(*(item_lookahead_sets + (*predecessor___0)->number) + predecessor_item));
#line 441
          predecessor___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 464
  tmp___4 = bitset_test(*(*(item_lookahead_sets + s->number) + item), (bitset_bindex )lookahead);
  }
#line 464
  return (tmp___4);
}
}
#line 482 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static void ielr_compute_annotation_lists(bitsetv follow_kernel_items , bitsetv always_follows ,
                                          state ***predecessors , AnnotationIndex *max_annotationsp ,
                                          InadequacyList ***inadequacy_listsp , AnnotationList ***annotation_listsp ,
                                          struct obstack *annotations_obstackp ) 
{ 
  bitset **item_lookahead_sets ;
  void *tmp ;
  AnnotationIndex *annotation_counts ;
  void *tmp___0 ;
  ContributionIndex max_contributions ;
  unsigned int total_annotations ;
  state_number i ;
  void *tmp___1 ;
  void *tmp___2 ;
  InadequacyListNodeCount inadequacy_list_node_count ;
  size_t j ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 490
  tmp = xnmalloc((size_t )nstates+10, (size_t )sizeof(*item_lookahead_sets));
#line 490
  item_lookahead_sets = (bitset **)tmp;
#line 492
  tmp___0 = xnmalloc((size_t )nstates+10, (size_t )sizeof(*annotation_counts));
#line 492
  annotation_counts = (AnnotationIndex *)tmp___0;
#line 494
  max_contributions = 0;
#line 495
  total_annotations = 0U;
#line 498
  tmp___1 = xnmalloc((size_t )nstates, (size_t )sizeof(*(*inadequacy_listsp)));
#line 498
  *inadequacy_listsp = (InadequacyList **)tmp___1;
#line 499
  tmp___2 = xnmalloc((size_t )nstates, (size_t )sizeof(*(*annotation_listsp)));
#line 499
  *annotation_listsp = (AnnotationList **)tmp___2;
#line 500
  i = 0;
  }
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    if (! (i < nstates)) {
#line 500
      goto while_break;
    }
#line 502
    *(item_lookahead_sets + i) = (bitset *)((void *)0);
#line 503
    *(*inadequacy_listsp + i) = (InadequacyList *)((void *)0);
#line 504
    *(*annotation_listsp + i) = (AnnotationList *)((void *)0);
#line 505
    *(annotation_counts + i) = (AnnotationIndex )0;
#line 500
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  inadequacy_list_node_count = (InadequacyListNodeCount )0;
#line 509
  i = 0;
  {
#line 509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 509
    if (! (i < nstates)) {
#line 509
      goto while_break___0;
    }
    {
#line 510
    AnnotationList__compute_from_inadequacies(*(states + i), follow_kernel_items,
                                              always_follows, predecessors, item_lookahead_sets,
                                              *inadequacy_listsp, *annotation_listsp,
                                              annotation_counts, & max_contributions,
                                              annotations_obstackp, & inadequacy_list_node_count);
#line 509
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 516
  *max_annotationsp = (AnnotationIndex )0;
#line 517
  i = 0;
  {
#line 517
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 517
    if (! (i < nstates)) {
#line 517
      goto while_break___1;
    }
#line 519
    if (*(annotation_counts + i) > *max_annotationsp) {
#line 520
      *max_annotationsp = *(annotation_counts + i);
    }
#line 521
    total_annotations += *(annotation_counts + i);
#line 517
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 523
  if (trace_flag & 4096) {
#line 525
    i = 0;
    {
#line 525
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 525
      if (! (i < nstates)) {
#line 525
        goto while_break___2;
      }
      {
#line 527
      rpl_fprintf(stderr, "Inadequacy annotations for state %d:\n", i);
#line 528
      AnnotationList__debug((AnnotationList const   *)*(*annotation_listsp + i), (*(states + i))->nitems,
                            2);
#line 525
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 531
    rpl_fprintf(stderr, "Number of LR(0)/LALR(1) states: %d\n", nstates);
#line 532
    rpl_fprintf(stderr, "Average number of annotations per state: %f\n", (double )((float )total_annotations / (float )nstates));
#line 534
    rpl_fprintf(stderr, "Max number of annotations per state: %d\n", *max_annotationsp);
#line 536
    rpl_fprintf(stderr, "Max number of contributions per annotation: %d\n", max_contributions);
    }
  }
#line 539
  i = 0;
  {
#line 539
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 539
    if (! (i < nstates)) {
#line 539
      goto while_break___3;
    }
#line 540
    if (*(item_lookahead_sets + i)) {
#line 543
      j = (size_t )0;
      {
#line 543
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 543
        if (! (j < (*(states + i))->nitems)) {
#line 543
          goto while_break___4;
        }
#line 544
        if (*(*(item_lookahead_sets + i) + j)) {
          {
#line 545
          bitset_free(*(*(item_lookahead_sets + i) + j));
          }
        }
#line 543
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 546
      free((void *)*(item_lookahead_sets + i));
      }
    }
#line 539
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 548
  free((void *)item_lookahead_sets);
#line 549
  free((void *)annotation_counts);
  }
#line 550
  return;
}
}
#line 580 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static void ielr_compute_goto_follow_set(bitsetv follow_kernel_items , bitsetv always_follows ,
                                         state_list *s , symbol *n , bitset follow_set ) 
{ 
  goto_number n_goto ;
  goto_number tmp ;
  bitset_iterator biter_item ;
  bitset_bindex item ;

  {
  {
#line 585
  tmp = map_goto(((s->lr0Isocore)->state)->number, n->number);
#line 585
  n_goto = tmp;
#line 586
  (*(((*(always_follows + n_goto))->b.vtable)->copy))(follow_set, *(always_follows + n_goto));
  }
#line 587
  if (s->lookaheads) {
#line 591
    biter_item.next = (bitset_bindex )0;
#line 591
    biter_item.num = (bitset_bindex )1024;
    {
#line 591
    while (1) {
      while_continue: /* CIL Label */ ;
#line 591
      if (biter_item.num == 1024U) {
        {
#line 591
        biter_item.num = (*(((*(follow_kernel_items + n_goto))->b.vtable)->list))(*(follow_kernel_items + n_goto),
                                                                                  biter_item.list,
                                                                                  (bitset_bindex )1024,
                                                                                  & biter_item.next);
        }
#line 591
        if (! biter_item.num) {
#line 591
          goto while_break;
        }
      } else {
#line 591
        goto while_break;
      }
#line 591
      biter_item.i = (bitset_bindex )0;
      {
#line 591
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 591
        if (biter_item.i < biter_item.num) {
#line 591
          item = biter_item.list[biter_item.i];
        } else {
#line 591
          goto while_break___0;
        }
#line 592
        if (*(s->lookaheads + item)) {
          {
#line 593
          (*((follow_set->b.vtable)->or_))(follow_set, follow_set, *(s->lookaheads + item));
          }
        }
#line 591
        (biter_item.i) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 595
  return;
}
}
#line 612 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static void ielr_compute_lookaheads(bitsetv follow_kernel_items , bitsetv always_follows ,
                                    state_list *s , state *t , bitsetv lookahead_filter ,
                                    bitsetv lookaheads ) 
{ 
  size_t s_item ;
  size_t t_item ;
  unsigned int rule_item ;
  _Bool tmp ;
  rule_number tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 617
  s_item = (size_t )0;
#line 619
  bitsetv_zero(lookaheads);
#line 620
  t_item = (size_t )0;
  }
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! (t_item < t->nitems)) {
#line 620
      goto while_break;
    }
#line 628
    if (! (t->items[t_item] != 0)) {
      {
#line 628
      __assert_fail("t->items[t_item] != 0", "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c",
                    628U, "ielr_compute_lookaheads");
      }
    }
#line 629
    if (t->items[t_item] > 1) {
      {
#line 629
      tmp___2 = (*(((*(lookahead_filter + t_item))->b.vtable)->empty_p))(*(lookahead_filter + t_item));
      }
#line 629
      if (! tmp___2) {
        {
#line 632
        tmp___1 = item_number_is_rule_number(*(ritem + (t->items[t_item] - 2)));
        }
#line 632
        if (tmp___1) {
#line 635
          rule_item = (unsigned int )t->items[t_item];
          {
#line 635
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 635
            tmp = item_number_is_rule_number(*(ritem + rule_item));
            }
#line 635
            if (tmp) {
#line 635
              goto while_break___0;
            }
#line 635
            rule_item ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 639
          tmp___0 = item_number_as_rule_number(*(ritem + rule_item));
#line 639
          ielr_compute_goto_follow_set(follow_kernel_items, always_follows, s, (rules + tmp___0)->lhs,
                                       *(lookaheads + t_item));
          }
        } else
#line 644
        if (s->lookaheads) {
          {
#line 649
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 649
            if (! (s_item < (s->state)->nitems)) {
#line 649
              goto while_break___1;
            }
#line 650
            if ((s->state)->items[s_item] == t->items[t_item] - 1) {
#line 651
              goto while_break___1;
            }
#line 649
            s_item ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 652
          if (! (s_item != (s->state)->nitems)) {
            {
#line 652
            __assert_fail("s_item != s->state->nitems", "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c",
                          652U, "ielr_compute_lookaheads");
            }
          }
#line 653
          if (*(s->lookaheads + s_item)) {
            {
#line 654
            (*(((*(s->lookaheads + s_item))->b.vtable)->copy))(*(lookaheads + t_item),
                                                               *(s->lookaheads + s_item));
            }
          }
        }
        {
#line 656
        (*(((*(lookaheads + t_item))->b.vtable)->and_))(*(lookaheads + t_item), *(lookaheads + t_item),
                                                        *(lookahead_filter + t_item));
        }
      }
    }
#line 620
    t_item ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  return;
}
}
#line 698 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static void ielr_compute_state(bitsetv follow_kernel_items , bitsetv always_follows ,
                               AnnotationList **annotation_lists , state *t , bitsetv lookaheads ,
                               state_list **last_statep , ContributionIndex *work1 ,
                               bitsetv work2 , state **tp ) 
{ 
  state_list *lr0_isocore ;
  state_list **this_isocorep ;
  _Bool has_lookaheads ;
  AnnotationIndex ai ;
  AnnotationList *a ;
  ContributionIndex ci ;
  ContributionIndex tmp ;
  size_t i ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  size_t i___0 ;
  _Bool tmp___2 ;
  _Bool new_lookaheads ;
  size_t i___1 ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int i___2 ;
  state *t2 ;
  state_list *old_isocore ;
  state_list *tmp___6 ;
  void *tmp___7 ;
  state *tmp___8 ;
  size_t i___3 ;
  void *tmp___9 ;
  _Bool tmp___10 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 704
  lr0_isocore = (t->state_list)->lr0Isocore;
#line 713
  if (annotation_lists) {
#line 714
    ai = (AnnotationIndex )0;
#line 714
    a = *(annotation_lists + (lr0_isocore->state)->number);
    {
#line 714
    while (1) {
      while_continue: /* CIL Label */ ;
#line 714
      if (! a) {
#line 714
        goto while_break;
      }
      {
#line 717
      *(work1 + ai) = AnnotationList__computeDominantContribution((AnnotationList const   *)a,
                                                                  (lr0_isocore->state)->nitems,
                                                                  lookaheads, (_Bool)0);
#line 714
      ai ++;
#line 714
      a = a->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 720
  this_isocorep = & t->state_list;
  {
#line 720
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 720
    if (! ((unsigned long )this_isocorep == (unsigned long )(& t->state_list))) {
#line 720
      if (! ((unsigned long )*this_isocorep != (unsigned long )t->state_list)) {
#line 720
        goto while_break___0;
      }
    }
#line 724
    if (! (*this_isocorep)->recomputedAsSuccessor) {
#line 725
      goto while_break___0;
    }
#line 726
    if (annotation_lists) {
#line 728
      ai = (AnnotationIndex )0;
#line 728
      a = *(annotation_lists + (lr0_isocore->state)->number);
      {
#line 728
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 728
        if (! a) {
#line 728
          goto while_break___1;
        }
#line 732
        if (*(work1 + ai) != (ContributionIndex )ContributionIndex__none) {
          {
#line 739
          tmp = AnnotationList__computeDominantContribution((AnnotationList const   *)a,
                                                            (lr0_isocore->state)->nitems,
                                                            (*this_isocorep)->lookaheads,
                                                            (_Bool)0);
#line 739
          ci = tmp;
          }
#line 743
          if (ci != (ContributionIndex )ContributionIndex__none) {
#line 743
            if (*(work1 + ai) != ci) {
#line 744
              goto while_break___1;
            }
          }
        }
#line 728
        ai ++;
#line 728
        a = a->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 747
      if (! a) {
#line 748
        goto while_break___0;
      }
    } else {
#line 753
      i = (size_t )0;
      {
#line 753
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 753
        if (! (i < t->nitems)) {
#line 753
          goto while_break___2;
        }
#line 755
        if (! (*this_isocorep)->lookaheads) {
#line 755
          goto _L;
        } else
#line 755
        if (! *((*this_isocorep)->lookaheads + i)) {
          _L: /* CIL Label */ 
          {
#line 758
          tmp___0 = (*(((*(lookaheads + i))->b.vtable)->empty_p))(*(lookaheads + i));
          }
#line 758
          if (! tmp___0) {
#line 759
            goto while_break___2;
          }
        } else {
          {
#line 763
          tmp___1 = (*(((*(lookaheads + i))->b.vtable)->equal_p))(*((*this_isocorep)->lookaheads + i),
                                                                  *(lookaheads + i));
          }
#line 763
          if (! tmp___1) {
#line 765
            goto while_break___2;
          }
        }
#line 753
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 767
      if (i == t->nitems) {
#line 768
        goto while_break___0;
      }
    }
#line 720
    this_isocorep = & (*this_isocorep)->nextIsocore;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 773
  has_lookaheads = (_Bool)0;
#line 776
  i___0 = (size_t )0;
  {
#line 776
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 776
    if (! (i___0 < (lr0_isocore->state)->nitems)) {
#line 776
      goto while_break___3;
    }
    {
#line 777
    tmp___2 = (*(((*(lookaheads + i___0))->b.vtable)->empty_p))(*(lookaheads + i___0));
    }
#line 777
    if (! tmp___2) {
#line 779
      has_lookaheads = (_Bool)1;
#line 780
      goto while_break___3;
    }
#line 776
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 785
  if ((unsigned long )this_isocorep == (unsigned long )(& t->state_list)) {
#line 785
    goto _L___0;
  } else
#line 785
  if ((unsigned long )*this_isocorep != (unsigned long )t->state_list) {
    _L___0: /* CIL Label */ 
#line 787
    new_lookaheads = (_Bool)0;
#line 788
    *tp = (*this_isocorep)->state;
#line 792
    if (has_lookaheads) {
#line 795
      if (! (*this_isocorep)->lookaheads) {
        {
#line 797
        tmp___3 = xnmalloc(t->nitems, (size_t )sizeof((*this_isocorep)->lookaheads));
#line 797
        (*this_isocorep)->lookaheads = (bitset *)tmp___3;
#line 799
        i___1 = (size_t )0;
        }
        {
#line 799
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 799
          if (! (i___1 < t->nitems)) {
#line 799
            goto while_break___4;
          }
#line 800
          *((*this_isocorep)->lookaheads + i___1) = (bitset )((void *)0);
#line 799
          i___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 802
      i___1 = (size_t )0;
      {
#line 802
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 802
        if (! (i___1 < t->nitems)) {
#line 802
          goto while_break___5;
        }
        {
#line 803
        tmp___5 = (*(((*(lookaheads + i___1))->b.vtable)->empty_p))(*(lookaheads + i___1));
        }
#line 803
        if (! tmp___5) {
#line 805
          if (! *((*this_isocorep)->lookaheads + i___1)) {
            {
#line 806
            *((*this_isocorep)->lookaheads + i___1) = bitset_create((bitset_bindex )ntokens,
                                                                    (bitset_attrs )1);
            }
          }
          {
#line 808
          (*(((*(lookaheads + i___1))->b.vtable)->andn))(*(lookaheads + i___1), *(lookaheads + i___1),
                                                         *((*this_isocorep)->lookaheads + i___1));
#line 810
          (*(((*(lookaheads + i___1))->b.vtable)->or_))(*((*this_isocorep)->lookaheads + i___1),
                                                        *(lookaheads + i___1), *((*this_isocorep)->lookaheads + i___1));
#line 812
          tmp___4 = (*(((*(lookaheads + i___1))->b.vtable)->empty_p))(*(lookaheads + i___1));
          }
#line 812
          if (! tmp___4) {
#line 813
            new_lookaheads = (_Bool)1;
          }
        }
#line 802
        i___1 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 821
    if (! (*this_isocorep)->recomputedAsSuccessor) {
#line 822
      (*this_isocorep)->recomputedAsSuccessor = (_Bool)1;
    } else
#line 823
    if (new_lookaheads) {
#line 828
      if (! annotation_lists) {
        {
#line 828
        __assert_fail("annotation_lists", "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c",
                      828U, "ielr_compute_state");
        }
      }
#line 829
      i___2 = 0;
      {
#line 829
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 829
        if (! (i___2 < ((*tp)->transitions)->num)) {
#line 829
          goto while_break___6;
        }
#line 831
        t2 = ((*tp)->transitions)->states[i___2];
#line 842
        if (! (t2->state_list)->recomputedAsSuccessor) {
#line 843
          goto while_break___6;
        }
        {
#line 844
        AnnotationList__computeLookaheadFilter((AnnotationList const   *)*(annotation_lists + (((t2->state_list)->lr0Isocore)->state)->number),
                                               t2->nitems, work2);
#line 847
        ielr_compute_lookaheads(follow_kernel_items, always_follows, *this_isocorep,
                                t2, work2, lookaheads);
#line 900
        ielr_compute_state(follow_kernel_items, always_follows, annotation_lists,
                           t2, lookaheads, last_statep, work1, work2, & ((*tp)->transitions)->states[i___2]);
#line 829
        i___2 ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 911
    old_isocore = *this_isocorep;
#line 912
    tmp___7 = xmalloc((size_t )sizeof(*(*last_statep)));
#line 912
    tmp___6 = (state_list *)tmp___7;
#line 912
    *this_isocorep = tmp___6;
#line 912
    (*last_statep)->next = tmp___6;
#line 913
    *last_statep = *this_isocorep;
#line 914
    tmp___8 = state_new_isocore((state const   *)t);
#line 914
    *tp = tmp___8;
#line 914
    (*last_statep)->state = tmp___8;
#line 915
    (*tp)->state_list = *last_statep;
#line 916
    (*last_statep)->recomputedAsSuccessor = (_Bool)1;
#line 917
    (*last_statep)->next = (struct state_list *)((void *)0);
#line 918
    (*last_statep)->lookaheads = (bitset *)((void *)0);
    }
#line 919
    if (has_lookaheads) {
      {
#line 922
      tmp___9 = xnmalloc(t->nitems, (size_t )sizeof((*last_statep)->lookaheads));
#line 922
      (*last_statep)->lookaheads = (bitset *)tmp___9;
#line 924
      i___3 = (size_t )0;
      }
      {
#line 924
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 924
        if (! (i___3 < t->nitems)) {
#line 924
          goto while_break___7;
        }
        {
#line 926
        tmp___10 = (*(((*(lookaheads + i___3))->b.vtable)->empty_p))(*(lookaheads + i___3));
        }
#line 926
        if (tmp___10) {
#line 927
          *((*last_statep)->lookaheads + i___3) = (bitset )((void *)0);
        } else {
          {
#line 930
          *((*last_statep)->lookaheads + i___3) = bitset_create((bitset_bindex )ntokens,
                                                                (bitset_attrs )1);
#line 932
          (*(((*(lookaheads + i___3))->b.vtable)->copy))(*((*last_statep)->lookaheads + i___3),
                                                         *(lookaheads + i___3));
          }
        }
#line 924
        i___3 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 936
    (*last_statep)->lr0Isocore = lr0_isocore;
#line 937
    (*last_statep)->nextIsocore = old_isocore;
  }
#line 939
  return;
}
}
#line 959 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
static void ielr_split_states(bitsetv follow_kernel_items , bitsetv always_follows ,
                              AnnotationList **annotation_lists , AnnotationIndex max_annotations ) 
{ 
  state_list *first_state___0 ;
  state_list *last_state___0 ;
  bitsetv lookahead_filter ;
  bitsetv lookaheads ;
  size_t max_nitems ;
  state_number i ;
  state_list **nodep ;
  struct state_list *tmp ;
  void *tmp___0 ;
  ContributionIndex *work ;
  void *tmp___1 ;
  state_list *this_state ;
  state *s ;
  int i___0 ;
  state *t ;
  void *tmp___2 ;
  state_list *node ;
  state_list *node___0 ;
  size_t i___1 ;
  item_number *itemset___0 ;
  size_t r ;
  rule *this_rule ;
  bitset lookahead_set___0 ;
  _Bool tmp___3 ;
  rule_number tmp___4 ;
  _Bool tmp___5 ;
  state_list *node___1 ;
  size_t i___2 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 966
  lookahead_filter = (bitsetv )((void *)0);
#line 971
  max_nitems = (size_t )0;
#line 973
  nodep = & first_state___0;
#line 974
  i = 0;
  {
#line 974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 974
    if (! (i < nstates)) {
#line 974
      goto while_break;
    }
    {
#line 976
    tmp___0 = xmalloc((size_t )sizeof(*(*nodep)));
#line 976
    last_state___0 = (state_list *)tmp___0;
#line 976
    tmp = last_state___0;
#line 976
    (*(states + i))->state_list = tmp;
#line 976
    *nodep = tmp;
#line 977
    (*nodep)->state = *(states + i);
#line 978
    (*nodep)->recomputedAsSuccessor = (_Bool)0;
#line 979
    (*nodep)->lookaheads = (bitset *)((void *)0);
#line 980
    (*nodep)->lr0Isocore = *nodep;
#line 981
    (*nodep)->nextIsocore = *nodep;
#line 982
    nodep = & (*nodep)->next;
    }
#line 983
    if ((*(states + i))->nitems > max_nitems) {
#line 984
      max_nitems = (*(states + i))->nitems;
    }
#line 974
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 986
  *nodep = (state_list *)((void *)0);
#line 987
  lookahead_filter = bitsetv_create(max_nitems, (bitset_bindex )ntokens, 1U);
  }
#line 988
  if (! annotation_lists) {
    {
#line 989
    bitsetv_ones(lookahead_filter);
    }
  }
  {
#line 990
  lookaheads = bitsetv_create(max_nitems, (bitset_bindex )ntokens, 1U);
#line 995
  tmp___1 = xnmalloc(max_annotations, (size_t )sizeof(*work));
#line 995
  work = (ContributionIndex *)tmp___1;
#line 997
  this_state = first_state___0;
  }
  {
#line 997
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 997
    if (! this_state) {
#line 997
      goto while_break___0;
    }
#line 999
    s = this_state->state;
#line 1001
    i___0 = 0;
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1001
      if (! (i___0 < (s->transitions)->num)) {
#line 1001
        goto while_break___1;
      }
#line 1003
      t = (s->transitions)->states[i___0];
#line 1004
      if (annotation_lists) {
        {
#line 1005
        AnnotationList__computeLookaheadFilter((AnnotationList const   *)*(annotation_lists + (((t->state_list)->lr0Isocore)->state)->number),
                                               t->nitems, lookahead_filter);
        }
      }
      {
#line 1008
      ielr_compute_lookaheads(follow_kernel_items, always_follows, this_state, t,
                              lookahead_filter, lookaheads);
#line 1011
      ielr_compute_state(follow_kernel_items, always_follows, annotation_lists, t,
                         lookaheads, & last_state___0, work, lookahead_filter, & (s->transitions)->states[i___0]);
#line 1001
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 997
    this_state = this_state->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1017
  free((void *)work);
#line 1020
  bitsetv_free(lookahead_filter);
#line 1021
  bitsetv_free(lookaheads);
#line 1024
  tmp___2 = xnrealloc((void *)states, (size_t )nstates, (size_t )sizeof(*states));
#line 1024
  states = (state **)tmp___2;
#line 1027
  node = first_state___0;
  }
  {
#line 1027
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1027
    if (! node) {
#line 1027
      goto while_break___2;
    }
#line 1028
    *(states + (node->state)->number) = node->state;
#line 1027
    node = node->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1033
  if (! annotation_lists) {
    {
#line 1035
    timevar_push((timevar_id_t )11);
#line 1036
    initialize_LA();
#line 1038
    node___0 = first_state___0;
    }
    {
#line 1038
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1038
      if (! node___0) {
#line 1038
        goto while_break___3;
      }
#line 1039
      if (! (node___0->state)->consistent) {
#line 1041
        i___1 = (size_t )0;
#line 1042
        itemset___0 = (node___0->state)->items;
#line 1044
        r = (size_t )0;
        {
#line 1044
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1044
          if (! (r < (size_t )((node___0->state)->reductions)->num)) {
#line 1044
            goto while_break___4;
          }
          {
#line 1046
          this_rule = ((node___0->state)->reductions)->rules[r];
#line 1047
          lookahead_set___0 = *(((node___0->state)->reductions)->lookahead_tokens + r);
#line 1049
          tmp___5 = item_number_is_rule_number(*(this_rule->rhs));
          }
#line 1049
          if (tmp___5) {
            {
#line 1050
            ielr_compute_goto_follow_set(follow_kernel_items, always_follows, node___0,
                                         this_rule->lhs, lookahead_set___0);
            }
          } else
#line 1053
          if (node___0->lookaheads) {
            {
#line 1058
            while (1) {
              while_continue___5: /* CIL Label */ ;
              {
#line 1058
              tmp___3 = item_number_is_rule_number(*(ritem + *(itemset___0 + i___1)));
              }
#line 1058
              if (tmp___3) {
                {
#line 1058
                tmp___4 = item_number_as_rule_number(*(ritem + *(itemset___0 + i___1)));
                }
#line 1058
                if (! (tmp___4 != this_rule->number)) {
#line 1058
                  goto while_break___5;
                }
              }
#line 1062
              i___1 ++;
#line 1063
              if (! (i___1 < (node___0->state)->nitems)) {
                {
#line 1063
                __assert_fail("i < node->state->nitems", "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c",
                              1063U, "ielr_split_states");
                }
              }
            }
            while_break___5: /* CIL Label */ ;
            }
#line 1065
            if (*(node___0->lookaheads + i___1)) {
              {
#line 1066
              (*(((*(node___0->lookaheads + i___1))->b.vtable)->copy))(lookahead_set___0,
                                                                       *(node___0->lookaheads + i___1));
              }
            }
          }
#line 1044
          r ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 1038
      node___0 = node___0->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1070
    timevar_pop((timevar_id_t )11);
    }
  }
  {
#line 1074
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1074
    if (! first_state___0) {
#line 1074
      goto while_break___6;
    }
#line 1076
    node___1 = first_state___0;
#line 1077
    if (node___1->lookaheads) {
#line 1080
      i___2 = (size_t )0;
      {
#line 1080
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1080
        if (! (i___2 < (node___1->state)->nitems)) {
#line 1080
          goto while_break___7;
        }
#line 1081
        if (*(node___1->lookaheads + i___2)) {
          {
#line 1082
          bitset_free(*(node___1->lookaheads + i___2));
          }
        }
#line 1080
        i___2 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1083
      free((void *)node___1->lookaheads);
      }
    }
    {
#line 1085
    first_state___0 = node___1->next;
#line 1086
    free((void *)node___1);
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1088
  return;
}
}
#line 1090 "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c"
void ielr(void) 
{ 
  LrType lr_type ;
  char *type ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bitsetv follow_kernel_items ;
  bitsetv always_follows ;
  InadequacyList **inadequacy_lists ;
  AnnotationList **annotation_lists ;
  struct obstack annotations_obstack ;
  AnnotationIndex max_annotations ;
  state ***predecessors ;
  state ****tmp___3 ;
  state_number i ;
  state_number nstates_lr0 ;
  state_number i___0 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp___4 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 1097
  tmp = muscle_percent_define_get("lr.type");
#line 1097
  type = tmp;
#line 1098
  tmp___2 = strcmp((char const   *)type, "lalr");
  }
#line 1098
  if (0 == tmp___2) {
#line 1099
    lr_type = (LrType )0;
  } else {
    {
#line 1100
    tmp___1 = strcmp((char const   *)type, "ielr");
    }
#line 1100
    if (0 == tmp___1) {
#line 1101
      lr_type = (LrType )1;
    } else {
      {
#line 1102
      tmp___0 = strcmp((char const   *)type, "canonical-lr");
      }
#line 1102
      if (0 == tmp___0) {
#line 1103
        lr_type = (LrType )2;
      } else {
        {
#line 1105
        __assert_fail("0", "/home/pronto/abs/test-suite/bison-2.5/src/ielr.c", 1105U,
                      "ielr");
        }
      }
    }
  }
  {
#line 1106
  free((void *)type);
#line 1110
  timevar_push((timevar_id_t )7);
  }
#line 1111
  if ((unsigned int )lr_type == 2U) {
    {
#line 1112
    set_goto_map();
    }
  } else {
    {
#line 1114
    lalr();
    }
  }
#line 1115
  if ((unsigned int )lr_type == 0U) {
    {
#line 1117
    bitsetv_free(goto_follows);
#line 1118
    timevar_pop((timevar_id_t )7);
    }
#line 1119
    return;
  }
  {
#line 1121
  timevar_pop((timevar_id_t )7);
#line 1126
  inadequacy_lists = (InadequacyList **)((void *)0);
#line 1127
  annotation_lists = (AnnotationList **)((void *)0);
#line 1129
  max_annotations = (AnnotationIndex )0;
#line 1134
  timevar_push((timevar_id_t )8);
  }
#line 1135
  if ((unsigned int )lr_type == 2U) {
#line 1135
    tmp___3 = (state ****)((void *)0);
  } else {
#line 1135
    tmp___3 = & predecessors;
  }
  {
#line 1135
  ielr_compute_auxiliary_tables(& follow_kernel_items, & always_follows, tmp___3);
#line 1138
  timevar_pop((timevar_id_t )8);
#line 1141
  timevar_push((timevar_id_t )9);
  }
#line 1142
  if ((unsigned int )lr_type != 2U) {
    {
#line 1144
    _obstack_begin(& annotations_obstack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 1145
    ielr_compute_annotation_lists(follow_kernel_items, always_follows, predecessors,
                                  & max_annotations, & inadequacy_lists, & annotation_lists,
                                  & annotations_obstack);
#line 1151
    i = 0;
    }
    {
#line 1151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1151
      if (! (i < nstates)) {
#line 1151
        goto while_break;
      }
      {
#line 1152
      free((void *)*(predecessors + i));
#line 1151
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1154
    free((void *)predecessors);
#line 1155
    bitsetv_free(goto_follows);
#line 1156
    lalr_free();
    }
  }
  {
#line 1158
  timevar_pop((timevar_id_t )9);
#line 1162
  timevar_push((timevar_id_t )10);
#line 1164
  nstates_lr0 = nstates;
#line 1165
  ielr_split_states(follow_kernel_items, always_follows, annotation_lists, max_annotations);
  }
#line 1167
  if (inadequacy_lists) {
#line 1170
    i___0 = 0;
    {
#line 1170
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1170
      if (! (i___0 < nstates_lr0)) {
#line 1170
        goto while_break___0;
      }
      {
#line 1171
      InadequacyList__delete(*(inadequacy_lists + i___0));
#line 1170
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1174
  free((void *)inadequacy_lists);
  }
#line 1175
  if (annotation_lists) {
#line 1176
    __o = & annotations_obstack;
#line 1176
    __obj = (void *)0;
#line 1176
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 1176
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 1176
        tmp___4 = (char *)__obj;
#line 1176
        __o->object_base = tmp___4;
#line 1176
        __o->next_free = tmp___4;
      } else {
        {
#line 1176
        obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 1176
      obstack_free(__o, __obj);
      }
    }
  }
  {
#line 1177
  free((void *)annotation_lists);
#line 1178
  bitsetv_free(follow_kernel_items);
#line 1179
  bitsetv_free(always_follows);
#line 1180
  timevar_pop((timevar_id_t )10);
#line 1184
  timevar_push((timevar_id_t )11);
#line 1185
  free((void *)goto_map);
#line 1186
  free((void *)from_state);
#line 1187
  free((void *)to_state);
  }
#line 1188
  if ((unsigned int )lr_type == 2U) {
    {
#line 1192
    set_goto_map();
    }
  } else {
    {
#line 1196
    lalr();
#line 1197
    bitsetv_free(goto_follows);
    }
  }
  {
#line 1199
  timevar_pop((timevar_id_t )11);
  }
#line 1200
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 252 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
size_t ritem_longest_rhs(void) ;
#line 88 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.h"
goto_number *goto_map  ;
#line 91 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.h"
goto_number ngotos  ;
#line 94 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.h"
state_number *from_state  ;
#line 97 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.h"
state_number *to_state  ;
#line 48 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
bitsetv goto_follows  =    (bitsetv )((void *)0);
#line 63 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static bitsetv LA  =    (bitsetv )((void *)0);
#line 64 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
size_t nLA  ;
#line 67 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static goto_number **includes  ;
#line 68 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static goto_list **lookback  ;
#line 73 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
void set_goto_map(void) 
{ 
  state_number s ;
  goto_number *temp_map ;
  void *tmp ;
  void *tmp___0 ;
  transitions *sp ;
  int i ;
  goto_number k ;
  int i___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  transitions *sp___0 ;
  int i___1 ;
  goto_number k___0 ;
  goto_number tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 79
  tmp = xcalloc((size_t )(nvars + 1), (size_t )sizeof(*goto_map));
#line 79
  goto_map = (goto_number *)tmp;
#line 80
  tmp___0 = xnmalloc((size_t )(nvars + 1), (size_t )sizeof(*temp_map));
#line 80
  temp_map = (goto_number *)tmp___0;
#line 82
  ngotos = (goto_number )0;
#line 83
  s = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (s < nstates)) {
#line 83
      goto while_break;
    }
#line 85
    sp = (*(states + s))->transitions;
#line 87
    i = sp->num - 1;
    {
#line 87
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 87
      if (i >= 0) {
#line 87
        if (! (! ((sp->states[i])->accessing_symbol < ntokens))) {
#line 87
          goto while_break___0;
        }
      } else {
#line 87
        goto while_break___0;
      }
#line 89
      ngotos ++;
#line 92
      if (! (ngotos != 4294967295U)) {
        {
#line 92
        __assert_fail("ngotos != ((goto_number) -1)", "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c",
                      92U, "set_goto_map");
        }
      }
#line 94
      (*(goto_map + ((sp->states[i])->accessing_symbol - ntokens))) ++;
#line 87
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 83
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  k = (goto_number )0;
#line 101
  i___0 = ntokens;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i___0 < nsyms)) {
#line 101
      goto while_break___1;
    }
#line 103
    *(temp_map + (i___0 - ntokens)) = k;
#line 104
    k += *(goto_map + (i___0 - ntokens));
#line 101
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 107
  i___0 = ntokens;
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 107
    if (! (i___0 < nsyms)) {
#line 107
      goto while_break___2;
    }
#line 108
    *(goto_map + (i___0 - ntokens)) = *(temp_map + (i___0 - ntokens));
#line 107
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 110
  *(goto_map + (nsyms - ntokens)) = ngotos;
#line 111
  *(temp_map + (nsyms - ntokens)) = ngotos;
#line 114
  tmp___1 = xcalloc(ngotos + 1, (size_t )sizeof(*from_state));
#line 114
  from_state = (state_number *)tmp___1;
#line 115
  tmp___2 = xcalloc(ngotos + 10, (size_t )sizeof(*to_state));
#line 115
  to_state = (state_number *)tmp___2;
#line 117
  s = 0;
  }
  {
#line 117
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 117
    if (! (s < nstates)) {
#line 117
      goto while_break___3;
    }
#line 119
    sp___0 = (*(states + s))->transitions;
#line 121
    i___1 = sp___0->num - 1;
    {
#line 121
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 121
      if (i___1 >= 0) {
#line 121
        if (! (! ((sp___0->states[i___1])->accessing_symbol < ntokens))) {
#line 121
          goto while_break___4;
        }
      } else {
#line 121
        goto while_break___4;
      }
#line 123
      tmp___3 = *(temp_map + ((sp___0->states[i___1])->accessing_symbol - ntokens));
#line 123
      (*(temp_map + ((sp___0->states[i___1])->accessing_symbol - ntokens))) ++;
#line 123
      k___0 = tmp___3;
#line 124
      *(from_state + k___0) = s;
#line 125
      *(to_state + k___0) = (sp___0->states[i___1])->number;
#line 121
      i___1 --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 117
    s ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 129
  free((void *)temp_map);
  }
#line 130
  return;
}
}
#line 133 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
goto_number map_goto(state_number s0 , symbol_number sym ) 
{ 
  goto_number high___0 ;
  goto_number low ;
  goto_number middle ;
  state_number s ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 141
  low = *(goto_map + (sym - ntokens));
#line 142
  high___0 = *(goto_map + ((sym - ntokens) + 1)) - 1U;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (low <= high___0)) {
      {
#line 146
      __assert_fail("low <= high", "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c",
                    146U, "map_goto");
      }
    }
#line 147
    middle = (low + high___0) / 2U;
#line 148
    s = *(from_state + middle);
#line 149
    if (s == s0) {
#line 150
      return (middle);
    } else
#line 151
    if (s < s0) {
#line 152
      low = middle + 1U;
    } else {
#line 154
      high___0 = middle - 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 159 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static void initialize_F(void) 
{ 
  goto_number **reads ;
  void *tmp ;
  goto_number *edge ;
  void *tmp___0 ;
  goto_number nedges ;
  goto_number i ;
  state_number stateno ;
  transitions *sp ;
  int j ;
  symbol_number sym ;
  goto_number tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 162
  tmp = xnmalloc(ngotos+10, (size_t )sizeof(*reads));
#line 162
  reads = (goto_number **)tmp;
#line 163
  tmp___0 = xnmalloc(ngotos + 1U, (size_t )sizeof(*edge));
#line 163
  edge = (goto_number *)tmp___0;
#line 164
  nedges = (goto_number )0;
#line 168
  goto_follows = bitsetv_create(ngotos, (bitset_bindex )ntokens, 1U);
#line 170
  i = (goto_number )0;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < ngotos)) {
#line 170
      goto while_break;
    }
#line 172
    stateno = *(to_state + i);
#line 173
    sp = (*(states + stateno))->transitions;
#line 176
    j = 0;
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 176
      if (j < sp->num) {
#line 176
        if (! ((unsigned long )sp->states[j] == (unsigned long )((void *)0))) {
#line 176
          if (! ((sp->states[j])->accessing_symbol < ntokens)) {
#line 176
            goto while_break___0;
          }
        }
      } else {
#line 176
        goto while_break___0;
      }
#line 176
      if (! ((unsigned long )sp->states[j] == (unsigned long )((void *)0))) {
        {
#line 177
        bitset_set(*(goto_follows + i), (bitset_bindex )(sp->states[j])->accessing_symbol);
        }
      }
#line 176
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 179
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 179
      if (! (j < sp->num)) {
#line 179
        goto while_break___1;
      }
#line 181
      sym = (sp->states[j])->accessing_symbol;
#line 182
      if (*(nullable + (sym - ntokens))) {
        {
#line 183
        tmp___1 = nedges;
#line 183
        nedges ++;
#line 183
        *(edge + tmp___1) = map_goto(stateno, sym);
        }
      }
#line 179
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 186
    if (nedges == 0U) {
#line 187
      *(reads + i) = (goto_number *)((void *)0);
    } else {
      {
#line 190
      tmp___2 = xnmalloc(nedges + 1U, (size_t )sizeof(*(*(reads + i) + 0)));
#line 190
      *(reads + i) = (goto_number *)tmp___2;
#line 191
      memcpy((void */* __restrict  */)*(reads + i), (void const   */* __restrict  */)edge,
             (size_t )((unsigned long )nedges * sizeof(*(edge + 0))));
#line 192
      *(*(reads + i) + nedges) = (relation_node )-1;
#line 193
      nedges = (goto_number )0;
      }
    }
#line 170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 197
  relation_digraph(reads, ngotos, & goto_follows);
#line 199
  i = (goto_number )0;
  }
  {
#line 199
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 199
    if (! (i < ngotos)) {
#line 199
      goto while_break___2;
    }
    {
#line 200
    free((void *)*(reads + i));
#line 199
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 202
  free((void *)reads);
#line 203
  free((void *)edge);
  }
#line 204
  return;
}
}
#line 207 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static void add_lookback_edge(state *s , rule *r , goto_number gotono ) 
{ 
  int ri ;
  int tmp ;
  goto_list *sp ;
  void *tmp___0 ;

  {
  {
#line 210
  tmp = state_reduction_find(s, r);
#line 210
  ri = tmp;
#line 211
  tmp___0 = xmalloc((size_t )sizeof(*sp));
#line 211
  sp = (goto_list *)tmp___0;
#line 212
  sp->next = *(lookback + (((s->reductions)->lookahead_tokens - LA) + (long )ri));
#line 213
  sp->value = gotono;
#line 214
  *(lookback + (((s->reductions)->lookahead_tokens - LA) + (long )ri)) = sp;
  }
#line 215
  return;
}
}
#line 219 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static void build_relations(void) 
{ 
  goto_number *edge ;
  void *tmp ;
  state_number *states1 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  goto_number i ;
  void *tmp___2 ;
  int nedges ;
  symbol_number symbol1 ;
  rule **rulep ;
  _Bool done ;
  int length ;
  item_number const   *rp ;
  state *s ;
  symbol_number tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  symbol_number tmp___7 ;
  int j ;
  void *tmp___8 ;

  {
  {
#line 222
  tmp = xnmalloc(ngotos + 1U, (size_t )sizeof(*edge));
#line 222
  edge = (goto_number *)tmp;
#line 223
  tmp___0 = ritem_longest_rhs();
#line 223
  tmp___1 = xnmalloc(tmp___0 + 1U, (size_t )sizeof(*states1));
#line 223
  states1 = (state_number *)tmp___1;
#line 226
  tmp___2 = xnmalloc(ngotos + 10U, (size_t )sizeof(*includes));
#line 226
  includes = (goto_number **)tmp___2;
#line 228
  i = (goto_number )0;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (i < ngotos)) {
#line 228
      goto while_break;
    }
#line 230
    nedges = 0;
#line 231
    symbol1 = (*(states + *(to_state + i)))->accessing_symbol;
#line 234
    rulep = *(derives + (symbol1 - ntokens));
    {
#line 234
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 234
      if (! *rulep) {
#line 234
        goto while_break___0;
      }
#line 237
      length = 1;
#line 239
      s = *(states + *(from_state + i));
#line 240
      *(states1 + 0) = s->number;
#line 242
      rp = (item_number const   *)(*rulep)->rhs;
      {
#line 242
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 242
        tmp___5 = item_number_is_rule_number((item_number )*rp);
        }
#line 242
        if (tmp___5) {
#line 242
          goto while_break___1;
        }
        {
#line 244
        tmp___3 = item_number_as_symbol_number((item_number )*rp);
#line 244
        s = transitions_to(s->transitions, tmp___3);
#line 246
        tmp___4 = length;
#line 246
        length ++;
#line 246
        *(states1 + tmp___4) = s->number;
#line 242
        rp ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 249
      if (! s->consistent) {
        {
#line 250
        add_lookback_edge(s, *rulep, i);
        }
      }
#line 252
      length --;
#line 253
      done = (_Bool)0;
      {
#line 254
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 254
        if (! (! done)) {
#line 254
          goto while_break___2;
        }
#line 256
        done = (_Bool)1;
#line 260
        rp --;
#line 261
        if (*rp >= (item_number const   )ntokens) {
          {
#line 264
          tmp___6 = nedges;
#line 264
          nedges ++;
#line 264
          tmp___7 = item_number_as_symbol_number((item_number )*rp);
#line 264
          length --;
#line 264
          *(edge + tmp___6) = map_goto(*(states1 + length), tmp___7);
          }
#line 266
          if (*(nullable + (*rp - (item_number const   )ntokens))) {
#line 267
            done = (_Bool)0;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 234
      rulep ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 272
    if (nedges == 0) {
#line 273
      *(includes + i) = (goto_number *)((void *)0);
    } else {
      {
#line 277
      tmp___8 = xnmalloc((size_t )(nedges + 1), (size_t )sizeof(*(*(includes + i) + 0)));
#line 277
      *(includes + i) = (goto_number *)tmp___8;
#line 278
      j = 0;
      }
      {
#line 278
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 278
        if (! (j < nedges)) {
#line 278
          goto while_break___3;
        }
#line 279
        *(*(includes + i) + j) = *(edge + j);
#line 278
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 280
      *(*(includes + i) + nedges) = (relation_node )-1;
    }
#line 228
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  free((void *)edge);
#line 285
  free((void *)states1);
#line 287
  relation_transpose(& includes, ngotos);
  }
#line 288
  return;
}
}
#line 292 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static void compute_FOLLOWS(void) 
{ 
  goto_number i ;

  {
  {
#line 297
  relation_digraph(includes, ngotos, & goto_follows);
#line 299
  i = (goto_number )0;
  }
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (i < ngotos)) {
#line 299
      goto while_break;
    }
    {
#line 300
    free((void *)*(includes + i));
#line 299
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 302
  free((void *)includes);
  }
#line 303
  return;
}
}
#line 306 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static void compute_lookahead_tokens(void) 
{ 
  size_t i ;
  goto_list *sp ;
  goto_list *_node ;
  goto_list *_next ;

  {
#line 312
  i = (size_t )0;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! (i < nLA)) {
#line 312
      goto while_break;
    }
#line 313
    sp = *(lookback + i);
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! sp) {
#line 313
        goto while_break___0;
      }
      {
#line 314
      (*(((*(LA + i))->b.vtable)->or_))(*(LA + i), *(LA + i), *(goto_follows + sp->value));
#line 313
      sp = sp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 312
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  i = (size_t )0;
  {
#line 317
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 317
    if (! (i < nLA)) {
#line 317
      goto while_break___1;
    }
    {
#line 318
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 318
      _node = *(lookback + i);
      {
#line 318
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 318
        if (! _node) {
#line 318
          goto while_break___3;
        }
        {
#line 318
        _next = _node->next;
#line 318
        free((void *)_node);
#line 318
        _node = _next;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 318
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 317
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 320
  free((void *)lookback);
  }
#line 321
  return;
}
}
#line 329 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static int state_lookahead_tokens_count(state *s , _Bool default_reduction_only_for_accept ) 
{ 
  int n_lookahead_tokens ;
  reductions *rp ;
  transitions *sp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 332
  n_lookahead_tokens = 0;
#line 333
  rp = s->reductions;
#line 334
  sp = s->transitions;
#line 341
  if (! (sp->num == 0)) {
#line 341
    if (! (! ((unsigned long )sp->states[0] == (unsigned long )((void *)0)))) {
      {
#line 341
      __assert_fail("sp->num == 0 || !(sp->states[0] == ((void *)0))", "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c",
                    341U, "state_lookahead_tokens_count");
      }
    }
  }
#line 351
  if (rp->num > 1) {
#line 355
    n_lookahead_tokens += rp->num;
  } else
#line 351
  if (rp->num == 1) {
#line 351
    if (sp->num) {
#line 351
      if ((sp->states[0])->accessing_symbol < ntokens) {
#line 355
        n_lookahead_tokens += rp->num;
      } else {
#line 351
        goto _L___0;
      }
    } else {
#line 351
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 351
  if (rp->num == 1) {
#line 351
    if ((rp->rules[0])->number != 0) {
#line 351
      if (default_reduction_only_for_accept) {
#line 355
        n_lookahead_tokens += rp->num;
      } else {
#line 357
        s->consistent = (char)1;
      }
    } else {
#line 357
      s->consistent = (char)1;
    }
  } else {
#line 357
    s->consistent = (char)1;
  }
#line 359
  return (n_lookahead_tokens);
}
}
#line 367 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
void initialize_LA(void) 
{ 
  state_number i ;
  bitsetv pLA ;
  _Bool default_reduction_only_for_accept ;
  char *default_reductions ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int count ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 374
  tmp = muscle_percent_define_get("lr.default-reductions");
#line 374
  default_reductions = tmp;
#line 376
  tmp___0 = strcmp((char const   *)default_reductions, "accepting");
#line 376
  default_reduction_only_for_accept = (_Bool )(0 == tmp___0);
#line 378
  free((void *)default_reductions);
#line 382
  nLA = (size_t )0;
#line 383
  i = 0;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (i < nstates)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp___1 = state_lookahead_tokens_count(*(states + i), default_reduction_only_for_accept);
#line 384
    nLA += (size_t )tmp___1;
#line 383
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  if (! nLA) {
#line 389
    nLA = (size_t )1;
  }
  {
#line 391
  LA = bitsetv_create(nLA, (bitset_bindex )ntokens, 1U);
#line 391
  pLA = LA;
#line 395
  i = 0;
  }
  {
#line 395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 395
    if (! (i < nstates)) {
#line 395
      goto while_break___0;
    }
    {
#line 397
    tmp___2 = state_lookahead_tokens_count(*(states + i), default_reduction_only_for_accept);
#line 397
    count = tmp___2;
    }
#line 400
    if (count) {
#line 402
      ((*(states + i))->reductions)->lookahead_tokens = pLA;
#line 403
      pLA += count;
    }
#line 395
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 406
  return;
}
}
#line 413 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
static void lookahead_tokens_print(FILE *out ) 
{ 
  state_number i ;
  int j ;
  int k ;
  reductions *reds ;
  bitset_iterator iter ;
  int n_lookahead_tokens ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 418
  rpl_fprintf(out, "Lookahead tokens: BEGIN\n");
#line 419
  i = 0;
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (i < nstates)) {
#line 419
      goto while_break;
    }
#line 421
    reds = (*(states + i))->reductions;
#line 423
    n_lookahead_tokens = 0;
#line 425
    if (reds->lookahead_tokens) {
#line 426
      k = 0;
      {
#line 426
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 426
        if (! (k < reds->num)) {
#line 426
          goto while_break___0;
        }
#line 427
        if (*(reds->lookahead_tokens + k)) {
#line 428
          n_lookahead_tokens ++;
        }
#line 426
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 430
    rpl_fprintf(out, "State %d: %d lookahead tokens\n", i, n_lookahead_tokens);
    }
#line 433
    if (reds->lookahead_tokens) {
#line 434
      j = 0;
      {
#line 434
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 434
        if (! (j < reds->num)) {
#line 434
          goto while_break___1;
        }
#line 435
        iter.next = (bitset_bindex )0;
#line 435
        iter.num = (bitset_bindex )1024;
        {
#line 435
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 435
          if (iter.num == 1024U) {
            {
#line 435
            iter.num = (*(((*(reds->lookahead_tokens + j))->b.vtable)->list))(*(reds->lookahead_tokens + j),
                                                                              iter.list,
                                                                              (bitset_bindex )1024,
                                                                              & iter.next);
            }
#line 435
            if (! iter.num) {
#line 435
              goto while_break___2;
            }
          } else {
#line 435
            goto while_break___2;
          }
#line 435
          iter.i = (bitset_bindex )0;
          {
#line 435
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 435
            if (iter.i < iter.num) {
#line 435
              k = (int )iter.list[iter.i];
            } else {
#line 435
              goto while_break___3;
            }
            {
#line 437
            rpl_fprintf(out, "   on %d (%s) -> rule %d\n", k, (*(symbols + k))->tag,
                        (reds->rules[j])->number);
#line 435
            (iter.i) ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 434
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 419
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  rpl_fprintf(out, "Lookahead tokens: END\n");
  }
#line 443
  return;
}
}
#line 445 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
void lalr(void) 
{ 
  void *tmp ;

  {
  {
#line 448
  initialize_LA();
#line 449
  set_goto_map();
#line 450
  initialize_F();
#line 451
  tmp = xcalloc(nLA, (size_t )sizeof(*lookback));
#line 451
  lookback = (goto_list **)tmp;
#line 452
  build_relations();
#line 453
  compute_FOLLOWS();
#line 454
  compute_lookahead_tokens();
  }
#line 456
  if (trace_flag & 8) {
    {
#line 457
    lookahead_tokens_print(stderr);
    }
  }
#line 458
  return;
}
}
#line 461 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
void lalr_update_state_numbers(state_number *old_to_new , state_number nstates_old ) 
{ 
  goto_number ngotos_reachable ;
  symbol_number nonterminal ;
  goto_number i ;
  symbol_number tmp ;
  symbol_number tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 464
  ngotos_reachable = (goto_number )0;
#line 465
  nonterminal = 0;
#line 466
  if (! (nsyms == nvars + ntokens)) {
    {
#line 466
    __assert_fail("nsyms == nvars + ntokens", "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c",
                  466U, "lalr_update_state_numbers");
    }
  }
#line 469
  i = (goto_number )0;
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (! (i < ngotos)) {
#line 469
      goto while_break;
    }
    {
#line 471
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 471
      if (! (i == *(goto_map + nonterminal))) {
#line 471
        goto while_break___0;
      }
#line 472
      tmp = nonterminal;
#line 472
      nonterminal ++;
#line 472
      *(goto_map + tmp) = ngotos_reachable;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 475
    if (*(old_to_new + *(from_state + i)) != nstates_old) {
#line 479
      if (! (*(old_to_new + *(to_state + i)) != nstates_old)) {
        {
#line 479
        __assert_fail("old_to_new[to_state[i]] != nstates_old", "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c",
                      479U, "lalr_update_state_numbers");
        }
      }
#line 480
      *(from_state + ngotos_reachable) = *(old_to_new + *(from_state + i));
#line 481
      *(to_state + ngotos_reachable) = *(old_to_new + *(to_state + i));
#line 482
      ngotos_reachable ++;
    }
#line 469
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 486
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 486
    if (! (nonterminal <= nvars)) {
#line 486
      goto while_break___1;
    }
#line 488
    if (! (ngotos == *(goto_map + nonterminal))) {
      {
#line 488
      __assert_fail("ngotos == goto_map[nonterminal]", "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c",
                    488U, "lalr_update_state_numbers");
      }
    }
#line 489
    tmp___0 = nonterminal;
#line 489
    nonterminal ++;
#line 489
    *(goto_map + tmp___0) = ngotos_reachable;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 491
  ngotos = ngotos_reachable;
#line 492
  return;
}
}
#line 495 "/home/pronto/abs/test-suite/bison-2.5/src/lalr.c"
void lalr_free(void) 
{ 
  state_number s ;

  {
#line 499
  s = 0;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (s < nstates)) {
#line 499
      goto while_break;
    }
#line 500
    ((*(states + s))->reductions)->lookahead_tokens = (bitset *)((void *)0);
#line 499
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  bitsetv_free(LA);
  }
#line 502
  return;
}
}
#line 229 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 132 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
int warnings_flag ;
#line 209 "/home/pronto/abs/test-suite/bison-2.5/src/gram.h"
_Bool rule_useful_in_grammar_p(rule *r ) ;
#line 223
void rule_lhs_print_xml(rule *r , FILE *out , int level ) ;
#line 229
void rule_rhs_print(rule *r , FILE *out ) ;
#line 232
void rule_print(rule *r , FILE *out ) ;
#line 36 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
item_number *ritem  =    (item_number *)((void *)0);
#line 37 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
unsigned int nritems  =    0U;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
rule *rules  =    (rule *)((void *)0);
#line 40 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
rule_number nrules  =    0;
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
symbol **symbols  =    (symbol **)((void *)0);
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
int nsyms  =    0;
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
int ntokens  =    1;
#line 45 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
int nvars  =    0;
#line 47 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
symbol_number *token_translations  =    (symbol_number *)((void *)0);
#line 49 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
int max_user_token_number  =    256;
#line 51 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
_Bool rule_useful_in_grammar_p(rule *r ) 
{ 


  {
#line 54
  return ((_Bool )(r->number < nrules));
}
}
#line 57 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
_Bool rule_useless_in_grammar_p(rule *r ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  {
#line 60
  tmp = rule_useful_in_grammar_p(r);
  }
#line 60
  if (tmp) {
#line 60
    tmp___0 = 0;
  } else {
#line 60
    tmp___0 = 1;
  }
#line 60
  return ((_Bool )tmp___0);
}
}
#line 63 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
_Bool rule_useless_in_parser_p(rule *r ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 66
  if (! r->useful) {
    {
#line 66
    tmp = rule_useful_in_grammar_p(r);
    }
#line 66
    if (tmp) {
#line 66
      tmp___0 = 1;
    } else {
#line 66
      tmp___0 = 0;
    }
  } else {
#line 66
    tmp___0 = 0;
  }
#line 66
  return ((_Bool )tmp___0);
}
}
#line 69 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void rule_lhs_print(rule *r , symbol *previous_lhs , FILE *out ) 
{ 
  int n ;
  size_t tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 72
  rpl_fprintf(out, "  %3d ", r->number);
  }
#line 73
  if ((unsigned long )previous_lhs != (unsigned long )r->lhs) {
    {
#line 75
    rpl_fprintf(out, "%s:", (r->lhs)->tag);
    }
  } else {
    {
#line 80
    tmp = strlen(previous_lhs->tag);
#line 80
    n = (int )tmp;
    }
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
#line 80
      if (! (n > 0)) {
#line 80
        goto while_break;
      }
      {
#line 81
      fputc_unlocked(' ', out);
#line 80
      n --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 82
    fputc_unlocked('|', out);
    }
  }
#line 84
  return;
}
}
#line 86 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void rule_lhs_print_xml(rule *r , FILE *out , int level ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 89
  xml_printf(out, level, "<lhs>%s</lhs>", (r->lhs)->tag);
  }
#line 90
  return;
}
}
#line 92 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
int rule_rhs_length(rule *r ) 
{ 
  int res ;
  item_number *rhsp ;

  {
#line 95
  res = 0;
#line 97
  rhsp = r->rhs;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (*rhsp >= 0)) {
#line 97
      goto while_break;
    }
#line 98
    res ++;
#line 97
    rhsp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (res);
}
}
#line 102 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void rule_rhs_print(rule *r , FILE *out ) 
{ 
  item_number *rp ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 105
  if (*(r->rhs) >= 0) {
#line 108
    rp = r->rhs;
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;
#line 108
      if (! (*rp >= 0)) {
#line 108
        goto while_break;
      }
      {
#line 109
      rpl_fprintf(out, " %s", (*(symbols + *rp))->tag);
#line 108
      rp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 110
    fputc_unlocked('\n', out);
    }
  } else {
    {
#line 114
    tmp = gettext("empty");
#line 114
    rpl_fprintf(out, " /* %s */\n", tmp);
    }
  }
#line 116
  return;
}
}
#line 118 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
static void rule_rhs_print_xml(rule *r , FILE *out , int level ) 
{ 
  item_number *rp ;
  char const   *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 121
  if (*(r->rhs) >= 0) {
    {
#line 124
    xml_puts(out, level, "<rhs>");
#line 125
    rp = r->rhs;
    }
    {
#line 125
    while (1) {
      while_continue: /* CIL Label */ ;
#line 125
      if (! (*rp >= 0)) {
#line 125
        goto while_break;
      }
      {
#line 126
      tmp = xml_escape((*(symbols + *rp))->tag);
#line 126
      xml_printf(out, level + 1, "<symbol>%s</symbol>", tmp);
#line 125
      rp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 128
    xml_puts(out, level, "</rhs>");
    }
  } else {
    {
#line 132
    xml_puts(out, level, "<rhs>");
#line 133
    xml_puts(out, level + 1, "<empty/>");
#line 134
    xml_puts(out, level, "</rhs>");
    }
  }
#line 136
  return;
}
}
#line 138 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void rule_print(rule *r , FILE *out ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 141
  rpl_fprintf(out, "%s:", (r->lhs)->tag);
#line 142
  rule_rhs_print(r, out);
  }
#line 143
  return;
}
}
#line 145 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void ritem_print(FILE *out ) 
{ 
  unsigned int i ;
  rule_number tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 149
  fputs_unlocked((char const   */* __restrict  */)"RITEM\n", (FILE */* __restrict  */)out);
#line 150
  i = 0U;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i < nritems)) {
#line 150
      goto while_break;
    }
#line 151
    if (*(ritem + i) >= 0) {
      {
#line 152
      rpl_fprintf(out, "  %s", (*(symbols + *(ritem + i)))->tag);
      }
    } else {
      {
#line 154
      tmp = item_number_as_rule_number(*(ritem + i));
#line 154
      rpl_fprintf(out, "  (rule %d)\n", tmp);
      }
    }
#line 150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
  }
#line 156
  return;
}
}
#line 158 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
size_t ritem_longest_rhs(void) 
{ 
  int max ;
  rule_number r ;
  int length ;
  int tmp ;

  {
#line 161
  max = 0;
#line 164
  r = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (r < nrules)) {
#line 164
      goto while_break;
    }
    {
#line 166
    tmp = rule_rhs_length(rules + r);
#line 166
    length = tmp;
    }
#line 167
    if (length > max) {
#line 168
      max = length;
    }
#line 164
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return ((size_t )max);
}
}
#line 174 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void grammar_rules_partial_print(FILE *out , char const   *title , _Bool (*filter)(rule * ) ) 
{ 
  rule_number r ;
  _Bool first ;
  symbol *previous_lhs ;
  _Bool tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 179
  first = (_Bool)1;
#line 180
  previous_lhs = (symbol *)((void *)0);
#line 183
  r = 0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (r < nrules + nuseless_productions)) {
#line 183
      goto while_break;
    }
#line 185
    if (filter) {
      {
#line 185
      tmp = (*filter)(rules + r);
      }
#line 185
      if (! tmp) {
#line 186
        goto __Cont;
      }
    }
#line 187
    if (first) {
      {
#line 188
      rpl_fprintf(out, "%s\n\n", title);
      }
    } else
#line 189
    if (previous_lhs) {
#line 189
      if ((unsigned long )previous_lhs != (unsigned long )(rules + r)->lhs) {
        {
#line 190
        fputc_unlocked('\n', out);
        }
      }
    }
    {
#line 191
    first = (_Bool)0;
#line 192
    rule_lhs_print(rules + r, previous_lhs, out);
#line 193
    rule_rhs_print(rules + r, out);
#line 194
    previous_lhs = (rules + r)->lhs;
    }
    __Cont: /* CIL Label */ 
#line 183
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (! first) {
    {
#line 197
    fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
    }
  }
#line 198
  return;
}
}
#line 200 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void grammar_rules_print(FILE *out ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 203
  tmp = gettext("Grammar");
#line 203
  grammar_rules_partial_print(out, (char const   *)tmp, & rule_useful_in_grammar_p);
  }
#line 204
  return;
}
}
#line 206 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void grammar_rules_print_xml(FILE *out , int level ) 
{ 
  rule_number r ;
  _Bool first ;
  char const   *usefulness ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 210
  first = (_Bool)1;
#line 212
  r = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (r < nrules + nuseless_productions)) {
#line 212
      goto while_break;
    }
#line 214
    if (first) {
      {
#line 215
      xml_puts(out, level + 1, "<rules>");
      }
    }
    {
#line 216
    first = (_Bool)0;
#line 219
    tmp___0 = rule_useless_in_grammar_p(rules + r);
    }
#line 219
    if (tmp___0) {
#line 220
      usefulness = "useless-in-grammar";
    } else {
      {
#line 221
      tmp = rule_useless_in_parser_p(rules + r);
      }
#line 221
      if (tmp) {
#line 222
        usefulness = "useless-in-parser";
      } else {
#line 224
        usefulness = "useful";
      }
    }
    {
#line 225
    xml_indent(out, level + 2);
#line 226
    rpl_fprintf(out, "<rule number=\"%d\" usefulness=\"%s\"", (rules + r)->number,
                usefulness);
    }
#line 228
    if ((rules + r)->precsym) {
      {
#line 229
      tmp___1 = xml_escape(((rules + r)->precsym)->tag);
#line 229
      rpl_fprintf(out, " percent_prec=\"%s\"", tmp___1);
      }
    }
    {
#line 231
    fputs_unlocked((char const   */* __restrict  */)">\n", (FILE */* __restrict  */)out);
#line 233
    rule_lhs_print_xml(rules + r, out, level + 3);
#line 234
    rule_rhs_print_xml(rules + r, out, level + 3);
#line 235
    xml_puts(out, level + 2, "</rule>");
#line 212
    r ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  if (! first) {
    {
#line 238
    xml_puts(out, level + 1, "</rules>");
    }
  } else {
    {
#line 240
    xml_puts(out, level + 1, "<rules/>");
    }
  }
#line 241
  return;
}
}
#line 243 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void grammar_dump(FILE *out , char const   *title ) 
{ 
  symbol_number i ;
  rule_number i___0 ;
  rule *rule_i ;
  item_number *rp ;
  unsigned int rhs_itemno ;
  unsigned int rhs_count ;
  unsigned int tmp ;
  int tmp___0 ;
  rule_number tmp___1 ;
  rule_number r ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 246
  rpl_fprintf(out, "%s\n\n", title);
#line 247
  rpl_fprintf(out, "ntokens = %d, nvars = %d, nsyms = %d, nrules = %d, nritems = %d\n\n",
              ntokens, nvars, nsyms, nrules, nritems);
#line 252
  rpl_fprintf(out, "Variables\n---------\n\n");
#line 255
  rpl_fprintf(out, "Value  Sprec  Sassoc  Tag\n");
#line 257
  i = ntokens;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (i < nsyms)) {
#line 257
      goto while_break;
    }
    {
#line 258
    rpl_fprintf(out, "%5d  %5d   %5d  %s\n", i, (*(symbols + i))->prec, (unsigned int )(*(symbols + i))->assoc,
                (*(symbols + i))->tag);
#line 257
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 262
  rpl_fprintf(out, "\n\n");
#line 265
  rpl_fprintf(out, "Rules\n-----\n\n");
#line 268
  rpl_fprintf(out, "Num (Prec, Assoc, Useful, Ritem Range) Lhs -> Rhs (Ritem range) [Num]\n");
#line 269
  i___0 = 0;
  }
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! (i___0 < nrules + nuseless_productions)) {
#line 269
      goto while_break___0;
    }
#line 271
    rule_i = rules + i___0;
#line 272
    rp = (item_number *)((void *)0);
#line 273
    rhs_itemno = (unsigned int )(rule_i->rhs - ritem);
#line 274
    rhs_count = 0U;
#line 276
    rp = rule_i->rhs;
    {
#line 276
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 276
      if (! (*rp >= 0)) {
#line 276
        goto while_break___1;
      }
#line 277
      rhs_count ++;
#line 276
      rp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 278
    if (rule_i->prec) {
#line 278
      tmp = (unsigned int )(rule_i->prec)->assoc;
    } else {
#line 278
      tmp = 0U;
    }
#line 278
    if (rule_i->prec) {
#line 278
      tmp___0 = (rule_i->prec)->prec;
    } else {
#line 278
      tmp___0 = 0;
    }
    {
#line 278
    rpl_fprintf(out, "%3d (%2d, %2d, %2d, %2u-%2u)   %2d ->", i___0, tmp___0, tmp,
                (int )rule_i->useful, rhs_itemno, (rhs_itemno + rhs_count) - 1U, (rule_i->lhs)->number);
#line 287
    rp = rule_i->rhs;
    }
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 287
      if (! (*rp >= 0)) {
#line 287
        goto while_break___2;
      }
      {
#line 288
      rpl_fprintf(out, " %3d", *rp);
#line 287
      rp ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 289
    tmp___1 = item_number_as_rule_number(*rp);
#line 289
    rpl_fprintf(out, "  [%d]\n", tmp___1);
#line 269
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 292
  rpl_fprintf(out, "\n\n");
#line 294
  rpl_fprintf(out, "Rules interpreted\n-----------------\n\n");
#line 297
  r = 0;
  }
  {
#line 297
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 297
    if (! (r < nrules + nuseless_productions)) {
#line 297
      goto while_break___3;
    }
    {
#line 299
    rpl_fprintf(out, "%-5d  ", r);
#line 300
    rule_print(rules + r, out);
#line 297
    r ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 303
  rpl_fprintf(out, "\n\n");
  }
#line 304
  return;
}
}
#line 306 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void grammar_rules_useless_report(char const   *message ) 
{ 
  rule_number r ;
  char *__cil_tmp3 ;

  {
#line 310
  r = 0;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! (r < nrules)) {
#line 310
      goto while_break;
    }
#line 311
    if (! (rules + r)->useful) {
      {
#line 313
      warn_at((rules + r)->location, "%s: ", message);
      }
#line 314
      if (warnings_flag & 32) {
        {
#line 316
        rule_print(rules + r, stderr);
#line 317
        fflush_unlocked(stderr);
        }
      }
    }
#line 310
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 322 "/home/pronto/abs/test-suite/bison-2.5/src/gram.c"
void grammar_free(void) 
{ 


  {
#line 325
  if (ritem) {
    {
#line 326
    free((void *)(ritem - 1));
    }
  }
  {
#line 327
  free((void *)rules);
#line 328
  free((void *)token_translations);
#line 330
  symbols_free();
#line 331
  free_merger_functions();
  }
#line 332
  return;
}
}
#line 346 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 26 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
char *program_name  ;
#line 36
char const   *include ;
#line 38 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool debug_flag  ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool defines_flag  ;
#line 40 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool graph_flag  ;
#line 41 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool xml_flag  ;
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool locations_flag  ;
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool no_lines_flag  ;
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool token_table_flag  ;
#line 45 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.h"
_Bool yacc_flag  ;
#line 59 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
_Bool error_verbose  =    (_Bool)0;
#line 61 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
_Bool nondeterministic_parser  =    (_Bool)0;
#line 62 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
_Bool glr_parser  =    (_Bool)0;
#line 64 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
int report_flag  =    0;
#line 65 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
int trace_flag  =    0;
#line 66 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
int warnings_flag  =    56;
#line 69 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static struct bison_language  const  valid_languages[4]  = {      {{(char )'c', (char )'\000'}, {(char )'c', (char )'-', (char )'s', (char )'k',
                                    (char )'e', (char )'l', (char )'.', (char )'m',
                                    (char )'4', (char )'\000'}, {(char )'.', (char )'c',
                                                                 (char )'\000'}, {(char )'.',
                                                                                  (char )'h',
                                                                                  (char )'\000'},
      (_Bool)1}, 
        {{(char )'c', (char )'+', (char )'+', (char )'\000'}, {(char )'c', (char )'+',
                                                            (char )'+', (char )'-',
                                                            (char )'s', (char )'k',
                                                            (char )'e', (char )'l',
                                                            (char )'.', (char )'m',
                                                            (char )'4', (char )'\000'},
      {(char )'.', (char )'c', (char )'c', (char )'\000'}, {(char )'.', (char )'h',
                                                            (char )'h', (char )'\000'},
      (_Bool)1}, 
        {{(char )'j', (char )'a', (char )'v', (char )'a', (char )'\000'}, {(char )'j',
                                                                        (char )'a',
                                                                        (char )'v',
                                                                        (char )'a',
                                                                        (char )'-',
                                                                        (char )'s',
                                                                        (char )'k',
                                                                        (char )'e',
                                                                        (char )'l',
                                                                        (char )'.',
                                                                        (char )'m',
                                                                        (char )'4',
                                                                        (char )'\000'},
      {(char )'.', (char )'j', (char )'a', (char )'v', (char )'a', (char )'\000'},
      {(char )'.', (char )'j', (char )'a', (char )'v', (char )'a', (char )'\000'},
      (_Bool)0}, 
        {{(char )'\000'}, {(char )'\000'}, {(char )'\000'}, {(char )'\000'}, (_Bool)0}};
#line 76 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
int skeleton_prio  =    2;
#line 77 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
char const   *skeleton  =    (char const   *)((void *)0);
#line 78 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
int language_prio  =    2;
#line 79 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
struct bison_language  const  *language  =    & valid_languages[0];
#line 80 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
char const   *include  =    (char const   *)((void *)0);
#line 99 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static void flags_argmatch(char const   *rpl_option , char const   * const  *keys ,
                           int const   *values___0 , int all , int *flags , char *args ) 
{ 
  int no ;
  int tmp___0 ;
  int tmp___1 ;
  int value ;
  ptrdiff_t tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 104
  if (args) {
    {
#line 106
    args = strtok((char */* __restrict  */)args, (char const   */* __restrict  */)",");
    }
    {
#line 107
    while (1) {
      while_continue: /* CIL Label */ ;
#line 107
      if (! args) {
#line 107
        goto while_break;
      }
      {
#line 109
      tmp___1 = strncmp((char const   *)args, "no-", (size_t )3);
      }
#line 109
      if (tmp___1 == 0) {
#line 109
        tmp___0 = 3;
      } else {
#line 109
        tmp___0 = 0;
      }
      {
#line 109
      no = tmp___0;
#line 110
      tmp___2 = __xargmatch_internal(rpl_option, (char const   *)(args + no), keys,
                                     (char const   *)values___0, (size_t )sizeof(*values___0),
                                     argmatch_die);
#line 110
      value = (int )*(values___0 + tmp___2);
      }
#line 111
      if (value == 0) {
#line 113
        if (no) {
#line 114
          *flags |= all;
        } else {
#line 116
          *flags &= ~ all;
        }
      } else
#line 120
      if (no) {
#line 121
        *flags &= ~ value;
      } else {
#line 123
        *flags |= value;
      }
      {
#line 125
      args = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 129
    *flags |= all;
  }
#line 130
  return;
}
}
#line 151 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static char const   * const  report_args[11]  = 
#line 151
  {      (char const   */* const  */)"none",      (char const   */* const  */)"state",      (char const   */* const  */)"states",      (char const   */* const  */)"itemset", 
        (char const   */* const  */)"itemsets",      (char const   */* const  */)"lookahead",      (char const   */* const  */)"lookaheads",      (char const   */* const  */)"look-ahead", 
        (char const   */* const  */)"solved",      (char const   */* const  */)"all",      (char const   */* const  */)0};
#line 164 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static int const   report_types[10]  = 
#line 164
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )3, 
        (int const   )3,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )9,      (int const   )-1};
#line 183 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static char const   * const  trace_args[16]  = 
#line 183
  {      (char const   */* const  */)"none       - no traces",      (char const   */* const  */)"scan       - grammar scanner traces",      (char const   */* const  */)"parse      - grammar parser traces",      (char const   */* const  */)"automaton  - construction of the automaton", 
        (char const   */* const  */)"bitsets    - use of bitsets",      (char const   */* const  */)"grammar    - reading, reducing the grammar",      (char const   */* const  */)"resource   - memory consumption (where available)",      (char const   */* const  */)"sets       - grammar sets: firsts, nullable etc.", 
        (char const   */* const  */)"muscles    - m4 definitions passed to the skeleton",      (char const   */* const  */)"tools      - m4 invocation",      (char const   */* const  */)"m4         - m4 traces",      (char const   */* const  */)"skeleton   - skeleton postprocessing", 
        (char const   */* const  */)"time       - time consumption",      (char const   */* const  */)"ielr       - IELR conversion",      (char const   */* const  */)"all        - all of the above",      (char const   */* const  */)0};
#line 205 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static int const   trace_types[15]  = 
#line 205
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )64, 
        (int const   )16,      (int const   )128,      (int const   )4,      (int const   )8, 
        (int const   )2048,      (int const   )32,      (int const   )1024,      (int const   )512, 
        (int const   )256,      (int const   )4096,      (int const   )-1};
#line 231 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static char const   * const  warnings_args[9]  = 
#line 231
  {      (char const   */* const  */)"none            - no warnings",      (char const   */* const  */)"midrule-values  - unset or unused midrule values",      (char const   */* const  */)"yacc            - incompatibilities with POSIX Yacc",      (char const   */* const  */)"conflicts-sr    - S/R conflicts", 
        (char const   */* const  */)"conflicts-rr    - R/R conflicts",      (char const   */* const  */)"other           - all other warnings",      (char const   */* const  */)"all             - all of the above",      (char const   */* const  */)"error           - warnings are errors", 
        (char const   */* const  */)0};
#line 246 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static int const   warnings_types[8]  = 
#line 246
  {      (int const   )0,      (int const   )2,      (int const   )4,      (int const   )8, 
        (int const   )16,      (int const   )32,      (int const   )-2,      (int const   )1};
#line 265
static  __attribute__((__noreturn__)) void usage(int status ) ;
#line 267
static  __attribute__((__noreturn__)) void usage(int status ) ;
#line 267 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static void usage(int status ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 270
  if (status != 0) {
    {
#line 271
    tmp = gettext("Try `%s --help\' for more information.\n");
#line 271
    rpl_fprintf(stderr, (char const   *)tmp, program_name);
    }
  } else {
    {
#line 280
    tmp___0 = gettext("Usage: %s [OPTION]... FILE\n");
#line 280
    __printf__((char const   *)tmp___0, program_name);
#line 281
    tmp___1 = gettext("Generate a deterministic LR or generalized LR (GLR) parser employing\nLALR(1), IELR(1), or canonical LR(1) parser tables.  IELR(1) and\ncanonical LR(1) support is experimental.\n\n");
#line 281
    fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
#line 288
    tmp___2 = gettext("Mandatory arguments to long options are mandatory for short options too.\n");
#line 288
    fputs_unlocked((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
#line 291
    tmp___3 = gettext("The same is true for optional arguments.\n");
#line 291
    fputs_unlocked((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)stdout);
#line 295
    tmp___4 = gettext("\nOperation modes:\n  -h, --help                 display this help and exit\n  -V, --version              output version information and exit\n      --print-localedir      output directory containing locale-dependent data\n      --print-datadir        output directory containing skeletons and XSLT\n  -y, --yacc                 emulate POSIX Yacc\n  -W, --warnings[=CATEGORY]  report the warnings falling in CATEGORY\n\n");
#line 295
    fputs_unlocked((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)stdout);
#line 307
    tmp___5 = gettext("Parser:\n  -L, --language=LANGUAGE          specify the output programming language\n                                   (this is an experimental feature)\n  -S, --skeleton=FILE              specify the skeleton to use\n  -t, --debug                      instrument the parser for debugging\n      --locations                  enable location support\n  -D, --define=NAME[=VALUE]        similar to `%define NAME \"VALUE\"\'\n  -F, --force-define=NAME[=VALUE]  override `%define NAME \"VALUE\"\'\n  -p, --name-prefix=PREFIX         prepend PREFIX to the external symbols\n  -l, --no-lines                   don\'t generate `#line\' directives\n  -k, --token-table                include a table of token names\n\n");
#line 307
    fputs_unlocked((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)stdout);
#line 324
    tmp___6 = gettext("Output:\n      --defines[=FILE]       also produce a header file\n  -d                         likewise but cannot specify FILE (for POSIX Yacc)\n  -r, --report=THINGS        also produce details on the automaton\n      --report-file=FILE     write report to FILE\n  -v, --verbose              same as `--report=state\'\n  -b, --file-prefix=PREFIX   specify a PREFIX for output files\n  -o, --output=FILE          leave output to FILE\n  -g, --graph[=FILE]         also output a graph of the automaton\n  -x, --xml[=FILE]           also output an XML report of the automaton\n                             (the XML schema is experimental)\n\n");
#line 324
    fputs_unlocked((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)stdout);
#line 339
    tmp___7 = gettext("Warning categories include:\n  `midrule-values\'  unset or unused midrule values\n  `yacc\'            incompatibilities with POSIX Yacc\n  `conflicts-sr\'    S/R conflicts (enabled by default)\n  `conflicts-rr\'    R/R conflicts (enabled by default)\n  `other\'           all other warnings (enabled by default)\n  `all\'             all the warnings\n  `no-CATEGORY\'     turn off warnings in CATEGORY\n  `none\'            turn off all the warnings\n  `error\'           treat warnings as errors\n\n");
#line 339
    fputs_unlocked((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)stdout);
#line 353
    tmp___8 = gettext("THINGS is a list of comma separated words that can include:\n  `state\'        describe the states\n  `itemset\'      complete the core item sets with their closure\n  `lookahead\'    explicitly associate lookahead tokens to items\n  `solved\'       describe shift/reduce conflicts solving\n  `all\'          include all the above information\n  `none\'         disable the report\n");
#line 353
    fputs_unlocked((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)stdout);
#line 363
    tmp___9 = gettext("\nReport bugs to <%s>.\n");
#line 363
    __printf__((char const   *)tmp___9, "bug-bison@gnu.org");
    }
  }
  {
#line 366
  exit(status);
  }
}
}
#line 374 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static void version(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 379
  tmp = gettext("bison (GNU Bison) %s");
#line 379
  __printf__((char const   *)tmp, "2.5");
#line 380
  putc_unlocked('\n', stdout);
#line 381
  tmp___0 = gettext("Written by Robert Corbett and Richard Stallman.\n");
#line 381
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stdout);
#line 382
  putc_unlocked('\n', stdout);
#line 384
  tmp___1 = gettext("Copyright (C) %d Free Software Foundation, Inc.\n");
#line 384
  rpl_fprintf(stdout, (char const   *)tmp___1, 2011);
#line 388
  tmp___2 = gettext("This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
#line 388
  fputs_unlocked((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
  }
#line 393
  return;
}
}
#line 400 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
void skeleton_arg(char const   *arg , int prio , location loc___0 ) 
{ 
  char *tmp ;
  char *__cil_tmp5 ;

  {
#line 403
  if (prio < skeleton_prio) {
#line 405
    skeleton_prio = prio;
#line 406
    skeleton = arg;
  } else
#line 408
  if (prio == skeleton_prio) {
    {
#line 409
    tmp = gettext("multiple skeleton declarations are invalid");
#line 409
    complain_at(loc___0, (char const   *)tmp);
    }
  }
#line 410
  return;
}
}
#line 412 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
void language_argmatch(char const   *arg , int prio , location loc___0 ) 
{ 
  char const   *msg ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 417
  if (prio < language_prio) {
#line 420
    i = 0;
    {
#line 420
    while (1) {
      while_continue: /* CIL Label */ ;
#line 420
      if (! valid_languages[i].language[0]) {
#line 420
        goto while_break;
      }
      {
#line 421
      tmp = c_strcasecmp(arg, (char const   *)(valid_languages[i].language));
      }
#line 421
      if (tmp == 0) {
#line 423
        language_prio = prio;
#line 424
        language = & valid_languages[i];
#line 425
        return;
      }
#line 420
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 427
    tmp___0 = gettext("invalid language `%s\'");
#line 427
    msg = (char const   *)tmp___0;
    }
  } else
#line 429
  if (language_prio == prio) {
    {
#line 430
    tmp___1 = gettext("multiple language declarations are invalid");
#line 430
    msg = (char const   *)tmp___1;
    }
  } else {
#line 432
    return;
  }
  {
#line 434
  complain_at(loc___0, msg, arg);
  }
#line 435
  return;
}
}
#line 443 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static char const   short_options[39]  = 
#line 443
  {      (char const   )'D',      (char const   )':',      (char const   )'F',      (char const   )':', 
        (char const   )'L',      (char const   )':',      (char const   )'S',      (char const   )':', 
        (char const   )'T',      (char const   )':',      (char const   )':',      (char const   )'V', 
        (char const   )'W',      (char const   )':',      (char const   )':',      (char const   )'b', 
        (char const   )':',      (char const   )'d',      (char const   )'e',      (char const   )'g', 
        (char const   )':',      (char const   )':',      (char const   )'h',      (char const   )'k', 
        (char const   )'l',      (char const   )'n',      (char const   )'o',      (char const   )':', 
        (char const   )'p',      (char const   )':',      (char const   )'r',      (char const   )':', 
        (char const   )'t',      (char const   )'v',      (char const   )'x',      (char const   )':', 
        (char const   )':',      (char const   )'y',      (char const   )'\000'};
#line 477 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static struct rpl_option  const  long_options[29]  = 
#line 477
  {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"print-localedir", 0, (int *)0, 129}, 
        {"print-datadir", 0, (int *)0, 130}, 
        {"warnings", 2, (int *)0, 'W'}, 
        {"name-prefix", 1, (int *)0, 'p'}, 
        {"include", 1, (int *)0, 'I'}, 
        {"file-prefix", 1, (int *)0, 'b'}, 
        {"output", 1, (int *)0, 'o'}, 
        {"output-file", 1, (int *)0, 'o'}, 
        {"graph", 2, (int *)0, 'g'}, 
        {"xml", 2, (int *)0, 'x'}, 
        {"report", 1, (int *)0, 'r'}, 
        {"report-file", 1, (int *)0, 131}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"trace", 2, (int *)0, 'T'}, 
        {"defines", 2, (int *)0, 'd'}, 
        {"fixed-output-files", 0, (int *)0, 'y'}, 
        {"yacc", 0, (int *)0, 'y'}, 
        {"debug", 0, (int *)0, 't'}, 
        {"define", 1, (int *)0, 'D'}, 
        {"force-define", 1, (int *)0, 'F'}, 
        {"locations", 0, (int *)0, 128}, 
        {"no-lines", 0, (int *)0, 'l'}, 
        {"raw", 0, (int *)0, 0}, 
        {"skeleton", 1, (int *)0, 'S'}, 
        {"language", 1, (int *)0, 'L'}, 
        {"token-table", 0, (int *)0, 'k'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 533 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
static location command_line_location(void) 
{ 
  location res ;
  uniqstr tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 539
  tmp = uniqstr_new("<command line>");
#line 539
  boundary_set(& res.start, tmp, rpl_optind, -1);
#line 540
  res.end = res.start;
  }
#line 541
  return (res);
}
}
#line 545 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
void getargs(int argc , char **argv ) 
{ 
  int c ;
  char *name ;
  char *value ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  location tmp___3 ;
  location tmp___4 ;
  location tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *p ;
  char *tmp___9 ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___10 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___11 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___12 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___13 ;
  struct obstack *__o___3 ;
  char *tmp___14 ;
  struct obstack *__o___4 ;
  char *tmp___15 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 550
    c = rpl_getopt_long(argc, argv, short_options, long_options, (int *)((void *)0));
    }
#line 550
    if (! (c != -1)) {
#line 550
      goto while_break;
    }
    {
#line 557
    if (c == 0) {
#line 557
      goto case_0;
    }
#line 562
    if (c == 70) {
#line 562
      goto case_70;
    }
#line 562
    if (c == 68) {
#line 562
      goto case_70;
    }
#line 575
    if (c == 73) {
#line 575
      goto case_73;
    }
#line 579
    if (c == 76) {
#line 579
      goto case_76;
    }
#line 584
    if (c == 83) {
#line 584
      goto case_83;
    }
#line 589
    if (c == 84) {
#line 589
      goto case_84;
    }
#line 593
    if (c == 86) {
#line 593
      goto case_86;
    }
#line 597
    if (c == 87) {
#line 597
      goto case_87;
    }
#line 601
    if (c == 98) {
#line 601
      goto case_98;
    }
#line 605
    if (c == 100) {
#line 605
      goto case_100;
    }
#line 612
    if (c == 103) {
#line 612
      goto case_103;
    }
#line 618
    if (c == 104) {
#line 618
      goto case_104;
    }
#line 621
    if (c == 107) {
#line 621
      goto case_107;
    }
#line 625
    if (c == 108) {
#line 625
      goto case_108;
    }
#line 629
    if (c == 111) {
#line 629
      goto case_111;
    }
#line 633
    if (c == 112) {
#line 633
      goto case_112;
    }
#line 637
    if (c == 114) {
#line 637
      goto case_114;
    }
#line 641
    if (c == 116) {
#line 641
      goto case_116;
    }
#line 645
    if (c == 118) {
#line 645
      goto case_118;
    }
#line 649
    if (c == 120) {
#line 649
      goto case_120;
    }
#line 655
    if (c == 121) {
#line 655
      goto case_121;
    }
#line 659
    if (c == 128) {
#line 659
      goto case_128;
    }
#line 663
    if (c == 129) {
#line 663
      goto case_129;
    }
#line 667
    if (c == 130) {
#line 667
      goto case_130;
    }
#line 671
    if (c == 131) {
#line 671
      goto case_131;
    }
#line 675
    goto switch_default;
    case_0: /* CIL Label */ 
#line 559
    goto switch_break;
    case_70: /* CIL Label */ 
    case_68: /* CIL Label */ 
    {
#line 564
    name = rpl_optarg;
#line 565
    tmp = mbschr((char const   *)rpl_optarg, '=');
#line 565
    value = tmp;
    }
#line 566
    if (value) {
#line 567
      tmp___0 = value;
#line 567
      value ++;
#line 567
      *tmp___0 = (char)0;
    }
#line 568
    if (c == 68) {
#line 568
      tmp___1 = 0;
    } else {
#line 568
      tmp___1 = 1;
    }
#line 568
    if (value) {
#line 568
      tmp___2 = (char const   *)value;
    } else {
#line 568
      tmp___2 = "";
    }
    {
#line 568
    tmp___3 = command_line_location();
#line 568
    muscle_percent_define_insert((char const   *)name, tmp___3, tmp___2, (muscle_percent_define_how )tmp___1);
    }
#line 573
    goto switch_break;
    case_73: /* CIL Label */ 
#line 576
    include = (char const   *)rpl_optarg;
#line 577
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 580
    tmp___4 = command_line_location();
#line 580
    language_argmatch((char const   *)rpl_optarg, 0, tmp___4);
    }
#line 582
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 585
    tmp___5 = command_line_location();
#line 585
    skeleton_arg((char const   *)rpl_optarg, 0, tmp___5);
    }
#line 587
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 590
    flags_argmatch("--trace", trace_args, trace_types, -1, & trace_flag, rpl_optarg);
    }
#line 591
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 594
    version();
#line 595
    exit(0);
    }
    case_87: /* CIL Label */ 
    {
#line 598
    flags_argmatch("--warnings", warnings_args, warnings_types, -2, & warnings_flag,
                   rpl_optarg);
    }
#line 599
    goto switch_break;
    case_98: /* CIL Label */ 
#line 602
    spec_file_prefix = (char const   *)rpl_optarg;
#line 603
    goto switch_break;
    case_100: /* CIL Label */ 
#line 607
    defines_flag = (_Bool)1;
#line 608
    if (rpl_optarg) {
      {
#line 609
      spec_defines_file = xstrdup((char const   *)rpl_optarg);
      }
    }
#line 610
    goto switch_break;
    case_103: /* CIL Label */ 
#line 613
    graph_flag = (_Bool)1;
#line 614
    if (rpl_optarg) {
      {
#line 615
      spec_graph_file = xstrdup((char const   *)rpl_optarg);
      }
    }
#line 616
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 619
    usage(0);
    }
    case_107: /* CIL Label */ 
#line 622
    token_table_flag = (_Bool)1;
#line 623
    goto switch_break;
    case_108: /* CIL Label */ 
#line 626
    no_lines_flag = (_Bool)1;
#line 627
    goto switch_break;
    case_111: /* CIL Label */ 
#line 630
    spec_outfile = (char const   *)rpl_optarg;
#line 631
    goto switch_break;
    case_112: /* CIL Label */ 
#line 634
    spec_name_prefix = (char const   *)rpl_optarg;
#line 635
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 638
    flags_argmatch("--report", report_args, report_types, -1, & report_flag, rpl_optarg);
    }
#line 639
    goto switch_break;
    case_116: /* CIL Label */ 
#line 642
    debug_flag = (_Bool)1;
#line 643
    goto switch_break;
    case_118: /* CIL Label */ 
#line 646
    report_flag |= 1;
#line 647
    goto switch_break;
    case_120: /* CIL Label */ 
#line 650
    xml_flag = (_Bool)1;
#line 651
    if (rpl_optarg) {
      {
#line 652
      spec_xml_file = xstrdup((char const   *)rpl_optarg);
      }
    }
#line 653
    goto switch_break;
    case_121: /* CIL Label */ 
#line 656
    yacc_flag = (_Bool)1;
#line 657
    goto switch_break;
    case_128: /* CIL Label */ 
#line 660
    locations_flag = (_Bool)1;
#line 661
    goto switch_break;
    case_129: /* CIL Label */ 
    {
#line 664
    __printf__("%s\n", "/usr/local/share/locale");
#line 665
    exit(0);
    }
    case_130: /* CIL Label */ 
    {
#line 668
    tmp___6 = compute_pkgdatadir();
#line 668
    __printf__("%s\n", tmp___6);
#line 669
    exit(0);
    }
    case_131: /* CIL Label */ 
    {
#line 672
    spec_verbose_file = xstrdup((char const   *)rpl_optarg);
    }
#line 673
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 676
    usage(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  if (argc - rpl_optind != 1) {
#line 681
    if (argc - rpl_optind < 1) {
      {
#line 682
      tmp___7 = gettext("missing operand after `%s\'");
#line 682
      error(0, 0, (char const   *)tmp___7, *(argv + (argc - 1)));
      }
    } else {
      {
#line 684
      tmp___8 = gettext("extra operand `%s\'");
#line 684
      error(0, 0, (char const   *)tmp___8, *(argv + (rpl_optind + 1)));
      }
    }
    {
#line 685
    usage(1);
    }
  }
  {
#line 688
  grammar_file = uniqstr_new((char const   *)*(argv + rpl_optind));
#line 688
  current_file = grammar_file;
  }
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 689
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 689
      tmp___9 = quotearg_style((enum quoting_style )3, grammar_file);
#line 689
      p = (char const   *)tmp___9;
      }
      {
#line 689
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 689
        if (! *p) {
#line 689
          goto while_break___2;
        }
        {
#line 689
        if ((int const   )*p == 36) {
#line 689
          goto case_36;
        }
#line 689
        if ((int const   )*p == 64) {
#line 689
          goto case_64;
        }
#line 689
        if ((int const   )*p == 91) {
#line 689
          goto case_91;
        }
#line 689
        if ((int const   )*p == 93) {
#line 689
          goto case_93;
        }
#line 689
        goto switch_default___0;
        case_36: /* CIL Label */ 
        {
#line 689
        __o = & muscle_obstack;
#line 689
        tmp___10 = strlen("$][");
#line 689
        __len = (int )tmp___10;
        }
#line 689
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 689
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 689
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len);
#line 689
        __o->next_free += __len;
        }
#line 689
        goto switch_break___0;
        case_64: /* CIL Label */ 
        {
#line 689
        __o___0 = & muscle_obstack;
#line 689
        tmp___11 = strlen("@@");
#line 689
        __len___0 = (int )tmp___11;
        }
#line 689
        if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
          {
#line 689
          _obstack_newchunk(__o___0, __len___0);
          }
        }
        {
#line 689
        memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___0);
#line 689
        __o___0->next_free += __len___0;
        }
#line 689
        goto switch_break___0;
        case_91: /* CIL Label */ 
        {
#line 689
        __o___1 = & muscle_obstack;
#line 689
        tmp___12 = strlen("@{");
#line 689
        __len___1 = (int )tmp___12;
        }
#line 689
        if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
          {
#line 689
          _obstack_newchunk(__o___1, __len___1);
          }
        }
        {
#line 689
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___1);
#line 689
        __o___1->next_free += __len___1;
        }
#line 689
        goto switch_break___0;
        case_93: /* CIL Label */ 
        {
#line 689
        __o___2 = & muscle_obstack;
#line 689
        tmp___13 = strlen("@}");
#line 689
        __len___2 = (int )tmp___13;
        }
#line 689
        if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
          {
#line 689
          _obstack_newchunk(__o___2, __len___2);
          }
        }
        {
#line 689
        memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___2);
#line 689
        __o___2->next_free += __len___2;
        }
#line 689
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 689
        __o___3 = & muscle_obstack;
#line 689
        if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
          {
#line 689
          _obstack_newchunk(__o___3, 1);
          }
        }
#line 689
        tmp___14 = __o___3->next_free;
#line 689
        (__o___3->next_free) ++;
#line 689
        *tmp___14 = (char )*p;
#line 689
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 689
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 689
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 689
    __o___4 = & muscle_obstack;
#line 689
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 689
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 689
    tmp___15 = __o___4->next_free;
#line 689
    (__o___4->next_free) ++;
#line 689
    *tmp___15 = (char)0;
#line 689
    __o1 = & muscle_obstack;
#line 689
    __value = (void *)__o1->object_base;
#line 689
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 689
      __o1->maybe_empty_object = 1U;
    }
#line 689
    if (sizeof(int ) < sizeof(void *)) {
#line 689
      tmp___16 = __o1->object_base;
    } else {
#line 689
      tmp___16 = (char *)0;
    }
#line 689
    if (sizeof(int ) < sizeof(void *)) {
#line 689
      tmp___17 = __o1->object_base;
    } else {
#line 689
      tmp___17 = (char *)0;
    }
#line 689
    __o1->next_free = tmp___16 + (((__o1->next_free - tmp___17) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 689
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 689
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 689
    __o1->object_base = __o1->next_free;
#line 689
    muscle_insert("file_name", (char const   *)__value);
    }
#line 689
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 690
  return;
}
}
#line 692 "/home/pronto/abs/test-suite/bison-2.5/src/getargs.c"
void tr(char *s , char from , char to ) 
{ 


  {
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! *s) {
#line 695
      goto while_break;
    }
#line 696
    if ((int )*s == (int )from) {
#line 697
      *s = to;
    }
#line 695
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 698
  return;
}
}
#line 140 "../lib/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
char *parser_file_name  ;
#line 51 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
char *dir_prefix  ;
#line 62 "/home/pronto/abs/test-suite/bison-2.5/src/files.h"
char *all_but_ext  ;
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
char const   *spec_outfile  =    (char const   *)((void *)0);
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
char const   *spec_file_prefix  =    (char const   *)((void *)0);
#line 45 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
char const   *spec_name_prefix  =    (char const   *)((void *)0);
#line 46 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
char *spec_verbose_file  =    (char *)((void *)0);
#line 47 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
char *spec_graph_file  =    (char *)((void *)0);
#line 48 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
char *spec_xml_file  =    (char *)((void *)0);
#line 49 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
char *spec_defines_file  =    (char *)((void *)0);
#line 53 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static char **file_names  =    (char **)((void *)0);
#line 54 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static int file_names_count  =    0;
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
uniqstr grammar_file  =    (uniqstr )((void *)0);
#line 57 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
uniqstr current_file  =    (uniqstr )((void *)0);
#line 76 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static char *all_but_tab_ext  ;
#line 80 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static char *src_extension  =    (char *)((void *)0);
#line 82 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static char *header_extension  =    (char *)((void *)0);
#line 89 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static char *concat2(char const   *str1 , char const   *str2 ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *res ;
  void *tmp___1 ;
  char *cp ;

  {
  {
#line 92
  tmp = strlen(str1);
#line 92
  tmp___0 = strlen(str2);
#line 92
  len = tmp + tmp___0;
#line 93
  tmp___1 = xmalloc(len + 1U);
#line 93
  res = (char *)tmp___1;
#line 95
  cp = stpcpy((char */* __restrict  */)res, (char const   */* __restrict  */)str1);
#line 96
  cp = stpcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)str2);
  }
#line 97
  return (res);
}
}
#line 105 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
FILE *xfopen(char const   *name , char const   *mode ) 
{ 
  FILE *ptr ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 110
  ptr = fopen_safer(name, mode);
  }
#line 111
  if (! ptr) {
    {
#line 112
    tmp = gettext("cannot open file `%s\'");
#line 112
    tmp___0 = get_errno();
#line 112
    error(1, tmp___0, (char const   *)tmp, name);
    }
  }
#line 114
  return (ptr);
}
}
#line 121 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
void xfclose(FILE *ptr ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 124
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 125
    return;
  }
  {
#line 127
  tmp___0 = ferror_unlocked(ptr);
  }
#line 127
  if (tmp___0) {
    {
#line 128
    tmp = gettext("I/O error");
#line 128
    error(1, 0, (char const   *)tmp);
    }
  }
  {
#line 130
  tmp___3 = fclose(ptr);
  }
#line 130
  if (tmp___3 != 0) {
    {
#line 131
    tmp___1 = gettext("cannot close file");
#line 131
    tmp___2 = get_errno();
#line 131
    error(1, tmp___2, (char const   *)tmp___1);
    }
  }
#line 132
  return;
}
}
#line 140 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static void compute_exts_from_gf(char const   *ext ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 143
  tmp = strcmp(ext, ".y");
  }
#line 143
  if (tmp == 0) {
    {
#line 145
    src_extension = xstrdup((char const   *)(language->src_extension));
#line 146
    header_extension = xstrdup((char const   *)(language->header_extension));
    }
  } else {
    {
#line 150
    src_extension = xstrdup(ext);
#line 151
    header_extension = xstrdup(ext);
#line 152
    tr(src_extension, (char )'y', (char )'c');
#line 153
    tr(src_extension, (char )'Y', (char )'C');
#line 154
    tr(header_extension, (char )'y', (char )'h');
#line 155
    tr(header_extension, (char )'Y', (char )'H');
    }
  }
#line 157
  return;
}
}
#line 160 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static void compute_exts_from_src(char const   *ext ) 
{ 


  {
  {
#line 166
  src_extension = xstrdup(ext);
#line 167
  header_extension = xstrdup(ext);
#line 168
  tr(header_extension, (char )'c', (char )'h');
#line 169
  tr(header_extension, (char )'C', (char )'H');
  }
#line 170
  return;
}
}
#line 201 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static void file_name_split(char const   *file_name , char const   **base___0 , char const   **tab ,
                            char const   **ext ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  size_t baselen ;
  size_t dottablen ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 205
  tmp = last_component(file_name);
#line 205
  *base___0 = (char const   *)tmp;
#line 208
  tmp___0 = mbsrchr(*base___0, '.');
#line 208
  *ext = (char const   *)tmp___0;
#line 209
  *tab = (char const   *)((void *)0);
  }
#line 213
  if (*ext) {
#line 215
    baselen = (size_t )(*ext - *base___0);
#line 216
    dottablen = (size_t )4;
#line 217
    if (dottablen < baselen) {
      {
#line 217
      tmp___1 = strncmp(*ext - dottablen, ".tab", dottablen);
      }
#line 217
      if (tmp___1 == 0) {
#line 220
        *tab = *ext - dottablen;
      } else {
        {
#line 217
        tmp___2 = strncmp(*ext - dottablen, "_tab", dottablen);
        }
#line 217
        if (tmp___2 == 0) {
#line 220
          *tab = *ext - dottablen;
        }
      }
    }
  }
#line 222
  return;
}
}
#line 225 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
static void compute_file_name_parts(void) 
{ 
  char const   *base___0 ;
  char const   *tab ;
  char const   *ext ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 235
  if (spec_outfile) {
    {
#line 237
    file_name_split(spec_outfile, & base___0, & tab, & ext);
#line 238
    dir_prefix = xstrndup(spec_outfile, (size_t )(base___0 - spec_outfile));
#line 241
    tmp = strlen(spec_outfile);
    }
#line 241
    if (ext) {
      {
#line 241
      tmp___0 = strlen(ext);
#line 241
      tmp___1 = tmp___0;
      }
    } else {
#line 241
      tmp___1 = (size_t )0;
    }
    {
#line 241
    all_but_ext = xstrndup(spec_outfile, tmp - tmp___1);
#line 246
    tmp___2 = strlen(spec_outfile);
    }
#line 246
    if (tab) {
      {
#line 246
      tmp___3 = strlen(tab);
#line 246
      tmp___6 = tmp___3;
      }
    } else {
#line 246
      if (ext) {
        {
#line 246
        tmp___4 = strlen(ext);
#line 246
        tmp___5 = tmp___4;
        }
      } else {
#line 246
        tmp___5 = (size_t )0;
      }
#line 246
      tmp___6 = tmp___5;
    }
    {
#line 246
    all_but_tab_ext = xstrndup(spec_outfile, tmp___2 - tmp___6);
    }
#line 251
    if (ext) {
      {
#line 252
      compute_exts_from_src(ext);
      }
    }
  } else {
    {
#line 256
    file_name_split(grammar_file, & base___0, & tab, & ext);
    }
#line 258
    if (spec_file_prefix) {
      {
#line 261
      tmp___7 = last_component(spec_file_prefix);
#line 261
      dir_prefix = xstrndup(spec_file_prefix, (size_t )(tmp___7 - (char *)spec_file_prefix));
#line 264
      all_but_tab_ext = xstrdup(spec_file_prefix);
      }
    } else
#line 266
    if (yacc_flag) {
      {
#line 269
      dir_prefix = xstrdup("");
#line 270
      all_but_tab_ext = xstrdup("y");
      }
    } else {
      {
#line 276
      dir_prefix = xstrdup("");
#line 277
      tmp___8 = strlen(base___0);
      }
#line 277
      if (ext) {
        {
#line 277
        tmp___9 = strlen(ext);
#line 277
        tmp___10 = tmp___9;
        }
      } else {
#line 277
        tmp___10 = (size_t )0;
      }
      {
#line 277
      all_but_tab_ext = xstrndup(base___0, tmp___8 - tmp___10);
      }
    }
#line 281
    if (language->add_tab) {
      {
#line 282
      all_but_ext = concat2((char const   *)all_but_tab_ext, ".tab");
      }
    } else {
      {
#line 284
      all_but_ext = xstrdup((char const   *)all_but_tab_ext);
      }
    }
#line 287
    if (ext) {
#line 287
      if (! yacc_flag) {
        {
#line 288
        compute_exts_from_gf(ext);
        }
      }
    }
  }
#line 290
  return;
}
}
#line 296 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
void compute_output_file_names(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 299
  compute_file_name_parts();
  }
#line 302
  if (! src_extension) {
    {
#line 303
    src_extension = xstrdup(".c");
    }
  }
#line 304
  if (! header_extension) {
    {
#line 305
    header_extension = xstrdup(".h");
    }
  }
#line 307
  if (spec_outfile) {
    {
#line 307
    tmp = xstrdup(spec_outfile);
#line 307
    parser_file_name = tmp;
    }
  } else {
    {
#line 307
    tmp___0 = concat2((char const   *)all_but_ext, (char const   *)src_extension);
#line 307
    parser_file_name = tmp___0;
    }
  }
#line 312
  if (defines_flag) {
#line 314
    if (! spec_defines_file) {
      {
#line 315
      spec_defines_file = concat2((char const   *)all_but_ext, (char const   *)header_extension);
      }
    }
  }
#line 318
  if (graph_flag) {
#line 320
    if (! spec_graph_file) {
      {
#line 321
      spec_graph_file = concat2((char const   *)all_but_tab_ext, ".dot");
      }
    }
    {
#line 322
    output_file_name_check(& spec_graph_file);
    }
  }
#line 325
  if (xml_flag) {
#line 327
    if (! spec_xml_file) {
      {
#line 328
      spec_xml_file = concat2((char const   *)all_but_tab_ext, ".xml");
      }
    }
    {
#line 329
    output_file_name_check(& spec_xml_file);
    }
  }
#line 332
  if (report_flag) {
#line 334
    if (! spec_verbose_file) {
      {
#line 335
      spec_verbose_file = concat2((char const   *)all_but_tab_ext, ".output");
      }
    }
    {
#line 336
    output_file_name_check(& spec_verbose_file);
    }
  }
  {
#line 339
  free((void *)all_but_tab_ext);
#line 340
  free((void *)src_extension);
#line 341
  free((void *)header_extension);
  }
#line 342
  return;
}
}
#line 344 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
void output_file_name_check(char **file_name ) 
{ 
  _Bool conflict ;
  char const   *tmp ;
  char *tmp___0 ;
  int i ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 347
  conflict = (_Bool)0;
#line 348
  tmp___4 = strcmp((char const   *)*file_name, grammar_file);
  }
#line 348
  if (0 == tmp___4) {
    {
#line 350
    tmp = quote((char const   *)*file_name);
#line 350
    tmp___0 = gettext("refusing to overwrite the input file %s");
#line 350
    complain((char const   *)tmp___0, tmp);
#line 352
    conflict = (_Bool)1;
    }
  } else {
#line 357
    i = 0;
    {
#line 357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 357
      if (! (i < file_names_count)) {
#line 357
        goto while_break;
      }
      {
#line 358
      tmp___3 = strcmp((char const   *)*(file_names + i), (char const   *)*file_name);
      }
#line 358
      if (0 == tmp___3) {
        {
#line 360
        tmp___1 = quote((char const   *)*file_name);
#line 360
        tmp___2 = gettext("conflicting outputs to file %s");
#line 360
        warn((char const   *)tmp___2, tmp___1);
#line 362
        conflict = (_Bool)1;
        }
      }
#line 357
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 365
  if (conflict) {
    {
#line 367
    free((void *)*file_name);
#line 368
    *file_name = strdup("/dev/null");
    }
  } else {
    {
#line 372
    file_names_count ++;
#line 372
    tmp___5 = xnrealloc((void *)file_names, (size_t )file_names_count, (size_t )sizeof(*file_names));
#line 372
    file_names = (char **)tmp___5;
#line 374
    *(file_names + (file_names_count - 1)) = xstrdup((char const   *)*file_name);
    }
  }
#line 376
  return;
}
}
#line 378 "/home/pronto/abs/test-suite/bison-2.5/src/files.c"
void output_file_names_free(void) 
{ 
  int i ;

  {
  {
#line 381
  free((void *)all_but_ext);
#line 382
  free((void *)spec_verbose_file);
#line 383
  free((void *)spec_graph_file);
#line 384
  free((void *)spec_xml_file);
#line 385
  free((void *)spec_defines_file);
#line 386
  free((void *)parser_file_name);
#line 387
  free((void *)dir_prefix);
#line 390
  i = 0;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < file_names_count)) {
#line 390
      goto while_break;
    }
    {
#line 391
    free((void *)*(file_names + i));
#line 390
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 393
  free((void *)file_names);
  }
#line 394
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.5/src/derives.h"
rule ***derives  ;
#line 40 "/home/pronto/abs/test-suite/bison-2.5/src/derives.c"
static void print_derives(void) 
{ 
  int i ;
  rule **rp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 45
  fputs_unlocked((char const   */* __restrict  */)"DERIVES\n", (FILE */* __restrict  */)stderr);
#line 47
  i = ntokens;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < nsyms)) {
#line 47
      goto while_break;
    }
    {
#line 50
    rpl_fprintf(stderr, "\t%s derives\n", (*(symbols + i))->tag);
#line 51
    rp = *(derives + (i - ntokens));
    }
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 51
      if (! *rp) {
#line 51
        goto while_break___0;
      }
      {
#line 53
      rpl_fprintf(stderr, "\t\t%3d ", (*rp)->user_number);
#line 54
      rule_rhs_print(*rp, stderr);
#line 51
      rp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)stderr);
  }
#line 59
  return;
}
}
#line 62 "/home/pronto/abs/test-suite/bison-2.5/src/derives.c"
void derives_compute(void) 
{ 
  symbol_number i ;
  rule_number r ;
  rule **q ;
  rule_list **dset ;
  void *tmp ;
  rule_list *delts ;
  void *tmp___0 ;
  symbol_number lhs ;
  rule_list *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  rule_list *p___0 ;
  rule **tmp___3 ;
  rule **tmp___4 ;

  {
  {
#line 71
  tmp = xcalloc((size_t )nvars, (size_t )sizeof(*dset));
#line 71
  dset = (rule_list **)tmp;
#line 76
  tmp___0 = xnmalloc((size_t )nrules, (size_t )sizeof(*delts));
#line 76
  delts = (rule_list *)tmp___0;
#line 78
  r = nrules - 1;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (r >= 0)) {
#line 78
      goto while_break;
    }
#line 80
    lhs = ((rules + r)->lhs)->number;
#line 81
    p = delts + r;
#line 83
    p->next = *(dset + (lhs - ntokens));
#line 84
    p->value = rules + r;
#line 85
    *(dset + (lhs - ntokens)) = p;
#line 78
    r --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  tmp___1 = xnmalloc((size_t )nvars, (size_t )sizeof(*derives));
#line 91
  derives = (rule ***)tmp___1;
#line 92
  tmp___2 = xnmalloc((size_t )(nvars + nrules), (size_t )sizeof(*q));
#line 92
  q = (rule **)tmp___2;
#line 94
  i = ntokens;
  }
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if (! (i < nsyms)) {
#line 94
      goto while_break___0;
    }
#line 96
    p___0 = *(dset + (i - ntokens));
#line 97
    *(derives + (i - ntokens)) = q;
    {
#line 98
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 98
      if (! p___0) {
#line 98
        goto while_break___1;
      }
#line 100
      tmp___3 = q;
#line 100
      q ++;
#line 100
      *tmp___3 = p___0->value;
#line 101
      p___0 = p___0->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 103
    tmp___4 = q;
#line 103
    q ++;
#line 103
    *tmp___4 = (rule *)((void *)0);
#line 94
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 106
  if (trace_flag & 8) {
    {
#line 107
    print_derives();
    }
  }
  {
#line 109
  free((void *)dset);
#line 110
  free((void *)delts);
  }
#line 111
  return;
}
}
#line 114 "/home/pronto/abs/test-suite/bison-2.5/src/derives.c"
void derives_free(void) 
{ 


  {
  {
#line 117
  free((void *)*(derives + 0));
#line 118
  free((void *)derives);
  }
#line 119
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 33 "/home/pronto/abs/test-suite/bison-2.5/src/complain.h"
void set_warning_issued(void) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
int expected_sr_conflicts  =    -1;
#line 40 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
int expected_rr_conflicts  =    -1;
#line 41 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static char *conflicts  ;
#line 42 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static struct obstack solved_conflicts_obstack  ;
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static struct obstack solved_conflicts_xml_obstack  ;
#line 45 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static bitset shift_set  ;
#line 46 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static bitset lookahead_set  ;
#line 65 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
__inline static void log_resolution(rule *r , symbol_number token , enum conflict_resolution resolution ) 
{ 
  char buf___0[4096] ;
  char *tmp ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  char buf___1[4096] ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___2 ;
  char buf___2[4096] ;
  char *tmp___3 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___4 ;
  char buf___3[4096] ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___5 ;
  char buf___4[4096] ;
  struct obstack *__o___3 ;
  int __len___3 ;
  size_t tmp___6 ;
  char buf___5[4096] ;
  struct obstack *__o___4 ;
  int __len___4 ;
  size_t tmp___7 ;
  char buf___6[4096] ;
  struct obstack *__o___5 ;
  int __len___5 ;
  size_t tmp___8 ;
  char buf___7[4096] ;
  struct obstack *__o___6 ;
  int __len___6 ;
  size_t tmp___9 ;
  struct obstack *__o___7 ;
  int __len___7 ;
  size_t tmp___10 ;
  char buf___8[4096] ;
  char const   *tmp___11 ;
  struct obstack *__o___8 ;
  int __len___8 ;
  size_t tmp___12 ;
  char buf___9[4096] ;
  char const   *tmp___13 ;
  struct obstack *__o___9 ;
  int __len___9 ;
  size_t tmp___14 ;
  char buf___10[4096] ;
  char const   *tmp___15 ;
  struct obstack *__o___10 ;
  int __len___10 ;
  size_t tmp___16 ;
  char buf___11[4096] ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  struct obstack *__o___11 ;
  int __len___11 ;
  size_t tmp___19 ;
  char buf___12[4096] ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  struct obstack *__o___12 ;
  int __len___12 ;
  size_t tmp___22 ;
  char buf___13[4096] ;
  char const   *tmp___23 ;
  struct obstack *__o___13 ;
  int __len___13 ;
  size_t tmp___24 ;
  char buf___14[4096] ;
  char const   *tmp___25 ;
  struct obstack *__o___14 ;
  int __len___14 ;
  size_t tmp___26 ;
  char buf___15[4096] ;
  char const   *tmp___27 ;
  struct obstack *__o___15 ;
  int __len___15 ;
  size_t tmp___28 ;
  struct obstack *__o___16 ;
  int __len___16 ;
  size_t tmp___29 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  void *__cil_tmp89 ;
  void *__cil_tmp90 ;
  void *__cil_tmp91 ;
  void *__cil_tmp92 ;
  void *__cil_tmp93 ;
  void *__cil_tmp94 ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  void *__cil_tmp98 ;
  void *__cil_tmp99 ;
  void *__cil_tmp100 ;
  void *__cil_tmp101 ;
  void *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;

  {
#line 69
  if (report_flag & 8) {
    {
#line 75
    if ((unsigned int )resolution == 3U) {
#line 75
      goto case_3;
    }
#line 75
    if ((unsigned int )resolution == 0U) {
#line 75
      goto case_3;
    }
#line 84
    if ((unsigned int )resolution == 2U) {
#line 84
      goto case_2;
    }
#line 84
    if ((unsigned int )resolution == 1U) {
#line 84
      goto case_2;
    }
#line 92
    if ((unsigned int )resolution == 4U) {
#line 92
      goto case_4;
    }
#line 72
    goto switch_break;
    case_3: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 76
      tmp = gettext("    Conflict between rule %d and token %s resolved as shift");
#line 76
      rpl_sprintf(buf___0, (char const   *)tmp, r->number, (*(symbols + token))->tag);
#line 76
      __o = & solved_conflicts_obstack;
#line 76
      tmp___0 = strlen((char const   *)(buf___0));
#line 76
      __len = (int )tmp___0;
      }
#line 76
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 76
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 76
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len);
#line 76
      __o->next_free += __len;
      }
#line 76
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 81
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 85
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 85
      tmp___1 = gettext("    Conflict between rule %d and token %s resolved as reduce");
#line 85
      rpl_sprintf(buf___1, (char const   *)tmp___1, r->number, (*(symbols + token))->tag);
#line 85
      __o___0 = & solved_conflicts_obstack;
#line 85
      tmp___2 = strlen((char const   *)(buf___1));
#line 85
      __len___0 = (int )tmp___2;
      }
#line 85
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 85
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 85
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 85
      __o___0->next_free += __len___0;
      }
#line 85
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 93
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 93
      tmp___3 = gettext("    Conflict between rule %d and token %s resolved as an error");
#line 93
      rpl_sprintf(buf___2, (char const   *)tmp___3, r->number, (*(symbols + token))->tag);
#line 93
      __o___1 = & solved_conflicts_obstack;
#line 93
      tmp___4 = strlen((char const   *)(buf___2));
#line 93
      __len___1 = (int )tmp___4;
      }
#line 93
      if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 93
        _obstack_newchunk(__o___1, __len___1);
        }
      }
      {
#line 93
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___2),
             (size_t )__len___1);
#line 93
      __o___1->next_free += __len___1;
      }
#line 93
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 98
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 104
    if ((unsigned int )resolution == 0U) {
#line 104
      goto case_0___0;
    }
#line 111
    if ((unsigned int )resolution == 1U) {
#line 111
      goto case_1___0;
    }
#line 118
    if ((unsigned int )resolution == 2U) {
#line 118
      goto case_2___0;
    }
#line 124
    if ((unsigned int )resolution == 3U) {
#line 124
      goto case_3___0;
    }
#line 130
    if ((unsigned int )resolution == 4U) {
#line 130
      goto case_4___0;
    }
#line 102
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 105
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 105
      rpl_sprintf(buf___3, " (%s < %s)", (r->prec)->tag, (*(symbols + token))->tag);
#line 105
      __o___2 = & solved_conflicts_obstack;
#line 105
      tmp___5 = strlen((char const   *)(buf___3));
#line 105
      __len___2 = (int )tmp___5;
      }
#line 105
      if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___2, __len___2);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___2);
#line 105
      __o___2->next_free += __len___2;
      }
#line 105
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 109
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 112
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 112
      rpl_sprintf(buf___4, " (%s < %s)", (*(symbols + token))->tag, (r->prec)->tag);
#line 112
      __o___3 = & solved_conflicts_obstack;
#line 112
      tmp___6 = strlen((char const   *)(buf___4));
#line 112
      __len___3 = (int )tmp___6;
      }
#line 112
      if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
        {
#line 112
        _obstack_newchunk(__o___3, __len___3);
        }
      }
      {
#line 112
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___4),
             (size_t )__len___3);
#line 112
      __o___3->next_free += __len___3;
      }
#line 112
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 116
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 119
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 119
      rpl_sprintf(buf___5, " (%%left %s)", (*(symbols + token))->tag);
#line 119
      __o___4 = & solved_conflicts_obstack;
#line 119
      tmp___7 = strlen((char const   *)(buf___5));
#line 119
      __len___4 = (int )tmp___7;
      }
#line 119
      if ((unsigned long )(__o___4->next_free + __len___4) > (unsigned long )__o___4->chunk_limit) {
        {
#line 119
        _obstack_newchunk(__o___4, __len___4);
        }
      }
      {
#line 119
      memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___4);
#line 119
      __o___4->next_free += __len___4;
      }
#line 119
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 122
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 125
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 125
      rpl_sprintf(buf___6, " (%%right %s)", (*(symbols + token))->tag);
#line 125
      __o___5 = & solved_conflicts_obstack;
#line 125
      tmp___8 = strlen((char const   *)(buf___6));
#line 125
      __len___5 = (int )tmp___8;
      }
#line 125
      if ((unsigned long )(__o___5->next_free + __len___5) > (unsigned long )__o___5->chunk_limit) {
        {
#line 125
        _obstack_newchunk(__o___5, __len___5);
        }
      }
      {
#line 125
      memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___6),
             (size_t )__len___5);
#line 125
      __o___5->next_free += __len___5;
      }
#line 125
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 128
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 131
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 131
      rpl_sprintf(buf___7, " (%%nonassoc %s)", (*(symbols + token))->tag);
#line 131
      __o___6 = & solved_conflicts_obstack;
#line 131
      tmp___9 = strlen((char const   *)(buf___7));
#line 131
      __len___6 = (int )tmp___9;
      }
#line 131
      if ((unsigned long )(__o___6->next_free + __len___6) > (unsigned long )__o___6->chunk_limit) {
        {
#line 131
        _obstack_newchunk(__o___6, __len___6);
        }
      }
      {
#line 131
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___7),
             (size_t )__len___6);
#line 131
      __o___6->next_free += __len___6;
      }
#line 131
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 134
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 137
    __o___7 = & solved_conflicts_obstack;
#line 137
    tmp___10 = strlen(".\n");
#line 137
    __len___7 = (int )tmp___10;
    }
#line 137
    if ((unsigned long )(__o___7->next_free + __len___7) > (unsigned long )__o___7->chunk_limit) {
      {
#line 137
      _obstack_newchunk(__o___7, __len___7);
      }
    }
    {
#line 137
    memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)".\n",
           (size_t )__len___7);
#line 137
    __o___7->next_free += __len___7;
    }
  }
#line 141
  if (xml_flag) {
    {
#line 147
    if ((unsigned int )resolution == 3U) {
#line 147
      goto case_3___1;
    }
#line 147
    if ((unsigned int )resolution == 0U) {
#line 147
      goto case_3___1;
    }
#line 156
    if ((unsigned int )resolution == 2U) {
#line 156
      goto case_2___1;
    }
#line 156
    if ((unsigned int )resolution == 1U) {
#line 156
      goto case_2___1;
    }
#line 164
    if ((unsigned int )resolution == 4U) {
#line 164
      goto case_4___1;
    }
#line 144
    goto switch_break___1;
    case_3___1: /* CIL Label */ 
    case_0___1: /* CIL Label */ 
    {
#line 148
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 148
      tmp___11 = xml_escape((*(symbols + token))->tag);
#line 148
      rpl_sprintf(buf___8, "        <resolution rule=\"%d\" symbol=\"%s\" type=\"shift\">",
                  r->number, tmp___11);
#line 148
      __o___8 = & solved_conflicts_xml_obstack;
#line 148
      tmp___12 = strlen((char const   *)(buf___8));
#line 148
      __len___8 = (int )tmp___12;
      }
#line 148
      if ((unsigned long )(__o___8->next_free + __len___8) > (unsigned long )__o___8->chunk_limit) {
        {
#line 148
        _obstack_newchunk(__o___8, __len___8);
        }
      }
      {
#line 148
      memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___8),
             (size_t )__len___8);
#line 148
      __o___8->next_free += __len___8;
      }
#line 148
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 153
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    case_1___1: /* CIL Label */ 
    {
#line 157
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 157
      tmp___13 = xml_escape((*(symbols + token))->tag);
#line 157
      rpl_sprintf(buf___9, "        <resolution rule=\"%d\" symbol=\"%s\" type=\"reduce\">",
                  r->number, tmp___13);
#line 157
      __o___9 = & solved_conflicts_xml_obstack;
#line 157
      tmp___14 = strlen((char const   *)(buf___9));
#line 157
      __len___9 = (int )tmp___14;
      }
#line 157
      if ((unsigned long )(__o___9->next_free + __len___9) > (unsigned long )__o___9->chunk_limit) {
        {
#line 157
        _obstack_newchunk(__o___9, __len___9);
        }
      }
      {
#line 157
      memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)(buf___9),
             (size_t )__len___9);
#line 157
      __o___9->next_free += __len___9;
      }
#line 157
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 162
    goto switch_break___1;
    case_4___1: /* CIL Label */ 
    {
#line 165
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 165
      tmp___15 = xml_escape((*(symbols + token))->tag);
#line 165
      rpl_sprintf(buf___10, "        <resolution rule=\"%d\" symbol=\"%s\" type=\"error\">",
                  r->number, tmp___15);
#line 165
      __o___10 = & solved_conflicts_xml_obstack;
#line 165
      tmp___16 = strlen((char const   *)(buf___10));
#line 165
      __len___10 = (int )tmp___16;
      }
#line 165
      if ((unsigned long )(__o___10->next_free + __len___10) > (unsigned long )__o___10->chunk_limit) {
        {
#line 165
        _obstack_newchunk(__o___10, __len___10);
        }
      }
      {
#line 165
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___10),
             (size_t )__len___10);
#line 165
      __o___10->next_free += __len___10;
      }
#line 165
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 170
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 176
    if ((unsigned int )resolution == 0U) {
#line 176
      goto case_0___2;
    }
#line 183
    if ((unsigned int )resolution == 1U) {
#line 183
      goto case_1___2;
    }
#line 190
    if ((unsigned int )resolution == 2U) {
#line 190
      goto case_2___2;
    }
#line 196
    if ((unsigned int )resolution == 3U) {
#line 196
      goto case_3___2;
    }
#line 202
    if ((unsigned int )resolution == 4U) {
#line 202
      goto case_4___2;
    }
#line 174
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
    {
#line 177
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 177
      tmp___17 = xml_escape_n(1, (*(symbols + token))->tag);
#line 177
      tmp___18 = xml_escape_n(0, (r->prec)->tag);
#line 177
      rpl_sprintf(buf___11, "%s &lt; %s", tmp___18, tmp___17);
#line 177
      __o___11 = & solved_conflicts_xml_obstack;
#line 177
      tmp___19 = strlen((char const   *)(buf___11));
#line 177
      __len___11 = (int )tmp___19;
      }
#line 177
      if ((unsigned long )(__o___11->next_free + __len___11) > (unsigned long )__o___11->chunk_limit) {
        {
#line 177
        _obstack_newchunk(__o___11, __len___11);
        }
      }
      {
#line 177
      memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)(buf___11),
             (size_t )__len___11);
#line 177
      __o___11->next_free += __len___11;
      }
#line 177
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 181
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
    {
#line 184
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 184
      tmp___20 = xml_escape_n(1, (r->prec)->tag);
#line 184
      tmp___21 = xml_escape_n(0, (*(symbols + token))->tag);
#line 184
      rpl_sprintf(buf___12, "%s &lt; %s", tmp___21, tmp___20);
#line 184
      __o___12 = & solved_conflicts_xml_obstack;
#line 184
      tmp___22 = strlen((char const   *)(buf___12));
#line 184
      __len___12 = (int )tmp___22;
      }
#line 184
      if ((unsigned long )(__o___12->next_free + __len___12) > (unsigned long )__o___12->chunk_limit) {
        {
#line 184
        _obstack_newchunk(__o___12, __len___12);
        }
      }
      {
#line 184
      memcpy((void */* __restrict  */)__o___12->next_free, (void const   */* __restrict  */)(buf___12),
             (size_t )__len___12);
#line 184
      __o___12->next_free += __len___12;
      }
#line 184
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 188
    goto switch_break___2;
    case_2___2: /* CIL Label */ 
    {
#line 191
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 191
      tmp___23 = xml_escape((*(symbols + token))->tag);
#line 191
      rpl_sprintf(buf___13, "%%left %s", tmp___23);
#line 191
      __o___13 = & solved_conflicts_xml_obstack;
#line 191
      tmp___24 = strlen((char const   *)(buf___13));
#line 191
      __len___13 = (int )tmp___24;
      }
#line 191
      if ((unsigned long )(__o___13->next_free + __len___13) > (unsigned long )__o___13->chunk_limit) {
        {
#line 191
        _obstack_newchunk(__o___13, __len___13);
        }
      }
      {
#line 191
      memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)(buf___13),
             (size_t )__len___13);
#line 191
      __o___13->next_free += __len___13;
      }
#line 191
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 194
    goto switch_break___2;
    case_3___2: /* CIL Label */ 
    {
#line 197
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 197
      tmp___25 = xml_escape((*(symbols + token))->tag);
#line 197
      rpl_sprintf(buf___14, "%%right %s", tmp___25);
#line 197
      __o___14 = & solved_conflicts_xml_obstack;
#line 197
      tmp___26 = strlen((char const   *)(buf___14));
#line 197
      __len___14 = (int )tmp___26;
      }
#line 197
      if ((unsigned long )(__o___14->next_free + __len___14) > (unsigned long )__o___14->chunk_limit) {
        {
#line 197
        _obstack_newchunk(__o___14, __len___14);
        }
      }
      {
#line 197
      memcpy((void */* __restrict  */)__o___14->next_free, (void const   */* __restrict  */)(buf___14),
             (size_t )__len___14);
#line 197
      __o___14->next_free += __len___14;
      }
#line 197
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 200
    goto switch_break___2;
    case_4___2: /* CIL Label */ 
    {
#line 203
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 203
      tmp___27 = xml_escape((*(symbols + token))->tag);
#line 203
      rpl_sprintf(buf___15, "%%nonassoc %s", tmp___27);
#line 203
      __o___15 = & solved_conflicts_xml_obstack;
#line 203
      tmp___28 = strlen((char const   *)(buf___15));
#line 203
      __len___15 = (int )tmp___28;
      }
#line 203
      if ((unsigned long )(__o___15->next_free + __len___15) > (unsigned long )__o___15->chunk_limit) {
        {
#line 203
        _obstack_newchunk(__o___15, __len___15);
        }
      }
      {
#line 203
      memcpy((void */* __restrict  */)__o___15->next_free, (void const   */* __restrict  */)(buf___15),
             (size_t )__len___15);
#line 203
      __o___15->next_free += __len___15;
      }
#line 203
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 206
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 209
    __o___16 = & solved_conflicts_xml_obstack;
#line 209
    tmp___29 = strlen("</resolution>\n");
#line 209
    __len___16 = (int )tmp___29;
    }
#line 209
    if ((unsigned long )(__o___16->next_free + __len___16) > (unsigned long )__o___16->chunk_limit) {
      {
#line 209
      _obstack_newchunk(__o___16, __len___16);
      }
    }
    {
#line 209
    memcpy((void */* __restrict  */)__o___16->next_free, (void const   */* __restrict  */)"</resolution>\n",
           (size_t )__len___16);
#line 209
    __o___16->next_free += __len___16;
    }
  }
#line 211
  return;
}
}
#line 220 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static void flush_shift(state *s , int token ) 
{ 
  transitions *trans ;
  int i ;

  {
  {
#line 223
  trans = s->transitions;
#line 226
  bitset_reset(lookahead_set, (bitset_bindex )token);
#line 227
  i = 0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < trans->num)) {
#line 227
      goto while_break;
    }
#line 228
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 228
      if ((trans->states[i])->accessing_symbol == token) {
#line 230
        trans->states[i] = (state *)((void *)0);
      }
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 240 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static void flush_reduce(bitset lookahead_tokens , int token ) 
{ 


  {
  {
#line 243
  bitset_reset(lookahead_tokens, (bitset_bindex )token);
  }
#line 244
  return;
}
}
#line 259 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static void resolve_sr_conflict(state *s , int ruleno , symbol **errors , int *nerrs ) 
{ 
  symbol_number i ;
  reductions *reds ;
  rule *redrule ;
  int redprec ;
  bitset lookahead_tokens ;
  int tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 263
  reds = s->reductions;
#line 265
  redrule = reds->rules[ruleno];
#line 266
  redprec = (redrule->prec)->prec;
#line 267
  lookahead_tokens = *(reds->lookahead_tokens + ruleno);
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (i < ntokens)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp___0 = bitset_test(lookahead_tokens, (bitset_bindex )i);
    }
#line 270
    if (tmp___0) {
      {
#line 270
      tmp___1 = bitset_test(lookahead_set, (bitset_bindex )i);
      }
#line 270
      if (tmp___1) {
#line 270
        if ((*(symbols + i))->prec) {
#line 277
          if ((*(symbols + i))->prec < redprec) {
            {
#line 279
            log_resolution(redrule, i, (enum conflict_resolution )1);
#line 280
            flush_shift(s, i);
            }
          } else
#line 282
          if ((*(symbols + i))->prec > redprec) {
            {
#line 284
            log_resolution(redrule, i, (enum conflict_resolution )0);
#line 285
            flush_reduce(lookahead_tokens, i);
            }
          } else {
            {
#line 298
            if ((unsigned int )(*(symbols + i))->assoc == 1U) {
#line 298
              goto case_1;
            }
#line 303
            if ((unsigned int )(*(symbols + i))->assoc == 2U) {
#line 303
              goto case_2;
            }
#line 308
            if ((unsigned int )(*(symbols + i))->assoc == 3U) {
#line 308
              goto case_3;
            }
#line 295
            goto switch_default;
            switch_default: /* CIL Label */ 
            {
#line 296
            abort();
            }
            case_1: /* CIL Label */ 
            {
#line 299
            log_resolution(redrule, i, (enum conflict_resolution )3);
#line 300
            flush_reduce(lookahead_tokens, i);
            }
#line 301
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 304
            log_resolution(redrule, i, (enum conflict_resolution )2);
#line 305
            flush_shift(s, i);
            }
#line 306
            goto switch_break;
            case_3: /* CIL Label */ 
            {
#line 309
            log_resolution(redrule, i, (enum conflict_resolution )4);
#line 310
            flush_shift(s, i);
#line 311
            flush_reduce(lookahead_tokens, i);
#line 313
            tmp = *nerrs;
#line 313
            (*nerrs) ++;
#line 313
            *(errors + tmp) = *(symbols + i);
            }
#line 314
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 327 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static void set_conflicts(state *s , symbol **errors ) 
{ 
  int i ;
  transitions *trans ;
  reductions *reds ;
  int nerrs ;
  _Bool tmp ;
  struct obstack *__o ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct obstack  const  *__o___0 ;
  struct obstack *__o___1 ;
  char *tmp___3 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct obstack  const  *__o___2 ;
  _Bool tmp___6 ;

  {
#line 331
  trans = s->transitions;
#line 332
  reds = s->reductions;
#line 333
  nerrs = 0;
#line 335
  if (s->consistent) {
#line 336
    return;
  }
  {
#line 338
  (*((lookahead_set->b.vtable)->zero))(lookahead_set);
#line 340
  i = 0;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (i < trans->num) {
#line 340
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 340
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 340
          goto while_break;
        }
      }
    } else {
#line 340
      goto while_break;
    }
#line 340
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
      {
#line 341
      bitset_set(lookahead_set, (bitset_bindex )(trans->states[i])->accessing_symbol);
      }
    }
#line 340
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  i = 0;
  {
#line 346
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 346
    if (! (i < reds->num)) {
#line 346
      goto while_break___0;
    }
#line 347
    if ((reds->rules[i])->prec) {
#line 347
      if (((reds->rules[i])->prec)->prec) {
        {
#line 347
        tmp = (*((lookahead_set->b.vtable)->disjoint_p))(*(reds->lookahead_tokens + i),
                                                         lookahead_set);
        }
#line 347
        if (! tmp) {
          {
#line 349
          resolve_sr_conflict(s, i, errors, & nerrs);
          }
        }
      }
    }
#line 346
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 351
  if (nerrs) {
    {
#line 355
    state_errs_set(s, nerrs, errors);
    }
  }
#line 357
  __o___0 = (struct obstack  const  *)(& solved_conflicts_obstack);
#line 357
  if ((unsigned int )(__o___0->next_free - __o___0->object_base)) {
#line 359
    __o = & solved_conflicts_obstack;
#line 359
    if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
      {
#line 359
      _obstack_newchunk(__o, 1);
      }
    }
#line 359
    tmp___0 = __o->next_free;
#line 359
    (__o->next_free) ++;
#line 359
    *tmp___0 = (char )'\000';
#line 360
    __o1 = & solved_conflicts_obstack;
#line 360
    __value = (void *)__o1->object_base;
#line 360
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 360
      __o1->maybe_empty_object = 1U;
    }
#line 360
    if (sizeof(int ) < sizeof(void *)) {
#line 360
      tmp___1 = __o1->object_base;
    } else {
#line 360
      tmp___1 = (char *)0;
    }
#line 360
    if (sizeof(int ) < sizeof(void *)) {
#line 360
      tmp___2 = __o1->object_base;
    } else {
#line 360
      tmp___2 = (char *)0;
    }
#line 360
    __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 360
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 360
      __o1->next_free = __o1->chunk_limit;
    }
#line 360
    __o1->object_base = __o1->next_free;
#line 360
    s->solved_conflicts = (char const   *)__value;
  }
#line 362
  __o___2 = (struct obstack  const  *)(& solved_conflicts_xml_obstack);
#line 362
  if ((unsigned int )(__o___2->next_free - __o___2->object_base)) {
#line 364
    __o___1 = & solved_conflicts_xml_obstack;
#line 364
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 364
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 364
    tmp___3 = __o___1->next_free;
#line 364
    (__o___1->next_free) ++;
#line 364
    *tmp___3 = (char )'\000';
#line 365
    __o1___0 = & solved_conflicts_xml_obstack;
#line 365
    __value___0 = (void *)__o1___0->object_base;
#line 365
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 365
      __o1___0->maybe_empty_object = 1U;
    }
#line 365
    if (sizeof(int ) < sizeof(void *)) {
#line 365
      tmp___4 = __o1___0->object_base;
    } else {
#line 365
      tmp___4 = (char *)0;
    }
#line 365
    if (sizeof(int ) < sizeof(void *)) {
#line 365
      tmp___5 = __o1___0->object_base;
    } else {
#line 365
      tmp___5 = (char *)0;
    }
#line 365
    __o1___0->next_free = tmp___4 + (((__o1___0->next_free - tmp___5) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 365
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 365
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 365
    __o1___0->object_base = __o1___0->next_free;
#line 365
    s->solved_conflicts_xml = (char const   *)__value___0;
  }
#line 370
  i = 0;
  {
#line 370
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 370
    if (! (i < reds->num)) {
#line 370
      goto while_break___1;
    }
    {
#line 372
    tmp___6 = (*((lookahead_set->b.vtable)->disjoint_p))(*(reds->lookahead_tokens + i),
                                                         lookahead_set);
    }
#line 372
    if (! tmp___6) {
#line 373
      *(conflicts + s->number) = (char)1;
    }
    {
#line 374
    (*((lookahead_set->b.vtable)->or_))(lookahead_set, lookahead_set, *(reds->lookahead_tokens + i));
#line 370
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 376
  return;
}
}
#line 384 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
void conflicts_solve(void) 
{ 
  state_number i ;
  symbol **errors ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 389
  tmp = xnmalloc((size_t )(ntokens + 1), (size_t )sizeof(*errors));
#line 389
  errors = (symbol **)tmp;
#line 391
  tmp___0 = xcalloc((size_t )nstates, (size_t )sizeof(*conflicts));
#line 391
  conflicts = (char *)tmp___0;
#line 392
  shift_set = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 393
  lookahead_set = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 394
  _obstack_begin(& solved_conflicts_obstack, 0, 0, (void *(*)(long  ))(& xmalloc),
                 & free);
#line 395
  _obstack_begin(& solved_conflicts_xml_obstack, 0, 0, (void *(*)(long  ))(& xmalloc),
                 & free);
#line 397
  i = 0;
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! (i < nstates)) {
#line 397
      goto while_break;
    }
    {
#line 399
    set_conflicts(*(states + i), errors);
    }
#line 403
    if (! (*(states + i))->errs) {
      {
#line 404
      (*(states + i))->errs = errs_new(0, (symbol **)0);
      }
    }
#line 397
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 407
  free((void *)errors);
  }
#line 408
  return;
}
}
#line 411 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
void conflicts_update_state_numbers(state_number *old_to_new , state_number nstates_old ) 
{ 
  state_number i ;

  {
#line 416
  i = 0;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! (i < nstates_old)) {
#line 416
      goto while_break;
    }
#line 417
    if (*(old_to_new + i) != nstates_old) {
#line 418
      *(conflicts + *(old_to_new + i)) = *(conflicts + i);
    }
#line 416
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return;
}
}
#line 426 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static int count_sr_conflicts(state *s ) 
{ 
  int i ;
  int src_count ;
  transitions *trans ;
  reductions *reds ;
  bitset_bindex tmp ;

  {
#line 430
  src_count = 0;
#line 431
  trans = s->transitions;
#line 432
  reds = s->reductions;
#line 434
  if (! trans) {
#line 435
    return (0);
  }
  {
#line 437
  (*((lookahead_set->b.vtable)->zero))(lookahead_set);
#line 438
  (*((shift_set->b.vtable)->zero))(shift_set);
#line 440
  i = 0;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (i < trans->num) {
#line 440
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 440
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 440
          goto while_break;
        }
      }
    } else {
#line 440
      goto while_break;
    }
#line 440
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
      {
#line 441
      bitset_set(shift_set, (bitset_bindex )(trans->states[i])->accessing_symbol);
      }
    }
#line 440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  i = 0;
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 443
    if (! (i < reds->num)) {
#line 443
      goto while_break___0;
    }
    {
#line 444
    (*((lookahead_set->b.vtable)->or_))(lookahead_set, lookahead_set, *(reds->lookahead_tokens + i));
#line 443
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 446
  (*((lookahead_set->b.vtable)->and_))(lookahead_set, lookahead_set, shift_set);
#line 448
  tmp = (*((lookahead_set->b.vtable)->count))(lookahead_set);
#line 448
  src_count = (int )tmp;
  }
#line 450
  return (src_count);
}
}
#line 461 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static int count_rr_conflicts(state *s , _Bool one_per_token ) 
{ 
  int i ;
  reductions *reds ;
  int rrc_count ;
  int count ;
  int j ;
  _Bool tmp ;
  int tmp___0 ;

  {
#line 465
  reds = s->reductions;
#line 466
  rrc_count = 0;
#line 468
  i = 0;
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    if (! (i < ntokens)) {
#line 468
      goto while_break;
    }
#line 470
    count = 0;
#line 472
    j = 0;
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! (j < reds->num)) {
#line 472
        goto while_break___0;
      }
      {
#line 473
      tmp = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
      }
#line 473
      if (tmp) {
#line 474
        count ++;
      }
#line 472
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 476
    if (count >= 2) {
#line 477
      if (one_per_token) {
#line 477
        tmp___0 = 1;
      } else {
#line 477
        tmp___0 = count - 1;
      }
#line 477
      rrc_count += tmp___0;
    }
#line 468
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  return (rrc_count);
}
}
#line 488 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
static void conflict_report(FILE *out , int src_num , int rrc_num ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 491
  if (src_num) {
#line 491
    if (rrc_num) {
      {
#line 492
      tmp = gettext("conflicts: %d shift/reduce, %d reduce/reduce\n");
#line 492
      rpl_fprintf(out, (char const   *)tmp, src_num, rrc_num);
      }
    } else {
#line 491
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 494
  if (src_num) {
    {
#line 495
    tmp___0 = gettext("conflicts: %d shift/reduce\n");
#line 495
    rpl_fprintf(out, (char const   *)tmp___0, src_num);
    }
  } else
#line 496
  if (rrc_num) {
    {
#line 497
    tmp___1 = gettext("conflicts: %d reduce/reduce\n");
#line 497
    rpl_fprintf(out, (char const   *)tmp___1, rrc_num);
    }
  }
#line 498
  return;
}
}
#line 505 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
void conflicts_output(FILE *out ) 
{ 
  _Bool printed_sth ;
  state_number i ;
  state *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 508
  printed_sth = (_Bool)0;
#line 510
  i = 0;
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! (i < nstates)) {
#line 510
      goto while_break;
    }
#line 512
    s = *(states + i);
#line 513
    if (*(conflicts + i)) {
      {
#line 515
      tmp = gettext("State %d ");
#line 515
      rpl_fprintf(out, (char const   *)tmp, i);
#line 516
      tmp___0 = count_rr_conflicts(s, (_Bool)1);
#line 516
      tmp___1 = count_sr_conflicts(s);
#line 516
      conflict_report(out, tmp___1, tmp___0);
#line 518
      printed_sth = (_Bool)1;
      }
    }
#line 510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  if (printed_sth) {
    {
#line 522
    fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
    }
  }
#line 523
  return;
}
}
#line 532 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
int conflicts_total_count(void) 
{ 
  state_number i ;
  int count ;
  int tmp ;
  int tmp___0 ;

  {
#line 539
  count = 0;
#line 540
  i = 0;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    if (! (i < nstates)) {
#line 540
      goto while_break;
    }
#line 541
    if (*(conflicts + i)) {
      {
#line 543
      tmp = count_sr_conflicts(*(states + i));
#line 543
      count += tmp;
#line 544
      tmp___0 = count_rr_conflicts(*(states + i), (_Bool)0);
#line 544
      count += tmp___0;
      }
    }
#line 540
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 546
  return (count);
}
}
#line 554 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
void conflicts_print(void) 
{ 
  _Bool src_ok ;
  _Bool rrc_ok ;
  int src_total ;
  int rrc_total ;
  int src_expected ;
  int rrc_expected ;
  state_number i ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 563
  src_total = 0;
#line 564
  rrc_total = 0;
#line 572
  i = 0;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    if (! (i < nstates)) {
#line 572
      goto while_break;
    }
#line 573
    if (*(conflicts + i)) {
      {
#line 575
      tmp = count_sr_conflicts(*(states + i));
#line 575
      src_total += tmp;
#line 576
      tmp___0 = count_rr_conflicts(*(states + i), (_Bool)1);
#line 576
      rrc_total += tmp___0;
      }
    }
#line 572
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  if (! glr_parser) {
#line 580
    if (rrc_total > 0) {
#line 580
      if (expected_rr_conflicts != -1) {
        {
#line 582
        tmp___1 = gettext("%%expect-rr applies only to GLR parsers");
#line 582
        warn((char const   *)tmp___1);
#line 583
        expected_rr_conflicts = -1;
        }
      }
    }
  }
#line 586
  if (expected_sr_conflicts == -1) {
#line 586
    src_expected = 0;
  } else {
#line 586
    src_expected = expected_sr_conflicts;
  }
#line 587
  if (expected_rr_conflicts == -1) {
#line 587
    rrc_expected = 0;
  } else {
#line 587
    rrc_expected = expected_rr_conflicts;
  }
#line 588
  src_ok = (_Bool )(src_total == src_expected);
#line 589
  rrc_ok = (_Bool )(rrc_total == rrc_expected);
#line 593
  if ((int )rrc_ok & (int )src_ok) {
#line 594
    return;
  }
#line 597
  if (expected_sr_conflicts == -1) {
#line 597
    if (expected_rr_conflicts == -1) {
#line 599
      if (! (warnings_flag & 8)) {
#line 600
        src_total = 0;
      }
#line 601
      if (! (warnings_flag & 16)) {
#line 602
        rrc_total = 0;
      }
    }
  }
#line 604
  if (src_total | rrc_total) {
#line 606
    if (expected_sr_conflicts == -1) {
#line 606
      if (expected_rr_conflicts == -1) {
        {
#line 607
        set_warning_issued();
        }
      }
    }
#line 608
    if (! yacc_flag) {
      {
#line 609
      rpl_fprintf(stderr, "%s: ", current_file);
      }
    }
    {
#line 610
    conflict_report(stderr, src_total, rrc_total);
    }
  }
#line 613
  if (expected_sr_conflicts != -1) {
#line 613
    goto _L;
  } else
#line 613
  if (expected_rr_conflicts != -1) {
    _L: /* CIL Label */ 
#line 615
    if (! src_ok) {
      {
#line 616
      tmp___2 = ngettext("expected %d shift/reduce conflict", "expected %d shift/reduce conflicts",
                         (unsigned long )src_expected);
#line 616
      complain((char const   *)tmp___2, src_expected);
      }
    }
#line 620
    if (! rrc_ok) {
      {
#line 621
      tmp___3 = ngettext("expected %d reduce/reduce conflict", "expected %d reduce/reduce conflicts",
                         (unsigned long )rrc_expected);
#line 621
      complain((char const   *)tmp___3, rrc_expected);
      }
    }
  }
#line 626
  return;
}
}
#line 629 "/home/pronto/abs/test-suite/bison-2.5/src/conflicts.c"
void conflicts_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___0 ;

  {
  {
#line 632
  free((void *)conflicts);
#line 633
  bitset_free(shift_set);
#line 634
  bitset_free(lookahead_set);
#line 635
  __o = & solved_conflicts_obstack;
#line 635
  __obj = (void *)0;
  }
#line 635
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 635
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 635
      tmp = (char *)__obj;
#line 635
      __o->object_base = tmp;
#line 635
      __o->next_free = tmp;
    } else {
      {
#line 635
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 635
    obstack_free(__o, __obj);
    }
  }
#line 636
  __o___0 = & solved_conflicts_xml_obstack;
#line 636
  __obj___0 = (void *)0;
#line 636
  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
#line 636
    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 636
      tmp___0 = (char *)__obj___0;
#line 636
      __o___0->object_base = tmp___0;
#line 636
      __o___0->next_free = tmp___0;
    } else {
      {
#line 636
      obstack_free(__o___0, __obj___0);
      }
    }
  } else {
    {
#line 636
    obstack_free(__o___0, __obj___0);
    }
  }
#line 637
  return;
}
}
#line 87 "/home/pronto/abs/test-suite/bison-2.5/src/complain.h"
_Bool complaint_issued  ;
#line 32 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
static unsigned int *indent_ptr  =    (unsigned int *)0;
#line 47 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
static void error_message(location *loc___0 , char const   *prefix , char const   *message ,
                          va_list args ) 
{ 
  unsigned int pos___0 ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t l ;
  size_t tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 53
  pos___0 = 0U;
#line 55
  if (loc___0) {
    {
#line 56
    tmp = location_print(stderr, *loc___0);
#line 56
    pos___0 += tmp;
    }
  } else {
#line 58
    if (current_file) {
#line 58
      tmp___0 = current_file;
    } else {
#line 58
      tmp___0 = (char const   *)program_name;
    }
    {
#line 58
    tmp___1 = rpl_fprintf(stderr, "%s", tmp___0);
#line 58
    pos___0 += (unsigned int )tmp___1;
    }
  }
  {
#line 59
  tmp___2 = rpl_fprintf(stderr, ": ");
#line 59
  pos___0 += (unsigned int )tmp___2;
  }
#line 61
  if (indent_ptr) {
#line 63
    if (! *indent_ptr) {
#line 64
      *indent_ptr = pos___0;
    } else
#line 65
    if (*indent_ptr > pos___0) {
      {
#line 66
      rpl_fprintf(stderr, "%*s", *indent_ptr - pos___0, "");
      }
    }
#line 67
    indent_ptr = (unsigned int *)0;
  }
#line 70
  if (prefix) {
    {
#line 71
    rpl_fprintf(stderr, "%s: ", prefix);
    }
  }
  {
#line 73
  rpl_vfprintf(stderr, message, args);
#line 75
  tmp___3 = strlen(message);
#line 75
  l = tmp___3;
  }
#line 76
  if (l < 2U) {
    {
#line 77
    putc_unlocked('\n', stderr);
#line 78
    fflush_unlocked(stderr);
    }
  } else
#line 76
  if ((int const   )*(message + (l - 2U)) != 58) {
    {
#line 77
    putc_unlocked('\n', stderr);
#line 78
    fflush_unlocked(stderr);
    }
  } else
#line 76
  if ((int const   )*(message + (l - 1U)) != 32) {
    {
#line 77
    putc_unlocked('\n', stderr);
#line 78
    fflush_unlocked(stderr);
    }
  }
#line 81
  return;
}
}
#line 100 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
static _Bool warning_issued  =    (_Bool)0;
#line 97 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void set_warning_issued(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 101
  if (! warning_issued) {
#line 101
    if (warnings_flag & 1) {
      {
#line 103
      rpl_fprintf(stderr, "%s: warnings being treated as errors\n", program_name);
#line 104
      complaint_issued = (_Bool)1;
      }
    }
  }
#line 106
  warning_issued = (_Bool)1;
#line 107
  return;
}
}
#line 109 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  warn_at)(location loc___0 , char const   *message 
                                        , ...) 
{ 
  va_list args ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
#line 112
  if (! (warnings_flag & 32)) {
#line 113
    return;
  }
  {
#line 114
  set_warning_issued();
#line 115
  __builtin_va_start(args, message);
#line 115
  tmp = gettext("warning");
#line 115
  error_message(& loc___0, (char const   *)tmp, message, args);
#line 115
  __builtin_va_end(args);
  }
#line 116
  return;
}
}
#line 118 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  warn_at_indent)(location loc___0 , unsigned int *indent ,
                                               char const   *message  , ...) 
{ 
  va_list args ;
  char *tmp ;
  char *__cil_tmp6 ;

  {
#line 122
  if (! (warnings_flag & 32)) {
#line 123
    return;
  }
  {
#line 124
  set_warning_issued();
#line 125
  indent_ptr = indent;
#line 126
  __builtin_va_start(args, message);
#line 126
  tmp = gettext("warning");
#line 126
  error_message(& loc___0, (char const   *)tmp, message, args);
#line 126
  __builtin_va_end(args);
  }
#line 127
  return;
}
}
#line 129 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  warn)(char const   *message  , ...) 
{ 
  va_list args ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 132
  if (! (warnings_flag & 32)) {
#line 133
    return;
  }
  {
#line 134
  set_warning_issued();
#line 135
  __builtin_va_start(args, message);
#line 135
  tmp = gettext("warning");
#line 135
  error_message((location *)((void *)0), (char const   *)tmp, message, args);
#line 135
  __builtin_va_end(args);
  }
#line 136
  return;
}
}
#line 143 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  complain_at)(location loc___0 , char const   *message 
                                            , ...) 
{ 
  va_list args ;

  {
  {
#line 146
  __builtin_va_start(args, message);
#line 146
  error_message(& loc___0, (char const   *)((void *)0), message, args);
#line 146
  __builtin_va_end(args);
#line 147
  complaint_issued = (_Bool)1;
  }
#line 148
  return;
}
}
#line 150 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  complain_at_indent)(location loc___0 , unsigned int *indent ,
                                                   char const   *message  , ...) 
{ 
  va_list args ;

  {
  {
#line 154
  indent_ptr = indent;
#line 155
  __builtin_va_start(args, message);
#line 155
  error_message(& loc___0, (char const   *)((void *)0), message, args);
#line 155
  __builtin_va_end(args);
#line 156
  complaint_issued = (_Bool)1;
  }
#line 157
  return;
}
}
#line 159 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  complain)(char const   *message  , ...) 
{ 
  va_list args ;

  {
  {
#line 162
  __builtin_va_start(args, message);
#line 162
  error_message((location *)((void *)0), (char const   *)((void *)0), message, args);
#line 162
  __builtin_va_end(args);
#line 163
  complaint_issued = (_Bool)1;
  }
#line 164
  return;
}
}
#line 172 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  yacc_at)(location loc___0 , char const   *message 
                                        , ...) 
{ 
  va_list args ;
  va_list args___0 ;
  char *tmp ;
  char *__cil_tmp6 ;

  {
#line 175
  if (yacc_flag) {
    {
#line 177
    __builtin_va_start(args, message);
#line 177
    error_message(& loc___0, (char const   *)((void *)0), message, args);
#line 177
    __builtin_va_end(args);
#line 178
    complaint_issued = (_Bool)1;
    }
  } else
#line 180
  if (warnings_flag & 4) {
    {
#line 182
    set_warning_issued();
#line 183
    __builtin_va_start(args___0, message);
#line 183
    tmp = gettext("warning");
#line 183
    error_message(& loc___0, (char const   *)tmp, message, args___0);
#line 183
    __builtin_va_end(args___0);
    }
  }
#line 185
  return;
}
}
#line 187 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  midrule_value_at)(location loc___0 , char const   *message 
                                                 , ...) 
{ 
  va_list args ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
#line 190
  if (! (warnings_flag & 2)) {
#line 191
    return;
  }
  {
#line 192
  set_warning_issued();
#line 193
  __builtin_va_start(args, message);
#line 193
  tmp = gettext("warning");
#line 193
  error_message(& loc___0, (char const   *)tmp, message, args);
#line 193
  __builtin_va_end(args);
  }
#line 194
  return;
}
}
#line 200
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal_at)(location loc___0 ,
                                                                        char const   *message 
                                                                        , ...) ;
#line 200 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  fatal_at)(location loc___0 , char const   *message 
                                         , ...) 
{ 
  va_list args ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 203
  __builtin_va_start(args, message);
#line 203
  tmp = gettext("fatal error");
#line 203
  error_message(& loc___0, (char const   *)tmp, message, args);
#line 203
  __builtin_va_end(args);
#line 204
  exit(1);
  }
}
}
#line 207
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *message 
                                                                     , ...) ;
#line 207 "/home/pronto/abs/test-suite/bison-2.5/src/complain.c"
void ( /* format attribute */  fatal)(char const   *message  , ...) 
{ 
  va_list args ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 210
  __builtin_va_start(args, message);
#line 210
  tmp = gettext("fatal error");
#line 210
  error_message((location *)((void *)0), (char const   *)tmp, message, args);
#line 210
  __builtin_va_end(args);
#line 211
  exit(1);
  }
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 54 "/home/pronto/abs/test-suite/bison-2.5/src/closure.h"
item_number *itemset  ;
#line 55 "/home/pronto/abs/test-suite/bison-2.5/src/closure.h"
size_t nitemset  ;
#line 40 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
static bitset ruleset  ;
#line 43 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
static bitsetv fderives  =    (bitsetv )((void *)0);
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
static bitsetv firsts  =    (bitsetv )((void *)0);
#line 55 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
static void print_closure(char const   *title , item_number *array , size_t size ) 
{ 
  size_t i ;
  item_number *rp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 59
  rpl_fprintf(stderr, "Closure: %s\n", title);
#line 60
  i = (size_t )0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < size)) {
#line 60
      goto while_break;
    }
    {
#line 63
    rpl_fprintf(stderr, "  %2d: .", *(array + i));
#line 64
    rp = ritem + *(array + i);
    }
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 64
      if (! (*rp >= 0)) {
#line 64
        goto while_break___0;
      }
      {
#line 65
      rpl_fprintf(stderr, " %s", (*(symbols + *rp))->tag);
#line 64
      rp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 66
    rpl_fprintf(stderr, "  (rule %d)\n", - *rp - 1);
#line 60
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)stderr);
  }
#line 69
  return;
}
}
#line 72 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
static void print_firsts(void) 
{ 
  symbol_number i ;
  symbol_number j ;
  bitset_iterator iter ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 77
  rpl_fprintf(stderr, "FIRSTS\n");
#line 78
  i = ntokens;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < nsyms)) {
#line 78
      goto while_break;
    }
    {
#line 81
    rpl_fprintf(stderr, "\t%s firsts\n", (*(symbols + i))->tag);
#line 82
    iter.next = (bitset_bindex )0;
#line 82
    iter.num = (bitset_bindex )1024;
    }
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      if (iter.num == 1024U) {
        {
#line 82
        iter.num = (*(((*(firsts + (i - ntokens)))->b.vtable)->list))(*(firsts + (i - ntokens)),
                                                                      iter.list, (bitset_bindex )1024,
                                                                      & iter.next);
        }
#line 82
        if (! iter.num) {
#line 82
          goto while_break___0;
        }
      } else {
#line 82
        goto while_break___0;
      }
#line 82
      iter.i = (bitset_bindex )0;
      {
#line 82
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 82
        if (iter.i < iter.num) {
#line 82
          j = (symbol_number )iter.list[iter.i];
        } else {
#line 82
          goto while_break___1;
        }
        {
#line 84
        rpl_fprintf(stderr, "\t\t%s\n", (*(symbols + (j + ntokens)))->tag);
#line 82
        (iter.i) ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  rpl_fprintf(stderr, "\n\n");
  }
#line 89
  return;
}
}
#line 92 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
static void print_fderives(void) 
{ 
  int i ;
  rule_number r ;
  bitset_iterator iter ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 98
  rpl_fprintf(stderr, "FDERIVES\n");
#line 99
  i = ntokens;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < nsyms)) {
#line 99
      goto while_break;
    }
    {
#line 102
    rpl_fprintf(stderr, "\t%s derives\n", (*(symbols + i))->tag);
#line 103
    iter.next = (bitset_bindex )0;
#line 103
    iter.num = (bitset_bindex )1024;
    }
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (iter.num == 1024U) {
        {
#line 103
        iter.num = (*(((*(fderives + (i - ntokens)))->b.vtable)->list))(*(fderives + (i - ntokens)),
                                                                        iter.list,
                                                                        (bitset_bindex )1024,
                                                                        & iter.next);
        }
#line 103
        if (! iter.num) {
#line 103
          goto while_break___0;
        }
      } else {
#line 103
        goto while_break___0;
      }
#line 103
      iter.i = (bitset_bindex )0;
      {
#line 103
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 103
        if (iter.i < iter.num) {
#line 103
          r = (rule_number )iter.list[iter.i];
        } else {
#line 103
          goto while_break___1;
        }
        {
#line 105
        rpl_fprintf(stderr, "\t\t%3d ", r);
#line 106
        rule_rhs_print(rules + r, stderr);
#line 103
        (iter.i) ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  rpl_fprintf(stderr, "\n\n");
  }
#line 110
  return;
}
}
#line 123 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
static void set_firsts(void) 
{ 
  symbol_number i ;
  symbol_number j ;
  item_number sym ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 128
  firsts = bitsetv_create((bitset_bindex )nvars, (bitset_bindex )nvars, 1U);
#line 130
  i = ntokens;
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (i < nsyms)) {
#line 130
      goto while_break;
    }
#line 131
    j = 0;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (! *(*(derives + (i - ntokens)) + j)) {
#line 131
        goto while_break___0;
      }
#line 133
      sym = *((*(*(derives + (i - ntokens)) + j))->rhs + 0);
#line 134
      if (sym >= ntokens) {
        {
#line 135
        bitset_set(*(firsts + (i - ntokens)), (bitset_bindex )(sym - ntokens));
        }
      }
#line 131
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 130
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if (trace_flag & 8) {
    {
#line 139
    bitsetv_matrix_dump(stderr, "RTC: Firsts Input", firsts);
    }
  }
  {
#line 140
  bitsetv_reflexive_transitive_closure(firsts);
  }
#line 141
  if (trace_flag & 8) {
    {
#line 142
    bitsetv_matrix_dump(stderr, "RTC: Firsts Output", firsts);
    }
  }
#line 144
  if (trace_flag & 8) {
    {
#line 145
    print_firsts();
    }
  }
#line 146
  return;
}
}
#line 158 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
static void set_fderives(void) 
{ 
  symbol_number i ;
  symbol_number j ;
  rule_number k ;
  _Bool tmp ;

  {
  {
#line 164
  fderives = bitsetv_create((bitset_bindex )nvars, (bitset_bindex )nrules, 1U);
#line 166
  set_firsts();
#line 168
  i = ntokens;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < nsyms)) {
#line 168
      goto while_break;
    }
#line 169
    j = ntokens;
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      if (! (j < nsyms)) {
#line 169
        goto while_break___0;
      }
      {
#line 170
      tmp = bitset_test(*(firsts + (i - ntokens)), (bitset_bindex )(j - ntokens));
      }
#line 170
      if (tmp) {
#line 171
        k = 0;
        {
#line 171
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 171
          if (! *(*(derives + (j - ntokens)) + k)) {
#line 171
            goto while_break___1;
          }
          {
#line 172
          bitset_set(*(fderives + (i - ntokens)), (bitset_bindex )(*(*(derives + (j - ntokens)) + k))->number);
#line 171
          k ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 169
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  if (trace_flag & 8) {
    {
#line 175
    print_fderives();
    }
  }
  {
#line 177
  bitsetv_free(firsts);
  }
#line 178
  return;
}
}
#line 182 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
void new_closure(unsigned int n ) 
{ 
  void *tmp ;

  {
  {
#line 185
  tmp = xnmalloc(n, (size_t )sizeof(*itemset));
#line 185
  itemset = (item_number *)tmp;
#line 187
  ruleset = bitset_create((bitset_bindex )nrules, (bitset_attrs )1);
#line 189
  set_fderives();
  }
#line 190
  return;
}
}
#line 194 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
void closure(item_number *core , size_t n ) 
{ 
  size_t c ;
  rule_number ruleno ;
  bitset_iterator iter ;
  item_number itemno ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 205
  if (trace_flag & 8) {
    {
#line 206
    print_closure("input", core, n);
    }
  }
  {
#line 208
  (*((ruleset->b.vtable)->zero))(ruleset);
#line 210
  c = (size_t )0;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (c < n)) {
#line 210
      goto while_break;
    }
#line 211
    if (*(ritem + *(core + c)) >= ntokens) {
      {
#line 212
      (*((ruleset->b.vtable)->or_))(ruleset, ruleset, *(fderives + (*(ritem + *(core + c)) - ntokens)));
      }
    }
#line 210
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  nitemset = (size_t )0;
#line 217
  c = (size_t )0;
#line 218
  iter.next = (bitset_bindex )0;
#line 218
  iter.num = (bitset_bindex )1024;
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 218
    if (iter.num == 1024U) {
      {
#line 218
      iter.num = (*((ruleset->b.vtable)->list))(ruleset, iter.list, (bitset_bindex )1024,
                                                & iter.next);
      }
#line 218
      if (! iter.num) {
#line 218
        goto while_break___0;
      }
    } else {
#line 218
      goto while_break___0;
    }
#line 218
    iter.i = (bitset_bindex )0;
    {
#line 218
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 218
      if (iter.i < iter.num) {
#line 218
        ruleno = (rule_number )iter.list[iter.i];
      } else {
#line 218
        goto while_break___1;
      }
#line 220
      itemno = (item_number )((rules + ruleno)->rhs - ritem);
      {
#line 221
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 221
        if (c < n) {
#line 221
          if (! (*(core + c) < itemno)) {
#line 221
            goto while_break___2;
          }
        } else {
#line 221
          goto while_break___2;
        }
#line 223
        *(itemset + nitemset) = *(core + c);
#line 224
        nitemset ++;
#line 225
        c ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 227
      *(itemset + nitemset) = itemno;
#line 228
      nitemset ++;
#line 218
      (iter.i) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 231
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 231
    if (! (c < n)) {
#line 231
      goto while_break___3;
    }
#line 233
    *(itemset + nitemset) = *(core + c);
#line 234
    nitemset ++;
#line 235
    c ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 238
  if (trace_flag & 8) {
    {
#line 239
    print_closure("output", itemset, nitemset);
    }
  }
#line 240
  return;
}
}
#line 243 "/home/pronto/abs/test-suite/bison-2.5/src/closure.c"
void free_closure(void) 
{ 


  {
  {
#line 246
  free((void *)itemset);
#line 247
  bitset_free(ruleset);
#line 248
  bitsetv_free(fderives);
  }
#line 249
  return;
}
}
#line 27 "/home/pronto/abs/test-suite/bison-2.5/src/assoc.c"
char const   *assoc_to_string(assoc a ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 35
  if ((unsigned int )a == 0U) {
#line 35
    goto case_0;
  }
#line 38
  if ((unsigned int )a == 1U) {
#line 38
    goto case_1;
  }
#line 41
  if ((unsigned int )a == 2U) {
#line 41
    goto case_2;
  }
#line 44
  if ((unsigned int )a == 3U) {
#line 44
    goto case_3;
  }
#line 32
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 33
  abort();
  }
  case_0: /* CIL Label */ 
#line 36
  return ("undefined associativity");
  case_1: /* CIL Label */ 
#line 39
  return ("%right");
  case_2: /* CIL Label */ 
#line 42
  return ("%left");
  case_3: /* CIL Label */ 
#line 45
  return ("%nonassoc");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 37 "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.h"
Sbitset Sbitset__new(Sbitset__Index nbits ) ;
#line 38
Sbitset Sbitset__new_on_obstack(Sbitset__Index nbits , struct obstack *obstackp ) ;
#line 40
void Sbitset__delete(Sbitset self ) ;
#line 45
_Bool Sbitset__isEmpty(Sbitset self , Sbitset__Index nbits ) ;
#line 47
void Sbitset__fprint(Sbitset self , Sbitset__Index nbits , FILE *file ) ;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.c"
Sbitset Sbitset__new(Sbitset__Index nbits ) 
{ 
  void *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 29
  if (! nbits) {
    {
#line 29
    __assert_fail("nbits", "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.c",
                  29U, "Sbitset__new");
    }
  }
  {
#line 30
  tmp = xcalloc((size_t )1, ((nbits + 8U) - 1U) / 8U);
  }
#line 30
  return ((Sbitset )tmp);
}
}
#line 33 "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.c"
Sbitset Sbitset__new_on_obstack(Sbitset__Index nbits , struct obstack *obstackp ) 
{ 
  Sbitset result ;
  Sbitset ptr ;
  Sbitset end ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 39
  if (! nbits) {
    {
#line 39
    __assert_fail("nbits", "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.c",
                  39U, "Sbitset__new_on_obstack");
    }
  }
#line 40
  __h = obstackp;
#line 40
  __o = __h;
#line 40
  __len = (int )(((nbits + 8U) - 1U) / 8U);
#line 40
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 40
    _obstack_newchunk(__o, __len);
    }
  }
#line 40
  __o->next_free += __len;
#line 40
  __o1 = __h;
#line 40
  __value = (void *)__o1->object_base;
#line 40
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 40
    __o1->maybe_empty_object = 1U;
  }
#line 40
  if (sizeof(int ) < sizeof(void *)) {
#line 40
    tmp = __o1->object_base;
  } else {
#line 40
    tmp = (char *)0;
  }
#line 40
  if (sizeof(int ) < sizeof(void *)) {
#line 40
    tmp___0 = __o1->object_base;
  } else {
#line 40
    tmp___0 = (char *)0;
  }
#line 40
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 40
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 40
    __o1->next_free = __o1->chunk_limit;
  }
#line 40
  __o1->object_base = __o1->next_free;
#line 40
  result = (Sbitset )__value;
#line 41
  ptr = result;
#line 41
  end = result + ((nbits + 8U) - 1U) / 8U;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 41
      goto while_break;
    }
#line 42
    *ptr = (unsigned char)0;
#line 41
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (result);
}
}
#line 46 "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.c"
void Sbitset__delete(Sbitset self ) 
{ 


  {
  {
#line 49
  free((void *)self);
  }
#line 50
  return;
}
}
#line 52 "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.c"
_Bool Sbitset__isEmpty(Sbitset self , Sbitset__Index nbits ) 
{ 
  Sbitset last ;

  {
#line 55
  last = (self + ((nbits + 8U) - 1U) / 8U) - 1;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )self < (unsigned long )last)) {
#line 56
      goto while_break;
    }
#line 57
    if ((int )*self != 0) {
#line 58
      return ((_Bool)0);
    }
#line 56
    self ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return ((_Bool )(((int )*last & (255 << (7U - (nbits - 1U) % 8U))) == 0));
}
}
#line 62 "/home/pronto/abs/test-suite/bison-2.5/src/Sbitset.c"
void Sbitset__fprint(Sbitset self , Sbitset__Index nbits , FILE *file ) 
{ 
  Sbitset__Index i ;
  Sbitset itr ;
  _Bool first ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 67
  first = (_Bool)1;
#line 68
  rpl_fprintf(file, "nbits = %zu, set = {", nbits);
#line 71
  itr = self;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((unsigned long )itr < (unsigned long )(self + ((nbits + 8U) - 1U) / 8U))) {
#line 71
      goto while_break;
    }
#line 71
    if ((int )*itr != 0) {
#line 71
      i = (Sbitset__Index )((itr - self) * 8L);
      {
#line 71
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 71
        if (i < nbits) {
#line 71
          if (! ((unsigned long )(self + i / 8U) < (unsigned long )(itr + 1))) {
#line 71
            goto while_break___0;
          }
        } else {
#line 71
          goto while_break___0;
        }
#line 71
        if (((int )*itr & (1 << (7U - i % 8U))) != 0) {
#line 73
          if (first) {
#line 74
            first = (_Bool)0;
          } else {
            {
#line 76
            rpl_fprintf(file, ",");
            }
          }
          {
#line 77
          rpl_fprintf(file, " %zu", i);
          }
        }
#line 71
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 71
    itr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  rpl_fprintf(file, " }");
  }
#line 80
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 49 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static state_list___0 *first_state  =    (state_list___0 *)((void *)0);
#line 50 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static state_list___0 *last_state  =    (state_list___0 *)((void *)0);
#line 58 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static state *state_list_append(symbol_number sym , size_t core_size , item_number *core ) 
{ 
  state_list___0 *node ;
  void *tmp ;
  state *s ;
  state *tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 61
  tmp = xmalloc((size_t )sizeof(*node));
#line 61
  node = (state_list___0 *)tmp;
#line 62
  tmp___0 = state_new(sym, core_size, core);
#line 62
  s = tmp___0;
  }
#line 64
  if (trace_flag & 64) {
    {
#line 65
    rpl_fprintf(stderr, "state_list_append (state = %d, symbol = %d (%s))\n", nstates,
                sym, (*(symbols + sym))->tag);
    }
  }
#line 68
  node->next = (struct state_list___0 *)((void *)0);
#line 69
  node->state = s;
#line 71
  if (! first_state) {
#line 72
    first_state = node;
  }
#line 73
  if (last_state) {
#line 74
    last_state->next = node;
  }
#line 75
  last_state = node;
#line 77
  return (s);
}
}
#line 80 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static int nshifts  ;
#line 81 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static symbol_number *shift_symbol  ;
#line 83 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static rule **redset  ;
#line 84 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static state **shiftset  ;
#line 86 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static item_number **kernel_base  ;
#line 87 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static int *kernel_size  ;
#line 88 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static item_number *kernel_items  ;
#line 91 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static void allocate_itemsets(void) 
{ 
  symbol_number i ;
  rule_number r ;
  item_number *rhsp ;
  size_t count ;
  size_t *symbol_count ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 102
  count = (size_t )0;
#line 103
  tmp = xcalloc((size_t )(nsyms + nuseless_nonterminals), (size_t )sizeof(*symbol_count));
#line 103
  symbol_count = (size_t *)tmp;
#line 106
  r = 0;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (r < nrules)) {
#line 106
      goto while_break;
    }
#line 107
    rhsp = (rules + r)->rhs;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! (*rhsp >= 0)) {
#line 107
        goto while_break___0;
      }
#line 109
      count ++;
#line 110
      (*(symbol_count + *rhsp)) ++;
#line 107
      rhsp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 106
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp___0 = xnmalloc((size_t )nsyms, (size_t )sizeof(*kernel_base));
#line 119
  kernel_base = (item_number **)tmp___0;
#line 120
  tmp___1 = xnmalloc(count, (size_t )sizeof(*kernel_items));
#line 120
  kernel_items = (item_number *)tmp___1;
#line 122
  count = (size_t )0;
#line 123
  i = 0;
  }
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! (i < nsyms)) {
#line 123
      goto while_break___1;
    }
#line 125
    *(kernel_base + i) = kernel_items + count;
#line 126
    count += *(symbol_count + i);
#line 123
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 129
  free((void *)symbol_count);
#line 130
  tmp___2 = xnmalloc((size_t )nsyms, (size_t )sizeof(*kernel_size));
#line 130
  kernel_size = (int *)tmp___2;
  }
#line 131
  return;
}
}
#line 134 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static void allocate_storage(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 137
  allocate_itemsets();
#line 139
  tmp = xnmalloc((size_t )nsyms, (size_t )sizeof(*shiftset));
#line 139
  shiftset = (state **)tmp;
#line 140
  tmp___0 = xnmalloc((size_t )nrules, (size_t )sizeof(*redset));
#line 140
  redset = (rule **)tmp___0;
#line 141
  state_hash_new();
#line 142
  tmp___1 = xnmalloc((size_t )nsyms, (size_t )sizeof(*shift_symbol));
#line 142
  shift_symbol = (symbol_number *)tmp___1;
  }
#line 143
  return;
}
}
#line 146 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static void free_storage(void) 
{ 


  {
  {
#line 149
  free((void *)shift_symbol);
#line 150
  free((void *)redset);
#line 151
  free((void *)shiftset);
#line 152
  free((void *)kernel_base);
#line 153
  free((void *)kernel_size);
#line 154
  free((void *)kernel_items);
#line 155
  state_hash_free();
  }
#line 156
  return;
}
}
#line 176 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static void new_itemsets(state *s ) 
{ 
  size_t i ;
  symbol_number sym ;
  symbol_number tmp ;
  _Bool tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 181
  if (trace_flag & 64) {
    {
#line 182
    rpl_fprintf(stderr, "Entering new_itemsets, state = %d\n", s->number);
    }
  }
  {
#line 184
  memset((void *)kernel_size, 0, (size_t )((unsigned long )nsyms * sizeof(*kernel_size)));
#line 186
  nshifts = 0;
#line 188
  i = (size_t )0;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < nitemset)) {
#line 188
      goto while_break;
    }
    {
#line 189
    tmp___0 = item_number_is_symbol_number(*(ritem + *(itemset + i)));
    }
#line 189
    if (tmp___0) {
      {
#line 191
      tmp = item_number_as_symbol_number(*(ritem + *(itemset + i)));
#line 191
      sym = tmp;
      }
#line 192
      if (! *(kernel_size + sym)) {
#line 194
        *(shift_symbol + nshifts) = sym;
#line 195
        nshifts ++;
      }
#line 198
      *(*(kernel_base + sym) + *(kernel_size + sym)) = *(itemset + i) + 1;
#line 199
      (*(kernel_size + sym)) ++;
    }
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return;
}
}
#line 211 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static state *get_state(symbol_number sym , size_t core_size , item_number *core ) 
{ 
  state *s ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 216
  if (trace_flag & 64) {
    {
#line 217
    rpl_fprintf(stderr, "Entering get_state, symbol = %d (%s)\n", sym, (*(symbols + sym))->tag);
    }
  }
  {
#line 220
  s = state_hash_lookup(core_size, core);
  }
#line 221
  if (! s) {
    {
#line 222
    s = state_list_append(sym, core_size, core);
    }
  }
#line 224
  if (trace_flag & 64) {
    {
#line 225
    rpl_fprintf(stderr, "Exiting get_state => %d\n", s->number);
    }
  }
#line 227
  return (s);
}
}
#line 237 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static void append_states(state *s ) 
{ 
  int i ;
  symbol_number sym ;
  int j ;
  symbol_number sym___0 ;
  char *__cil_tmp6 ;

  {
#line 242
  if (trace_flag & 64) {
    {
#line 243
    rpl_fprintf(stderr, "Entering append_states, state = %d\n", s->number);
    }
  }
#line 247
  i = 1;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (i < nshifts)) {
#line 247
      goto while_break;
    }
#line 249
    sym = *(shift_symbol + i);
#line 251
    j = i;
    {
#line 251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 251
      if (0 < j) {
#line 251
        if (! (sym < *(shift_symbol + (j - 1)))) {
#line 251
          goto while_break___0;
        }
      } else {
#line 251
        goto while_break___0;
      }
#line 252
      *(shift_symbol + j) = *(shift_symbol + (j - 1));
#line 251
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 253
    *(shift_symbol + j) = sym;
#line 247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  i = 0;
  {
#line 256
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 256
    if (! (i < nshifts)) {
#line 256
      goto while_break___1;
    }
    {
#line 258
    sym___0 = *(shift_symbol + i);
#line 259
    *(shiftset + i) = get_state(sym___0, (size_t )*(kernel_size + sym___0), *(kernel_base + sym___0));
#line 256
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 261
  return;
}
}
#line 270 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static void save_reductions(state *s ) 
{ 
  int count ;
  size_t i ;
  item_number item ;
  rule_number r ;
  rule_number tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 273
  count = 0;
#line 277
  i = (size_t )0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i < nitemset)) {
#line 277
      goto while_break;
    }
    {
#line 279
    item = *(ritem + *(itemset + i));
#line 280
    tmp___1 = item_number_is_rule_number(item);
    }
#line 280
    if (tmp___1) {
      {
#line 282
      tmp = item_number_as_rule_number(item);
#line 282
      r = tmp;
#line 283
      tmp___0 = count;
#line 283
      count ++;
#line 283
      *(redset + tmp___0) = rules + r;
      }
#line 284
      if (r == 0) {
#line 287
        if (! (! final_state)) {
          {
#line 287
          __assert_fail("!final_state", "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c",
                        287U, "save_reductions");
          }
        }
#line 288
        final_state = s;
      }
    }
#line 277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  state_reductions_set(s, count, redset);
  }
#line 295
  return;
}
}
#line 302 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
static void set_states(void) 
{ 
  void *tmp ;
  state_list___0 *this ;
  state *s ;

  {
  {
#line 305
  tmp = xcalloc((size_t )nstates + 10, (size_t )sizeof(*states));
#line 305
  states = (state **)tmp;
  }
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! first_state) {
#line 307
      goto while_break;
    }
#line 309
    this = first_state;
#line 315
    s = this->state;
#line 316
    if (! s->transitions) {
      {
#line 317
      state_transitions_set(s, 0, (state **)0);
      }
    }
#line 318
    if (! s->reductions) {
      {
#line 319
      state_reductions_set(s, 0, (rule **)0);
      }
    }
    {
#line 321
    *(states + s->number) = s;
#line 323
    first_state = this->next;
#line 324
    free((void *)this);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  first_state = (state_list___0 *)((void *)0);
#line 327
  last_state = (state_list___0 *)((void *)0);
#line 328
  return;
}
}
#line 336 "/home/pronto/abs/test-suite/bison-2.5/src/LR0.c"
void generate_states(void) 
{ 
  item_number initial_core ;
  state_list___0 *list ;
  state *s ;
  char *__cil_tmp4 ;

  {
  {
#line 339
  initial_core = 0;
#line 340
  list = (state_list___0 *)((void *)0);
#line 341
  allocate_storage();
#line 342
  new_closure(nritems);
#line 346
  state_list_append(0, (size_t )1, & initial_core);
#line 349
  list = first_state;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! list) {
#line 349
      goto while_break;
    }
#line 351
    s = list->state;
#line 352
    if (trace_flag & 64) {
      {
#line 353
      rpl_fprintf(stderr, "Processing state %d (reached by %s)\n", s->number, (*(symbols + s->accessing_symbol))->tag);
      }
    }
    {
#line 358
    closure(s->items, s->nitems);
#line 360
    save_reductions(s);
#line 362
    new_itemsets(s);
#line 364
    append_states(s);
#line 368
    state_transitions_set(s, nshifts, shiftset);
#line 349
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  free_closure();
#line 373
  free_storage();
#line 376
  set_states();
  }
#line 377
  return;
}
}
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.h"
int const   ContributionIndex__error_action ;
#line 113
InadequacyList *InadequacyList__new_conflict(state *manifesting_state , symbol *token ,
                                             bitset actions___0 , InadequacyListNodeCount *node_count ) ;
#line 132
ContributionIndex InadequacyList__getShiftContributionIndex(InadequacyList const   *self ) ;
#line 143
symbol *InadequacyList__getContributionToken(InadequacyList const   *self , ContributionIndex i ) ;
#line 154
void InadequacyList__prependTo(InadequacyList *self , InadequacyList **list ) ;
#line 25 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c"
int const   ContributionIndex__none  =    (ContributionIndex const   )-1;
#line 26 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c"
int const   ContributionIndex__error_action  =    (ContributionIndex const   )-2;
#line 28 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c"
InadequacyList *InadequacyList__new_conflict(state *manifesting_state , symbol *token ,
                                             bitset actions___0 , InadequacyListNodeCount *node_count ) 
{ 
  InadequacyList *result ;
  void *tmp ;
  InadequacyListNodeCount tmp___0 ;
  bitset_bindex tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 33
  tmp = xmalloc((size_t )sizeof(*result));
#line 33
  result = (InadequacyList *)tmp;
#line 34
  tmp___0 = *node_count;
#line 34
  (*node_count) ++;
#line 34
  result->id = tmp___0;
  }
#line 35
  if (! (*node_count != 0ULL)) {
    {
#line 35
    __assert_fail("*node_count != 0", "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c",
                  35U, "InadequacyList__new_conflict");
    }
  }
  {
#line 36
  result->next = (struct InadequacyList *)((void *)0);
#line 37
  result->manifestingState = manifesting_state;
#line 38
  tmp___1 = (*((actions___0->b.vtable)->count))(actions___0);
#line 38
  result->contributionCount = (ContributionIndex )tmp___1;
#line 39
  result->inadequacy.conflict.token = token;
#line 40
  result->inadequacy.conflict.actions = actions___0;
  }
#line 41
  return (result);
}
}
#line 44 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c"
void InadequacyList__delete(InadequacyList *self ) 
{ 
  InadequacyList *node ;

  {
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! self) {
#line 47
      goto while_break;
    }
    {
#line 49
    node = self;
#line 50
    self = self->next;
#line 51
    bitset_free(node->inadequacy.conflict.actions);
#line 52
    free((void *)node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return;
}
}
#line 56 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c"
ContributionIndex InadequacyList__getShiftContributionIndex(InadequacyList const   *self ) 
{ 
  _Bool tmp ;

  {
  {
#line 59
  tmp = bitset_test((bitset )self->inadequacy.conflict.actions, (bitset_bindex )((self->manifestingState)->reductions)->num);
  }
#line 59
  if (! tmp) {
#line 61
    return ((ContributionIndex )ContributionIndex__none);
  }
#line 62
  return ((ContributionIndex )(self->contributionCount - 1));
}
}
#line 65 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c"
symbol *InadequacyList__getContributionToken(InadequacyList const   *self , ContributionIndex i ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 69
  if (0 <= i) {
#line 69
    if (! (i < (ContributionIndex )self->contributionCount)) {
      {
#line 69
      __assert_fail("0 <= i && i < self->contributionCount", "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c",
                    69U, "InadequacyList__getContributionToken");
      }
    }
  } else {
    {
#line 69
    __assert_fail("0 <= i && i < self->contributionCount", "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c",
                  69U, "InadequacyList__getContributionToken");
    }
  }
#line 70
  return ((symbol *)self->inadequacy.conflict.token);
}
}
#line 73 "/home/pronto/abs/test-suite/bison-2.5/src/InadequacyList.c"
void InadequacyList__prependTo(InadequacyList *self , InadequacyList **list ) 
{ 
  InadequacyList *head_old ;

  {
#line 76
  head_old = *list;
#line 77
  *list = self;
#line 78
  self->next = head_old;
#line 79
  return;
}
}
#line 127 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 37 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
static AnnotationList *AnnotationList__alloc_on_obstack(ContributionIndex contribution_count ,
                                                        struct obstack *annotations_obstackp ) 
{ 
  AnnotationList *result ;
  size_t contributions_size ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 42
  contributions_size = (size_t )((unsigned long )contribution_count * sizeof(result->contributions[0]));
#line 44
  __h = annotations_obstackp;
#line 44
  __o = __h;
#line 44
  __len = (int )((unsigned long )(& ((AnnotationList *)0)->contributions) + (unsigned long )contributions_size);
#line 44
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 44
    _obstack_newchunk(__o, __len);
    }
  }
#line 44
  __o->next_free += __len;
#line 44
  __o1 = __h;
#line 44
  __value = (void *)__o1->object_base;
#line 44
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 44
    __o1->maybe_empty_object = 1U;
  }
#line 44
  if (sizeof(int ) < sizeof(void *)) {
#line 44
    tmp = __o1->object_base;
  } else {
#line 44
    tmp = (char *)0;
  }
#line 44
  if (sizeof(int ) < sizeof(void *)) {
#line 44
    tmp___0 = __o1->object_base;
  } else {
#line 44
    tmp___0 = (char *)0;
  }
#line 44
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 44
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 44
    __o1->next_free = __o1->chunk_limit;
  }
#line 44
  __o1->object_base = __o1->next_free;
#line 44
  result = (AnnotationList *)__value;
#line 47
  result->next = (struct AnnotationList *)((void *)0);
#line 48
  result->inadequacyNode = (InadequacyList *)((void *)0);
#line 49
  return (result);
}
}
#line 60 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
static _Bool AnnotationList__isContributionAlways(AnnotationList const   *self , ContributionIndex ci ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 64
  if (0 <= ci) {
#line 64
    if (! (ci < (self->inadequacyNode)->contributionCount)) {
      {
#line 64
      __assert_fail("0 <= ci && ci < self->inadequacyNode->contributionCount", "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                    64U, "AnnotationList__isContributionAlways");
      }
    }
  } else {
    {
#line 64
    __assert_fail("0 <= ci && ci < self->inadequacyNode->contributionCount", "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                  64U, "AnnotationList__isContributionAlways");
    }
  }
#line 65
  return ((_Bool )((unsigned long )self->contributions[ci] == (unsigned long )((void *)0)));
}
}
#line 97 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
static _Bool AnnotationList__insertInto(AnnotationList *self , AnnotationList **list ,
                                        size_t nitems ) 
{ 
  AnnotationList **node ;
  int cmp ;
  ContributionIndex ci ;
  _Bool tmp ;
  size_t item ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 102
  node = list;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! *node) {
#line 102
      goto while_break;
    }
#line 104
    cmp = 0;
#line 106
    if ((self->inadequacyNode)->id < ((*node)->inadequacyNode)->id) {
#line 107
      cmp = 1;
    } else
#line 108
    if (((*node)->inadequacyNode)->id < (self->inadequacyNode)->id) {
#line 109
      cmp = -1;
    } else {
#line 111
      ci = 0;
      {
#line 111
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 111
        if (cmp == 0) {
#line 111
          if (! (ci < (self->inadequacyNode)->contributionCount)) {
#line 111
            goto while_break___0;
          }
        } else {
#line 111
          goto while_break___0;
        }
        {
#line 115
        tmp___1 = AnnotationList__isContributionAlways((AnnotationList const   *)self,
                                                       ci);
        }
#line 115
        if (tmp___1) {
          {
#line 117
          tmp = AnnotationList__isContributionAlways((AnnotationList const   *)*node,
                                                     ci);
          }
#line 117
          if (! tmp) {
#line 118
            cmp = -1;
          }
        } else {
          {
#line 120
          tmp___0 = AnnotationList__isContributionAlways((AnnotationList const   *)*node,
                                                         ci);
          }
#line 120
          if (tmp___0) {
#line 121
            cmp = 1;
          } else {
#line 125
            item = (size_t )0;
            {
#line 125
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 125
              if (cmp == 0) {
#line 125
                if (! (item < nitems)) {
#line 125
                  goto while_break___1;
                }
              } else {
#line 125
                goto while_break___1;
              }
#line 127
              if (! (((int )*(self->contributions[ci] + item / 8U) & (1 << (7U - item % 8U))) != 0)) {
#line 129
                if (((int )*((*node)->contributions[ci] + item / 8U) & (1 << (7U - item % 8U))) != 0) {
#line 130
                  cmp = -1;
                }
              } else
#line 132
              if (! (((int )*((*node)->contributions[ci] + item / 8U) & (1 << (7U - item % 8U))) != 0)) {
#line 133
                cmp = 1;
              }
#line 125
              item ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 111
        ci ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 137
    if (cmp < 0) {
#line 139
      self->next = *node;
#line 140
      *node = self;
#line 141
      goto while_break;
    } else
#line 143
    if (cmp == 0) {
#line 145
      self = (AnnotationList *)((void *)0);
#line 146
      goto while_break;
    }
#line 102
    node = & (*node)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (! *node) {
#line 150
    *node = self;
  }
#line 151
  return ((_Bool )((unsigned long )self != (unsigned long )((void *)0)));
}
}
#line 154 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
static bitset AnnotationList__compute_shift_tokens(transitions *trans ) 
{ 
  bitset shift_tokens ;
  bitset tmp ;
  int i ;

  {
  {
#line 157
  tmp = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 157
  shift_tokens = tmp;
#line 159
  i = 0;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (i < trans->num) {
#line 159
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 159
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 159
          goto while_break;
        }
      }
    } else {
#line 159
      goto while_break;
    }
#line 159
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
      {
#line 160
      bitset_set(shift_tokens, (bitset_bindex )(trans->states[i])->accessing_symbol);
      }
    }
#line 159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (shift_tokens);
}
}
#line 164 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
static bitset AnnotationList__compute_conflicted_tokens(bitset shift_tokens , reductions *reds ) 
{ 
  bitset conflicted_tokens ;
  bitset tmp ;
  bitset conflicted_tokens_rule ;
  bitset tmp___0 ;
  bitset tokens ;
  bitset tmp___1 ;
  int i ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 168
  tmp = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 168
  conflicted_tokens = tmp;
#line 169
  tmp___0 = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 169
  conflicted_tokens_rule = tmp___0;
#line 170
  tmp___1 = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 170
  tokens = tmp___1;
#line 173
  (*((shift_tokens->b.vtable)->copy))(tokens, shift_tokens);
#line 174
  i = 0;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (i < reds->num)) {
#line 174
      goto while_break;
    }
    {
#line 176
    (*((tokens->b.vtable)->and_))(conflicted_tokens_rule, tokens, *(reds->lookahead_tokens + i));
#line 177
    (*((conflicted_tokens->b.vtable)->or_))(conflicted_tokens, conflicted_tokens,
                                            conflicted_tokens_rule);
#line 179
    (*((tokens->b.vtable)->or_))(tokens, tokens, *(reds->lookahead_tokens + i));
    }
#line 182
    if (! (i == 0)) {
#line 182
      if (! ((unsigned long )reds->rules[i - 1] < (unsigned long )reds->rules[i])) {
        {
#line 182
        __assert_fail("i == 0 || reds->rules[i-1] < reds->rules[i]", "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                      182U, "AnnotationList__compute_conflicted_tokens");
        }
      }
    }
#line 174
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  bitset_free(tokens);
#line 186
  bitset_free(conflicted_tokens_rule);
  }
#line 188
  return (conflicted_tokens);
}
}
#line 191 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
static _Bool AnnotationList__compute_lhs_contributions(state *s , rule *the_rule ,
                                                       symbol_number conflicted_token ,
                                                       bitsetv follow_kernel_items ,
                                                       bitsetv always_follows , state ***predecessors ,
                                                       bitset **item_lookahead_sets ,
                                                       Sbitset *items , struct obstack *annotations_obstackp ) 
{ 
  goto_number lhs_goto ;
  goto_number tmp ;
  _Bool tmp___0 ;
  bitset_iterator biter_item ;
  bitset_bindex item ;
  _Bool tmp___1 ;

  {
  {
#line 202
  tmp = map_goto(s->number, (the_rule->lhs)->number);
#line 202
  lhs_goto = tmp;
#line 203
  tmp___0 = bitset_test(*(always_follows + lhs_goto), (bitset_bindex )conflicted_token);
  }
#line 203
  if (tmp___0) {
#line 204
    return ((_Bool)1);
  }
  {
#line 205
  *items = Sbitset__new_on_obstack(s->nitems, annotations_obstackp);
#line 209
  biter_item.next = (bitset_bindex )0;
#line 209
  biter_item.num = (bitset_bindex )1024;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (biter_item.num == 1024U) {
      {
#line 209
      biter_item.num = (*(((*(follow_kernel_items + lhs_goto))->b.vtable)->list))(*(follow_kernel_items + lhs_goto),
                                                                                  biter_item.list,
                                                                                  (bitset_bindex )1024,
                                                                                  & biter_item.next);
      }
#line 209
      if (! biter_item.num) {
#line 209
        goto while_break;
      }
    } else {
#line 209
      goto while_break;
    }
#line 209
    biter_item.i = (bitset_bindex )0;
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if (biter_item.i < biter_item.num) {
#line 209
        item = biter_item.list[biter_item.i];
      } else {
#line 209
        goto while_break___0;
      }
      {
#line 210
      tmp___1 = ielr_item_has_lookahead(s, 0, item, conflicted_token, predecessors,
                                        item_lookahead_sets);
      }
#line 210
      if (tmp___1) {
        {
#line 212
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 212
          *(*items + item / 8U) = (unsigned char )((int )*(*items + item / 8U) | (1 << (7U - item % 8U)));
#line 212
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 209
      (biter_item.i) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((_Bool)0);
}
}
#line 217 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
static void AnnotationList__computePredecessorAnnotations(AnnotationList *self , state *s ,
                                                          bitsetv follow_kernel_items ,
                                                          bitsetv always_follows ,
                                                          state ***predecessors ,
                                                          bitset **item_lookahead_sets ,
                                                          AnnotationList **annotation_lists ,
                                                          AnnotationIndex *annotation_counts ,
                                                          struct obstack *annotations_obstackp ) 
{ 
  state **predecessor ;
  AnnotationList *annotation_node ;
  AnnotationList *tmp ;
  _Bool potential_contribution ;
  bitset *lookaheads ;
  ContributionIndex ci ;
  symbol_number contribution_token ;
  symbol *tmp___0 ;
  _Bool tmp___1 ;
  size_t predecessor_item ;
  Sbitset sbiter_item ;
  Sbitset__Index self_item ;
  Sbitset items ;
  unsigned int rulei ;
  _Bool tmp___2 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp___3 ;
  Sbitset ptr_self ;
  Sbitset ptr_other1 ;
  Sbitset ptr_other2 ;
  Sbitset end_self ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___4 ;
  rule_number tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  Sbitset biter ;
  Sbitset__Index i ;
  size_t j ;
  void *tmp___9 ;
  struct obstack *__o___1 ;
  void *__obj___1 ;
  char *tmp___10 ;
  ContributionIndex tmp___11 ;
  size_t i___0 ;
  struct obstack *__o___2 ;
  void *__obj___2 ;
  char *tmp___12 ;
  _Bool tmp___13 ;
  struct obstack *__o___3 ;
  void *__obj___3 ;
  char *tmp___14 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
#line 231
  predecessor = *(predecessors + s->number);
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! *predecessor) {
#line 231
      goto while_break;
    }
    {
#line 233
    tmp = AnnotationList__alloc_on_obstack((self->inadequacyNode)->contributionCount,
                                           annotations_obstackp);
#line 233
    annotation_node = tmp;
#line 236
    annotation_node->inadequacyNode = self->inadequacyNode;
#line 237
    potential_contribution = (_Bool)0;
#line 238
    lookaheads = (bitset *)((void *)0);
#line 241
    ci = 0;
    }
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 241
      if (! (ci < (self->inadequacyNode)->contributionCount)) {
#line 241
        goto while_break___0;
      }
      {
#line 243
      tmp___0 = InadequacyList__getContributionToken((InadequacyList const   *)self->inadequacyNode,
                                                     ci);
#line 243
      contribution_token = tmp___0->number;
#line 246
      tmp___1 = AnnotationList__isContributionAlways((AnnotationList const   *)self,
                                                     ci);
      }
#line 246
      if (tmp___1) {
#line 248
        annotation_node->contributions[ci] = (Sbitset )((void *)0);
#line 249
        goto __Cont;
      }
      {
#line 251
      annotation_node->contributions[ci] = Sbitset__new_on_obstack((*predecessor)->nitems,
                                                                   annotations_obstackp);
#line 255
      predecessor_item = (size_t )0;
#line 258
      sbiter_item = self->contributions[ci];
      }
      {
#line 258
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 258
        if (! ((unsigned long )sbiter_item < (unsigned long )(self->contributions[ci] + ((s->nitems + 8U) - 1U) / 8U))) {
#line 258
          goto while_break___1;
        }
#line 258
        if ((int )*sbiter_item != 0) {
#line 258
          self_item = (Sbitset__Index )((sbiter_item - self->contributions[ci]) * 8L);
          {
#line 258
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 258
            if (self_item < s->nitems) {
#line 258
              if (! ((unsigned long )(self->contributions[ci] + self_item / 8U) < (unsigned long )(sbiter_item + 1))) {
#line 258
                goto while_break___2;
              }
            } else {
#line 258
              goto while_break___2;
            }
#line 258
            if (((int )*sbiter_item & (1 << (7U - self_item % 8U))) != 0) {
#line 270
              if (! (s->items[self_item] > 1)) {
                {
#line 270
                __assert_fail("s->items[self_item] > 1", "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                              270U, "AnnotationList__computePredecessorAnnotations");
                }
              }
              {
#line 274
              tmp___8 = item_number_is_rule_number(*(ritem + (s->items[self_item] - 2)));
              }
#line 274
              if (tmp___8) {
#line 279
                rulei = (unsigned int )s->items[self_item];
                {
#line 279
                while (1) {
                  while_continue___3: /* CIL Label */ ;
                  {
#line 279
                  tmp___2 = item_number_is_rule_number(*(ritem + rulei));
                  }
#line 279
                  if (tmp___2) {
#line 279
                    goto while_break___3;
                  }
#line 279
                  rulei ++;
                }
                while_break___3: /* CIL Label */ ;
                }
                {
#line 283
                tmp___5 = item_number_as_rule_number(*(ritem + rulei));
#line 283
                tmp___6 = AnnotationList__compute_lhs_contributions(*predecessor,
                                                                    rules + tmp___5,
                                                                    contribution_token,
                                                                    follow_kernel_items,
                                                                    always_follows,
                                                                    predecessors,
                                                                    item_lookahead_sets,
                                                                    & items, annotations_obstackp);
                }
#line 283
                if (tmp___6) {
#line 290
                  __o = annotations_obstackp;
#line 290
                  __obj = (void *)annotation_node->contributions[ci];
#line 290
                  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 290
                    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 290
                      tmp___3 = (char *)__obj;
#line 290
                      __o->object_base = tmp___3;
#line 290
                      __o->next_free = tmp___3;
                    } else {
                      {
#line 290
                      obstack_free(__o, __obj);
                      }
                    }
                  } else {
                    {
#line 290
                    obstack_free(__o, __obj);
                    }
                  }
#line 292
                  annotation_node->contributions[ci] = (Sbitset )((void *)0);
#line 293
                  goto while_break___2;
                } else {
                  {
#line 297
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 297
                    ptr_self = annotation_node->contributions[ci];
#line 297
                    ptr_other1 = annotation_node->contributions[ci];
#line 297
                    ptr_other2 = items;
#line 297
                    end_self = ptr_self + (((*predecessor)->nitems + 8U) - 1U) / 8U;
                    {
#line 297
                    while (1) {
                      while_continue___5: /* CIL Label */ ;
#line 297
                      if (! ((unsigned long )ptr_self < (unsigned long )end_self)) {
#line 297
                        goto while_break___5;
                      }
#line 297
                      *ptr_self = (unsigned char )((int )*ptr_other1 | (int )*ptr_other2);
#line 297
                      ptr_self ++;
#line 297
                      ptr_other1 ++;
#line 297
                      ptr_other2 ++;
                    }
                    while_break___5: /* CIL Label */ ;
                    }
#line 297
                    goto while_break___4;
                  }
                  while_break___4: /* CIL Label */ ;
                  }
#line 300
                  __o___0 = annotations_obstackp;
#line 300
                  __obj___0 = (void *)items;
#line 300
                  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
#line 300
                    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 300
                      tmp___4 = (char *)__obj___0;
#line 300
                      __o___0->object_base = tmp___4;
#line 300
                      __o___0->next_free = tmp___4;
                    } else {
                      {
#line 300
                      obstack_free(__o___0, __obj___0);
                      }
                    }
                  } else {
                    {
#line 300
                    obstack_free(__o___0, __obj___0);
                    }
                  }
                }
              } else {
                {
#line 310
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 310
                  if (! (predecessor_item < (*predecessor)->nitems)) {
#line 310
                    goto while_break___6;
                  }
#line 313
                  if ((*predecessor)->items[predecessor_item] == s->items[self_item] - 1) {
#line 315
                    goto while_break___6;
                  }
#line 310
                  predecessor_item ++;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 316
                if (! (predecessor_item != (*predecessor)->nitems)) {
                  {
#line 316
                  __assert_fail("predecessor_item != (*predecessor)->nitems", "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                                316U, "AnnotationList__computePredecessorAnnotations");
                  }
                }
                {
#line 317
                tmp___7 = ielr_item_has_lookahead(*predecessor, 0, predecessor_item,
                                                  contribution_token, predecessors,
                                                  item_lookahead_sets);
                }
#line 317
                if (tmp___7) {
                  {
#line 322
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
#line 322
                    *(annotation_node->contributions[ci] + predecessor_item / 8U) = (unsigned char )((int )*(annotation_node->contributions[ci] + predecessor_item / 8U) | (1 << (7U - predecessor_item % 8U)));
#line 322
                    goto while_break___7;
                  }
                  while_break___7: /* CIL Label */ ;
                  }
                }
              }
            }
#line 258
            self_item ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 258
        sbiter_item ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 327
      if (annotation_node->contributions[ci]) {
#line 331
        biter = annotation_node->contributions[ci];
        {
#line 331
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 331
          if (! ((unsigned long )biter < (unsigned long )(annotation_node->contributions[ci] + (((*predecessor)->nitems + 8U) - 1U) / 8U))) {
#line 331
            goto while_break___8;
          }
#line 331
          if ((int )*biter != 0) {
#line 331
            i = (Sbitset__Index )((biter - annotation_node->contributions[ci]) * 8L);
            {
#line 331
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 331
              if (i < (*predecessor)->nitems) {
#line 331
                if (! ((unsigned long )(annotation_node->contributions[ci] + i / 8U) < (unsigned long )(biter + 1))) {
#line 331
                  goto while_break___9;
                }
              } else {
#line 331
                goto while_break___9;
              }
#line 331
              if (((int )*biter & (1 << (7U - i % 8U))) != 0) {
#line 334
                potential_contribution = (_Bool)1;
#line 335
                if (! lookaheads) {
                  {
#line 338
                  tmp___9 = xnmalloc((*predecessor)->nitems, (size_t )sizeof(*lookaheads));
#line 338
                  lookaheads = (bitset *)tmp___9;
#line 340
                  j = (size_t )0;
                  }
                  {
#line 340
                  while (1) {
                    while_continue___10: /* CIL Label */ ;
#line 340
                    if (! (j < (*predecessor)->nitems)) {
#line 340
                      goto while_break___10;
                    }
#line 341
                    *(lookaheads + j) = (bitset )((void *)0);
#line 340
                    j ++;
                  }
                  while_break___10: /* CIL Label */ ;
                  }
                }
#line 343
                if (! *(lookaheads + i)) {
                  {
#line 344
                  *(lookaheads + i) = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
                  }
                }
                {
#line 345
                bitset_set(*(lookaheads + i), (bitset_bindex )contribution_token);
                }
              }
#line 331
              i ++;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 331
          biter ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ 
#line 241
      ci ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 370
    if (potential_contribution) {
      {
#line 372
      tmp___11 = AnnotationList__computeDominantContribution((AnnotationList const   *)annotation_node,
                                                             (*predecessor)->nitems,
                                                             lookaheads, (_Bool)1);
      }
#line 372
      if (ContributionIndex__none != (ContributionIndex const   )tmp___11) {
#line 376
        __o___1 = annotations_obstackp;
#line 376
        __obj___1 = (void *)annotation_node;
#line 376
        if ((unsigned long )__obj___1 > (unsigned long )((void *)__o___1->chunk)) {
#line 376
          if ((unsigned long )__obj___1 < (unsigned long )((void *)__o___1->chunk_limit)) {
#line 376
            tmp___10 = (char *)__obj___1;
#line 376
            __o___1->object_base = tmp___10;
#line 376
            __o___1->next_free = tmp___10;
          } else {
            {
#line 376
            obstack_free(__o___1, __obj___1);
            }
          }
        } else {
          {
#line 376
          obstack_free(__o___1, __obj___1);
          }
        }
#line 377
        annotation_node = (AnnotationList *)((void *)0);
      }
#line 381
      i___0 = (size_t )0;
      {
#line 381
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 381
        if (! (i___0 < (*predecessor)->nitems)) {
#line 381
          goto while_break___11;
        }
#line 382
        if (*(lookaheads + i___0)) {
          {
#line 383
          bitset_free(*(lookaheads + i___0));
          }
        }
#line 381
        i___0 ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 384
      free((void *)lookaheads);
      }
#line 386
      if (annotation_node) {
        {
#line 388
        tmp___13 = AnnotationList__insertInto(annotation_node, annotation_lists + (*predecessor)->number,
                                              (*predecessor)->nitems);
        }
#line 388
        if (tmp___13) {
          {
#line 393
          (*(annotation_counts + (*predecessor)->number)) ++;
#line 394
          AnnotationList__computePredecessorAnnotations(annotation_node, *predecessor,
                                                        follow_kernel_items, always_follows,
                                                        predecessors, item_lookahead_sets,
                                                        annotation_lists, annotation_counts,
                                                        annotations_obstackp);
          }
        } else {
#line 401
          __o___2 = annotations_obstackp;
#line 401
          __obj___2 = (void *)annotation_node;
#line 401
          if ((unsigned long )__obj___2 > (unsigned long )((void *)__o___2->chunk)) {
#line 401
            if ((unsigned long )__obj___2 < (unsigned long )((void *)__o___2->chunk_limit)) {
#line 401
              tmp___12 = (char *)__obj___2;
#line 401
              __o___2->object_base = tmp___12;
#line 401
              __o___2->next_free = tmp___12;
            } else {
              {
#line 401
              obstack_free(__o___2, __obj___2);
              }
            }
          } else {
            {
#line 401
            obstack_free(__o___2, __obj___2);
            }
          }
        }
      }
    } else {
#line 405
      __o___3 = annotations_obstackp;
#line 405
      __obj___3 = (void *)annotation_node;
#line 405
      if ((unsigned long )__obj___3 > (unsigned long )((void *)__o___3->chunk)) {
#line 405
        if ((unsigned long )__obj___3 < (unsigned long )((void *)__o___3->chunk_limit)) {
#line 405
          tmp___14 = (char *)__obj___3;
#line 405
          __o___3->object_base = tmp___14;
#line 405
          __o___3->next_free = tmp___14;
        } else {
          {
#line 405
          obstack_free(__o___3, __obj___3);
          }
        }
      } else {
        {
#line 405
        obstack_free(__o___3, __obj___3);
        }
      }
    }
#line 231
    predecessor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
void AnnotationList__compute_from_inadequacies(state *s , bitsetv follow_kernel_items ,
                                               bitsetv always_follows , state ***predecessors ,
                                               bitset **item_lookahead_sets , InadequacyList **inadequacy_lists ,
                                               AnnotationList **annotation_lists ,
                                               AnnotationIndex *annotation_counts ,
                                               ContributionIndex *max_contributionsp ,
                                               struct obstack *annotations_obstackp ,
                                               InadequacyListNodeCount *inadequacy_list_node_count ) 
{ 
  bitsetv all_lookaheads ;
  bitset shift_tokens ;
  bitset conflicted_tokens ;
  bitset_iterator biter_conflict ;
  bitset_bindex conflicted_token ;
  AnnotationList *annotation_node ;
  bitset actions___0 ;
  bitset tmp ;
  ContributionIndex contribution_count ;
  _Bool potential_contribution ;
  int rule_i ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  ContributionIndex ci ;
  int item_i ;
  int rule_i___0 ;
  rule *the_rule ;
  _Bool tmp___2 ;
  rule_number tmp___3 ;
  ContributionIndex tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  InadequacyList *conflict_node ;
  InadequacyList *tmp___10 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  ContributionIndex tmp___14 ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___15 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 426
  if (s->consistent) {
#line 427
    return;
  }
  {
#line 429
  all_lookaheads = bitsetv_create(s->nitems, (bitset_bindex )ntokens, 1U);
#line 430
  bitsetv_ones(all_lookaheads);
#line 431
  shift_tokens = AnnotationList__compute_shift_tokens(s->transitions);
#line 432
  conflicted_tokens = AnnotationList__compute_conflicted_tokens(shift_tokens, s->reductions);
#line 436
  biter_conflict.next = (bitset_bindex )0;
#line 436
  biter_conflict.num = (bitset_bindex )1024;
  }
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (biter_conflict.num == 1024U) {
      {
#line 436
      biter_conflict.num = (*((conflicted_tokens->b.vtable)->list))(conflicted_tokens,
                                                                    biter_conflict.list,
                                                                    (bitset_bindex )1024,
                                                                    & biter_conflict.next);
      }
#line 436
      if (! biter_conflict.num) {
#line 436
        goto while_break;
      }
    } else {
#line 436
      goto while_break;
    }
#line 436
    biter_conflict.i = (bitset_bindex )0;
    {
#line 436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 436
      if (biter_conflict.i < biter_conflict.num) {
#line 436
        conflicted_token = biter_conflict.list[biter_conflict.i];
      } else {
#line 436
        goto while_break___0;
      }
      {
#line 441
      tmp = bitset_create((bitset_bindex )((s->reductions)->num + 1), (bitset_attrs )1);
#line 441
      actions___0 = tmp;
#line 442
      contribution_count = 0;
#line 443
      potential_contribution = (_Bool)0;
#line 448
      rule_i = 0;
      }
      {
#line 448
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 448
        if (! (rule_i < (s->reductions)->num)) {
#line 448
          goto while_break___1;
        }
        {
#line 449
        tmp___0 = bitset_test(*((s->reductions)->lookahead_tokens + rule_i), conflicted_token);
        }
#line 449
        if (tmp___0) {
#line 451
          contribution_count ++;
        }
#line 448
        rule_i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 452
      tmp___1 = bitset_test(shift_tokens, conflicted_token);
      }
#line 452
      if (tmp___1) {
#line 453
        contribution_count ++;
      }
      {
#line 454
      annotation_node = AnnotationList__alloc_on_obstack(contribution_count, annotations_obstackp);
#line 462
      ci = 0;
#line 463
      item_i = 0;
#line 465
      rule_i___0 = 0;
      }
      {
#line 465
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 465
        if (! (rule_i___0 < (s->reductions)->num)) {
#line 465
          goto while_break___2;
        }
        {
#line 467
        the_rule = (s->reductions)->rules[rule_i___0];
#line 468
        tmp___8 = bitset_test(*((s->reductions)->lookahead_tokens + rule_i___0), conflicted_token);
        }
#line 468
        if (tmp___8) {
          {
#line 471
          bitset_set(actions___0, (bitset_bindex )rule_i___0);
#line 473
          tmp___6 = item_number_is_rule_number(*(the_rule->rhs + 0));
          }
#line 473
          if (tmp___6) {
            {
#line 494
            tmp___5 = AnnotationList__compute_lhs_contributions(s, the_rule, (symbol_number )conflicted_token,
                                                                follow_kernel_items,
                                                                always_follows, predecessors,
                                                                item_lookahead_sets,
                                                                & annotation_node->contributions[ci],
                                                                annotations_obstackp);
            }
#line 494
            if (tmp___5) {
#line 500
              tmp___4 = ci;
#line 500
              ci ++;
#line 500
              annotation_node->contributions[tmp___4] = (Sbitset )((void *)0);
#line 501
              goto __Cont;
            }
          } else {
            {
#line 475
            annotation_node->contributions[ci] = Sbitset__new_on_obstack(s->nitems,
                                                                         annotations_obstackp);
            }
            {
#line 480
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 480
              tmp___2 = item_number_is_rule_number(*(ritem + s->items[item_i]));
              }
#line 480
              if (tmp___2) {
                {
#line 480
                tmp___3 = item_number_as_rule_number(*(ritem + s->items[item_i]));
                }
#line 480
                if (! (tmp___3 != the_rule->number)) {
#line 480
                  goto while_break___3;
                }
              }
#line 486
              item_i ++;
#line 487
              if (! ((size_t )item_i < s->nitems)) {
                {
#line 487
                __assert_fail("item_i < s->nitems", "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                              487U, "AnnotationList__compute_from_inadequacies");
                }
              }
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 489
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 489
              *(annotation_node->contributions[ci] + item_i / 8) = (unsigned char )((int )*(annotation_node->contributions[ci] + item_i / 8) | (1 << (7 - item_i % 8)));
#line 489
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          {
#line 504
          tmp___7 = Sbitset__isEmpty(annotation_node->contributions[ci], s->nitems);
          }
#line 504
          if (tmp___7) {
            {
#line 504
            __assert_fail("!Sbitset__isEmpty (annotation_node->contributions[ci], s->nitems)",
                          "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                          505U, "AnnotationList__compute_from_inadequacies");
            }
          }
#line 506
          ci ++;
#line 507
          potential_contribution = (_Bool)1;
        }
        __Cont: /* CIL Label */ 
#line 465
        rule_i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 519
      if (potential_contribution) {
        {
#line 521
        tmp___9 = bitset_test(shift_tokens, conflicted_token);
        }
#line 521
        if (tmp___9) {
          {
#line 523
          bitset_set(actions___0, (bitset_bindex )(s->reductions)->num);
#line 524
          annotation_node->contributions[contribution_count - 1] = (Sbitset )((void *)0);
          }
        }
        {
#line 527
        tmp___10 = InadequacyList__new_conflict(s, *(symbols + conflicted_token),
                                                actions___0, inadequacy_list_node_count);
#line 527
        conflict_node = tmp___10;
#line 531
        actions___0 = (bitset )((void *)0);
#line 532
        annotation_node->inadequacyNode = conflict_node;
#line 533
        tmp___14 = AnnotationList__computeDominantContribution((AnnotationList const   *)annotation_node,
                                                               s->nitems, all_lookaheads,
                                                               (_Bool)1);
        }
#line 533
        if (ContributionIndex__none != (ContributionIndex const   )tmp___14) {
#line 537
          __o = annotations_obstackp;
#line 537
          __obj = (void *)annotation_node;
#line 537
          if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 537
            if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 537
              tmp___11 = (char *)__obj;
#line 537
              __o->object_base = tmp___11;
#line 537
              __o->next_free = tmp___11;
            } else {
              {
#line 537
              obstack_free(__o, __obj);
              }
            }
          } else {
            {
#line 537
            obstack_free(__o, __obj);
            }
          }
          {
#line 538
          InadequacyList__delete(conflict_node);
          }
        } else {
          {
#line 542
          InadequacyList__prependTo(conflict_node, inadequacy_lists + s->number);
#line 544
          tmp___12 = AnnotationList__insertInto(annotation_node, annotation_lists + s->number,
                                                s->nitems);
          }
#line 544
          if (! tmp___12) {
            {
#line 544
            __assert_fail("AnnotationList__insertInto ( annotation_node, &annotation_lists[s->number], s->nitems)",
                          "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                          546U, "AnnotationList__compute_from_inadequacies");
            }
          }
          {
#line 551
          tmp___13 = bitset_test(shift_tokens, conflicted_token);
          }
#line 551
          if (tmp___13) {
#line 551
            if (! (*(symbols + conflicted_token))->prec) {
              {
#line 551
              __assert_fail("!bitset_test (shift_tokens, conflicted_token) || symbols[conflicted_token]->prec",
                            "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                            552U, "AnnotationList__compute_from_inadequacies");
              }
            }
          }
#line 553
          (*(annotation_counts + s->number)) ++;
#line 554
          if (contribution_count > *max_contributionsp) {
#line 555
            *max_contributionsp = contribution_count;
          }
          {
#line 556
          AnnotationList__computePredecessorAnnotations(annotation_node, s, follow_kernel_items,
                                                        always_follows, predecessors,
                                                        item_lookahead_sets, annotation_lists,
                                                        annotation_counts, annotations_obstackp);
          }
        }
      } else {
        {
#line 566
        bitset_free(actions___0);
#line 567
        __o___0 = annotations_obstackp;
#line 567
        __obj___0 = (void *)annotation_node;
        }
#line 567
        if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
#line 567
          if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 567
            tmp___15 = (char *)__obj___0;
#line 567
            __o___0->object_base = tmp___15;
#line 567
            __o___0->next_free = tmp___15;
          } else {
            {
#line 567
            obstack_free(__o___0, __obj___0);
            }
          }
        } else {
          {
#line 567
          obstack_free(__o___0, __obj___0);
          }
        }
      }
#line 436
      (biter_conflict.i) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 571
  bitsetv_free(all_lookaheads);
#line 572
  bitset_free(shift_tokens);
#line 573
  bitset_free(conflicted_tokens);
  }
#line 574
  return;
}
}
#line 576 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
void AnnotationList__debug(AnnotationList const   *self , size_t nitems , int spaces ) 
{ 
  AnnotationList const   *a ;
  AnnotationIndex ai ;
  int j ;
  ContributionIndex ci ;
  bitset_bindex rulei ;
  symbol_number token ;
  symbol *tmp ;
  int j___0 ;
  _Bool tmp___0 ;
  ContributionIndex tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 581
  a = self;
#line 581
  ai = (AnnotationIndex )0;
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 581
    if (! a) {
#line 581
      goto while_break;
    }
#line 585
    j = 0;
    {
#line 585
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 585
      if (! (j < spaces)) {
#line 585
        goto while_break___0;
      }
      {
#line 586
      putc_unlocked(' ', stderr);
#line 585
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 588
    rpl_fprintf(stderr, "Annotation %d (manifesting state %d):\n", ai, ((a->inadequacyNode)->manifestingState)->number);
#line 592
    rulei = (bitset_bindex )0;
#line 593
    rulei = bitset_first((a->inadequacyNode)->inadequacy.conflict.actions);
#line 594
    ci = 0;
    }
    {
#line 594
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 594
      if (! (ci < (a->inadequacyNode)->contributionCount)) {
#line 594
        goto while_break___1;
      }
      {
#line 596
      tmp = InadequacyList__getContributionToken((InadequacyList const   *)a->inadequacyNode,
                                                 ci);
#line 596
      token = tmp->number;
#line 601
      j___0 = 0;
      }
      {
#line 601
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 601
        if (! (j___0 < spaces + 2)) {
#line 601
          goto while_break___2;
        }
        {
#line 602
        putc_unlocked(' ', stderr);
#line 601
        j___0 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 604
      tmp___1 = InadequacyList__getShiftContributionIndex((InadequacyList const   *)a->inadequacyNode);
      }
#line 604
      if (ci == tmp___1) {
        {
#line 606
        rpl_fprintf(stderr, "Contributes shift of token %d.\n", token);
        }
      } else {
        {
#line 609
        rpl_fprintf(stderr, "Contributes token %d", token);
        }
#line 610
        if (! (rulei != 4294967295U)) {
          {
#line 610
          __assert_fail("rulei != ((bitset_bindex) -1)", "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c",
                        610U, "AnnotationList__debug");
          }
        }
        {
#line 611
        rpl_fprintf(stderr, " as lookahead, rule number %d", ((((a->inadequacyNode)->manifestingState)->reductions)->rules[rulei])->number);
#line 614
        rulei = bitset_next((a->inadequacyNode)->inadequacy.conflict.actions, rulei + 1U);
#line 617
        tmp___0 = AnnotationList__isContributionAlways(a, ci);
        }
#line 617
        if (tmp___0) {
          {
#line 618
          rpl_fprintf(stderr, " always.");
          }
        } else {
          {
#line 621
          rpl_fprintf(stderr, ", items: ");
#line 622
          Sbitset__fprint(a->contributions[ci], nitems, stderr);
          }
        }
        {
#line 624
        rpl_fprintf(stderr, "\n");
        }
      }
#line 594
      ci ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 581
    a = (AnnotationList const   *)a->next;
#line 581
    ai ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 631 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
void AnnotationList__computeLookaheadFilter(AnnotationList const   *self , size_t nitems ,
                                            bitsetv lookahead_filter ) 
{ 
  ContributionIndex ci ;
  Sbitset__Index item ;
  Sbitset biter ;
  symbol_number token ;
  symbol *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 636
  bitsetv_zero(lookahead_filter);
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! self) {
#line 637
      goto while_break;
    }
#line 640
    ci = 0;
    {
#line 640
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 640
      if (! (ci < (self->inadequacyNode)->contributionCount)) {
#line 640
        goto while_break___0;
      }
      {
#line 641
      tmp___0 = AnnotationList__isContributionAlways(self, ci);
      }
#line 641
      if (! tmp___0) {
        {
#line 645
        tmp = InadequacyList__getContributionToken((InadequacyList const   *)self->inadequacyNode,
                                                   ci);
#line 645
        token = tmp->number;
#line 648
        biter = self->contributions[ci];
        }
        {
#line 648
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 648
          if (! ((unsigned long )biter < (unsigned long )(self->contributions[ci] + ((nitems + 8U) - 1U) / 8U))) {
#line 648
            goto while_break___1;
          }
#line 648
          if ((int )*biter != 0) {
#line 648
            item = (Sbitset__Index )((biter - self->contributions[ci]) * 8L);
            {
#line 648
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 648
              if (item < nitems) {
#line 648
                if (! ((unsigned long )(self->contributions[ci] + item / 8U) < (unsigned long )(biter + 1))) {
#line 648
                  goto while_break___2;
                }
              } else {
#line 648
                goto while_break___2;
              }
#line 648
              if (((int )*biter & (1 << (7U - item % 8U))) != 0) {
                {
#line 649
                bitset_set(*(lookahead_filter + item), (bitset_bindex )token);
                }
              }
#line 648
              item ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 648
          biter ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 640
      ci ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 637
    self = (AnnotationList const   *)self->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  return;
}
}
#line 671 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
static _Bool AnnotationList__stateMakesContribution(AnnotationList const   *self ,
                                                    size_t nitems , ContributionIndex ci ,
                                                    bitset *lookaheads ) 
{ 
  _Bool tmp ;
  symbol_number token ;
  symbol *tmp___0 ;
  Sbitset__Index item ;
  Sbitset biter ;
  _Bool tmp___1 ;

  {
  {
#line 676
  tmp = AnnotationList__isContributionAlways(self, ci);
  }
#line 676
  if (tmp) {
#line 677
    return ((_Bool)1);
  }
#line 678
  if (! lookaheads) {
#line 679
    return ((_Bool)0);
  }
  {
#line 681
  tmp___0 = InadequacyList__getContributionToken((InadequacyList const   *)self->inadequacyNode,
                                                 ci);
#line 681
  token = tmp___0->number;
#line 685
  biter = self->contributions[ci];
  }
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (! ((unsigned long )biter < (unsigned long )(self->contributions[ci] + ((nitems + 8U) - 1U) / 8U))) {
#line 685
      goto while_break;
    }
#line 685
    if ((int )*biter != 0) {
#line 685
      item = (Sbitset__Index )((biter - self->contributions[ci]) * 8L);
      {
#line 685
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 685
        if (item < nitems) {
#line 685
          if (! ((unsigned long )(self->contributions[ci] + item / 8U) < (unsigned long )(biter + 1))) {
#line 685
            goto while_break___0;
          }
        } else {
#line 685
          goto while_break___0;
        }
#line 685
        if (((int )*biter & (1 << (7U - item % 8U))) != 0) {
#line 686
          if (*(lookaheads + item)) {
            {
#line 686
            tmp___1 = bitset_test(*(lookaheads + item), (bitset_bindex )token);
            }
#line 686
            if (tmp___1) {
#line 687
              return ((_Bool)1);
            }
          }
        }
#line 685
        item ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 685
    biter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 689
  return ((_Bool)0);
}
}
#line 692 "/home/pronto/abs/test-suite/bison-2.5/src/AnnotationList.c"
ContributionIndex AnnotationList__computeDominantContribution(AnnotationList const   *self ,
                                                              size_t nitems , bitset *lookaheads ,
                                                              _Bool require_split_stable ) 
{ 
  symbol *token ;
  ContributionIndex ci_shift ;
  ContributionIndex tmp ;
  _Bool find_stable_domination_over_shift ;
  _Bool find_stable_error_action_domination ;
  ContributionIndex ci ;
  int actioni ;
  ContributionIndex ci_rr_dominator ;
  int shift_precedence ;
  bitset_bindex tmp___0 ;
  bitset_bindex tmp___1 ;
  int reduce_precedence ;
  rule *r ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  ContributionIndex ci___0 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 698
  tmp = InadequacyList__getShiftContributionIndex((InadequacyList const   *)self->inadequacyNode);
#line 698
  ci_shift = tmp;
#line 701
  token = (self->inadequacyNode)->inadequacy.conflict.token;
  }
#line 704
  if (ci_shift != (ContributionIndex )ContributionIndex__none) {
#line 706
    find_stable_domination_over_shift = (_Bool)0;
#line 707
    find_stable_error_action_domination = (_Bool)0;
#line 711
    ci_rr_dominator = (ContributionIndex )ContributionIndex__none;
#line 712
    shift_precedence = token->prec;
#line 715
    if (! shift_precedence) {
#line 716
      return (ci_shift);
    }
    {
#line 721
    ci = 0;
#line 721
    tmp___0 = bitset_first((self->inadequacyNode)->inadequacy.conflict.actions);
#line 721
    actioni = (int )tmp___0;
    }
    {
#line 721
    while (1) {
      while_continue: /* CIL Label */ ;
#line 721
      if (! (ci < (self->inadequacyNode)->contributionCount)) {
#line 721
        goto while_break;
      }
#line 727
      reduce_precedence = 0;
#line 728
      if (ci == ci_shift) {
#line 729
        goto __Cont;
      }
#line 731
      r = (((self->inadequacyNode)->manifestingState)->reductions)->rules[actioni];
#line 733
      if (r->prec) {
#line 734
        reduce_precedence = (r->prec)->prec;
      }
#line 739
      if (reduce_precedence) {
#line 739
        if (reduce_precedence < shift_precedence) {
#line 743
          goto __Cont;
        } else
#line 739
        if (reduce_precedence == shift_precedence) {
#line 739
          if ((unsigned int )token->assoc == 1U) {
#line 743
            goto __Cont;
          }
        }
      }
      {
#line 744
      tmp___2 = AnnotationList__stateMakesContribution(self, nitems, ci, lookaheads);
      }
#line 744
      if (! tmp___2) {
#line 746
        goto __Cont;
      }
#line 749
      if (reduce_precedence == shift_precedence) {
#line 749
        if ((unsigned int )token->assoc == 3U) {
#line 754
          if (find_stable_domination_over_shift) {
#line 755
            return ((ContributionIndex )ContributionIndex__none);
          }
#line 756
          if (! require_split_stable) {
#line 758
            return ((ContributionIndex )ContributionIndex__error_action);
          } else {
            {
#line 756
            tmp___3 = AnnotationList__isContributionAlways(self, ci);
            }
#line 756
            if (tmp___3) {
#line 758
              return ((ContributionIndex )ContributionIndex__error_action);
            }
          }
#line 759
          find_stable_error_action_domination = (_Bool)1;
        }
      }
#line 763
      if (ci_rr_dominator == (ContributionIndex )ContributionIndex__none) {
#line 764
        ci_rr_dominator = ci;
      }
#line 768
      if (reduce_precedence) {
#line 772
        if (find_stable_error_action_domination) {
#line 773
          return ((ContributionIndex )ContributionIndex__none);
        }
#line 774
        if (! require_split_stable) {
#line 775
          return (ci_rr_dominator);
        }
        {
#line 776
        tmp___4 = AnnotationList__isContributionAlways(self, ci_rr_dominator);
        }
#line 776
        if (! tmp___4) {
#line 778
          return ((ContributionIndex )ContributionIndex__none);
        }
        {
#line 779
        tmp___5 = AnnotationList__isContributionAlways(self, ci);
        }
#line 779
        if (tmp___5) {
#line 780
          return (ci_rr_dominator);
        }
#line 781
        find_stable_domination_over_shift = (_Bool)1;
      }
      __Cont: /* CIL Label */ 
      {
#line 721
      ci ++;
#line 721
      tmp___1 = bitset_next((self->inadequacyNode)->inadequacy.conflict.actions, (bitset_bindex )(actioni + 1));
#line 721
      actioni = (int )tmp___1;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 785
    if (find_stable_domination_over_shift) {
#line 787
      return ((ContributionIndex )ContributionIndex__none);
    } else
#line 785
    if (find_stable_error_action_domination) {
#line 787
      return ((ContributionIndex )ContributionIndex__none);
    }
#line 789
    return (ci_shift);
  }
#line 796
  ci___0 = 0;
  {
#line 796
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 796
    if (! (ci___0 < (self->inadequacyNode)->contributionCount)) {
#line 796
      goto while_break___0;
    }
    {
#line 797
    tmp___7 = AnnotationList__stateMakesContribution(self, nitems, ci___0, lookaheads);
    }
#line 797
    if (tmp___7) {
#line 800
      if (require_split_stable) {
        {
#line 800
        tmp___6 = AnnotationList__isContributionAlways(self, ci___0);
        }
#line 800
        if (! tmp___6) {
#line 802
          return ((ContributionIndex )ContributionIndex__none);
        }
      }
#line 803
      return (ci___0);
    }
#line 796
    ci___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 806
  return ((ContributionIndex )ContributionIndex__none);
}
}
