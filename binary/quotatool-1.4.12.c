/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 53 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 25 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/system.h"
struct _fs_t {
   char device[4096] ;
   char mount_pt[4096] ;
   char mnt_type[4096] ;
};
#line 32 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/system.h"
typedef struct _fs_t fs_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 18 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/parse.h"
struct _argdata_t {
   char *id ;
   char *qfile ;
   short id_type ;
   short silent ;
   short noaction ;
   short dump_info ;
   short raise_only ;
   char *block_hard ;
   char *block_soft ;
   char *block_grace ;
   short block_reset ;
   char *inode_hard ;
   char *inode_soft ;
   char *inode_grace ;
   short inode_reset ;
};
#line 37 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/parse.h"
typedef struct _argdata_t argdata_t;
#line 53 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/quota.h"
struct _quota_t {
   u_int64_t block_hard ;
   u_int64_t block_soft ;
   u_int64_t diskspace_used ;
   u_int64_t inode_hard ;
   u_int64_t inode_soft ;
   u_int64_t inode_used ;
   time_t block_time ;
   time_t inode_time ;
   time_t block_grace ;
   time_t inode_grace ;
   int _id ;
   int _id_type ;
   char *_qfile ;
   int _do_set_global_block_gracetime ;
   int _do_set_global_inode_gracetime ;
   void *_v2_quotainfo ;
   void *_generic_quotainfo ;
};
#line 76 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/quota.h"
typedef struct _quota_t quota_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 19 "/usr/include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 22 "/usr/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 20 "./src/linux/linux_quota.h"
typedef u_int32_t qid_t;
#line 21 "./src/linux/linux_quota.h"
typedef u_int64_t qsize_t;
#line 78 "./src/linux/linux_quota.h"
struct if_dqblk {
   u_int64_t dqb_bhardlimit ;
   u_int64_t dqb_bsoftlimit ;
   u_int64_t dqb_curspace ;
   u_int64_t dqb_ihardlimit ;
   u_int64_t dqb_isoftlimit ;
   u_int64_t dqb_curinodes ;
   u_int64_t dqb_btime ;
   u_int64_t dqb_itime ;
   u_int32_t dqb_valid ;
};
#line 99 "./src/linux/linux_quota.h"
struct if_dqinfo {
   u_int64_t dqi_bgrace ;
   u_int64_t dqi_igrace ;
   u_int32_t dqi_flags ;
   u_int32_t dqi_valid ;
};
#line 16 "./src/linux/dqblk_v1.h"
struct v1_kern_dqblk {
   u_int32_t dqb_bhardlimit ;
   u_int32_t dqb_bsoftlimit ;
   u_int32_t dqb_curblocks ;
   u_int32_t dqb_ihardlimit ;
   u_int32_t dqb_isoftlimit ;
   u_int32_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 25 "./src/linux/dqblk_v2.h"
struct v2_kern_dqblk {
   unsigned int dqb_ihardlimit ;
   unsigned int dqb_isoftlimit ;
   unsigned int dqb_curinodes ;
   unsigned int dqb_bhardlimit ;
   unsigned int dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 37 "./src/linux/dqblk_v2.h"
struct v2_kern_dqinfo {
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   unsigned int dqi_flags ;
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
};
#line 47 "./src/linux/dqblk_v2.h"
struct v2_dqstats {
   u_int32_t lookups ;
   u_int32_t drops ;
   u_int32_t reads ;
   u_int32_t writes ;
   u_int32_t cache_hits ;
   u_int32_t allocated_dquots ;
   u_int32_t free_dquots ;
   u_int32_t syncs ;
   u_int32_t version ;
};
#line 14 "./src/linux/xfs_quota.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
#line 14 "./src/linux/xfs_quota.h"
typedef struct fs_disk_quota fs_disk_quota_t;
#line 95 "./src/linux/xfs_quota.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 95 "./src/linux/xfs_quota.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 101 "./src/linux/xfs_quota.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 101 "./src/linux/xfs_quota.h"
typedef struct fs_quota_stat fs_quota_stat_t;
#line 152 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 105 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 111
extern struct group *getgrnam(char const   *__name ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) setmntent)(char const   *__file ,
                                                                                  char const   *__mode ) ;
#line 71
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 87
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) endmntent)(FILE *__stream ) ;
#line 91
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) hasmntopt)(struct mntent  const  *__mnt ,
                                                                                  char const   *__opt ) ;
#line 34 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/system.h"
fs_t *system_getfs(char *fs_spec ) ;
#line 35
uid_t system_getuid(char *user ) ;
#line 36
gid_t system_getgid(char *group ) ;
#line 71 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/system.c"
void output_error(char const   *format  , ...) ;
#line 101
void output_debug(char const   *format  , ...) ;
#line 195
void output_info(char const   *format  , ...) ;
#line 58 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/system.c"
fs_t *system_getfs(char *fs_spec ) 
{ 
  struct mntent *current_fs ;
  FILE *etc_mtab ;
  fs_t *ent ;
  int done ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *loopd_start ;
  char *loopd_end ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 69
  tmp = malloc(sizeof(fs_t ));
#line 69
  ent = (fs_t *)tmp;
  }
#line 70
  if (! ent) {
    {
#line 71
    output_error("Insufficient Memory");
#line 72
    exit(4);
    }
  }
  {
#line 92
  etc_mtab = setmntent("/etc/mtab", "r");
  }
#line 93
  if (! etc_mtab) {
    {
#line 94
    tmp___0 = __errno_location();
#line 94
    tmp___1 = strerror(*tmp___0);
#line 94
    output_error("Failed opening %s for reading: %s", "/etc/mtab", tmp___1);
    }
#line 96
    return ((fs_t *)((void *)0));
  }
  {
#line 101
  output_debug("Looking for fs_spec \'%s\'", fs_spec);
#line 103
  done = 0;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 114
    current_fs = getmntent(etc_mtab);
    }
#line 115
    if (! current_fs) {
      {
#line 125
      output_error("Filesystem %s does not exist", fs_spec);
      }
#line 126
      return ((fs_t *)((void *)0));
    }
    {
#line 129
    output_debug("Checking device \'%s\', mounted at \'%s\'", current_fs->mnt_fsname,
                 current_fs->mnt_dir);
#line 133
    tmp___3 = strcmp((char const   *)current_fs->mnt_fsname, (char const   *)fs_spec);
    }
#line 133
    if (tmp___3) {
      {
#line 133
      tmp___4 = strcmp((char const   *)current_fs->mnt_dir, (char const   *)fs_spec);
      }
#line 133
      if (! tmp___4) {
        _L: /* CIL Label */ 
        {
#line 138
        loopd_start = (char *)((void *)0);
#line 138
        loopd_end = (char *)((void *)0);
#line 141
        strncpy((char */* __restrict  */)(ent->mnt_type), (char const   */* __restrict  */)current_fs->mnt_type,
                (size_t )4095);
#line 144
        loopd_start = strstr((char const   *)current_fs->mnt_opts, "loop=/");
        }
#line 144
        if ((unsigned long )loopd_start != (unsigned long )((void *)0)) {
          {
#line 145
          tmp___2 = strlen("loop=");
#line 145
          loopd_start += tmp___2;
#line 146
          output_debug("%s looks like a loop device, trying to grok opts: %s", current_fs->mnt_fsname,
                       current_fs->mnt_opts);
#line 148
          loopd_end = loopd_start;
          }
          {
#line 148
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 148
            if ((int )*loopd_end != 0) {
#line 148
              if (! ((int )*loopd_end != 44)) {
#line 148
                goto while_break___0;
              }
            } else {
#line 148
              goto while_break___0;
            }
#line 148
            loopd_end ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 151
          if ((unsigned long )loopd_end > (unsigned long )loopd_start) {
            {
#line 152
            strncpy((char */* __restrict  */)(ent->device), (char const   */* __restrict  */)loopd_start,
                    (size_t )(loopd_end - loopd_start));
#line 153
            ent->device[loopd_end - loopd_start] = (char )'\000';
#line 154
            output_debug("found loop device %s", ent->device);
            }
          } else {
            {
#line 157
            output_error("%s seems like a loop device but I can\'t grok the device from opts: %s\n",
                         current_fs->mnt_fsname, current_fs->mnt_opts);
#line 161
            endmntent(etc_mtab);
            }
#line 162
            return ((fs_t *)((void *)0));
          }
        } else {
          {
#line 167
          strncpy((char */* __restrict  */)(ent->device), (char const   */* __restrict  */)current_fs->mnt_fsname,
                  (size_t )4095);
#line 168
          strncpy((char */* __restrict  */)(ent->mount_pt), (char const   */* __restrict  */)current_fs->mnt_dir,
                  (size_t )4095);
          }
        }
#line 172
        done = 1;
#line 173
        goto __Cont;
      }
    } else {
#line 133
      goto _L;
    }
    __Cont: /* CIL Label */ 
#line 106
    if (! (! done)) {
#line 106
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  tmp___5 = hasmntopt((struct mntent  const  *)current_fs, "ro");
  }
#line 187
  if (tmp___5) {
    {
#line 188
    output_error("Filesystem %s is mounted read-only\n", fs_spec);
#line 189
    endmntent(etc_mtab);
    }
#line 191
    return ((fs_t *)((void *)0));
  }
  {
#line 195
  output_info("filesystem %s has device node %s", fs_spec, ent->device);
#line 200
  endmntent(etc_mtab);
  }
#line 202
  return (ent);
}
}
#line 211 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/system.c"
uid_t system_getuid(char *user ) 
{ 
  struct passwd *pwent ;
  int uid ;
  char *temp_str ;
  long tmp ;

  {
  {
#line 216
  pwent = getpwnam((char const   *)user);
  }
#line 218
  if ((unsigned long )pwent == (unsigned long )((void *)0)) {
    {
#line 221
    tmp = strtol((char const   */* __restrict  */)user, (char **/* __restrict  */)(& temp_str),
                 10);
#line 221
    uid = (int )tmp;
#line 222
    pwent = getpwuid((uid_t )uid);
    }
#line 223
    if ((unsigned long )user == (unsigned long )temp_str) {
      {
#line 224
      output_error("User %s does not exist\n", user);
      }
#line 225
      return ((uid_t )-1);
    } else
#line 223
    if ((unsigned long )pwent == (unsigned long )((void *)0)) {
      {
#line 224
      output_error("User %s does not exist\n", user);
      }
#line 225
      return ((uid_t )-1);
    }
  }
  {
#line 228
  output_info("user \'%s\' has uid %d", user, pwent->pw_uid);
  }
#line 229
  return (pwent->pw_uid);
}
}
#line 234 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/system.c"
gid_t system_getgid(char *group ) 
{ 
  struct group *grent ;
  int gid ;
  char *temp_str ;
  long tmp ;

  {
  {
#line 240
  grent = getgrnam((char const   *)group);
  }
#line 241
  if ((unsigned long )grent == (unsigned long )((void *)0)) {
    {
#line 242
    tmp = strtol((char const   */* __restrict  */)group, (char **/* __restrict  */)(& temp_str),
                 10);
#line 242
    gid = (int )tmp;
#line 243
    grent = getgrgid((gid_t )gid);
    }
#line 244
    if ((unsigned long )group == (unsigned long )temp_str) {
      {
#line 246
      output_error("Group %s does not exist\n", group);
      }
#line 247
      return ((gid_t )-1);
    } else
#line 244
    if ((unsigned long )grent == (unsigned long )((void *)0)) {
      {
#line 246
      output_error("Group %s does not exist\n", group);
      }
#line 247
      return ((gid_t )-1);
    }
  }
  {
#line 250
  output_info("group \'%s\' has gid %d", group, grent->gr_gid);
  }
#line 251
  return (grent->gr_gid);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 18 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/output.h"
int output_level ;
#line 20
void output_version(void) ;
#line 21
void output_help(void) ;
#line 26 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/output.c"
int output_level  =    1;
#line 34 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/output.c"
void output_version(void) 
{ 


  {
  {
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s version %d.%d.%s\n",
          "quotatool", 1, 4, "12");
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s\n",
          "Copyright (c) 1999-2012 Mike Glover / Johan Ekenberg");
#line 38
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Distributed under the GNU General Public License\n");
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s\n",
          "http://quotatool.ekenberg.se");
  }
#line 40
  return;
}
}
#line 48 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/output.c"
void output_help(void) 
{ 


  {
  {
#line 50
  output_version();
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUsage: quotatool -u uid | -g gid options [...] filesystem\n");
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       quotatool -u | -g -i | -b  -t time filesystem\n");
#line 53
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -b      : set block limits\n");
#line 55
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -i      : set inode limits\n");
#line 56
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -q n    : set soft limit to n blocks/inodes\n");
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -l n    : set hard limit to n blocks/inodes\n");
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t time : set global grace period to time\n");
#line 59
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -r      : restart grace period for uid or gid\n");
#line 60
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -R      : raise-only, never lower quotas for uid/gid\n");
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d      : dump quota info in machine readable format (see manpage)\n");
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h      : show this help\n");
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v      : be verbose (twice or thrice for debugging)\n");
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -V      : show version\n");
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -n      : do nothing (useful with -v)\n");
  }
#line 66
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/output.c"
__inline static void _output(int level , char const   *format , va_list arglist ) 
{ 


  {
#line 77
  if (level <= output_level) {
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            "quotatool");
#line 79
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             arglist);
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 82
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/output.c"
void output_error(char const   *format  , ...) 
{ 
  va_list arglist ;

  {
  {
#line 86
  __builtin_va_start(arglist, format);
#line 87
  _output(1, format, arglist);
#line 88
  __builtin_va_end(arglist);
  }
#line 89
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/output.c"
void output_info(char const   *format  , ...) 
{ 
  va_list arglist ;

  {
  {
#line 93
  __builtin_va_start(arglist, format);
#line 94
  _output(2, format, arglist);
#line 95
  __builtin_va_end(arglist);
  }
#line 96
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/output.c"
void output_debug(char const   *format  , ...) 
{ 
  va_list arglist ;

  {
  {
#line 100
  __builtin_va_start(arglist, format);
#line 101
  _output(3, format, arglist);
#line 102
  __builtin_va_end(arglist);
  }
#line 103
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 40 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/parse.h"
argdata_t *parse_commandline(int argc , char **argv ) ;
#line 41
time_t parse_timespan(time_t orig , char *string ) ;
#line 42
u_int64_t parse_size(u_int64_t orig , char *string ) ;
#line 78 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/quota.h"
quota_t *quota_new(int q_type , int id , char *fs_spec ) ;
#line 79
void quota_delete(quota_t *myquota ) ;
#line 81
int quota_get(quota_t *myquota ) ;
#line 82
int quota_set(quota_t *myquota ) ;
#line 50 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/main.c"
extern int ( /* missing proto */  isdigit)() ;
#line 208
int xfs_reset_grace(quota_t *myquota , int grace_type ) ;
#line 27 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/main.c"
int main(int argc , char **argv ) 
{ 
  u_int64_t block_sav ;
  u_int64_t inode_sav ;
  u_int64_t old_quota ;
  int id ;
  time_t old_grace ;
  argdata_t *argdata ;
  quota_t *quota ;
  char *tmpstr ;
  long tmp ;
  uid_t tmp___0 ;
  gid_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  time_t now ;
  time_t tmp___5 ;
  u_int64_t display_blocks_used ;
  char const   *tmp___6 ;
  time_t tmp___7 ;
  time_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 39
  argdata = parse_commandline(argc, argv);
  }
#line 40
  if (! argdata) {
    {
#line 41
    exit(1);
    }
  }
#line 46
  if (! argdata->id) {
#line 47
    id = 0;
  } else {
    {
#line 50
    tmp___2 = strlen((char const   *)argdata->id);
    }
#line 50
    if (tmp___2 > 1UL) {
#line 50
      if ((int )*(argdata->id + 0) == 58) {
        {
#line 50
        tmp___3 = isdigit((int )*(argdata->id + 1));
        }
#line 50
        if (tmp___3) {
          {
#line 51
          (argdata->id) ++;
#line 52
          tmp = strtol((char const   */* __restrict  */)argdata->id, (char **/* __restrict  */)(& tmpstr),
                       10);
#line 52
          id = (int )tmp;
          }
        } else {
#line 50
          goto _L___0;
        }
      } else {
#line 50
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 54
    if ((int )argdata->id_type == 1) {
      {
#line 55
      tmp___0 = system_getuid(argdata->id);
#line 55
      id = (int )tmp___0;
      }
    } else {
      {
#line 58
      tmp___1 = system_getgid(argdata->id);
#line 58
      id = (int )tmp___1;
      }
    }
  }
#line 60
  if (id < 0) {
    {
#line 61
    exit(2);
    }
  }
  {
#line 66
  quota = quota_new((int )argdata->id_type, id, argdata->qfile);
  }
#line 67
  if (! quota) {
    {
#line 68
    exit(3);
    }
  }
  {
#line 71
  tmp___4 = quota_get(quota);
  }
#line 71
  if (! tmp___4) {
    {
#line 72
    exit(3);
    }
  }
#line 75
  if (argdata->dump_info) {
    {
#line 76
    tmp___5 = time((time_t *)((void *)0));
#line 76
    now = tmp___5;
#line 77
    display_blocks_used = (u_int64_t )0;
#line 79
    output_info("");
    }
#line 80
    if ((int )argdata->id_type == 1) {
#line 80
      tmp___6 = "uid";
    } else {
#line 80
      tmp___6 = "gid";
    }
    {
#line 80
    output_info("%s Filesystem blocks quota limit grace files quota limit grace",
                tmp___6);
#line 84
    display_blocks_used = quota->diskspace_used / 1024UL;
    }
#line 85
    if (quota->diskspace_used % 1024UL != 0UL) {
#line 85
      display_blocks_used ++;
    }
#line 87
    if ((unsigned long )quota->inode_time) {
#line 87
      tmp___7 = quota->inode_time - now;
    } else {
#line 87
      tmp___7 = (time_t )0;
    }
#line 87
    if ((unsigned long )quota->block_time) {
#line 87
      tmp___8 = quota->block_time - now;
    } else {
#line 87
      tmp___8 = (time_t )0;
    }
    {
#line 87
    printf((char const   */* __restrict  */)"%d %s %lu %lu %lu %lu %lu %lu %lu%lu\n",
           id, argdata->qfile, display_blocks_used, quota->block_soft, quota->block_hard,
           tmp___8, quota->inode_used, quota->inode_soft, quota->inode_hard, tmp___7);
#line 101
    exit(0);
    }
  }
  {
#line 105
  output_info("");
#line 106
  output_info("%-14s %-16s %-16s", "Limit", "Old", "New");
#line 107
  output_info("%-14s %-16s %-16s", "-----", "---", "---");
  }
#line 115
  if (argdata->block_grace) {
    {
#line 116
    old_grace = quota->block_grace;
#line 117
    quota->block_grace = parse_timespan(old_grace, argdata->block_grace);
#line 118
    quota->_do_set_global_block_gracetime = 1;
#line 119
    output_info("%-14s %-16d %-16d", "block grace:", old_grace, quota->block_grace);
    }
  }
#line 122
  if (argdata->inode_grace) {
    {
#line 123
    old_grace = quota->inode_grace;
#line 124
    quota->inode_grace = parse_timespan(old_grace, argdata->inode_grace);
#line 125
    quota->_do_set_global_inode_gracetime = 1;
#line 126
    output_info("%-14s %-16d %-16d", "inode grace:", old_grace, quota->inode_grace);
    }
  }
#line 138
  if (argdata->block_hard) {
    {
#line 139
    old_quota = quota->block_hard;
#line 140
    quota->block_hard = parse_size(old_quota, argdata->block_hard);
    }
#line 141
    if (quota->block_hard < 0UL) {
      {
#line 142
      exit(2);
      }
    }
#line 144
    if (argdata->raise_only) {
#line 144
      if (quota->block_hard <= old_quota) {
        {
#line 145
        output_info("New block quota not higher than current, won\'t change");
#line 146
        quota->block_hard = old_quota;
        }
      }
    }
    {
#line 148
    output_info("%-14s %-16llu %llu", "block hard:", old_quota, quota->block_hard);
    }
  }
#line 151
  if (argdata->block_soft) {
    {
#line 152
    old_quota = quota->block_soft;
#line 153
    quota->block_soft = parse_size(old_quota, argdata->block_soft);
    }
#line 154
    if (quota->block_soft < 0UL) {
      {
#line 155
      exit(2);
      }
    }
#line 157
    if (argdata->raise_only) {
#line 157
      if (quota->block_soft <= old_quota) {
        {
#line 158
        output_info("New block soft limit not higher than current, won\'t change");
#line 159
        quota->block_soft = old_quota;
        }
      }
    }
    {
#line 161
    output_info("%-14s %-16llu %-16llu", "block soft:", old_quota, quota->block_soft);
    }
  }
#line 164
  if (argdata->inode_hard) {
    {
#line 165
    old_quota = quota->inode_hard;
#line 166
    quota->inode_hard = parse_size(old_quota, argdata->inode_hard);
    }
#line 167
    if (quota->inode_hard < 0UL) {
      {
#line 168
      exit(2);
      }
    }
#line 170
    if (argdata->raise_only) {
#line 170
      if (quota->inode_hard <= old_quota) {
        {
#line 171
        output_info("New inode quota not higher than current, won\'t change");
#line 172
        quota->inode_hard = old_quota;
        }
      }
    }
    {
#line 174
    output_info("%-14s %-16llu %-16llu", "inode hard:", old_quota, quota->inode_hard);
    }
  }
#line 177
  if (argdata->inode_soft) {
    {
#line 178
    old_quota = quota->inode_soft;
#line 179
    quota->inode_soft = parse_size(old_quota, argdata->inode_soft);
    }
#line 180
    if (quota->inode_soft < 0UL) {
      {
#line 181
      exit(2);
      }
    }
#line 183
    if (argdata->raise_only) {
#line 183
      if (quota->inode_soft <= old_quota) {
        {
#line 184
        output_info("New inode soft limit not higher than current, won\'t change");
#line 185
        quota->inode_soft = old_quota;
        }
      }
    }
    {
#line 187
    output_info("%-14s %-16llu %-16llu", "inode_soft:", old_quota, quota->inode_soft);
    }
  }
#line 204
  if (argdata->block_reset) {
#line 204
    goto _L___1;
  } else
#line 204
  if (argdata->inode_reset) {
    _L___1: /* CIL Label */ 
#line 205
    block_sav = quota->diskspace_used;
#line 206
    inode_sav = quota->inode_used;
#line 207
    if (argdata->block_reset) {
#line 207
      if (! argdata->noaction) {
        {
#line 208
        xfs_reset_grace(quota, 1);
#line 209
        quota->diskspace_used = quota->block_soft - 1UL;
        }
      }
    }
#line 211
    if (argdata->inode_reset) {
#line 211
      if (! argdata->noaction) {
        {
#line 212
        xfs_reset_grace(quota, 2);
#line 213
        quota->inode_used = quota->inode_soft - 1UL;
        }
      }
    }
#line 215
    if (! argdata->noaction) {
      {
#line 216
      tmp___9 = quota_set(quota);
      }
#line 216
      if (! tmp___9) {
        {
#line 217
        exit(3);
        }
      }
    }
#line 220
    quota->diskspace_used = block_sav;
#line 221
    quota->inode_used = inode_sav;
  }
#line 229
  if (! argdata->noaction) {
    {
#line 230
    tmp___10 = quota_set(quota);
    }
#line 230
    if (! tmp___10) {
      {
#line 231
      exit(3);
      }
    }
  }
  {
#line 235
  quota_delete(quota);
#line 236
  exit(0);
  }
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 120 "./src/linux/linux_quota.h"
extern long quotactl(int  , char const   * , qid_t  , caddr_t  ) ;
#line 134
int kern_quota_format(fs_t *fs , int q_type ) ;
#line 37 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int quota_format  ;
#line 38 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int kernel_iface  ;
#line 40
static int v1_quota_get(quota_t *myquota ) ;
#line 41
static int v1_quota_set(quota_t *myquota ) ;
#line 42
static int v2_quota_get(quota_t *myquota ) ;
#line 43
static int v2_quota_set(quota_t *myquota ) ;
#line 44
static int generic_quota_get(quota_t *myquota ) ;
#line 45
static int generic_quota_set(quota_t *myquota ) ;
#line 46
static int xfs_quota_get(quota_t *myquota ) ;
#line 47
static int xfs_quota_set(quota_t *myquota ) ;
#line 50 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
quota_t *quota_new(int q_type , int id , char *fs_spec ) 
{ 
  quota_t *myquota ;
  fs_t *fs ;
  char *qfile ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 56
  q_type --;
#line 57
  if (q_type >= 2) {
    {
#line 58
    output_error("Unknown quota type: %d", q_type);
    }
#line 59
    return ((quota_t *)0);
  }
  {
#line 62
  tmp = malloc(sizeof(quota_t ));
#line 62
  myquota = (quota_t *)tmp;
  }
#line 63
  if (! myquota) {
    {
#line 64
    output_error("Insufficient memory");
#line 65
    exit(4);
    }
  }
  {
#line 68
  fs = system_getfs(fs_spec);
  }
#line 69
  if (! fs) {
#line 70
    return ((quota_t *)((void *)0));
  }
  {
#line 76
  output_debug("Detecting quota format");
#line 77
  tmp___0 = kern_quota_format(fs, q_type);
  }
#line 77
  if (tmp___0 == -1) {
    {
#line 78
    output_error("Can\'t determine quota format!");
#line 79
    exit(3);
    }
  }
#line 81
  if (quota_format == -2) {
    {
#line 82
    output_error("Quota format too new (?)");
#line 83
    exit(3);
    }
  }
#line 85
  if (quota_format & (1 << 3)) {
    {
#line 86
    output_debug("Detected quota format: XFS");
    }
  }
#line 88
  if (quota_format & (1 << 1)) {
    {
#line 89
    output_debug("Detected quota format: NEW");
    }
#line 90
    if (kernel_iface == 3) {
      {
#line 91
      output_debug("Detected quota interface: GENERIC");
      }
    } else {
      {
#line 94
      myquota->_v2_quotainfo = (void *)((struct v2_kern_dqinfo *)0);
#line 95
      tmp___1 = malloc(sizeof(struct v2_kern_dqinfo ));
#line 95
      myquota->_v2_quotainfo = (void *)((struct v2_kern_dqinfo *)tmp___1);
      }
#line 96
      if (! myquota->_v2_quotainfo) {
        {
#line 97
        output_error("Insufficient memory");
#line 98
        exit(4);
        }
      }
    }
  } else
#line 102
  if (quota_format & 1) {
    {
#line 103
    output_debug("Detected quota format: OLD");
    }
#line 104
    if (kernel_iface == 3) {
      {
#line 105
      output_debug("Detected quota interface: GENERIC");
      }
    }
  } else
#line 108
  if (! (quota_format & (1 << 3))) {
    {
#line 109
    output_error("Unknown quota format!");
#line 110
    exit(3);
    }
  }
#line 112
  if (kernel_iface == 3) {
    {
#line 113
    myquota->_generic_quotainfo = (void *)((struct if_dqinfo *)0);
#line 114
    tmp___2 = malloc(sizeof(struct if_dqinfo ));
#line 114
    myquota->_generic_quotainfo = (void *)((struct if_dqinfo *)tmp___2);
    }
#line 115
    if (! myquota->_generic_quotainfo) {
      {
#line 116
      output_error("Insufficient memory");
#line 117
      exit(4);
      }
    }
  }
  {
#line 121
  qfile = strdup((char const   *)(fs->device));
#line 123
  myquota->_id = id;
#line 124
  myquota->_id_type = q_type;
#line 125
  myquota->_qfile = qfile;
#line 127
  free((void *)fs);
  }
#line 128
  return (myquota);
}
}
#line 131 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
void quota_delete(quota_t *myquota ) 
{ 


  {
  {
#line 132
  free((void *)myquota->_qfile);
  }
#line 133
  if (kernel_iface == 3) {
    {
#line 134
    free(myquota->_generic_quotainfo);
    }
  } else
#line 136
  if (quota_format & (1 << 1)) {
    {
#line 137
    free(myquota->_v2_quotainfo);
    }
  }
  {
#line 140
  free((void *)myquota);
  }
#line 141
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
int quota_get(quota_t *myquota ) 
{ 
  int retval ;

  {
  {
#line 146
  output_debug("fetching quotas: device=\'%s\',id=\'%d\'", myquota->_qfile, myquota->_id);
  }
#line 148
  if (quota_format & (1 << 3)) {
    {
#line 149
    retval = xfs_quota_get(myquota);
    }
  } else
#line 151
  if (kernel_iface == 3) {
    {
#line 152
    retval = generic_quota_get(myquota);
    }
  } else
#line 154
  if (quota_format & (1 << 1)) {
    {
#line 155
    retval = v2_quota_get(myquota);
    }
  } else {
    {
#line 158
    retval = v1_quota_get(myquota);
    }
  }
#line 160
  return (retval);
}
}
#line 163 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int v1_quota_get(quota_t *myquota ) 
{ 
  struct v1_kern_dqblk sysquota ;
  int retval ;
  long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 167
  tmp = quotactl((768 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                 (qid_t )myquota->_id, (caddr_t )(& sysquota));
#line 167
  retval = (int )tmp;
  }
#line 169
  if (retval < 0) {
    {
#line 170
    tmp___0 = __errno_location();
#line 170
    tmp___1 = strerror(*tmp___0);
#line 170
    output_error("Failed fetching quotas (v1): %s", tmp___1);
    }
#line 171
    return (0);
  }
#line 175
  myquota->block_hard = (u_int64_t )sysquota.dqb_bhardlimit;
#line 176
  myquota->block_soft = (u_int64_t )sysquota.dqb_bsoftlimit;
#line 177
  myquota->diskspace_used = (u_int64_t )sysquota.dqb_curblocks;
#line 178
  myquota->inode_hard = (u_int64_t )sysquota.dqb_ihardlimit;
#line 179
  myquota->inode_soft = (u_int64_t )sysquota.dqb_isoftlimit;
#line 180
  myquota->inode_used = (u_int64_t )sysquota.dqb_curinodes;
#line 181
  myquota->block_time = sysquota.dqb_btime;
#line 182
  myquota->inode_time = sysquota.dqb_itime;
#line 186
  myquota->block_grace = sysquota.dqb_btime;
#line 187
  myquota->inode_grace = sysquota.dqb_itime;
#line 189
  return (1);
}
}
#line 192 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int v2_quota_get(quota_t *myquota ) 
{ 
  struct v2_kern_dqblk sysquota ;
  int retval ;
  long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 196
  tmp = quotactl((3328 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                 (qid_t )myquota->_id, (caddr_t )(& sysquota));
#line 196
  retval = (int )tmp;
  }
#line 198
  if (retval < 0) {
    {
#line 199
    tmp___0 = __errno_location();
#line 199
    tmp___1 = strerror(*tmp___0);
#line 199
    output_error("Failed fetching quotas (v2): %s", tmp___1);
    }
#line 200
    return (0);
  }
  {
#line 204
  myquota->block_hard = (u_int64_t )sysquota.dqb_bhardlimit;
#line 205
  myquota->block_soft = (u_int64_t )sysquota.dqb_bsoftlimit;
#line 206
  myquota->diskspace_used = sysquota.dqb_curspace;
#line 207
  myquota->inode_hard = (u_int64_t )sysquota.dqb_ihardlimit;
#line 208
  myquota->inode_soft = (u_int64_t )sysquota.dqb_isoftlimit;
#line 209
  myquota->inode_used = (u_int64_t )sysquota.dqb_curinodes;
#line 210
  myquota->block_time = sysquota.dqb_btime;
#line 211
  myquota->inode_time = sysquota.dqb_itime;
#line 213
  tmp___2 = quotactl((2304 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                     (qid_t )myquota->_id, (caddr_t )myquota->_v2_quotainfo);
#line 213
  retval = (int )tmp___2;
  }
#line 215
  if (retval < 0) {
    {
#line 216
    tmp___3 = __errno_location();
#line 216
    tmp___4 = strerror(*tmp___3);
#line 216
    output_error("Failed fetching quotainfo: %s", tmp___4);
    }
#line 217
    return (0);
  }
#line 219
  myquota->block_grace = (time_t )((struct v2_kern_dqinfo *)myquota->_v2_quotainfo)->dqi_bgrace;
#line 220
  myquota->inode_grace = (time_t )((struct v2_kern_dqinfo *)myquota->_v2_quotainfo)->dqi_igrace;
#line 222
  return (1);
}
}
#line 225 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int generic_quota_get(quota_t *myquota ) 
{ 
  struct if_dqblk sysquota ;
  long retval ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 228
  retval = quotactl((8388615 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                    (qid_t )myquota->_id, (caddr_t )(& sysquota));
  }
#line 230
  if (retval < 0L) {
    {
#line 231
    tmp = __errno_location();
#line 231
    tmp___0 = strerror(*tmp);
#line 231
    output_error("Failed fetching quotas (generic): %s", tmp___0);
    }
#line 232
    return (0);
  }
  {
#line 236
  myquota->block_hard = sysquota.dqb_bhardlimit;
#line 237
  myquota->block_soft = sysquota.dqb_bsoftlimit;
#line 238
  myquota->diskspace_used = sysquota.dqb_curspace;
#line 239
  myquota->inode_hard = sysquota.dqb_ihardlimit;
#line 240
  myquota->inode_soft = sysquota.dqb_isoftlimit;
#line 241
  myquota->inode_used = sysquota.dqb_curinodes;
#line 242
  myquota->block_time = (time_t )sysquota.dqb_btime;
#line 243
  myquota->inode_time = (time_t )sysquota.dqb_itime;
#line 245
  retval = quotactl((8388613 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                    (qid_t )myquota->_id, (caddr_t )myquota->_generic_quotainfo);
  }
#line 247
  if (retval < 0L) {
    {
#line 248
    tmp___1 = __errno_location();
#line 248
    tmp___2 = strerror(*tmp___1);
#line 248
    output_error("Failed fetching quotainfo (generic): %s", tmp___2);
    }
#line 249
    return (0);
  }
#line 251
  myquota->block_grace = (time_t )((struct if_dqinfo *)myquota->_generic_quotainfo)->dqi_bgrace;
#line 252
  myquota->inode_grace = (time_t )((struct if_dqinfo *)myquota->_generic_quotainfo)->dqi_igrace;
#line 254
  return (1);
}
}
#line 257 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int xfs_quota_get(quota_t *myquota ) 
{ 
  fs_disk_quota_t sysquota ;
  fs_quota_stat_t quotastat ;
  int block_diff ;
  int retval ;
  long tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 263
  block_diff = 2;
#line 264
  tmp = quotactl((((88 << 8) + 3) << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                 (qid_t )myquota->_id, (caddr_t )(& sysquota));
#line 264
  retval = (int )tmp;
  }
#line 271
  if (retval < 0) {
    {
#line 276
    tmp___0 = __errno_location();
    }
#line 276
    if (*tmp___0 == 2) {
#line 277
      myquota->block_hard = (u_int64_t )0;
#line 278
      myquota->block_soft = (u_int64_t )0;
#line 279
      myquota->diskspace_used = (u_int64_t )0;
#line 280
      myquota->inode_hard = (u_int64_t )0;
#line 281
      myquota->inode_soft = (u_int64_t )0;
#line 282
      myquota->inode_used = (u_int64_t )0;
#line 283
      myquota->block_grace = (time_t )0;
#line 284
      myquota->inode_grace = (time_t )0;
#line 285
      myquota->block_time = (time_t )0;
#line 286
      myquota->inode_time = (time_t )0;
#line 287
      return (1);
    }
    {
#line 289
    tmp___1 = __errno_location();
#line 289
    tmp___2 = strerror(*tmp___1);
#line 289
    tmp___3 = __errno_location();
#line 289
    output_error("Failed fetching quotas: errno=%d, %s", *tmp___3, tmp___2);
    }
#line 290
    return (0);
  }
  {
#line 293
  tmp___4 = quotactl((((88 << 8) + 5) << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                     (qid_t )myquota->_id, (caddr_t )(& quotastat));
#line 293
  retval = (int )tmp___4;
#line 297
  myquota->block_hard = (u_int64_t )(sysquota.d_blk_hardlimit / (__u64 )block_diff);
#line 298
  myquota->block_soft = (u_int64_t )(sysquota.d_blk_softlimit / (__u64 )block_diff);
#line 299
  myquota->diskspace_used = (u_int64_t )((sysquota.d_bcount / (__u64 )block_diff) * 1024ULL);
#line 300
  myquota->inode_hard = (u_int64_t )sysquota.d_ino_hardlimit;
#line 301
  myquota->inode_soft = (u_int64_t )sysquota.d_ino_softlimit;
#line 302
  myquota->inode_used = (u_int64_t )sysquota.d_icount;
#line 303
  myquota->block_grace = (time_t )quotastat.qs_btimelimit;
#line 304
  myquota->inode_grace = (time_t )quotastat.qs_itimelimit;
#line 305
  myquota->block_time = (time_t )sysquota.d_btimer;
#line 306
  myquota->inode_time = (time_t )sysquota.d_itimer;
  }
#line 308
  return (1);
}
}
#line 311 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
int quota_set(quota_t *myquota ) 
{ 
  int retval ;
  __uid_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 314
  tmp = geteuid();
  }
#line 314
  if (tmp != 0U) {
    {
#line 315
    output_error("Only root can set quotas");
    }
#line 316
    return (0);
  }
#line 320
  if (quota_format & (1 << 3)) {
    {
#line 321
    retval = xfs_quota_set(myquota);
    }
  } else
#line 323
  if (kernel_iface == 3) {
    {
#line 324
    retval = generic_quota_set(myquota);
    }
  } else
#line 326
  if (quota_format & (1 << 1)) {
    {
#line 327
    retval = v2_quota_set(myquota);
    }
  } else {
    {
#line 330
    retval = v1_quota_set(myquota);
    }
  }
#line 333
  if (! retval) {
#line 334
    return (retval);
  }
#line 335
  if (quota_format & (1 << 3)) {
#line 336
    return (1);
  }
#line 339
  if (kernel_iface == 3) {
#line 339
    tmp___0 = 8388609;
  } else {
#line 339
    tmp___0 = 1536;
  }
  {
#line 339
  tmp___1 = quotactl((tmp___0 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                     (qid_t )0, (caddr_t )((void *)0));
#line 339
  retval = (int )tmp___1;
  }
#line 342
  if (retval < 0) {
    {
#line 343
    tmp___2 = __errno_location();
#line 343
    tmp___3 = strerror(*tmp___2);
#line 343
    output_error("Failed syncing quotas on %s: %s", myquota->_qfile, tmp___3);
    }
#line 345
    return (0);
  }
#line 347
  return (1);
}
}
#line 350 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int generic_quota_set(quota_t *myquota ) 
{ 
  struct if_dqblk sysquota ;
  int retval ;
  long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct if_dqinfo *foo ;
  long tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 355
  sysquota.dqb_bhardlimit = myquota->block_hard;
#line 356
  sysquota.dqb_bsoftlimit = myquota->block_soft;
#line 357
  sysquota.dqb_curspace = myquota->diskspace_used;
#line 358
  sysquota.dqb_ihardlimit = myquota->inode_hard;
#line 359
  sysquota.dqb_isoftlimit = myquota->inode_soft;
#line 360
  sysquota.dqb_curinodes = myquota->inode_used;
#line 363
  sysquota.dqb_valid = (u_int32_t )5;
#line 365
  tmp = quotactl((8388616 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                 (qid_t )myquota->_id, (caddr_t )(& sysquota));
#line 365
  retval = (int )tmp;
  }
#line 367
  if (retval < 0) {
    {
#line 368
    tmp___0 = __errno_location();
#line 368
    tmp___1 = strerror(*tmp___0);
#line 368
    output_error("Failed setting quota (generic): %s", tmp___1);
    }
#line 369
    return (0);
  }
#line 372
  if (myquota->_do_set_global_block_gracetime) {
#line 372
    goto _L;
  } else
#line 372
  if (myquota->_do_set_global_inode_gracetime) {
    _L: /* CIL Label */ 
#line 373
    foo = (struct if_dqinfo *)myquota->_generic_quotainfo;
#line 374
    if (myquota->_do_set_global_block_gracetime) {
#line 375
      foo->dqi_bgrace = (u_int64_t )myquota->block_grace;
    }
#line 376
    if (myquota->_do_set_global_inode_gracetime) {
#line 377
      foo->dqi_igrace = (u_int64_t )myquota->inode_grace;
    }
    {
#line 378
    tmp___2 = quotactl((8388614 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                       (qid_t )myquota->_id, (caddr_t )myquota->_generic_quotainfo);
#line 378
    retval = (int )tmp___2;
    }
#line 380
    if (retval < 0) {
      {
#line 381
      tmp___3 = __errno_location();
#line 381
      tmp___4 = strerror(*tmp___3);
#line 381
      output_error("Failed setting gracetime (generic): %s", tmp___4);
      }
#line 382
      return (0);
    }
  }
#line 386
  return (1);
}
}
#line 389 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int v2_quota_set(quota_t *myquota ) 
{ 
  struct v2_kern_dqblk sysquota ;
  int retval ;
  long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 394
  sysquota.dqb_bhardlimit = (unsigned int )myquota->block_hard;
#line 395
  sysquota.dqb_bsoftlimit = (unsigned int )myquota->block_soft;
#line 396
  sysquota.dqb_curspace = myquota->diskspace_used;
#line 397
  sysquota.dqb_ihardlimit = (unsigned int )myquota->inode_hard;
#line 398
  sysquota.dqb_isoftlimit = (unsigned int )myquota->inode_soft;
#line 399
  sysquota.dqb_curinodes = (unsigned int )myquota->inode_used;
#line 404
  tmp = quotactl((3584 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                 (qid_t )myquota->_id, (caddr_t )(& sysquota));
#line 404
  retval = (int )tmp;
  }
#line 406
  if (retval < 0) {
    {
#line 407
    tmp___0 = __errno_location();
#line 407
    tmp___1 = strerror(*tmp___0);
#line 407
    output_error("Failed setting quota (v2): %s", tmp___1);
    }
#line 408
    return (0);
  }
#line 412
  if (myquota->_do_set_global_block_gracetime) {
#line 412
    goto _L;
  } else
#line 412
  if (myquota->_do_set_global_inode_gracetime) {
    _L: /* CIL Label */ 
#line 413
    if (myquota->_do_set_global_block_gracetime) {
#line 414
      ((struct v2_kern_dqinfo *)myquota->_v2_quotainfo)->dqi_bgrace = (unsigned int )myquota->block_grace;
    }
#line 415
    if (myquota->_do_set_global_inode_gracetime) {
#line 416
      ((struct v2_kern_dqinfo *)myquota->_v2_quotainfo)->dqi_igrace = (unsigned int )myquota->inode_grace;
    }
    {
#line 417
    tmp___2 = quotactl((2816 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                       (qid_t )myquota->_id, (caddr_t )myquota->_v2_quotainfo);
#line 417
    retval = (int )tmp___2;
    }
#line 419
    if (retval < 0) {
      {
#line 420
      tmp___3 = __errno_location();
#line 420
      tmp___4 = strerror(*tmp___3);
#line 420
      output_error("Failed setting gracetime: %s", tmp___4);
      }
#line 421
      return (0);
    }
  }
#line 425
  return (1);
}
}
#line 428 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int v1_quota_set(quota_t *myquota ) 
{ 
  struct v1_kern_dqblk sysquota ;
  int retval ;
  long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 433
  sysquota.dqb_bhardlimit = (u_int32_t )myquota->block_hard;
#line 434
  sysquota.dqb_bsoftlimit = (u_int32_t )myquota->block_soft;
#line 435
  sysquota.dqb_curblocks = (u_int32_t )myquota->diskspace_used;
#line 436
  sysquota.dqb_ihardlimit = (u_int32_t )myquota->inode_hard;
#line 437
  sysquota.dqb_isoftlimit = (u_int32_t )myquota->inode_soft;
#line 438
  sysquota.dqb_curinodes = (u_int32_t )myquota->inode_used;
#line 440
  sysquota.dqb_btime = myquota->block_grace;
#line 441
  sysquota.dqb_itime = myquota->inode_grace;
#line 444
  tmp = quotactl((1024 << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                 (qid_t )myquota->_id, (caddr_t )(& sysquota));
#line 444
  retval = (int )tmp;
  }
#line 446
  if (retval < 0) {
    {
#line 447
    tmp___0 = __errno_location();
#line 447
    tmp___1 = strerror(*tmp___0);
#line 447
    output_error("Failed setting quota (v1): %s", tmp___1);
    }
#line 448
    return (0);
  }
#line 451
  return (1);
}
}
#line 454 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
static int xfs_quota_set(quota_t *myquota ) 
{ 
  fs_disk_quota_t sysquota ;
  int retval ;
  int block_diff ;
  long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 457
  block_diff = 2;
#line 459
  memset((void *)(& sysquota), 0, sizeof(fs_disk_quota_t ));
#line 461
  sysquota.d_blk_hardlimit = (__u64 )(myquota->block_hard * (u_int64_t )block_diff);
#line 462
  sysquota.d_blk_softlimit = (__u64 )(myquota->block_soft * (u_int64_t )block_diff);
#line 463
  sysquota.d_bcount = (__u64 )((myquota->diskspace_used * (u_int64_t )block_diff) / 1024UL);
#line 464
  sysquota.d_ino_hardlimit = (__u64 )myquota->inode_hard;
#line 465
  sysquota.d_ino_softlimit = (__u64 )myquota->inode_soft;
#line 466
  sysquota.d_icount = (__u64 )myquota->inode_used;
#line 468
  sysquota.d_btimer = (__s32 )myquota->block_grace;
#line 469
  sysquota.d_itimer = (__s32 )myquota->inode_grace;
#line 470
  sysquota.d_fieldmask = (__u16 )(((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5));
  }
#line 471
  if (myquota->_do_set_global_block_gracetime) {
#line 472
    sysquota.d_fieldmask = (__u16 )((int )sysquota.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
  } else
#line 471
  if (myquota->_do_set_global_inode_gracetime) {
#line 472
    sysquota.d_fieldmask = (__u16 )((int )sysquota.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
  }
  {
#line 474
  tmp = quotactl((((88 << 8) + 4) << 8) | (myquota->_id_type & 255), (char const   *)myquota->_qfile,
                 (qid_t )myquota->_id, (caddr_t )(& sysquota));
#line 474
  retval = (int )tmp;
  }
#line 476
  if (retval < 0) {
    {
#line 477
    tmp___0 = __errno_location();
#line 477
    tmp___1 = strerror(*tmp___0);
#line 477
    output_error("Failed setting quota (xfs): %s", tmp___1);
    }
#line 478
    return (0);
  }
#line 482
  return (1);
}
}
#line 490 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
int kern_quota_format(fs_t *fs , int q_type ) 
{ 
  u_int32_t version ;
  struct v2_dqstats v2_stats ;
  FILE *f ;
  int ret ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int actfmt ;
  int retval ;
  long tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int err_stat ;
  int err_quota ;
  char tmp___7[1024] ;
  int *tmp___8 ;
  long tmp___9 ;
  int *tmp___10 ;
  long tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;

  {
  {
#line 494
  ret = 0;
#line 497
  tmp___0 = strcasecmp((char const   *)(fs->mnt_type), "xfs");
  }
#line 497
  if (tmp___0 == 0) {
    {
#line 498
    tmp = stat((char const   */* __restrict  */)"/proc/fs/xfs/stat", (struct stat */* __restrict  */)(& st));
    }
#line 498
    if (tmp == 0) {
#line 499
      quota_format |= 1 << 3;
#line 500
      return (ret);
    } else {
      {
#line 503
      output_error("%s is mounted as XFS but no kernel support for XFS quota!", fs->device);
#line 504
      exit(3);
      }
    }
  }
  {
#line 508
  f = fopen((char const   */* __restrict  */)"/proc/fs/quota", (char const   */* __restrict  */)"r");
  }
#line 508
  if (f) {
    {
#line 509
    tmp___1 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Version %u",
                     & version);
    }
#line 509
    if (tmp___1 != 1) {
      {
#line 510
      fclose(f);
      }
#line 511
      return (-2);
    }
    {
#line 513
    fclose(f);
    }
  } else {
    {
#line 515
    tmp___18 = stat((char const   */* __restrict  */)"/proc/sys/fs/quota", (struct stat */* __restrict  */)(& st));
    }
#line 515
    if (tmp___18 == 0) {
      {
#line 518
      kernel_iface = 3;
#line 519
      tmp___2 = quotactl((8388612 << 8) | (q_type & 255), (char const   *)(fs->device),
                         (qid_t )0, (caddr_t )((void *)(& actfmt)));
#line 519
      retval = (int )tmp___2;
      }
#line 520
      if (retval < 0) {
#line 521
        if (! (quota_format & (1 << 3))) {
          {
#line 522
          tmp___3 = __errno_location();
#line 522
          tmp___4 = strerror(*tmp___3);
#line 522
          output_error("Error while detecting kernel quota version: %s\n", tmp___4);
#line 523
          exit(3);
          }
        }
      } else
#line 527
      if (actfmt == 1) {
#line 528
        quota_format |= 1;
      } else
#line 529
      if (actfmt == 2) {
#line 530
        quota_format |= 1 << 1;
      } else {
#line 532
        return (-1);
      }
#line 534
      return (ret);
    } else {
      {
#line 536
      tmp___17 = quotactl(4352 << 8, (char const   *)((void *)0), (qid_t )0, (caddr_t )((void *)(& v2_stats)));
      }
#line 536
      if (tmp___17 >= 0L) {
#line 537
        version = v2_stats.version;
      } else {
        {
#line 540
        tmp___5 = __errno_location();
        }
#line 540
        if (*tmp___5 == 38) {
#line 541
          return (-1);
        } else {
          {
#line 540
          tmp___6 = __errno_location();
          }
#line 540
          if (*tmp___6 == 95) {
#line 541
            return (-1);
          }
        }
        {
#line 542
        tmp___12 = __errno_location();
        }
#line 542
        if (*tmp___12 == 22) {
#line 542
          goto _L;
        } else {
          {
#line 542
          tmp___13 = __errno_location();
          }
#line 542
          if (*tmp___13 == 14) {
#line 542
            goto _L;
          } else {
            {
#line 542
            tmp___14 = __errno_location();
            }
#line 542
            if (*tmp___14 == 1) {
              _L: /* CIL Label */ 
              {
#line 546
              err_stat = 0;
#line 547
              err_quota = 0;
#line 550
              tmp___9 = quotactl(2048 << 8, (char const   *)((void *)0), (qid_t )0,
                                 tmp___7);
              }
#line 550
              if (tmp___9) {
                {
#line 551
                tmp___8 = __errno_location();
#line 551
                err_stat = *tmp___8;
                }
              }
              {
#line 552
              tmp___11 = quotactl(768 << 8, "/dev/null", (qid_t )0, tmp___7);
              }
#line 552
              if (tmp___11) {
                {
#line 553
                tmp___10 = __errno_location();
#line 553
                err_quota = *tmp___10;
                }
              }
#line 558
              if (err_stat == 0) {
#line 558
                if (err_quota == 22) {
#line 559
                  quota_format |= 1 << 1;
#line 560
                  kernel_iface = 2;
                } else {
#line 563
                  quota_format |= 1;
#line 564
                  kernel_iface = 1;
                }
              } else {
#line 563
                quota_format |= 1;
#line 564
                kernel_iface = 1;
              }
#line 566
              return (ret);
            }
          }
        }
        {
#line 568
        tmp___15 = __errno_location();
#line 568
        tmp___16 = strerror(*tmp___15);
#line 568
        output_error("Error while detecting kernel quota version: %s\n", tmp___16);
#line 569
        exit(3);
        }
      }
    }
  }
#line 571
  if (version > 60500U) {
#line 572
    quota_format = -2;
  }
#line 573
  if (version <= 60400U) {
#line 574
    quota_format |= 1;
#line 575
    kernel_iface = 1;
  } else {
#line 578
    quota_format |= 1 << 1;
#line 579
    kernel_iface = 1;
  }
#line 581
  return (ret);
}
}
#line 584 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/linux/quota.c"
int xfs_reset_grace(quota_t *myquota , int grace_type ) 
{ 
  quota_t temp_quota ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 596
  if (! (quota_format & (1 << 3))) {
#line 596
    return (1);
  }
  {
#line 598
  memcpy((void */* __restrict  */)(& temp_quota), (void const   */* __restrict  */)myquota,
         sizeof(quota_t ));
  }
#line 600
  if (grace_type == 1) {
    {
#line 601
    output_debug("xfs_reset_grace: BLOCK");
#line 602
    temp_quota.block_soft = temp_quota.diskspace_used + 1UL;
#line 602
    temp_quota.block_hard = temp_quota.block_soft;
#line 603
    tmp = xfs_quota_set(& temp_quota);
    }
#line 603
    if (tmp) {
      {
#line 603
      tmp___0 = xfs_quota_set(myquota);
      }
#line 603
      if (tmp___0) {
#line 604
        return (1);
      }
    }
  } else
#line 607
  if (grace_type == 2) {
    {
#line 608
    output_debug("xfs_reset_grace: INODE");
#line 609
    temp_quota.inode_soft = temp_quota.inode_used + 1UL;
#line 609
    temp_quota.inode_hard = temp_quota.inode_soft;
#line 610
    tmp___1 = xfs_quota_set(& temp_quota);
    }
#line 610
    if (tmp___1) {
      {
#line 610
      tmp___2 = xfs_quota_set(myquota);
      }
#line 610
      if (tmp___2) {
#line 611
        return (1);
      }
    }
  } else {
    {
#line 616
    output_error("xfs_reset_grace(): wrong parameter for grace_type");
    }
#line 617
    return (0);
  }
#line 619
  return (0);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 47 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/parse.c"
argdata_t *parse_commandline(int argc , char **argv ) 
{ 
  argdata_t *data ;
  int done ;
  int fail ;
  int quota_type ;
  int opt ;
  void *tmp ;
  char const   *tmp___0 ;

  {
#line 56
  if (argc == 1) {
    {
#line 57
    output_help();
    }
#line 58
    return ((argdata_t *)((void *)0));
  }
  {
#line 61
  tmp = calloc((size_t )1, sizeof(argdata_t ));
#line 61
  data = (argdata_t *)tmp;
  }
#line 62
  if (! data) {
    {
#line 63
    output_error("Insufficient memory");
#line 64
    exit(4);
    }
  }
#line 67
  quota_type = 0;
#line 68
  optarg = (char *)((void *)0);
#line 69
  opterr = 0;
#line 70
  fail = 0;
#line 70
  done = fail;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! done) {
#line 71
      if (! (! fail)) {
#line 71
        goto while_break;
      }
    } else {
#line 71
      goto while_break;
    }
    {
#line 72
    opt = getopt(argc, (char * const  *)argv, "hVvnu::g::birq:l:t:dR");
    }
#line 74
    if (opt > 0) {
      {
#line 75
      output_debug("option: \'%c\', argument: \'%s\'", opt, optarg);
      }
    }
    {
#line 79
    if (opt == -1) {
#line 79
      goto case_neg_1;
    }
#line 83
    if (opt == 104) {
#line 83
      goto case_104;
    }
#line 87
    if (opt == 86) {
#line 87
      goto case_86;
    }
#line 91
    if (opt == 118) {
#line 91
      goto case_118;
    }
#line 95
    if (opt == 110) {
#line 95
      goto case_110;
    }
#line 100
    if (opt == 117) {
#line 100
      goto case_117;
    }
#line 131
    if (opt == 103) {
#line 131
      goto case_103;
    }
#line 161
    if (opt == 98) {
#line 161
      goto case_98;
    }
#line 166
    if (opt == 105) {
#line 166
      goto case_105;
    }
#line 173
    if (opt == 113) {
#line 173
      goto case_113;
    }
#line 193
    if (opt == 108) {
#line 193
      goto case_108;
    }
#line 214
    if (opt == 116) {
#line 214
      goto case_116;
    }
#line 235
    if (opt == 114) {
#line 235
      goto case_114;
    }
#line 254
    if (opt == 100) {
#line 254
      goto case_100;
    }
#line 258
    if (opt == 82) {
#line 258
      goto case_82;
    }
#line 262
    if (opt == 58) {
#line 262
      goto case_58;
    }
#line 266
    if (opt == 63) {
#line 266
      goto case_63;
    }
#line 269
    goto switch_default___3;
    case_neg_1: /* CIL Label */ 
#line 80
    done = 1;
#line 81
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 84
    output_help();
#line 85
    exit(0);
    }
    case_86: /* CIL Label */ 
    {
#line 88
    output_version();
#line 89
    exit(0);
    }
    case_118: /* CIL Label */ 
#line 92
    output_level ++;
#line 93
    goto switch_break;
    case_110: /* CIL Label */ 
#line 96
    data->noaction = (short)1;
#line 97
    goto switch_break;
    case_117: /* CIL Label */ 
#line 101
    if (data->id_type) {
      {
#line 102
      output_error("Only one quota (user or group) can be set");
#line 103
      fail = 1;
      }
#line 104
      goto while_continue;
    }
#line 106
    data->id_type = (short)1;
#line 109
    if (optarg) {
      {
#line 110
      output_debug("not mangling: optarg=\'%s\', next=\'%s\'", optarg, *(argv + optind));
#line 112
      data->id = optarg;
      }
    } else
#line 115
    if (! *(argv + optind)) {
      {
#line 116
      output_debug("not mangling: NULL user");
#line 117
      data->id = (char *)((void *)0);
      }
    } else
#line 115
    if ((int )*(*(argv + optind) + 0) == 45) {
      {
#line 116
      output_debug("not mangling: NULL user");
#line 117
      data->id = (char *)((void *)0);
      }
    } else {
      {
#line 121
      output_debug("mangling everything: next=\'%s\'", *(argv + optind));
#line 122
      data->id = *(argv + optind);
#line 123
      optind ++;
      }
    }
    {
#line 128
    output_info("using uid %s", data->id);
    }
#line 129
    goto switch_break;
    case_103: /* CIL Label */ 
#line 132
    if (data->id_type) {
      {
#line 133
      output_error("Only one quota (user or group) can be set");
#line 134
      fail = 1;
      }
#line 135
      goto while_continue;
    }
#line 137
    data->id_type = (short)2;
#line 139
    if (optarg) {
      {
#line 140
      output_debug("not mangling: optarg=\'%s\', next=\'%s\'", optarg, *(argv + optind));
#line 142
      data->id = optarg;
      }
    } else
#line 144
    if (! *(argv + optind)) {
      {
#line 145
      output_debug("not mangling: NULL user");
#line 146
      data->id = (char *)((void *)0);
      }
    } else
#line 144
    if ((int )*(*(argv + optind) + 0) == 45) {
      {
#line 145
      output_debug("not mangling: NULL user");
#line 146
      data->id = (char *)((void *)0);
      }
    } else {
      {
#line 149
      output_debug("mangling everything: next=\'%s\', argv[optind]");
#line 150
      data->id = *(argv + optind);
#line 151
      optind ++;
      }
    }
    {
#line 156
    output_info("using gid  %s", data->id);
    }
#line 157
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 162
    output_info("setting block limit");
#line 163
    quota_type = 1;
    }
#line 164
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 167
    output_info("setting inode limit");
#line 168
    quota_type = 2;
    }
#line 169
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 175
    if (quota_type == 0) {
#line 175
      goto case_0;
    }
#line 179
    if (quota_type == 1) {
#line 179
      goto case_1;
    }
#line 182
    if (quota_type == 2) {
#line 182
      goto case_2;
    }
#line 185
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 176
    output_error("must specify either block or inode");
#line 177
    fail = 1;
    }
#line 178
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 180
    data->block_soft = optarg;
#line 181
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 183
    data->inode_soft = optarg;
#line 184
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 186
    output_error("Impossible error #42q: evacuate the building!");
    }
#line 187
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 189
    output_info("setting soft limit to %s", optarg);
    }
#line 190
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 195
    if (quota_type == 0) {
#line 195
      goto case_0___0;
    }
#line 199
    if (quota_type == 1) {
#line 199
      goto case_1___0;
    }
#line 202
    if (quota_type == 2) {
#line 202
      goto case_2___0;
    }
#line 205
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
    {
#line 196
    output_error("must specify either block or inode");
#line 197
    fail = 1;
    }
#line 198
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
#line 200
    data->block_hard = optarg;
#line 201
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
#line 203
    data->inode_hard = optarg;
#line 204
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 206
    output_error("Impossible error #42l: evacuate the building!");
    }
#line 207
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 209
    output_info("setting hard limit to %s", optarg);
    }
#line 210
    goto switch_break;
    case_116: /* CIL Label */ 
#line 215
    data->id = (char *)((void *)0);
    {
#line 217
    if (quota_type == 0) {
#line 217
      goto case_0___1;
    }
#line 221
    if (quota_type == 1) {
#line 221
      goto case_1___1;
    }
#line 224
    if (quota_type == 2) {
#line 224
      goto case_2___1;
    }
#line 227
    goto switch_default___1;
    case_0___1: /* CIL Label */ 
    {
#line 218
    output_error("must specify either block or inode");
#line 219
    fail = 1;
    }
#line 220
    goto switch_break___2;
    case_1___1: /* CIL Label */ 
#line 222
    data->block_grace = optarg;
#line 223
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
#line 225
    data->inode_grace = optarg;
#line 226
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 228
    output_error("Impossible error #42t: evacuate the building!");
    }
#line 229
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 231
    output_info("setting grace period to %s", optarg);
    }
#line 232
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 237
    if (quota_type == 0) {
#line 237
      goto case_0___2;
    }
#line 241
    if (quota_type == 1) {
#line 241
      goto case_1___2;
    }
#line 244
    if (quota_type == 2) {
#line 244
      goto case_2___2;
    }
#line 247
    goto switch_default___2;
    case_0___2: /* CIL Label */ 
    {
#line 238
    output_error("must specify either block or inode");
#line 239
    fail = 1;
    }
#line 240
    goto switch_break___3;
    case_1___2: /* CIL Label */ 
#line 242
    data->block_reset = (short)1;
#line 243
    goto switch_break___3;
    case_2___2: /* CIL Label */ 
#line 245
    data->inode_reset = (short)1;
#line 246
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
    {
#line 248
    output_error("Impossible error #42r: evacuate the building!");
    }
#line 249
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
    {
#line 251
    output_info("resetting grace period");
    }
#line 252
    goto switch_break;
    case_100: /* CIL Label */ 
#line 255
    data->dump_info = (short)1;
#line 256
    goto switch_break;
    case_82: /* CIL Label */ 
#line 259
    data->raise_only = (short)1;
#line 260
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 263
    output_error("Option \'%c\' requires an argument", optopt);
    }
#line 264
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 267
    output_error("Unrecognized option: \'%c\'", optopt);
    }
    switch_default___3: /* CIL Label */ 
    {
#line 270
    output_help();
#line 271
    fail = 1;
    }
#line 272
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  if (fail) {
    {
#line 280
    free((void *)data);
    }
#line 281
    return ((argdata_t *)((void *)0));
  }
#line 284
  if (! data->id_type) {
    {
#line 285
    output_error("Must specify either user or group quota");
    }
#line 286
    return ((argdata_t *)((void *)0));
  }
#line 289
  if (data->dump_info) {
#line 290
    if ((int )data->id_type == 1) {
#line 290
      tmp___0 = "user";
    } else {
#line 290
      tmp___0 = "group";
    }
    {
#line 290
    output_info("Option \'d\' => just dumping quota-info for %s", tmp___0);
    }
  }
#line 294
  data->qfile = *(argv + optind);
#line 295
  if (! data->qfile) {
    {
#line 296
    output_error("No filesystem specified");
    }
#line 297
    return ((argdata_t *)((void *)0));
  }
#line 301
  if (data->block_grace) {
#line 301
    goto _L;
  } else
#line 301
  if (data->inode_grace) {
    _L: /* CIL Label */ 
#line 302
    if (data->block_hard) {
      {
#line 303
      output_error("Wrong options for -t, please see manpage for usage instructions!");
      }
#line 304
      return ((argdata_t *)((void *)0));
    } else
#line 302
    if (data->block_soft) {
      {
#line 303
      output_error("Wrong options for -t, please see manpage for usage instructions!");
      }
#line 304
      return ((argdata_t *)((void *)0));
    } else
#line 302
    if (data->inode_hard) {
      {
#line 303
      output_error("Wrong options for -t, please see manpage for usage instructions!");
      }
#line 304
      return ((argdata_t *)((void *)0));
    } else
#line 302
    if (data->inode_soft) {
      {
#line 303
      output_error("Wrong options for -t, please see manpage for usage instructions!");
      }
#line 304
      return ((argdata_t *)((void *)0));
    } else
#line 302
    if (data->id) {
      {
#line 303
      output_error("Wrong options for -t, please see manpage for usage instructions!");
      }
#line 304
      return ((argdata_t *)((void *)0));
    }
  }
  {
#line 308
  output_info("using filesystem %s", data->qfile);
  }
#line 310
  return (data);
}
}
#line 337 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/parse.c"
time_t parse_timespan(time_t orig , char *string ) 
{ 
  char *cp ;
  int count ;
  int unit ;
  char op ;
  long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 343
  op = (char )'\000';
#line 344
  if ((int )*string == 43) {
#line 346
    op = *string;
#line 347
    string ++;
  } else
#line 344
  if ((int )*string == 45) {
#line 346
    op = *string;
#line 347
    string ++;
  }
  {
#line 350
  tmp = strtol((char const   */* __restrict  */)string, (char **/* __restrict  */)(& cp),
               10);
#line 350
  count = (int )tmp;
  }
#line 351
  if ((unsigned long )cp == (unsigned long )string) {
    {
#line 352
    output_error("Invalid format: %s", string);
    }
#line 353
    return ((time_t )-1);
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 357
    tmp___0 = strchr(" \t\n", (int )*cp);
    }
#line 357
    if (! tmp___0) {
#line 357
      goto while_break;
    }
#line 357
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  tmp___7 = strncasecmp((char const   *)cp, "s", (size_t )1);
  }
#line 360
  if (tmp___7) {
    {
#line 363
    tmp___6 = strncasecmp((char const   *)cp, "mi", (size_t )2);
    }
#line 363
    if (tmp___6) {
      {
#line 366
      tmp___5 = strncasecmp((char const   *)cp, "h", (size_t )1);
      }
#line 366
      if (tmp___5) {
        {
#line 369
        tmp___4 = strncasecmp((char const   *)cp, "d", (size_t )1);
        }
#line 369
        if (tmp___4) {
          {
#line 372
          tmp___3 = strncasecmp((char const   *)cp, "w", (size_t )1);
          }
#line 372
          if (tmp___3) {
            {
#line 375
            tmp___2 = strncasecmp((char const   *)cp, "mo", (size_t )2);
            }
#line 375
            if (tmp___2) {
              {
#line 378
              tmp___1 = strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJLKMNOPQRSTUVWXYZ",
                               (int )*cp);
              }
#line 378
              if (tmp___1) {
                {
#line 379
                output_error("Invalid format: %s", string);
                }
#line 380
                return ((time_t )-1);
              } else {
#line 383
                unit = 1;
              }
            } else {
#line 376
              unit = 2592000;
            }
          } else {
#line 373
            unit = 604800;
          }
        } else {
#line 370
          unit = 86400;
        }
      } else {
#line 367
        unit = 3600;
      }
    } else {
#line 364
      unit = 60;
    }
  } else {
#line 361
    unit = 1;
  }
  {
#line 387
  if ((int )op == 43) {
#line 387
    goto case_43;
  }
#line 389
  if ((int )op == 45) {
#line 389
    goto case_45;
  }
#line 391
  goto switch_default;
  case_43: /* CIL Label */ 
#line 388
  return (orig + (time_t )(count * unit));
  case_45: /* CIL Label */ 
#line 390
  return (orig - (time_t )(count * unit));
  switch_default: /* CIL Label */ 
#line 392
  return ((time_t )count * (time_t )unit);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 410 "/home/wheatley/newnew/temp/quotatool-1.4.12/src/parse.c"
u_int64_t parse_size(u_int64_t orig , char *string ) 
{ 
  char *cp ;
  u_int64_t blocks ;
  u_int64_t unit ;
  uint count ;
  char op ;
  long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 416
  op = (char )'\000';
#line 417
  if ((int )*string == 43) {
#line 419
    op = *string;
#line 420
    string ++;
  } else
#line 417
  if ((int )*string == 45) {
#line 419
    op = *string;
#line 420
    string ++;
  }
  {
#line 424
  tmp = strtol((char const   */* __restrict  */)string, (char **/* __restrict  */)(& cp),
               10);
#line 424
  count = (uint )tmp;
  }
#line 425
  if ((unsigned long )cp == (unsigned long )string) {
#line 426
    return (orig);
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    tmp___0 = strchr(" \t\n", (int )*cp);
    }
#line 430
    if (! tmp___0) {
#line 430
      goto while_break;
    }
#line 430
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  tmp___6 = strncasecmp((char const   *)cp, "by", (size_t )2);
  }
#line 433
  if (tmp___6) {
    {
#line 436
    tmp___5 = strncasecmp((char const   *)cp, "bl", (size_t )2);
    }
#line 436
    if (tmp___5) {
      {
#line 439
      tmp___4 = strncasecmp((char const   *)cp, "k", (size_t )1);
      }
#line 439
      if (tmp___4) {
        {
#line 442
        tmp___3 = strncasecmp((char const   *)cp, "m", (size_t )1);
        }
#line 442
        if (tmp___3) {
          {
#line 445
          tmp___2 = strncasecmp((char const   *)cp, "g", (size_t )1);
          }
#line 445
          if (tmp___2) {
            {
#line 448
            tmp___1 = strncasecmp((char const   *)cp, "t", (size_t )1);
            }
#line 448
            if (tmp___1) {
#line 452
              unit = (u_int64_t )1024;
            } else {
#line 449
              unit = 1099511627776UL;
            }
          } else {
#line 446
            unit = 1073741824UL;
          }
        } else {
#line 443
          unit = 1048576UL;
        }
      } else {
#line 440
        unit = 1024UL;
      }
    } else {
#line 437
      unit = (u_int64_t )1024;
    }
  } else {
#line 434
    unit = (u_int64_t )1;
  }
#line 456
  if (count == 0U) {
#line 457
    return ((u_int64_t )0);
  }
#line 461
  blocks = (u_int64_t )(((double )count * (double )unit - (double )1) / (double )1024) + 1UL;
  {
#line 464
  if ((int )op == 43) {
#line 464
    goto case_43;
  }
#line 466
  if ((int )op == 45) {
#line 466
    goto case_45;
  }
#line 468
  goto switch_default;
  case_43: /* CIL Label */ 
#line 465
  return (orig + blocks);
  case_45: /* CIL Label */ 
#line 467
  return (orig - blocks);
  switch_default: /* CIL Label */ 
#line 469
  return (blocks);
  switch_break: /* CIL Label */ ;
  }
}
}
