/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 32 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/types.h"
typedef long long fsize_t;
#line 37 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/types.h"
typedef unsigned long long fnum_t;
#line 41 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/types.h"
typedef unsigned int pnum_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 75 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/options.h"
struct program_options {
   pnum_t num_parts ;
   fnum_t max_entries ;
   fsize_t max_size ;
   char *in_filename ;
   unsigned char arbitrary_values ;
   char *out_filename ;
   unsigned char add_slash ;
   unsigned char verbose ;
   unsigned char follow_symbolic_links ;
   unsigned char cross_fs_boundaries ;
   char **include_files ;
   unsigned int ninclude_files ;
   char **include_files_ci ;
   unsigned int ninclude_files_ci ;
   char **exclude_files ;
   unsigned int nexclude_files ;
   char **exclude_files_ci ;
   unsigned int nexclude_files_ci ;
   unsigned char empty_dirs ;
   unsigned char dnr_empty ;
   int dir_depth ;
   unsigned char leaf_dirs ;
   unsigned char live_mode ;
   char *pre_part_hook ;
   char *post_part_hook ;
   fsize_t preload_size ;
   fsize_t overload_size ;
   fsize_t round_size ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.h"
struct file_entry;
#line 42 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.h"
struct file_entry {
   char *path ;
   fsize_t size ;
   pnum_t partition_index ;
   struct file_entry *nextp ;
   struct file_entry *prevp ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_20 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_21 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_20 __wait_terminated ;
   struct __anonstruct___wait_stopped_21 __wait_stopped ;
};
#line 45 "/usr/include/fts.h"
struct _ftsent;
#line 45 "/usr/include/fts.h"
struct __anonstruct_FTS_26 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_pathlen ;
   int fts_nitems ;
   int (*fts_compar)(void const   * , void const   * ) ;
   int fts_options ;
};
#line 45 "/usr/include/fts.h"
typedef struct __anonstruct_FTS_26 FTS;
#line 71 "/usr/include/fts.h"
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   u_short fts_pathlen ;
   u_short fts_namelen ;
   ino_t fts_ino ;
   dev_t fts_dev ;
   nlink_t fts_nlink ;
   short fts_level ;
   u_short fts_info ;
   u_short fts_flags ;
   u_short fts_instr ;
   struct stat *fts_statp ;
   char fts_name[1] ;
};
#line 71 "/usr/include/fts.h"
typedef struct _ftsent FTSENT;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 88 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
struct __anonstruct_live_status_55 {
   int fd ;
   char *filename ;
   pnum_t partition_index ;
   fsize_t partition_size ;
   fnum_t partition_num_files ;
   int exit_summary ;
   pid_t child_pid ;
};
#line 339 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 337 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 335 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.h"
struct partition;
#line 37 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.h"
struct partition {
   fsize_t size ;
   fnum_t num_files ;
   struct partition *nextp ;
   struct partition *prevp ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.h"
unsigned int get_num_digits(double i ) ;
#line 75
fsize_t get_size(char *file_path , struct stat *file_stat , struct program_options *options ) ;
#line 82
int valid_filename(char *filename , struct program_options *options , unsigned char is_leaf ) ;
#line 84
char **clone_env(void) ;
#line 85
int push_env(char *str , char ***env ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.h"
int fpart_hook(char const   *cmd , struct program_options  const  *options , char const   *live_filename ,
               pnum_t const   *live_partition_index , fsize_t const   *live_partition_size ,
               fnum_t const   *live_num_files ) ;
#line 54
int handle_file_entry(struct file_entry **head , char *path , fsize_t size , struct program_options *options ) ;
#line 56
int live_print_file_entry(char *path , fsize_t size , char *out_template , struct program_options *options ) ;
#line 58
int add_file_entry(struct file_entry **head , char *path , fsize_t size , struct program_options *options ) ;
#line 60
int init_file_entries(char *file_path , struct file_entry **head , fnum_t *count ,
                      struct program_options *options ) ;
#line 62
void uninit_file_entries(struct file_entry *head , struct program_options *options ) ;
#line 64
int print_file_entries(struct file_entry *head , char *out_template , pnum_t num_parts ) ;
#line 66
void init_file_entry_p(struct file_entry **file_entry_p , fnum_t num_entries , struct file_entry *head ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 124 "/usr/include/fts.h"
extern int fts_close(FTS * ) ;
#line 125
extern FTS *fts_open(char * const  * , int  , int (*)(FTSENT const   ** , FTSENT const   ** ) ) ;
#line 127
extern FTSENT *fts_read(FTS * ) ;
#line 128
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS * ,
                                                                              FTSENT * ,
                                                                              int  ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 568
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *__path ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 134
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) killpg)(__pid_t __pgrp ,
                                                                             int __sig ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 125
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
static  __attribute__((__noreturn__)) void kill_child(int sig ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
static struct __anonstruct_live_status_55 live_status  =    {1, (char *)((void *)0), (pnum_t )0, (fsize_t )0, (fnum_t )0, 0, -1};
#line 109
static  __attribute__((__noreturn__)) void kill_child(int sig ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
static void kill_child(int sig ) 
{ 
  int tmp ;

  {
#line 116
  if (live_status.child_pid > 1) {
#line 117
    if (sig) {
#line 117
      tmp = sig;
    } else {
#line 117
      tmp = 15;
    }
    {
#line 117
    killpg(live_status.child_pid, tmp);
#line 118
    waitpid(live_status.child_pid, (int *)((void *)0), 0);
    }
  }
  {
#line 120
  exit(1);
  }
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
int fpart_hook(char const   *cmd , struct program_options  const  *options , char const   *live_filename ,
               pnum_t const   *live_partition_index , fsize_t const   *live_partition_size ,
               fnum_t const   *live_num_files ) 
{ 
  int retval ;
  char *env_fpart_hooktype_name ;
  char *env_fpart_partfilename_name ;
  char *env_fpart_partnumber_name ;
  char *env_fpart_partsize_name ;
  char *env_fpart_partnumfiles_name ;
  char *env_fpart_pid_name ;
  char *env_fpart_hooktype_string ;
  char *env_fpart_partfilename_string ;
  char *env_fpart_partnumber_string ;
  char *env_fpart_partsize_string ;
  char *env_fpart_partnumfiles_string ;
  char *env_fpart_pid_string ;
  char **envp ;
  char **tmp ;
  size_t malloc_size ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  unsigned int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  unsigned int tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  unsigned int tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  pid_t fpart_pid ;
  __pid_t tmp___24 ;
  size_t tmp___25 ;
  unsigned int tmp___26 ;
  void *tmp___27 ;
  int tmp___28 ;
  int child_status ;
  int *tmp___29 ;
  char *tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  pid_t wpid ;
  int *tmp___34 ;
  char *tmp___35 ;
  union __anonunion_56 __constr_expr_0 ;
  union __anonunion_57 __constr_expr_1 ;
  union __anonunion_58 __constr_expr_2 ;

  {
#line 131
  if (! ((unsigned long )cmd != (unsigned long )((void *)0))) {
    {
#line 131
    __assert_fail("cmd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  131U, "fpart_hook");
    }
  }
#line 132
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 132
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  132U, "fpart_hook");
    }
  }
  {
#line 134
  retval = 0;
#line 137
  env_fpart_hooktype_name = (char *)"FPART_HOOKTYPE";
#line 138
  env_fpart_partfilename_name = (char *)"FPART_PARTFILENAME";
#line 139
  env_fpart_partnumber_name = (char *)"FPART_PARTNUMBER";
#line 140
  env_fpart_partsize_name = (char *)"FPART_PARTSIZE";
#line 141
  env_fpart_partnumfiles_name = (char *)"FPART_PARTNUMFILES";
#line 142
  env_fpart_pid_name = (char *)"FPART_PID";
#line 145
  env_fpart_hooktype_string = (char *)((void *)0);
#line 146
  env_fpart_partfilename_string = (char *)((void *)0);
#line 147
  env_fpart_partnumber_string = (char *)((void *)0);
#line 148
  env_fpart_partsize_string = (char *)((void *)0);
#line 149
  env_fpart_partnumfiles_string = (char *)((void *)0);
#line 150
  env_fpart_pid_string = (char *)((void *)0);
#line 158
  tmp = clone_env();
#line 158
  envp = tmp;
  }
#line 159
  if ((unsigned long )envp == (unsigned long )((void *)0)) {
#line 160
    return (1);
  }
#line 162
  malloc_size = (size_t )1;
#line 165
  if ((unsigned long )cmd == (unsigned long )options->pre_part_hook) {
#line 166
    if (! ((unsigned long )live_partition_index != (unsigned long )((void *)0))) {
      {
#line 166
      __assert_fail("live_partition_index != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                    166U, "fpart_hook");
      }
    }
#line 167
    if (! ((unsigned long )live_partition_size != (unsigned long )((void *)0))) {
      {
#line 167
      __assert_fail("live_partition_size != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                    167U, "fpart_hook");
      }
    }
#line 168
    if (! ((unsigned long )live_num_files != (unsigned long )((void *)0))) {
      {
#line 168
      __assert_fail("live_num_files != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                    168U, "fpart_hook");
      }
    }
#line 170
    if ((int const   )options->verbose >= 1) {
      {
#line 171
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Executing pre-part #%d hook: \'%s\'\n",
              *live_partition_index, cmd);
      }
    }
    {
#line 175
    tmp___0 = strlen((char const   *)env_fpart_hooktype_name);
#line 175
    tmp___1 = strlen("pre-part");
#line 175
    malloc_size = ((tmp___0 + 1UL) + tmp___1) + 1UL;
#line 177
    tmp___2 = malloc(malloc_size);
#line 177
    env_fpart_hooktype_string = (char *)tmp___2;
    }
#line 177
    if ((unsigned long )env_fpart_hooktype_string == (unsigned long )((void *)0)) {
      {
#line 177
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "fpart_hook");
#line 177
      retval = 1;
      }
#line 177
      goto cleanup;
    }
    {
#line 181
    snprintf((char */* __restrict  */)env_fpart_hooktype_string, malloc_size, (char const   */* __restrict  */)"%s=%s",
             env_fpart_hooktype_name, "pre-part");
#line 183
    tmp___3 = push_env(env_fpart_hooktype_string, & envp);
    }
#line 183
    if (tmp___3 != 0) {
#line 184
      retval = 1;
#line 185
      goto cleanup;
    }
  } else
#line 188
  if ((unsigned long )cmd == (unsigned long )options->post_part_hook) {
#line 189
    if (! ((unsigned long )live_partition_index != (unsigned long )((void *)0))) {
      {
#line 189
      __assert_fail("live_partition_index != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                    189U, "fpart_hook");
      }
    }
#line 190
    if (! ((unsigned long )live_partition_size != (unsigned long )((void *)0))) {
      {
#line 190
      __assert_fail("live_partition_size != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                    190U, "fpart_hook");
      }
    }
#line 191
    if (! ((unsigned long )live_num_files != (unsigned long )((void *)0))) {
      {
#line 191
      __assert_fail("live_num_files != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                    191U, "fpart_hook");
      }
    }
#line 193
    if ((int const   )options->verbose >= 1) {
      {
#line 194
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Executing post-part #%d hook: \'%s\'\n",
              *live_partition_index, cmd);
      }
    }
    {
#line 198
    tmp___4 = strlen((char const   *)env_fpart_hooktype_name);
#line 198
    tmp___5 = strlen("post-part");
#line 198
    malloc_size = ((tmp___4 + 1UL) + tmp___5) + 1UL;
#line 200
    tmp___6 = malloc(malloc_size);
#line 200
    env_fpart_hooktype_string = (char *)tmp___6;
    }
#line 200
    if ((unsigned long )env_fpart_hooktype_string == (unsigned long )((void *)0)) {
      {
#line 200
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "fpart_hook");
#line 200
      retval = 1;
      }
#line 200
      goto cleanup;
    }
    {
#line 204
    snprintf((char */* __restrict  */)env_fpart_hooktype_string, malloc_size, (char const   */* __restrict  */)"%s=%s",
             env_fpart_hooktype_name, "post-part");
#line 206
    tmp___7 = push_env(env_fpart_hooktype_string, & envp);
    }
#line 206
    if (tmp___7 != 0) {
#line 207
      retval = 1;
#line 208
      goto cleanup;
    }
  }
#line 213
  if ((unsigned long )live_filename != (unsigned long )((void *)0)) {
    {
#line 214
    tmp___8 = strlen((char const   *)env_fpart_partfilename_name);
#line 214
    tmp___9 = strlen(live_filename);
#line 214
    malloc_size = ((tmp___8 + 1UL) + tmp___9) + 1UL;
#line 216
    tmp___10 = malloc(malloc_size);
#line 216
    env_fpart_partfilename_string = (char *)tmp___10;
    }
#line 216
    if ((unsigned long )env_fpart_partfilename_string == (unsigned long )((void *)0)) {
      {
#line 216
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "fpart_hook");
#line 216
      retval = 1;
      }
#line 216
      goto cleanup;
    }
    {
#line 220
    snprintf((char */* __restrict  */)env_fpart_partfilename_string, malloc_size,
             (char const   */* __restrict  */)"%s=%s", env_fpart_partfilename_name,
             live_filename);
#line 222
    tmp___11 = push_env(env_fpart_partfilename_string, & envp);
    }
#line 222
    if (tmp___11 != 0) {
#line 223
      retval = 1;
#line 224
      goto cleanup;
    }
  }
#line 229
  if ((unsigned long )live_partition_index != (unsigned long )((void *)0)) {
    {
#line 230
    tmp___12 = strlen((char const   *)env_fpart_partnumber_name);
#line 230
    tmp___13 = get_num_digits((double )*live_partition_index);
#line 230
    malloc_size = ((tmp___12 + 1UL) + (size_t )tmp___13) + 1UL;
#line 232
    tmp___14 = malloc(malloc_size);
#line 232
    env_fpart_partnumber_string = (char *)tmp___14;
    }
#line 232
    if ((unsigned long )env_fpart_partnumber_string == (unsigned long )((void *)0)) {
      {
#line 232
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "fpart_hook");
#line 232
      retval = 1;
      }
#line 232
      goto cleanup;
    }
    {
#line 236
    snprintf((char */* __restrict  */)env_fpart_partnumber_string, malloc_size, (char const   */* __restrict  */)"%s=%d",
             env_fpart_partnumber_name, *live_partition_index);
#line 238
    tmp___15 = push_env(env_fpart_partnumber_string, & envp);
    }
#line 238
    if (tmp___15 != 0) {
#line 239
      retval = 1;
#line 240
      goto cleanup;
    }
  }
#line 245
  if ((unsigned long )live_partition_size != (unsigned long )((void *)0)) {
    {
#line 246
    tmp___16 = strlen((char const   *)env_fpart_partsize_name);
#line 246
    tmp___17 = get_num_digits((double )*live_partition_size);
#line 246
    malloc_size = ((tmp___16 + 1UL) + (size_t )tmp___17) + 1UL;
#line 248
    tmp___18 = malloc(malloc_size);
#line 248
    env_fpart_partsize_string = (char *)tmp___18;
    }
#line 248
    if ((unsigned long )env_fpart_partsize_string == (unsigned long )((void *)0)) {
      {
#line 248
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "fpart_hook");
#line 248
      retval = 1;
      }
#line 248
      goto cleanup;
    }
    {
#line 252
    snprintf((char */* __restrict  */)env_fpart_partsize_string, malloc_size, (char const   */* __restrict  */)"%s=%lld",
             env_fpart_partsize_name, *live_partition_size);
#line 254
    tmp___19 = push_env(env_fpart_partsize_string, & envp);
    }
#line 254
    if (tmp___19 != 0) {
#line 255
      retval = 1;
#line 256
      goto cleanup;
    }
  }
#line 261
  if ((unsigned long )live_num_files != (unsigned long )((void *)0)) {
    {
#line 262
    tmp___20 = strlen((char const   *)env_fpart_partnumfiles_name);
#line 262
    tmp___21 = get_num_digits((double )*live_num_files);
#line 262
    malloc_size = ((tmp___20 + 1UL) + (size_t )tmp___21) + 1UL;
#line 264
    tmp___22 = malloc(malloc_size);
#line 264
    env_fpart_partnumfiles_string = (char *)tmp___22;
    }
#line 264
    if ((unsigned long )env_fpart_partnumfiles_string == (unsigned long )((void *)0)) {
      {
#line 264
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "fpart_hook");
#line 264
      retval = 1;
      }
#line 264
      goto cleanup;
    }
    {
#line 268
    snprintf((char */* __restrict  */)env_fpart_partnumfiles_string, malloc_size,
             (char const   */* __restrict  */)"%s=%llu", env_fpart_partnumfiles_name,
             *live_num_files);
#line 270
    tmp___23 = push_env(env_fpart_partnumfiles_string, & envp);
    }
#line 270
    if (tmp___23 != 0) {
#line 271
      retval = 1;
#line 272
      goto cleanup;
    }
  }
  {
#line 277
  tmp___24 = getpid();
#line 277
  fpart_pid = tmp___24;
#line 278
  tmp___25 = strlen((char const   *)env_fpart_pid_name);
#line 278
  tmp___26 = get_num_digits((double )fpart_pid);
#line 278
  malloc_size = ((tmp___25 + 1UL) + (size_t )tmp___26) + 1UL;
#line 280
  tmp___27 = malloc(malloc_size);
#line 280
  env_fpart_pid_string = (char *)tmp___27;
  }
#line 280
  if ((unsigned long )env_fpart_pid_string == (unsigned long )((void *)0)) {
    {
#line 280
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
            "fpart_hook");
#line 280
    retval = 1;
    }
#line 280
    goto cleanup;
  }
  {
#line 284
  snprintf((char */* __restrict  */)env_fpart_pid_string, malloc_size, (char const   */* __restrict  */)"%s=%d",
           env_fpart_pid_name, fpart_pid);
#line 286
  tmp___28 = push_env(env_fpart_pid_string, & envp);
  }
#line 286
  if (tmp___28 != 0) {
#line 287
    retval = 1;
#line 288
    goto cleanup;
  }
  {
#line 292
  child_status = 0;
#line 293
  live_status.child_pid = fork();
  }
  {
#line 294
  if (live_status.child_pid == -1) {
#line 294
    goto case_neg_1;
  }
#line 298
  if (live_status.child_pid == 0) {
#line 298
    goto case_0;
  }
#line 310
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 295
  tmp___29 = __errno_location();
#line 295
  tmp___30 = strerror(*tmp___29);
#line 295
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fork(): %s\n",
          tmp___30);
#line 296
  retval = 1;
  }
#line 297
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 301
  tmp___33 = setpgid(live_status.child_pid, 0);
  }
#line 301
  if (tmp___33 != 0) {
    {
#line 302
    tmp___31 = __errno_location();
#line 302
    tmp___32 = strerror(*tmp___31);
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): setpgid(): %s\n",
            "fpart_hook", tmp___32);
#line 304
    exit(1);
    }
  }
  {
#line 306
  execle("/bin/sh", "sh", "-c", cmd, (char *)((void *)0), envp);
#line 308
  exit(1);
  }
  switch_default: /* CIL Label */ 
  {
#line 313
  signal(15, & kill_child);
#line 314
  signal(2, & kill_child);
#line 315
  signal(1, & kill_child);
  }
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 319
    wpid = wait((union wait *)(& child_status));
    }
#line 318
    if (wpid != live_status.child_pid) {
#line 318
      if (! (wpid != -1)) {
#line 318
        goto while_break;
      }
    } else {
#line 318
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  signal(15, (void (*)(int  ))0);
#line 324
  signal(2, (void (*)(int  ))0);
#line 325
  signal(1, (void (*)(int  ))0);
#line 327
  live_status.child_pid = -1;
  }
#line 329
  if (wpid == -1) {
    {
#line 330
    tmp___34 = __errno_location();
#line 330
    tmp___35 = strerror(*tmp___34);
#line 330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): wait(): %s\n",
            "fpart_hook", tmp___35);
#line 332
    retval = 1;
    }
  } else {
#line 335
    __constr_expr_2.__in = child_status;
#line 335
    if ((__constr_expr_2.__i & 127) == 0) {
#line 337
      __constr_expr_1.__in = child_status;
#line 337
      if ((__constr_expr_1.__i & 65280) >> 8 != 0) {
#line 338
        if ((int const   )options->verbose >= 1) {
          {
#line 339
          __constr_expr_0.__in = child_status;
#line 339
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hook \'%s\' exited with error %d\n",
                  cmd, (__constr_expr_0.__i & 65280) >> 8);
          }
        }
#line 341
        retval = 1;
      }
    } else {
#line 345
      if ((int const   )options->verbose >= 1) {
        {
#line 346
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hook \'%s\' terminated prematurely\n",
                cmd);
        }
      }
#line 348
      retval = 1;
    }
  }
#line 352
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  cleanup: 
#line 356
  if ((unsigned long )envp != (unsigned long )((void *)0)) {
    {
#line 357
    free((void *)envp);
    }
  }
#line 358
  if ((unsigned long )env_fpart_hooktype_string != (unsigned long )((void *)0)) {
    {
#line 359
    free((void *)env_fpart_hooktype_string);
    }
  }
#line 360
  if ((unsigned long )env_fpart_partfilename_string != (unsigned long )((void *)0)) {
    {
#line 361
    free((void *)env_fpart_partfilename_string);
    }
  }
#line 362
  if ((unsigned long )env_fpart_partnumber_string != (unsigned long )((void *)0)) {
    {
#line 363
    free((void *)env_fpart_partnumber_string);
    }
  }
#line 364
  if ((unsigned long )env_fpart_partsize_string != (unsigned long )((void *)0)) {
    {
#line 365
    free((void *)env_fpart_partsize_string);
    }
  }
#line 366
  if ((unsigned long )env_fpart_partnumfiles_string != (unsigned long )((void *)0)) {
    {
#line 367
    free((void *)env_fpart_partnumfiles_string);
    }
  }
#line 368
  if ((unsigned long )env_fpart_pid_string != (unsigned long )((void *)0)) {
    {
#line 369
    free((void *)env_fpart_pid_string);
    }
  }
#line 370
  return (retval);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
int handle_file_entry(struct file_entry **head , char *path , fsize_t size , struct program_options *options ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 378
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 378
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  378U, "handle_file_entry");
    }
  }
#line 380
  if ((int )options->live_mode == 1) {
    {
#line 381
    tmp = live_print_file_entry(path, size, options->out_filename, options);
    }
#line 381
    return (tmp);
  } else {
    {
#line 384
    tmp___0 = add_file_entry(head, path, size, options);
    }
#line 384
    return (tmp___0);
  }
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
int live_print_file_entry(char *path , fsize_t size , char *out_template , struct program_options *options ) 
{ 
  size_t malloc_size ;
  size_t tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  fsize_t tmp___5 ;
  size_t to_write ;
  size_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;

  {
#line 392
  if (! ((unsigned long )path != (unsigned long )((void *)0))) {
    {
#line 392
    __assert_fail("path != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  392U, "live_print_file_entry");
    }
  }
#line 393
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 393
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  393U, "live_print_file_entry");
    }
  }
#line 394
  if (! ((int )options->live_mode == 1)) {
    {
#line 394
    __assert_fail("options->live_mode == 1", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  394U, "live_print_file_entry");
    }
  }
#line 397
  if (live_status.partition_num_files == 0ULL) {
#line 399
    if (live_status.partition_index == 0U) {
#line 400
      live_status.partition_size = options->preload_size;
    }
#line 402
    if ((unsigned long )out_template != (unsigned long )((void *)0)) {
      {
#line 404
      tmp = strlen((char const   *)out_template);
#line 404
      tmp___0 = get_num_digits((double )live_status.partition_index);
#line 404
      malloc_size = ((tmp + 1UL) + (size_t )tmp___0) + 1UL;
#line 406
      tmp___1 = malloc(malloc_size);
#line 406
      live_status.filename = (char *)tmp___1;
      }
#line 406
      if ((unsigned long )live_status.filename == (unsigned long )((void *)0)) {
        {
#line 406
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
                "live_print_file_entry");
        }
#line 406
        return (1);
      }
      {
#line 409
      snprintf((char */* __restrict  */)live_status.filename, malloc_size, (char const   */* __restrict  */)"%s.%d",
               out_template, live_status.partition_index);
      }
    }
#line 414
    if ((unsigned long )options->pre_part_hook != (unsigned long )((void *)0)) {
      {
#line 415
      tmp___2 = fpart_hook((char const   *)options->pre_part_hook, (struct program_options  const  *)options,
                           (char const   *)live_status.filename, (pnum_t const   *)(& live_status.partition_index),
                           (fsize_t const   *)(& live_status.partition_size), (fnum_t const   *)(& live_status.partition_num_files));
      }
#line 415
      if (tmp___2 != 0) {
#line 418
        live_status.exit_summary = 1;
      }
    }
#line 421
    if ((unsigned long )out_template != (unsigned long )((void *)0)) {
      {
#line 423
      live_status.fd = open((char const   *)live_status.filename, 577, 432);
      }
#line 423
      if (live_status.fd < 0) {
        {
#line 425
        tmp___3 = __errno_location();
#line 425
        tmp___4 = strerror(*tmp___3);
#line 425
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
                live_status.filename, tmp___4);
#line 427
        free((void *)live_status.filename);
#line 428
        live_status.filename = (char *)((void *)0);
        }
#line 429
        return (1);
      }
    }
  }
#line 435
  if ((size + options->overload_size) % options->round_size != 0LL) {
#line 435
    tmp___5 = ((size + options->overload_size) / options->round_size) * options->round_size + options->round_size;
  } else {
#line 435
    tmp___5 = size + options->overload_size;
  }
#line 435
  live_status.partition_size += tmp___5;
#line 437
  (live_status.partition_num_files) ++;
#line 439
  if ((unsigned long )out_template == (unsigned long )((void *)0)) {
    {
#line 441
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%d (%lld): %s\n",
            live_status.partition_index, size, path);
    }
  } else {
    {
#line 446
    tmp___6 = strlen((char const   *)path);
#line 446
    to_write = tmp___6;
#line 447
    tmp___9 = write(live_status.fd, (void const   *)path, to_write);
    }
#line 447
    if (tmp___9 != (ssize_t )to_write) {
      {
#line 449
      tmp___7 = __errno_location();
#line 449
      tmp___8 = strerror(*tmp___7);
#line 449
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              tmp___8);
      }
#line 452
      return (1);
    } else {
      {
#line 447
      tmp___10 = write(live_status.fd, (void const   *)"\n", (size_t )1);
      }
#line 447
      if (tmp___10 != 1L) {
        {
#line 449
        tmp___7 = __errno_location();
#line 449
        tmp___8 = strerror(*tmp___7);
#line 449
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                tmp___8);
        }
#line 452
        return (1);
      }
    }
  }
#line 457
  if ((int )options->verbose >= 2) {
    {
#line 458
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            path);
    }
  }
#line 461
  if (options->max_entries > 0ULL) {
#line 461
    if (live_status.partition_num_files >= options->max_entries) {
#line 461
      goto _L;
    } else {
#line 461
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 461
  if (options->max_size > 0LL) {
#line 461
    if (live_status.partition_size >= options->max_size) {
      _L: /* CIL Label */ 
#line 466
      if ((int )options->verbose >= 1) {
        {
#line 467
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Filled part #%d: size = %lld, %lld file(s)\n",
                live_status.partition_index, live_status.partition_size, live_status.partition_num_files);
        }
      }
#line 472
      if ((unsigned long )out_template == (unsigned long )((void *)0)) {
        {
#line 473
        fflush(stdout);
        }
      } else {
        {
#line 475
        close(live_status.fd);
        }
      }
#line 478
      if ((unsigned long )options->post_part_hook != (unsigned long )((void *)0)) {
        {
#line 479
        tmp___11 = fpart_hook((char const   *)options->post_part_hook, (struct program_options  const  *)options,
                              (char const   *)live_status.filename, (pnum_t const   *)(& live_status.partition_index),
                              (fsize_t const   *)(& live_status.partition_size), (fnum_t const   *)(& live_status.partition_num_files));
        }
#line 479
        if (tmp___11 != 0) {
#line 483
          live_status.exit_summary = 1;
        }
      }
#line 486
      if ((unsigned long )out_template != (unsigned long )((void *)0)) {
        {
#line 487
        free((void *)live_status.filename);
#line 488
        live_status.filename = (char *)((void *)0);
        }
      }
#line 492
      (live_status.partition_index) ++;
#line 493
      live_status.partition_size = options->preload_size;
#line 494
      live_status.partition_num_files = (fnum_t )0;
    }
  }
#line 497
  return (0);
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
int add_file_entry(struct file_entry **head , char *path , fsize_t size , struct program_options *options ) 
{ 
  struct file_entry **current ;
  struct file_entry *previous ;
  void *tmp ;
  size_t malloc_size ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 512
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 512
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  512U, "add_file_entry");
    }
  }
#line 513
  if (! ((unsigned long )path != (unsigned long )((void *)0))) {
    {
#line 513
    __assert_fail("path != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  513U, "add_file_entry");
    }
  }
#line 514
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 514
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  514U, "add_file_entry");
    }
  }
#line 515
  if (! ((int )options->live_mode == 0)) {
    {
#line 515
    __assert_fail("options->live_mode == 0", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  515U, "add_file_entry");
    }
  }
  {
#line 517
  current = head;
#line 518
  previous = (struct file_entry *)((void *)0);
#line 521
  previous = *current;
#line 523
  tmp = malloc(sizeof(struct file_entry ));
#line 523
  *current = (struct file_entry *)tmp;
  }
#line 523
  if ((unsigned long )*current == (unsigned long )((void *)0)) {
    {
#line 523
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
            "add_file_entry");
    }
#line 523
    return (1);
  }
#line 528
  if ((unsigned long )*head == (unsigned long )((void *)0)) {
#line 529
    *head = *current;
  }
  {
#line 532
  tmp___0 = strlen((char const   *)path);
#line 532
  malloc_size = tmp___0 + 1UL;
#line 534
  tmp___1 = malloc(malloc_size);
#line 534
  (*current)->path = (char *)tmp___1;
  }
#line 534
  if ((unsigned long )(*current)->path == (unsigned long )((void *)0)) {
    {
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
            "add_file_entry");
#line 534
    free((void *)*current);
#line 534
    *current = previous;
    }
#line 534
    return (1);
  }
  {
#line 539
  snprintf((char */* __restrict  */)(*current)->path, malloc_size, (char const   */* __restrict  */)"%s",
           path);
#line 540
  (*current)->size = size + options->overload_size;
  }
#line 541
  if ((*current)->size % options->round_size != 0LL) {
#line 541
    (*current)->size = ((*current)->size / options->round_size) * options->round_size + options->round_size;
  } else {
#line 541
    (*current)->size = (*current)->size;
  }
#line 544
  (*current)->partition_index = (pnum_t )0;
#line 545
  (*current)->nextp = (struct file_entry *)((void *)0);
#line 546
  (*current)->prevp = previous;
#line 549
  if ((unsigned long )previous != (unsigned long )((void *)0)) {
#line 550
    previous->nextp = *current;
  }
#line 553
  if ((int )options->verbose >= 2) {
    {
#line 554
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            (*current)->path);
    }
  }
#line 556
  return (0);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
static int fts_dirsfirst(FTSENT const   **a , FTSENT const   **b ) 
{ 


  {
#line 568
  if (! ((unsigned long )a != (unsigned long )((void *)0))) {
    {
#line 568
    __assert_fail("a != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  568U, "fts_dirsfirst");
    }
  }
#line 569
  if (! ((unsigned long )*a != (unsigned long )((void *)0))) {
    {
#line 569
    __assert_fail("(*a) != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  569U, "fts_dirsfirst");
    }
  }
#line 570
  if (! ((unsigned long )b != (unsigned long )((void *)0))) {
    {
#line 570
    __assert_fail("b != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  570U, "fts_dirsfirst");
    }
  }
#line 571
  if (! ((unsigned long )*b != (unsigned long )((void *)0))) {
    {
#line 571
    __assert_fail("(*b) != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  571U, "fts_dirsfirst");
    }
  }
#line 573
  if ((int const   )(*a)->fts_info == 10) {
#line 577
    return (0);
  } else
#line 573
  if ((int const   )(*a)->fts_info == 11) {
#line 577
    return (0);
  } else
#line 573
  if ((int const   )(*b)->fts_info == 10) {
#line 577
    return (0);
  } else
#line 573
  if ((int const   )(*b)->fts_info == 11) {
#line 577
    return (0);
  }
#line 580
  if ((((*a)->fts_statp)->st_mode & 61440U) == 16384U) {
#line 581
    if (! ((((*b)->fts_statp)->st_mode & 61440U) == 16384U)) {
#line 582
      return (-1);
    } else {
#line 584
      return (0);
    }
  } else
#line 586
  if ((((*b)->fts_statp)->st_mode & 61440U) == 16384U) {
#line 587
    return (1);
  } else {
#line 589
    return (0);
  }
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
int init_file_entries(char *file_path , struct file_entry **head , fnum_t *count ,
                      struct program_options *options ) 
{ 
  FTS *ftsp ;
  FTSENT *p ;
  int fts_options ;
  int tmp ;
  int tmp___0 ;
  char *fts_argv[2] ;
  int (*tmp___1)(FTSENT const   **a , FTSENT const   **b ) ;
  unsigned char curdir_empty ;
  unsigned char curdir_dirsfound ;
  unsigned char curdir_addme ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  fsize_t curdir_size ;
  char *curdir_entry_path ;
  int tmp___5 ;
  size_t malloc_size ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  fsize_t tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 602
  if (! ((unsigned long )file_path != (unsigned long )((void *)0))) {
    {
#line 602
    __assert_fail("file_path != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  602U, "init_file_entries");
    }
  }
#line 603
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 603
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  603U, "init_file_entries");
    }
  }
#line 604
  if (! ((unsigned long )count != (unsigned long )((void *)0))) {
    {
#line 604
    __assert_fail("count != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  604U, "init_file_entries");
    }
  }
#line 605
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 605
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  605U, "init_file_entries");
    }
  }
#line 608
  ftsp = (FTS *)((void *)0);
#line 609
  p = (FTSENT *)((void *)0);
#line 610
  if ((int )options->follow_symbolic_links == 0) {
#line 610
    tmp = 2;
  } else {
#line 610
    tmp = 16;
  }
#line 610
  fts_options = tmp;
#line 612
  if ((int )options->cross_fs_boundaries == 0) {
#line 612
    tmp___0 = 64;
  } else {
#line 612
    tmp___0 = 0;
  }
#line 612
  fts_options |= tmp___0;
#line 615
  fts_argv[0] = file_path;
#line 615
  fts_argv[1] = (char *)((void *)0);
#line 616
  if ((int )options->leaf_dirs == 1) {
#line 616
    tmp___1 = & fts_dirsfirst;
  } else {
#line 616
    tmp___1 = (int (*)(FTSENT const   **a , FTSENT const   **b ))((void *)0);
  }
  {
#line 616
  ftsp = fts_open((char * const  *)(fts_argv), fts_options, tmp___1);
  }
#line 616
  if ((unsigned long )ftsp == (unsigned long )((void *)0)) {
    {
#line 618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fts_open()\n",
            file_path);
    }
#line 619
    return (0);
  }
#line 623
  curdir_empty = (unsigned char)1;
#line 624
  curdir_dirsfound = (unsigned char)0;
#line 625
  curdir_addme = (unsigned char)0;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 627
    p = fts_read(ftsp);
    }
#line 627
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 627
      goto while_break;
    }
    {
#line 630
    if ((int )p->fts_info == 7) {
#line 630
      goto case_7;
    }
#line 637
    if ((int )p->fts_info == 4) {
#line 637
      goto case_4;
    }
#line 652
    if ((int )p->fts_info == 10) {
#line 652
      goto case_10;
    }
#line 655
    if ((int )p->fts_info == 11) {
#line 655
      goto case_11;
    }
#line 660
    if ((int )p->fts_info == 2) {
#line 660
      goto case_2;
    }
#line 662
    if ((int )p->fts_info == 5) {
#line 662
      goto case_5;
    }
#line 665
    if ((int )p->fts_info == 6) {
#line 665
      goto add_directory;
    }
#line 747
    if ((int )p->fts_info == 1) {
#line 747
      goto case_1;
    }
#line 775
    goto switch_default;
    case_7: /* CIL Label */ 
    {
#line 631
    tmp___2 = strerror(p->fts_errno);
#line 631
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            p->fts_path, tmp___2);
    }
#line 633
    goto while_continue;
    case_4: /* CIL Label */ 
    {
#line 639
    tmp___3 = strerror(p->fts_errno);
#line 639
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            p->fts_path, tmp___3);
    }
#line 643
    if ((int )options->dnr_empty == 1) {
#line 644
      curdir_empty = (unsigned char)1;
#line 645
      goto add_directory;
    }
#line 648
    curdir_empty = (unsigned char)0;
#line 649
    curdir_dirsfound = (unsigned char)1;
#line 650
    goto while_continue;
    case_10: /* CIL Label */ 
    {
#line 653
    tmp___4 = strerror(p->fts_errno);
#line 653
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            p->fts_path, tmp___4);
    }
    case_11: /* CIL Label */ 
#line 657
    curdir_empty = (unsigned char)0;
#line 658
    goto while_continue;
    case_2: /* CIL Label */ 
    {
#line 661
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: filesystem loop detected\n",
            p->fts_path);
    }
    case_5: /* CIL Label */ 
#line 663
    goto while_continue;
    add_directory: 
    case_6: /* CIL Label */ 
#line 670
    if ((int )options->empty_dirs == 1) {
#line 670
      if (curdir_empty) {
#line 671
        curdir_addme = (unsigned char)1;
      }
    }
#line 675
    if ((int )options->leaf_dirs == 1) {
#line 675
      if (! curdir_dirsfound) {
#line 676
        curdir_addme = (unsigned char)1;
      }
    }
#line 679
    if (curdir_addme) {
      {
#line 680
      curdir_size = (fsize_t )0;
#line 681
      curdir_entry_path = (char *)((void *)0);
#line 685
      tmp___5 = valid_filename(p->fts_name, options, (unsigned char)1);
      }
#line 685
      if (! tmp___5) {
#line 686
        if ((int )options->verbose >= 1) {
          {
#line 687
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipping directory: \'%s\'\n",
                  p->fts_path);
          }
        }
#line 689
        goto reset_directory;
      }
      {
#line 694
      malloc_size = (size_t )(((int )p->fts_pathlen + 1) + 1);
#line 695
      tmp___6 = malloc(malloc_size);
#line 695
      curdir_entry_path = (char *)tmp___6;
      }
#line 695
      if ((unsigned long )curdir_entry_path == (unsigned long )((void *)0)) {
        {
#line 695
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
                "init_file_entries");
#line 695
        fts_close(ftsp);
        }
#line 695
        return (1);
      }
#line 701
      if ((int )options->add_slash == 1) {
#line 701
        if ((int )p->fts_pathlen > 0) {
#line 701
          if ((int )*(p->fts_path + ((int )p->fts_pathlen - 1)) != 47) {
            {
#line 704
            snprintf((char */* __restrict  */)curdir_entry_path, malloc_size, (char const   */* __restrict  */)"%s/",
                     p->fts_path);
            }
          } else {
            {
#line 707
            snprintf((char */* __restrict  */)curdir_entry_path, malloc_size, (char const   */* __restrict  */)"%s",
                     p->fts_path);
            }
          }
        } else {
          {
#line 707
          snprintf((char */* __restrict  */)curdir_entry_path, malloc_size, (char const   */* __restrict  */)"%s",
                   p->fts_path);
          }
        }
      } else {
        {
#line 707
        snprintf((char */* __restrict  */)curdir_entry_path, malloc_size, (char const   */* __restrict  */)"%s",
                 p->fts_path);
        }
      }
#line 711
      if ((int )p->fts_level > 0) {
#line 711
        if ((int )options->cross_fs_boundaries == 0) {
#line 711
          if (((p->fts_parent)->fts_statp)->st_dev != (p->fts_statp)->st_dev) {
#line 716
            curdir_size = (fsize_t )0;
          } else {
#line 711
            goto _L___0;
          }
        } else {
#line 711
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 717
      if (curdir_empty) {
#line 718
        curdir_size = (fsize_t )0;
      } else {
        {
#line 720
        curdir_size = get_size(p->fts_accpath, p->fts_statp, options);
        }
      }
      {
#line 724
      tmp___7 = handle_file_entry(head, curdir_entry_path, curdir_size, options);
      }
#line 724
      if (tmp___7 == 0) {
#line 726
        (*count) ++;
      } else {
        {
#line 728
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot add file entry\n",
                "init_file_entries");
#line 730
        free((void *)curdir_entry_path);
#line 731
        fts_close(ftsp);
        }
#line 732
        return (1);
      }
      {
#line 736
      free((void *)curdir_entry_path);
      }
    }
    reset_directory: 
#line 741
    curdir_empty = (unsigned char)0;
#line 742
    curdir_dirsfound = (unsigned char)1;
#line 743
    curdir_addme = (unsigned char)0;
#line 744
    goto while_continue;
    case_1: /* CIL Label */ 
    {
#line 749
    curdir_empty = (unsigned char)1;
#line 750
    curdir_dirsfound = (unsigned char)0;
#line 753
    tmp___8 = valid_filename(p->fts_name, options, (unsigned char)0);
    }
#line 753
    if (! tmp___8) {
#line 754
      if ((int )options->verbose >= 1) {
        {
#line 755
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipping directory: \'%s\'\n",
                p->fts_path);
        }
      }
      {
#line 757
      fts_set(ftsp, p, 4);
      }
#line 758
      goto while_continue;
    }
#line 763
    if (options->dir_depth != -1) {
#line 763
      if ((int )p->fts_level >= options->dir_depth) {
        {
#line 765
        fts_set(ftsp, p, 4);
#line 766
        curdir_addme = (unsigned char)1;
#line 770
        curdir_empty = (unsigned char)0;
        }
      }
    }
#line 772
    goto while_continue;
    switch_default: /* CIL Label */ 
    {
#line 779
    curdir_empty = (unsigned char)0;
#line 782
    tmp___9 = valid_filename(p->fts_name, options, (unsigned char)1);
    }
#line 782
    if (! tmp___9) {
#line 783
      if ((int )options->verbose >= 1) {
        {
#line 784
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipping file: \'%s\'\n",
                p->fts_path);
        }
      }
#line 785
      goto while_continue;
    }
#line 793
    if ((int )options->leaf_dirs == 1) {
#line 793
      if (! curdir_dirsfound) {
#line 794
        goto while_continue;
      }
    }
    {
#line 797
    tmp___10 = get_size(p->fts_accpath, p->fts_statp, options);
#line 797
    tmp___11 = handle_file_entry(head, p->fts_path, tmp___10, options);
    }
#line 797
    if (tmp___11 == 0) {
#line 801
      (*count) ++;
    } else {
      {
#line 803
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot add file entry\n",
              "init_file_entries");
#line 804
      fts_close(ftsp);
      }
#line 805
      return (1);
    }
#line 807
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 812
  tmp___12 = __errno_location();
  }
#line 812
  if (*tmp___12 != 0) {
    {
#line 813
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fts_read()\n",
            file_path);
#line 814
    fts_close(ftsp);
    }
#line 815
    return (1);
  }
  {
#line 818
  tmp___13 = fts_close(ftsp);
  }
#line 818
  if (tmp___13 < 0) {
    {
#line 819
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fts_close()\n",
            file_path);
    }
  }
#line 821
  return (0);
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
void uninit_file_entries(struct file_entry *head , struct program_options *options ) 
{ 
  struct file_entry *current ;
  struct file_entry *prev ;
  int tmp ;

  {
#line 828
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 828
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  828U, "uninit_file_entries");
    }
  }
  {
#line 831
  while (1) {
    while_continue: /* CIL Label */ ;
#line 831
    if (head) {
#line 831
      if (! head->nextp) {
#line 831
        goto while_break;
      }
    } else {
#line 831
      goto while_break;
    }
#line 831
    head = head->nextp;
  }
  while_break: /* CIL Label */ ;
  }
#line 833
  current = head;
#line 834
  prev = (struct file_entry *)((void *)0);
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 836
    if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 836
      goto while_break___0;
    }
#line 837
    if ((unsigned long )current->path != (unsigned long )((void *)0)) {
      {
#line 838
      free((void *)current->path);
      }
    }
    {
#line 840
    prev = current->prevp;
#line 841
    free((void *)current);
#line 842
    current = prev;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 846
  if ((int )options->live_mode == 1) {
#line 848
    if ((int )options->verbose >= 1) {
#line 848
      if (live_status.partition_num_files > 0ULL) {
        {
#line 850
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Filled part #%d: size = %lld, %lld file(s)\n",
                live_status.partition_index, live_status.partition_size, live_status.partition_num_files);
        }
      }
    }
#line 855
    if ((unsigned long )options->out_filename == (unsigned long )((void *)0)) {
      {
#line 856
      fflush(stdout);
      }
    } else
#line 857
    if ((unsigned long )live_status.filename != (unsigned long )((void *)0)) {
      {
#line 858
      close(live_status.fd);
      }
    }
#line 861
    if ((unsigned long )options->post_part_hook != (unsigned long )((void *)0)) {
#line 861
      if (live_status.partition_num_files > 0ULL) {
        {
#line 863
        tmp = fpart_hook((char const   *)options->post_part_hook, (struct program_options  const  *)options,
                         (char const   *)live_status.filename, (pnum_t const   *)(& live_status.partition_index),
                         (fsize_t const   *)(& live_status.partition_size), (fnum_t const   *)(& live_status.partition_num_files));
        }
#line 863
        if (tmp != 0) {
#line 867
          live_status.exit_summary = 1;
        }
      }
    }
#line 870
    if ((unsigned long )live_status.filename != (unsigned long )((void *)0)) {
      {
#line 871
      free((void *)live_status.filename);
#line 872
      live_status.filename = (char *)((void *)0);
      }
    }
#line 876
    if ((int )options->verbose >= 1) {
#line 876
      if (live_status.exit_summary != 0) {
        {
#line 877
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: at least one hook exited with error !\n");
        }
      }
    }
  }
#line 880
  return;
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
int print_file_entries(struct file_entry *head , char *out_template , pnum_t num_parts ) 
{ 
  struct file_entry *start ;
  pnum_t current_chunk ;
  pnum_t current_file_entry ;
  int fd[32] ;
  char *out_filename ;
  size_t malloc_size ;
  size_t tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  pnum_t i ;
  int *tmp___2 ;
  char *tmp___3 ;
  pnum_t i___0 ;
  int tmp___4 ;
  size_t to_write ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  pnum_t i___1 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;
  pnum_t i___2 ;

  {
#line 889
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 889
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  889U, "print_file_entries");
    }
  }
#line 890
  if (! (num_parts > 0U)) {
    {
#line 890
    __assert_fail("num_parts > 0", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  890U, "print_file_entries");
    }
  }
#line 893
  if ((unsigned long )out_template == (unsigned long )((void *)0)) {
    {
#line 894
    while (1) {
      while_continue: /* CIL Label */ ;
#line 894
      if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 894
        goto while_break;
      }
      {
#line 895
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%d (%lld): %s\n",
              head->partition_index, head->size, head->path);
#line 897
      head = head->nextp;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 899
    return (0);
  }
#line 904
  start = head;
#line 905
  current_chunk = (pnum_t )0;
#line 906
  current_file_entry = (pnum_t )0;
  {
#line 910
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 910
    if (! (current_chunk * 32U + current_file_entry < num_parts)) {
#line 910
      goto while_break___0;
    }
    {
#line 916
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 916
      if (current_file_entry < 32U) {
#line 916
        if (! (current_chunk * 32U + current_file_entry < num_parts)) {
#line 916
          goto while_break___1;
        }
      } else {
#line 916
        goto while_break___1;
      }
      {
#line 919
      out_filename = (char *)((void *)0);
#line 920
      tmp = strlen((char const   *)out_template);
#line 920
      tmp___0 = get_num_digits((double )(current_chunk * 32U + current_file_entry));
#line 920
      malloc_size = ((tmp + 1UL) + (size_t )tmp___0) + 1UL;
#line 922
      tmp___1 = malloc(malloc_size);
#line 922
      out_filename = (char *)tmp___1;
      }
#line 922
      if ((unsigned long )out_filename == (unsigned long )((void *)0)) {
        {
#line 922
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
                "print_file_entries");
#line 922
        i = (pnum_t )0;
        }
        {
#line 922
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 922
          if (! (i < current_file_entry)) {
#line 922
            goto while_break___2;
          }
          {
#line 922
          close(fd[i]);
#line 922
          i ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 922
        return (1);
      }
      {
#line 929
      snprintf((char */* __restrict  */)out_filename, malloc_size, (char const   */* __restrict  */)"%s.%d",
               out_template, current_chunk * 32U + current_file_entry);
#line 932
      tmp___4 = open((char const   *)out_filename, 577, 432);
#line 932
      fd[current_file_entry] = tmp___4;
      }
#line 932
      if (tmp___4 < 0) {
        {
#line 934
        tmp___2 = __errno_location();
#line 934
        tmp___3 = strerror(*tmp___2);
#line 934
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
                out_filename, tmp___3);
#line 935
        free((void *)out_filename);
#line 938
        i___0 = (pnum_t )0;
        }
        {
#line 938
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 938
          if (! (i___0 < current_file_entry)) {
#line 938
            goto while_break___3;
          }
          {
#line 939
          close(fd[i___0]);
#line 938
          i___0 ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 940
        return (1);
      }
      {
#line 942
      free((void *)out_filename);
#line 943
      current_file_entry ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 946
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 946
      if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 946
        goto while_break___4;
      }
#line 947
      if (head->partition_index >= current_chunk * 32U) {
#line 947
        if (head->partition_index < (current_chunk + 1U) * 32U) {
          {
#line 949
          tmp___5 = strlen((char const   *)head->path);
#line 949
          to_write = tmp___5;
#line 950
          tmp___8 = write(fd[head->partition_index % 32U], (void const   *)head->path,
                          to_write);
          }
#line 950
          if (tmp___8 != (ssize_t )to_write) {
#line 950
            goto _L;
          } else {
            {
#line 950
            tmp___9 = write(fd[head->partition_index % 32U], (void const   *)"\n",
                            (size_t )1);
            }
#line 950
            if (tmp___9 != 1L) {
              _L: /* CIL Label */ 
              {
#line 952
              tmp___6 = __errno_location();
#line 952
              tmp___7 = strerror(*tmp___6);
#line 952
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                      tmp___7);
#line 955
              i___1 = (pnum_t )0;
              }
              {
#line 955
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 955
                if (i___1 < 32U) {
#line 955
                  if (! (current_chunk * 32U + i___1 < num_parts)) {
#line 955
                    goto while_break___5;
                  }
                } else {
#line 955
                  goto while_break___5;
                }
                {
#line 956
                close(fd[i___1]);
#line 955
                i___1 ++;
                }
              }
              while_break___5: /* CIL Label */ ;
              }
#line 957
              return (1);
            }
          }
        }
      }
#line 960
      head = head->nextp;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 963
    head = start;
#line 967
    i___2 = (pnum_t )0;
    {
#line 967
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 967
      if (i___2 < 32U) {
#line 967
        if (! (current_chunk * 32U + i___2 < num_parts)) {
#line 967
          goto while_break___6;
        }
      } else {
#line 967
        goto while_break___6;
      }
      {
#line 968
      close(fd[i___2]);
#line 967
      i___2 ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 970
    current_file_entry = (pnum_t )0;
#line 971
    current_chunk ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 974
  return (0);
}
}
#line 983 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c"
void init_file_entry_p(struct file_entry **file_entry_p , fnum_t num_entries , struct file_entry *head ) 
{ 
  fnum_t i ;

  {
#line 987
  if (! ((unsigned long )file_entry_p != (unsigned long )((void *)0))) {
    {
#line 987
    __assert_fail("file_entry_p != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/file_entry.c",
                  987U, "init_file_entry_p");
    }
  }
#line 989
  i = (fnum_t )0;
  {
#line 990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 990
    if ((unsigned long )head != (unsigned long )((void *)0)) {
#line 990
      if ((unsigned long )file_entry_p != (unsigned long )((void *)0)) {
#line 990
        if (! (i < num_entries)) {
#line 990
          goto while_break;
        }
      } else {
#line 990
        goto while_break;
      }
    } else {
#line 990
      goto while_break;
    }
#line 991
    *(file_entry_p + i) = head;
#line 992
    head = head->nextp;
#line 993
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 995
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/options.h"
void init_options(struct program_options *options ) ;
#line 131
void uninit_options(struct program_options *options ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.h"
char *abs_path(char const   *path ) ;
#line 78
int str_push(char ***array , unsigned int *num , char const   * const  str ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.h"
int add_partitions(struct partition **head , pnum_t num_parts , struct program_options *options ) ;
#line 47
void uninit_partitions(struct partition *head ) ;
#line 50
void print_partitions(struct partition *head ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.h"
int sort_file_entry_p(void const   *a , void const   *b ) ;
#line 36
int dispatch_file_entry_p_by_size(struct file_entry **file_entry_p , fnum_t num_entries ,
                                  struct partition *head , pnum_t num_parts ) ;
#line 38
int dispatch_empty_file_entries(struct file_entry *head , fnum_t num_entries , struct partition *part_head ,
                                pnum_t num_parts ) ;
#line 40
pnum_t dispatch_file_entries_by_limits(struct file_entry *head , struct partition **part_head ,
                                       fnum_t max_entries , fsize_t max_size , struct program_options *options ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c"
static void version(void) 
{ 


  {
  {
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fpart v0.9\nCopyright (c) 2011-2013 Ganael LAPLANCHE <ganael.laplanche@martymac.org>\nWWW: http://contribs.martymac.org\n");
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Build options: debug=");
#line 70
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no, fts=");
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"system\n");
  }
#line 77
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c"
static void usage(void) 
{ 


  {
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: fpart [OPTIONS] -n num | -f files | -s size [FILE or DIR...]\n");
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sort and pack files into partitions.\n");
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"General options:\n");
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h\tthis help\n");
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -V\tprint version\n");
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 91
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Partition control:\n");
#line 92
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -n\tpack files into <num> partitions\n");
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f\tlimit partitions to <files> files\n");
#line 94
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -s\tlimit partitions to <size> bytes\n");
#line 95
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Input control:\n");
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -i\tread file list from <infile> (stdin if \'-\' is specified)\n");
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -a\tinput contains arbitrary values (do not crawl filesystem)\n");
#line 101
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Output control:\n");
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -o\toutput partitions to <outfile> template (stdout if \'-\' is specified)\n");
#line 105
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -e\tadd ending slash to directories\n");
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v\tverbose mode (may be specified more than once to increase verbosity)\n");
#line 108
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 109
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Filesystem crawling control:\n");
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -l\tfollow symbolic links\n");
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -b\tdo not cross filesystem boundaries\n");
#line 112
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -y\tinclude files matching <pattern> only (may be specified more than once)\n");
#line 115
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -Y\tsame as -y, but ignore case\n");
#line 117
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -x\texclude files matching <pattern> (may be specified more than once)\n");
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -X\tsame as -x, but ignore case\n");
#line 122
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 123
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Directory handling:\n");
#line 124
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -z\tpack empty directories (default: pack files only)\n");
#line 126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -Z\ttreat un-readable directories as empty (implies -z)\n");
#line 128
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d\tpack directories instead of files after a certain <depth>\n");
#line 130
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -D\tpack leaf directories (i.e. containing files only, implies -z)\n");
#line 132
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 133
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Live mode:\n");
#line 134
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -L\tlive mode: generate partitions during filesystem crawling\n");
#line 136
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -w\tpre-partition hook: execute <cmd> at partition start\n");
#line 138
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -W\tpost-partition hook: execute <cmd> at partition end\n");
#line 140
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Size handling:\n");
#line 142
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -p\tpreload each partition with <num> bytes\n");
#line 143
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -q\toverload each file with <num> bytes\n");
#line 144
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -r\tround each file size up to next <num> bytes multiple\n");
#line 146
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 147
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Example: fpart -n 3 -o var-parts /var\n");
#line 148
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 149
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please report bugs to Ganael LAPLANCHE <ganael.laplanche@martymac.org>\n");
  }
#line 151
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c"
static int handle_argument(char *argument , fnum_t *totalfiles , struct file_entry **head ,
                           struct program_options *options ) 
{ 
  fsize_t input_size ;
  char *input_path ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *input_path___0 ;
  size_t input_path_len ;
  size_t tmp___3 ;
  size_t malloc_size ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 163
  if (! ((unsigned long )argument != (unsigned long )((void *)0))) {
    {
#line 163
    __assert_fail("argument != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c",
                  163U, "handle_argument");
    }
  }
#line 164
  if (! ((unsigned long )totalfiles != (unsigned long )((void *)0))) {
    {
#line 164
    __assert_fail("totalfiles != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c",
                  164U, "handle_argument");
    }
  }
#line 165
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 165
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c",
                  165U, "handle_argument");
    }
  }
#line 166
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 166
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c",
                  166U, "handle_argument");
    }
  }
#line 168
  if ((int )options->arbitrary_values == 1) {
    {
#line 170
    input_size = (fsize_t )0;
#line 171
    input_path = (char *)((void *)0);
#line 172
    tmp = strlen((char const   *)argument);
#line 172
    tmp___0 = malloc(tmp + 1UL);
#line 172
    input_path = (char *)tmp___0;
    }
#line 172
    if ((unsigned long )input_path == (unsigned long )((void *)0)) {
      {
#line 172
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "handle_argument");
      }
#line 172
      return (1);
    }
    {
#line 176
    tmp___2 = sscanf((char const   */* __restrict  */)argument, (char const   */* __restrict  */)"%lld %[^\n]",
                     & input_size, input_path);
    }
#line 176
    if (tmp___2 == 2) {
      {
#line 177
      tmp___1 = handle_file_entry(head, input_path, input_size, options);
      }
#line 177
      if (tmp___1 == 0) {
#line 178
        (*totalfiles) ++;
      } else {
        {
#line 180
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot add file entry\n",
                "handle_argument");
#line 181
        free((void *)input_path);
        }
#line 182
        return (1);
      }
    } else {
      {
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error parsing input values: %s\n",
              argument);
      }
    }
    {
#line 189
    free((void *)input_path);
    }
  } else {
    {
#line 193
    input_path___0 = (char *)((void *)0);
#line 194
    tmp___3 = strlen((char const   *)argument);
#line 194
    input_path_len = tmp___3;
#line 195
    malloc_size = input_path_len + 1UL;
#line 196
    tmp___4 = malloc(malloc_size);
#line 196
    input_path___0 = (char *)tmp___4;
    }
#line 196
    if ((unsigned long )input_path___0 == (unsigned long )((void *)0)) {
      {
#line 196
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "handle_argument");
      }
#line 196
      return (1);
    }
    {
#line 199
    snprintf((char */* __restrict  */)input_path___0, malloc_size, (char const   */* __restrict  */)"%s",
             argument);
    }
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;
#line 202
      if (input_path_len > 1UL) {
#line 202
        if ((int )*(input_path___0 + (input_path_len - 1UL)) == 47) {
#line 202
          if (! ((int )*(input_path___0 + (input_path_len - 2UL)) == 47)) {
#line 202
            goto while_break;
          }
        } else {
#line 202
          goto while_break;
        }
      } else {
#line 202
        goto while_break;
      }
#line 205
      *(input_path___0 + (input_path_len - 1UL)) = (char )'\000';
#line 206
      input_path_len --;
    }
    while_break: /* CIL Label */ ;
    }
#line 210
    if ((int )*(input_path___0 + 0) != 0) {
      {
#line 215
      tmp___5 = init_file_entries(input_path___0, head, totalfiles, options);
      }
#line 215
      if (tmp___5 != 0) {
        {
#line 216
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot initialize file entries\n",
                "handle_argument");
#line 218
        free((void *)input_path___0);
        }
#line 219
        return (1);
      }
    }
    {
#line 224
    free((void *)input_path___0);
    }
  }
#line 227
  return (0);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c"
static int handle_options(struct program_options *options , int *argcp , char ***argvp ) 
{ 
  int ch ;
  char *endptr ;
  long num_parts ;
  long tmp ;
  char *endptr___0 ;
  long long max_entries ;
  long long tmp___0 ;
  char *endptr___1 ;
  long long max_size ;
  long long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char ***dst_list ;
  unsigned int *dst_num ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *endptr___2 ;
  long dir_depth ;
  long tmp___6 ;
  size_t malloc_size ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t malloc_size___0 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *endptr___3 ;
  long long preload_size ;
  long long tmp___11 ;
  char *endptr___4 ;
  long long overload_size ;
  long long tmp___12 ;
  char *endptr___5 ;
  long long round_size ;
  long long tmp___13 ;
  char *opt_input ;
  size_t malloc_size___1 ;
  size_t tmp___14 ;
  void *tmp___15 ;

  {
#line 243
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 243
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c",
                  243U, "handle_options");
    }
  }
#line 244
  if (! ((unsigned long )argcp != (unsigned long )((void *)0))) {
    {
#line 244
    __assert_fail("argcp != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c",
                  244U, "handle_options");
    }
  }
#line 245
  if (! (*argcp > 0)) {
    {
#line 245
    __assert_fail("*argcp > 0", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c",
                  245U, "handle_options");
    }
  }
#line 246
  if (! ((unsigned long )argvp != (unsigned long )((void *)0))) {
    {
#line 246
    __assert_fail("argvp != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c",
                  246U, "handle_options");
    }
  }
#line 247
  if (! ((unsigned long )*argvp != (unsigned long )((void *)0))) {
    {
#line 247
    __assert_fail("*argvp != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c",
                  247U, "handle_options");
    }
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    ch = getopt(*argcp, (char * const  *)*argvp, "?hVn:f:s:i:ao:evlby:Y:x:X:zZd:DLw:W:p:q:r:");
    }
#line 253
    if (! (ch != -1)) {
#line 253
      goto while_break;
    }
    {
#line 262
    if (ch == 104) {
#line 262
      goto case_104;
    }
#line 262
    if (ch == 63) {
#line 262
      goto case_104;
    }
#line 264
    if (ch == 86) {
#line 264
      goto case_86;
    }
#line 266
    if (ch == 110) {
#line 266
      goto case_110;
    }
#line 277
    if (ch == 102) {
#line 277
      goto case_102;
    }
#line 289
    if (ch == 115) {
#line 289
      goto case_115;
    }
#line 300
    if (ch == 105) {
#line 300
      goto case_105;
    }
#line 316
    if (ch == 97) {
#line 316
      goto case_97;
    }
#line 319
    if (ch == 111) {
#line 319
      goto case_111;
    }
#line 340
    if (ch == 101) {
#line 340
      goto case_101;
    }
#line 343
    if (ch == 118) {
#line 343
      goto case_118;
    }
#line 346
    if (ch == 108) {
#line 346
      goto case_108;
    }
#line 349
    if (ch == 98) {
#line 349
      goto case_98;
    }
#line 355
    if (ch == 88) {
#line 355
      goto case_88;
    }
#line 355
    if (ch == 120) {
#line 355
      goto case_88;
    }
#line 355
    if (ch == 89) {
#line 355
      goto case_88;
    }
#line 355
    if (ch == 121) {
#line 355
      goto case_88;
    }
#line 385
    if (ch == 122) {
#line 385
      goto case_122;
    }
#line 388
    if (ch == 90) {
#line 388
      goto case_90;
    }
#line 392
    if (ch == 100) {
#line 392
      goto case_100;
    }
#line 403
    if (ch == 68) {
#line 403
      goto case_68;
    }
#line 407
    if (ch == 76) {
#line 407
      goto case_76;
    }
#line 410
    if (ch == 119) {
#line 410
      goto case_119;
    }
#line 425
    if (ch == 87) {
#line 425
      goto case_87;
    }
#line 440
    if (ch == 112) {
#line 440
      goto case_112;
    }
#line 455
    if (ch == 113) {
#line 455
      goto case_113;
    }
#line 470
    if (ch == 114) {
#line 470
      goto case_114;
    }
#line 260
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 263
    return (6);
    case_86: /* CIL Label */ 
#line 265
    return (10);
    case_110: /* CIL Label */ 
    {
#line 268
    endptr = (char *)((void *)0);
#line 269
    tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr),
                 10);
#line 269
    num_parts = tmp;
    }
#line 271
    if ((unsigned long )endptr == (unsigned long )optarg) {
#line 272
      return (7);
    } else
#line 271
    if ((int )*endptr != 0) {
#line 272
      return (7);
    } else
#line 271
    if (num_parts <= 0L) {
#line 272
      return (7);
    }
#line 274
    options->num_parts = (pnum_t )num_parts;
#line 275
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 279
    endptr___0 = (char *)((void *)0);
#line 280
    tmp___0 = strtoll((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___0),
                      10);
#line 280
    max_entries = tmp___0;
    }
#line 282
    if ((unsigned long )endptr___0 == (unsigned long )optarg) {
#line 284
      return (7);
    } else
#line 282
    if ((int )*endptr___0 != 0) {
#line 284
      return (7);
    } else
#line 282
    if (max_entries <= 0LL) {
#line 284
      return (7);
    }
#line 286
    options->max_entries = (fnum_t )max_entries;
#line 287
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 291
    endptr___1 = (char *)((void *)0);
#line 292
    tmp___1 = strtoll((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___1),
                      10);
#line 292
    max_size = tmp___1;
    }
#line 294
    if ((unsigned long )endptr___1 == (unsigned long )optarg) {
#line 295
      return (7);
    } else
#line 294
    if ((int )*endptr___1 != 0) {
#line 295
      return (7);
    } else
#line 294
    if (max_size <= 0LL) {
#line 295
      return (7);
    }
#line 297
    options->max_size = max_size;
#line 298
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 303
    tmp___2 = strlen((char const   *)optarg);
    }
#line 303
    if (tmp___2 == 0UL) {
#line 304
      goto switch_break;
    }
#line 306
    if ((unsigned long )options->in_filename != (unsigned long )((void *)0)) {
      {
#line 307
      free((void *)options->in_filename);
      }
    }
    {
#line 308
    options->in_filename = abs_path((char const   *)optarg);
    }
#line 309
    if ((unsigned long )options->in_filename == (unsigned long )((void *)0)) {
      {
#line 310
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot determine absolute path for file \'%s\'\n",
              "handle_options", optarg);
      }
#line 312
      return (3);
    }
#line 314
    goto switch_break;
    case_97: /* CIL Label */ 
#line 317
    options->arbitrary_values = (unsigned char)1;
#line 318
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 322
    tmp___3 = strlen((char const   *)optarg);
    }
#line 322
    if (tmp___3 == 0UL) {
#line 323
      goto switch_break;
    }
#line 325
    if ((unsigned long )options->out_filename != (unsigned long )((void *)0)) {
      {
#line 326
      free((void *)options->out_filename);
      }
    }
#line 328
    if ((int )*(optarg + 0) == 45) {
#line 328
      if ((int )*(optarg + 1) == 0) {
#line 329
        options->out_filename = (char *)((void *)0);
      } else {
#line 328
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 331
      options->out_filename = abs_path((char const   *)optarg);
      }
#line 332
      if ((unsigned long )options->out_filename == (unsigned long )((void *)0)) {
        {
#line 333
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot determine absolute path for file \'%s\'\n",
                "handle_options", optarg);
        }
#line 335
        return (3);
      }
    }
#line 338
    goto switch_break;
    case_101: /* CIL Label */ 
#line 341
    options->add_slash = (unsigned char)1;
#line 342
    goto switch_break;
    case_118: /* CIL Label */ 
#line 344
    options->verbose = (unsigned char )((int )options->verbose + 1);
#line 345
    goto switch_break;
    case_108: /* CIL Label */ 
#line 347
    options->follow_symbolic_links = (unsigned char)0;
#line 348
    goto switch_break;
    case_98: /* CIL Label */ 
#line 350
    options->cross_fs_boundaries = (unsigned char)0;
#line 351
    goto switch_break;
    case_88: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 357
    dst_list = (char ***)((void *)0);
#line 358
    dst_num = (unsigned int *)((void *)0);
    {
#line 360
    if (ch == 121) {
#line 360
      goto case_121___0;
    }
#line 364
    if (ch == 89) {
#line 364
      goto case_89___0;
    }
#line 368
    if (ch == 120) {
#line 368
      goto case_120___0;
    }
#line 372
    if (ch == 88) {
#line 372
      goto case_88___0;
    }
#line 359
    goto switch_break___0;
    case_121___0: /* CIL Label */ 
#line 361
    dst_list = & options->include_files;
#line 362
    dst_num = & options->ninclude_files;
#line 363
    goto switch_break___0;
    case_89___0: /* CIL Label */ 
#line 365
    dst_list = & options->include_files_ci;
#line 366
    dst_num = & options->ninclude_files_ci;
#line 367
    goto switch_break___0;
    case_120___0: /* CIL Label */ 
#line 369
    dst_list = & options->exclude_files;
#line 370
    dst_num = & options->nexclude_files;
#line 371
    goto switch_break___0;
    case_88___0: /* CIL Label */ 
#line 373
    dst_list = & options->exclude_files_ci;
#line 374
    dst_num = & options->nexclude_files_ci;
#line 375
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 378
    tmp___4 = strlen((char const   *)optarg);
    }
#line 378
    if (tmp___4 == 0UL) {
#line 379
      goto switch_break;
    }
    {
#line 381
    tmp___5 = str_push(dst_list, dst_num, (char const   */* const  */)optarg);
    }
#line 381
    if (tmp___5 != 0) {
#line 382
      return (3);
    }
#line 383
    goto switch_break;
    case_122: /* CIL Label */ 
#line 386
    options->empty_dirs = (unsigned char)1;
#line 387
    goto switch_break;
    case_90: /* CIL Label */ 
#line 389
    options->dnr_empty = (unsigned char)1;
#line 390
    options->empty_dirs = (unsigned char)1;
#line 391
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 394
    endptr___2 = (char *)((void *)0);
#line 395
    tmp___6 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___2),
                     10);
#line 395
    dir_depth = tmp___6;
    }
#line 397
    if ((unsigned long )endptr___2 == (unsigned long )optarg) {
#line 398
      return (7);
    } else
#line 397
    if ((int )*endptr___2 != 0) {
#line 398
      return (7);
    } else
#line 397
    if (dir_depth < 0L) {
#line 398
      return (7);
    }
#line 400
    options->dir_depth = (int )dir_depth;
#line 401
    goto switch_break;
    case_68: /* CIL Label */ 
#line 404
    options->leaf_dirs = (unsigned char)1;
#line 405
    options->empty_dirs = (unsigned char)1;
#line 406
    goto switch_break;
    case_76: /* CIL Label */ 
#line 408
    options->live_mode = (unsigned char)1;
#line 409
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 413
    tmp___7 = strlen((char const   *)optarg);
#line 413
    malloc_size = tmp___7 + 1UL;
    }
#line 414
    if (malloc_size <= 1UL) {
#line 415
      goto switch_break;
    }
#line 417
    if ((unsigned long )options->pre_part_hook != (unsigned long )((void *)0)) {
      {
#line 418
      free((void *)options->pre_part_hook);
      }
    }
    {
#line 419
    tmp___8 = malloc(malloc_size);
#line 419
    options->pre_part_hook = (char *)tmp___8;
    }
#line 419
    if ((unsigned long )options->pre_part_hook == (unsigned long )((void *)0)) {
      {
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "handle_options");
      }
#line 419
      return (3);
    }
    {
#line 422
    snprintf((char */* __restrict  */)options->pre_part_hook, malloc_size, (char const   */* __restrict  */)"%s",
             optarg);
    }
#line 423
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 428
    tmp___9 = strlen((char const   *)optarg);
#line 428
    malloc_size___0 = tmp___9 + 1UL;
    }
#line 429
    if (malloc_size___0 <= 1UL) {
#line 430
      goto switch_break;
    }
#line 432
    if ((unsigned long )options->post_part_hook != (unsigned long )((void *)0)) {
      {
#line 433
      free((void *)options->post_part_hook);
      }
    }
    {
#line 434
    tmp___10 = malloc(malloc_size___0);
#line 434
    options->post_part_hook = (char *)tmp___10;
    }
#line 434
    if ((unsigned long )options->post_part_hook == (unsigned long )((void *)0)) {
      {
#line 434
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "handle_options");
      }
#line 434
      return (3);
    }
    {
#line 437
    snprintf((char */* __restrict  */)options->post_part_hook, malloc_size___0, (char const   */* __restrict  */)"%s",
             optarg);
    }
#line 438
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 442
    endptr___3 = (char *)((void *)0);
#line 443
    tmp___11 = strtoll((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___3),
                       10);
#line 443
    preload_size = tmp___11;
    }
#line 445
    if ((unsigned long )endptr___3 == (unsigned long )optarg) {
      {
#line 447
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -p requires a value greater than 0.\n");
      }
#line 449
      return (7);
    } else
#line 445
    if ((int )*endptr___3 != 0) {
      {
#line 447
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -p requires a value greater than 0.\n");
      }
#line 449
      return (7);
    } else
#line 445
    if (preload_size <= 0LL) {
      {
#line 447
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -p requires a value greater than 0.\n");
      }
#line 449
      return (7);
    }
#line 452
    options->preload_size = preload_size;
#line 453
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 457
    endptr___4 = (char *)((void *)0);
#line 458
    tmp___12 = strtoll((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___4),
                       10);
#line 458
    overload_size = tmp___12;
    }
#line 460
    if ((unsigned long )endptr___4 == (unsigned long )optarg) {
      {
#line 462
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -q requires a value greater than 0.\n");
      }
#line 464
      return (7);
    } else
#line 460
    if ((int )*endptr___4 != 0) {
      {
#line 462
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -q requires a value greater than 0.\n");
      }
#line 464
      return (7);
    } else
#line 460
    if (overload_size <= 0LL) {
      {
#line 462
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -q requires a value greater than 0.\n");
      }
#line 464
      return (7);
    }
#line 467
    options->overload_size = overload_size;
#line 468
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 472
    endptr___5 = (char *)((void *)0);
#line 473
    tmp___13 = strtoll((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___5),
                       10);
#line 473
    round_size = tmp___13;
    }
#line 475
    if ((unsigned long )endptr___5 == (unsigned long )optarg) {
      {
#line 477
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -r requires a value greater than 1.\n");
      }
#line 479
      return (7);
    } else
#line 475
    if ((int )*endptr___5 != 0) {
      {
#line 477
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -r requires a value greater than 1.\n");
      }
#line 479
      return (7);
    } else
#line 475
    if (round_size <= 1LL) {
      {
#line 477
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -r requires a value greater than 1.\n");
      }
#line 479
      return (7);
    }
#line 482
    options->round_size = round_size;
#line 483
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  *argcp -= optind;
#line 488
  *argvp += optind;
#line 491
  if (options->num_parts == 0U) {
#line 491
    if (options->max_entries == 0ULL) {
#line 491
      if (options->max_size == 0LL) {
        {
#line 494
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please specify either -n, -f or -s.\n");
        }
#line 495
        return (7);
      }
    }
  }
#line 498
  if (options->num_parts != 0U) {
#line 498
    if (options->max_entries != 0ULL) {
      {
#line 502
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -n is incompatible with options -f, -s and -L.\n");
      }
#line 504
      return (7);
    } else
#line 498
    if (options->max_size != 0LL) {
      {
#line 502
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -n is incompatible with options -f, -s and -L.\n");
      }
#line 504
      return (7);
    } else
#line 498
    if ((int )options->live_mode != 0) {
      {
#line 502
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -n is incompatible with options -f, -s and -L.\n");
      }
#line 504
      return (7);
    }
  }
#line 507
  if ((int )options->arbitrary_values == 1) {
#line 508
    if ((int )options->add_slash != 0) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if ((int )options->follow_symbolic_links != 1) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if ((int )options->cross_fs_boundaries != 1) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if ((unsigned long )options->include_files != (unsigned long )((void *)0)) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if ((unsigned long )options->include_files_ci != (unsigned long )((void *)0)) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if ((unsigned long )options->exclude_files != (unsigned long )((void *)0)) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if ((unsigned long )options->exclude_files_ci != (unsigned long )((void *)0)) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if ((int )options->empty_dirs != 0) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if ((int )options->dnr_empty != 0) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if (options->dir_depth != -1) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    } else
#line 508
    if ((int )options->leaf_dirs != 0) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option -a is incompatible with crawling-related options.\n");
      }
#line 521
      return (7);
    }
  }
#line 525
  if ((int )options->live_mode == 0) {
#line 525
    if ((unsigned long )options->pre_part_hook != (unsigned long )((void *)0)) {
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hooks can only be used with option -L.\n");
      }
#line 530
      return (7);
    } else
#line 525
    if ((unsigned long )options->post_part_hook != (unsigned long )((void *)0)) {
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hooks can only be used with option -L.\n");
      }
#line 530
      return (7);
    }
  }
#line 533
  if ((unsigned long )options->in_filename == (unsigned long )((void *)0)) {
#line 533
    if (*argcp <= 0) {
      {
#line 535
      opt_input = (char *)"-";
#line 536
      tmp___14 = strlen((char const   *)opt_input);
#line 536
      malloc_size___1 = tmp___14 + 1UL;
#line 537
      tmp___15 = malloc(malloc_size___1);
#line 537
      options->in_filename = (char *)tmp___15;
      }
#line 537
      if ((unsigned long )options->in_filename == (unsigned long )((void *)0)) {
        {
#line 537
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
                "handle_options");
        }
#line 537
        return (3);
      }
      {
#line 540
      snprintf((char */* __restrict  */)options->in_filename, malloc_size___1, (char const   */* __restrict  */)"%s",
               opt_input);
      }
    }
  }
#line 543
  return (0);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/fpart.c"
int main(int argc , char **argv ) 
{ 
  fnum_t totalfiles ;
  struct program_options options ;
  int options_init_res ;
  int tmp ;
  int tmp___0 ;
  struct file_entry *head ;
  FILE *in_fp ;
  int *tmp___1 ;
  char *tmp___2 ;
  char line[2048] ;
  char *line_end_p ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int i ;
  int tmp___6 ;
  struct partition *part_head ;
  pnum_t num_parts ;
  struct file_entry **file_entry_p ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 548
  totalfiles = (fnum_t )0;
#line 558
  init_options(& options);
#line 561
  tmp = handle_options(& options, & argc, & argv);
#line 561
  options_init_res = tmp;
  }
#line 563
  if (options_init_res & 4) {
    {
#line 564
    usage();
    }
  }
#line 565
  if (options_init_res & 8) {
    {
#line 566
    version();
    }
  }
#line 567
  if (options_init_res & 2) {
    {
#line 568
    uninit_options(& options);
    }
#line 569
    if (options_init_res & 1) {
#line 569
      tmp___0 = 1;
    } else {
#line 569
      tmp___0 = 0;
    }
    {
#line 569
    exit(tmp___0);
    }
  }
#line 578
  head = (struct file_entry *)((void *)0);
#line 580
  if ((int )options.verbose >= 1) {
    {
#line 581
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Examining filesystem...\n");
    }
  }
#line 584
  if ((unsigned long )options.in_filename != (unsigned long )((void *)0)) {
#line 586
    in_fp = (FILE *)((void *)0);
#line 587
    if ((int )*(options.in_filename + 0) == 45) {
#line 587
      if ((int )*(options.in_filename + 1) == 0) {
#line 590
        in_fp = stdin;
      } else {
#line 587
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 594
      in_fp = fopen((char const   */* __restrict  */)options.in_filename, (char const   */* __restrict  */)"r");
      }
#line 594
      if ((unsigned long )in_fp == (unsigned long )((void *)0)) {
        {
#line 595
        tmp___1 = __errno_location();
#line 595
        tmp___2 = strerror(*tmp___1);
#line 595
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
                options.in_filename, tmp___2);
#line 597
        uninit_options(& options);
#line 598
        exit(1);
        }
      }
    }
    {
#line 604
    line_end_p = (char *)((void *)0);
#line 605
    bzero((void *)(line), (size_t )2048);
    }
    {
#line 606
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 606
      tmp___4 = fgets((char */* __restrict  */)(line), 2048, (FILE */* __restrict  */)in_fp);
      }
#line 606
      if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 606
        goto while_break;
      }
      {
#line 608
      line_end_p = strchr((char const   *)(line), '\n');
      }
#line 608
      if ((unsigned long )line_end_p != (unsigned long )((void *)0)) {
#line 609
        *line_end_p = (char )'\000';
      }
      {
#line 611
      tmp___3 = handle_argument(line, & totalfiles, & head, & options);
      }
#line 611
      if (tmp___3 != 0) {
        {
#line 612
        uninit_file_entries(head, & options);
#line 613
        uninit_options(& options);
#line 614
        exit(1);
        }
      }
      {
#line 618
      bzero((void *)(line), (size_t )2048);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 622
    tmp___5 = ferror(in_fp);
    }
#line 622
    if (tmp___5 != 0) {
      {
#line 623
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading from input stream\n");
      }
    }
#line 627
    if ((unsigned long )in_fp != (unsigned long )((void *)0)) {
      {
#line 628
      fclose(in_fp);
      }
    }
  }
#line 637
  i = 0;
  {
#line 637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 637
    if (! (i < argc)) {
#line 637
      goto while_break___0;
    }
    {
#line 638
    tmp___6 = handle_argument(*(argv + i), & totalfiles, & head, & options);
    }
#line 638
    if (tmp___6 != 0) {
      {
#line 639
      uninit_file_entries(head, & options);
#line 640
      uninit_options(& options);
#line 641
      exit(1);
      }
    }
#line 637
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 650
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 650
    if (head) {
#line 650
      if (! head->prevp) {
#line 650
        goto while_break___1;
      }
    } else {
#line 650
      goto while_break___1;
    }
#line 650
    head = head->prevp;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 653
  if (totalfiles <= 0ULL) {
    {
#line 654
    uninit_file_entries(head, & options);
#line 656
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lld file(s) found.\n",
            totalfiles);
#line 657
    uninit_options(& options);
#line 658
    exit(0);
    }
  } else
#line 653
  if ((int )options.live_mode == 1) {
    {
#line 654
    uninit_file_entries(head, & options);
#line 656
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lld file(s) found.\n",
            totalfiles);
#line 657
    uninit_options(& options);
#line 658
    exit(0);
    }
  }
  {
#line 662
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lld file(s) found.\n",
          totalfiles);
  }
#line 664
  if ((int )options.verbose >= 1) {
    {
#line 665
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorting entries...\n");
    }
  }
#line 672
  part_head = (struct partition *)((void *)0);
#line 673
  num_parts = options.num_parts;
#line 676
  if (options.num_parts != 0U) {
    {
#line 678
    file_entry_p = (struct file_entry **)((void *)0);
#line 680
    tmp___7 = malloc((size_t )((fnum_t )sizeof(struct file_entry *) * totalfiles));
#line 680
    file_entry_p = (struct file_entry **)tmp___7;
    }
#line 680
    if ((unsigned long )file_entry_p == (unsigned long )((void *)0)) {
      {
#line 680
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "main");
#line 680
      uninit_file_entries(head, & options);
#line 680
      uninit_options(& options);
#line 680
      exit(1);
      }
    }
    {
#line 687
    init_file_entry_p(file_entry_p, totalfiles, head);
#line 690
    qsort((void *)(file_entry_p + 0), (size_t )totalfiles, sizeof(struct file_entry *),
          & sort_file_entry_p);
#line 695
    tmp___8 = add_partitions(& part_head, options.num_parts, & options);
    }
#line 695
    if (tmp___8 != 0) {
      {
#line 696
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot init list of partitions\n",
              "main");
#line 698
      uninit_partitions(part_head);
#line 699
      free((void *)file_entry_p);
#line 700
      uninit_file_entries(head, & options);
#line 701
      uninit_options(& options);
#line 702
      exit(1);
      }
    }
    {
#line 705
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 705
      if (part_head) {
#line 705
        if (! part_head->prevp) {
#line 705
          goto while_break___2;
        }
      } else {
#line 705
        goto while_break___2;
      }
#line 705
      part_head = part_head->prevp;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 708
    tmp___9 = dispatch_file_entry_p_by_size(file_entry_p, totalfiles, part_head, options.num_parts);
    }
#line 708
    if (tmp___9 != 0) {
      {
#line 710
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): unable to dispatch file entries\n",
              "main");
#line 712
      uninit_partitions(part_head);
#line 713
      free((void *)file_entry_p);
#line 714
      uninit_file_entries(head, & options);
#line 715
      uninit_options(& options);
#line 716
      exit(1);
      }
    }
    {
#line 720
    tmp___10 = dispatch_empty_file_entries(head, totalfiles, part_head, options.num_parts);
    }
#line 720
    if (tmp___10 != 0) {
      {
#line 722
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): unable to dispatch empty file entries\n",
              "main");
#line 724
      uninit_partitions(part_head);
#line 725
      free((void *)file_entry_p);
#line 726
      uninit_file_entries(head, & options);
#line 727
      uninit_options(& options);
#line 728
      exit(1);
      }
    }
    {
#line 732
    free((void *)file_entry_p);
    }
  } else {
    {
#line 742
    num_parts = dispatch_file_entries_by_limits(head, & part_head, options.max_entries,
                                                options.max_size, & options);
    }
#line 742
    if (num_parts == 0U) {
      {
#line 745
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): unable to dispatch file entries\n",
              "main");
#line 747
      uninit_partitions(part_head);
#line 748
      uninit_file_entries(head, & options);
#line 749
      uninit_options(& options);
#line 750
      exit(1);
      }
    }
    {
#line 755
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 755
      if (part_head) {
#line 755
        if (! part_head->prevp) {
#line 755
          goto while_break___3;
        }
      } else {
#line 755
        goto while_break___3;
      }
#line 755
      part_head = part_head->prevp;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 763
  print_partitions(part_head);
  }
#line 765
  if ((int )options.verbose >= 1) {
    {
#line 766
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Writing output lists...\n");
    }
  }
  {
#line 769
  print_file_entries(head, options.out_filename, num_parts);
  }
#line 771
  if ((int )options.verbose >= 1) {
    {
#line 772
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cleaning up...\n");
    }
  }
  {
#line 775
  uninit_partitions(part_head);
#line 776
  uninit_file_entries(head, & options);
#line 777
  uninit_options(& options);
#line 778
  exit(0);
  }
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.h"
void str_cleanup(char ***array , unsigned int *num ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/options.c"
void init_options(struct program_options *options ) 
{ 


  {
#line 73
  options->num_parts = (pnum_t )0;
#line 74
  options->max_entries = (fnum_t )0;
#line 75
  options->max_size = (fsize_t )0;
#line 76
  options->in_filename = (char *)((void *)0);
#line 77
  options->arbitrary_values = (unsigned char)0;
#line 78
  options->out_filename = (char *)((void *)0);
#line 79
  options->add_slash = (unsigned char)0;
#line 80
  options->verbose = (unsigned char)0;
#line 81
  options->follow_symbolic_links = (unsigned char)1;
#line 82
  options->cross_fs_boundaries = (unsigned char)1;
#line 83
  options->include_files = (char **)((void *)0);
#line 84
  options->ninclude_files = 0U;
#line 85
  options->include_files_ci = (char **)((void *)0);
#line 86
  options->ninclude_files_ci = 0U;
#line 87
  options->exclude_files = (char **)((void *)0);
#line 88
  options->nexclude_files = 0U;
#line 89
  options->exclude_files_ci = (char **)((void *)0);
#line 90
  options->nexclude_files_ci = 0U;
#line 91
  options->empty_dirs = (unsigned char)0;
#line 92
  options->dnr_empty = (unsigned char)0;
#line 93
  options->dir_depth = -1;
#line 94
  options->leaf_dirs = (unsigned char)0;
#line 95
  options->live_mode = (unsigned char)0;
#line 96
  options->pre_part_hook = (char *)((void *)0);
#line 97
  options->post_part_hook = (char *)((void *)0);
#line 98
  options->preload_size = (fsize_t )0;
#line 99
  options->overload_size = (fsize_t )0;
#line 100
  options->round_size = (fsize_t )1;
#line 101
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/options.c"
void uninit_options(struct program_options *options ) 
{ 


  {
#line 107
  options->round_size = (fsize_t )1;
#line 108
  options->overload_size = (fsize_t )0;
#line 109
  options->preload_size = (fsize_t )0;
#line 110
  if ((unsigned long )options->post_part_hook != (unsigned long )((void *)0)) {
    {
#line 111
    free((void *)options->post_part_hook);
    }
  }
#line 112
  if ((unsigned long )options->pre_part_hook != (unsigned long )((void *)0)) {
    {
#line 113
    free((void *)options->pre_part_hook);
    }
  }
#line 114
  options->live_mode = (unsigned char)0;
#line 115
  options->leaf_dirs = (unsigned char)0;
#line 116
  options->dir_depth = -1;
#line 117
  options->dnr_empty = (unsigned char)0;
#line 118
  options->empty_dirs = (unsigned char)0;
#line 119
  if ((unsigned long )options->exclude_files_ci != (unsigned long )((void *)0)) {
    {
#line 120
    str_cleanup(& options->exclude_files_ci, & options->nexclude_files_ci);
    }
  }
#line 122
  if ((unsigned long )options->exclude_files != (unsigned long )((void *)0)) {
    {
#line 123
    str_cleanup(& options->exclude_files, & options->nexclude_files);
    }
  }
#line 125
  if ((unsigned long )options->include_files_ci != (unsigned long )((void *)0)) {
    {
#line 126
    str_cleanup(& options->include_files_ci, & options->ninclude_files_ci);
    }
  }
#line 128
  if ((unsigned long )options->include_files != (unsigned long )((void *)0)) {
    {
#line 129
    str_cleanup(& options->include_files, & options->ninclude_files);
    }
  }
#line 131
  options->cross_fs_boundaries = (unsigned char)1;
#line 132
  options->follow_symbolic_links = (unsigned char)1;
#line 133
  options->verbose = (unsigned char)0;
#line 134
  options->add_slash = (unsigned char)0;
#line 135
  if ((unsigned long )options->out_filename != (unsigned long )((void *)0)) {
    {
#line 136
    free((void *)options->out_filename);
    }
  }
#line 137
  options->arbitrary_values = (unsigned char)0;
#line 138
  if ((unsigned long )options->in_filename != (unsigned long )((void *)0)) {
    {
#line 139
    free((void *)options->in_filename);
    }
  }
#line 140
  options->max_size = (fsize_t )0;
#line 141
  options->max_entries = (fnum_t )0;
#line 142
  options->num_parts = (pnum_t )0;
#line 143
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.h"
pnum_t find_smallest_partition_index(struct partition *head ) ;
#line 49
struct partition *get_partition_at(struct partition *head , pnum_t index ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c"
int add_partitions(struct partition **head , pnum_t num_parts , struct program_options *options ) 
{ 
  struct partition **current ;
  struct partition *previous ;
  pnum_t i ;
  void *tmp ;

  {
#line 53
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 53
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c",
                  53U, "add_partitions");
    }
  }
#line 54
  if (! (num_parts > 0U)) {
    {
#line 54
    __assert_fail("num_parts > 0", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c",
                  54U, "add_partitions");
    }
  }
#line 55
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 55
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c",
                  55U, "add_partitions");
    }
  }
#line 57
  current = head;
#line 58
  previous = (struct partition *)((void *)0);
#line 60
  i = (pnum_t )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < num_parts)) {
#line 61
      goto while_break;
    }
    {
#line 63
    previous = *current;
#line 64
    tmp = malloc(sizeof(struct partition ));
#line 64
    *current = (struct partition *)tmp;
    }
#line 64
    if ((unsigned long )*current == (unsigned long )((void *)0)) {
      {
#line 64
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
              "add_partitions");
      }
#line 64
      return (1);
    }
#line 69
    if ((unsigned long )*head == (unsigned long )((void *)0)) {
#line 70
      *head = *current;
    }
#line 73
    (*current)->size = options->preload_size;
#line 74
    (*current)->num_files = (fnum_t )0;
#line 75
    (*current)->nextp = (struct partition *)((void *)0);
#line 76
    (*current)->prevp = previous;
#line 79
    if ((unsigned long )previous != (unsigned long )((void *)0)) {
#line 80
      previous->nextp = *current;
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c"
void uninit_partitions(struct partition *head ) 
{ 
  struct partition *current ;
  struct partition *prev ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (head) {
#line 92
      if (! head->nextp) {
#line 92
        goto while_break;
      }
    } else {
#line 92
      goto while_break;
    }
#line 92
    head = head->nextp;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  current = head;
#line 95
  prev = (struct partition *)((void *)0);
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 97
      goto while_break___0;
    }
    {
#line 98
    prev = current->prevp;
#line 99
    free((void *)current);
#line 100
    current = prev;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c"
pnum_t find_smallest_partition_index(struct partition *head ) 
{ 
  fsize_t smallest_partition_value ;
  pnum_t smallest_partition_index ;
  pnum_t i ;

  {
#line 109
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 109
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c",
                  109U, "find_smallest_partition_index");
    }
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (head) {
#line 112
      if (! head->prevp) {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
#line 112
    head = head->prevp;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  smallest_partition_value = head->size;
#line 116
  smallest_partition_index = (pnum_t )0;
#line 118
  i = (pnum_t )0;
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 119
      goto while_break___0;
    }
#line 120
    if (head->size < smallest_partition_value) {
#line 121
      smallest_partition_value = head->size;
#line 122
      smallest_partition_index = i;
    }
#line 124
    head = head->nextp;
#line 125
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  return (smallest_partition_index);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c"
struct partition *get_partition_at(struct partition *head , pnum_t index ) 
{ 
  pnum_t i ;

  {
#line 134
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 134
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c",
                  134U, "get_partition_at");
    }
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (head) {
#line 137
      if (! head->prevp) {
#line 137
        goto while_break;
      }
    } else {
#line 137
      goto while_break;
    }
#line 137
    head = head->prevp;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  i = (pnum_t )0;
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if ((unsigned long )head != (unsigned long )((void *)0)) {
#line 140
      if (! (i < index)) {
#line 140
        goto while_break___0;
      }
    } else {
#line 140
      goto while_break___0;
    }
#line 141
    head = head->nextp;
#line 142
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  return (head);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/partition.c"
void print_partitions(struct partition *head ) 
{ 
  pnum_t i ;

  {
#line 151
  i = (pnum_t )0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 152
      goto while_break;
    }
    {
#line 153
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Part #%d: size = %lld, %lld file(s)\n",
            i, head->size, head->num_files);
#line 155
    head = head->nextp;
#line 156
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.h"
int str_match(char const   * const  * const  array , unsigned int const   num , char const   * const  str ,
              unsigned char const   ignore_case ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 545
extern char **environ ;
#line 78 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c"
unsigned int get_num_digits(double i ) 
{ 
  double logvalue ;
  double tmp ;
  unsigned int tmp___0 ;

  {
#line 81
  if ((int )i == 0) {
#line 82
    return (1U);
  }
  {
#line 84
  tmp = log10(i);
#line 84
  logvalue = tmp;
  }
#line 85
  if (logvalue >= (double )0) {
#line 85
    tmp___0 = (unsigned int )logvalue + 1U;
  } else {
#line 85
    tmp___0 = 0U;
  }
#line 85
  return (tmp___0);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c"
fsize_t get_size(char *file_path , struct stat *file_stat , struct program_options *options ) 
{ 
  fsize_t file_size ;
  __off_t tmp ;
  FTS *ftsp ;
  FTSENT *p ;
  int fts_options ;
  int tmp___0 ;
  int tmp___1 ;
  char *fts_argv[2] ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 94
  if (! ((unsigned long )file_path != (unsigned long )((void *)0))) {
    {
#line 94
    __assert_fail("file_path != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  94U, "get_size");
    }
  }
#line 95
  if (! ((unsigned long )file_stat != (unsigned long )((void *)0))) {
    {
#line 95
    __assert_fail("file_stat != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  95U, "get_size");
    }
  }
#line 96
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 96
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  96U, "get_size");
    }
  }
#line 98
  file_size = (fsize_t )0;
#line 102
  if (! ((file_stat->st_mode & 61440U) == 16384U)) {
#line 103
    if ((file_stat->st_mode & 61440U) == 32768U) {
#line 103
      tmp = file_stat->st_size;
    } else {
#line 103
      tmp = (__off_t )0;
    }
#line 103
    return ((fsize_t )tmp);
  }
#line 107
  ftsp = (FTS *)((void *)0);
#line 108
  p = (FTSENT *)((void *)0);
#line 109
  if ((int )options->follow_symbolic_links == 0) {
#line 109
    tmp___0 = 2;
  } else {
#line 109
    tmp___0 = 16;
  }
#line 109
  fts_options = tmp___0;
#line 111
  if ((int )options->cross_fs_boundaries == 0) {
#line 111
    tmp___1 = 64;
  } else {
#line 111
    tmp___1 = 0;
  }
  {
#line 111
  fts_options |= tmp___1;
#line 114
  fts_argv[0] = file_path;
#line 114
  fts_argv[1] = (char *)((void *)0);
#line 115
  ftsp = fts_open((char * const  *)(fts_argv), fts_options, (int (*)(FTSENT const   ** ,
                                                                     FTSENT const   ** ))((void *)0));
  }
#line 115
  if ((unsigned long )ftsp == (unsigned long )((void *)0)) {
    {
#line 116
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fts_open()\n",
            file_path);
    }
#line 117
    return ((fsize_t )0);
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    p = fts_read(ftsp);
    }
#line 120
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 120
      goto while_break;
    }
    {
#line 124
    if ((int )p->fts_info == 10) {
#line 124
      goto case_10;
    }
#line 124
    if ((int )p->fts_info == 7) {
#line 124
      goto case_10;
    }
#line 124
    if ((int )p->fts_info == 4) {
#line 124
      goto case_10;
    }
#line 129
    if ((int )p->fts_info == 2) {
#line 129
      goto case_2;
    }
#line 133
    if ((int )p->fts_info == 8) {
#line 133
      goto case_8;
    }
#line 138
    goto switch_default;
    case_10: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 125
    tmp___2 = strerror(p->fts_errno);
#line 125
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            p->fts_path, tmp___2);
    }
#line 127
    goto while_continue;
    case_2: /* CIL Label */ 
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: filesystem loop detected\n",
            p->fts_path);
    }
#line 131
    goto while_continue;
    case_8: /* CIL Label */ 
#line 134
    file_size += (fsize_t )(p->fts_statp)->st_size;
#line 135
    goto while_continue;
    switch_default: /* CIL Label */ 
#line 139
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  tmp___3 = __errno_location();
  }
#line 143
  if (*tmp___3 != 0) {
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fts_read()\n",
            file_path);
    }
  }
  {
#line 146
  tmp___4 = fts_close(ftsp);
  }
#line 146
  if (tmp___4 < 0) {
    {
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fts_close()\n",
            file_path);
    }
  }
#line 149
  return (file_size);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c"
char *abs_path(char const   *path ) 
{ 
  char *cwd ;
  char *abs___0 ;
  size_t malloc_size ;
  int *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 159
  if (! ((unsigned long )path != (unsigned long )((void *)0))) {
    {
#line 159
    __assert_fail("path != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  159U, "abs_path");
    }
  }
#line 161
  cwd = (char *)((void *)0);
#line 162
  abs___0 = (char *)((void *)0);
#line 163
  malloc_size = (size_t )0;
#line 165
  if ((int const   )*(path + 0) == 0) {
    {
#line 166
    tmp = __errno_location();
#line 166
    *tmp = 2;
    }
#line 167
    return ((char *)((void *)0));
  }
#line 170
  if ((int const   )*(path + 0) != 47) {
#line 170
    if ((int const   )*(path + 0) != 45) {
#line 170
      goto _L;
    } else
#line 170
    if ((int const   )*(path + 1) != 0) {
      _L: /* CIL Label */ 
      {
#line 173
      tmp___0 = malloc((size_t )4096);
#line 173
      cwd = (char *)tmp___0;
      }
#line 173
      if ((unsigned long )cwd == (unsigned long )((void *)0)) {
        {
#line 173
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
                "abs_path");
        }
#line 173
        return ((char *)((void *)0));
      }
      {
#line 176
      tmp___1 = getcwd(cwd, (size_t )4096);
      }
#line 176
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 177
        free((void *)cwd);
        }
#line 178
        return ((char *)((void *)0));
      }
      {
#line 180
      tmp___2 = strlen((char const   *)cwd);
#line 180
      malloc_size += tmp___2 + 1UL;
      }
    }
  }
  {
#line 182
  tmp___3 = strlen(path);
#line 182
  malloc_size += tmp___3 + 1UL;
#line 184
  tmp___4 = malloc(malloc_size);
#line 184
  abs___0 = (char *)tmp___4;
  }
#line 184
  if ((unsigned long )abs___0 == (unsigned long )((void *)0)) {
    {
#line 184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
            "abs_path");
    }
  } else
#line 188
  if ((unsigned long )cwd != (unsigned long )((void *)0)) {
    {
#line 189
    snprintf((char */* __restrict  */)abs___0, malloc_size, (char const   */* __restrict  */)"%s/%s",
             cwd, path);
    }
  } else {
    {
#line 191
    snprintf((char */* __restrict  */)abs___0, malloc_size, (char const   */* __restrict  */)"%s",
             path);
    }
  }
#line 194
  if ((unsigned long )cwd != (unsigned long )((void *)0)) {
    {
#line 195
    free((void *)cwd);
    }
  }
#line 197
  return (abs___0);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c"
int str_push(char ***array , unsigned int *num , char const   * const  str ) 
{ 
  char *tmp_str ;
  size_t malloc_size ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 206
  if (! ((unsigned long )array != (unsigned long )((void *)0))) {
    {
#line 206
    __assert_fail("array != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  206U, "str_push");
    }
  }
#line 207
  if (! ((unsigned long )num != (unsigned long )((void *)0))) {
    {
#line 207
    __assert_fail("num != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  207U, "str_push");
    }
  }
#line 208
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 208
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  208U, "str_push");
    }
  }
#line 209
  if ((unsigned long )*array == (unsigned long )((void *)0)) {
#line 209
    if (! (*num == 0U)) {
#line 209
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 209
  if (*num > 0U) {
#line 209
    if (! ((unsigned long )*array != (unsigned long )((void *)0))) {
      {
#line 209
      __assert_fail("((*array == ((void *)0)) && (*num == 0)) || ((*num > 0) && (*array != ((void *)0)))",
                    "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                    210U, "str_push");
      }
    }
  } else {
    {
#line 209
    __assert_fail("((*array == ((void *)0)) && (*num == 0)) || ((*num > 0) && (*array != ((void *)0)))",
                  "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  210U, "str_push");
    }
  }
  {
#line 213
  tmp_str = (char *)((void *)0);
#line 214
  tmp = strlen((char const   *)str);
#line 214
  malloc_size = tmp + 1UL;
#line 215
  tmp___0 = malloc(malloc_size);
#line 215
  tmp_str = (char *)tmp___0;
  }
#line 215
  if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
    {
#line 215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
            "str_push");
    }
#line 215
    return (1);
  }
  {
#line 218
  snprintf((char */* __restrict  */)tmp_str, malloc_size, (char const   */* __restrict  */)"%s",
           str);
#line 221
  tmp___1 = realloc((void *)*array, sizeof(char *) * (unsigned long )(*num + 1U));
#line 221
  *array = (char **)tmp___1;
  }
#line 221
  if ((unsigned long )*array == (unsigned long )((void *)0)) {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot reallocate memory\n",
            "str_push");
#line 221
    free((void *)tmp_str);
    }
#line 221
    return (1);
  }
#line 225
  *(*array + *num) = tmp_str;
#line 226
  (*num) ++;
#line 228
  return (0);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c"
void str_cleanup(char ***array , unsigned int *num ) 
{ 


  {
#line 238
  if (! ((unsigned long )num != (unsigned long )((void *)0))) {
    {
#line 238
    __assert_fail("num != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  238U, "str_cleanup");
    }
  }
#line 239
  if (! ((unsigned long )array != (unsigned long )((void *)0))) {
    {
#line 239
    __assert_fail("array != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  239U, "str_cleanup");
    }
  }
#line 240
  if ((unsigned long )*array == (unsigned long )((void *)0)) {
#line 240
    if (! (*num == 0U)) {
#line 240
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 240
  if (*num > 0U) {
#line 240
    if (! ((unsigned long )*array != (unsigned long )((void *)0))) {
      {
#line 240
      __assert_fail("((*array == ((void *)0)) && (*num == 0)) || ((*num > 0) && (*array != ((void *)0)))",
                    "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                    241U, "str_cleanup");
      }
    }
  } else {
    {
#line 240
    __assert_fail("((*array == ((void *)0)) && (*num == 0)) || ((*num > 0) && (*array != ((void *)0)))",
                  "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  241U, "str_cleanup");
    }
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (*num > 0U)) {
#line 243
      goto while_break;
    }
#line 244
    if ((unsigned long )*(*array + (*num - 1U)) != (unsigned long )((void *)0)) {
      {
#line 245
      free((void *)*(*array + (*num - 1U)));
#line 246
      *(*array + (*num - 1U)) = (char *)((void *)0);
#line 247
      (*num) --;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  free((void *)*array);
#line 251
  *array = (char **)((void *)0);
  }
#line 253
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c"
int str_match(char const   * const  * const  array , unsigned int const   num , char const   * const  str ,
              unsigned char const   ignore_case ) 
{ 
  unsigned int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 262
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 262
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  262U, "str_match");
    }
  }
#line 264
  if ((unsigned long )array == (unsigned long )((void *)0)) {
#line 265
    return (0);
  }
#line 267
  i = 0U;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (i < (unsigned int )num)) {
#line 268
      goto while_break;
    }
#line 269
    if (ignore_case) {
#line 269
      tmp = 1 << 4;
    } else {
#line 269
      tmp = 0;
    }
    {
#line 269
    tmp___0 = fnmatch((char const   *)*(array + i), (char const   *)str, tmp);
    }
#line 269
    if (tmp___0 == 0) {
#line 270
      return (1);
    }
#line 271
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return (0);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c"
int valid_filename(char *filename , struct program_options *options , unsigned char is_leaf ) 
{ 
  int valid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 284
  if (! ((unsigned long )filename != (unsigned long )((void *)0))) {
    {
#line 284
    __assert_fail("filename != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  284U, "valid_filename");
    }
  }
#line 285
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 285
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  285U, "valid_filename");
    }
  }
#line 287
  valid = 1;
#line 295
  if (is_leaf) {
#line 296
    if ((unsigned long )options->include_files != (unsigned long )((void *)0)) {
#line 296
      goto _L;
    } else
#line 296
    if ((unsigned long )options->include_files_ci != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 299
      valid = 0;
#line 301
      tmp = str_match((char const   * const  */* const  */)options->include_files,
                      (unsigned int const   )options->ninclude_files, (char const   */* const  */)filename,
                      (unsigned char const   )0);
      }
#line 301
      if (tmp) {
#line 305
        valid = 1;
      } else {
        {
#line 301
        tmp___0 = str_match((char const   * const  */* const  */)options->include_files_ci,
                            (unsigned int const   )options->ninclude_files_ci, (char const   */* const  */)filename,
                            (unsigned char const   )1);
        }
#line 301
        if (tmp___0) {
#line 305
          valid = 1;
        }
      }
    }
  }
  {
#line 310
  tmp___1 = str_match((char const   * const  */* const  */)options->exclude_files,
                      (unsigned int const   )options->nexclude_files, (char const   */* const  */)filename,
                      (unsigned char const   )0);
  }
#line 310
  if (tmp___1) {
#line 314
    valid = 0;
  } else {
    {
#line 310
    tmp___2 = str_match((char const   * const  */* const  */)options->exclude_files_ci,
                        (unsigned int const   )options->nexclude_files_ci, (char const   */* const  */)filename,
                        (unsigned char const   )1);
    }
#line 310
    if (tmp___2) {
#line 314
      valid = 0;
    }
  }
#line 322
  return (valid);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c"
char **clone_env(void) 
{ 
  unsigned int env_size ;
  char **new_env ;
  size_t malloc_size ;
  void *tmp ;

  {
#line 331
  env_size = 0U;
#line 332
  new_env = (char **)((void *)0);
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! *(environ + env_size)) {
#line 338
      goto while_break;
    }
#line 338
    env_size ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 340
  env_size ++;
#line 342
  malloc_size = sizeof(char *) * (unsigned long )env_size;
#line 343
  tmp = malloc(malloc_size);
#line 343
  new_env = (char **)tmp;
  }
#line 343
  if ((unsigned long )new_env == (unsigned long )((void *)0)) {
    {
#line 343
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
            "clone_env");
    }
  } else {
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 348
      if (! (env_size > 0U)) {
#line 348
        goto while_break___0;
      }
#line 349
      *(new_env + (env_size - 1U)) = *(environ + (env_size - 1U));
#line 350
      env_size --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 353
  return (new_env);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c"
int push_env(char *str , char ***env ) 
{ 
  unsigned int env_size ;
  char **new_env ;
  size_t malloc_size ;
  void *tmp ;

  {
#line 363
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 363
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  363U, "push_env");
    }
  }
#line 364
  if (! ((unsigned long )env != (unsigned long )((void *)0))) {
    {
#line 364
    __assert_fail("env != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  364U, "push_env");
    }
  }
#line 365
  if (! ((unsigned long )*env != (unsigned long )((void *)0))) {
    {
#line 365
    __assert_fail("*env != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/utils.c",
                  365U, "push_env");
    }
  }
#line 367
  env_size = 0U;
#line 368
  new_env = (char **)((void *)0);
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! *(*env + env_size)) {
#line 371
      goto while_break;
    }
#line 371
    env_size ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 373
  env_size ++;
#line 375
  env_size ++;
#line 377
  malloc_size = sizeof(char *) * (unsigned long )env_size;
#line 378
  tmp = malloc(malloc_size);
#line 378
  new_env = (char **)tmp;
  }
#line 378
  if ((unsigned long )new_env == (unsigned long )((void *)0)) {
    {
#line 378
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot allocate memory\n",
            "push_env");
    }
#line 378
    return (1);
  }
#line 383
  *(new_env + (env_size - 1U)) = (char *)((void *)0);
#line 384
  *(new_env + (env_size - 2U)) = str;
#line 385
  env_size -= 2U;
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (env_size > 0U)) {
#line 386
      goto while_break___0;
    }
#line 387
    *(new_env + (env_size - 1U)) = *(*env + (env_size - 1U));
#line 388
    env_size --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 392
  free((void *)*env);
#line 393
  *env = new_env;
  }
#line 395
  return (0);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c"
int sort_file_entry_p(void const   *a , void const   *b ) 
{ 


  {
#line 49
  if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 49
    if (! ((unsigned long )*((struct file_entry **)a) != (unsigned long )((void *)0))) {
      {
#line 49
      __assert_fail("(a != ((void *)0)) && (*(struct file_entry **)a != ((void *)0))",
                    "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                    49U, "sort_file_entry_p");
      }
    }
  } else {
    {
#line 49
    __assert_fail("(a != ((void *)0)) && (*(struct file_entry **)a != ((void *)0))",
                  "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  49U, "sort_file_entry_p");
    }
  }
#line 50
  if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 50
    if (! ((unsigned long )*((struct file_entry **)b) != (unsigned long )((void *)0))) {
      {
#line 50
      __assert_fail("(b != ((void *)0)) && (*(struct file_entry **)b != ((void *)0))",
                    "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                    50U, "sort_file_entry_p");
      }
    }
  } else {
    {
#line 50
    __assert_fail("(b != ((void *)0)) && (*(struct file_entry **)b != ((void *)0))",
                  "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  50U, "sort_file_entry_p");
    }
  }
#line 52
  if ((*((struct file_entry **)a))->size < (*((struct file_entry **)b))->size) {
#line 53
    return (1);
  } else
#line 54
  if ((*((struct file_entry **)a))->size > (*((struct file_entry **)b))->size) {
#line 55
    return (-1);
  } else {
#line 57
    return (0);
  }
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c"
int dispatch_file_entry_p_by_size(struct file_entry **file_entry_p , fnum_t num_entries ,
                                  struct partition *head , pnum_t num_parts ) 
{ 
  fnum_t i ;
  pnum_t smallest_partition_index ;
  pnum_t tmp ;
  struct partition *smallest_partition ;
  struct partition *tmp___0 ;

  {
#line 68
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 68
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  68U, "dispatch_file_entry_p_by_size");
    }
  }
#line 69
  if (! (num_parts > 0U)) {
    {
#line 69
    __assert_fail("num_parts > 0", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  69U, "dispatch_file_entry_p_by_size");
    }
  }
#line 71
  i = (fnum_t )0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if ((unsigned long )file_entry_p != (unsigned long )((void *)0)) {
#line 72
      if ((unsigned long )*(file_entry_p + i) != (unsigned long )((void *)0)) {
#line 72
        if (! (i < num_entries)) {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    } else {
#line 72
      goto while_break;
    }
    {
#line 75
    tmp = find_smallest_partition_index(head);
#line 75
    smallest_partition_index = tmp;
#line 76
    tmp___0 = get_partition_at(head, smallest_partition_index);
#line 76
    smallest_partition = tmp___0;
    }
#line 78
    if ((unsigned long )smallest_partition == (unsigned long )((void *)0)) {
      {
#line 79
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): get_partition_at() returned NULL\n",
              "dispatch_file_entry_p_by_size");
      }
#line 81
      return (1);
    }
#line 84
    (*(file_entry_p + i))->partition_index = smallest_partition_index;
#line 91
    smallest_partition->size += (*(file_entry_p + i))->size;
#line 92
    (smallest_partition->num_files) ++;
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (0);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c"
int dispatch_empty_file_entries(struct file_entry *head , fnum_t num_entries , struct partition *part_head ,
                                pnum_t num_parts ) 
{ 
  struct file_entry *start ;
  fnum_t num_empty_entries ;
  fnum_t mean_files ;
  pnum_t j ;
  struct partition *part_start ;
  struct partition *previous_partition ;
  struct partition *tmp ;

  {
#line 107
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 107
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  107U, "dispatch_empty_file_entries");
    }
  }
#line 108
  if (! ((unsigned long )part_head != (unsigned long )((void *)0))) {
    {
#line 108
    __assert_fail("part_head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  108U, "dispatch_empty_file_entries");
    }
  }
#line 109
  if (! (num_parts > 0U)) {
    {
#line 109
    __assert_fail("num_parts > 0", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  109U, "dispatch_empty_file_entries");
    }
  }
#line 112
  start = head;
#line 115
  num_empty_entries = (fnum_t )0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
#line 117
    if (head->size == 0LL) {
#line 118
      num_empty_entries ++;
    }
#line 119
    head = head->nextp;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  head = start;
#line 125
  mean_files = num_entries / (fnum_t )num_parts;
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (part_head) {
#line 130
      if (! part_head->prevp) {
#line 130
        goto while_break___0;
      }
    } else {
#line 130
      goto while_break___0;
    }
#line 130
    part_head = part_head->prevp;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 134
      goto while_break___1;
    }
#line 135
    if (head->size == 0LL) {
#line 137
      j = (pnum_t )0;
#line 139
      part_start = part_head;
      {
#line 141
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 141
        if (! ((unsigned long )part_head != (unsigned long )((void *)0))) {
#line 141
          goto while_break___2;
        }
#line 142
        if (head->partition_index != j) {
#line 142
          if (part_head->num_files < mean_files) {
            {
#line 144
            tmp = get_partition_at(part_start, head->partition_index);
#line 144
            previous_partition = tmp;
            }
#line 146
            if ((unsigned long )previous_partition == (unsigned long )((void *)0)) {
              {
#line 147
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): get_partition_at() returned NULL\n",
                      "dispatch_empty_file_entries");
              }
#line 149
              return (1);
            }
#line 153
            (previous_partition->num_files) --;
#line 155
            (part_head->num_files) ++;
#line 157
            head->partition_index = j;
#line 163
            goto while_break___2;
          }
        }
#line 165
        part_head = part_head->nextp;
#line 166
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 169
      part_head = part_start;
    }
#line 171
    head = head->nextp;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 173
  return (0);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c"
pnum_t dispatch_file_entries_by_limits(struct file_entry *head , struct partition **part_head ,
                                       fnum_t max_entries , fsize_t max_size , struct program_options *options ) 
{ 
  pnum_t num_parts_created ;
  int tmp ;
  struct partition *default_partition ;
  pnum_t default_partition_index ;
  int tmp___0 ;
  struct partition *start_partition ;
  pnum_t start_partition_index ;
  pnum_t current_partition_index ;
  int tmp___1 ;

  {
#line 189
  if (! ((unsigned long )head != (unsigned long )((void *)0))) {
    {
#line 189
    __assert_fail("head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  189U, "dispatch_file_entries_by_limits");
    }
  }
#line 190
  if ((unsigned long )part_head != (unsigned long )((void *)0)) {
#line 190
    if (! ((unsigned long )*part_head == (unsigned long )((void *)0))) {
      {
#line 190
      __assert_fail("(part_head != ((void *)0)) && (*part_head == ((void *)0))", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                    190U, "dispatch_file_entries_by_limits");
      }
    }
  } else {
    {
#line 190
    __assert_fail("(part_head != ((void *)0)) && (*part_head == ((void *)0))", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  190U, "dispatch_file_entries_by_limits");
    }
  }
#line 191
  if (! (max_size >= 0LL)) {
    {
#line 191
    __assert_fail("max_size >= 0", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  191U, "dispatch_file_entries_by_limits");
    }
  }
#line 192
  if (! ((unsigned long )options != (unsigned long )((void *)0))) {
    {
#line 192
    __assert_fail("options != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                  192U, "dispatch_file_entries_by_limits");
    }
  }
#line 195
  num_parts_created = (pnum_t )0;
#line 199
  if (max_size > 0LL) {
    {
#line 200
    tmp = add_partitions(part_head, (pnum_t )1, options);
    }
#line 200
    if (tmp != 0) {
      {
#line 201
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot init default partition\n",
              "dispatch_file_entries_by_limits");
      }
#line 202
      return (num_parts_created);
    }
#line 204
    num_parts_created ++;
  }
  {
#line 206
  default_partition = *part_head;
#line 207
  default_partition_index = (pnum_t )0;
#line 210
  tmp___0 = add_partitions(part_head, (pnum_t )1, options);
  }
#line 210
  if (tmp___0 != 0) {
    {
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot create partition\n",
            "dispatch_file_entries_by_limits");
    }
#line 212
    return (num_parts_created);
  }
#line 214
  num_parts_created ++;
#line 215
  start_partition = *part_head;
#line 216
  start_partition_index = num_parts_created - 1U;
#line 220
  current_partition_index = start_partition_index;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 221
      goto while_break;
    }
#line 224
    if (max_size > 0LL) {
#line 224
      if (head->size > max_size) {
#line 225
        head->partition_index = default_partition_index;
#line 226
        default_partition->size += head->size;
#line 227
        (default_partition->num_files) ++;
      } else {
#line 224
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 235
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 235
        if (! ((unsigned long )*part_head != (unsigned long )((void *)0))) {
#line 235
          goto while_break___0;
        }
#line 237
        if (max_entries > 0ULL) {
#line 237
          if ((*part_head)->num_files + 1ULL > max_entries) {
#line 237
            goto _L;
          } else {
#line 237
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 237
        if (max_size > 0LL) {
#line 237
          if ((*part_head)->size + head->size > max_size) {
            _L: /* CIL Label */ 
#line 240
            if ((unsigned long )(*part_head)->nextp == (unsigned long )((void *)0)) {
              {
#line 241
              tmp___1 = add_partitions(part_head, (pnum_t )1, options);
              }
#line 241
              if (tmp___1 != 0) {
                {
#line 242
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(): cannot create partition\n",
                        "dispatch_file_entries_by_limits");
                }
#line 244
                return (num_parts_created);
              }
#line 246
              num_parts_created ++;
            } else {
#line 254
              *part_head = (*part_head)->nextp;
            }
#line 256
            current_partition_index ++;
          } else {
#line 260
            head->partition_index = current_partition_index;
#line 261
            (*part_head)->size += head->size;
#line 262
            ((*part_head)->num_files) ++;
#line 270
            goto while_break___0;
          }
        } else {
#line 260
          head->partition_index = current_partition_index;
#line 261
          (*part_head)->size += head->size;
#line 262
          ((*part_head)->num_files) ++;
#line 270
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 274
      if (! ((unsigned long )*part_head != (unsigned long )((void *)0))) {
        {
#line 274
        __assert_fail("*part_head != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fpart-0.9/src/dispatch.c",
                      274U, "dispatch_file_entries_by_limits");
        }
      }
    }
#line 278
    head = head->nextp;
#line 281
    current_partition_index = start_partition_index;
#line 282
    *part_head = start_partition;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return (num_parts_created);
}
}
