/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 31 "/usr/include/elf.h"
typedef uint16_t Elf32_Half;
#line 32 "/usr/include/elf.h"
typedef uint16_t Elf64_Half;
#line 35 "/usr/include/elf.h"
typedef uint32_t Elf32_Word;
#line 37 "/usr/include/elf.h"
typedef uint32_t Elf64_Word;
#line 43 "/usr/include/elf.h"
typedef uint64_t Elf64_Xword;
#line 47 "/usr/include/elf.h"
typedef uint32_t Elf32_Addr;
#line 48 "/usr/include/elf.h"
typedef uint64_t Elf64_Addr;
#line 51 "/usr/include/elf.h"
typedef uint32_t Elf32_Off;
#line 52 "/usr/include/elf.h"
typedef uint64_t Elf64_Off;
#line 67 "/usr/include/elf.h"
struct __anonstruct_Elf32_Ehdr_30 {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
#line 67 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Ehdr_30 Elf32_Ehdr;
#line 85 "/usr/include/elf.h"
struct __anonstruct_Elf64_Ehdr_31 {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 85 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Ehdr_31 Elf64_Ehdr;
#line 272 "/usr/include/elf.h"
struct __anonstruct_Elf32_Shdr_32 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
#line 272 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Shdr_32 Elf32_Shdr;
#line 286 "/usr/include/elf.h"
struct __anonstruct_Elf64_Shdr_33 {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 286 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Shdr_33 Elf64_Shdr;
#line 541 "/usr/include/elf.h"
struct __anonstruct_Elf32_Phdr_42 {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
#line 541 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Phdr_42 Elf32_Phdr;
#line 553 "/usr/include/elf.h"
struct __anonstruct_Elf64_Phdr_43 {
   Elf64_Word p_type ;
   Elf64_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
#line 553 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Phdr_43 Elf64_Phdr;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 8 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.h"
struct pax_state;
#line 8
struct pax_state;
#line 10 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.h"
union __anonunion_phdr_72 {
   Elf32_Phdr *_32 ;
   Elf64_Phdr *_64 ;
};
#line 10 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.h"
union __anonunion_phnum_73 {
   Elf32_Half _32 ;
   Elf64_Half _64 ;
};
#line 10 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.h"
union __anonunion_shdr_74 {
   Elf32_Shdr *_32 ;
   Elf64_Shdr *_64 ;
};
#line 10 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.h"
union __anonunion_shnum_75 {
   Elf32_Half _32 ;
   Elf64_Half _64 ;
};
#line 10 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.h"
struct elf_ops {
   int (* const  modify_phdr)(struct pax_state * const   ) ;
   union __anonunion_phdr_72 phdr ;
   union __anonunion_phnum_73 phnum ;
   union __anonunion_shdr_74 shdr ;
   union __anonunion_shnum_75 shnum ;
};
#line 30 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.h"
struct pax_state {
   char **argv ;
   unsigned int flags_on ;
   unsigned int flags_off ;
   unsigned int files ;
   unsigned int quiet : 1 ;
   unsigned int shortonly : 1 ;
   unsigned int view : 1 ;
   unsigned int convert : 1 ;
   unsigned int create : 1 ;
   struct elf_ops *ops ;
   int fd ;
   unsigned char *map ;
   size_t size ;
};
#line 26 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
struct pax_flags {
   char const   *longname ;
   unsigned int flag ;
   char shortname ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 1016 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 26 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
static void report_flags(Elf64_Word const   flags , struct pax_state  const  * const  state ) ;
#line 26 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
static struct pax_flags  const  pax_flags[6]  = {      {"PAGEEXEC", 1U << 4, (char )'P'}, 
        {"SEGMEXEC", 1U << 6, (char )'S'}, 
        {"MPROTECT", 1U << 8, (char )'M'}, 
        {"RANDEXEC", 1U << 10, (char )'X'}, 
        {"EMUTRAMP", 1U << 12, (char )'E'}, 
        {"RANDMMAP", 1U << 14, (char )'R'}};
#line 24 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
static void report_flags(Elf64_Word const   flags , struct pax_state  const  * const  state ) 
{ 
  unsigned int num_pax_flags ;
  char *buffer ;
  unsigned long __lengthofbuffer ;
  void *tmp ;
  unsigned int i ;

  {
  {
#line 39
  num_pax_flags = (unsigned int )(sizeof(pax_flags) / sizeof(pax_flags[0]));
#line 40
  __lengthofbuffer = (unsigned long )(2U * num_pax_flags + 1U);
#line 40
  tmp = __builtin_alloca(sizeof(*buffer) * __lengthofbuffer);
#line 40
  buffer = (char *)tmp;
#line 44
  memset((void *)buffer, '-', sizeof(*buffer) * __lengthofbuffer - 1UL);
#line 45
  i = 0U;
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < num_pax_flags)) {
#line 45
      goto while_break;
    }
#line 46
    if (flags & pax_flags[i].flag) {
#line 46
      *(buffer + 2U * i) = (char )pax_flags[i].shortname;
    }
#line 47
    if (flags & (pax_flags[i].flag << 1)) {
#line 47
      *(buffer + (2U * i + 1U)) = (char )((int const   )pax_flags[i].shortname | 32);
    }
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  *(buffer + (sizeof(*buffer) * __lengthofbuffer - 1UL)) = (char)0;
#line 51
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"- PaX flags: %s [%s]\n",
          buffer, *(state->argv + state->files));
  }
#line 53
  if (state->shortonly) {
#line 54
    return;
  }
#line 56
  i = 0U;
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (! (i < num_pax_flags)) {
#line 56
      goto while_break___0;
    }
#line 57
    if (flags & pax_flags[i].flag) {
      {
#line 57
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t%s is enabled\n",
              pax_flags[i].longname);
      }
    }
#line 58
    if (flags & (pax_flags[i].flag << 1)) {
      {
#line 58
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t%s is disabled\n",
              pax_flags[i].longname);
      }
    }
#line 56
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 60
  return;
}
}
#line 15 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl-elf.c"
static int elf32_modify_phdr(struct pax_state * const  state ) 
{ 
  unsigned int i ;
  unsigned int pt_phdr ;
  unsigned int pt_load ;
  unsigned int gnu_stack ;
  unsigned int pax_flags___0 ;
  Elf32_Phdr *phdr ;
  Elf32_Shdr *shdr ;
  Elf32_Ehdr *ehdr ;
  Elf32_Word shift ;
  unsigned char *newmap ;
  Elf32_Phdr *newphdr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Elf32_Phdr *tmp___2 ;
  Elf32_Shdr *tmp___3 ;
  Elf32_Phdr *tmp___4 ;
  Elf32_Shdr *tmp___5 ;
  Elf32_Ehdr const   *ehdr___0 ;

  {
#line 18
  phdr = (state->ops)->phdr._32;
#line 19
  shdr = (state->ops)->shdr._32;
#line 22
  pt_phdr = (unsigned int )(state->ops)->phnum._32;
#line 23
  pt_load = (unsigned int )(state->ops)->phnum._32;
#line 24
  gnu_stack = (unsigned int )(state->ops)->phnum._32;
#line 25
  pax_flags___0 = (unsigned int )(state->ops)->phnum._32;
#line 28
  i = 0U;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < (unsigned int )(state->ops)->shnum._32)) {
#line 28
      goto while_break;
    }
#line 29
    if (0U == (shdr + i)->sh_type) {
#line 30
      goto __Cont;
    }
#line 32
    if ((shdr + i)->sh_addralign) {
#line 32
      if (~ ((shdr + i)->sh_addralign - 1U) + (shdr + i)->sh_addralign) {
#line 32
        goto _L;
      } else {
#line 32
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 32
    if ((shdr + i)->sh_addralign) {
#line 32
      if ((shdr + i)->sh_addr) {
#line 32
        if ((shdr + i)->sh_addr & ((shdr + i)->sh_addralign - 1U)) {
#line 32
          goto _L;
        } else {
#line 32
          goto _L___2;
        }
      } else {
#line 32
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 32
    if ((shdr + i)->sh_addr) {
#line 32
      if ((shdr + i)->sh_addr + (shdr + i)->sh_size < (shdr + i)->sh_addr) {
#line 32
        goto _L;
      } else {
#line 32
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 32
    if ((unsigned long )(shdr + i)->sh_offset < sizeof(Elf32_Ehdr ) + sizeof(Elf32_Phdr ) * (unsigned long )(state->ops)->phnum._32) {
#line 32
      goto _L;
    } else
#line 32
    if ((shdr + i)->sh_offset + (shdr + i)->sh_size < (shdr + i)->sh_offset) {
#line 32
      goto _L;
    } else
#line 32
    if (8U != (shdr + i)->sh_type) {
#line 32
      if ((size_t )((shdr + i)->sh_offset + (shdr + i)->sh_size) > state->size) {
        _L: /* CIL Label */ 
#line 39
        if (! state->quiet) {
          {
#line 40
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (invalid SHT_ entry:%u)\n",
                  *(state->argv + state->files), i);
          }
        }
#line 41
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
#line 28
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  i = 0U;
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! (i < (unsigned int )(state->ops)->phnum._32)) {
#line 46
      goto while_break___0;
    }
#line 47
    if ((phdr + i)->p_align) {
#line 47
      if (~ ((phdr + i)->p_align - 1U) + (phdr + i)->p_align) {
#line 47
        goto _L___4;
      } else {
#line 47
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 47
    if ((phdr + i)->p_align) {
#line 47
      if (((phdr + i)->p_offset ^ (phdr + i)->p_vaddr) & ((phdr + i)->p_align - 1U)) {
#line 47
        goto _L___4;
      } else {
#line 47
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 47
    if ((phdr + i)->p_vaddr + (phdr + i)->p_memsz < (phdr + i)->p_vaddr) {
#line 47
      goto _L___4;
    } else
#line 47
    if ((phdr + i)->p_offset + (phdr + i)->p_filesz < (phdr + i)->p_offset) {
#line 47
      goto _L___4;
    } else
#line 47
    if ((size_t )((phdr + i)->p_offset + (phdr + i)->p_filesz) > state->size) {
#line 47
      goto _L___4;
    } else
#line 47
    if ((phdr + i)->p_filesz > (phdr + i)->p_memsz) {
      _L___4: /* CIL Label */ 
#line 54
      if (! state->quiet) {
        {
#line 55
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (invalid PT_ entry:%u)\n",
                *(state->argv + state->files), i);
        }
      }
#line 56
      return (1);
    }
    {
#line 60
    if ((phdr + i)->p_type == 6U) {
#line 60
      goto case_6;
    }
#line 75
    if ((phdr + i)->p_type == 1U) {
#line 75
      goto case_1;
    }
#line 80
    if ((phdr + i)->p_type == 1694766464U) {
#line 80
      goto case_1694766464;
    }
#line 89
    if ((phdr + i)->p_type == 1685382481U) {
#line 89
      goto case_1685382481;
    }
#line 59
    goto switch_break;
    case_6: /* CIL Label */ 
#line 61
    if (pt_phdr == (unsigned int )(state->ops)->phnum._32) {
#line 62
      if (pt_load != (unsigned int )(state->ops)->phnum._32) {
#line 63
        if (! state->quiet) {
          {
#line 64
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (PT_LOAD before PT_PHDR)\n",
                  *(state->argv + state->files));
          }
        }
#line 65
        return (1);
      }
#line 67
      pt_phdr = i;
    } else {
#line 69
      if (! state->quiet) {
        {
#line 70
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (more than one PT_PHDR)\n",
                *(state->argv + state->files));
        }
      }
#line 71
      return (1);
    }
#line 73
    goto switch_break;
    case_1: /* CIL Label */ 
#line 76
    if (pt_load == (unsigned int )(state->ops)->phnum._32) {
#line 77
      pt_load = i;
    }
#line 78
    goto switch_break;
    case_1694766464: /* CIL Label */ 
#line 81
    if (pax_flags___0 != (unsigned int )(state->ops)->phnum._32) {
#line 82
      if (! state->quiet) {
        {
#line 83
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (more than one PT_PAX_FLAGS)\n",
                *(state->argv + state->files));
        }
      }
#line 84
      return (1);
    }
#line 86
    pax_flags___0 = i;
#line 87
    goto switch_break;
    case_1685382481: /* CIL Label */ 
#line 90
    if (gnu_stack != (unsigned int )(state->ops)->phnum._32) {
#line 91
      if (! state->quiet) {
        {
#line 92
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (more than one PT_GNU_STACK)\n",
                *(state->argv + state->files));
        }
      }
#line 93
      return (1);
    }
#line 95
    gnu_stack = i;
#line 96
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 46
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  if (pt_load == (unsigned int )(state->ops)->phnum._32) {
#line 102
    if (! state->quiet) {
      {
#line 103
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (no PT_LOAD found)\n",
              *(state->argv + state->files));
      }
    }
#line 104
    return (1);
  }
#line 107
  if (pt_phdr < (unsigned int )(state->ops)->phnum._32) {
#line 108
    if ((phdr + pt_phdr)->p_vaddr + (phdr + pt_phdr)->p_memsz <= (phdr + pt_load)->p_vaddr) {
#line 108
      goto _L___7;
    } else
#line 108
    if ((phdr + pt_load)->p_vaddr + (phdr + pt_load)->p_memsz <= (phdr + pt_phdr)->p_vaddr) {
      _L___7: /* CIL Label */ 
#line 110
      if (! state->quiet) {
        {
#line 111
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (PT_PHDR is outside of first PT_LOAD)\n",
                *(state->argv + state->files));
        }
      }
#line 112
      return (1);
    }
  }
#line 117
  if (pax_flags___0 == (unsigned int )(state->ops)->phnum._32) {
#line 117
    if (state->convert) {
#line 118
      if (gnu_stack < (unsigned int )(state->ops)->phnum._32) {
#line 119
        pax_flags___0 = gnu_stack;
#line 120
        (phdr + pax_flags___0)->p_type = (Elf32_Word )1694766464;
#line 121
        (phdr + pax_flags___0)->p_flags = (1U << 11) | (1U << 13);
#line 122
        if (! state->quiet) {
          {
#line 123
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s had a PT_GNU_STACK program header, converted\n",
                  *(state->argv + state->files));
          }
        }
      } else
#line 125
      if (! state->quiet) {
        {
#line 126
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s does not have a PT_GNU_STACK program header, conversion failed\n",
                *(state->argv + state->files));
        }
      }
    }
  }
#line 131
  if (pax_flags___0 == (unsigned int )(state->ops)->phnum._32) {
#line 131
    if (state->create) {
#line 132
      ehdr = (Elf32_Ehdr *)state->map;
#line 135
      if ((phdr + pt_load)->p_align != (phdr + pt_load)->p_align) {
#line 136
        if (! state->quiet) {
          {
#line 137
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s has a too big alignment, creation failed\n",
                  *(state->argv + state->files));
          }
        }
#line 138
        return (1);
      }
#line 140
      shift = (phdr + pt_load)->p_align;
#line 142
      if (shift == (phdr + pt_load)->p_vaddr) {
#line 143
        shift >>= 1;
#line 144
        if (! state->quiet) {
          {
#line 145
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s will be realigned, beware\n",
                  *(state->argv + state->files));
          }
        }
      }
#line 148
      if (pt_phdr == (unsigned int )(state->ops)->phnum._32) {
#line 148
        goto _L___8;
      } else
#line 148
      if ((unsigned long )(phdr + pt_phdr)->p_offset == sizeof(Elf32_Ehdr )) {
#line 148
        if ((phdr + pt_phdr)->p_align < shift) {
#line 148
          if ((unsigned long )(phdr + pt_phdr)->p_memsz + sizeof(Elf32_Phdr ) < (unsigned long )(phdr + pt_load)->p_memsz) {
            _L___8: /* CIL Label */ 
#line 148
            if ((phdr + pt_load)->p_vaddr > shift) {
#line 148
              if ((int )ehdr->e_machine != 50) {
#line 148
                if (state->size + (size_t )shift > (size_t )shift) {
                  {
#line 160
                  tmp = munmap((void *)state->map, state->size);
                  }
#line 160
                  if (-1 == tmp) {
#line 161
                    if (! state->quiet) {
                      {
#line 162
                      perror((char const   *)*(state->argv + state->files));
                      }
                    }
#line 163
                    return (1);
                  }
                  {
#line 167
                  state->size += (size_t )shift;
#line 170
                  tmp___0 = ftruncate(state->fd, (off_t )state->size);
                  }
#line 170
                  if (-1 == tmp___0) {
#line 171
                    if (! state->quiet) {
                      {
#line 172
                      perror((char const   *)*(state->argv + state->files));
                      }
                    }
#line 173
                    return (1);
                  }
                  {
#line 177
                  tmp___1 = mmap((void *)0, state->size, 3, 1, state->fd, (off_t )0);
#line 177
                  newmap = (unsigned char *)tmp___1;
                  }
#line 178
                  if ((unsigned long )((void *)-1) == (unsigned long )newmap) {
#line 179
                    if (! state->quiet) {
                      {
#line 180
                      perror((char const   *)*(state->argv + state->files));
                      }
                    }
#line 181
                    return (1);
                  }
#line 185
                  tmp___2 = (Elf32_Phdr *)((unsigned char *)phdr + (newmap - state->map));
#line 185
                  (state->ops)->phdr._32 = tmp___2;
#line 185
                  phdr = tmp___2;
#line 186
                  if (shdr) {
#line 187
                    tmp___3 = (Elf32_Shdr *)((unsigned char *)shdr + (newmap - state->map));
#line 187
                    (state->ops)->shdr._32 = tmp___3;
#line 187
                    shdr = tmp___3;
                  }
                  {
#line 188
                  state->map = newmap;
#line 189
                  ehdr = (Elf32_Ehdr *)state->map;
#line 192
                  memmove((void *)(state->map + shift), (void const   *)state->map,
                          state->size - (size_t )shift);
#line 193
                  memset((void *)(state->map + sizeof(Elf32_Ehdr )), 0, (unsigned long )shift - sizeof(Elf32_Ehdr ));
#line 196
                  tmp___4 = (Elf32_Phdr *)((unsigned char *)phdr + shift);
#line 196
                  (state->ops)->phdr._32 = tmp___4;
#line 196
                  phdr = tmp___4;
                  }
#line 197
                  if (shdr) {
#line 198
                    tmp___5 = (Elf32_Shdr *)((unsigned char *)shdr + shift);
#line 198
                    (state->ops)->shdr._32 = tmp___5;
#line 198
                    shdr = tmp___5;
                  }
#line 201
                  if (shdr) {
#line 202
                    ehdr->e_shoff += shift;
                  }
#line 205
                  newphdr = (Elf32_Phdr *)(state->map + ehdr->e_phoff);
#line 206
                  i = 0U;
                  {
#line 206
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 206
                    if (! (i < (unsigned int )(state->ops)->phnum._32)) {
#line 206
                      goto while_break___1;
                    }
#line 207
                    *(newphdr + i) = *(phdr + i);
#line 208
                    if ((unsigned long )(newphdr + i)->p_offset >= sizeof(Elf32_Ehdr ) + sizeof(Elf32_Phdr ) * (unsigned long )(state->ops)->phnum._32) {
#line 209
                      (newphdr + i)->p_offset += shift;
                    } else
#line 210
                    if ((newphdr + i)->p_vaddr >= (phdr + pt_load)->p_vaddr) {
#line 211
                      (newphdr + i)->p_vaddr -= shift;
#line 212
                      (newphdr + i)->p_paddr -= shift;
                    }
#line 214
                    if ((newphdr + i)->p_align > shift) {
#line 215
                      (newphdr + i)->p_align = shift;
                    }
#line 206
                    i ++;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
#line 217
                  (newphdr + pt_load)->p_memsz += shift;
#line 218
                  (newphdr + pt_load)->p_filesz += shift;
#line 221
                  pax_flags___0 = i;
#line 222
                  (newphdr + pax_flags___0)->p_type = (Elf32_Word )1694766464;
#line 223
                  (newphdr + pax_flags___0)->p_flags = (1U << 11) | (1U << 13);
#line 224
                  (newphdr + pax_flags___0)->p_align = (Elf32_Word )4;
#line 225
                  if (pt_phdr < (unsigned int )(state->ops)->phnum._32) {
#line 226
                    (newphdr + pt_phdr)->p_memsz += (Elf32_Word )sizeof(Elf32_Phdr );
#line 227
                    (newphdr + pt_phdr)->p_filesz += (Elf32_Word )sizeof(Elf32_Phdr );
                  } else {
#line 229
                    pt_phdr ++;
                  }
#line 230
                  ehdr->e_phnum = (Elf32_Half )((int )ehdr->e_phnum + 1);
#line 231
                  (state->ops)->phnum._32 = (Elf32_Half )((int )(state->ops)->phnum._32 + 1);
#line 232
                  phdr = newphdr;
#line 235
                  i = 0U;
                  {
#line 235
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 235
                    if (! (i < (unsigned int )(state->ops)->shnum._32)) {
#line 235
                      goto while_break___2;
                    }
#line 236
                    if ((shdr + i)->sh_offset) {
#line 237
                      (shdr + i)->sh_offset += shift;
                    }
#line 235
                    i ++;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 240
                  if (! state->quiet) {
                    {
#line 241
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s got a new PT_PAX_FLAGS program header\n",
                            *(state->argv + state->files));
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 243
      if (pax_flags___0 == (unsigned int )(state->ops)->phnum._32) {
#line 244
        if (! state->quiet) {
          {
#line 245
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s cannot have a PT_PAX_FLAGS program header, creation failed\n",
                  *(state->argv + state->files));
          }
        }
      }
    }
  }
#line 249
  if (pax_flags___0 == (unsigned int )(state->ops)->phnum._32) {
#line 250
    if (! state->quiet) {
#line 250
      if (! state->convert) {
#line 250
        if (! state->create) {
          {
#line 251
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s does not have a PT_PAX_FLAGS program header, try conversion\n",
                  *(state->argv + state->files));
          }
        }
      }
    }
#line 252
    return (1);
  }
#line 255
  if (state->view) {
    {
#line 256
    report_flags((Elf64_Word const   )(phdr + pax_flags___0)->p_flags, (struct pax_state  const  */* const  */)state);
    }
  }
#line 257
  if (state->flags_on | state->flags_off) {
#line 258
    ehdr___0 = (Elf32_Ehdr const   *)state->map;
#line 260
    if ((int const   )ehdr___0->e_type == 3) {
#line 261
      (phdr + pax_flags___0)->p_flags &= ~ ((state->flags_off | (1U << 10)) & ~ (1U << 11));
#line 262
      (phdr + pax_flags___0)->p_flags |= (state->flags_on | (1U << 11)) & ~ (1U << 10);
    } else {
#line 264
      (phdr + pax_flags___0)->p_flags &= ~ state->flags_off;
#line 265
      (phdr + pax_flags___0)->p_flags |= state->flags_on;
    }
  }
#line 268
  return (0);
}
}
#line 271 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl-elf.c"
static struct elf_ops elf32  =    {(int (*/* const  */)(struct pax_state * const   ))(& elf32_modify_phdr), {(Elf32_Phdr *)0},
    {(unsigned short)0}, {(Elf32_Shdr *)0}, {(unsigned short)0}};
#line 275 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl-elf.c"
static int is_elf32(struct pax_state * const  state ) 
{ 
  Elf32_Ehdr const   *ehdr ;
  int tmp ;

  {
  {
#line 277
  ehdr = (Elf32_Ehdr const   *)state->map;
#line 279
  tmp = memcmp((void const   *)(ehdr->e_ident), (void const   *)"\177ELF", (size_t )4);
  }
#line 279
  if (tmp) {
#line 280
    return (0);
  }
#line 281
  if ((unsigned long )ehdr->e_ehsize != sizeof(Elf32_Ehdr )) {
#line 282
    return (0);
  }
#line 283
  if (ehdr->e_version != 1U) {
#line 284
    return (0);
  } else
#line 283
  if ((int )ehdr->e_ident[4] != 1) {
#line 284
    return (0);
  }
#line 285
  if ((int const   )ehdr->e_type != 2) {
#line 285
    if ((int const   )ehdr->e_type != 3) {
#line 286
      return (0);
    }
  }
#line 288
  if (! ehdr->e_phoff) {
#line 289
    return (0);
  } else
#line 288
  if (! ehdr->e_phnum) {
#line 289
    return (0);
  } else
#line 288
  if (sizeof(Elf32_Phdr ) != (unsigned long )ehdr->e_phentsize) {
#line 289
    return (0);
  }
#line 290
  if ((unsigned int )ehdr->e_phnum > 65536U / (unsigned int )ehdr->e_phentsize - 1U) {
#line 291
    return (0);
  }
#line 292
  if (ehdr->e_phoff > ehdr->e_phoff + (Elf32_Off const   )((Elf32_Off )ehdr->e_phentsize * (Elf32_Off )ehdr->e_phnum)) {
#line 293
    return (0);
  }
#line 294
  if (state->size < (size_t )(ehdr->e_phoff + (Elf32_Off const   )((Elf32_Off )ehdr->e_phentsize * (Elf32_Off )ehdr->e_phnum))) {
#line 295
    return (0);
  }
#line 297
  if (ehdr->e_shoff) {
#line 298
    if (! ehdr->e_shnum) {
#line 299
      return (0);
    } else
#line 298
    if (sizeof(Elf32_Shdr ) != (unsigned long )ehdr->e_shentsize) {
#line 299
      return (0);
    }
#line 300
    if ((unsigned int )ehdr->e_shnum > 65536U / (unsigned int )ehdr->e_shentsize) {
#line 301
      return (0);
    }
#line 302
    if (ehdr->e_shoff > ehdr->e_shoff + (Elf32_Off const   )((Elf32_Off )ehdr->e_shentsize * (Elf32_Off )ehdr->e_shnum)) {
#line 303
      return (0);
    }
#line 304
    if ((Elf32_Off )state->size < (Elf32_Off )(ehdr->e_shoff + (Elf32_Off const   )((Elf32_Off )ehdr->e_shentsize * (Elf32_Off )ehdr->e_shnum))) {
#line 305
      return (0);
    }
  }
#line 308
  state->ops = & elf32;
#line 309
  (state->ops)->phdr._32 = (Elf32_Phdr *)(state->map + ehdr->e_phoff);
#line 310
  (state->ops)->phnum._32 = (Elf32_Half )ehdr->e_phnum;
#line 311
  if (ehdr->e_shoff) {
#line 312
    (state->ops)->shdr._32 = (Elf32_Shdr *)(state->map + ehdr->e_shoff);
#line 313
    (state->ops)->shnum._32 = (Elf32_Half )ehdr->e_shnum;
  } else {
#line 315
    (state->ops)->shdr._32 = (Elf32_Shdr *)((void *)0);
#line 316
    (state->ops)->shnum._32 = (Elf32_Half )0;
  }
#line 319
  return (1);
}
}
#line 15 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl-elf.c"
static int elf64_modify_phdr(struct pax_state * const  state ) 
{ 
  unsigned int i ;
  unsigned int pt_phdr ;
  unsigned int pt_load ;
  unsigned int gnu_stack ;
  unsigned int pax_flags___0 ;
  Elf64_Phdr *phdr ;
  Elf64_Shdr *shdr ;
  Elf64_Ehdr *ehdr ;
  Elf64_Word shift ;
  unsigned char *newmap ;
  Elf64_Phdr *newphdr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Elf64_Phdr *tmp___2 ;
  Elf64_Shdr *tmp___3 ;
  Elf64_Phdr *tmp___4 ;
  Elf64_Shdr *tmp___5 ;
  Elf64_Ehdr const   *ehdr___0 ;

  {
#line 18
  phdr = (state->ops)->phdr._64;
#line 19
  shdr = (state->ops)->shdr._64;
#line 22
  pt_phdr = (unsigned int )(state->ops)->phnum._64;
#line 23
  pt_load = (unsigned int )(state->ops)->phnum._64;
#line 24
  gnu_stack = (unsigned int )(state->ops)->phnum._64;
#line 25
  pax_flags___0 = (unsigned int )(state->ops)->phnum._64;
#line 28
  i = 0U;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < (unsigned int )(state->ops)->shnum._64)) {
#line 28
      goto while_break;
    }
#line 29
    if (0U == (shdr + i)->sh_type) {
#line 30
      goto __Cont;
    }
#line 32
    if ((shdr + i)->sh_addralign) {
#line 32
      if (~ ((shdr + i)->sh_addralign - 1UL) + (shdr + i)->sh_addralign) {
#line 32
        goto _L;
      } else {
#line 32
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 32
    if ((shdr + i)->sh_addralign) {
#line 32
      if ((shdr + i)->sh_addr) {
#line 32
        if ((shdr + i)->sh_addr & ((shdr + i)->sh_addralign - 1UL)) {
#line 32
          goto _L;
        } else {
#line 32
          goto _L___2;
        }
      } else {
#line 32
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 32
    if ((shdr + i)->sh_addr) {
#line 32
      if ((shdr + i)->sh_addr + (shdr + i)->sh_size < (shdr + i)->sh_addr) {
#line 32
        goto _L;
      } else {
#line 32
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 32
    if ((shdr + i)->sh_offset < sizeof(Elf64_Ehdr ) + sizeof(Elf64_Phdr ) * (unsigned long )(state->ops)->phnum._64) {
#line 32
      goto _L;
    } else
#line 32
    if ((shdr + i)->sh_offset + (shdr + i)->sh_size < (shdr + i)->sh_offset) {
#line 32
      goto _L;
    } else
#line 32
    if (8U != (shdr + i)->sh_type) {
#line 32
      if ((shdr + i)->sh_offset + (shdr + i)->sh_size > state->size) {
        _L: /* CIL Label */ 
#line 39
        if (! state->quiet) {
          {
#line 40
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (invalid SHT_ entry:%u)\n",
                  *(state->argv + state->files), i);
          }
        }
#line 41
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
#line 28
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  i = 0U;
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! (i < (unsigned int )(state->ops)->phnum._64)) {
#line 46
      goto while_break___0;
    }
#line 47
    if ((phdr + i)->p_align) {
#line 47
      if (~ ((phdr + i)->p_align - 1UL) + (phdr + i)->p_align) {
#line 47
        goto _L___4;
      } else {
#line 47
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 47
    if ((phdr + i)->p_align) {
#line 47
      if (((phdr + i)->p_offset ^ (phdr + i)->p_vaddr) & ((phdr + i)->p_align - 1UL)) {
#line 47
        goto _L___4;
      } else {
#line 47
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 47
    if ((phdr + i)->p_vaddr + (phdr + i)->p_memsz < (phdr + i)->p_vaddr) {
#line 47
      goto _L___4;
    } else
#line 47
    if ((phdr + i)->p_offset + (phdr + i)->p_filesz < (phdr + i)->p_offset) {
#line 47
      goto _L___4;
    } else
#line 47
    if ((phdr + i)->p_offset + (phdr + i)->p_filesz > state->size) {
#line 47
      goto _L___4;
    } else
#line 47
    if ((phdr + i)->p_filesz > (phdr + i)->p_memsz) {
      _L___4: /* CIL Label */ 
#line 54
      if (! state->quiet) {
        {
#line 55
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (invalid PT_ entry:%u)\n",
                *(state->argv + state->files), i);
        }
      }
#line 56
      return (1);
    }
    {
#line 60
    if ((phdr + i)->p_type == 6U) {
#line 60
      goto case_6;
    }
#line 75
    if ((phdr + i)->p_type == 1U) {
#line 75
      goto case_1;
    }
#line 80
    if ((phdr + i)->p_type == 1694766464U) {
#line 80
      goto case_1694766464;
    }
#line 89
    if ((phdr + i)->p_type == 1685382481U) {
#line 89
      goto case_1685382481;
    }
#line 59
    goto switch_break;
    case_6: /* CIL Label */ 
#line 61
    if (pt_phdr == (unsigned int )(state->ops)->phnum._64) {
#line 62
      if (pt_load != (unsigned int )(state->ops)->phnum._64) {
#line 63
        if (! state->quiet) {
          {
#line 64
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (PT_LOAD before PT_PHDR)\n",
                  *(state->argv + state->files));
          }
        }
#line 65
        return (1);
      }
#line 67
      pt_phdr = i;
    } else {
#line 69
      if (! state->quiet) {
        {
#line 70
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (more than one PT_PHDR)\n",
                *(state->argv + state->files));
        }
      }
#line 71
      return (1);
    }
#line 73
    goto switch_break;
    case_1: /* CIL Label */ 
#line 76
    if (pt_load == (unsigned int )(state->ops)->phnum._64) {
#line 77
      pt_load = i;
    }
#line 78
    goto switch_break;
    case_1694766464: /* CIL Label */ 
#line 81
    if (pax_flags___0 != (unsigned int )(state->ops)->phnum._64) {
#line 82
      if (! state->quiet) {
        {
#line 83
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (more than one PT_PAX_FLAGS)\n",
                *(state->argv + state->files));
        }
      }
#line 84
      return (1);
    }
#line 86
    pax_flags___0 = i;
#line 87
    goto switch_break;
    case_1685382481: /* CIL Label */ 
#line 90
    if (gnu_stack != (unsigned int )(state->ops)->phnum._64) {
#line 91
      if (! state->quiet) {
        {
#line 92
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (more than one PT_GNU_STACK)\n",
                *(state->argv + state->files));
        }
      }
#line 93
      return (1);
    }
#line 95
    gnu_stack = i;
#line 96
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 46
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  if (pt_load == (unsigned int )(state->ops)->phnum._64) {
#line 102
    if (! state->quiet) {
      {
#line 103
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (no PT_LOAD found)\n",
              *(state->argv + state->files));
      }
    }
#line 104
    return (1);
  }
#line 107
  if (pt_phdr < (unsigned int )(state->ops)->phnum._64) {
#line 108
    if ((phdr + pt_phdr)->p_vaddr + (phdr + pt_phdr)->p_memsz <= (phdr + pt_load)->p_vaddr) {
#line 108
      goto _L___7;
    } else
#line 108
    if ((phdr + pt_load)->p_vaddr + (phdr + pt_load)->p_memsz <= (phdr + pt_phdr)->p_vaddr) {
      _L___7: /* CIL Label */ 
#line 110
      if (! state->quiet) {
        {
#line 111
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable (PT_PHDR is outside of first PT_LOAD)\n",
                *(state->argv + state->files));
        }
      }
#line 112
      return (1);
    }
  }
#line 117
  if (pax_flags___0 == (unsigned int )(state->ops)->phnum._64) {
#line 117
    if (state->convert) {
#line 118
      if (gnu_stack < (unsigned int )(state->ops)->phnum._64) {
#line 119
        pax_flags___0 = gnu_stack;
#line 120
        (phdr + pax_flags___0)->p_type = (Elf64_Word )1694766464;
#line 121
        (phdr + pax_flags___0)->p_flags = (1U << 11) | (1U << 13);
#line 122
        if (! state->quiet) {
          {
#line 123
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s had a PT_GNU_STACK program header, converted\n",
                  *(state->argv + state->files));
          }
        }
      } else
#line 125
      if (! state->quiet) {
        {
#line 126
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s does not have a PT_GNU_STACK program header, conversion failed\n",
                *(state->argv + state->files));
        }
      }
    }
  }
#line 131
  if (pax_flags___0 == (unsigned int )(state->ops)->phnum._64) {
#line 131
    if (state->create) {
#line 132
      ehdr = (Elf64_Ehdr *)state->map;
#line 135
      if ((phdr + pt_load)->p_align != (Elf64_Xword )((Elf64_Word )(phdr + pt_load)->p_align)) {
#line 136
        if (! state->quiet) {
          {
#line 137
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s has a too big alignment, creation failed\n",
                  *(state->argv + state->files));
          }
        }
#line 138
        return (1);
      }
#line 140
      shift = (Elf64_Word )(phdr + pt_load)->p_align;
#line 142
      if ((Elf64_Addr )shift == (phdr + pt_load)->p_vaddr) {
#line 143
        shift >>= 1;
#line 144
        if (! state->quiet) {
          {
#line 145
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s will be realigned, beware\n",
                  *(state->argv + state->files));
          }
        }
      }
#line 148
      if (pt_phdr == (unsigned int )(state->ops)->phnum._64) {
#line 148
        goto _L___8;
      } else
#line 148
      if ((phdr + pt_phdr)->p_offset == sizeof(Elf64_Ehdr )) {
#line 148
        if ((phdr + pt_phdr)->p_align < (Elf64_Xword )shift) {
#line 148
          if ((phdr + pt_phdr)->p_memsz + sizeof(Elf64_Phdr ) < (phdr + pt_load)->p_memsz) {
            _L___8: /* CIL Label */ 
#line 148
            if ((phdr + pt_load)->p_vaddr > (Elf64_Addr )shift) {
#line 148
              if ((int )ehdr->e_machine != 50) {
#line 148
                if (state->size + (size_t )shift > (size_t )shift) {
                  {
#line 160
                  tmp = munmap((void *)state->map, state->size);
                  }
#line 160
                  if (-1 == tmp) {
#line 161
                    if (! state->quiet) {
                      {
#line 162
                      perror((char const   *)*(state->argv + state->files));
                      }
                    }
#line 163
                    return (1);
                  }
                  {
#line 167
                  state->size += (size_t )shift;
#line 170
                  tmp___0 = ftruncate(state->fd, (off_t )state->size);
                  }
#line 170
                  if (-1 == tmp___0) {
#line 171
                    if (! state->quiet) {
                      {
#line 172
                      perror((char const   *)*(state->argv + state->files));
                      }
                    }
#line 173
                    return (1);
                  }
                  {
#line 177
                  tmp___1 = mmap((void *)0, state->size, 3, 1, state->fd, (off_t )0);
#line 177
                  newmap = (unsigned char *)tmp___1;
                  }
#line 178
                  if ((unsigned long )((void *)-1) == (unsigned long )newmap) {
#line 179
                    if (! state->quiet) {
                      {
#line 180
                      perror((char const   *)*(state->argv + state->files));
                      }
                    }
#line 181
                    return (1);
                  }
#line 185
                  tmp___2 = (Elf64_Phdr *)((unsigned char *)phdr + (newmap - state->map));
#line 185
                  (state->ops)->phdr._64 = tmp___2;
#line 185
                  phdr = tmp___2;
#line 186
                  if (shdr) {
#line 187
                    tmp___3 = (Elf64_Shdr *)((unsigned char *)shdr + (newmap - state->map));
#line 187
                    (state->ops)->shdr._64 = tmp___3;
#line 187
                    shdr = tmp___3;
                  }
                  {
#line 188
                  state->map = newmap;
#line 189
                  ehdr = (Elf64_Ehdr *)state->map;
#line 192
                  memmove((void *)(state->map + shift), (void const   *)state->map,
                          state->size - (size_t )shift);
#line 193
                  memset((void *)(state->map + sizeof(Elf64_Ehdr )), 0, (unsigned long )shift - sizeof(Elf64_Ehdr ));
#line 196
                  tmp___4 = (Elf64_Phdr *)((unsigned char *)phdr + shift);
#line 196
                  (state->ops)->phdr._64 = tmp___4;
#line 196
                  phdr = tmp___4;
                  }
#line 197
                  if (shdr) {
#line 198
                    tmp___5 = (Elf64_Shdr *)((unsigned char *)shdr + shift);
#line 198
                    (state->ops)->shdr._64 = tmp___5;
#line 198
                    shdr = tmp___5;
                  }
#line 201
                  if (shdr) {
#line 202
                    ehdr->e_shoff += (Elf64_Off )shift;
                  }
#line 205
                  newphdr = (Elf64_Phdr *)(state->map + ehdr->e_phoff);
#line 206
                  i = 0U;
                  {
#line 206
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 206
                    if (! (i < (unsigned int )(state->ops)->phnum._64)) {
#line 206
                      goto while_break___1;
                    }
#line 207
                    *(newphdr + i) = *(phdr + i);
#line 208
                    if ((newphdr + i)->p_offset >= sizeof(Elf64_Ehdr ) + sizeof(Elf64_Phdr ) * (unsigned long )(state->ops)->phnum._64) {
#line 209
                      (newphdr + i)->p_offset += (Elf64_Off )shift;
                    } else
#line 210
                    if ((newphdr + i)->p_vaddr >= (phdr + pt_load)->p_vaddr) {
#line 211
                      (newphdr + i)->p_vaddr -= (Elf64_Addr )shift;
#line 212
                      (newphdr + i)->p_paddr -= (Elf64_Addr )shift;
                    }
#line 214
                    if ((newphdr + i)->p_align > (Elf64_Xword )shift) {
#line 215
                      (newphdr + i)->p_align = (Elf64_Xword )shift;
                    }
#line 206
                    i ++;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
#line 217
                  (newphdr + pt_load)->p_memsz += (Elf64_Xword )shift;
#line 218
                  (newphdr + pt_load)->p_filesz += (Elf64_Xword )shift;
#line 221
                  pax_flags___0 = i;
#line 222
                  (newphdr + pax_flags___0)->p_type = (Elf64_Word )1694766464;
#line 223
                  (newphdr + pax_flags___0)->p_flags = (1U << 11) | (1U << 13);
#line 224
                  (newphdr + pax_flags___0)->p_align = (Elf64_Xword )4;
#line 225
                  if (pt_phdr < (unsigned int )(state->ops)->phnum._64) {
#line 226
                    (newphdr + pt_phdr)->p_memsz += (Elf64_Xword )((Elf64_Word )sizeof(Elf64_Phdr ));
#line 227
                    (newphdr + pt_phdr)->p_filesz += (Elf64_Xword )((Elf64_Word )sizeof(Elf64_Phdr ));
                  } else {
#line 229
                    pt_phdr ++;
                  }
#line 230
                  ehdr->e_phnum = (Elf64_Half )((int )ehdr->e_phnum + 1);
#line 231
                  (state->ops)->phnum._64 = (Elf64_Half )((int )(state->ops)->phnum._64 + 1);
#line 232
                  phdr = newphdr;
#line 235
                  i = 0U;
                  {
#line 235
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 235
                    if (! (i < (unsigned int )(state->ops)->shnum._64)) {
#line 235
                      goto while_break___2;
                    }
#line 236
                    if ((shdr + i)->sh_offset) {
#line 237
                      (shdr + i)->sh_offset += (Elf64_Off )shift;
                    }
#line 235
                    i ++;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 240
                  if (! state->quiet) {
                    {
#line 241
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s got a new PT_PAX_FLAGS program header\n",
                            *(state->argv + state->files));
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 243
      if (pax_flags___0 == (unsigned int )(state->ops)->phnum._64) {
#line 244
        if (! state->quiet) {
          {
#line 245
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s cannot have a PT_PAX_FLAGS program header, creation failed\n",
                  *(state->argv + state->files));
          }
        }
      }
    }
  }
#line 249
  if (pax_flags___0 == (unsigned int )(state->ops)->phnum._64) {
#line 250
    if (! state->quiet) {
#line 250
      if (! state->convert) {
#line 250
        if (! state->create) {
          {
#line 251
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s does not have a PT_PAX_FLAGS program header, try conversion\n",
                  *(state->argv + state->files));
          }
        }
      }
    }
#line 252
    return (1);
  }
#line 255
  if (state->view) {
    {
#line 256
    report_flags((Elf64_Word const   )(phdr + pax_flags___0)->p_flags, (struct pax_state  const  */* const  */)state);
    }
  }
#line 257
  if (state->flags_on | state->flags_off) {
#line 258
    ehdr___0 = (Elf64_Ehdr const   *)state->map;
#line 260
    if ((int const   )ehdr___0->e_type == 3) {
#line 261
      (phdr + pax_flags___0)->p_flags &= ~ ((state->flags_off | (1U << 10)) & ~ (1U << 11));
#line 262
      (phdr + pax_flags___0)->p_flags |= (state->flags_on | (1U << 11)) & ~ (1U << 10);
    } else {
#line 264
      (phdr + pax_flags___0)->p_flags &= ~ state->flags_off;
#line 265
      (phdr + pax_flags___0)->p_flags |= state->flags_on;
    }
  }
#line 268
  return (0);
}
}
#line 271 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl-elf.c"
static struct elf_ops elf64  =    {(int (*/* const  */)(struct pax_state * const   ))(& elf64_modify_phdr), {(Elf32_Phdr *)0},
    {(unsigned short)0}, {(Elf32_Shdr *)0}, {(unsigned short)0}};
#line 275 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl-elf.c"
static int is_elf64(struct pax_state * const  state ) 
{ 
  Elf64_Ehdr const   *ehdr ;
  int tmp ;

  {
  {
#line 277
  ehdr = (Elf64_Ehdr const   *)state->map;
#line 279
  tmp = memcmp((void const   *)(ehdr->e_ident), (void const   *)"\177ELF", (size_t )4);
  }
#line 279
  if (tmp) {
#line 280
    return (0);
  }
#line 281
  if ((unsigned long )ehdr->e_ehsize != sizeof(Elf64_Ehdr )) {
#line 282
    return (0);
  }
#line 283
  if (ehdr->e_version != 1U) {
#line 284
    return (0);
  } else
#line 283
  if ((int )ehdr->e_ident[4] != 2) {
#line 284
    return (0);
  }
#line 285
  if ((int const   )ehdr->e_type != 2) {
#line 285
    if ((int const   )ehdr->e_type != 3) {
#line 286
      return (0);
    }
  }
#line 288
  if (! ehdr->e_phoff) {
#line 289
    return (0);
  } else
#line 288
  if (! ehdr->e_phnum) {
#line 289
    return (0);
  } else
#line 288
  if (sizeof(Elf64_Phdr ) != (unsigned long )ehdr->e_phentsize) {
#line 289
    return (0);
  }
#line 290
  if ((unsigned int )ehdr->e_phnum > 65536U / (unsigned int )ehdr->e_phentsize - 1U) {
#line 291
    return (0);
  }
#line 292
  if (ehdr->e_phoff > ehdr->e_phoff + (Elf64_Off const   )((Elf64_Off )ehdr->e_phentsize * (Elf64_Off )ehdr->e_phnum)) {
#line 293
    return (0);
  }
#line 294
  if (state->size < (size_t )(ehdr->e_phoff + (Elf64_Off const   )((Elf64_Off )ehdr->e_phentsize * (Elf64_Off )ehdr->e_phnum))) {
#line 295
    return (0);
  }
#line 297
  if (ehdr->e_shoff) {
#line 298
    if (! ehdr->e_shnum) {
#line 299
      return (0);
    } else
#line 298
    if (sizeof(Elf64_Shdr ) != (unsigned long )ehdr->e_shentsize) {
#line 299
      return (0);
    }
#line 300
    if ((unsigned int )ehdr->e_shnum > 65536U / (unsigned int )ehdr->e_shentsize) {
#line 301
      return (0);
    }
#line 302
    if (ehdr->e_shoff > ehdr->e_shoff + (Elf64_Off const   )((Elf64_Off )ehdr->e_shentsize * (Elf64_Off )ehdr->e_shnum)) {
#line 303
      return (0);
    }
#line 304
    if ((Elf64_Off const   )((Elf32_Off )state->size) < ehdr->e_shoff + (Elf64_Off const   )((Elf64_Off )ehdr->e_shentsize * (Elf64_Off )ehdr->e_shnum)) {
#line 305
      return (0);
    }
  }
#line 308
  state->ops = & elf64;
#line 309
  (state->ops)->phdr._64 = (Elf64_Phdr *)(state->map + ehdr->e_phoff);
#line 310
  (state->ops)->phnum._64 = (Elf64_Half )ehdr->e_phnum;
#line 311
  if (ehdr->e_shoff) {
#line 312
    (state->ops)->shdr._64 = (Elf64_Shdr *)(state->map + ehdr->e_shoff);
#line 313
    (state->ops)->shnum._64 = (Elf64_Half )ehdr->e_shnum;
  } else {
#line 315
    (state->ops)->shdr._64 = (Elf64_Shdr *)((void *)0);
#line 316
    (state->ops)->shnum._64 = (Elf64_Half )0;
  }
#line 319
  return (1);
}
}
#line 70 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
static void banner(void) 
{ 


  {
  {
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PaX control v0.7\nCopyright 2004,2005,2006,2007,2009,2010,2011,2012 PaX Team <pageexec@freemail.hu>\n\n");
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
static void usage(void) 
{ 


  {
  {
#line 79
  banner();
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: paxctl <options> <files>\n\noptions:\n\t-p: disable PAGEEXEC\t\t-P: enable PAGEEXEC\n\t-e: disable EMUTRAMP\t\t-E: enable EMUTRAMP\n\t-m: disable MPROTECT\t\t-M: enable MPROTECT\n\t-r: disable RANDMMAP\t\t-R: enable RANDMMAP\n\t-x: disable RANDEXEC\t\t-X: enable RANDEXEC\n\t-s: disable SEGMEXEC\t\t-S: enable SEGMEXEC\n\n\t-v: view flags\t\t\t-z: restore default flags\n\t-q: suppress error messages\t-Q: report flags in short format\n\t-c: convert PT_GNU_STACK into PT_PAX_FLAGS (see manpage!)\n\t-C: create PT_PAX_FLAGS (see manpage!)\n");
#line 94
  exit(1);
  }
}
}
#line 97 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
static int pax_verify_file(struct pax_state * const  state ) 
{ 
  int fd ;
  int oflags ;
  int mflags ;
  struct stat st ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 102
  if (((state->flags_on | state->flags_off) | state->convert) | state->create) {
#line 103
    oflags = 2;
#line 104
    mflags = 3;
  } else {
#line 106
    oflags = 0;
#line 107
    mflags = 1;
  }
  {
#line 110
  fd = open((char const   *)*(state->argv + state->files), oflags);
  }
#line 111
  if (-1 == fd) {
#line 112
    if (! state->quiet) {
      {
#line 113
      perror((char const   *)*(state->argv + state->files));
      }
    }
#line 114
    return (1);
  }
  {
#line 117
  tmp = fstat(fd, & st);
  }
#line 117
  if (-1 == tmp) {
    {
#line 118
    close(fd);
    }
#line 119
    if (! state->quiet) {
      {
#line 120
      perror((char const   *)*(state->argv + state->files));
      }
    }
#line 121
    return (1);
  }
#line 124
  if (st.st_size < 0L) {
#line 124
    goto _L;
  } else
#line 124
  if (2147483647L < st.st_size) {
    _L: /* CIL Label */ 
    {
#line 125
    close(fd);
    }
#line 126
    if (! state->quiet) {
      {
#line 127
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is too big\n",
              *(state->argv + state->files));
      }
    }
#line 128
    return (1);
  }
  {
#line 130
  state->size = (size_t )st.st_size;
#line 131
  tmp___0 = mmap((void *)0, state->size, mflags, 1, fd, (off_t )0);
#line 131
  state->map = (unsigned char *)tmp___0;
  }
#line 132
  if ((unsigned long )((void *)-1) == (unsigned long )state->map) {
    {
#line 133
    state->map = (unsigned char *)((void *)0);
#line 134
    state->size = (size_t )0;
#line 135
    close(fd);
    }
#line 136
    if (! state->quiet) {
      {
#line 137
      perror((char const   *)*(state->argv + state->files));
      }
    }
#line 138
    return (1);
  }
#line 141
  if (state->size < sizeof(Elf64_Ehdr )) {
#line 141
    goto _L___0;
  } else {
    {
#line 141
    tmp___1 = is_elf32(state);
    }
#line 141
    if (! tmp___1) {
      {
#line 141
      tmp___2 = is_elf64(state);
      }
#line 141
      if (! tmp___2) {
        _L___0: /* CIL Label */ 
        {
#line 142
        munmap((void *)state->map, (size_t )st.st_size);
#line 143
        state->map = (unsigned char *)((void *)0);
#line 144
        state->size = (size_t )0;
#line 145
        close(fd);
        }
#line 146
        if (! state->quiet) {
          {
#line 147
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s is not a valid ELF executable\n",
                  *(state->argv + state->files));
          }
        }
#line 148
        return (1);
      }
    }
  }
#line 151
  state->fd = fd;
#line 153
  return (0);
}
}
#line 156 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
static int pax_process_file(struct pax_state * const  state ) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 158
  ret = 1;
#line 161
  tmp = pax_verify_file(state);
  }
#line 161
  if (0 == tmp) {
    {
#line 163
    ret = (*((state->ops)->modify_phdr))(state);
#line 165
    munmap((void *)state->map, state->size);
#line 166
    close(state->fd);
#line 167
    state->map = (unsigned char *)((void *)0);
#line 168
    state->size = (size_t )0;
#line 169
    state->fd = -1;
    }
  }
#line 172
  return (ret);
}
}
#line 175 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
static int pax_process_files(struct pax_state * const  state ) 
{ 
  int status ;
  int tmp ;

  {
#line 177
  status = 0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! *(state->argv + state->files)) {
#line 179
      goto while_break;
    }
    {
#line 180
    tmp = pax_process_file(state);
    }
#line 180
    if (0 != tmp) {
#line 181
      status = 1;
    }
#line 182
    (state->files) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return (status);
}
}
#line 188 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
static int pax_parse_args(int argc , struct pax_state * const  state ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 191
    tmp = getopt(argc, (char * const  *)state->argv, "pPsSmMeErRxXvqQzcC");
    }
    {
#line 192
    if (tmp == -1) {
#line 192
      goto case_neg_1;
    }
#line 196
    if (tmp == 63) {
#line 196
      goto case_63;
    }
#line 213
    if (tmp == 112) {
#line 213
      goto case_112;
    }
#line 213
    if (tmp == 80) {
#line 213
      goto case_80;
    }
#line 214
    if (tmp == 115) {
#line 214
      goto case_115;
    }
#line 214
    if (tmp == 83) {
#line 214
      goto case_83;
    }
#line 215
    if (tmp == 109) {
#line 215
      goto case_109;
    }
#line 215
    if (tmp == 77) {
#line 215
      goto case_77;
    }
#line 216
    if (tmp == 101) {
#line 216
      goto case_101;
    }
#line 216
    if (tmp == 69) {
#line 216
      goto case_69;
    }
#line 217
    if (tmp == 114) {
#line 217
      goto case_114;
    }
#line 217
    if (tmp == 82) {
#line 217
      goto case_82;
    }
#line 218
    if (tmp == 120) {
#line 218
      goto case_120;
    }
#line 218
    if (tmp == 88) {
#line 218
      goto case_88;
    }
#line 222
    if (tmp == 118) {
#line 222
      goto case_118;
    }
#line 226
    if (tmp == 113) {
#line 226
      goto case_113;
    }
#line 230
    if (tmp == 81) {
#line 230
      goto case_81;
    }
#line 234
    if (tmp == 122) {
#line 234
      goto case_122;
    }
#line 239
    if (tmp == 99) {
#line 239
      goto case_99;
    }
#line 243
    if (tmp == 67) {
#line 243
      goto case_67;
    }
#line 191
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 193
    state->files = (unsigned int )optind;
#line 194
    if (optind < argc) {
#line 194
      tmp___0 = 0;
    } else {
#line 194
      tmp___0 = 1;
    }
#line 194
    return (tmp___0);
    case_63: /* CIL Label */ 
#line 197
    return (1);
    case_112: /* CIL Label */ 
#line 213
    state->flags_on &= ~ (1U << 4);
#line 213
    state->flags_on |= 1U << 5;
#line 213
    state->flags_off &= ~ (1U << 5);
#line 213
    state->flags_off |= 1U << 4;
#line 213
    goto switch_break;
    case_80: /* CIL Label */ 
#line 213
    state->flags_on &= ~ (1U << 5);
#line 213
    state->flags_on |= 1U << 4;
#line 213
    state->flags_off &= ~ (1U << 4);
#line 213
    state->flags_off |= 1U << 5;
#line 213
    goto switch_break;
    case_115: /* CIL Label */ 
#line 214
    state->flags_on &= ~ (1U << 6);
#line 214
    state->flags_on |= 1U << 7;
#line 214
    state->flags_off &= ~ (1U << 7);
#line 214
    state->flags_off |= 1U << 6;
#line 214
    goto switch_break;
    case_83: /* CIL Label */ 
#line 214
    state->flags_on &= ~ (1U << 7);
#line 214
    state->flags_on |= 1U << 6;
#line 214
    state->flags_off &= ~ (1U << 6);
#line 214
    state->flags_off |= 1U << 7;
#line 214
    goto switch_break;
    case_109: /* CIL Label */ 
#line 215
    state->flags_on &= ~ (1U << 8);
#line 215
    state->flags_on |= 1U << 9;
#line 215
    state->flags_off &= ~ (1U << 9);
#line 215
    state->flags_off |= 1U << 8;
#line 215
    goto switch_break;
    case_77: /* CIL Label */ 
#line 215
    state->flags_on &= ~ (1U << 9);
#line 215
    state->flags_on |= 1U << 8;
#line 215
    state->flags_off &= ~ (1U << 8);
#line 215
    state->flags_off |= 1U << 9;
#line 215
    goto switch_break;
    case_101: /* CIL Label */ 
#line 216
    state->flags_on &= ~ (1U << 12);
#line 216
    state->flags_on |= 1U << 13;
#line 216
    state->flags_off &= ~ (1U << 13);
#line 216
    state->flags_off |= 1U << 12;
#line 216
    goto switch_break;
    case_69: /* CIL Label */ 
#line 216
    state->flags_on &= ~ (1U << 13);
#line 216
    state->flags_on |= 1U << 12;
#line 216
    state->flags_off &= ~ (1U << 12);
#line 216
    state->flags_off |= 1U << 13;
#line 216
    goto switch_break;
    case_114: /* CIL Label */ 
#line 217
    state->flags_on &= ~ (1U << 14);
#line 217
    state->flags_on |= 1U << 15;
#line 217
    state->flags_off &= ~ (1U << 15);
#line 217
    state->flags_off |= 1U << 14;
#line 217
    goto switch_break;
    case_82: /* CIL Label */ 
#line 217
    state->flags_on &= ~ (1U << 15);
#line 217
    state->flags_on |= 1U << 14;
#line 217
    state->flags_off &= ~ (1U << 14);
#line 217
    state->flags_off |= 1U << 15;
#line 217
    goto switch_break;
    case_120: /* CIL Label */ 
#line 218
    state->flags_on &= ~ (1U << 10);
#line 218
    state->flags_on |= 1U << 11;
#line 218
    state->flags_off &= ~ (1U << 11);
#line 218
    state->flags_off |= 1U << 10;
#line 218
    goto switch_break;
    case_88: /* CIL Label */ 
#line 218
    state->flags_on &= ~ (1U << 11);
#line 218
    state->flags_on |= 1U << 10;
#line 218
    state->flags_off &= ~ (1U << 10);
#line 218
    state->flags_off |= 1U << 11;
#line 218
    goto switch_break;
    case_118: /* CIL Label */ 
#line 223
    state->view = 1U;
#line 224
    goto switch_break;
    case_113: /* CIL Label */ 
#line 227
    state->quiet = 1U;
#line 228
    goto switch_break;
    case_81: /* CIL Label */ 
#line 231
    state->shortonly = 1U;
#line 232
    goto switch_break;
    case_122: /* CIL Label */ 
#line 235
    state->flags_on = 0U;
#line 236
    state->flags_off = 65520U;
#line 237
    goto switch_break;
    case_99: /* CIL Label */ 
#line 240
    state->convert = 1U;
#line 241
    goto switch_break;
    case_67: /* CIL Label */ 
#line 244
    state->create = 1U;
#line 245
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 250 "/home/wheatley/newnew/temp/paxctl-0.7/paxctl.c"
int main(int argc , char **argv ) 
{ 
  struct pax_state state ;
  int tmp ;
  int tmp___0 ;

  {
#line 252
  state.argv = argv;
#line 252
  state.flags_on = 0U;
#line 252
  state.flags_off = 0U;
#line 252
  state.files = 0U;
#line 252
  state.quiet = 0U;
#line 252
  state.shortonly = 0U;
#line 252
  state.view = 0U;
#line 252
  state.convert = 0U;
#line 252
  state.create = 0U;
#line 252
  state.ops = (struct elf_ops *)((void *)0);
#line 252
  state.fd = -1;
#line 252
  state.map = (unsigned char *)((void *)0);
#line 252
  state.size = (size_t )0;
#line 268
  if (3 > argc) {
    {
#line 269
    usage();
    }
  }
  {
#line 272
  tmp = pax_parse_args(argc, (struct pax_state */* const  */)(& state));
  }
#line 272
  if (0 != tmp) {
#line 273
    return (1);
  }
#line 275
  if (state.view) {
    {
#line 276
    banner();
    }
  }
  {
#line 279
  tmp___0 = pax_process_files((struct pax_state */* const  */)(& state));
  }
#line 279
  return (tmp___0);
}
}
