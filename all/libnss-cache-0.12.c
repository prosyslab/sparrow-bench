/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 37 "/usr/include/grp.h"
typedef __gid_t gid_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 31 "/usr/include/nss.h"
enum nss_status {
    NSS_STATUS_TRYAGAIN = -2,
    NSS_STATUS_UNAVAIL = -1,
    NSS_STATUS_NOTFOUND = 0,
    NSS_STATUS_SUCCESS = 1,
    NSS_STATUS_RETURN = 2
} ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_11 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_11 pthread_mutex_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 39 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 82 "/usr/include/wchar.h"
union __anonunion___value_22 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 82 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_21 {
   int __count ;
   union __anonunion___value_22 __value ;
};
#line 82 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_21 __mbstate_t;
#line 21 "/usr/include/_G_config.h"
struct __anonstruct__G_fpos_t_23 {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 21 "/usr/include/_G_config.h"
typedef struct __anonstruct__G_fpos_t_23 _G_fpos_t;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 110 "/usr/include/stdio.h"
typedef _G_fpos_t fpos_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 48 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.h"
enum nss_cache_match {
    NSS_CACHE_EXACT = 0,
    NSS_CACHE_HIGH = 1,
    NSS_CACHE_LOW = 2,
    NSS_CACHE_ERROR = 3
} ;
#line 55 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.h"
struct nss_cache_args {
   char *system_filename ;
   char *sorted_filename ;
   void *lookup_function ;
   void *lookup_value ;
   void *lookup_result ;
   char *buffer ;
   size_t buflen ;
   char *lookup_key ;
   size_t lookup_key_length ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 165 "/usr/include/grp.h"
extern int fgetgrent_r(FILE * __restrict  __stream , struct group * __restrict  __resultbuf ,
                       char * __restrict  __buffer , size_t __buflen , struct group ** __restrict  __result ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 755
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 163 "/usr/include/pwd.h"
extern int fgetpwent_r(FILE * __restrict  __stream , struct passwd * __restrict  __resultbuf ,
                       char * __restrict  __buffer , size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 131 "/usr/include/shadow.h"
extern int fgetspent_r(FILE *__stream , struct spwd *__result_buf , char *__buffer ,
                       size_t __buflen , struct spwd **__result ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 798
extern int fgetpos(FILE * __restrict  __stream , fpos_t * __restrict  __pos ) ;
#line 803
extern int fsetpos(FILE *__stream , fpos_t const   *__pos ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 151
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 195 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) difftime)(time_t __time1 ,
                                                                                  time_t __time0 )  __attribute__((__const__)) ;
#line 44 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.h"
extern char *_nss_cache_setpwent_path(char const   *path ) ;
#line 45
extern char *_nss_cache_setgrent_path(char const   *path ) ;
#line 46
extern char *_nss_cache_setspent_path(char const   *path ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 773 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 29 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static pthread_mutex_t mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 33 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static FILE *p_file  =    (FILE *)((void *)0);
#line 34 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static FILE *g_file  =    (FILE *)((void *)0);
#line 35 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static FILE *s_file  =    (FILE *)((void *)0);
#line 36 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static char p_filename[255]  = 
#line 36
  {      (char )'/',      (char )'e',      (char )'t',      (char )'c', 
        (char )'/',      (char )'p',      (char )'a',      (char )'s', 
        (char )'s',      (char )'w',      (char )'d',      (char )'.', 
        (char )'c',      (char )'a',      (char )'c',      (char )'h', 
        (char )'e',      (char )'\000'};
#line 37 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static char g_filename[255]  = 
#line 37
  {      (char )'/',      (char )'e',      (char )'t',      (char )'c', 
        (char )'/',      (char )'g',      (char )'r',      (char )'o', 
        (char )'u',      (char )'p',      (char )'.',      (char )'c', 
        (char )'a',      (char )'c',      (char )'h',      (char )'e', 
        (char )'\000'};
#line 38 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static char s_filename[255]  = 
#line 38
  {      (char )'/',      (char )'e',      (char )'t',      (char )'c', 
        (char )'/',      (char )'s',      (char )'h',      (char )'a', 
        (char )'d',      (char )'o',      (char )'w',      (char )'.', 
        (char )'c',      (char )'a',      (char )'c',      (char )'h', 
        (char )'e',      (char )'\000'};
#line 45 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
__inline static enum nss_status _nss_cache_ent_bad_return_code(int errnoval ) 
{ 
  enum nss_status ret ;

  {
  {
#line 49
  if (errnoval == 34) {
#line 49
    goto case_34;
  }
#line 54
  goto switch_default;
  case_34: /* CIL Label */ 
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  ret = (enum nss_status )-2;
#line 52
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  ret = (enum nss_status )0;
  switch_break: /* CIL Label */ ;
  }
#line 58
  return (ret);
}
}
#line 65 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
int _nss_cache_bsearch2_compare(void const   *key , void const   *value ) 
{ 
  struct nss_cache_args *args ;
  char const   *value_text ;
  int tmp ;

  {
  {
#line 66
  args = (struct nss_cache_args *)key;
#line 67
  value_text = (char const   *)value;
#line 71
  tmp = strcmp((char const   *)args->lookup_key, value_text);
  }
#line 71
  return (tmp);
}
}
#line 74 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_bsearch2(struct nss_cache_args *args , int *errnop ) 
{ 
  enum nss_cache_match (*lookup)(FILE * , struct nss_cache_args * ) ;
  FILE *file ;
  FILE *system_file_stream ;
  struct stat system_file ;
  struct stat sorted_file ;
  enum nss_status ret ;
  long offset ;
  void *mapped_data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  char const   *data ;
  long entry_size ;
  long entry_count ;
  void *entry ;
  void *tmp___4 ;
  char const   *entry_text ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  enum nss_cache_match tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 75
  lookup = (enum nss_cache_match (*)(FILE * , struct nss_cache_args * ))args->lookup_function;
#line 79
  file = (FILE *)((void *)0);
#line 80
  system_file_stream = (FILE *)((void *)0);
#line 83
  ret = (enum nss_status )100;
#line 84
  offset = 0L;
#line 85
  mapped_data = (void *)0;
#line 87
  file = fopen((char const   */* __restrict  */)args->sorted_filename, (char const   */* __restrict  */)"r");
  }
#line 88
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 89
    while (1) {
      while_continue: /* CIL Label */ ;
#line 89
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    return ((enum nss_status )-1);
  }
  {
#line 96
  tmp = stat((char const   */* __restrict  */)args->system_filename, (struct stat */* __restrict  */)(& system_file));
  }
#line 96
  if (tmp != 0) {
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 98
    fclose(file);
    }
#line 99
    return ((enum nss_status )-1);
  }
  {
#line 101
  tmp___0 = fileno(file);
#line 101
  tmp___1 = fstat(tmp___0, & sorted_file);
  }
#line 101
  if (tmp___1 != 0) {
    {
#line 102
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 102
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 103
    fclose(file);
    }
#line 104
    return ((enum nss_status )-1);
  }
  {
#line 106
  tmp___2 = difftime(system_file.st_mtim.tv_sec, sorted_file.st_mtim.tv_sec);
  }
#line 106
  if (tmp___2 > (double )0) {
    {
#line 107
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 107
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 108
    fclose(file);
    }
#line 109
    return ((enum nss_status )-1);
  }
  {
#line 112
  tmp___3 = fileno(file);
#line 112
  mapped_data = mmap((void *)0, (size_t )sorted_file.st_size, 1, 2, tmp___3, (__off_t )0);
  }
#line 113
  if ((unsigned long )mapped_data == (unsigned long )((void *)-1)) {
    {
#line 114
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 114
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 115
    fclose(file);
    }
#line 116
    return ((enum nss_status )-1);
  }
#line 119
  data = (char const   *)mapped_data;
  {
#line 120
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 120
    if (! ((int const   )*data != 10)) {
#line 120
      goto while_break___4;
    }
#line 120
    data ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 121
  entry_size = (data - (char const   *)mapped_data) + 1L;
#line 122
  entry_count = sorted_file.st_size / entry_size;
#line 124
  tmp___4 = bsearch((void const   *)args, (void const   *)mapped_data, (size_t )entry_count,
                    (size_t )entry_size, & _nss_cache_bsearch2_compare);
#line 124
  entry = tmp___4;
  }
#line 125
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    {
#line 126
    entry_text = (char const   *)entry;
#line 127
    tmp___5 = strlen(entry_text);
#line 127
    sscanf((char const   */* __restrict  */)((entry_text + tmp___5) + 1), (char const   */* __restrict  */)"%ld",
           & offset);
    }
  }
  {
#line 130
  tmp___6 = munmap(mapped_data, (size_t )sorted_file.st_size);
  }
#line 130
  if (tmp___6 == -1) {
    {
#line 131
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 131
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 133
  fclose(file);
  }
#line 135
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 136
    return ((enum nss_status )0);
  }
  {
#line 139
  system_file_stream = fopen((char const   */* __restrict  */)args->system_filename,
                             (char const   */* __restrict  */)"r");
  }
#line 140
  if ((unsigned long )system_file_stream == (unsigned long )((void *)0)) {
    {
#line 141
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 141
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 142
    return ((enum nss_status )-1);
  }
  {
#line 145
  tmp___7 = fseek(system_file_stream, offset, 0);
  }
#line 145
  if (tmp___7 != 0) {
    {
#line 146
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 146
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 147
    return ((enum nss_status )-1);
  }
  {
#line 150
  tmp___8 = (*lookup)(system_file_stream, args);
  }
  {
#line 151
  if ((unsigned int )tmp___8 == 0U) {
#line 151
    goto case_0;
  }
#line 154
  if ((unsigned int )tmp___8 == 3U) {
#line 154
    goto case_3;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
#line 152
  ret = (enum nss_status )1;
#line 153
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 155
  tmp___10 = __errno_location();
  }
#line 155
  if (*tmp___10 == 34) {
    {
#line 157
    tmp___9 = __errno_location();
#line 157
    *errnop = *tmp___9;
#line 158
    ret = _nss_cache_ent_bad_return_code(*errnop);
    }
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 162
  ret = (enum nss_status )-1;
#line 163
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 166
  fclose(system_file_stream);
  }
#line 167
  return (ret);
}
}
#line 177 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
extern char *_nss_cache_setpwent_path(char const   *path ) 
{ 
  char *tmp ;

  {
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  tmp = strncpy((char */* __restrict  */)(p_filename), (char const   */* __restrict  */)path,
                (size_t )254);
  }
#line 180
  return (tmp);
}
}
#line 187 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_cache_match _nss_cache_pwuid_wrap(FILE *file , struct nss_cache_args *args ) 
{ 
  struct passwd *result ;
  uid_t *uid ;
  int tmp ;

  {
  {
#line 189
  result = (struct passwd *)args->lookup_result;
#line 190
  uid = (uid_t *)args->lookup_value;
#line 192
  tmp = fgetpwent_r((FILE */* __restrict  */)file, (struct passwd */* __restrict  */)result,
                    (char */* __restrict  */)args->buffer, args->buflen, (struct passwd **/* __restrict  */)(& result));
  }
#line 192
  if (tmp == 0) {
#line 193
    if (result->pw_uid == *uid) {
      {
#line 194
      while (1) {
        while_continue: /* CIL Label */ ;
#line 194
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 195
      return ((enum nss_cache_match )0);
    }
    {
#line 197
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 197
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 198
    if (result->pw_uid > *uid) {
#line 199
      return ((enum nss_cache_match )1);
    } else {
#line 201
      return ((enum nss_cache_match )2);
    }
  }
#line 205
  return ((enum nss_cache_match )3);
}
}
#line 211 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_cache_match _nss_cache_pwnam_wrap(FILE *file , struct nss_cache_args *args ) 
{ 
  struct passwd *result ;
  char *name ;
  int ret ;
  int tmp ;

  {
  {
#line 213
  result = (struct passwd *)args->lookup_result;
#line 214
  name = (char *)args->lookup_value;
#line 217
  tmp = fgetpwent_r((FILE */* __restrict  */)file, (struct passwd */* __restrict  */)result,
                    (char */* __restrict  */)args->buffer, args->buflen, (struct passwd **/* __restrict  */)(& result));
  }
#line 217
  if (tmp == 0) {
    {
#line 218
    ret = strcoll((char const   *)result->pw_name, (char const   *)name);
    }
#line 219
    if (ret == 0) {
      {
#line 220
      while (1) {
        while_continue: /* CIL Label */ ;
#line 220
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 221
      return ((enum nss_cache_match )0);
    }
    {
#line 223
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 223
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    if (ret > 0) {
#line 225
      return ((enum nss_cache_match )1);
    } else {
#line 227
      return ((enum nss_cache_match )2);
    }
  }
#line 231
  return ((enum nss_cache_match )3);
}
}
#line 237 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_status _nss_cache_setpwent_locked(void) 
{ 


  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  p_file = fopen((char const   */* __restrict  */)(p_filename), (char const   */* __restrict  */)"r");
  }
#line 242
  if (p_file) {
#line 243
    return ((enum nss_status )1);
  } else {
#line 245
    return ((enum nss_status )-1);
  }
}
}
#line 253 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_setpwent(int stayopen ) 
{ 
  enum nss_status ret ;

  {
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 255
    pthread_mutex_lock(& mutex);
    }
#line 255
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  ret = _nss_cache_setpwent_locked();
  }
  {
#line 257
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 257
    pthread_mutex_unlock(& mutex);
    }
#line 257
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 258
  return (ret);
}
}
#line 264 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_status _nss_cache_endpwent_locked(void) 
{ 


  {
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if (p_file) {
    {
#line 268
    fclose(p_file);
#line 269
    p_file = (FILE *)((void *)0);
    }
  }
#line 271
  return ((enum nss_status )1);
}
}
#line 277 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_endpwent(void) 
{ 
  enum nss_status ret ;

  {
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 279
    pthread_mutex_lock(& mutex);
    }
#line 279
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  ret = _nss_cache_endpwent_locked();
  }
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 281
    pthread_mutex_unlock(& mutex);
    }
#line 281
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 282
  return (ret);
}
}
#line 288 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_status _nss_cache_getpwent_r_locked(struct passwd *result , char *buffer ,
                                                    size_t buflen , int *errnop ) 
{ 
  enum nss_status ret ;
  int *tmp ;
  int tmp___0 ;

  {
#line 291
  ret = (enum nss_status )1;
#line 293
  if ((unsigned long )p_file == (unsigned long )((void *)0)) {
    {
#line 294
    while (1) {
      while_continue: /* CIL Label */ ;
#line 294
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 295
    ret = _nss_cache_setpwent_locked();
    }
  }
#line 298
  if ((int )ret == 1) {
    {
#line 299
    tmp___0 = fgetpwent_r((FILE */* __restrict  */)p_file, (struct passwd */* __restrict  */)result,
                          (char */* __restrict  */)buffer, buflen, (struct passwd **/* __restrict  */)(& result));
    }
#line 299
    if (tmp___0 == 0) {
      {
#line 300
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 300
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 302
      tmp = __errno_location();
#line 302
      *errnop = *tmp;
#line 303
      ret = _nss_cache_ent_bad_return_code(*errnop);
      }
    }
  }
#line 307
  return (ret);
}
}
#line 313 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_getpwent_r(struct passwd *result , char *buffer , size_t buflen ,
                                      int *errnop ) 
{ 
  enum nss_status ret ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 317
    pthread_mutex_lock(& mutex);
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  ret = _nss_cache_getpwent_r_locked(result, buffer, buflen, errnop);
  }
  {
#line 319
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 319
    pthread_mutex_unlock(& mutex);
    }
#line 319
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 320
  return (ret);
}
}
#line 326 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_getpwuid_r(uid_t uid , struct passwd *result , char *buffer ,
                                      size_t buflen , int *errnop ) 
{ 
  char filename[255] ;
  struct nss_cache_args args ;
  enum nss_status ret ;
  size_t tmp ;
  char uid_text[11] ;

  {
  {
#line 333
  strncpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)(p_filename),
          (size_t )254);
#line 334
  tmp = strlen((char const   *)(filename));
  }
#line 334
  if (tmp > 248UL) {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
#line 335
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 336
    return ((enum nss_status )-1);
  }
  {
#line 338
  strncat((char */* __restrict  */)(filename), (char const   */* __restrict  */)".ixuid",
          (size_t )6);
#line 340
  args.sorted_filename = filename;
#line 341
  args.system_filename = p_filename;
#line 342
  args.lookup_function = (void *)(& _nss_cache_pwuid_wrap);
#line 343
  args.lookup_value = (void *)(& uid);
#line 344
  args.lookup_result = (void *)result;
#line 345
  args.buffer = buffer;
#line 346
  args.buflen = buflen;
#line 348
  snprintf((char */* __restrict  */)(uid_text), sizeof(uid_text), (char const   */* __restrict  */)"%d",
           uid);
#line 349
  args.lookup_key = uid_text;
#line 350
  args.lookup_key_length = strlen((char const   *)(uid_text));
  }
  {
#line 352
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 352
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 353
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 353
    pthread_mutex_lock(& mutex);
    }
#line 353
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 354
  ret = _nss_cache_bsearch2(& args, errnop);
  }
#line 356
  if ((int )ret == -1) {
    {
#line 357
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 357
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 358
    ret = _nss_cache_setpwent_locked();
    }
#line 360
    if ((int )ret == 1) {
      {
#line 361
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 361
        ret = _nss_cache_getpwent_r_locked(result, buffer, buflen, errnop);
        }
#line 361
        if (! ((int )ret == 1)) {
#line 361
          goto while_break___3;
        }
#line 366
        if (result->pw_uid == uid) {
#line 367
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  {
#line 372
  _nss_cache_endpwent_locked();
  }
  {
#line 373
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 373
    pthread_mutex_unlock(& mutex);
    }
#line 373
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 375
  return (ret);
}
}
#line 381 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_getpwnam_r(char const   *name , struct passwd *result ,
                                      char *buffer , size_t buflen , int *errnop ) 
{ 
  char *pw_name ;
  char filename[255] ;
  struct nss_cache_args args ;
  enum nss_status ret ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 389
    pthread_mutex_lock(& mutex);
    }
#line 389
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 392
  tmp = strlen(name);
#line 392
  tmp___0 = malloc(tmp + 1UL);
#line 392
  pw_name = (char *)tmp___0;
  }
#line 393
  if ((unsigned long )pw_name == (unsigned long )((void *)0)) {
    {
#line 394
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 394
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 395
    return ((enum nss_status )-1);
  }
  {
#line 397
  tmp___1 = strlen(name);
#line 397
  strncpy((char */* __restrict  */)pw_name, (char const   */* __restrict  */)name,
          tmp___1 + 1UL);
#line 399
  strncpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)(p_filename),
          (size_t )254);
#line 400
  tmp___2 = strlen((char const   *)(filename));
  }
#line 400
  if (tmp___2 > 247UL) {
    {
#line 401
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 401
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 402
    free((void *)pw_name);
    }
#line 403
    return ((enum nss_status )-1);
  }
  {
#line 405
  strncat((char */* __restrict  */)(filename), (char const   */* __restrict  */)".ixname",
          (size_t )7);
#line 407
  args.sorted_filename = filename;
#line 408
  args.system_filename = p_filename;
#line 409
  args.lookup_function = (void *)(& _nss_cache_pwnam_wrap);
#line 410
  args.lookup_value = (void *)pw_name;
#line 411
  args.lookup_result = (void *)result;
#line 412
  args.buffer = buffer;
#line 413
  args.buflen = buflen;
#line 414
  args.lookup_key = pw_name;
#line 415
  args.lookup_key_length = strlen((char const   *)pw_name);
  }
  {
#line 417
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 417
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 418
  ret = _nss_cache_bsearch2(& args, errnop);
  }
#line 420
  if ((int )ret == -1) {
    {
#line 421
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 421
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 422
    ret = _nss_cache_setpwent_locked();
    }
#line 424
    if ((int )ret == 1) {
      {
#line 425
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 425
        ret = _nss_cache_getpwent_r_locked(result, buffer, buflen, errnop);
        }
#line 425
        if (! ((int )ret == 1)) {
#line 425
          goto while_break___4;
        }
        {
#line 430
        tmp___3 = strcmp((char const   *)result->pw_name, name);
        }
#line 430
        if (! tmp___3) {
#line 431
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
  {
#line 436
  free((void *)pw_name);
#line 437
  _nss_cache_endpwent_locked();
  }
  {
#line 438
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 438
    pthread_mutex_unlock(& mutex);
    }
#line 438
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 440
  return (ret);
}
}
#line 450 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
extern char *_nss_cache_setgrent_path(char const   *path ) 
{ 
  char *tmp ;

  {
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 453
  tmp = strncpy((char */* __restrict  */)(g_filename), (char const   */* __restrict  */)path,
                (size_t )254);
  }
#line 453
  return (tmp);
}
}
#line 460 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_status _nss_cache_setgrent_locked(void) 
{ 


  {
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 463
  g_file = fopen((char const   */* __restrict  */)(g_filename), (char const   */* __restrict  */)"r");
  }
#line 465
  if (g_file) {
#line 466
    return ((enum nss_status )1);
  } else {
#line 468
    return ((enum nss_status )-1);
  }
}
}
#line 475 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_cache_match _nss_cache_grgid_wrap(FILE *file , struct nss_cache_args *args ) 
{ 
  struct group *result ;
  gid_t *gid ;
  int tmp ;

  {
  {
#line 477
  result = (struct group *)args->lookup_result;
#line 478
  gid = (gid_t *)args->lookup_value;
#line 480
  tmp = fgetgrent_r((FILE */* __restrict  */)file, (struct group */* __restrict  */)result,
                    (char */* __restrict  */)args->buffer, args->buflen, (struct group **/* __restrict  */)(& result));
  }
#line 480
  if (tmp == 0) {
#line 481
    if (result->gr_gid == *gid) {
      {
#line 482
      while (1) {
        while_continue: /* CIL Label */ ;
#line 482
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 483
      return ((enum nss_cache_match )0);
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 486
    if (result->gr_gid > *gid) {
#line 487
      return ((enum nss_cache_match )1);
    } else {
#line 489
      return ((enum nss_cache_match )2);
    }
  }
#line 493
  return ((enum nss_cache_match )3);
}
}
#line 499 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_cache_match _nss_cache_grnam_wrap(FILE *file , struct nss_cache_args *args ) 
{ 
  struct group *result ;
  char *name ;
  int ret ;
  int tmp ;

  {
  {
#line 501
  result = (struct group *)args->lookup_result;
#line 502
  name = (char *)args->lookup_value;
#line 505
  tmp = fgetgrent_r((FILE */* __restrict  */)file, (struct group */* __restrict  */)result,
                    (char */* __restrict  */)args->buffer, args->buflen, (struct group **/* __restrict  */)(& result));
  }
#line 505
  if (tmp == 0) {
    {
#line 506
    ret = strcoll((char const   *)result->gr_name, (char const   *)name);
    }
#line 507
    if (ret == 0) {
      {
#line 508
      while (1) {
        while_continue: /* CIL Label */ ;
#line 508
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 509
      return ((enum nss_cache_match )0);
    }
    {
#line 511
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 511
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 512
    if (ret > 0) {
#line 513
      return ((enum nss_cache_match )1);
    } else {
#line 515
      return ((enum nss_cache_match )2);
    }
  }
#line 519
  return ((enum nss_cache_match )3);
}
}
#line 526 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_setgrent(int stayopen ) 
{ 
  enum nss_status ret ;

  {
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    pthread_mutex_lock(& mutex);
    }
#line 528
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 529
  ret = _nss_cache_setgrent_locked();
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 530
    pthread_mutex_unlock(& mutex);
    }
#line 530
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 531
  return (ret);
}
}
#line 537 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_status _nss_cache_endgrent_locked(void) 
{ 


  {
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (g_file) {
    {
#line 541
    fclose(g_file);
#line 542
    g_file = (FILE *)((void *)0);
    }
  }
#line 544
  return ((enum nss_status )1);
}
}
#line 550 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_endgrent(void) 
{ 
  enum nss_status ret ;

  {
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 552
    pthread_mutex_lock(& mutex);
    }
#line 552
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  ret = _nss_cache_endgrent_locked();
  }
  {
#line 554
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 554
    pthread_mutex_unlock(& mutex);
    }
#line 554
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 555
  return (ret);
}
}
#line 561 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_status _nss_cache_getgrent_r_locked(struct group *result , char *buffer ,
                                                    size_t buflen , int *errnop ) 
{ 
  enum nss_status ret ;
  fpos_t position ;
  int *tmp ;
  int tmp___0 ;

  {
#line 564
  ret = (enum nss_status )1;
#line 566
  if ((unsigned long )g_file == (unsigned long )((void *)0)) {
    {
#line 567
    while (1) {
      while_continue: /* CIL Label */ ;
#line 567
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 568
    ret = _nss_cache_setgrent_locked();
    }
  }
#line 571
  if ((int )ret == 1) {
    {
#line 574
    fgetpos((FILE */* __restrict  */)g_file, (fpos_t */* __restrict  */)(& position));
#line 575
    tmp___0 = fgetgrent_r((FILE */* __restrict  */)g_file, (struct group */* __restrict  */)result,
                          (char */* __restrict  */)buffer, buflen, (struct group **/* __restrict  */)(& result));
    }
#line 575
    if (tmp___0 == 0) {
      {
#line 576
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 576
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 585
      fsetpos(g_file, (fpos_t const   *)(& position));
#line 586
      tmp = __errno_location();
#line 586
      *errnop = *tmp;
#line 587
      ret = _nss_cache_ent_bad_return_code(*errnop);
      }
    }
  }
#line 591
  return (ret);
}
}
#line 597 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_getgrent_r(struct group *result , char *buffer , size_t buflen ,
                                      int *errnop ) 
{ 
  enum nss_status ret ;

  {
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 601
    pthread_mutex_lock(& mutex);
    }
#line 601
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 602
  ret = _nss_cache_getgrent_r_locked(result, buffer, buflen, errnop);
  }
  {
#line 603
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 603
    pthread_mutex_unlock(& mutex);
    }
#line 603
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 604
  return (ret);
}
}
#line 610 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_getgrgid_r(gid_t gid , struct group *result , char *buffer ,
                                      size_t buflen , int *errnop ) 
{ 
  char filename[255] ;
  struct nss_cache_args args ;
  enum nss_status ret ;
  size_t tmp ;
  char gid_text[11] ;

  {
#line 620
  if (buflen < (size_t )(1 << 20)) {
#line 621
    *errnop = 34;
#line 622
    return ((enum nss_status )-2);
  }
  {
#line 625
  strncpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)(g_filename),
          (size_t )254);
#line 626
  tmp = strlen((char const   *)(filename));
  }
#line 626
  if (tmp > 248UL) {
    {
#line 627
    while (1) {
      while_continue: /* CIL Label */ ;
#line 627
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 628
    return ((enum nss_status )-1);
  }
  {
#line 630
  strncat((char */* __restrict  */)(filename), (char const   */* __restrict  */)".ixgid",
          (size_t )6);
#line 632
  args.sorted_filename = filename;
#line 633
  args.system_filename = g_filename;
#line 634
  args.lookup_function = (void *)(& _nss_cache_grgid_wrap);
#line 635
  args.lookup_value = (void *)(& gid);
#line 636
  args.lookup_result = (void *)result;
#line 637
  args.buffer = buffer;
#line 638
  args.buflen = buflen;
#line 640
  snprintf((char */* __restrict  */)(gid_text), sizeof(gid_text), (char const   */* __restrict  */)"%d",
           gid);
#line 641
  args.lookup_key = gid_text;
#line 642
  args.lookup_key_length = strlen((char const   *)(gid_text));
  }
  {
#line 644
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 644
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 645
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 645
    pthread_mutex_lock(& mutex);
    }
#line 645
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 646
  ret = _nss_cache_bsearch2(& args, errnop);
  }
#line 648
  if ((int )ret == -1) {
    {
#line 649
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 649
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 650
    ret = _nss_cache_setgrent_locked();
    }
#line 652
    if ((int )ret == 1) {
      {
#line 653
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 653
        ret = _nss_cache_getgrent_r_locked(result, buffer, buflen, errnop);
        }
#line 653
        if (! ((int )ret == 1)) {
#line 653
          goto while_break___3;
        }
#line 658
        if (result->gr_gid == gid) {
#line 659
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  {
#line 664
  _nss_cache_endgrent_locked();
  }
  {
#line 665
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 665
    pthread_mutex_unlock(& mutex);
    }
#line 665
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 667
  return (ret);
}
}
#line 673 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_getgrnam_r(char const   *name , struct group *result ,
                                      char *buffer , size_t buflen , int *errnop ) 
{ 
  char *gr_name ;
  char filename[255] ;
  struct nss_cache_args args ;
  enum nss_status ret ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 681
    pthread_mutex_lock(& mutex);
    }
#line 681
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 684
  tmp = strlen(name);
#line 684
  tmp___0 = malloc(tmp + 1UL);
#line 684
  gr_name = (char *)tmp___0;
  }
#line 685
  if ((unsigned long )gr_name == (unsigned long )((void *)0)) {
    {
#line 686
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 686
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 687
    return ((enum nss_status )-1);
  }
  {
#line 689
  tmp___1 = strlen(name);
#line 689
  strncpy((char */* __restrict  */)gr_name, (char const   */* __restrict  */)name,
          tmp___1 + 1UL);
#line 691
  strncpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)(g_filename),
          (size_t )254);
#line 692
  tmp___2 = strlen((char const   *)(filename));
  }
#line 692
  if (tmp___2 > 247UL) {
    {
#line 693
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 693
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 694
    free((void *)gr_name);
    }
#line 695
    return ((enum nss_status )-1);
  }
  {
#line 697
  strncat((char */* __restrict  */)(filename), (char const   */* __restrict  */)".ixname",
          (size_t )7);
#line 699
  args.sorted_filename = filename;
#line 700
  args.system_filename = g_filename;
#line 701
  args.lookup_function = (void *)(& _nss_cache_grnam_wrap);
#line 702
  args.lookup_value = (void *)gr_name;
#line 703
  args.lookup_result = (void *)result;
#line 704
  args.buffer = buffer;
#line 705
  args.buflen = buflen;
#line 706
  args.lookup_key = gr_name;
#line 707
  args.lookup_key_length = strlen((char const   *)gr_name);
  }
  {
#line 709
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 709
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 710
  ret = _nss_cache_bsearch2(& args, errnop);
  }
#line 712
  if ((int )ret == -1) {
    {
#line 713
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 713
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 714
    ret = _nss_cache_setgrent_locked();
    }
#line 716
    if ((int )ret == 1) {
      {
#line 717
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 717
        ret = _nss_cache_getgrent_r_locked(result, buffer, buflen, errnop);
        }
#line 717
        if (! ((int )ret == 1)) {
#line 717
          goto while_break___4;
        }
        {
#line 722
        tmp___3 = strcmp((char const   *)result->gr_name, name);
        }
#line 722
        if (! tmp___3) {
#line 723
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
  {
#line 728
  free((void *)gr_name);
#line 729
  _nss_cache_endgrent_locked();
  }
  {
#line 730
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 730
    pthread_mutex_unlock(& mutex);
    }
#line 730
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 732
  return (ret);
}
}
#line 742 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
extern char *_nss_cache_setspent_path(char const   *path ) 
{ 
  char *tmp ;

  {
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 745
  tmp = strncpy((char */* __restrict  */)(s_filename), (char const   */* __restrict  */)path,
                (size_t )254);
  }
#line 745
  return (tmp);
}
}
#line 752 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_status _nss_cache_setspent_locked(void) 
{ 


  {
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 755
  s_file = fopen((char const   */* __restrict  */)(s_filename), (char const   */* __restrict  */)"r");
  }
#line 757
  if (s_file) {
#line 758
    return ((enum nss_status )1);
  } else {
#line 760
    return ((enum nss_status )-1);
  }
}
}
#line 767 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_cache_match _nss_cache_spnam_wrap(FILE *file , struct nss_cache_args *args ) 
{ 
  struct spwd *result ;
  char *name ;
  int ret ;
  int tmp ;

  {
  {
#line 769
  result = (struct spwd *)args->lookup_result;
#line 770
  name = (char *)args->lookup_value;
#line 773
  tmp = fgetspent_r(file, result, args->buffer, args->buflen, & result);
  }
#line 773
  if (tmp == 0) {
    {
#line 774
    ret = strcoll((char const   *)result->sp_namp, (char const   *)name);
    }
#line 775
    if (ret == 0) {
      {
#line 776
      while (1) {
        while_continue: /* CIL Label */ ;
#line 776
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 777
      return ((enum nss_cache_match )0);
    }
    {
#line 779
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 779
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 780
    if (ret > 0) {
#line 781
      return ((enum nss_cache_match )1);
    } else {
#line 783
      return ((enum nss_cache_match )2);
    }
  }
#line 787
  return ((enum nss_cache_match )3);
}
}
#line 794 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_setspent(int stayopen ) 
{ 
  enum nss_status ret ;

  {
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 796
    pthread_mutex_lock(& mutex);
    }
#line 796
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 797
  ret = _nss_cache_setspent_locked();
  }
  {
#line 798
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 798
    pthread_mutex_unlock(& mutex);
    }
#line 798
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 799
  return (ret);
}
}
#line 805 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_status _nss_cache_endspent_locked(void) 
{ 


  {
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 807
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  if (s_file) {
    {
#line 809
    fclose(s_file);
#line 810
    s_file = (FILE *)((void *)0);
    }
  }
#line 812
  return ((enum nss_status )1);
}
}
#line 818 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_endspent(void) 
{ 
  enum nss_status ret ;

  {
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 820
    pthread_mutex_lock(& mutex);
    }
#line 820
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 821
  ret = _nss_cache_endspent_locked();
  }
  {
#line 822
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 822
    pthread_mutex_unlock(& mutex);
    }
#line 822
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 823
  return (ret);
}
}
#line 829 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
static enum nss_status _nss_cache_getspent_r_locked(struct spwd *result , char *buffer ,
                                                    size_t buflen , int *errnop ) 
{ 
  enum nss_status ret ;
  int *tmp ;
  int tmp___0 ;

  {
#line 833
  ret = (enum nss_status )1;
#line 835
  if ((unsigned long )s_file == (unsigned long )((void *)0)) {
    {
#line 836
    while (1) {
      while_continue: /* CIL Label */ ;
#line 836
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 837
    ret = _nss_cache_setspent_locked();
    }
  }
#line 840
  if ((int )ret == 1) {
    {
#line 841
    tmp___0 = fgetspent_r(s_file, result, buffer, buflen, & result);
    }
#line 841
    if (tmp___0 == 0) {
      {
#line 842
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 842
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 844
      tmp = __errno_location();
#line 844
      *errnop = *tmp;
#line 845
      ret = _nss_cache_ent_bad_return_code(*errnop);
      }
    }
  }
#line 849
  return (ret);
}
}
#line 855 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_getspent_r(struct spwd *result , char *buffer , size_t buflen ,
                                      int *errnop ) 
{ 
  enum nss_status ret ;

  {
  {
#line 859
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 859
    pthread_mutex_lock(& mutex);
    }
#line 859
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 860
  ret = _nss_cache_getspent_r_locked(result, buffer, buflen, errnop);
  }
  {
#line 861
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 861
    pthread_mutex_unlock(& mutex);
    }
#line 861
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 862
  return (ret);
}
}
#line 868 "/home/wheatley/newnew/temp/libnss-cache-0.12/nss_cache.c"
enum nss_status _nss_cache_getspnam_r(char const   *name , struct spwd *result , char *buffer ,
                                      size_t buflen , int *errnop ) 
{ 
  char *sp_namp ;
  char filename[255] ;
  struct nss_cache_args args ;
  enum nss_status ret ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 876
    pthread_mutex_lock(& mutex);
    }
#line 876
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 879
  tmp = strlen(name);
#line 879
  tmp___0 = malloc(tmp + 1UL);
#line 879
  sp_namp = (char *)tmp___0;
  }
#line 880
  if ((unsigned long )sp_namp == (unsigned long )((void *)0)) {
    {
#line 881
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 881
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 882
    return ((enum nss_status )-1);
  }
  {
#line 884
  tmp___1 = strlen(name);
#line 884
  strncpy((char */* __restrict  */)sp_namp, (char const   */* __restrict  */)name,
          tmp___1 + 1UL);
#line 886
  strncpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)(s_filename),
          (size_t )254);
#line 887
  tmp___2 = strlen((char const   *)(filename));
  }
#line 887
  if (tmp___2 > 247UL) {
    {
#line 888
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 888
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 889
    free((void *)sp_namp);
    }
#line 890
    return ((enum nss_status )-1);
  }
  {
#line 892
  strncat((char */* __restrict  */)(filename), (char const   */* __restrict  */)".ixname",
          (size_t )7);
#line 894
  args.sorted_filename = filename;
#line 895
  args.system_filename = s_filename;
#line 896
  args.lookup_function = (void *)(& _nss_cache_spnam_wrap);
#line 897
  args.lookup_value = (void *)sp_namp;
#line 898
  args.lookup_result = (void *)result;
#line 899
  args.buffer = buffer;
#line 900
  args.buflen = buflen;
#line 901
  args.lookup_key = sp_namp;
#line 902
  args.lookup_key_length = strlen((char const   *)sp_namp);
  }
  {
#line 904
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 904
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 905
  ret = _nss_cache_bsearch2(& args, errnop);
  }
#line 907
  if ((int )ret == -1) {
    {
#line 908
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 908
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 909
    ret = _nss_cache_setspent_locked();
    }
#line 911
    if ((int )ret == 1) {
      {
#line 912
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 912
        ret = _nss_cache_getspent_r_locked(result, buffer, buflen, errnop);
        }
#line 912
        if (! ((int )ret == 1)) {
#line 912
          goto while_break___4;
        }
        {
#line 917
        tmp___3 = strcmp((char const   *)result->sp_namp, name);
        }
#line 917
        if (! tmp___3) {
#line 918
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
  {
#line 923
  free((void *)sp_namp);
#line 924
  _nss_cache_endspent_locked();
  }
  {
#line 925
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 925
    pthread_mutex_unlock(& mutex);
    }
#line 925
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 927
  return (ret);
}
}
