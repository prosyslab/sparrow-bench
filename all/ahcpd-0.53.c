/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_31 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_34 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_35 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_36 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_29 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_30 _kill ;
   struct __anonstruct__timer_31 _timer ;
   struct __anonstruct__rt_32 _rt ;
   struct __anonstruct__sigchld_33 _sigchld ;
   struct __anonstruct__sigfault_34 _sigfault ;
   struct __anonstruct__sigpoll_35 _sigpoll ;
   struct __anonstruct__sigsys_36 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_28 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_29 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_28 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_48 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_48 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_58 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_58 __in6_u ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 288 "/usr/include/netinet/in.h"
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
#line 75 "/home/june/collector/temp/ahcpd-0.53/ahcpd.h"
struct network {
   char *ifname ;
   int ifindex ;
};
#line 35 "/home/june/collector/temp/ahcpd-0.53/prefix.h"
struct prefix {
   unsigned char p[16] ;
   unsigned char plen ;
};
#line 42 "/home/june/collector/temp/ahcpd-0.53/prefix.h"
struct prefix_list {
   int n ;
   struct prefix l[8] ;
};
#line 23 "/home/june/collector/temp/ahcpd-0.53/config.h"
struct server_config {
   char const   *lease_dir ;
   struct prefix_list *name_server ;
   struct prefix_list *ntp_server ;
   struct prefix_list *ipv6_prefix ;
   unsigned char lease_first[4] ;
   unsigned char lease_last[4] ;
};
#line 25 "/home/june/collector/temp/ahcpd-0.53/configure.h"
struct config_data {
   unsigned int origin ;
   unsigned int origin_m ;
   unsigned int expires ;
   unsigned int expires_m ;
   struct prefix_list *server_ipv6 ;
   struct prefix_list *server_ipv4 ;
   struct prefix_list *ipv6_prefix ;
   struct prefix_list *ipv4_prefix ;
   struct prefix_list *ipv6_address ;
   struct prefix_list *ipv4_address ;
   struct prefix_list *ipv6_prefix_delegation ;
   struct prefix_list *ipv4_prefix_delegation ;
   int ipv4_mandatory ;
   int ipv6_mandatory ;
   int ipv4_delegation_mandatory ;
   int ipv6_delegation_mandatory ;
   struct prefix_list *name_server ;
   struct prefix_list *ntp_server ;
   struct prefix_list *our_ipv6_address ;
};
#line 99 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
enum state {
    STATE_IDLE = 0,
    STATE_INIT = 1,
    STATE_REQUESTING = 2,
    STATE_RENEWING_UNICAST = 3,
    STATE_RENEWING = 4,
    STATE_BOUND = 5
} ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 81 "/home/june/collector/temp/ahcpd-0.53/lease.c"
struct lease_entry {
   unsigned char *id ;
   int id_len ;
   unsigned int address ;
   unsigned int lease_orig ;
   unsigned int lease_time ;
   time_t lease_end_m ;
};
#line 289 "/home/june/collector/temp/ahcpd-0.53/config.c"
struct string_state {
   char *string ;
   int n ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_57 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_58 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_57 ifr_ifrn ;
   union __anonunion_ifr_ifru_58 ifr_ifru ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 180 "/home/june/collector/temp/ahcpd-0.53/configure.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 179 "/home/june/collector/temp/ahcpd-0.53/configure.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 176 "/home/june/collector/temp/ahcpd-0.53/configure.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/timex.h"
struct timex {
   unsigned int modes ;
   __syscall_slong_t offset ;
   __syscall_slong_t freq ;
   __syscall_slong_t maxerror ;
   __syscall_slong_t esterror ;
   int status ;
   __syscall_slong_t constant ;
   __syscall_slong_t precision ;
   __syscall_slong_t tolerance ;
   struct timeval time ;
   __syscall_slong_t tick ;
   __syscall_slong_t ppsfreq ;
   __syscall_slong_t jitter ;
   int shift ;
   __syscall_slong_t stabil ;
   __syscall_slong_t jitcnt ;
   __syscall_slong_t calcnt ;
   __syscall_slong_t errcnt ;
   __syscall_slong_t stbcnt ;
   int tai ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 43 "/home/june/collector/temp/ahcpd-0.53/transport.c"
struct duplicate {
   struct timeval time ;
   unsigned char src[8] ;
   unsigned char dest[8] ;
   unsigned char nonce[4] ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 193 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) if_nametoindex)(char const   *__ifname ) ;
#line 70 "/home/june/collector/temp/ahcpd-0.53/ahcpd.h"
int nodns ;
#line 70
int af ;
#line 70
int request_prefix_delegation ;
#line 71
char *config_script ;
#line 72
int debug ;
#line 73 "/home/june/collector/temp/ahcpd-0.53/ahcpd.h"
unsigned char myid[8]  ;
#line 74 "/home/june/collector/temp/ahcpd-0.53/ahcpd.h"
int numnetworks  ;
#line 81 "/home/june/collector/temp/ahcpd-0.53/ahcpd.h"
struct network networks[20]  ;
#line 83 "/home/june/collector/temp/ahcpd-0.53/ahcpd.h"
struct in6_addr protocol_group  ;
#line 84
unsigned int protocol_port ;
#line 85
int protocol_socket ;
#line 87
unsigned char const   zeroes[16] ;
#line 87
unsigned char const   ones[16] ;
#line 89
void timeval_min(struct timeval *d , struct timeval  const  *s ) ;
#line 90
void timeval_min_sec(struct timeval *d , int secs ) ;
#line 91
void timeval_minus(struct timeval *d , struct timeval  const  *s1 , struct timeval  const  *s2 ) ;
#line 96
int timeval_compare(struct timeval  const  *s1 , struct timeval  const  *s2 ) ;
#line 98
void ( /* format attribute */  do_debugf)(int level , char const   *format  , ...)  __attribute__((__cold__)) ;
#line 29 "/home/june/collector/temp/ahcpd-0.53/monotonic.h"
void time_init(void) ;
#line 31
int get_real_time(struct timeval *tv , int *status_return ) ;
#line 32
int gettime(struct timeval *tv , time_t *stable ) ;
#line 23 "/home/june/collector/temp/ahcpd-0.53/transport.h"
unsigned int myseqno ;
#line 25
int send_packet(struct sockaddr *sin , int sinlen , unsigned char const   *dest ,
                int hopcount , unsigned char const   *buf___0 , size_t bufsize ) ;
#line 28
int handle_packet(int ll , unsigned char const   *buf___0 , size_t buflen ) ;
#line 51 "/home/june/collector/temp/ahcpd-0.53/prefix.h"
void prefix_list_extract4(unsigned char *dest , struct prefix_list *p ) ;
#line 29 "/home/june/collector/temp/ahcpd-0.53/config.h"
int client_config ;
#line 30
struct server_config *server_config ;
#line 32
int parse_config_from_string(char *string ) ;
#line 33
int parse_config_from_file(char *filename ) ;
#line 39 "/home/june/collector/temp/ahcpd-0.53/configure.h"
struct config_data *config_data ;
#line 41
unsigned int config_renew_time(void) ;
#line 42
void free_config_data(struct config_data *config ) ;
#line 46
struct config_data *make_config_data(int expires , unsigned char *ipv4 , struct server_config *server_config___0 ,
                                     char **interfaces___0 ) ;
#line 51
struct config_data *parse_message(int configure , unsigned char const   *data , int len ,
                                  char **interfaces___0 ) ;
#line 54
int unconfigure(char **interfaces___0 ) ;
#line 55
int query_body(unsigned char opcode , int time___0 , unsigned char const   *ipv4 ,
               unsigned char *buf___0 , int buflen ) ;
#line 57
int server_body(unsigned char opcode , struct config_data *config , unsigned char *buf___0 ,
                int buflen ) ;
#line 60
int if_eui64(char *ifname , unsigned char *eui ) ;
#line 61
int random_eui64(unsigned char *eui ) ;
#line 26 "/home/june/collector/temp/ahcpd-0.53/lease.h"
int lease_init(char const   *dir , unsigned char const   *first , unsigned char const   *last ,
               int debug___0 ) ;
#line 29
int take_lease(unsigned char const   *client_id , int client_len , unsigned char const   *suggested_ipv4 ,
               unsigned char *ipv4_return , unsigned int *lease_time , int commit ) ;
#line 33
int release_lease(unsigned char const   *client_id , int client_len , unsigned char const   *ipv4 ) ;
#line 53 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
struct timeval now  ;
#line 54 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
struct timeval  const  zero  =    {(__time_t )0, (__suseconds_t )0};
#line 56 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static int volatile   exiting  =    (sig_atomic_t volatile   )0;
#line 56 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static int volatile   dumping  =    (sig_atomic_t volatile   )0;
#line 56 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static int volatile   changed  =    (sig_atomic_t volatile   )0;
#line 58 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
unsigned int protocol_port  =    5359U;
#line 59 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int protocol_socket  =    -1;
#line 61 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
char *unique_id_file  =    (char *)"/var/lib/ahcpd-unique-id";
#line 62 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int nodns  =    0;
#line 62 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int af  =    3;
#line 62 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int request_prefix_delegation  =    0;
#line 63 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
char *config_script  =    (char *)"/etc/ahcp/ahcp-config.sh";
#line 64 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int debug  =    1;
#line 65 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int do_daemonise  =    0;
#line 66 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
char *logfile  =    (char *)((void *)0);
#line 66 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
char *pidfile  =    (char *)"/var/run/ahcpd.pid";
#line 73 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
char *interfaces[21]  ;
#line 74 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
struct timeval check_networks_time  =    {(__time_t )0, (__suseconds_t )0};
#line 76 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
struct timeval message_time  =    {(__time_t )0, (__suseconds_t )0};
#line 78 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
unsigned char const   zeroes[16]  = {      (unsigned char const   )0};
#line 79 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
unsigned char const   ones[16]  = 
#line 79
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255};
#line 84
static void init_signals(void) ;
#line 85
static int check_network(struct network *net ) ;
#line 86
int ahcp_socket(int port ) ;
#line 87
int ahcp_recv(int s , void *buf___0 , int buflen , struct sockaddr *sin , int slen ) ;
#line 88
static int send_unicast_packet(unsigned char *server_id , struct config_data *config ,
                               int index___0 , void *buf___0 , int buflen ) ;
#line 92
static int reopen_logfile(void) ;
#line 93
static int daemonise(void) ;
#line 94
static void set_timeout(int which , int msecs , int override ) ;
#line 95
unsigned int roughly(unsigned int value ) ;
#line 108 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int main(int argc , char **argv ) 
{ 
  char *multicast ;
  char *config_file ;
  struct sockaddr_in6 sin6 ;
  int opt ;
  int fd ;
  int rc ;
  int i ;
  int net ;
  unsigned int seed ;
  enum state state ;
  int count ;
  int server_hopcount ;
  unsigned char selected_server[8] ;
  unsigned char last_ipv4[4] ;
  unsigned int tmp ;
  unsigned int lease_time ;
  int tmp___0 ;
  int tmp___1 ;
  int pfd ;
  int len ;
  char buf___0[100] ;
  __pid_t tmp___2 ;
  ssize_t tmp___3 ;
  struct timeval tv ;
  ssize_t tmp___4 ;
  long tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  fd_set readfds ;
  struct timeval tv___0 ;
  int tmp___10 ;
  int __d0 ;
  int __d1 ;
  unsigned int tmp___11 ;
  long tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int clock_status___0 ;
  time_t stable ;
  struct timeval tv___1 ;
  struct timeval real ;
  int tmp___15 ;
  unsigned char buf___1[2048] ;
  int len___0 ;
  struct sockaddr *psin ;
  int sinlen ;
  int *tmp___16 ;
  int *tmp___17 ;
  struct in6_addr  const  *__a ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  unsigned char *body ;
  int bodylen ;
  long tmp___20 ;
  struct config_data *config ;
  long tmp___21 ;
  struct config_data *config___0 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  struct config_data *config___1 ;
  unsigned int client_lease_time ;
  unsigned char reply[2048] ;
  int hopcount ;
  unsigned char ipv4[4] ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  char a[16] ;
  int tmp___30 ;
  unsigned char *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  long tmp___36 ;
  unsigned int tmp___37 ;
  long tmp___38 ;
  long tmp___39 ;
  unsigned int tmp___40 ;
  unsigned char buf___2[2048] ;
  int i___0 ;
  unsigned char *tmp___42 ;
  int tmp___43 ;
  unsigned int tmp___44 ;
  long tmp___45 ;
  unsigned char *tmp___47 ;
  int tmp___48 ;
  unsigned int tmp___49 ;
  long tmp___50 ;
  long tmp___51 ;
  long tmp___52 ;
  long tmp___53 ;
  int tmp___54 ;
  long tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  unsigned char buf___3[2048] ;
  int len___1 ;
  unsigned char *tmp___59 ;
  int tmp___60 ;
  int index___0 ;
  int success ;
  long tmp___61 ;
  long tmp___62 ;
  long tmp___63 ;

  {
#line 111
  multicast = (char *)"ff02::cca6:c0f9:e182:5359";
#line 112
  config_file = (char *)((void *)0);
#line 116
  state = (enum state )0;
#line 117
  count = 0;
#line 118
  server_hopcount = 0;
#line 120
  last_ipv4[0] = (unsigned char)0;
#line 120
  tmp = 1U;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (tmp >= 4U) {
#line 120
      goto while_break;
    }
#line 120
    last_ipv4[tmp] = (unsigned char)0;
#line 120
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  lease_time = 3666U;
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 125
    opt = getopt(argc, (char * const  *)argv, "m:p:nN46s:d:i:t:P:c:C:DL:I:");
    }
#line 126
    if (opt < 0) {
#line 127
      goto while_break___0;
    }
    {
#line 130
    if (opt == 109) {
#line 130
      goto case_109;
    }
#line 133
    if (opt == 112) {
#line 133
      goto case_112;
    }
#line 138
    if (opt == 110) {
#line 138
      goto case_110;
    }
#line 141
    if (opt == 78) {
#line 141
      goto case_78;
    }
#line 144
    if (opt == 52) {
#line 144
      goto case_52;
    }
#line 147
    if (opt == 54) {
#line 147
      goto case_54;
    }
#line 150
    if (opt == 115) {
#line 150
      goto case_115;
    }
#line 153
    if (opt == 100) {
#line 153
      goto case_100;
    }
#line 156
    if (opt == 105) {
#line 156
      goto case_105;
    }
#line 159
    if (opt == 116) {
#line 159
      goto case_116;
    }
#line 164
    if (opt == 80) {
#line 164
      goto case_80;
    }
#line 167
    if (opt == 99) {
#line 167
      goto case_99;
    }
#line 170
    if (opt == 67) {
#line 170
      goto case_67;
    }
#line 178
    if (opt == 68) {
#line 178
      goto case_68;
    }
#line 181
    if (opt == 76) {
#line 181
      goto case_76;
    }
#line 184
    if (opt == 73) {
#line 184
      goto case_73;
    }
#line 187
    goto switch_default;
    case_109: /* CIL Label */ 
#line 131
    multicast = optarg;
#line 132
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 134
    tmp___0 = atoi((char const   *)optarg);
#line 134
    protocol_port = (unsigned int )tmp___0;
    }
#line 135
    if (protocol_port <= 0U) {
#line 136
      goto usage;
    } else
#line 135
    if (protocol_port > 65535U) {
#line 136
      goto usage;
    }
#line 137
    goto switch_break;
    case_110: /* CIL Label */ 
#line 139
    client_config = 0;
#line 140
    goto switch_break;
    case_78: /* CIL Label */ 
#line 142
    nodns = 1;
#line 143
    goto switch_break;
    case_52: /* CIL Label */ 
#line 145
    af = 1;
#line 146
    goto switch_break;
    case_54: /* CIL Label */ 
#line 148
    af = 2;
#line 149
    goto switch_break;
    case_115: /* CIL Label */ 
#line 151
    config_script = optarg;
#line 152
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 154
    debug = atoi((char const   *)optarg);
    }
#line 155
    goto switch_break;
    case_105: /* CIL Label */ 
#line 157
    unique_id_file = optarg;
#line 158
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 160
    tmp___1 = atoi((char const   *)optarg);
#line 160
    lease_time = (unsigned int )tmp___1;
    }
#line 161
    if (lease_time < 300U) {
#line 162
      goto usage;
    } else
#line 161
    if (lease_time > 31536000U) {
#line 162
      goto usage;
    }
#line 163
    goto switch_break;
    case_80: /* CIL Label */ 
#line 165
    request_prefix_delegation = 1;
#line 166
    goto switch_break;
    case_99: /* CIL Label */ 
#line 168
    config_file = optarg;
#line 169
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 171
    rc = parse_config_from_string(optarg);
    }
#line 172
    if (rc < 0) {
      {
#line 173
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t parse configuration from command line.\n");
#line 175
      exit(1);
      }
    }
#line 177
    goto switch_break;
    case_68: /* CIL Label */ 
#line 179
    do_daemonise = 1;
#line 180
    goto switch_break;
    case_76: /* CIL Label */ 
#line 182
    logfile = optarg;
#line 183
    goto switch_break;
    case_73: /* CIL Label */ 
#line 185
    pidfile = optarg;
#line 186
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 188
    goto usage;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 192
  if (optind >= argc) {
#line 193
    goto usage;
  }
#line 195
  if (config_file) {
    {
#line 196
    rc = parse_config_from_file(config_file);
    }
#line 197
    if (rc < 0) {
      {
#line 198
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t parse configuration from file %s.\n",
              config_file);
#line 201
      exit(1);
      }
    }
  }
#line 205
  i = optind;
  {
#line 205
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 205
    if (! (i < argc)) {
#line 205
      goto while_break___1;
    }
#line 206
    if (i - optind >= 20) {
      {
#line 207
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many interfaces.\n");
#line 208
      exit(1);
      }
    }
#line 210
    interfaces[i - optind] = *(argv + i);
#line 205
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 212
  numnetworks = i - optind;
#line 213
  interfaces[i - optind] = (char *)((void *)0);
#line 215
  rc = inet_pton(10, (char const   */* __restrict  */)multicast, (void */* __restrict  */)(& protocol_group));
  }
#line 216
  if (rc <= 0) {
#line 217
    goto usage;
  }
  {
#line 219
  time_init();
  }
#line 221
  if (do_daemonise) {
#line 222
    if ((unsigned long )logfile == (unsigned long )((void *)0)) {
#line 223
      logfile = (char *)"/var/log/ahcpd.log";
    }
  }
  {
#line 226
  rc = reopen_logfile();
  }
#line 227
  if (rc < 0) {
    {
#line 228
    perror("reopen_logfile()");
#line 229
    exit(1);
    }
  }
  {
#line 232
  fd = open("/dev/null", 0);
  }
#line 233
  if (fd < 0) {
    {
#line 234
    perror("open(null)");
#line 235
    exit(1);
    }
  }
  {
#line 238
  rc = dup2(fd, 0);
  }
#line 239
  if (rc < 0) {
    {
#line 240
    perror("dup2(null, 0)");
#line 241
    exit(1);
    }
  }
  {
#line 244
  close(fd);
  }
#line 246
  if (do_daemonise) {
    {
#line 247
    rc = daemonise();
    }
#line 248
    if (rc < 0) {
      {
#line 249
      perror("daemonise");
#line 250
      exit(1);
      }
    }
  }
#line 254
  if (pidfile) {
    {
#line 258
    tmp___2 = getpid();
#line 258
    len = snprintf((char */* __restrict  */)(buf___0), (size_t )100, (char const   */* __restrict  */)"%lu",
                   (unsigned long )tmp___2);
    }
#line 259
    if (len < 0) {
      {
#line 260
      perror("snprintf(getpid)");
#line 261
      exit(1);
      }
    } else
#line 259
    if (len >= 100) {
      {
#line 260
      perror("snprintf(getpid)");
#line 261
      exit(1);
      }
    }
    {
#line 264
    pfd = open((char const   *)pidfile, 193, 420);
    }
#line 265
    if (pfd < 0) {
      {
#line 266
      perror("creat(pidfile)");
#line 267
      exit(1);
      }
    }
    {
#line 270
    tmp___3 = write(pfd, (void const   *)(buf___0), (size_t )len);
#line 270
    rc = (int )tmp___3;
    }
#line 271
    if (rc < len) {
      {
#line 272
      perror("write(pidfile)");
      }
#line 273
      goto fail;
    }
    {
#line 276
    close(pfd);
    }
  }
  {
#line 279
  gettime(& now, (time_t *)((void *)0));
#line 281
  fd = open("/dev/urandom", 0);
  }
#line 282
  if (fd < 0) {
    {
#line 284
    perror("open(random)");
#line 285
    get_real_time(& tv, (int *)((void *)0));
#line 286
    seed = (unsigned int )(tv.tv_sec ^ tv.tv_usec);
    }
  } else {
    {
#line 288
    tmp___4 = read(fd, (void *)(& seed), sizeof(unsigned int ));
#line 288
    rc = (int )tmp___4;
    }
#line 289
    if ((unsigned long )rc < sizeof(unsigned int )) {
      {
#line 290
      perror("read(random)");
      }
#line 291
      goto fail;
    }
    {
#line 293
    close(fd);
    }
  }
  {
#line 295
  srandom(seed);
#line 297
  tmp___5 = random();
#line 297
  myseqno = (unsigned int )tmp___5;
  }
#line 299
  if (unique_id_file) {
#line 299
    if ((int )*(unique_id_file + 0) != 0) {
      {
#line 300
      fd = open((char const   *)unique_id_file, 0);
      }
#line 301
      if (fd >= 0) {
        {
#line 302
        tmp___6 = read(fd, (void *)(myid), (size_t )8);
#line 302
        rc = (int )tmp___6;
        }
#line 303
        if (rc == 8) {
          {
#line 304
          close(fd);
          }
#line 305
          goto unique_id_done;
        }
        {
#line 307
        close(fd);
        }
      }
    }
  }
#line 311
  i = 0;
  {
#line 311
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 311
    if (! (i < numnetworks)) {
#line 311
      goto while_break___2;
    }
    {
#line 312
    rc = if_eui64(interfaces[i], myid);
    }
#line 313
    if (rc >= 0) {
#line 314
      goto write_unique_id;
    }
#line 311
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 317
  rc = random_eui64(myid);
  }
#line 318
  if (rc < 0) {
    {
#line 319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t generate unique id.\n");
    }
#line 320
    goto fail;
  }
  write_unique_id: 
#line 324
  if (unique_id_file) {
#line 324
    if ((int )*(unique_id_file + 0) != 0) {
      {
#line 325
      fd = open((char const   *)unique_id_file, 577, 420);
      }
#line 326
      if (fd < 0) {
        {
#line 327
        perror("creat(unique_id)");
        }
      } else {
        {
#line 329
        tmp___7 = write(fd, (void const   *)(myid), (size_t )8);
#line 329
        rc = (int )tmp___7;
        }
#line 330
        if (rc != 8) {
          {
#line 331
          perror("write(unique_id)");
#line 332
          unlink((char const   *)unique_id_file);
          }
        }
        {
#line 334
        close(fd);
        }
      }
    }
  }
  unique_id_done: 
#line 340
  if (server_config) {
#line 342
    if ((int )server_config->lease_first[0] != 0) {
#line 343
      if ((unsigned long )server_config->lease_dir == (unsigned long )((void *)0)) {
        {
#line 344
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No lease directory configured!\n");
        }
#line 345
        goto fail;
      }
      {
#line 347
      rc = lease_init(server_config->lease_dir, (unsigned char const   *)(server_config->lease_first),
                      (unsigned char const   *)(server_config->lease_last), debug >= 2);
      }
#line 351
      if (rc < 0) {
        {
#line 352
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t initialise lease database.\n");
        }
#line 353
        goto fail;
      }
    }
  }
  {
#line 361
  protocol_socket = ahcp_socket((int )protocol_port);
  }
#line 362
  if (protocol_socket < 0) {
    {
#line 363
    perror("ahcp_socket");
    }
#line 364
    goto fail;
  }
#line 367
  i = 0;
  {
#line 367
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 367
    if (! (i < numnetworks)) {
#line 367
      goto while_break___3;
    }
    {
#line 368
    networks[i].ifname = interfaces[i];
#line 369
    check_network(& networks[i]);
    }
#line 370
    if (networks[i].ifindex <= 0) {
      {
#line 371
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: unknown interface %s.\n",
              networks[i].ifname);
      }
#line 373
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 367
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 377
  init_signals();
#line 378
  set_timeout(1, 30000, 1);
  }
#line 393
  if (client_config) {
#line 394
    server_hopcount = 0;
    {
#line 395
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 395
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 395
        tmp___8 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 395
        if (tmp___8) {
          {
#line 395
          do_debugf(2, "Switching to state %d.\n", 1);
          }
        }
#line 395
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 395
      state = (enum state )1;
#line 395
      if ((unsigned int )state == 0U) {
        {
#line 395
        set_timeout(2, 0, 1);
        }
      } else
#line 395
      if ((unsigned int )state == 5U) {
        {
#line 395
        set_timeout(2, 0, 1);
        }
      } else {
        {
#line 395
        set_timeout(2, 300, 1);
        }
      }
#line 395
      count = 0;
#line 395
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 398
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 398
    tmp___9 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
    }
#line 398
    if (tmp___9) {
      {
#line 398
      do_debugf(2, "Entering main loop.\n");
      }
    }
#line 398
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 400
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 404
    if ((unsigned int )state == 5U) {
#line 404
      tmp___10 = 1;
    } else
#line 404
    if ((unsigned int )state == 3U) {
#line 404
      tmp___10 = 1;
    } else
#line 404
    if ((unsigned int )state == 4U) {
#line 404
      tmp___10 = 1;
    } else {
#line 404
      tmp___10 = 0;
    }
#line 404
    if (! (((unsigned long )config_data != (unsigned long )((void *)0)) == tmp___10)) {
      {
#line 404
      __assert_fail("(config_data != ((void *)0)) == (state == STATE_BOUND || state == STATE_RENEWING_UNICAST || state == STATE_RENEWING)",
                    "/home/june/collector/temp/ahcpd-0.53/ahcpd.c", 406U, "main");
      }
    }
    {
#line 408
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 408
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 408
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 410
    tv___0 = check_networks_time;
#line 411
    timeval_min(& tv___0, (struct timeval  const  *)(& message_time));
    }
#line 412
    if (config_data) {
      {
#line 413
      timeval_min_sec(& tv___0, (int )config_data->expires_m);
      }
#line 414
      if ((unsigned int )state == 5U) {
        {
#line 415
        tmp___11 = config_renew_time();
#line 415
        timeval_min_sec(& tv___0, (int )tmp___11);
        }
      }
    }
    {
#line 418
    gettime(& now, (time_t *)((void *)0));
#line 420
    tmp___14 = timeval_compare((struct timeval  const  *)(& tv___0), (struct timeval  const  *)(& now));
    }
#line 420
    if (tmp___14 > 0) {
      {
#line 421
      timeval_minus(& tv___0, (struct timeval  const  *)(& tv___0), (struct timeval  const  *)(& now));
#line 423
      readfds.__fds_bits[protocol_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << protocol_socket % (8 * (int )sizeof(__fd_mask ));
      }
      {
#line 424
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 424
        tmp___12 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
        }
#line 424
        if (tmp___12) {
          {
#line 424
          do_debugf(3, "Sleeping for %d.%03ds, state=%d.\n", (int )tv___0.tv_sec,
                    (int )(tv___0.tv_usec / 1000L), (int )state);
          }
        }
#line 424
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 426
      rc = select(protocol_socket + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                  (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv___0));
      }
#line 427
      if (rc < 0) {
        {
#line 427
        tmp___13 = __errno_location();
        }
#line 427
        if (*tmp___13 != 4) {
          {
#line 428
          perror("select");
#line 429
          sleep(5U);
          }
#line 430
          goto while_continue___7;
        }
      }
    }
    {
#line 434
    gettime(& now, (time_t *)((void *)0));
    }
#line 436
    if (exiting) {
#line 437
      goto while_break___7;
    }
#line 439
    if (dumping) {
      {
#line 443
      dumping = (int volatile   )0;
#line 444
      get_real_time(& real, & clock_status___0);
#line 445
      gettime(& tv___1, & stable);
#line 446
      printf((char const   */* __restrict  */)"Clock status %d, stable for at least %ld seconds.\n",
             clock_status___0, stable);
#line 448
      printf((char const   */* __restrict  */)"Forwarder forwarding.\n");
      }
#line 449
      if (server_config) {
        {
#line 450
        printf((char const   */* __restrict  */)"Server serving.\n");
        }
      }
#line 451
      if (client_config) {
        {
#line 452
        printf((char const   */* __restrict  */)"Client in state %d, ", (int )state);
#line 453
        tmp___15 = memcmp((void const   *)(selected_server), (void const   *)(zeroes),
                          (size_t )8);
        }
#line 453
        if (tmp___15 != 0) {
          {
#line 454
          printf((char const   */* __restrict  */)"server selected, ");
          }
        }
#line 455
        if (config_data) {
          {
#line 456
          printf((char const   */* __restrict  */)"configuration valid for %lds (originally %lds since %lds).",
                 (long )config_data->expires_m - now.tv_sec, (long )config_data->expires,
                 (long )config_data->origin);
          }
        } else {
          {
#line 462
          printf((char const   */* __restrict  */)"not configured.\n");
          }
        }
      }
      {
#line 465
      printf((char const   */* __restrict  */)"\n");
#line 466
      fflush(stdout);
      }
    }
#line 469
    if (changed) {
#line 470
      changed = (int volatile   )0;
#line 471
      i = 0;
      {
#line 471
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 471
        if (! (i < numnetworks)) {
#line 471
          goto while_break___10;
        }
        {
#line 472
        check_network(& networks[i]);
#line 471
        i ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 473
      set_timeout(1, 30000, 1);
#line 474
      rc = reopen_logfile();
      }
#line 475
      if (rc < 0) {
        {
#line 476
        perror("reopen_logfile");
        }
#line 477
        goto fail;
      }
    }
#line 481
    if ((readfds.__fds_bits[protocol_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << protocol_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 487
      len___0 = ahcp_recv(protocol_socket, (void *)(buf___1), 2048, (struct sockaddr *)(& sin6),
                          (int )sizeof(sin6));
      }
#line 489
      if (len___0 < 0) {
        {
#line 490
        tmp___16 = __errno_location();
        }
#line 490
        if (*tmp___16 != 11) {
          {
#line 490
          tmp___17 = __errno_location();
          }
#line 490
          if (*tmp___17 != 4) {
            {
#line 491
            perror("recv");
#line 492
            sleep(5U);
            }
          }
        }
#line 494
        goto while_continue___7;
      }
      {
#line 497
      psin = (struct sockaddr *)(& sin6);
#line 498
      sinlen = (int )sizeof(sin6);
#line 500
      __a = (struct in6_addr  const  *)(& sin6.sin6_addr);
#line 500
      tmp___18 = htonl(4290772992U);
#line 500
      tmp___19 = htonl(4269801472U);
      }
#line 500
      if ((__a->__in6_u.__u6_addr32[0] & tmp___18) == tmp___19) {
#line 501
        net = 0;
        {
#line 501
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 501
          if (! (net < numnetworks)) {
#line 501
            goto while_break___11;
          }
#line 502
          if (networks[net].ifindex <= 0) {
#line 503
            goto __Cont___0;
          }
#line 504
          if ((uint32_t )networks[net].ifindex == sin6.sin6_scope_id) {
#line 505
            goto while_break___11;
          }
          __Cont___0: /* CIL Label */ 
#line 501
          net ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 507
        if (net >= numnetworks) {
          {
#line 508
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received packet on unknown network.\n");
          }
#line 509
          goto while_continue___7;
        }
      } else {
#line 512
        net = -1;
      }
      {
#line 515
      rc = handle_packet(net >= 0, (unsigned char const   *)(buf___1), (size_t )len___0);
#line 516
      gettime(& now, (time_t *)((void *)0));
      }
#line 517
      if (rc == 2) {
#line 518
        body = buf___1 + 24;
#line 519
        bodylen = len___0 - 24;
#line 521
        if (len___0 < 28) {
          {
#line 522
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received truncated packet (%d).\n",
                  rc);
          }
#line 523
          goto while_continue___7;
        }
        {
#line 526
        while (1) {
          while_continue___12: /* CIL Label */ ;
          {
#line 526
          tmp___20 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
          }
#line 526
          if (tmp___20) {
            {
#line 526
            do_debugf(2, "Received packet %d in state %d.\n", (int )*(body + 0), (int )state);
            }
          }
#line 526
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 530
        if ((unsigned int )state == 0U) {
#line 530
          goto case_0;
        }
#line 532
        if ((unsigned int )state == 1U) {
#line 532
          goto case_1;
        }
#line 552
        if ((unsigned int )state == 3U) {
#line 552
          goto case_3;
        }
#line 552
        if ((unsigned int )state == 4U) {
#line 552
          goto case_3;
        }
#line 552
        if ((unsigned int )state == 2U) {
#line 552
          goto case_3;
        }
#line 585
        if ((unsigned int )state == 5U) {
#line 585
          goto case_5;
        }
#line 587
        goto switch_default___0;
        case_0: /* CIL Label */ 
#line 531
        goto switch_break___0;
        case_1: /* CIL Label */ 
#line 533
        if ((int )*(body + 0) == 1) {
          {
#line 535
          config = parse_message(0, (unsigned char const   *)body, bodylen, interfaces);
          }
#line 536
          if (config) {
#line 536
            if (af & 1) {
#line 536
              if (config->ipv4_address) {
#line 536
                goto _L;
              } else {
#line 536
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 536
            if (af & 2) {
#line 536
              if (config->ipv6_prefix) {
                _L: /* CIL Label */ 
#line 539
                if (af & 1) {
#line 539
                  if (config->ipv4_address) {
                    {
#line 540
                    prefix_list_extract4(last_ipv4, config->ipv4_address);
                    }
                  }
                }
                {
#line 542
                server_hopcount = (int )buf___1[3];
#line 543
                memcpy((void */* __restrict  */)(selected_server), (void const   */* __restrict  */)(buf___1 + 8),
                       (size_t )8);
                }
                {
#line 544
                while (1) {
                  while_continue___13: /* CIL Label */ ;
                  {
#line 544
                  while (1) {
                    while_continue___14: /* CIL Label */ ;
                    {
#line 544
                    tmp___21 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
                    }
#line 544
                    if (tmp___21) {
                      {
#line 544
                      do_debugf(2, "Switching to state %d.\n", 2);
                      }
                    }
#line 544
                    goto while_break___14;
                  }
                  while_break___14: /* CIL Label */ ;
                  }
#line 544
                  state = (enum state )2;
#line 544
                  if ((unsigned int )state == 0U) {
                    {
#line 544
                    set_timeout(2, 0, 1);
                    }
                  } else
#line 544
                  if ((unsigned int )state == 5U) {
                    {
#line 544
                    set_timeout(2, 0, 1);
                    }
                  } else {
                    {
#line 544
                    set_timeout(2, 300, 1);
                    }
                  }
#line 544
                  count = 0;
#line 544
                  goto while_break___13;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
            }
          }
#line 546
          if (config) {
            {
#line 547
            free_config_data(config);
            }
          }
        }
#line 549
        goto switch_break___0;
        case_3: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_2: /* CIL Label */ 
#line 553
        if ((int )*(body + 0) == 3) {
          {
#line 553
          tmp___26 = memcmp((void const   *)(buf___1 + 8), (void const   *)(selected_server),
                            (size_t )8);
          }
#line 553
          if (tmp___26 == 0) {
            {
#line 556
            config___0 = parse_message(1, (unsigned char const   *)body, bodylen,
                                       interfaces);
            }
#line 557
            if (! config_data) {
              {
#line 561
              server_hopcount = 0;
#line 562
              memset((void *)(selected_server), 0, (size_t )8);
              }
              {
#line 563
              while (1) {
                while_continue___15: /* CIL Label */ ;
                {
#line 563
                while (1) {
                  while_continue___16: /* CIL Label */ ;
                  {
#line 563
                  tmp___22 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
                  }
#line 563
                  if (tmp___22) {
                    {
#line 563
                    do_debugf(2, "Switching to state %d.\n", 1);
                    }
                  }
#line 563
                  goto while_break___16;
                }
                while_break___16: /* CIL Label */ ;
                }
#line 563
                state = (enum state )1;
#line 563
                if ((unsigned int )state == 0U) {
                  {
#line 563
                  set_timeout(2, 0, 1);
                  }
                } else
#line 563
                if ((unsigned int )state == 5U) {
                  {
#line 563
                  set_timeout(2, 0, 1);
                  }
                } else {
                  {
#line 563
                  set_timeout(2, 300, 1);
                  }
                }
#line 563
                count = 0;
#line 563
                goto while_break___15;
              }
              while_break___15: /* CIL Label */ ;
              }
              {
#line 564
              set_timeout(2, 30000, 1);
              }
            } else
#line 565
            if (config___0) {
#line 566
              if (af & 1) {
#line 566
                if (config___0->ipv4_address) {
                  {
#line 567
                  prefix_list_extract4(last_ipv4, config___0->ipv4_address);
                  }
                }
              }
              {
#line 569
              server_hopcount = (int )buf___1[3];
#line 570
              free_config_data(config___0);
              }
              {
#line 571
              while (1) {
                while_continue___17: /* CIL Label */ ;
                {
#line 571
                while (1) {
                  while_continue___18: /* CIL Label */ ;
                  {
#line 571
                  tmp___23 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
                  }
#line 571
                  if (tmp___23) {
                    {
#line 571
                    do_debugf(2, "Switching to state %d.\n", 5);
                    }
                  }
#line 571
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
#line 571
                state = (enum state )5;
#line 571
                if ((unsigned int )state == 0U) {
                  {
#line 571
                  set_timeout(2, 0, 1);
                  }
                } else
#line 571
                if ((unsigned int )state == 5U) {
                  {
#line 571
                  set_timeout(2, 0, 1);
                  }
                } else {
                  {
#line 571
                  set_timeout(2, 300, 1);
                  }
                }
#line 571
                count = 0;
#line 571
                goto while_break___17;
              }
              while_break___17: /* CIL Label */ ;
              }
            } else {
              {
#line 573
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Eek!  Configured, but config null.\n");
              }
            }
          } else {
#line 553
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 576
        if ((int )*(body + 0) == 4) {
          {
#line 576
          tmp___25 = memcmp((void const   *)(buf___1 + 8), (void const   *)(selected_server),
                            (size_t )8);
          }
#line 576
          if (tmp___25 == 0) {
#line 578
            if (config_data) {
              {
#line 579
              unconfigure(interfaces);
              }
            }
            {
#line 580
            server_hopcount = 0;
#line 581
            memset((void *)(selected_server), 0, (size_t )8);
            }
            {
#line 582
            while (1) {
              while_continue___19: /* CIL Label */ ;
              {
#line 582
              while (1) {
                while_continue___20: /* CIL Label */ ;
                {
#line 582
                tmp___24 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
                }
#line 582
                if (tmp___24) {
                  {
#line 582
                  do_debugf(2, "Switching to state %d.\n", 1);
                  }
                }
#line 582
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 582
              state = (enum state )1;
#line 582
              if ((unsigned int )state == 0U) {
                {
#line 582
                set_timeout(2, 0, 1);
                }
              } else
#line 582
              if ((unsigned int )state == 5U) {
                {
#line 582
                set_timeout(2, 0, 1);
                }
              } else {
                {
#line 582
                set_timeout(2, 300, 1);
                }
              }
#line 582
              count = 0;
#line 582
              goto while_break___19;
            }
            while_break___19: /* CIL Label */ ;
            }
          }
        }
#line 584
        goto switch_break___0;
        case_5: /* CIL Label */ 
#line 586
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 588
        abort();
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 592
        if (server_config) {
#line 593
          if ((int )*(body + 0) == 0) {
#line 593
            goto _L___4;
          } else
#line 593
          if ((int )*(body + 0) == 2) {
#line 593
            goto _L___4;
          } else
#line 593
          if ((int )*(body + 0) == 5) {
            _L___4: /* CIL Label */ 
#line 600
            ipv4[0] = (unsigned char)0;
#line 600
            tmp___27 = 1U;
            {
#line 600
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 600
              if (tmp___27 >= 4U) {
#line 600
                goto while_break___21;
              }
#line 600
              ipv4[tmp___27] = (unsigned char)0;
#line 600
              tmp___27 ++;
            }
            while_break___21: /* CIL Label */ ;
            }
            {
#line 602
            config___1 = parse_message(-1, (unsigned char const   *)body, bodylen,
                                       interfaces);
            }
#line 603
            if (! config___1) {
              {
#line 604
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparseable client message.\n");
              }
#line 605
              goto while_continue___7;
            }
#line 608
            hopcount = (int )buf___1[3];
#line 609
            if (config___1->ipv4_address) {
              {
#line 610
              prefix_list_extract4(ipv4, config___1->ipv4_address);
              }
            }
#line 611
            if (config___1->expires) {
              {
#line 611
              tmp___28 = roughly(120U);
#line 611
              client_lease_time = config___1->expires + tmp___28;
              }
            } else {
              {
#line 611
              tmp___29 = roughly(120U);
#line 611
              client_lease_time = 14400U + tmp___29;
              }
            }
            {
#line 616
            free_config_data(config___1);
            }
#line 618
            if ((int )*(body + 0) == 5) {
              {
#line 619
              tmp___30 = memcmp((void const   *)(ipv4), (void const   *)(zeroes),
                                (size_t )4);
              }
#line 619
              if (tmp___30 != 0) {
                {
#line 620
                rc = release_lease((unsigned char const   *)(buf___1 + 8), 8, (unsigned char const   *)(ipv4));
                }
#line 621
                if (rc < 0) {
                  {
#line 623
                  inet_ntop(2, (void const   */* __restrict  */)(ipv4), (char */* __restrict  */)(a),
                            (socklen_t )16);
#line 625
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t release lease for %s.\n",
                          a);
                  }
                }
              }
#line 630
              goto while_continue___7;
            }
#line 633
            if (config___1->ipv4_mandatory) {
#line 633
              if (! server_config->lease_first[0]) {
#line 641
                rc = -1;
              } else {
#line 633
                goto _L___3;
              }
            } else
            _L___3: /* CIL Label */ 
#line 633
            if (config___1->ipv6_mandatory) {
#line 633
              if (! server_config->ipv6_prefix) {
#line 641
                rc = -1;
              } else {
#line 633
                goto _L___2;
              }
            } else
            _L___2: /* CIL Label */ 
#line 633
            if (config___1->ipv4_delegation_mandatory) {
#line 641
              rc = -1;
            } else
#line 633
            if (config___1->ipv6_delegation_mandatory) {
#line 641
              rc = -1;
            } else
#line 642
            if (server_config->lease_first[0]) {
#line 642
              if (config___1->ipv4_address) {
                {
#line 644
                tmp___33 = memcmp((void const   *)(ipv4), (void const   *)(zeroes),
                                  (size_t )4);
                }
#line 644
                if (tmp___33 == 0) {
#line 644
                  tmp___32 = ipv4;
                } else {
#line 644
                  tmp___32 = (unsigned char *)((void *)0);
                }
                {
#line 644
                rc = take_lease((unsigned char const   *)(buf___1 + 8), 8, (unsigned char const   *)tmp___32,
                                ipv4, & client_lease_time, (int )*(body + 0) == 2);
                }
              } else {
#line 650
                rc = 0;
              }
            } else {
#line 650
              rc = 0;
            }
#line 656
            if (rc < 0) {
#line 656
              if ((int )*(body + 0) == 0) {
#line 657
                goto while_continue___7;
              }
            }
            {
#line 659
            config___1 = make_config_data((int )client_lease_time, ipv4, server_config,
                                          interfaces);
            }
#line 663
            if ((unsigned long )config___1 == (unsigned long )((void *)0)) {
              {
#line 664
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t build config data.\n");
              }
#line 665
              goto while_continue___7;
            }
#line 668
            if (rc < 0) {
#line 668
              tmp___35 = 4;
            } else {
#line 668
              if ((int )*(body + 0) == 0) {
#line 668
                tmp___34 = 1;
              } else {
#line 668
                tmp___34 = 3;
              }
#line 668
              tmp___35 = tmp___34;
            }
            {
#line 668
            rc = server_body((unsigned char )tmp___35, config___1, reply, 2048);
            }
#line 672
            if (rc < 0) {
              {
#line 673
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t build reply.\n");
              }
            } else {
              {
#line 675
              while (1) {
                while_continue___22: /* CIL Label */ ;
                {
#line 675
                tmp___36 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
                }
#line 675
                if (tmp___36) {
                  {
#line 675
                  do_debugf(2, "Sending %d (%d bytes, %d hops).\n", (int )reply[0],
                            rc, hopcount);
                  }
                }
#line 675
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
              {
#line 677
              tmp___37 = roughly(50000U);
#line 677
              usleep(tmp___37);
#line 678
              send_packet(psin, sinlen, (unsigned char const   *)(buf___1 + 8), hopcount,
                          (unsigned char const   *)(reply), (size_t )rc);
#line 680
              gettime(& now, (time_t *)((void *)0));
              }
            }
            {
#line 683
            free_config_data(config___1);
            }
          }
        }
      }
    }
#line 691
    if (config_data) {
#line 692
      if (now.tv_sec >= (__time_t )config_data->expires_m) {
        {
#line 693
        unconfigure(interfaces);
#line 694
        server_hopcount = 0;
        }
        {
#line 695
        while (1) {
          while_continue___23: /* CIL Label */ ;
          {
#line 695
          while (1) {
            while_continue___24: /* CIL Label */ ;
            {
#line 695
            tmp___38 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
            }
#line 695
            if (tmp___38) {
              {
#line 695
              do_debugf(2, "Switching to state %d.\n", 1);
              }
            }
#line 695
            goto while_break___24;
          }
          while_break___24: /* CIL Label */ ;
          }
#line 695
          state = (enum state )1;
#line 695
          if ((unsigned int )state == 0U) {
            {
#line 695
            set_timeout(2, 0, 1);
            }
          } else
#line 695
          if ((unsigned int )state == 5U) {
            {
#line 695
            set_timeout(2, 0, 1);
            }
          } else {
            {
#line 695
            set_timeout(2, 300, 1);
            }
          }
#line 695
          count = 0;
#line 695
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
    }
#line 699
    if ((unsigned int )state == 5U) {
      {
#line 700
      tmp___40 = config_renew_time();
      }
#line 700
      if (now.tv_sec >= (__time_t )tmp___40) {
        {
#line 701
        while (1) {
          while_continue___25: /* CIL Label */ ;
          {
#line 701
          while (1) {
            while_continue___26: /* CIL Label */ ;
            {
#line 701
            tmp___39 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
            }
#line 701
            if (tmp___39) {
              {
#line 701
              do_debugf(2, "Switching to state %d.\n", 3);
              }
            }
#line 701
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
#line 701
          state = (enum state )3;
#line 701
          if ((unsigned int )state == 0U) {
            {
#line 701
            set_timeout(2, 0, 1);
            }
          } else
#line 701
          if ((unsigned int )state == 5U) {
            {
#line 701
            set_timeout(2, 0, 1);
            }
          } else {
            {
#line 701
            set_timeout(2, 300, 1);
            }
          }
#line 701
          count = 0;
#line 701
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
      }
    }
#line 704
    if (message_time.tv_sec > 0L) {
#line 704
      if (now.tv_sec >= message_time.tv_sec) {
        {
#line 708
        if ((unsigned int )state == 0U) {
#line 708
          goto case_0___0;
        }
#line 712
        if ((unsigned int )state == 1U) {
#line 712
          goto case_1___0;
        }
#line 727
        if ((unsigned int )state == 4U) {
#line 727
          goto case_4___0;
        }
#line 731
        if ((unsigned int )state == 3U) {
#line 731
          goto case_3___0;
        }
#line 731
        if ((unsigned int )state == 2U) {
#line 731
          goto case_3___0;
        }
#line 772
        if ((unsigned int )state == 5U) {
#line 772
          goto case_5___0;
        }
#line 776
        goto switch_default___1;
        case_0___0: /* CIL Label */ 
        {
#line 709
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempted to send message in IDLE state.\n");
#line 710
        set_timeout(2, 0, 1);
        }
#line 711
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
        {
#line 713
        server_hopcount ++;
#line 714
        tmp___43 = memcmp((void const   *)(last_ipv4), (void const   *)(zeroes), (size_t )4);
        }
#line 714
        if (tmp___43) {
#line 714
          tmp___42 = (unsigned char *)((void *)0);
        } else {
#line 714
          tmp___42 = last_ipv4;
        }
        {
#line 714
        tmp___44 = roughly(120U);
#line 714
        i___0 = query_body((unsigned char)0, (int )(lease_time + tmp___44), (unsigned char const   *)tmp___42,
                           buf___2, 2048);
        }
#line 717
        if (i___0 >= 0) {
          {
#line 718
          while (1) {
            while_continue___27: /* CIL Label */ ;
            {
#line 718
            tmp___45 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
            }
#line 718
            if (tmp___45) {
              {
#line 718
              do_debugf(2, "Sending %d (%d bytes, %d hops).\n", (int )buf___2[0],
                        i___0, server_hopcount);
              }
            }
#line 718
            goto while_break___27;
          }
          while_break___27: /* CIL Label */ ;
          }
          {
#line 720
          send_packet((struct sockaddr *)((void *)0), 0, (unsigned char const   *)((void *)0),
                      server_hopcount, (unsigned char const   *)(buf___2), (size_t )i___0);
          }
        } else {
          {
#line 722
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t build body.\n");
          }
        }
        {
#line 724
        count ++;
#line 725
        set_timeout(2, 1000 * count, 1);
        }
#line 726
        goto switch_break___1;
        case_4___0: /* CIL Label */ 
#line 728
        server_hopcount ++;
        case_3___0: /* CIL Label */ 
        case_2___0: /* CIL Label */ 
        {
#line 732
        tmp___48 = memcmp((void const   *)(last_ipv4), (void const   *)(zeroes), (size_t )4);
        }
#line 732
        if (tmp___48) {
#line 732
          tmp___47 = (unsigned char *)((void *)0);
        } else {
#line 732
          tmp___47 = last_ipv4;
        }
        {
#line 732
        tmp___49 = roughly(120U);
#line 732
        i___0 = query_body((unsigned char)2, (int )(lease_time + tmp___49), (unsigned char const   *)tmp___47,
                           buf___2, 2048);
        }
#line 735
        if (i___0 < 0) {
          {
#line 736
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t build body.\n");
          }
#line 737
          goto switch_break___1;
        }
#line 739
        if ((unsigned int )state == 2U) {
#line 739
          if (count > 7) {
            {
#line 740
            while (1) {
              while_continue___28: /* CIL Label */ ;
              {
#line 740
              tmp___50 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
              }
#line 740
              if (tmp___50) {
                {
#line 740
                do_debugf(2, "Giving up on request.\n");
                }
              }
#line 740
              goto while_break___28;
            }
            while_break___28: /* CIL Label */ ;
            }
            {
#line 741
            server_hopcount = 0;
#line 742
            memset((void *)(selected_server), 0, (size_t )8);
            }
            {
#line 743
            while (1) {
              while_continue___29: /* CIL Label */ ;
              {
#line 743
              while (1) {
                while_continue___30: /* CIL Label */ ;
                {
#line 743
                tmp___51 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
                }
#line 743
                if (tmp___51) {
                  {
#line 743
                  do_debugf(2, "Switching to state %d.\n", 1);
                  }
                }
#line 743
                goto while_break___30;
              }
              while_break___30: /* CIL Label */ ;
              }
#line 743
              state = (enum state )1;
#line 743
              if ((unsigned int )state == 0U) {
                {
#line 743
                set_timeout(2, 0, 1);
                }
              } else
#line 743
              if ((unsigned int )state == 5U) {
                {
#line 743
                set_timeout(2, 0, 1);
                }
              } else {
                {
#line 743
                set_timeout(2, 300, 1);
                }
              }
#line 743
              count = 0;
#line 743
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
          } else {
#line 739
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 744
        if ((unsigned int )state == 3U) {
          {
#line 745
          while (1) {
            while_continue___31: /* CIL Label */ ;
            {
#line 745
            tmp___52 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
            }
#line 745
            if (tmp___52) {
              {
#line 745
              do_debugf(2, "Sending %d (%d bytes, unicast)\n", (int )buf___2[0], i___0);
              }
            }
#line 745
            goto while_break___31;
          }
          while_break___31: /* CIL Label */ ;
          }
          {
#line 747
          rc = send_unicast_packet(selected_server, config_data, count / 3, (void *)(buf___2),
                                   i___0);
          }
#line 750
          if (rc == 0) {
            {
#line 751
            while (1) {
              while_continue___32: /* CIL Label */ ;
              {
#line 751
              while (1) {
                while_continue___33: /* CIL Label */ ;
                {
#line 751
                tmp___53 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
                }
#line 751
                if (tmp___53) {
                  {
#line 751
                  do_debugf(2, "Switching to state %d.\n", 4);
                  }
                }
#line 751
                goto while_break___33;
              }
              while_break___33: /* CIL Label */ ;
              }
#line 751
              state = (enum state )4;
#line 751
              if ((unsigned int )state == 0U) {
                {
#line 751
                set_timeout(2, 0, 1);
                }
              } else
#line 751
              if ((unsigned int )state == 5U) {
                {
#line 751
                set_timeout(2, 0, 1);
                }
              } else {
                {
#line 751
                set_timeout(2, 300, 1);
                }
              }
#line 751
              count = 0;
#line 751
              goto while_break___32;
            }
            while_break___32: /* CIL Label */ ;
            }
          } else {
#line 755
            count ++;
#line 756
            if (rc < 0) {
#line 756
              tmp___54 = 300;
            } else {
#line 756
              tmp___54 = 10000;
            }
            {
#line 756
            set_timeout(2, tmp___54, 1);
            }
          }
        } else {
          {
#line 759
          while (1) {
            while_continue___34: /* CIL Label */ ;
            {
#line 759
            tmp___55 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
            }
#line 759
            if (tmp___55) {
              {
#line 759
              do_debugf(2, "Sending %d (%d bytes, %d hops).\n", (int )buf___2[0],
                        i___0, server_hopcount);
              }
            }
#line 759
            goto while_break___34;
          }
          while_break___34: /* CIL Label */ ;
          }
          {
#line 761
          send_packet((struct sockaddr *)((void *)0), 0, (unsigned char const   *)(selected_server),
                      server_hopcount, (unsigned char const   *)(buf___2), (size_t )i___0);
#line 763
          count ++;
          }
#line 767
          if ((unsigned int )state == 2U) {
#line 767
            tmp___56 = 2000 * count;
          } else {
#line 767
            tmp___56 = 10000 * count;
          }
          {
#line 767
          set_timeout(2, tmp___56, 1);
          }
        }
#line 771
        goto switch_break___1;
        case_5___0: /* CIL Label */ 
        {
#line 773
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempted to send message in BOUND state.\n");
#line 774
        set_timeout(2, 0, 1);
        }
#line 775
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
        {
#line 776
        abort();
        }
        switch_break___1: /* CIL Label */ ;
        }
      }
    }
#line 780
    if (check_networks_time.tv_sec > 0L) {
      {
#line 780
      tmp___57 = timeval_compare((struct timeval  const  *)(& check_networks_time),
                                 (struct timeval  const  *)(& now));
      }
#line 780
      if (tmp___57 <= 0) {
#line 782
        i = 0;
        {
#line 782
        while (1) {
          while_continue___35: /* CIL Label */ ;
#line 782
          if (! (i < numnetworks)) {
#line 782
            goto while_break___35;
          }
          {
#line 783
          check_network(& networks[i]);
#line 782
          i ++;
          }
        }
        while_break___35: /* CIL Label */ ;
        }
        {
#line 784
        set_timeout(1, 30000, 1);
        }
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 790
  if (config_data) {
    {
#line 793
    tmp___60 = memcmp((void const   *)(last_ipv4), (void const   *)(zeroes), (size_t )4);
    }
#line 793
    if (tmp___60) {
#line 793
      tmp___59 = (unsigned char *)((void *)0);
    } else {
#line 793
      tmp___59 = last_ipv4;
    }
    {
#line 793
    len___1 = query_body((unsigned char)5, 0, (unsigned char const   *)tmp___59, buf___3,
                         2048);
    }
#line 796
    if (len___1 >= 0) {
#line 797
      index___0 = 0;
#line 798
      success = 0;
      {
#line 799
      while (1) {
        while_continue___36: /* CIL Label */ ;
        {
#line 800
        while (1) {
          while_continue___37: /* CIL Label */ ;
          {
#line 800
          tmp___61 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
          }
#line 800
          if (tmp___61) {
            {
#line 800
            do_debugf(2, "Sending %d (%d bytes, unicast).\n", (int )buf___3[0], i);
            }
          }
#line 800
          goto while_break___37;
        }
        while_break___37: /* CIL Label */ ;
        }
        {
#line 801
        rc = send_unicast_packet(selected_server, config_data, index___0, (void *)(buf___3),
                                 len___1);
        }
#line 803
        if (rc > 0) {
#line 804
          success = 1;
#line 805
          goto while_break___36;
        } else
#line 806
        if (rc == 0) {
#line 807
          goto while_break___36;
        }
#line 809
        index___0 ++;
      }
      while_break___36: /* CIL Label */ ;
      }
#line 812
      if (! success) {
        {
#line 813
        while (1) {
          while_continue___38: /* CIL Label */ ;
          {
#line 813
          tmp___62 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
          }
#line 813
          if (tmp___62) {
            {
#line 813
            do_debugf(2, "Sending %d (%d bytes, %d hops).\n", (int )buf___3[0], i,
                      server_hopcount);
            }
          }
#line 813
          goto while_break___38;
        }
        while_break___38: /* CIL Label */ ;
        }
        {
#line 815
        send_packet((struct sockaddr *)((void *)0), 0, (unsigned char const   *)((void *)0),
                    server_hopcount + 2, (unsigned char const   *)(buf___3), (size_t )len___1);
        }
      }
    }
    {
#line 818
    unconfigure(interfaces);
    }
    {
#line 819
    while (1) {
      while_continue___39: /* CIL Label */ ;
      {
#line 819
      while (1) {
        while_continue___40: /* CIL Label */ ;
        {
#line 819
        tmp___63 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
        }
#line 819
        if (tmp___63) {
          {
#line 819
          do_debugf(2, "Switching to state %d.\n", 1);
          }
        }
#line 819
        goto while_break___40;
      }
      while_break___40: /* CIL Label */ ;
      }
#line 819
      state = (enum state )1;
#line 819
      if ((unsigned int )state == 0U) {
        {
#line 819
        set_timeout(2, 0, 1);
        }
      } else
#line 819
      if ((unsigned int )state == 5U) {
        {
#line 819
        set_timeout(2, 0, 1);
        }
      } else {
        {
#line 819
        set_timeout(2, 300, 1);
        }
      }
#line 819
      count = 0;
#line 819
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
  }
#line 822
  if (pidfile) {
    {
#line 823
    unlink((char const   *)pidfile);
    }
  }
#line 824
  return (0);
  usage: 
  {
#line 827
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Syntax: ahcpd [-m group] [-p port] [-n] [-4] [-6] [-N]\n              [-i file] [-s script] [-D] [-I pidfile] [-L logfile]\n              [-C statement] [-c filename]interface...\n");
#line 835
  exit(1);
  }
  fail: 
#line 838
  if (pidfile) {
    {
#line 839
    unlink((char const   *)pidfile);
    }
  }
  {
#line 840
  exit(1);
  }
}
}
#line 843 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
unsigned int roughly(unsigned int value ) 
{ 
  long tmp ;

  {
  {
#line 846
  tmp = random();
  }
#line 846
  return ((unsigned int )((long )((value * 3U) / 4U) + tmp % (long )(value / 4U)));
}
}
#line 849 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static void set_timeout(int which , int msecs , int override ) 
{ 
  struct timeval *tv ;
  int ms ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  long tmp___1 ;

  {
#line 853
  if (msecs == 0) {
#line 853
    tmp___0 = 0U;
  } else {
    {
#line 853
    tmp = roughly((unsigned int )msecs);
#line 853
    tmp___0 = tmp;
    }
  }
#line 853
  ms = (int )tmp___0;
  {
#line 855
  if (which == 2) {
#line 855
    goto case_2;
  }
#line 856
  if (which == 1) {
#line 856
    goto case_1;
  }
#line 857
  goto switch_default;
  case_2: /* CIL Label */ 
#line 855
  tv = & message_time;
#line 855
  goto switch_break;
  case_1: /* CIL Label */ 
#line 856
  tv = & check_networks_time;
#line 856
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 857
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 861
  if (override) {
#line 861
    goto _L;
  } else
#line 861
  if (tv->tv_sec == 0L) {
#line 861
    goto _L;
  } else
#line 861
  if (tv->tv_sec > now.tv_sec + (__time_t )(ms / 1000)) {
    _L: /* CIL Label */ 
#line 862
    if (msecs <= 0) {
#line 863
      tv->tv_usec = (__suseconds_t )0;
#line 864
      tv->tv_sec = (__time_t )0;
    } else {
      {
#line 866
      tmp___1 = random();
#line 866
      tv->tv_usec = (now.tv_usec + (__suseconds_t )(ms * 1000)) % 1000000L + tmp___1 % 1000L;
#line 868
      tv->tv_sec = now.tv_sec + (now.tv_usec / 1000L + (__suseconds_t )ms) / 1000L;
      }
    }
  }
#line 871
  return;
}
}
#line 873 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static int check_network(struct network *net ) 
{ 
  int ifindex ;
  int rc ;
  struct ipv6_mreq mreq ;
  unsigned int tmp ;

  {
  {
#line 879
  tmp = if_nametoindex((char const   *)net->ifname);
#line 879
  ifindex = (int )tmp;
  }
#line 880
  if (ifindex != net->ifindex) {
#line 881
    net->ifindex = ifindex;
#line 882
    if (net->ifindex > 0) {
      {
#line 883
      memset((void *)(& mreq), 0, sizeof(mreq));
#line 884
      memcpy((void */* __restrict  */)(& mreq.ipv6mr_multiaddr), (void const   */* __restrict  */)(& protocol_group),
             (size_t )16);
#line 885
      mreq.ipv6mr_interface = (unsigned int )net->ifindex;
#line 886
      rc = setsockopt(protocol_socket, 41, 20, (void const   *)((char *)(& mreq)),
                      (socklen_t )sizeof(mreq));
      }
#line 888
      if (rc < 0) {
        {
#line 889
        perror("setsockopt(IPV6_JOIN_GROUP)");
#line 890
        net->ifindex = 0;
        }
#line 891
        goto fail;
      }
#line 893
      return (1);
    }
  }
  fail: 
#line 897
  return (0);
}
}
#line 900 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static void sigexit(int signo ) 
{ 


  {
#line 903
  exiting = (int volatile   )1;
#line 904
  return;
}
}
#line 906 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static void sigdump(int signo ) 
{ 


  {
#line 909
  dumping = (int volatile   )1;
#line 910
  return;
}
}
#line 912 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static void sigchanged(int signo ) 
{ 


  {
#line 915
  changed = (int volatile   )1;
#line 916
  return;
}
}
#line 918 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static void init_signals(void) 
{ 
  struct sigaction sa ;
  sigset_t ss ;

  {
  {
#line 924
  sigemptyset(& ss);
#line 925
  sa.__sigaction_handler.sa_handler = & sigexit;
#line 926
  sa.sa_mask = ss;
#line 927
  sa.sa_flags = 0;
#line 928
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 930
  sigemptyset(& ss);
#line 931
  sa.__sigaction_handler.sa_handler = & sigexit;
#line 932
  sa.sa_mask = ss;
#line 933
  sa.sa_flags = 0;
#line 934
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 936
  sigemptyset(& ss);
#line 937
  sa.__sigaction_handler.sa_handler = & sigexit;
#line 938
  sa.sa_mask = ss;
#line 939
  sa.sa_flags = 0;
#line 940
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 942
  sigemptyset(& ss);
#line 943
  sa.__sigaction_handler.sa_handler = & sigdump;
#line 944
  sa.sa_mask = ss;
#line 945
  sa.sa_flags = 0;
#line 946
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 948
  sigemptyset(& ss);
#line 949
  sa.__sigaction_handler.sa_handler = & sigchanged;
#line 950
  sa.sa_mask = ss;
#line 951
  sa.sa_flags = 0;
#line 952
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 961
  return;
}
}
#line 963 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int ahcp_socket(int port ) 
{ 
  struct sockaddr_in6 sin6 ;
  int s ;
  int rc ;
  int saved_errno ;
  int one ;
  int zero___0 ;
  int ds ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 969
  one = 1;
#line 969
  zero___0 = 0;
#line 970
  ds = 192;
#line 972
  s = socket(10, 2, 0);
  }
#line 973
  if (s < 0) {
#line 974
    return (-1);
  }
  {
#line 976
  rc = setsockopt(s, 1, 2, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 977
  if (rc < 0) {
    {
#line 978
    perror("setsockopt(SO_REUSEADDR)");
    }
  }
  {
#line 980
  rc = setsockopt(s, 41, 19, (void const   *)(& zero___0), (socklen_t )sizeof(zero___0));
  }
#line 982
  if (rc < 0) {
    {
#line 983
    perror("setsockopt(IPV6_MULTICAST_LOOP)");
    }
  }
  {
#line 985
  rc = setsockopt(s, 41, 18, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 987
  if (rc < 0) {
    {
#line 988
    perror("setsockopt(IPV6_MULTICAST_HOPS)");
    }
  }
  {
#line 991
  rc = setsockopt(s, 41, 26, (void const   *)(& zero___0), (socklen_t )sizeof(zero___0));
  }
#line 993
  if (rc < 0) {
    {
#line 994
    perror("setsockopt(IPV6_V6ONLY)");
    }
  }
  {
#line 998
  rc = setsockopt(s, 41, 67, (void const   *)(& ds), (socklen_t )sizeof(ds));
  }
#line 1003
  if (rc < 0) {
    {
#line 1004
    perror("setsockopt(IPV6_TCLASS)");
    }
  }
  {
#line 1006
  rc = fcntl(s, 1, 0);
  }
#line 1007
  if (rc < 0) {
#line 1008
    goto fail;
  }
  {
#line 1010
  rc = fcntl(s, 2, rc | 1);
  }
#line 1011
  if (rc < 0) {
#line 1012
    goto fail;
  }
  {
#line 1014
  rc = fcntl(s, 3, 0);
  }
#line 1015
  if (rc < 0) {
#line 1016
    goto fail;
  }
  {
#line 1018
  rc = fcntl(s, 4, rc | 2048);
  }
#line 1019
  if (rc < 0) {
#line 1020
    goto fail;
  }
  {
#line 1022
  memset((void *)(& sin6), 0, sizeof(sin6));
#line 1023
  sin6.sin6_family = (sa_family_t )10;
#line 1024
  sin6.sin6_port = htons((uint16_t )port);
#line 1025
  rc = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& sin6)), (socklen_t )sizeof(sin6));
  }
#line 1026
  if (rc < 0) {
#line 1027
    goto fail;
  }
#line 1029
  return (s);
  fail: 
  {
#line 1032
  tmp = __errno_location();
#line 1032
  saved_errno = *tmp;
#line 1033
  close(s);
#line 1034
  tmp___0 = __errno_location();
#line 1034
  *tmp___0 = saved_errno;
  }
#line 1035
  return (-1);
}
}
#line 1038 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int ahcp_recv(int s , void *buf___0 , int buflen , struct sockaddr *sin , int slen ) 
{ 
  struct iovec iovec ;
  struct msghdr msg ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 1045
  memset((void *)(& msg), 0, sizeof(msg));
#line 1046
  iovec.iov_base = buf___0;
#line 1047
  iovec.iov_len = (size_t )buflen;
#line 1048
  msg.msg_name = (void *)sin;
#line 1049
  msg.msg_namelen = (socklen_t )slen;
#line 1050
  msg.msg_iov = & iovec;
#line 1051
  msg.msg_iovlen = (size_t )1;
#line 1053
  tmp = recvmsg(s, & msg, 0);
#line 1053
  rc = (int )tmp;
  }
#line 1054
  return (rc);
}
}
#line 1061 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static int send_unicast_packet(unsigned char *server_id , struct config_data *config ,
                               int index___0 , void *buf___0 , int buflen ) 
{ 
  int rc ;
  unsigned char *address ;
  struct sockaddr_in6 sin ;
  int num6 ;
  int tmp ;
  int num4 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1068
  if (config->server_ipv6) {
#line 1068
    tmp = (config->server_ipv6)->n;
  } else {
#line 1068
    tmp = 0;
  }
#line 1068
  num6 = tmp;
#line 1069
  if (config->server_ipv4) {
#line 1069
    tmp___0 = (config->server_ipv4)->n;
  } else {
#line 1069
    tmp___0 = 0;
  }
#line 1069
  num4 = tmp___0;
#line 1071
  if (! config_data) {
#line 1072
    return (0);
  }
#line 1074
  if (index___0 < num6) {
#line 1075
    address = (config->server_ipv6)->l[index___0].p;
  } else
#line 1076
  if (index___0 < num6 + num4) {
#line 1077
    address = (config->server_ipv4)->l[index___0 - num6].p;
  } else {
#line 1079
    return (0);
  }
  {
#line 1081
  memset((void *)(& sin), 0, sizeof(sin));
#line 1082
  sin.sin6_family = (sa_family_t )10;
#line 1083
  memcpy((void */* __restrict  */)(& sin.sin6_addr), (void const   */* __restrict  */)address,
         (size_t )16);
#line 1084
  sin.sin6_port = htons((uint16_t )protocol_port);
#line 1085
  rc = send_packet((struct sockaddr *)(& sin), (int )sizeof(sin), (unsigned char const   *)server_id,
                   1, (unsigned char const   *)buf___0, (size_t )buflen);
  }
#line 1087
  if (rc >= 0) {
#line 1087
    tmp___1 = 1;
  } else {
#line 1087
    tmp___1 = -1;
  }
#line 1087
  return (tmp___1);
}
}
#line 1090 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
int timeval_compare(struct timeval  const  *s1 , struct timeval  const  *s2 ) 
{ 


  {
#line 1093
  if (s1->tv_sec < s2->tv_sec) {
#line 1094
    return (-1);
  } else
#line 1095
  if (s1->tv_sec > s2->tv_sec) {
#line 1096
    return (1);
  } else
#line 1097
  if (s1->tv_usec < s2->tv_usec) {
#line 1098
    return (-1);
  } else
#line 1099
  if (s1->tv_usec > s2->tv_usec) {
#line 1100
    return (1);
  } else {
#line 1102
    return (0);
  }
}
}
#line 1106 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
void timeval_min(struct timeval *d , struct timeval  const  *s ) 
{ 
  int tmp ;

  {
#line 1109
  if (s->tv_sec == 0L) {
#line 1110
    return;
  }
#line 1112
  if (d->tv_sec == 0L) {
#line 1113
    *d = (struct timeval )*s;
  } else {
    {
#line 1112
    tmp = timeval_compare((struct timeval  const  *)d, s);
    }
#line 1112
    if (tmp > 0) {
#line 1113
      *d = (struct timeval )*s;
    }
  }
#line 1115
  return;
}
}
#line 1117 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
void timeval_minus(struct timeval *d , struct timeval  const  *s1 , struct timeval  const  *s2 ) 
{ 


  {
#line 1121
  if (s1->tv_usec >= s2->tv_usec) {
#line 1122
    d->tv_usec = (__suseconds_t )(s1->tv_usec - s2->tv_usec);
#line 1123
    d->tv_sec = (__time_t )(s1->tv_sec - s2->tv_sec);
  } else {
#line 1125
    d->tv_usec = (__suseconds_t )((s1->tv_usec + 1000000L) - s2->tv_usec);
#line 1126
    d->tv_sec = (__time_t )((s1->tv_sec - s2->tv_sec) - 1L);
  }
#line 1128
  return;
}
}
#line 1130 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
void timeval_min_sec(struct timeval *d , int secs ) 
{ 
  long tmp ;

  {
#line 1133
  if (d->tv_sec == 0L) {
    {
#line 1134
    d->tv_sec = (__time_t )secs;
#line 1135
    tmp = random();
#line 1135
    d->tv_usec = tmp % 1000000L;
    }
  } else
#line 1133
  if (d->tv_sec > (__time_t )secs) {
    {
#line 1134
    d->tv_sec = (__time_t )secs;
#line 1135
    tmp = random();
#line 1135
    d->tv_usec = tmp % 1000000L;
    }
  }
#line 1137
  return;
}
}
#line 1139 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static int reopen_logfile(void) 
{ 
  int lfd ;
  int rc ;

  {
#line 1144
  if ((unsigned long )logfile == (unsigned long )((void *)0)) {
#line 1145
    return (0);
  }
  {
#line 1147
  lfd = open((char const   *)logfile, 1089, 420);
  }
#line 1148
  if (lfd < 0) {
#line 1149
    return (-1);
  }
  {
#line 1151
  fflush(stdout);
#line 1152
  fflush(stderr);
#line 1154
  rc = dup2(lfd, 1);
  }
#line 1155
  if (rc < 0) {
#line 1156
    return (-1);
  }
  {
#line 1158
  rc = dup2(lfd, 2);
  }
#line 1159
  if (rc < 0) {
#line 1160
    return (-1);
  }
#line 1162
  if (lfd == 0) {
    {
#line 1163
    close(lfd);
    }
  } else
#line 1162
  if (lfd > 2) {
    {
#line 1163
    close(lfd);
    }
  }
#line 1165
  return (1);
}
}
#line 1168 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
static int daemonise(void) 
{ 
  int rc ;

  {
  {
#line 1173
  fflush(stdout);
#line 1174
  fflush(stderr);
#line 1176
  rc = fork();
  }
#line 1177
  if (rc < 0) {
#line 1178
    return (-1);
  }
#line 1180
  if (rc > 0) {
    {
#line 1181
    exit(0);
    }
  }
  {
#line 1183
  rc = setsid();
  }
#line 1184
  if (rc < 0) {
#line 1185
    return (-1);
  }
#line 1187
  return (1);
}
}
#line 1190
void ( /* format attribute */  do_debugf)(int level , char const   *format  , ...)  __attribute__((__cold__)) ;
#line 1190 "/home/june/collector/temp/ahcpd-0.53/ahcpd.c"
void ( /* format attribute */  do_debugf)(int level , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 1194
  __builtin_va_start(args, format);
  }
#line 1195
  if (debug >= level) {
    {
#line 1196
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             args);
#line 1197
    fflush(stderr);
    }
  }
  {
#line 1199
  __builtin_va_end(args);
  }
#line 1200
  return;
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 956
extern int fsync(int __fd ) ;
#line 39 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t readv(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 50
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 71 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static unsigned int first_address  =    0U;
#line 71 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static unsigned int last_address  =    0U;
#line 72 "/home/june/collector/temp/ahcpd-0.53/lease.c"
char const   *lease_directory  =    (char const   *)((void *)0);
#line 90 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static struct lease_entry *entries  =    (struct lease_entry *)((void *)0);
#line 92 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int numentries  =    0;
#line 93 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int maxentries  =    0;
#line 95 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static unsigned char *address_ipv4(unsigned int a , unsigned char *ipv4 ) 
{ 


  {
  {
#line 98
  a = htonl(a);
#line 99
  memcpy((void */* __restrict  */)ipv4, (void const   */* __restrict  */)(& a), (size_t )4);
  }
#line 100
  return (ipv4);
}
}
#line 103 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static unsigned int ipv4_address(unsigned char const   *ipv4 ) 
{ 
  unsigned int a ;
  uint32_t tmp ;

  {
  {
#line 107
  memcpy((void */* __restrict  */)(& a), (void const   */* __restrict  */)ipv4, (size_t )4);
#line 108
  tmp = ntohl(a);
  }
#line 108
  return (tmp);
}
}
#line 111 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int entry_match(struct lease_entry *entry , unsigned char const   *id , int id_len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 114
  if ((unsigned long )entry->id == (unsigned long )((void *)0)) {
#line 115
    return (0);
  }
#line 117
  if (entry->id_len == id_len) {
    {
#line 117
    tmp = memcmp((void const   *)entry->id, (void const   *)id, (size_t )id_len);
    }
#line 117
    if (tmp == 0) {
#line 117
      tmp___0 = 1;
    } else {
#line 117
      tmp___0 = 0;
    }
  } else {
#line 117
    tmp___0 = 0;
  }
#line 117
  return (tmp___0);
}
}
#line 120 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static struct lease_entry *find_entry(unsigned int address ) 
{ 
  int i ;

  {
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < numentries)) {
#line 124
      goto while_break;
    }
#line 125
    if ((entries + i)->address == address) {
#line 126
      return (entries + i);
    }
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return ((struct lease_entry *)((void *)0));
}
}
#line 131 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static struct lease_entry *find_entry_by_id(unsigned char const   *id , int id_len ) 
{ 
  int i ;
  int tmp ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < numentries)) {
#line 135
      goto while_break;
    }
    {
#line 136
    tmp = entry_match(entries + i, id, id_len);
    }
#line 136
    if (tmp) {
#line 137
      return (entries + i);
    }
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return ((struct lease_entry *)((void *)0));
}
}
#line 142 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static unsigned int find_entryless(unsigned int first , unsigned int last ) 
{ 
  unsigned int a ;
  int i ;

  {
#line 148
  a = first;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (a <= last)) {
#line 148
      goto while_break;
    }
#line 149
    i = 0;
    {
#line 149
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 149
      if (! (i < numentries)) {
#line 149
        goto while_break___0;
      }
#line 150
      if ((entries + i)->address == a) {
#line 151
        goto while_break___0;
      }
#line 149
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 153
    if (i >= numentries) {
#line 154
      return (a);
    }
#line 148
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return (0U);
}
}
#line 159 "/home/june/collector/temp/ahcpd-0.53/lease.c"
struct lease_entry *find_oldest_entry(void) 
{ 
  int i ;
  int j ;
  unsigned int age ;
  unsigned int a ;
  struct timeval now___0 ;
  struct lease_entry *tmp ;

  {
  {
#line 162
  j = -1;
#line 163
  age = 0U;
#line 166
  gettime(& now___0, (time_t *)((void *)0));
#line 168
  i = 0;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < numentries)) {
#line 168
      goto while_break;
    }
#line 169
    if ((unsigned long )(entries + i)->id == (unsigned long )((void *)0)) {
#line 170
      goto __Cont;
    }
#line 171
    a = (unsigned int )(now___0.tv_sec - (entries + i)->lease_end_m);
#line 172
    if (a > age) {
#line 173
      age = a;
#line 174
      j = i;
    }
    __Cont: /* CIL Label */ 
#line 168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if (j >= 0) {
#line 177
    tmp = entries + j;
  } else {
#line 177
    tmp = (struct lease_entry *)((void *)0);
  }
#line 177
  return (tmp);
}
}
#line 180 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static struct lease_entry *add_entry(unsigned char const   *id , int id_len , unsigned int address ,
                                     unsigned int lease_orig , unsigned int lease_time ,
                                     time_t lease_end_m ) 
{ 
  struct lease_entry *entry ;
  int i ;
  int tmp ;
  int n ;
  int tmp___0 ;
  struct lease_entry *new ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < numentries)) {
#line 187
      goto while_break;
    }
#line 188
    if ((entries + i)->address == address) {
      {
#line 189
      tmp = entry_match(entries + i, id, id_len);
      }
#line 189
      if (! tmp) {
#line 190
        return ((struct lease_entry *)((void *)0));
      }
#line 191
      entry = entries + i;
#line 192
      goto done;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  entry = (struct lease_entry *)((void *)0);
#line 197
  i = 0;
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 197
    if (! (i < numentries)) {
#line 197
      goto while_break___0;
    }
#line 198
    if ((unsigned long )(entries + i)->id == (unsigned long )((void *)0)) {
#line 199
      entry = entries + i;
#line 200
      goto while_break___0;
    }
#line 197
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 204
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 205
    if (numentries >= maxentries) {
#line 206
      if (maxentries < 16384) {
#line 207
        if (maxentries * 2 <= 16384) {
#line 207
          tmp___0 = maxentries * 2;
        } else {
#line 207
          tmp___0 = 16384;
        }
        {
#line 207
        n = tmp___0;
#line 208
        tmp___1 = realloc((void *)entries, (unsigned long )n * sizeof(struct lease_entry ));
#line 208
        new = (struct lease_entry *)tmp___1;
        }
#line 210
        if (new) {
#line 211
          entries = new;
#line 212
          maxentries = n;
        }
      }
    }
#line 217
    if (numentries < maxentries) {
#line 218
      tmp___2 = numentries;
#line 218
      numentries ++;
#line 218
      entry = entries + tmp___2;
    }
  }
#line 221
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    {
#line 222
    entry = find_oldest_entry();
    }
#line 223
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 224
      return ((struct lease_entry *)((void *)0));
    }
    {
#line 226
    free((void *)entry->id);
#line 227
    entry->id = (unsigned char *)((void *)0);
#line 228
    entry->id_len = 0;
#line 229
    entry->address = 0U;
#line 230
    entry->lease_orig = 0U;
#line 231
    entry->lease_time = 0U;
#line 232
    entry->lease_end_m = (time_t )0;
    }
  }
  {
#line 235
  tmp___3 = malloc((size_t )id_len);
#line 235
  entry->id = (unsigned char *)tmp___3;
  }
#line 236
  if ((unsigned long )entry->id == (unsigned long )((void *)0)) {
#line 237
    return ((struct lease_entry *)((void *)0));
  }
  {
#line 238
  memcpy((void */* __restrict  */)entry->id, (void const   */* __restrict  */)id,
         (size_t )id_len);
#line 239
  entry->id_len = id_len;
#line 240
  entry->address = address;
  }
  done: 
#line 243
  entry->lease_orig = lease_orig;
#line 244
  entry->lease_time = lease_time;
#line 245
  entry->lease_end_m = lease_end_m;
#line 246
  return (entry);
}
}
#line 249 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static char *lease_file(unsigned char const   *ipv4 , char *buf___0 , int bufsize ) 
{ 
  char const   *p ;
  int n ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 255
  tmp = strlen(lease_directory);
#line 255
  n = (int )tmp;
  }
#line 256
  if (n >= bufsize - 2) {
#line 257
    return ((char *)((void *)0));
  }
  {
#line 259
  memcpy((void */* __restrict  */)buf___0, (void const   */* __restrict  */)lease_directory,
         (size_t )n);
#line 260
  tmp___0 = n;
#line 260
  n ++;
#line 260
  *(buf___0 + tmp___0) = (char )'/';
#line 262
  p = inet_ntop(2, (void const   */* __restrict  */)ipv4, (char */* __restrict  */)(buf___0 + n),
                (socklen_t )(bufsize - n));
  }
#line 263
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 264
    return ((char *)((void *)0));
  }
#line 266
  return (buf___0);
}
}
#line 269 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int close_lease_file(int fd , int modified ) 
{ 
  int rc ;
  int save ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  again: 
#line 275
  if (modified) {
    {
#line 276
    rc = fsync(fd);
    }
#line 277
    if (rc < 0) {
      {
#line 279
      tmp = __errno_location();
      }
#line 279
      if (*tmp == 4) {
#line 279
        goto again;
      }
      {
#line 280
      tmp___0 = __errno_location();
#line 280
      save = *tmp___0;
#line 281
      close(fd);
#line 282
      tmp___1 = __errno_location();
#line 282
      *tmp___1 = save;
      }
#line 283
      return (-1);
    }
  }
  {
#line 287
  rc = close(fd);
  }
#line 288
  if (rc < 1) {
    {
#line 288
    tmp___2 = __errno_location();
    }
#line 288
    if (*tmp___2 == 4) {
#line 289
      goto again;
    }
  }
#line 290
  return (rc);
}
}
#line 293 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int read_lease_file(int fd , unsigned char const   *ipv4 , unsigned int *lease_orig_return ,
                           unsigned int *lease_time_return , unsigned char *ipv4_return ,
                           unsigned char *client_buf , int client_len ) 
{ 
  int rc ;
  int i ;
  struct iovec iov[2] ;
  char head[20] ;
  char name[16] ;
  unsigned int lease_orig ;
  unsigned int lease_time ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 304
  i = 0;
#line 305
  iov[i].iov_base = (void *)(head);
#line 306
  tmp = i;
#line 306
  i ++;
#line 306
  iov[tmp].iov_len = (size_t )20;
#line 307
  if (client_len > 0) {
#line 308
    iov[i].iov_base = (void *)client_buf;
#line 309
    tmp___0 = i;
#line 309
    i ++;
#line 309
    iov[tmp___0].iov_len = (size_t )client_len;
  }
  {
#line 312
  tmp___1 = readv(fd, (struct iovec  const  *)(iov), i);
#line 312
  rc = (int )tmp___1;
  }
#line 313
  if (rc < 0) {
    {
#line 314
    perror("read(lease_file)");
    }
#line 315
    return (-1);
  }
#line 318
  if (rc < 20) {
    {
#line 319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Truncated lease file for %s.\n",
            name);
    }
#line 320
    return (-1);
  } else
#line 318
  if (rc > 20 + client_len) {
    {
#line 319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Truncated lease file for %s.\n",
            name);
    }
#line 320
    return (-1);
  }
  {
#line 323
  tmp___2 = memcmp((void const   *)"AHCP", (void const   *)(head), (size_t )4);
  }
#line 323
  if (tmp___2 != 0) {
    {
#line 324
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Corrupted lease file for %s.\n",
            name);
    }
#line 325
    return (-1);
  }
  {
#line 328
  tmp___3 = memcmp((void const   *)"\001\000\000\000", (void const   *)(head + 4),
                   (size_t )4);
  }
#line 328
  if (tmp___3 != 0) {
    {
#line 329
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Lease file %s has wrong version.\n",
            name);
    }
#line 330
    return (-1);
  }
#line 333
  if (ipv4) {
    {
#line 333
    tmp___4 = memcmp((void const   *)ipv4, (void const   *)(head + 8), (size_t )4);
    }
#line 333
    if (tmp___4 != 0) {
      {
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mismatched lease file for %s.\n",
              name);
      }
#line 335
      return (-1);
    }
  }
  {
#line 338
  memcpy((void */* __restrict  */)(& lease_orig), (void const   */* __restrict  */)(head + 12),
         (size_t )4);
#line 339
  lease_orig = ntohl(lease_orig);
#line 341
  memcpy((void */* __restrict  */)(& lease_time), (void const   */* __restrict  */)(head + 16),
         (size_t )4);
#line 342
  lease_time = ntohl(lease_time);
  }
#line 344
  if (lease_orig_return) {
#line 345
    *lease_orig_return = lease_orig;
  }
#line 346
  if (lease_time_return) {
#line 347
    *lease_time_return = lease_time;
  }
#line 348
  if (ipv4_return) {
    {
#line 349
    memcpy((void */* __restrict  */)ipv4_return, (void const   */* __restrict  */)(head + 8),
           (size_t )4);
    }
  }
#line 351
  return (rc - 20);
}
}
#line 354 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int write_lease_file(int fd , unsigned char const   *ipv4 , unsigned int lease_orig ,
                            unsigned int lease_time , unsigned char const   *client_id ,
                            int client_len ) 
{ 
  struct iovec iov[5] ;
  int i ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 363
  if (client_len > 650) {
#line 364
    return (-1);
  }
  {
#line 366
  lease_orig = htonl(lease_orig);
#line 367
  lease_time = htonl(lease_time);
#line 369
  i = 0;
#line 370
  iov[i].iov_base = (void *)"AHCP\001\000\000\000";
#line 371
  tmp = i;
#line 371
  i ++;
#line 371
  iov[tmp].iov_len = (size_t )8;
#line 372
  iov[i].iov_base = (void *)ipv4;
#line 373
  tmp___0 = i;
#line 373
  i ++;
#line 373
  iov[tmp___0].iov_len = (size_t )4;
#line 374
  iov[i].iov_base = (void *)(& lease_orig);
#line 375
  tmp___1 = i;
#line 375
  i ++;
#line 375
  iov[tmp___1].iov_len = (size_t )4;
#line 376
  iov[i].iov_base = (void *)(& lease_time);
#line 377
  tmp___2 = i;
#line 377
  i ++;
#line 377
  iov[tmp___2].iov_len = (size_t )4;
#line 378
  iov[i].iov_base = (void *)client_id;
#line 379
  tmp___3 = i;
#line 379
  i ++;
#line 379
  iov[tmp___3].iov_len = (size_t )client_len;
#line 381
  tmp___4 = writev(fd, (struct iovec  const  *)(iov), i);
#line 381
  rc = (int )tmp___4;
  }
#line 382
  if (rc < 20 + client_len) {
    {
#line 383
    perror("write(lease_file)");
    }
#line 384
    return (-1);
  }
#line 387
  return (1);
}
}
#line 390 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int update_lease_file(int fd , unsigned int lease_orig , unsigned int lease_time ) 
{ 
  off_t lrc ;
  int rc ;
  int i ;
  struct iovec iov[2] ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 397
  lease_orig = htonl(lease_orig);
#line 398
  lease_time = htonl(lease_time);
#line 400
  lrc = lseek(fd, (__off_t )12, 0);
  }
#line 401
  if (lrc < 0L) {
    {
#line 402
    perror("lseek(lease_file)");
    }
#line 403
    return (-1);
  }
  {
#line 406
  i = 0;
#line 407
  iov[i].iov_base = (void *)(& lease_orig);
#line 408
  tmp = i;
#line 408
  i ++;
#line 408
  iov[tmp].iov_len = (size_t )4;
#line 409
  iov[i].iov_base = (void *)(& lease_time);
#line 410
  tmp___0 = i;
#line 410
  i ++;
#line 410
  iov[tmp___0].iov_len = (size_t )4;
#line 412
  tmp___1 = writev(fd, (struct iovec  const  *)(iov), i);
#line 412
  rc = (int )tmp___1;
  }
#line 413
  if (rc < 8) {
    {
#line 414
    perror("write(lease_file)");
    }
#line 415
    return (-1);
  }
#line 418
  return (1);
}
}
#line 423 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int purge_lease_file(char *fn , unsigned char *ipv4 ) 
{ 
  int fd ;
  int rc ;
  unsigned int lease_orig ;
  unsigned int lease_time ;
  struct timeval now___0 ;
  struct timeval real ;
  time_t stable ;
  int clock_status___0 ;

  {
  {
#line 432
  gettime(& now___0, & stable);
#line 433
  get_real_time(& real, & clock_status___0);
#line 435
  fd = open((char const   *)fn, 2);
  }
#line 436
  if (fd < 0) {
#line 437
    return (0);
  }
  {
#line 439
  rc = read_lease_file(fd, (unsigned char const   *)ipv4, & lease_orig, & lease_time,
                       (unsigned char *)((void *)0), (unsigned char *)((void *)0),
                       0);
  }
#line 440
  if (rc < 0) {
    {
#line 441
    close_lease_file(fd, 0);
    }
#line 442
    return (0);
  }
#line 445
  if (clock_status___0 == 2) {
#line 445
    if (lease_orig > 0U) {
#line 446
      if ((__time_t )((lease_orig + lease_time) + 1383066U) < real.tv_sec) {
        {
#line 447
        rc = unlink((char const   *)fn);
        }
#line 448
        if (rc < 0) {
          {
#line 448
          perror("unlink(lease_file)");
          }
        }
        {
#line 449
        close_lease_file(fd, 1);
        }
#line 450
        return (rc >= 0);
      }
    }
  }
  {
#line 454
  close_lease_file(fd, 0);
  }
#line 455
  return (0);
}
}
#line 459 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int mutate_lease(char *fn , unsigned char const   *ipv4 , struct lease_entry *entry ) 
{ 
  int fd ;
  unsigned int lease_orig ;
  unsigned int lease_time ;
  int rc ;
  struct timeval now___0 ;
  struct timeval real ;
  time_t stable ;
  int clock_status___0 ;
  time_t orig ;
  unsigned int tmp ;

  {
  {
#line 470
  gettime(& now___0, & stable);
#line 471
  get_real_time(& real, & clock_status___0);
  }
#line 473
  if (clock_status___0 != 2) {
#line 474
    return (-1);
  }
#line 476
  if (entry) {
    {
#line 476
    tmp = ipv4_address(ipv4);
    }
#line 476
    if (entry->address != tmp) {
      {
#line 477
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entry mismatch when mutating!\n");
      }
#line 478
      return (-1);
    }
  }
  {
#line 481
  fd = open((char const   *)fn, 2);
  }
#line 482
  if (fd < 0) {
#line 483
    return (0);
  }
  {
#line 485
  rc = read_lease_file(fd, ipv4, & lease_orig, & lease_time, (unsigned char *)((void *)0),
                       (unsigned char *)((void *)0), 0);
  }
#line 486
  if (rc < 0) {
#line 487
    goto fail;
  }
#line 489
  if (lease_orig != 0U) {
#line 490
    goto fail;
  }
#line 492
  if (entry) {
#line 492
    if (stable >= (time_t )lease_time) {
#line 493
      orig = real.tv_sec - (entry->lease_end_m - now___0.tv_sec);
    } else {
#line 495
      orig = real.tv_sec;
    }
  } else {
#line 495
    orig = real.tv_sec;
  }
#line 497
  if (orig > 1000000000L) {
#line 497
    if (orig <= real.tv_sec + 300L) {
#line 498
      lease_orig = (unsigned int )orig;
    } else {
#line 500
      lease_orig = (unsigned int )real.tv_sec;
    }
  } else {
#line 500
    lease_orig = (unsigned int )real.tv_sec;
  }
  {
#line 502
  rc = update_lease_file(fd, lease_orig, lease_time);
  }
#line 503
  if (rc < 0) {
#line 504
    goto fail;
  }
#line 506
  if (entry) {
#line 507
    entry->lease_orig = lease_orig;
  }
  {
#line 509
  close_lease_file(fd, 1);
  }
#line 510
  return (1);
  fail: 
  {
#line 513
  close_lease_file(fd, 0);
  }
#line 514
  return (0);
}
}
#line 517 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int lease_expired(unsigned char const   *ipv4 , unsigned int lease_orig , unsigned int lease_time ) 
{ 
  struct timeval now___0 ;
  struct timeval real ;
  time_t stable ;
  int clock_status___0 ;
  struct lease_entry *entry ;
  unsigned int tmp ;

  {
  {
#line 526
  get_real_time(& real, & clock_status___0);
  }
#line 528
  if (clock_status___0 == 2) {
#line 528
    if (lease_orig > 0U) {
#line 529
      return ((__time_t )(lease_orig + 666U) < real.tv_sec);
    }
  }
  {
#line 531
  gettime(& now___0, & stable);
  }
#line 533
  if (stable < (time_t )lease_time) {
#line 534
    return (0);
  }
#line 536
  if (! ipv4) {
#line 537
    return (0);
  }
  {
#line 539
  tmp = ipv4_address(ipv4);
#line 539
  entry = find_entry(tmp);
  }
#line 540
  if (! entry) {
#line 541
    return (0);
  }
#line 543
  return (entry->lease_end_m + 666L > now___0.tv_sec);
}
}
#line 546 "/home/june/collector/temp/ahcpd-0.53/lease.c"
static int get_lease(unsigned char const   *client_id , int client_len , unsigned char const   *ipv4 ,
                     unsigned int lease_time , int commit ) 
{ 
  unsigned char buf___0[512] ;
  char fn[256] ;
  char *p ;
  int fd ;
  int rc ;
  unsigned int lease_orig ;
  unsigned int old_orig ;
  unsigned int old_time ;
  time_t lease_end_m ;
  int clock_status___0 ;
  struct timeval now___0 ;
  struct timeval real ;
  int tmp ;
  int *tmp___0 ;
  struct lease_entry *entry ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  struct lease_entry *tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 559
  get_real_time(& real, & clock_status___0);
#line 560
  gettime(& now___0, (time_t *)((void *)0));
  }
#line 562
  if (clock_status___0 == 2) {
#line 562
    lease_orig = (unsigned int )real.tv_sec;
  } else {
#line 562
    lease_orig = 0U;
  }
  {
#line 563
  lease_end_m = now___0.tv_sec + (__time_t )lease_time;
#line 565
  p = lease_file(ipv4, fn, 256);
  }
#line 566
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 567
    return (-1);
  }
#line 569
  if (commit) {
#line 569
    tmp = 2;
  } else {
#line 569
    tmp = 0;
  }
  {
#line 569
  fd = open((char const   *)(fn), tmp);
  }
#line 570
  if (fd < 0) {
    {
#line 571
    tmp___0 = __errno_location();
    }
#line 571
    if (*tmp___0 == 2) {
#line 572
      if (commit) {
#line 573
        goto create;
      } else {
#line 575
        return (1);
      }
    }
    {
#line 577
    perror("open(lease_file)");
    }
#line 578
    return (-1);
  }
  {
#line 581
  rc = read_lease_file(fd, ipv4, & old_orig, & old_time, (unsigned char *)((void *)0),
                       buf___0, 512);
  }
#line 582
  if (rc < 0) {
    {
#line 583
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t read lease file.\n");
    }
#line 584
    goto fail;
  }
#line 587
  if (rc == client_len) {
    {
#line 587
    tmp___4 = memcmp((void const   *)(buf___0), (void const   *)client_id, (size_t )client_len);
    }
#line 587
    if (tmp___4 == 0) {
      {
#line 589
      tmp___1 = ipv4_address(ipv4);
#line 589
      entry = find_entry(tmp___1);
      }
#line 590
      if (! entry) {
        {
#line 591
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Eek!  Inconsistent lease entry!\n");
        }
#line 592
        goto fail;
      } else {
        {
#line 590
        tmp___2 = entry_match(entry, client_id, client_len);
        }
#line 590
        if (! tmp___2) {
          {
#line 591
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Eek!  Inconsistent lease entry!\n");
          }
#line 592
          goto fail;
        }
      }
#line 595
      if (clock_status___0 == 2) {
#line 595
        if (old_orig > 0U) {
#line 595
          if (lease_orig > 0U) {
#line 596
            if (lease_time <= (old_orig + old_time) - lease_orig) {
#line 596
              lease_time = (old_orig + old_time) - lease_orig;
            } else {
#line 596
              lease_time = lease_time;
            }
          } else {
#line 595
            goto _L___0;
          }
        } else {
#line 595
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 598
      if ((time_t )lease_time <= entry->lease_end_m - now___0.tv_sec) {
#line 598
        lease_time = (unsigned int )(entry->lease_end_m - now___0.tv_sec);
      } else {
#line 598
        lease_time = lease_time;
      }
#line 600
      if (commit) {
        {
#line 601
        rc = update_lease_file(fd, lease_orig, lease_time);
        }
#line 602
        if (rc < 0) {
#line 603
          goto fail;
        }
#line 604
        entry->lease_orig = lease_orig;
#line 605
        entry->lease_time = lease_time;
#line 606
        entry->lease_end_m = lease_end_m;
      }
    } else {
#line 587
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 609
    tmp___3 = lease_expired(ipv4, old_time, old_orig);
    }
#line 609
    if (! tmp___3) {
#line 610
      if (old_orig == 0U) {
#line 610
        if (clock_status___0 == 2) {
#line 611
          goto mutate;
        } else {
#line 613
          goto fail;
        }
      } else {
#line 613
        goto fail;
      }
    }
#line 616
    if (commit) {
      {
#line 617
      rc = unlink((char const   *)(fn));
      }
#line 618
      if (rc < 0) {
        {
#line 619
        perror("unlink(lease_file)");
        }
#line 620
        goto fail;
      }
      {
#line 622
      close_lease_file(fd, 1);
      }
#line 623
      goto create;
    }
  }
  {
#line 627
  tmp___5 = close_lease_file(fd, commit);
  }
#line 627
  return (tmp___5);
  fail: 
  {
#line 630
  close_lease_file(fd, 0);
  }
#line 631
  return (-1);
  mutate: 
  {
#line 634
  close_lease_file(fd, 0);
#line 635
  tmp___6 = ipv4_address(ipv4);
#line 635
  tmp___7 = find_entry(tmp___6);
#line 635
  mutate_lease(fn, ipv4, tmp___7);
  }
#line 636
  return (-1);
  create: 
  {
#line 639
  fd = open((char const   *)(fn), 194, 420);
  }
#line 640
  if (fd < 0) {
    {
#line 641
    perror("creat(lease_file)");
    }
#line 642
    return (-1);
  }
  {
#line 645
  rc = write_lease_file(fd, ipv4, lease_orig, lease_time, client_id, client_len);
  }
#line 647
  if (rc < 0) {
#line 648
    goto fail;
  }
  {
#line 650
  tmp___8 = ipv4_address(ipv4);
#line 650
  add_entry(client_id, client_len, tmp___8, lease_orig, lease_time, lease_end_m);
#line 653
  tmp___9 = close_lease_file(fd, 1);
  }
#line 653
  return (tmp___9);
}
}
#line 656 "/home/june/collector/temp/ahcpd-0.53/lease.c"
int release_lease(unsigned char const   *client_id , int client_len , unsigned char const   *ipv4 ) 
{ 
  unsigned char buf___0[512] ;
  char fn[256] ;
  char *p ;
  int fd ;
  int rc ;
  int clock_status___0 ;
  unsigned int orig ;
  struct timeval now___0 ;
  struct timeval real ;
  struct lease_entry *entry ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 667
  if (first_address == 0U) {
#line 668
    return (-1);
  } else
#line 667
  if ((unsigned long )lease_directory == (unsigned long )((void *)0)) {
#line 668
    return (-1);
  }
  {
#line 670
  p = lease_file(ipv4, fn, 256);
  }
#line 671
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 672
    return (-1);
  }
  {
#line 674
  fd = open((char const   *)(fn), 2);
  }
#line 675
  if (fd < 0) {
    {
#line 676
    perror("open(lease_file)");
    }
#line 677
    return (-1);
  }
  {
#line 680
  rc = read_lease_file(fd, ipv4, (unsigned int *)((void *)0), (unsigned int *)((void *)0),
                       (unsigned char *)((void *)0), buf___0, 512);
  }
#line 681
  if (rc < 0) {
#line 682
    goto fail;
  }
#line 684
  if (client_id) {
#line 685
    if (rc != client_len) {
#line 686
      goto fail;
    } else {
      {
#line 685
      tmp = memcmp((void const   *)(buf___0), (void const   *)client_id, (size_t )rc);
      }
#line 685
      if (tmp != 0) {
#line 686
        goto fail;
      }
    }
  }
  {
#line 689
  gettime(& now___0, (time_t *)((void *)0));
#line 690
  get_real_time(& real, & clock_status___0);
  }
#line 692
  if (clock_status___0 == 2) {
#line 693
    orig = (unsigned int )real.tv_sec;
  } else {
#line 695
    orig = 0U;
  }
  {
#line 697
  rc = update_lease_file(fd, orig, 0U);
  }
#line 698
  if (rc < 0) {
    {
#line 699
    rc = unlink((char const   *)(fn));
    }
#line 700
    if (rc < 0) {
      {
#line 701
      perror("unlink(lease_file)");
      }
#line 702
      goto fail;
    }
  }
  {
#line 705
  rc = close_lease_file(fd, 1);
  }
#line 706
  if (rc < 0) {
#line 707
    goto fail;
  }
  {
#line 709
  tmp___0 = ipv4_address(ipv4);
#line 709
  entry = find_entry(tmp___0);
#line 710
  entry->lease_orig = orig;
#line 711
  entry->lease_time = 0U;
#line 712
  entry->lease_end_m = now___0.tv_sec;
  }
#line 714
  return (1);
  fail: 
  {
#line 717
  close_lease_file(fd, 0);
  }
#line 718
  return (-1);
}
}
#line 721 "/home/june/collector/temp/ahcpd-0.53/lease.c"
int lease_init(char const   *dir , unsigned char const   *first , unsigned char const   *last ,
               int debug___0 ) 
{ 
  DIR *d ;
  struct timeval now___0 ;
  struct timeval real ;
  int clock_status___0 ;
  unsigned int fa ;
  unsigned int la ;
  void *tmp ;
  struct dirent *e ;
  unsigned char ipv4[4] ;
  unsigned char client_buf[512] ;
  char name[16] ;
  char fn[256] ;
  char const   *p ;
  struct lease_entry *entry ;
  unsigned int lease_orig ;
  unsigned int lease_time ;
  int fd ;
  int rc ;
  int len ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 730
  fa = ipv4_address(first);
#line 731
  la = ipv4_address(last);
  }
#line 733
  if (fa <= 16777216U) {
#line 734
    return (-1);
  } else
#line 733
  if (fa >= la) {
#line 734
    return (-1);
  }
  {
#line 736
  tmp = malloc(16UL * sizeof(struct lease_entry ));
#line 736
  entries = (struct lease_entry *)tmp;
  }
#line 737
  if ((unsigned long )entries == (unsigned long )((void *)0)) {
#line 738
    return (-1);
  }
  {
#line 739
  numentries = 0;
#line 740
  maxentries = 16;
#line 742
  gettime(& now___0, (time_t *)((void *)0));
#line 743
  get_real_time(& real, & clock_status___0);
#line 745
  d = opendir(dir);
  }
#line 746
  if ((unsigned long )d == (unsigned long )((void *)0)) {
    {
#line 747
    perror("open(lease_dir)");
    }
#line 748
    return (-1);
  }
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 760
    e = readdir(d);
    }
#line 761
    if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 761
      goto while_break;
    }
#line 762
    if ((int )e->d_name[0] == 46) {
#line 763
      goto while_continue;
    }
    {
#line 765
    rc = snprintf((char */* __restrict  */)(fn), (size_t )256, (char const   */* __restrict  */)"%s/%s",
                  dir, e->d_name);
    }
#line 766
    if (rc < 0) {
      {
#line 767
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t format filename %s/%s.\n",
              dir, e->d_name);
      }
#line 769
      goto while_continue;
    } else
#line 766
    if (rc >= 256) {
      {
#line 767
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t format filename %s/%s.\n",
              dir, e->d_name);
      }
#line 769
      goto while_continue;
    }
    {
#line 772
    fd = open((char const   *)(fn), 0);
    }
#line 773
    if (fd < 0) {
      {
#line 774
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Inaccessible lease file %s.\n",
              e->d_name);
      }
#line 775
      goto while_continue;
    }
    {
#line 777
    len = read_lease_file(fd, (unsigned char const   *)((void *)0), & lease_orig,
                          & lease_time, ipv4, client_buf, 512);
#line 779
    close(fd);
    }
#line 781
    if (len < 0) {
      {
#line 782
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Corrupted lease file %s.\n",
              fn);
      }
#line 783
      goto while_continue;
    }
    {
#line 786
    p = inet_ntop(2, (void const   */* __restrict  */)(ipv4), (char */* __restrict  */)(name),
                  (socklen_t )16);
    }
#line 787
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 788
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t format address.\n");
      }
#line 789
      goto while_continue;
    }
    {
#line 792
    tmp___0 = strcmp(p, (char const   *)(e->d_name));
    }
#line 792
    if (tmp___0 != 0) {
      {
#line 793
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mis-named lease file %s (should be %s).\n",
              fn, p);
      }
#line 795
      goto while_continue;
    }
    {
#line 798
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 798
      tmp___1 = __builtin_expect((long )(! (! (debug___0 >= 1))), 0L);
      }
#line 798
      if (tmp___1) {
        {
#line 798
        do_debugf(1, "Lease file %s: %u %u.\n", e->d_name, lease_orig, lease_time);
        }
      }
#line 798
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 801
    if (clock_status___0 == 2) {
      {
#line 802
      tmp___2 = lease_expired((unsigned char const   *)((void *)0), lease_orig, lease_time);
      }
#line 802
      if (tmp___2) {
        {
#line 803
        rc = purge_lease_file(fn, ipv4);
        }
#line 804
        if (rc > 0) {
#line 805
          goto while_continue;
        }
      }
    }
    {
#line 809
    tmp___3 = ipv4_address((unsigned char const   *)(ipv4));
#line 809
    entry = add_entry((unsigned char const   *)(client_buf), len, tmp___3, lease_orig,
                      lease_time, now___0.tv_sec + (__time_t )lease_time);
    }
#line 812
    if (entry) {
#line 812
      if (clock_status___0 == 2) {
#line 813
        if (lease_orig == 0U) {
          {
#line 814
          mutate_lease(fn, (unsigned char const   *)(ipv4), entry);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 817
  closedir(d);
  }
#line 819
  if (numentries >= 16384) {
    {
#line 820
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: lease index full.\nPerhaps you should recompile with a larger value for MAX_LEASE_ENTRIES?");
    }
  }
#line 825
  lease_directory = dir;
#line 826
  first_address = fa;
#line 827
  last_address = la;
#line 829
  return (1);
}
}
#line 832 "/home/june/collector/temp/ahcpd-0.53/lease.c"
int take_lease(unsigned char const   *client_id , int client_len , unsigned char const   *suggested_ipv4 ,
               unsigned char *ipv4_return , unsigned int *lease_time , int commit ) 
{ 
  unsigned int a ;
  unsigned int a0 ;
  unsigned int time___0 ;
  struct lease_entry *entry ;
  unsigned char ipv4[4] ;
  struct timeval now___0 ;
  struct timeval real ;
  int clock_status___0 ;
  time_t stable ;
  int tmp ;
  int tmp___0 ;
  int rc ;
  unsigned char *tmp___1 ;

  {
#line 845
  if (first_address == 0U) {
#line 846
    return (-1);
  } else
#line 845
  if ((unsigned long )lease_directory == (unsigned long )((void *)0)) {
#line 846
    return (-1);
  }
#line 848
  if (client_len < 1) {
#line 849
    return (-1);
  }
  {
#line 851
  gettime(& now___0, & stable);
#line 852
  get_real_time(& real, & clock_status___0);
#line 854
  time___0 = *lease_time;
  }
#line 855
  if (time___0 > 691200U) {
#line 856
    time___0 = 691200U;
  }
#line 857
  if (clock_status___0 != 2) {
#line 857
    if (time___0 > 14407U) {
#line 858
      time___0 = 14407U;
    }
  }
#line 859
  a0 = 0U;
#line 862
  if (suggested_ipv4) {
    {
#line 863
    a0 = ipv4_address(suggested_ipv4);
#line 864
    entry = find_entry(a0);
    }
#line 865
    if (entry) {
      {
#line 866
      tmp = entry_match(entry, client_id, client_len);
      }
#line 866
      if (! tmp) {
        {
#line 866
        tmp___0 = lease_expired(suggested_ipv4, entry->lease_orig, entry->lease_time);
        }
#line 866
        if (! tmp___0) {
#line 869
          a0 = 0U;
        }
      }
    }
  }
#line 874
  if (a0 < first_address) {
#line 874
    goto _L;
  } else
#line 874
  if (a0 > last_address) {
    _L: /* CIL Label */ 
    {
#line 875
    entry = find_entry_by_id(client_id, client_len);
    }
#line 876
    if (entry) {
#line 877
      a0 = entry->address;
    }
  }
#line 881
  if (a0 < first_address) {
    {
#line 882
    a0 = find_entryless(first_address, last_address);
    }
  } else
#line 881
  if (a0 > last_address) {
    {
#line 882
    a0 = find_entryless(first_address, last_address);
    }
  }
#line 885
  if (a0 < first_address) {
#line 885
    goto _L___0;
  } else
#line 885
  if (a0 > last_address) {
    _L___0: /* CIL Label */ 
    {
#line 886
    entry = find_oldest_entry();
    }
#line 887
    if (entry) {
#line 888
      a0 = entry->address;
    }
  }
#line 892
  if (a0 < first_address) {
#line 893
    a0 = first_address;
  } else
#line 892
  if (a0 > last_address) {
#line 893
    a0 = first_address;
  }
#line 896
  a = a0;
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 900
    if (a > last_address) {
#line 901
      a = first_address;
    }
    {
#line 903
    tmp___1 = address_ipv4(a, ipv4);
#line 903
    rc = get_lease(client_id, client_len, (unsigned char const   *)tmp___1, time___0,
                   commit);
    }
#line 905
    if (rc >= 0) {
      {
#line 906
      memcpy((void */* __restrict  */)ipv4_return, (void const   */* __restrict  */)(ipv4),
             (size_t )4);
#line 907
      *lease_time = time___0;
      }
#line 908
      return (1);
    }
#line 910
    a ++;
#line 897
    if (! (a != a0)) {
#line 897
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 913
  return (-1);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 50 "/home/june/collector/temp/ahcpd-0.53/prefix.h"
int prefix_list_v4(struct prefix_list *l ) ;
#line 56
struct prefix_list *parse_prefix(char *address , int kind ) ;
#line 57
struct prefix_list *cat_prefix_list(struct prefix_list *p1 , struct prefix_list *p2 ) ;
#line 31 "/home/june/collector/temp/ahcpd-0.53/config.c"
int client_config  =    1;
#line 33 "/home/june/collector/temp/ahcpd-0.53/config.c"
struct server_config *server_config  =    (struct server_config *)((void *)0);
#line 38 "/home/june/collector/temp/ahcpd-0.53/config.c"
static int skip_whitespace(int c , int (*gnc)(void * ) , void *closure ) 
{ 


  {
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (c == 32)) {
#line 41
      if (! (c == 9)) {
#line 41
        goto while_break;
      }
    }
    {
#line 42
    c = (*gnc)(closure);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (c);
}
}
#line 46 "/home/june/collector/temp/ahcpd-0.53/config.c"
static int skip_to_eol(int c , int (*gnc)(void * ) , void *closure ) 
{ 


  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (c != 10) {
#line 49
      if (! (c >= 0)) {
#line 49
        goto while_break;
      }
    } else {
#line 49
      goto while_break;
    }
    {
#line 50
    c = (*gnc)(closure);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  if (c == 10) {
    {
#line 52
    c = (*gnc)(closure);
    }
  }
#line 53
  return (c);
}
}
#line 56 "/home/june/collector/temp/ahcpd-0.53/config.c"
static int skip_eol(int c , int (*gnc)(void * ) , void *closure ) 
{ 


  {
  {
#line 59
  c = skip_whitespace(c, gnc, closure);
  }
#line 60
  if (c == 10) {
    {
#line 61
    c = skip_to_eol(c, gnc, closure);
    }
#line 62
    return (c);
  } else
#line 60
  if (c == 35) {
    {
#line 61
    c = skip_to_eol(c, gnc, closure);
    }
#line 62
    return (c);
  } else
#line 63
  if (c == -1) {
#line 64
    return (-1);
  } else {
#line 66
    return (-2);
  }
}
}
#line 70 "/home/june/collector/temp/ahcpd-0.53/config.c"
static int getword(int c , char **token_r , int (*gnc)(void * ) , void *closure ) 
{ 
  char buf___0[256] ;
  int i ;
  int tmp ;

  {
  {
#line 74
  i = 0;
#line 76
  c = skip_whitespace(c, gnc, closure);
  }
#line 77
  if (c < 0) {
#line 78
    return (c);
  }
#line 79
  if (c == 34) {
#line 80
    return (-2);
  } else
#line 79
  if (c == 10) {
#line 80
    return (-2);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (i >= 255) {
#line 82
      return (-2);
    }
    {
#line 83
    tmp = i;
#line 83
    i ++;
#line 83
    buf___0[tmp] = (char )c;
#line 84
    c = (*gnc)(closure);
    }
#line 81
    if (c != 32) {
#line 81
      if (c != 9) {
#line 81
        if (c != 10) {
#line 81
          if (! (c >= 0)) {
#line 81
            goto while_break;
          }
        } else {
#line 81
          goto while_break;
        }
      } else {
#line 81
        goto while_break;
      }
    } else {
#line 81
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  buf___0[i] = (char )'\000';
#line 87
  *token_r = strdup((char const   *)(buf___0));
  }
#line 88
  return (c);
}
}
#line 91 "/home/june/collector/temp/ahcpd-0.53/config.c"
static int getstring(int c , char **token_r , int (*gnc)(void * ) , void *closure ) 
{ 
  char buf___0[256] ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 95
  i = 0;
#line 97
  c = skip_whitespace(c, gnc, closure);
  }
#line 98
  if (c < 0) {
#line 99
    return (c);
  }
#line 100
  if (c == 10) {
#line 101
    return (-2);
  }
#line 104
  if (c != 34) {
    {
#line 105
    tmp = getword(c, token_r, gnc, closure);
    }
#line 105
    return (tmp);
  }
  {
#line 107
  c = (*gnc)(closure);
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (i >= 255) {
#line 110
      return (-2);
    } else
#line 110
    if (c == 10) {
#line 110
      return (-2);
    }
#line 111
    if (c == 34) {
      {
#line 112
      c = (*gnc)(closure);
      }
#line 113
      goto while_break;
    }
#line 115
    if (c == 92) {
      {
#line 116
      c = (*gnc)(closure);
      }
    }
    {
#line 117
    tmp___0 = i;
#line 117
    i ++;
#line 117
    buf___0[tmp___0] = (char )c;
#line 118
    c = (*gnc)(closure);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  buf___0[i] = (char )'\000';
#line 122
  *token_r = strdup((char const   *)(buf___0));
  }
#line 123
  return (c);
}
}
#line 126 "/home/june/collector/temp/ahcpd-0.53/config.c"
static int parse_config(int (*gnc)(void * ) , void *closure ) 
{ 
  int c ;
  char *token ;
  char *mtoken ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *dir ;
  char *ptoken ;
  struct prefix_list *prefix ;
  unsigned char zeroes___0[4] ;
  unsigned int tmp___3 ;
  unsigned int mask ;
  unsigned int first ;
  unsigned int last ;
  int tmp___4 ;
  int tmp___5 ;
  char *ptoken___0 ;
  struct prefix_list *prefix___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 132
  c = (*gnc)(closure);
  }
#line 133
  if (c < 2) {
#line 134
    return (-1);
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (c >= 0)) {
#line 136
      goto while_break;
    }
    {
#line 137
    c = skip_whitespace(c, gnc, closure);
    }
#line 138
    if (c == 10) {
      {
#line 139
      c = skip_to_eol(c, gnc, closure);
      }
#line 140
      goto while_continue;
    } else
#line 138
    if (c == 35) {
      {
#line 139
      c = skip_to_eol(c, gnc, closure);
      }
#line 140
      goto while_continue;
    }
#line 142
    if (c < 0) {
#line 143
      goto while_break;
    }
    {
#line 144
    c = getword(c, & token, gnc, closure);
    }
#line 145
    if (c < -1) {
#line 146
      return (-1);
    }
    {
#line 148
    tmp___11 = strcmp((char const   *)token, "mode");
    }
#line 148
    if (tmp___11 == 0) {
      {
#line 151
      c = getword(c, & mtoken, gnc, closure);
      }
#line 152
      if (c < -1) {
#line 153
        return (-1);
      }
      {
#line 155
      tmp___2 = strcmp((char const   *)mtoken, "server");
      }
#line 155
      if (tmp___2 == 0) {
#line 157
        client_config = 0;
#line 158
        if (! server_config) {
          {
#line 159
          tmp = calloc((size_t )1, sizeof(struct server_config ));
#line 159
          server_config = (struct server_config *)tmp;
          }
        }
#line 160
        if (! server_config) {
#line 161
          return (-1);
        }
      } else {
        {
#line 165
        tmp___1 = strcmp((char const   *)mtoken, "client");
        }
#line 165
        if (tmp___1 == 0) {
#line 166
          if (server_config) {
#line 167
            return (-1);
          }
#line 168
          client_config = 1;
        } else {
          {
#line 169
          tmp___0 = strcmp((char const   *)mtoken, "forwarder");
          }
#line 169
          if (tmp___0 == 0) {
#line 170
            if (server_config) {
#line 171
              return (-1);
            }
#line 172
            client_config = 0;
          } else {
#line 174
            return (-1);
          }
        }
      }
      {
#line 177
      free((void *)mtoken);
#line 179
      c = skip_eol(c, gnc, closure);
      }
#line 180
      if (c < -1) {
#line 181
        return (-1);
      }
    } else {
      {
#line 182
      tmp___10 = strcmp((char const   *)token, "lease-dir");
      }
#line 182
      if (tmp___10 == 0) {
#line 185
        if (! server_config) {
#line 186
          return (-1);
        }
        {
#line 188
        c = getstring(c, & dir, gnc, closure);
        }
#line 189
        if (c < -1) {
#line 190
          return (-1);
        }
#line 192
        if ((int )*(dir + 0) != 47) {
#line 193
          return (-1);
        }
        {
#line 195
        server_config->lease_dir = (char const   *)dir;
#line 196
        c = skip_eol(c, gnc, closure);
        }
#line 197
        if (c < -1) {
#line 198
          return (-1);
        }
      } else {
        {
#line 199
        tmp___9 = strcmp((char const   *)token, "prefix");
        }
#line 199
        if (tmp___9 == 0) {
#line 203
          if (! server_config) {
#line 204
            return (-1);
          }
          {
#line 206
          c = getword(c, & ptoken, gnc, closure);
          }
#line 207
          if (c < -1) {
#line 208
            return (-1);
          }
          {
#line 210
          prefix = parse_prefix(ptoken, 5);
          }
#line 212
          if ((unsigned long )prefix == (unsigned long )((void *)0)) {
#line 213
            return (-1);
          } else
#line 212
          if (prefix->n != 1) {
#line 213
            return (-1);
          }
          {
#line 215
          tmp___5 = prefix_list_v4(prefix);
          }
#line 215
          if (tmp___5) {
#line 216
            zeroes___0[0] = (unsigned char)0;
#line 216
            tmp___3 = 1U;
            {
#line 216
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 216
              if (tmp___3 >= 4U) {
#line 216
                goto while_break___0;
              }
#line 216
              zeroes___0[tmp___3] = (unsigned char)0;
#line 216
              tmp___3 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 218
            tmp___4 = memcmp((void const   *)(server_config->lease_first), (void const   *)(zeroes___0),
                             (size_t )4);
            }
#line 218
            if (tmp___4 != 0) {
#line 219
              return (-1);
            }
            {
#line 220
            mask = 4294967295U << (128 - (int )prefix->l[0].plen);
#line 221
            first = (unsigned int )(((((int )prefix->l[0].p[12] << 24) | ((int )prefix->l[0].p[13] << 16)) | ((int )prefix->l[0].p[14] << 8)) | (int )prefix->l[0].p[15]) & mask;
#line 226
            last = first | ~ mask;
#line 227
            first = htonl(first + 1U);
#line 228
            last = htonl(last - 1U);
#line 229
            memcpy((void */* __restrict  */)(server_config->lease_first), (void const   */* __restrict  */)(& first),
                   (size_t )4);
#line 230
            memcpy((void */* __restrict  */)(server_config->lease_last), (void const   */* __restrict  */)(& last),
                   (size_t )4);
#line 231
            free((void *)prefix);
            }
          } else {
            {
#line 233
            server_config->ipv6_prefix = cat_prefix_list(server_config->ipv6_prefix,
                                                         prefix);
            }
          }
          {
#line 237
          free((void *)ptoken);
#line 238
          c = skip_eol(c, gnc, closure);
          }
#line 239
          if (c < -1) {
#line 240
            return (-1);
          }
        } else {
          {
#line 241
          tmp___7 = strcmp((char const   *)token, "name-server");
          }
#line 241
          if (tmp___7 == 0) {
#line 241
            goto _L;
          } else {
            {
#line 241
            tmp___8 = strcmp((char const   *)token, "ntp-server");
            }
#line 241
            if (tmp___8 == 0) {
              _L: /* CIL Label */ 
#line 246
              if (! server_config) {
#line 247
                return (-1);
              }
              {
#line 249
              c = getword(c, & ptoken___0, gnc, closure);
              }
#line 250
              if (c < -1) {
#line 251
                return (-1);
              }
              {
#line 253
              prefix___0 = parse_prefix(ptoken___0, 2);
              }
#line 255
              if ((unsigned long )prefix___0 == (unsigned long )((void *)0)) {
#line 256
                return (-1);
              }
              {
#line 258
              tmp___6 = strcmp((char const   *)token, "name-server");
              }
#line 258
              if (tmp___6 == 0) {
                {
#line 259
                server_config->name_server = cat_prefix_list(server_config->name_server,
                                                             prefix___0);
                }
              } else {
                {
#line 263
                server_config->ntp_server = cat_prefix_list(server_config->ntp_server,
                                                            prefix___0);
                }
              }
              {
#line 266
              free((void *)ptoken___0);
              }
            } else {
#line 268
              return (-1);
            }
          }
        }
      }
    }
    {
#line 270
    free((void *)token);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  return (1);
}
}
#line 275 "/home/june/collector/temp/ahcpd-0.53/config.c"
int parse_config_from_file(char *filename ) 
{ 
  FILE *f ;
  int rc ;

  {
  {
#line 281
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 282
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 283
    return (-1);
  }
  {
#line 284
  rc = parse_config((int (*)(void * ))(& fgetc), (void *)f);
#line 285
  fclose(f);
  }
#line 286
  return (rc);
}
}
#line 294 "/home/june/collector/temp/ahcpd-0.53/config.c"
static int gnc_string(struct string_state *s ) 
{ 
  int tmp ;

  {
#line 297
  if ((int )*(s->string + s->n) == 0) {
#line 298
    return (-1);
  } else {
#line 300
    tmp = s->n;
#line 300
    (s->n) ++;
#line 300
    return ((int )*(s->string + tmp));
  }
}
}
#line 303 "/home/june/collector/temp/ahcpd-0.53/config.c"
int parse_config_from_string(char *string ) 
{ 
  struct string_state s ;
  int tmp ;

  {
  {
#line 306
  s.string = string;
#line 306
  s.n = 0;
#line 307
  tmp = parse_config((int (*)(void * ))(& gnc_string), (void *)(& s));
  }
#line 307
  return (tmp);
}
}
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 30 "/home/june/collector/temp/ahcpd-0.53/monotonic.h"
void time_confirm(int confirm ) ;
#line 30 "/home/june/collector/temp/ahcpd-0.53/prefix.h"
unsigned char const   v4prefix[16] ;
#line 47
void free_prefix_list(struct prefix_list *l ) ;
#line 48
struct prefix_list *copy_prefix_list(struct prefix_list *l ) ;
#line 49
int prefix_list_eq(struct prefix_list *l1 , struct prefix_list *l2 ) ;
#line 53
struct prefix_list *raw_prefix_list(unsigned char const   *data , int len , int kind ) ;
#line 55
char *format_prefix_list(struct prefix_list *p , int kind ) ;
#line 43 "/home/june/collector/temp/ahcpd-0.53/configure.h"
int config_data_compatible(struct config_data *config1 , struct config_data *config2 ) ;
#line 45
struct config_data *copy_config_data(struct config_data *config ) ;
#line 59
int address_conflict(struct prefix_list *a , struct prefix_list *b ) ;
#line 53 "/home/june/collector/temp/ahcpd-0.53/configure.c"
struct config_data *config_data  =    (struct config_data *)((void *)0);
#line 54 "/home/june/collector/temp/ahcpd-0.53/configure.c"
unsigned char const   v4prefix[16]  = 
#line 54
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 57 "/home/june/collector/temp/ahcpd-0.53/configure.c"
static int interface_ipv4(char const   *ifname , unsigned char *addr_r ) 
{ 
  struct ifreq req ;
  int s ;
  int rc ;

  {
  {
#line 63
  s = socket(2, 2, 0);
  }
#line 64
  if (s < 0) {
#line 65
    return (-1);
  }
  {
#line 67
  memset((void *)(& req), 0, sizeof(req));
#line 68
  strncpy((char */* __restrict  */)(req.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(req.ifr_ifrn.ifrn_name));
#line 69
  req.ifr_ifru.ifru_addr.sa_family = (sa_family_t )2;
#line 70
  rc = ioctl(s, 35093UL, & req);
  }
#line 71
  if (rc < 0) {
    {
#line 72
    close(s);
    }
#line 73
    return (-1);
  }
#line 76
  if ((int )req.ifr_ifru.ifru_addr.sa_family != 2) {
#line 77
    return (-1);
  }
  {
#line 79
  memcpy((void */* __restrict  */)addr_r, (void const   */* __restrict  */)(& ((struct sockaddr_in *)(& req.ifr_ifru.ifru_addr))->sin_addr),
         (size_t )4);
#line 80
  close(s);
  }
#line 81
  return (1);
}
}
#line 84 "/home/june/collector/temp/ahcpd-0.53/configure.c"
static struct prefix_list *my_ipv4(char **interfaces___0 ) 
{ 
  struct prefix_list *l ;
  int i ;
  int rc ;
  void *tmp ;

  {
  {
#line 90
  tmp = calloc((size_t )1, sizeof(struct prefix_list ));
#line 90
  l = (struct prefix_list *)tmp;
  }
#line 91
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 92
    return ((struct prefix_list *)((void *)0));
  }
#line 94
  i = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (l->n < 8) {
#line 95
      if (! *(interfaces___0 + i)) {
#line 95
        goto while_break;
      }
    } else {
#line 95
      goto while_break;
    }
    {
#line 96
    l->l[l->n].plen = (unsigned char)255;
#line 97
    memcpy((void */* __restrict  */)(l->l[l->n].p), (void const   */* __restrict  */)(v4prefix),
           (size_t )12);
#line 98
    rc = interface_ipv4((char const   *)*(interfaces___0 + i), l->l[l->n].p + 12);
    }
#line 99
    if (rc > 0) {
#line 100
      (l->n) ++;
    }
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if (l->n == 0) {
    {
#line 104
    free((void *)l);
    }
#line 105
    return ((struct prefix_list *)((void *)0));
  }
#line 108
  return (l);
}
}
#line 111 "/home/june/collector/temp/ahcpd-0.53/configure.c"
static int run_script(char const   *action , struct config_data *config , char **interfaces___0 ) 
{ 
  pid_t pid ;
  char buf___0[200] ;
  int i ;
  __pid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  long tmp___6 ;
  int status ;
  int *tmp___7 ;
  union __anonunion_66 __constr_expr_0 ;
  union __anonunion_67 __constr_expr_1 ;
  union __anonunion_68 __constr_expr_2 ;

  {
  {
#line 115
  pid = fork();
  }
#line 116
  if (pid < 0) {
    {
#line 117
    perror("fork");
    }
#line 118
    return (-1);
  } else
#line 119
  if (pid == 0) {
    {
#line 122
    tmp = getppid();
#line 122
    snprintf((char */* __restrict  */)(buf___0), (size_t )50, (char const   */* __restrict  */)"%lu",
             (unsigned long )tmp);
#line 123
    setenv("AHCP_DAEMON_PID", (char const   *)(buf___0), 1);
#line 124
    buf___0[0] = (char )'\000';
#line 125
    i = 0;
    }
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 126
      if (! *(interfaces___0 + i)) {
#line 126
        goto while_break;
      }
#line 127
      if (i > 0) {
        {
#line 128
        strncat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" ",
                (size_t )200);
        }
      }
      {
#line 129
      strncat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)*(interfaces___0 + i),
              (size_t )200);
#line 130
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 132
    setenv("AHCP_INTERFACES", (char const   *)(buf___0), 1);
#line 133
    snprintf((char */* __restrict  */)(buf___0), (size_t )50, (char const   */* __restrict  */)"%d",
             debug);
#line 134
    setenv("AHCP_DEBUG_LEVEL", (char const   *)(buf___0), 1);
    }
#line 135
    if (config->our_ipv6_address) {
#line 135
      if (af & 2) {
        {
#line 136
        tmp___0 = format_prefix_list(config->our_ipv6_address, 0);
#line 136
        setenv("AHCP_IPv6_ADDRESS", (char const   *)tmp___0, 1);
        }
      }
    }
#line 139
    if (config->ipv4_address) {
#line 139
      if (af & 1) {
        {
#line 140
        tmp___1 = format_prefix_list(config->ipv4_address, 1);
#line 140
        setenv("AHCP_IPv4_ADDRESS", (char const   *)tmp___1, 1);
        }
      }
    }
#line 143
    if (config->ipv6_prefix_delegation) {
#line 143
      if (af & 2) {
        {
#line 144
        tmp___2 = format_prefix_list(config->ipv6_prefix_delegation, 3);
#line 144
        setenv("AHCP_IPv6_PREFIX_DELEGATION", (char const   *)tmp___2, 1);
        }
      }
    }
#line 148
    if (config->ipv4_prefix_delegation) {
#line 148
      if (af & 2) {
        {
#line 149
        tmp___3 = format_prefix_list(config->ipv4_prefix_delegation, 4);
#line 149
        setenv("AHCP_IPv4_PREFIX_DELEGATION", (char const   *)tmp___3, 1);
        }
      }
    }
#line 154
    if (config->name_server) {
#line 154
      if (! nodns) {
        {
#line 155
        tmp___4 = format_prefix_list(config->name_server, 2);
#line 155
        setenv("AHCP_NAMESERVER", (char const   *)tmp___4, 1);
        }
      }
    }
#line 158
    if (config->ntp_server) {
      {
#line 159
      tmp___5 = format_prefix_list(config->ntp_server, 2);
#line 159
      setenv("AHCP_NTP_SERVER", (char const   *)tmp___5, 1);
      }
    }
    {
#line 162
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 162
      tmp___6 = __builtin_expect((long )(! (! (debug >= 1))), 0L);
      }
#line 162
      if (tmp___6) {
        {
#line 162
        do_debugf(1, "Running ``%s %s\'\'\n", config_script, action);
        }
      }
#line 162
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 164
    execl((char const   *)config_script, (char const   *)config_script, action, (void *)0);
#line 165
    perror("exec failed");
#line 166
    exit(42);
    }
  } else {
    again: 
    {
#line 170
    pid = waitpid(pid, & status, 0);
    }
#line 171
    if (pid < 0) {
      {
#line 172
      tmp___7 = __errno_location();
      }
#line 172
      if (*tmp___7 == 4) {
#line 173
        goto again;
      }
      {
#line 174
      perror("wait");
      }
#line 175
      return (-1);
    } else {
#line 176
      __constr_expr_2.__in = status;
#line 176
      if ((__constr_expr_2.__i & 127) == 0) {
#line 179
        __constr_expr_1.__in = status;
#line 179
        if ((__constr_expr_1.__i & 65280) >> 8 != 0) {
          {
#line 180
          __constr_expr_0.__in = status;
#line 180
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Child returned error status %d\n",
                  (__constr_expr_0.__i & 65280) >> 8);
          }
#line 182
          return (-1);
        }
      } else {
        {
#line 177
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Child died violently (%d)\n",
                status);
        }
#line 178
        return (-1);
      }
    }
  }
#line 185
  return (1);
}
}
#line 188 "/home/june/collector/temp/ahcpd-0.53/configure.c"
unsigned int config_renew_time(void) 
{ 


  {
#line 191
  return (config_data->origin_m + (config_data->expires * 5U) / 6U);
}
}
#line 194 "/home/june/collector/temp/ahcpd-0.53/configure.c"
void free_config_data(struct config_data *config ) 
{ 


  {
  {
#line 197
  free_prefix_list(config->server_ipv6);
#line 198
  free_prefix_list(config->server_ipv4);
#line 199
  free_prefix_list(config->ipv6_prefix);
#line 200
  free_prefix_list(config->ipv4_prefix);
#line 201
  free_prefix_list(config->ipv6_address);
#line 202
  free_prefix_list(config->ipv4_address);
#line 203
  free_prefix_list(config->ipv6_prefix_delegation);
#line 204
  free_prefix_list(config->ipv4_prefix_delegation);
#line 205
  free_prefix_list(config->name_server);
#line 206
  free_prefix_list(config->ntp_server);
#line 207
  free_prefix_list(config->our_ipv6_address);
#line 208
  free((void *)config);
  }
#line 209
  return;
}
}
#line 211 "/home/june/collector/temp/ahcpd-0.53/configure.c"
struct config_data *copy_config_data(struct config_data *config ) 
{ 
  struct config_data *c ;
  void *tmp ;

  {
  {
#line 214
  tmp = malloc(sizeof(struct config_data ));
#line 214
  c = (struct config_data *)tmp;
  }
#line 215
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 216
    return ((struct config_data *)((void *)0));
  }
#line 218
  *c = *config;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (c->server_ipv6) {
      {
#line 222
      c->server_ipv6 = copy_prefix_list(c->server_ipv6);
      }
    }
#line 222
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if (c->server_ipv4) {
      {
#line 223
      c->server_ipv4 = copy_prefix_list(c->server_ipv4);
      }
    }
#line 223
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 224
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 224
    if (c->ipv6_prefix) {
      {
#line 224
      c->ipv6_prefix = copy_prefix_list(c->ipv6_prefix);
      }
    }
#line 224
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 225
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 225
    if (c->ipv4_prefix) {
      {
#line 225
      c->ipv4_prefix = copy_prefix_list(c->ipv4_prefix);
      }
    }
#line 225
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 226
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 226
    if (c->ipv6_address) {
      {
#line 226
      c->ipv6_address = copy_prefix_list(c->ipv6_address);
      }
    }
#line 226
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 227
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 227
    if (c->ipv4_address) {
      {
#line 227
      c->ipv4_address = copy_prefix_list(c->ipv4_address);
      }
    }
#line 227
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 228
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 228
    if (c->ipv6_prefix_delegation) {
      {
#line 228
      c->ipv6_prefix_delegation = copy_prefix_list(c->ipv6_prefix_delegation);
      }
    }
#line 228
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 229
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 229
    if (c->ipv4_prefix_delegation) {
      {
#line 229
      c->ipv4_prefix_delegation = copy_prefix_list(c->ipv4_prefix_delegation);
      }
    }
#line 229
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 230
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 230
    if (c->name_server) {
      {
#line 230
      c->name_server = copy_prefix_list(c->name_server);
      }
    }
#line 230
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 231
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 231
    if (c->ntp_server) {
      {
#line 231
      c->ntp_server = copy_prefix_list(c->ntp_server);
      }
    }
#line 231
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 232
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 232
    if (c->our_ipv6_address) {
      {
#line 232
      c->our_ipv6_address = copy_prefix_list(c->our_ipv6_address);
      }
    }
#line 232
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 235
  return (c);
}
}
#line 238 "/home/june/collector/temp/ahcpd-0.53/configure.c"
int config_data_compatible(struct config_data *config1 , struct config_data *config2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 242
  if (! (! config1->ipv4_address) != ! (! config2->ipv4_address)) {
#line 247
    return (0);
  } else
#line 242
  if (! (! config1->ipv6_address) != ! (! config2->ipv6_address)) {
#line 247
    return (0);
  } else
#line 242
  if (! (! config1->ipv6_prefix) != ! (! config2->ipv6_prefix)) {
#line 247
    return (0);
  } else
#line 242
  if (! (! config1->ipv4_prefix_delegation) != ! (! config2->ipv4_prefix_delegation)) {
#line 247
    return (0);
  } else
#line 242
  if (! (! config1->ipv6_prefix_delegation) != ! (! config2->ipv6_prefix_delegation)) {
#line 247
    return (0);
  }
#line 249
  if (config1->ipv4_address) {
    {
#line 250
    tmp = prefix_list_eq(config1->ipv4_address, config2->ipv4_address);
    }
#line 250
    if (tmp) {
#line 250
      tmp___0 = 0;
    } else {
#line 250
      tmp___0 = 1;
    }
#line 250
    if (tmp___0 != 0) {
#line 251
      return (0);
    }
  }
#line 254
  if (config1->ipv6_address) {
    {
#line 255
    tmp___1 = prefix_list_eq(config1->ipv6_address, config2->ipv6_address);
    }
#line 255
    if (tmp___1) {
#line 255
      tmp___2 = 0;
    } else {
#line 255
      tmp___2 = 1;
    }
#line 255
    if (tmp___2 != 0) {
#line 256
      return (0);
    }
  }
#line 259
  if (config1->ipv6_prefix) {
    {
#line 260
    tmp___3 = prefix_list_eq(config1->ipv6_prefix, config2->ipv6_prefix);
    }
#line 260
    if (tmp___3) {
#line 260
      tmp___4 = 0;
    } else {
#line 260
      tmp___4 = 1;
    }
#line 260
    if (tmp___4 != 0) {
#line 261
      return (0);
    }
  }
#line 264
  if (config1->ipv4_prefix_delegation) {
    {
#line 265
    tmp___5 = prefix_list_eq(config1->ipv4_prefix_delegation, config2->ipv4_prefix_delegation);
    }
#line 265
    if (tmp___5) {
#line 265
      tmp___6 = 0;
    } else {
#line 265
      tmp___6 = 1;
    }
#line 265
    if (tmp___6 != 0) {
#line 267
      return (0);
    }
  }
#line 270
  if (config1->ipv6_prefix_delegation) {
    {
#line 271
    tmp___7 = prefix_list_eq(config1->ipv6_prefix_delegation, config2->ipv6_prefix_delegation);
    }
#line 271
    if (tmp___7) {
#line 271
      tmp___8 = 0;
    } else {
#line 271
      tmp___8 = 1;
    }
#line 271
    if (tmp___8 != 0) {
#line 273
      return (0);
    }
  }
#line 276
  return (1);
}
}
#line 279 "/home/june/collector/temp/ahcpd-0.53/configure.c"
struct config_data *make_config_data(int expires , unsigned char *ipv4 , struct server_config *server_config___0 ,
                                     char **interfaces___0 ) 
{ 
  struct config_data *config ;
  struct timeval now___0 ;
  struct timeval real ;
  int clock_status___0 ;
  struct prefix_list *my_address ;
  void *tmp ;

  {
  {
#line 289
  gettime(& now___0, (time_t *)((void *)0));
#line 290
  get_real_time(& real, & clock_status___0);
#line 292
  tmp = calloc((size_t )1, sizeof(struct config_data ));
#line 292
  config = (struct config_data *)tmp;
  }
#line 293
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 294
    return ((struct config_data *)((void *)0));
  }
#line 296
  config->expires = (unsigned int )expires;
#line 297
  config->origin_m = (unsigned int )now___0.tv_sec;
#line 298
  if (clock_status___0 != 0) {
#line 299
    config->origin = (unsigned int )real.tv_sec;
  }
#line 301
  config->expires_m = config->origin_m + config->expires;
#line 303
  if (ipv4) {
    {
#line 304
    config->ipv4_address = raw_prefix_list((unsigned char const   *)ipv4, 4, 1);
    }
  }
#line 306
  if (server_config___0->ipv6_prefix) {
    {
#line 307
    config->ipv6_prefix = copy_prefix_list(server_config___0->ipv6_prefix);
    }
  }
#line 309
  if (server_config___0->name_server) {
    {
#line 310
    config->name_server = copy_prefix_list(server_config___0->name_server);
    }
  }
#line 312
  if (server_config___0->ntp_server) {
    {
#line 313
    config->ntp_server = copy_prefix_list(server_config___0->ntp_server);
    }
  }
  {
#line 315
  my_address = my_ipv4(interfaces___0);
  }
#line 316
  if (my_address) {
#line 317
    config->server_ipv4 = my_address;
  }
#line 319
  return (config);
}
}
#line 324 "/home/june/collector/temp/ahcpd-0.53/configure.c"
struct config_data *parse_message(int configure , unsigned char const   *data , int len ,
                                  char **interfaces___0 ) 
{ 
  int bodylen ;
  int i ;
  int opt ;
  int olen ;
  int rc ;
  int mandatory ;
  unsigned char const   *body ;
  struct config_data *config ;
  unsigned int origin ;
  unsigned int expires ;
  struct timeval now___0 ;
  struct timeval real ;
  int clock_status___0 ;
  void *tmp ;
  unsigned int when ;
  unsigned int secs ;
  struct prefix_list *value ;
  struct prefix_list *pcat ;
  struct prefix_list *pcat___0 ;
  struct prefix_list *value___0 ;
  struct prefix_list *pcat___1 ;
  struct prefix_list *value___1 ;
  char const   *tmp___0 ;
  struct prefix_list *pcat___2 ;
  struct prefix_list *pcat___3 ;
  struct prefix_list *pcat___4 ;
  struct prefix_list *pcat___5 ;
  struct prefix_list *value___2 ;
  struct prefix_list *pcat___6 ;
  struct prefix_list *pcat___7 ;
  long tmp___1 ;
  unsigned char address[16] ;
  int have_address ;
  int tmp___2 ;

  {
#line 329
  mandatory = 0;
#line 332
  origin = 0U;
#line 332
  expires = 0U;
#line 345
  if (len < 4) {
#line 346
    return ((struct config_data *)((void *)0));
  }
  {
#line 348
  gettime(& now___0, (time_t *)((void *)0));
#line 349
  get_real_time(& real, & clock_status___0);
#line 351
  body = data + 4;
#line 353
  bodylen = (int )(((int const   )*(data + 2) << 8) | (int const   )*(data + 3));
  }
#line 354
  if (bodylen > len - 4) {
#line 355
    return ((struct config_data *)((void *)0));
  }
  {
#line 357
  tmp = calloc((size_t )1, sizeof(struct config_data ));
#line 357
  config = (struct config_data *)tmp;
  }
#line 358
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 359
    return ((struct config_data *)((void *)0));
  }
#line 361
  i = 0;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (i < bodylen)) {
#line 362
      goto while_break;
    }
#line 363
    opt = (int )*(body + i);
#line 364
    if (opt == 0) {
#line 365
      mandatory = 0;
#line 366
      i ++;
#line 367
      goto while_continue;
    } else
#line 368
    if (opt == 1) {
#line 369
      mandatory = 1;
#line 370
      i ++;
#line 371
      goto while_continue;
    }
#line 374
    olen = (int )*(body + (i + 1));
#line 375
    if ((olen + 2) + i > bodylen) {
      {
#line 376
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Truncated message.\n");
      }
#line 377
      goto fail;
    }
#line 380
    if (opt == 2) {
#line 383
      if (olen != 4) {
#line 384
        goto fail;
      }
      {
#line 386
      memcpy((void */* __restrict  */)(& when), (void const   */* __restrict  */)((body + i) + 2),
             (size_t )4);
#line 387
      when = ntohl(when);
      }
#line 388
      if (origin <= 0U) {
#line 389
        origin = when;
      } else
#line 391
      if (origin <= when) {
#line 391
        origin = origin;
      } else {
#line 391
        origin = when;
      }
    } else
#line 392
    if (opt == 3) {
#line 395
      if (olen != 4) {
#line 396
        goto fail;
      }
      {
#line 398
      memcpy((void */* __restrict  */)(& secs), (void const   */* __restrict  */)((body + i) + 2),
             (size_t )4);
#line 399
      secs = ntohl(secs);
      }
#line 400
      if (expires <= 0U) {
#line 401
        expires = secs;
      } else
#line 403
      if (expires <= secs) {
#line 403
        expires = expires;
      } else {
#line 403
        expires = secs;
      }
    } else
#line 404
    if (opt == 6) {
#line 404
      goto _L___1;
    } else
#line 404
    if (opt == 10) {
      _L___1: /* CIL Label */ 
#line 406
      if (olen % 17 != 0) {
        {
#line 407
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected length for prefix.\n");
        }
#line 408
        goto fail;
      }
      {
#line 411
      value = raw_prefix_list((body + i) + 2, olen, 3);
      }
#line 412
      if (opt == 6) {
        {
#line 413
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 413
          pcat = cat_prefix_list(config->ipv6_prefix, value);
          }
#line 413
          if ((unsigned long )pcat == (unsigned long )((void *)0)) {
#line 413
            goto fail;
          }
#line 413
          config->ipv6_prefix = pcat;
#line 413
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 414
        if (mandatory) {
#line 415
          config->ipv6_mandatory = 1;
        }
      } else {
        {
#line 417
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 417
          pcat___0 = cat_prefix_list(config->ipv6_prefix_delegation, value);
          }
#line 417
          if ((unsigned long )pcat___0 == (unsigned long )((void *)0)) {
#line 417
            goto fail;
          }
#line 417
          config->ipv6_prefix_delegation = pcat___0;
#line 417
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 418
        if (mandatory) {
#line 419
          config->ipv6_delegation_mandatory = 1;
        }
      }
    } else
#line 421
    if (opt == 11) {
#line 423
      if (olen % 5 != 0) {
        {
#line 424
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected length for prefix.\n");
        }
#line 425
        goto fail;
      }
      {
#line 427
      value___0 = raw_prefix_list((body + i) + 2, olen, 4);
      }
      {
#line 428
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 428
        pcat___1 = cat_prefix_list(config->ipv4_prefix_delegation, value___0);
        }
#line 428
        if ((unsigned long )pcat___1 == (unsigned long )((void *)0)) {
#line 428
          goto fail;
        }
#line 428
        config->ipv4_prefix_delegation = pcat___1;
#line 428
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 429
      if (mandatory) {
#line 430
        config->ipv4_delegation_mandatory = 1;
      }
    } else
#line 431
    if (opt == 4) {
#line 431
      goto _L___0;
    } else
#line 431
    if (opt == 8) {
#line 431
      goto _L___0;
    } else
#line 431
    if (opt == 12) {
#line 431
      goto _L___0;
    } else
#line 431
    if (opt == 13) {
      _L___0: /* CIL Label */ 
#line 434
      if (olen % 16 != 0) {
#line 435
        if (opt == 8) {
#line 435
          tmp___0 = "address";
        } else {
#line 435
          tmp___0 = "server";
        }
        {
#line 435
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected length for %s.\n",
                tmp___0);
        }
#line 437
        goto fail;
      }
      {
#line 440
      value___1 = raw_prefix_list((body + i) + 2, olen, 0);
      }
#line 441
      if (opt == 4) {
        {
#line 442
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 442
          pcat___2 = cat_prefix_list(config->server_ipv6, value___1);
          }
#line 442
          if ((unsigned long )pcat___2 == (unsigned long )((void *)0)) {
#line 442
            goto fail;
          }
#line 442
          config->server_ipv6 = pcat___2;
#line 442
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 443
      if (opt == 8) {
        {
#line 444
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 444
          pcat___3 = cat_prefix_list(config->ipv6_address, value___1);
          }
#line 444
          if ((unsigned long )pcat___3 == (unsigned long )((void *)0)) {
#line 444
            goto fail;
          }
#line 444
          config->ipv6_address = pcat___3;
#line 444
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 445
        if (mandatory) {
#line 446
          config->ipv6_mandatory = 1;
        }
      } else
#line 447
      if (opt == 12) {
        {
#line 448
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 448
          pcat___4 = cat_prefix_list(config->name_server, value___1);
          }
#line 448
          if ((unsigned long )pcat___4 == (unsigned long )((void *)0)) {
#line 448
            goto fail;
          }
#line 448
          config->name_server = pcat___4;
#line 448
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else
#line 449
      if (opt == 13) {
        {
#line 450
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 450
          pcat___5 = cat_prefix_list(config->ntp_server, value___1);
          }
#line 450
          if ((unsigned long )pcat___5 == (unsigned long )((void *)0)) {
#line 450
            goto fail;
          }
#line 450
          config->ntp_server = pcat___5;
#line 450
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
        {
#line 452
        abort();
        }
      }
    } else
#line 454
    if (opt == 5) {
#line 454
      goto _L;
    } else
#line 454
    if (opt == 9) {
      _L: /* CIL Label */ 
      {
#line 456
      value___2 = raw_prefix_list((body + i) + 2, olen, 1);
      }
#line 457
      if (opt == 5) {
        {
#line 458
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 458
          pcat___6 = cat_prefix_list(config->server_ipv4, value___2);
          }
#line 458
          if ((unsigned long )pcat___6 == (unsigned long )((void *)0)) {
#line 458
            goto fail;
          }
#line 458
          config->server_ipv4 = pcat___6;
#line 458
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else
#line 459
      if (opt == 9) {
        {
#line 460
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 460
          pcat___7 = cat_prefix_list(config->ipv4_address, value___2);
          }
#line 460
          if ((unsigned long )pcat___7 == (unsigned long )((void *)0)) {
#line 460
            goto fail;
          }
#line 460
          config->ipv4_address = pcat___7;
#line 460
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 461
        if (mandatory) {
#line 462
          config->ipv4_mandatory = 1;
        }
      } else {
        {
#line 464
        abort();
        }
      }
    } else {
#line 467
      if (mandatory) {
        {
#line 468
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 468
          tmp___1 = __builtin_expect((long )(! (! (debug >= 1))), 0L);
          }
#line 468
          if (tmp___1) {
            {
#line 468
            do_debugf(1, "Unsupported option %d\n", opt);
            }
          }
#line 468
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 469
      if (mandatory) {
#line 469
        if (configure >= 0) {
#line 470
          goto fail;
        }
      }
    }
#line 472
    mandatory = 0;
#line 473
    i += olen + 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  if (configure >= 0) {
#line 476
    if (expires <= 0U) {
#line 477
      goto fail;
    }
  }
#line 479
  config->origin_m = (unsigned int )now___0.tv_sec;
#line 480
  if (90000U <= expires) {
#line 480
    config->expires = 90000U;
  } else {
#line 480
    config->expires = expires;
  }
#line 482
  if (origin >= 0U) {
#line 483
    config->origin = origin;
#line 484
    if (configure >= 0) {
#line 485
      if ((__time_t )origin >= real.tv_sec - 300L) {
#line 485
        if ((__time_t )origin <= real.tv_sec + 300L) {
          {
#line 486
          time_confirm(1);
          }
        } else {
          {
#line 488
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Detected clock skew (client=%ld, server=%ld).\n",
                  now___0.tv_sec, (long )config->origin);
#line 491
          time_confirm(0);
          }
        }
      } else {
        {
#line 488
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Detected clock skew (client=%ld, server=%ld).\n",
                now___0.tv_sec, (long )config->origin);
#line 491
        time_confirm(0);
        }
      }
    }
  }
#line 496
  if (configure >= 0) {
#line 497
    config->expires_m = config->origin_m + config->expires;
#line 499
    if (clock_status___0 != 0) {
#line 499
      if (config->origin > 0U) {
#line 500
        if ((__time_t )config->expires_m <= ((__time_t )config->origin_m + (real.tv_sec - (__time_t )config->origin)) + (__time_t )config->expires) {
#line 500
          config->expires_m = config->expires_m;
        } else {
#line 500
          config->expires_m = (unsigned int )(((__time_t )config->origin_m + (real.tv_sec - (__time_t )config->origin)) + (__time_t )config->expires);
        }
      }
    }
#line 506
    if (config->ipv6_address) {
      {
#line 507
      config->our_ipv6_address = copy_prefix_list(config->ipv6_address);
      }
    } else
#line 508
    if (config->ipv6_prefix) {
#line 508
      if ((config->ipv6_prefix)->n > 0) {
#line 508
        if ((int )(config->ipv6_prefix)->l[0].plen <= 64) {
          {
#line 511
          have_address = 0;
#line 513
          memcpy((void */* __restrict  */)(address), (void const   */* __restrict  */)((config->ipv6_prefix)->l[0].p),
                 (size_t )16);
#line 515
          i = 0;
          }
          {
#line 516
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 516
            if (! *(interfaces___0 + i)) {
#line 516
              goto while_break___10;
            }
            {
#line 517
            rc = if_eui64(*(interfaces___0 + i), address + 8);
            }
#line 518
            if (rc >= 0) {
#line 519
              have_address = 1;
            }
#line 520
            i ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 523
          if (! have_address) {
            {
#line 524
            rc = random_eui64(address + 8);
            }
#line 525
            if (rc >= 0) {
#line 526
              have_address = 1;
            }
          }
#line 529
          if (have_address) {
            {
#line 530
            config->our_ipv6_address = raw_prefix_list((unsigned char const   *)(address),
                                                       16, 0);
            }
          }
#line 532
          if (! config->our_ipv6_address) {
            {
#line 533
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t generate IPv6 address.\n");
            }
          }
        }
      }
    }
  }
#line 537
  if (configure > 0) {
#line 537
    if ((int )*(config_script + 0) != 0) {
#line 537
      if ((__time_t )config->expires_m > now___0.tv_sec + 5L) {
#line 539
        if (config_data) {
          {
#line 540
          tmp___2 = config_data_compatible(config_data, config);
          }
#line 540
          if (! tmp___2) {
            {
#line 541
            unconfigure(interfaces___0);
            }
          }
        }
#line 543
        if (! config_data) {
          {
#line 544
          rc = run_script("start", config, interfaces___0);
          }
#line 545
          if (rc > 0) {
            {
#line 546
            config_data = copy_config_data(config);
            }
          }
        } else {
#line 548
          config_data->origin = config->origin;
#line 549
          config_data->origin_m = config->origin_m;
#line 550
          config_data->expires = config->expires;
#line 551
          config_data->expires_m = config->expires_m;
        }
      }
    }
  }
#line 555
  return (config);
  fail: 
  {
#line 558
  free_config_data(config);
  }
#line 559
  return ((struct config_data *)((void *)0));
}
}
#line 564 "/home/june/collector/temp/ahcpd-0.53/configure.c"
int unconfigure(char **interfaces___0 ) 
{ 
  int rc ;

  {
  {
#line 568
  rc = run_script("stop", config_data, interfaces___0);
#line 569
  free_config_data(config_data);
#line 570
  config_data = (struct config_data *)((void *)0);
  }
#line 571
  return (rc);
}
}
#line 574 "/home/june/collector/temp/ahcpd-0.53/configure.c"
int query_body(unsigned char opcode , int time___0 , unsigned char const   *ipv4 ,
               unsigned char *buf___0 , int buflen ) 
{ 
  int i ;
  int j ;
  unsigned int nowsecs ;
  unsigned int expires ;
  struct timeval real ;
  int clock_status___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 583
  get_real_time(& real, & clock_status___0);
#line 586
  i = 4;
  }
#line 586
  if (i >= buflen) {
#line 586
    goto fail;
  }
#line 588
  if (clock_status___0 != 0) {
    {
#line 589
    nowsecs = htonl((uint32_t )real.tv_sec);
#line 590
    tmp = i;
#line 590
    i ++;
#line 590
    *(buf___0 + tmp) = (unsigned char)2;
    }
#line 590
    if (i >= buflen) {
#line 590
      goto fail;
    }
#line 591
    tmp___0 = i;
#line 591
    i ++;
#line 591
    *(buf___0 + tmp___0) = (unsigned char)4;
#line 591
    if (i >= buflen - 4) {
#line 591
      goto fail;
    }
    {
#line 592
    memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)(& nowsecs),
           (size_t )4);
#line 593
    i += 4;
    }
  }
#line 596
  if (time___0 > 0) {
    {
#line 597
    expires = htonl((uint32_t )time___0);
#line 598
    tmp___1 = i;
#line 598
    i ++;
#line 598
    *(buf___0 + tmp___1) = (unsigned char)3;
    }
#line 598
    if (i >= buflen) {
#line 598
      goto fail;
    }
#line 599
    tmp___2 = i;
#line 599
    i ++;
#line 599
    *(buf___0 + tmp___2) = (unsigned char)4;
#line 599
    if (i >= buflen - 4) {
#line 599
      goto fail;
    }
    {
#line 600
    memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)(& expires),
           (size_t )4);
#line 601
    i += 4;
    }
  }
#line 604
  if (af & 1) {
#line 605
    tmp___3 = i;
#line 605
    i ++;
#line 605
    *(buf___0 + tmp___3) = (unsigned char)9;
#line 605
    if (i >= buflen) {
#line 605
      goto fail;
    }
#line 606
    tmp___4 = i;
#line 606
    i ++;
#line 606
    if (ipv4) {
#line 606
      *(buf___0 + tmp___4) = (unsigned char)4;
    } else {
#line 606
      *(buf___0 + tmp___4) = (unsigned char)0;
    }
#line 606
    if (i >= buflen) {
#line 606
      goto fail;
    }
#line 607
    if (ipv4) {
#line 608
      if (i >= buflen - 4) {
#line 608
        goto fail;
      }
      {
#line 609
      memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)ipv4,
             (size_t )4);
#line 610
      i += 4;
      }
    }
#line 612
    if (request_prefix_delegation) {
#line 613
      tmp___5 = i;
#line 613
      i ++;
#line 613
      *(buf___0 + tmp___5) = (unsigned char)11;
#line 613
      if (i >= buflen) {
#line 613
        goto fail;
      }
#line 614
      tmp___6 = i;
#line 614
      i ++;
#line 614
      *(buf___0 + tmp___6) = (unsigned char)0;
#line 614
      if (i >= buflen) {
#line 614
        goto fail;
      }
    }
  }
#line 618
  if (af & 2) {
#line 619
    tmp___7 = i;
#line 619
    i ++;
#line 619
    *(buf___0 + tmp___7) = (unsigned char)6;
#line 619
    if (i >= buflen) {
#line 619
      goto fail;
    }
#line 620
    tmp___8 = i;
#line 620
    i ++;
#line 620
    *(buf___0 + tmp___8) = (unsigned char)0;
#line 620
    if (i >= buflen) {
#line 620
      goto fail;
    }
#line 621
    if (request_prefix_delegation) {
#line 622
      tmp___9 = i;
#line 622
      i ++;
#line 622
      *(buf___0 + tmp___9) = (unsigned char)10;
#line 622
      if (i >= buflen) {
#line 622
        goto fail;
      }
#line 623
      tmp___10 = i;
#line 623
      i ++;
#line 623
      *(buf___0 + tmp___10) = (unsigned char)0;
#line 623
      if (i >= buflen) {
#line 623
        goto fail;
      }
    }
  }
#line 627
  if ((int )opcode != 5) {
#line 628
    if (! nodns) {
#line 629
      tmp___11 = i;
#line 629
      i ++;
#line 629
      *(buf___0 + tmp___11) = (unsigned char)12;
#line 629
      if (i >= buflen) {
#line 629
        goto fail;
      }
#line 630
      tmp___12 = i;
#line 630
      i ++;
#line 630
      *(buf___0 + tmp___12) = (unsigned char)0;
#line 630
      if (i >= buflen) {
#line 630
        goto fail;
      }
    }
#line 632
    tmp___13 = i;
#line 632
    i ++;
#line 632
    *(buf___0 + tmp___13) = (unsigned char)13;
#line 632
    if (i >= buflen) {
#line 632
      goto fail;
    }
#line 633
    tmp___14 = i;
#line 633
    i ++;
#line 633
    *(buf___0 + tmp___14) = (unsigned char)0;
#line 633
    if (i >= buflen) {
#line 633
      goto fail;
    }
  }
#line 637
  j = i - 4;
#line 638
  *(buf___0 + 0) = opcode;
#line 639
  *(buf___0 + 1) = (unsigned char)0;
#line 640
  *(buf___0 + 2) = (unsigned char )((j >> 8) & 255);
#line 641
  *(buf___0 + 3) = (unsigned char )(j & 255);
#line 643
  return (i);
  fail: 
#line 646
  return (-1);
}
}
#line 649 "/home/june/collector/temp/ahcpd-0.53/configure.c"
int server_body(unsigned char opcode , struct config_data *config , unsigned char *buf___0 ,
                int buflen ) 
{ 
  int i ;
  int j ;
  struct timeval now___0 ;
  struct timeval real ;
  int clock_status___0 ;
  unsigned int nowsecs ;
  unsigned int expires ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int j___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int j___1 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int j___2 ;
  int tmp___9 ;
  int tmp___10 ;
  int j___3 ;
  int tmp___11 ;
  int tmp___12 ;
  int j___4 ;
  int tmp___13 ;
  int tmp___14 ;
  int j___5 ;
  int tmp___15 ;
  int tmp___16 ;
  int j___6 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 658
  gettime(& now___0, (time_t *)((void *)0));
#line 659
  get_real_time(& real, & clock_status___0);
#line 662
  i = 4;
  }
#line 662
  if (i >= buflen) {
#line 662
    goto fail;
  }
#line 664
  if (now___0.tv_sec >= (__time_t )config->expires_m) {
#line 665
    return (-1);
  }
#line 667
  expires = config->expires;
#line 669
  if (clock_status___0 != 0) {
    {
#line 670
    nowsecs = htonl((uint32_t )real.tv_sec);
#line 671
    tmp = i;
#line 671
    i ++;
#line 671
    *(buf___0 + tmp) = (unsigned char)2;
    }
#line 671
    if (i >= buflen) {
#line 671
      goto fail;
    }
#line 672
    tmp___0 = i;
#line 672
    i ++;
#line 672
    *(buf___0 + tmp___0) = (unsigned char)4;
#line 672
    if (i >= buflen - 4) {
#line 672
      goto fail;
    }
    {
#line 673
    memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)(& nowsecs),
           (size_t )4);
#line 674
    i += 4;
    }
  }
  {
#line 677
  expires = htonl(expires);
#line 678
  tmp___1 = i;
#line 678
  i ++;
#line 678
  *(buf___0 + tmp___1) = (unsigned char)1;
  }
#line 678
  if (i >= buflen) {
#line 678
    goto fail;
  }
#line 679
  tmp___2 = i;
#line 679
  i ++;
#line 679
  *(buf___0 + tmp___2) = (unsigned char)3;
#line 679
  if (i >= buflen) {
#line 679
    goto fail;
  }
#line 680
  tmp___3 = i;
#line 680
  i ++;
#line 680
  *(buf___0 + tmp___3) = (unsigned char)4;
#line 680
  if (i >= buflen - 4) {
#line 680
    goto fail;
  }
  {
#line 681
  memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)(& expires),
         (size_t )4);
#line 682
  i += 4;
  }
#line 684
  if (config->ipv4_address) {
#line 686
    tmp___4 = i;
#line 686
    i ++;
#line 686
    *(buf___0 + tmp___4) = (unsigned char)9;
#line 686
    if (i >= buflen) {
#line 686
      goto fail;
    }
#line 687
    tmp___5 = i;
#line 687
    i ++;
#line 687
    *(buf___0 + tmp___5) = (unsigned char )(4 * (config->ipv4_address)->n);
#line 688
    if (i >= buflen) {
#line 688
      goto fail;
    }
#line 689
    j___0 = 0;
    {
#line 689
    while (1) {
      while_continue: /* CIL Label */ ;
#line 689
      if (! (j___0 < (config->ipv4_address)->n)) {
#line 689
        goto while_break;
      }
#line 690
      if (i >= buflen - 4) {
#line 690
        goto fail;
      }
      {
#line 691
      memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)((config->ipv4_address)->l[j___0].p + 12),
             (size_t )4);
#line 692
      i += 4;
#line 689
      j___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 696
  if (config->ipv6_prefix) {
#line 698
    tmp___6 = i;
#line 698
    i ++;
#line 698
    *(buf___0 + tmp___6) = (unsigned char)6;
#line 698
    if (i >= buflen) {
#line 698
      goto fail;
    }
#line 699
    tmp___7 = i;
#line 699
    i ++;
#line 699
    *(buf___0 + tmp___7) = (unsigned char )(17 * (config->ipv6_prefix)->n);
#line 699
    if (i >= buflen) {
#line 699
      goto fail;
    }
#line 700
    j___1 = 0;
    {
#line 700
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 700
      if (! (j___1 < (config->ipv6_prefix)->n)) {
#line 700
        goto while_break___0;
      }
#line 701
      if (i >= buflen - 17) {
#line 701
        goto fail;
      }
      {
#line 702
      memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)((config->ipv6_prefix)->l[j___1].p),
             (size_t )16);
#line 703
      i += 16;
#line 704
      tmp___8 = i;
#line 704
      i ++;
#line 704
      *(buf___0 + tmp___8) = (config->ipv6_prefix)->l[j___1].plen;
#line 700
      j___1 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 708
  if (config->ipv6_address) {
#line 710
    tmp___9 = i;
#line 710
    i ++;
#line 710
    *(buf___0 + tmp___9) = (unsigned char)8;
#line 710
    if (i >= buflen) {
#line 710
      goto fail;
    }
#line 711
    tmp___10 = i;
#line 711
    i ++;
#line 711
    *(buf___0 + tmp___10) = (unsigned char )(16 * (config->ipv6_address)->n);
#line 712
    if (i >= buflen) {
#line 712
      goto fail;
    }
#line 713
    j___2 = 0;
    {
#line 713
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 713
      if (! (j___2 < (config->ipv6_address)->n)) {
#line 713
        goto while_break___1;
      }
#line 714
      if (i >= buflen - 16) {
#line 714
        goto fail;
      }
      {
#line 715
      memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)((config->ipv6_address)->l[j___2].p),
             (size_t )16);
#line 716
      i += 16;
#line 713
      j___2 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 720
  if (config->name_server) {
#line 722
    tmp___11 = i;
#line 722
    i ++;
#line 722
    *(buf___0 + tmp___11) = (unsigned char)12;
#line 722
    if (i >= buflen) {
#line 722
      goto fail;
    }
#line 723
    tmp___12 = i;
#line 723
    i ++;
#line 723
    *(buf___0 + tmp___12) = (unsigned char )(16 * (config->name_server)->n);
#line 724
    if (i >= buflen) {
#line 724
      goto fail;
    }
#line 725
    j___3 = 0;
    {
#line 725
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 725
      if (! (j___3 < (config->name_server)->n)) {
#line 725
        goto while_break___2;
      }
#line 726
      if (i >= buflen - 6) {
#line 726
        goto fail;
      }
      {
#line 727
      memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)((config->name_server)->l[j___3].p),
             (size_t )16);
#line 728
      i += 16;
#line 725
      j___3 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 732
  if (config->ntp_server) {
#line 734
    tmp___13 = i;
#line 734
    i ++;
#line 734
    *(buf___0 + tmp___13) = (unsigned char)13;
#line 734
    if (i >= buflen) {
#line 734
      goto fail;
    }
#line 735
    tmp___14 = i;
#line 735
    i ++;
#line 735
    *(buf___0 + tmp___14) = (unsigned char )(16 * (config->ntp_server)->n);
#line 736
    if (i >= buflen) {
#line 736
      goto fail;
    }
#line 737
    j___4 = 0;
    {
#line 737
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 737
      if (! (j___4 < (config->ntp_server)->n)) {
#line 737
        goto while_break___3;
      }
#line 738
      if (i >= buflen - 6) {
#line 738
        goto fail;
      }
      {
#line 739
      memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)((config->ntp_server)->l[j___4].p),
             (size_t )16);
#line 740
      i += 16;
#line 737
      j___4 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 744
  if (config->server_ipv6) {
#line 746
    tmp___15 = i;
#line 746
    i ++;
#line 746
    *(buf___0 + tmp___15) = (unsigned char)4;
#line 746
    if (i >= buflen) {
#line 746
      goto fail;
    }
#line 747
    tmp___16 = i;
#line 747
    i ++;
#line 747
    *(buf___0 + tmp___16) = (unsigned char )(16 * (config->server_ipv6)->n);
#line 747
    if (i >= buflen) {
#line 747
      goto fail;
    }
#line 748
    j___5 = 0;
    {
#line 748
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 748
      if (! (j___5 < (config->server_ipv6)->n)) {
#line 748
        goto while_break___4;
      }
#line 749
      if (i >= buflen - 16) {
#line 749
        goto fail;
      }
      {
#line 750
      memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)((config->server_ipv6)->l[j___5].p),
             (size_t )16);
#line 751
      i += 16;
#line 748
      j___5 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 755
  if (config->server_ipv4) {
#line 757
    tmp___17 = i;
#line 757
    i ++;
#line 757
    *(buf___0 + tmp___17) = (unsigned char)5;
#line 757
    if (i >= buflen) {
#line 757
      goto fail;
    }
#line 758
    tmp___18 = i;
#line 758
    i ++;
#line 758
    *(buf___0 + tmp___18) = (unsigned char )(4 * (config->server_ipv4)->n);
#line 758
    if (i >= buflen) {
#line 758
      goto fail;
    }
#line 759
    j___6 = 0;
    {
#line 759
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 759
      if (! (j___6 < (config->server_ipv4)->n)) {
#line 759
        goto while_break___5;
      }
#line 760
      if (i >= buflen - 4) {
#line 760
        goto fail;
      }
      {
#line 761
      memcpy((void */* __restrict  */)(buf___0 + i), (void const   */* __restrict  */)((config->server_ipv4)->l[j___6].p + 12),
             (size_t )4);
#line 762
      i += 4;
#line 759
      j___6 ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 767
  j = i - 4;
#line 768
  *(buf___0 + 0) = opcode;
#line 769
  *(buf___0 + 1) = (unsigned char)0;
#line 770
  *(buf___0 + 2) = (unsigned char )((j >> 8) & 255);
#line 771
  *(buf___0 + 3) = (unsigned char )(j & 255);
#line 773
  return (i);
  fail: 
#line 776
  return (-1);
}
}
#line 779 "/home/june/collector/temp/ahcpd-0.53/configure.c"
int address_conflict(struct prefix_list *a , struct prefix_list *b ) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
#line 784
  i = 0;
  {
#line 784
  while (1) {
    while_continue: /* CIL Label */ ;
#line 784
    if (! (i < a->n)) {
#line 784
      goto while_break;
    }
#line 785
    j = 0;
    {
#line 785
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 785
      if (! (j < b->n)) {
#line 785
        goto while_break___0;
      }
      {
#line 786
      tmp = memcmp((void const   *)(a->l[i].p), (void const   *)(b->l[j].p), (size_t )16);
      }
#line 786
      if (tmp == 0) {
#line 787
        return (1);
      }
#line 785
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 784
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 788
  return (0);
}
}
#line 793 "/home/june/collector/temp/ahcpd-0.53/configure.c"
int if_eui64(char *ifname , unsigned char *eui ) 
{ 
  int s ;
  int rc ;
  struct ifreq ifr ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  unsigned char *mac ;
  int *tmp___1 ;
  int tmp___2 ;
  unsigned char *mac___0 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 799
  s = socket(2, 2, 0);
  }
#line 800
  if (s < 0) {
#line 800
    return (-1);
  }
  {
#line 801
  memset((void *)(& ifr), 0, sizeof(ifr));
#line 802
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(ifr.ifr_ifrn.ifrn_name));
#line 803
  rc = ioctl(s, 35111UL, & ifr);
  }
#line 804
  if (rc < 0) {
    {
#line 805
    tmp = __errno_location();
#line 805
    saved_errno = *tmp;
#line 806
    close(s);
#line 807
    tmp___0 = __errno_location();
#line 807
    *tmp___0 = saved_errno;
    }
#line 808
    return (-1);
  }
  {
#line 810
  close(s);
  }
  {
#line 816
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 6) {
#line 816
    goto case_6;
  }
#line 816
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 800) {
#line 816
    goto case_6;
  }
#line 816
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 774) {
#line 816
    goto case_6;
  }
#line 816
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 1) {
#line 816
    goto case_6;
  }
#line 834
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 32) {
#line 834
    goto case_32;
  }
#line 834
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 24) {
#line 834
    goto case_32;
  }
#line 834
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family == 27) {
#line 834
    goto case_32;
  }
#line 846
  goto switch_default;
  case_6: /* CIL Label */ 
  case_800: /* CIL Label */ 
  case_774: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 818
  mac = (unsigned char *)(ifr.ifr_ifru.ifru_hwaddr.sa_data);
#line 820
  tmp___2 = memcmp((void const   *)mac, (void const   *)(zeroes), (size_t )6);
  }
#line 820
  if (tmp___2 == 0) {
    {
#line 822
    tmp___1 = __errno_location();
#line 822
    *tmp___1 = 2;
    }
#line 823
    return (-1);
  } else
#line 820
  if (((int )*(mac + 0) & 1) != 0) {
    {
#line 822
    tmp___1 = __errno_location();
#line 822
    *tmp___1 = 2;
    }
#line 823
    return (-1);
  } else
#line 820
  if (((int )*(mac + 0) & 2) != 0) {
    {
#line 822
    tmp___1 = __errno_location();
#line 822
    *tmp___1 = 2;
    }
#line 823
    return (-1);
  }
  {
#line 825
  memcpy((void */* __restrict  */)eui, (void const   */* __restrict  */)mac, (size_t )3);
#line 826
  *(eui + 3) = (unsigned char)255;
#line 827
  *(eui + 4) = (unsigned char)254;
#line 828
  memcpy((void */* __restrict  */)(eui + 5), (void const   */* __restrict  */)(mac + 3),
         (size_t )3);
#line 829
  *(eui + 0) = (unsigned char )((int )*(eui + 0) ^ 2);
  }
#line 830
  return (1);
  case_32: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_27: /* CIL Label */ 
  {
#line 836
  mac___0 = (unsigned char *)(ifr.ifr_ifru.ifru_hwaddr.sa_data);
#line 837
  tmp___4 = memcmp((void const   *)mac___0, (void const   *)(zeroes), (size_t )8);
  }
#line 837
  if (tmp___4 == 0) {
    {
#line 839
    tmp___3 = __errno_location();
#line 839
    *tmp___3 = 2;
    }
#line 840
    return (-1);
  } else
#line 837
  if (((int )*(mac___0 + 0) & 1) != 0) {
    {
#line 839
    tmp___3 = __errno_location();
#line 839
    *tmp___3 = 2;
    }
#line 840
    return (-1);
  } else
#line 837
  if (((int )*(mac___0 + 0) & 2) != 0) {
    {
#line 839
    tmp___3 = __errno_location();
#line 839
    *tmp___3 = 2;
    }
#line 840
    return (-1);
  }
  {
#line 842
  memcpy((void */* __restrict  */)eui, (void const   */* __restrict  */)mac___0, (size_t )64);
#line 843
  *(eui + 0) = (unsigned char )((int )*(eui + 0) ^ 2);
  }
#line 844
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 847
  tmp___5 = __errno_location();
#line 847
  *tmp___5 = 2;
  }
#line 848
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 864 "/home/june/collector/temp/ahcpd-0.53/configure.c"
int random_eui64(unsigned char *eui ) 
{ 
  int fd ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 871
  fd = open("/dev/urandom", 0);
  }
#line 872
  if (fd < 0) {
#line 873
    return (-1);
  }
  {
#line 875
  tmp = read(fd, (void *)eui, (size_t )8);
#line 875
  rc = (int )tmp;
  }
#line 876
  if (rc < 8) {
#line 877
    return (-1);
  }
  {
#line 878
  close(fd);
#line 880
  *(eui + 0) = (unsigned char )((int )*(eui + 0) & -4);
  }
#line 881
  return (1);
}
}
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 52 "/home/june/collector/temp/ahcpd-0.53/prefix.h"
void prefix_list_extract6(unsigned char *dest , struct prefix_list *p ) ;
#line 32 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
void free_prefix_list(struct prefix_list *l ) 
{ 


  {
  {
#line 35
  free((void *)l);
  }
#line 36
  return;
}
}
#line 38 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
struct prefix_list *copy_prefix_list(struct prefix_list *l ) 
{ 
  struct prefix_list *c ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(sizeof(struct prefix_list ));
#line 41
  c = (struct prefix_list *)tmp;
  }
#line 42
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 43
    return ((struct prefix_list *)((void *)0));
  }
  {
#line 44
  memcpy((void */* __restrict  */)c, (void const   */* __restrict  */)l, sizeof(struct prefix_list ));
  }
#line 45
  return (c);
}
}
#line 48 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
int prefix_list_eq(struct prefix_list *l1 , struct prefix_list *l2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 51
  if (l1->n == l2->n) {
    {
#line 51
    tmp = memcmp((void const   *)(l1->l), (void const   *)(l2->l), (unsigned long )l1->n * sizeof(struct prefix ));
    }
#line 51
    if (tmp == 0) {
#line 51
      tmp___0 = 1;
    } else {
#line 51
      tmp___0 = 0;
    }
  } else {
#line 51
    tmp___0 = 0;
  }
#line 51
  return (tmp___0);
}
}
#line 55 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
int prefix_list_v4(struct prefix_list *l ) 
{ 
  int i ;
  int tmp ;

  {
#line 59
  i = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (i < l->n)) {
#line 59
      goto while_break;
    }
#line 60
    if ((int )l->l[i].plen < 96) {
#line 62
      return (0);
    } else {
      {
#line 60
      tmp = memcmp((void const   *)(l->l[i].p), (void const   *)(v4prefix), (size_t )12);
      }
#line 60
      if (tmp != 0) {
#line 62
        return (0);
      }
    }
#line 59
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return (1);
}
}
#line 67 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
void prefix_list_extract6(unsigned char *dest , struct prefix_list *p ) 
{ 


  {
#line 70
  if (! p) {
    {
#line 71
    memset((void *)dest, 0, (size_t )16);
    }
  } else
#line 70
  if (p->n == 0) {
    {
#line 71
    memset((void *)dest, 0, (size_t )16);
    }
  }
  {
#line 72
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)(p->l[0].p),
         (size_t )16);
  }
#line 73
  return;
}
}
#line 75 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
void prefix_list_extract4(unsigned char *dest , struct prefix_list *p ) 
{ 


  {
#line 78
  if (! p) {
    {
#line 79
    memset((void *)dest, 0, (size_t )4);
    }
  } else
#line 78
  if (p->n == 0) {
    {
#line 79
    memset((void *)dest, 0, (size_t )4);
    }
  }
  {
#line 80
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)(p->l[0].p + 12),
         (size_t )4);
  }
#line 81
  return;
}
}
#line 83 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
static void parse_a6(struct prefix *p , unsigned char const   *data ) 
{ 


  {
  {
#line 86
  memcpy((void */* __restrict  */)(p->p), (void const   */* __restrict  */)data, (size_t )16);
#line 87
  p->plen = (unsigned char)255;
  }
#line 88
  return;
}
}
#line 90 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
static void parse_a4(struct prefix *p , unsigned char const   *data ) 
{ 


  {
  {
#line 93
  memcpy((void */* __restrict  */)(p->p), (void const   */* __restrict  */)(v4prefix),
         (size_t )12);
#line 94
  memcpy((void */* __restrict  */)(p->p + 12), (void const   */* __restrict  */)data,
         (size_t )4);
#line 95
  p->plen = (unsigned char)255;
  }
#line 96
  return;
}
}
#line 98 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
static void parse_p6(struct prefix *p , unsigned char const   *data ) 
{ 


  {
  {
#line 101
  memcpy((void */* __restrict  */)(p->p), (void const   */* __restrict  */)data, (size_t )16);
#line 102
  p->plen = (unsigned char )*(data + 16);
  }
#line 103
  return;
}
}
#line 105 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
static void parse_p4(struct prefix *p , unsigned char const   *data ) 
{ 


  {
  {
#line 108
  memcpy((void */* __restrict  */)(p->p), (void const   */* __restrict  */)(v4prefix),
         (size_t )12);
#line 109
  memcpy((void */* __restrict  */)(p->p + 12), (void const   */* __restrict  */)data,
         (size_t )4);
#line 110
  p->plen = (unsigned char )((int const   )*(data + 4) + 96);
  }
#line 111
  return;
}
}
#line 115 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
struct prefix_list *raw_prefix_list(unsigned char const   *data , int len , int kind ) 
{ 
  struct prefix_list *l ;
  void *tmp ;
  int i ;
  int size ;
  void (*parser)(struct prefix * , unsigned char const   * ) ;

  {
  {
#line 118
  tmp = calloc((size_t )1, sizeof(struct prefix_list ));
#line 118
  l = (struct prefix_list *)tmp;
#line 120
  parser = (void (*)(struct prefix * , unsigned char const   * ))((void *)0);
  }
#line 122
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 123
    return ((struct prefix_list *)((void *)0));
  }
  {
#line 126
  if (kind == 0) {
#line 126
    goto case_0;
  }
#line 127
  if (kind == 1) {
#line 127
    goto case_1;
  }
#line 128
  if (kind == 3) {
#line 128
    goto case_3;
  }
#line 129
  if (kind == 4) {
#line 129
    goto case_4;
  }
#line 130
  goto switch_default;
  case_0: /* CIL Label */ 
#line 126
  size = 16;
#line 126
  parser = & parse_a6;
#line 126
  goto switch_break;
  case_1: /* CIL Label */ 
#line 127
  size = 4;
#line 127
  parser = & parse_a4;
#line 127
  goto switch_break;
  case_3: /* CIL Label */ 
#line 128
  size = 17;
#line 128
  parser = & parse_p6;
#line 128
  goto switch_break;
  case_4: /* CIL Label */ 
#line 129
  size = 5;
#line 129
  parser = & parse_p4;
#line 129
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 130
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 133
  if (len % size != 0) {
#line 134
    return ((struct prefix_list *)((void *)0));
  }
#line 136
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < len)) {
#line 137
      goto while_break;
    }
#line 138
    if (l->n >= 8) {
#line 139
      goto while_break;
    }
    {
#line 140
    (*parser)(& l->l[l->n], data + i);
#line 141
    (l->n) ++;
#line 142
    i += size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (l);
}
}
#line 151 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
static char buf[120]  ;
#line 148 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
char *format_prefix_list(struct prefix_list *p , int kind ) 
{ 
  int i ;
  int j ;
  int k ;
  char const   *r ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 155
  j = 0;
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < p->n)) {
#line 156
      goto while_break;
    }
    {
#line 158
    if (kind == 0) {
#line 158
      goto case_0;
    }
#line 163
    if (kind == 1) {
#line 163
      goto case_1;
    }
#line 168
    if (kind == 2) {
#line 168
      goto case_2;
    }
#line 176
    if (kind == 3) {
#line 176
      goto case_3;
    }
#line 184
    if (kind == 4) {
#line 184
      goto case_4;
    }
#line 192
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 159
    r = inet_ntop(10, (void const   */* __restrict  */)(p->l[i].p), (char */* __restrict  */)(buf + j),
                  (socklen_t )(120 - j));
    }
#line 160
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 160
      return ((char *)((void *)0));
    }
    {
#line 161
    tmp = strlen(r);
#line 161
    j = (int )((size_t )j + tmp);
    }
#line 162
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 164
    r = inet_ntop(2, (void const   */* __restrict  */)(p->l[i].p + 12), (char */* __restrict  */)(buf + j),
                  (socklen_t )(120 - j));
    }
#line 165
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 165
      return ((char *)((void *)0));
    }
    {
#line 166
    tmp___0 = strlen(r);
#line 166
    j = (int )((size_t )j + tmp___0);
    }
#line 167
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 169
    tmp___1 = memcmp((void const   *)(p->l[i].p), (void const   *)(v4prefix), (size_t )12);
    }
#line 169
    if (tmp___1 == 0) {
      {
#line 170
      r = inet_ntop(2, (void const   */* __restrict  */)(p->l[i].p + 12), (char */* __restrict  */)(buf + j),
                    (socklen_t )(120 - j));
      }
    } else {
      {
#line 172
      r = inet_ntop(10, (void const   */* __restrict  */)(p->l[i].p), (char */* __restrict  */)(buf + j),
                    (socklen_t )(120 - j));
      }
    }
#line 173
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 173
      return ((char *)((void *)0));
    }
    {
#line 174
    tmp___2 = strlen(r);
#line 174
    j = (int )((size_t )j + tmp___2);
    }
#line 175
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 177
    r = inet_ntop(10, (void const   */* __restrict  */)(p->l[i].p), (char */* __restrict  */)(buf + j),
                  (socklen_t )(120 - j));
    }
#line 178
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 178
      return ((char *)((void *)0));
    }
    {
#line 179
    tmp___3 = strlen(r);
#line 179
    j = (int )((size_t )j + tmp___3);
#line 180
    k = snprintf((char */* __restrict  */)(buf + j), (size_t )(120 - j), (char const   */* __restrict  */)"/%u",
                 (int )p->l[i].plen);
    }
#line 181
    if (k < 0) {
#line 181
      return ((char *)((void *)0));
    } else
#line 181
    if (k >= 120 - j) {
#line 181
      return ((char *)((void *)0));
    }
#line 182
    j += k;
#line 183
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 185
    r = inet_ntop(2, (void const   */* __restrict  */)(p->l[i].p + 12), (char */* __restrict  */)(buf + j),
                  (socklen_t )(120 - j));
    }
#line 186
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 186
      return ((char *)((void *)0));
    }
    {
#line 187
    tmp___4 = strlen(r);
#line 187
    j = (int )((size_t )j + tmp___4);
#line 188
    k = snprintf((char */* __restrict  */)(buf + j), (size_t )(120 - j), (char const   */* __restrict  */)"/%u",
                 (int )p->l[i].plen - 96);
    }
#line 189
    if (k < 0) {
#line 189
      return ((char *)((void *)0));
    } else
#line 189
    if (k >= 120 - j) {
#line 189
      return ((char *)((void *)0));
    }
#line 190
    j += k;
#line 191
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 192
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 194
    if (j >= 119) {
#line 194
      return ((char *)((void *)0));
    }
#line 195
    if (i + 1 < p->n) {
#line 196
      tmp___5 = j;
#line 196
      j ++;
#line 196
      buf[tmp___5] = (char )' ';
    }
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  if (j >= 120) {
#line 199
    return ((char *)((void *)0));
  }
#line 200
  tmp___6 = j;
#line 200
  j ++;
#line 200
  buf[tmp___6] = (char )'\000';
#line 201
  return (buf);
}
}
#line 204 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
struct prefix_list *parse_prefix(char *address , int kind ) 
{ 
  struct prefix_list *list ;
  unsigned char ipv6[16] ;
  unsigned char ipv4[4] ;
  int plen ;
  int rc ;
  char buf___0[30] ;
  char *p ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 211
  plen = 255;
  {
#line 214
  if (kind == 0) {
#line 214
    goto case_0;
  }
#line 219
  if (kind == 1) {
#line 219
    goto case_1;
  }
#line 223
  if (kind == 2) {
#line 223
    goto case_2;
  }
#line 231
  if (kind == 5) {
#line 231
    goto case_5;
  }
#line 254
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 215
  rc = inet_pton(10, (char const   */* __restrict  */)address, (void */* __restrict  */)(ipv6));
  }
#line 216
  if (rc > 0) {
#line 217
    goto return_ipv6;
  }
#line 218
  return ((struct prefix_list *)((void *)0));
  case_1: /* CIL Label */ 
  {
#line 220
  rc = inet_pton(2, (char const   */* __restrict  */)address, (void */* __restrict  */)(ipv4));
  }
#line 221
  if (rc > 0) {
#line 222
    goto return_ipv4;
  }
  case_2: /* CIL Label */ 
  {
#line 224
  rc = inet_pton(2, (char const   */* __restrict  */)address, (void */* __restrict  */)(ipv4));
  }
#line 225
  if (rc > 0) {
#line 226
    goto return_ipv4;
  }
  {
#line 227
  rc = inet_pton(10, (char const   */* __restrict  */)address, (void */* __restrict  */)(ipv6));
  }
#line 228
  if (rc > 0) {
#line 229
    goto return_ipv6;
  }
#line 230
  return ((struct prefix_list *)((void *)0));
  case_5: /* CIL Label */ 
  {
#line 235
  p = strchr((char const   *)address, '/');
  }
#line 236
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 237
    return ((struct prefix_list *)((void *)0));
  } else
#line 236
  if (p - address >= 30L) {
#line 237
    return ((struct prefix_list *)((void *)0));
  }
  {
#line 238
  plen = atoi((char const   *)(p + 1));
  }
#line 239
  if (plen <= 0) {
#line 240
    return ((struct prefix_list *)((void *)0));
  } else
#line 239
  if (plen > 128) {
#line 240
    return ((struct prefix_list *)((void *)0));
  }
  {
#line 241
  memcpy((void */* __restrict  */)(buf___0), (void const   */* __restrict  */)address,
         (size_t )(p - address));
#line 242
  buf___0[p - address] = (char )'\000';
#line 243
  rc = inet_pton(2, (char const   */* __restrict  */)(buf___0), (void */* __restrict  */)(ipv4));
  }
#line 244
  if (rc > 0) {
#line 245
    if (plen > 32) {
#line 246
      return ((struct prefix_list *)((void *)0));
    }
#line 247
    goto return_ipv4;
  }
  {
#line 249
  rc = inet_pton(10, (char const   */* __restrict  */)(buf___0), (void */* __restrict  */)(ipv6));
  }
#line 250
  if (rc > 0) {
#line 251
    goto return_ipv6;
  }
#line 252
  return ((struct prefix_list *)((void *)0));
  switch_default: /* CIL Label */ 
  {
#line 255
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  return_ipv6: 
  {
#line 259
  tmp = calloc((size_t )1, sizeof(struct prefix_list ));
#line 259
  list = (struct prefix_list *)tmp;
  }
#line 260
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 261
    return ((struct prefix_list *)((void *)0));
  }
  {
#line 262
  list->n = 1;
#line 263
  memcpy((void */* __restrict  */)(list->l[0].p), (void const   */* __restrict  */)(ipv6),
         (size_t )16);
#line 264
  list->l[0].plen = (unsigned char )plen;
  }
#line 265
  return (list);
  return_ipv4: 
  {
#line 268
  tmp___0 = calloc((size_t )1, sizeof(struct prefix_list ));
#line 268
  list = (struct prefix_list *)tmp___0;
  }
#line 269
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 270
    return ((struct prefix_list *)((void *)0));
  }
  {
#line 271
  list->n = 1;
#line 272
  memcpy((void */* __restrict  */)(list->l[0].p), (void const   */* __restrict  */)(v4prefix),
         (size_t )12);
#line 273
  memcpy((void */* __restrict  */)(list->l[0].p + 12), (void const   */* __restrict  */)(ipv4),
         (size_t )4);
  }
#line 274
  if (plen == 255) {
#line 274
    list->l[0].plen = (unsigned char)255;
  } else {
#line 274
    list->l[0].plen = (unsigned char )(plen + 96);
  }
#line 275
  return (list);
}
}
#line 278 "/home/june/collector/temp/ahcpd-0.53/prefix.c"
struct prefix_list *cat_prefix_list(struct prefix_list *p1 , struct prefix_list *p2 ) 
{ 
  int i ;

  {
#line 283
  if ((unsigned long )p1 == (unsigned long )((void *)0)) {
#line 284
    return (p2);
  }
#line 286
  if ((unsigned long )p2 == (unsigned long )((void *)0)) {
#line 287
    return (p1);
  }
#line 289
  if (p1->n + p2->n > 8) {
#line 290
    return ((struct prefix_list *)((void *)0));
  }
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (i < p2->n)) {
#line 292
      goto while_break;
    }
#line 293
    p1->l[p1->n + i] = p2->l[i];
#line 292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  p1->n += p2->n;
#line 297
  free((void *)p2);
  }
#line 298
  return (p1);
}
}
#line 342 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 48 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
static int have_posix_clocks  =    -1;
#line 51 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
static int clock_status  =    0;
#line 55 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
time_t clock_stable_time  ;
#line 58 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
time_t ntp_check_time  =    (time_t )0;
#line 63 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
static time_t offset  ;
#line 63 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
static time_t previous  ;
#line 58 "/usr/include/x86_64-linux-gnu/sys/timex.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) adjtimex)(struct timex *__ntx ) ;
#line 69 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
static int ntp_sync(void) 
{ 
  int rc ;
  struct timex timex ;
  int tmp ;

  {
  {
#line 75
  timex.modes = 0U;
#line 77
  rc = adjtimex(& timex);
  }
#line 78
  if (rc >= 0) {
#line 78
    if (rc != 5) {
#line 78
      tmp = 1;
    } else {
#line 78
      tmp = 0;
    }
  } else {
#line 78
    tmp = 0;
  }
#line 78
  return (tmp);
}
}
#line 105 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
static void fix_clock(struct timeval *real ) 
{ 
  int tmp ;

  {
#line 108
  if (! have_posix_clocks) {
#line 109
    if (previous > real->tv_sec) {
#line 110
      offset += previous - real->tv_sec;
    } else
#line 111
    if (previous + 120L < real->tv_sec) {
#line 112
      offset += (previous + 120L) - real->tv_sec;
    }
  }
#line 116
  if (real->tv_sec < 1200000000L) {
#line 117
    clock_status = 0;
  } else {
    {
#line 118
    tmp = ntp_sync();
    }
#line 118
    if (tmp) {
#line 119
      clock_status = 2;
    } else {
#line 121
      clock_status = 1;
    }
  }
#line 122
  return;
}
}
#line 124 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
void time_init(void) 
{ 
  struct timeval now___0 ;
  struct timeval real ;
  int rc ;
  struct timespec ts ;

  {
  {
#line 131
  rc = clock_gettime(1, & ts);
#line 132
  have_posix_clocks = rc >= 0;
#line 137
  gettimeofday((struct timeval */* __restrict  */)(& real), (__timezone_ptr_t )((void *)0));
#line 138
  offset = (time_t )0;
#line 139
  previous = real.tv_sec;
#line 140
  fix_clock(& real);
#line 142
  gettime(& now___0, (time_t *)((void *)0));
#line 143
  clock_stable_time = now___0.tv_sec;
  }
#line 144
  return;
}
}
#line 150 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
void time_confirm(int confirm ) 
{ 
  struct timeval tv ;
  int tmp ;

  {
  {
#line 155
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 157
  if (tv.tv_sec < 1200000000L) {
#line 158
    clock_status = 0;
  } else
#line 157
  if (confirm == 0) {
#line 158
    clock_status = 0;
  } else {
    {
#line 159
    tmp = ntp_sync();
    }
#line 159
    if (tmp) {
#line 160
      clock_status = 2;
    } else
#line 161
    if (confirm > 0) {
#line 162
      clock_status = 1;
    }
  }
#line 163
  return;
}
}
#line 165 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
int get_real_time(struct timeval *tv , int *status_return ) 
{ 
  int rc ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 169
  rc = gettimeofday((struct timeval */* __restrict  */)tv, (__timezone_ptr_t )((void *)0));
  }
#line 170
  if (rc < 0) {
#line 171
    return (rc);
  }
#line 173
  if (tv->tv_sec < previous) {
#line 173
    tmp = 1;
  } else
#line 173
  if (tv->tv_sec > previous + 120L) {
#line 173
    tmp = 1;
  } else {
#line 173
    tmp = 0;
  }
  {
#line 173
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 173
  if (tmp___0) {
    {
#line 174
    fix_clock(tv);
    }
  }
#line 176
  previous = tv->tv_sec;
#line 178
  if (status_return) {
#line 179
    *status_return = clock_status;
  }
#line 180
  return (rc);
}
}
#line 183 "/home/june/collector/temp/ahcpd-0.53/monotonic.c"
int gettime(struct timeval *tv , time_t *stable ) 
{ 
  int rc ;
  struct timespec ts ;
  long tmp ;

  {
#line 189
  if (have_posix_clocks) {
    {
#line 192
    rc = clock_gettime(1, & ts);
    }
#line 193
    if (rc < 0) {
#line 194
      return (rc);
    }
#line 195
    tv->tv_sec = ts.tv_sec;
#line 196
    tv->tv_usec = ts.tv_nsec / 1000L;
#line 198
    if (stable) {
#line 199
      *stable = tv->tv_sec - clock_stable_time;
    }
  } else {
    {
#line 205
    rc = get_real_time(tv, (int *)((void *)0));
    }
#line 206
    if (rc < 0) {
#line 207
      return (rc);
    }
#line 208
    tv->tv_sec += offset;
  }
#line 211
  if (stable) {
#line 212
    *stable = tv->tv_sec - clock_stable_time;
  }
  {
#line 214
  tmp = __builtin_expect((long )(! (! (tv->tv_sec - ntp_check_time > 3600L))), 0L);
  }
#line 214
  if (tmp) {
    {
#line 215
    time_confirm(-1);
#line 216
    ntp_check_time = tv->tv_sec;
    }
  }
#line 219
  return (rc);
}
}
#line 184 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 23 "/home/june/collector/temp/ahcpd-0.53/transport.h"
unsigned int myseqno  ;
#line 50 "/home/june/collector/temp/ahcpd-0.53/transport.c"
struct duplicate duplicate[64]  ;
#line 51 "/home/june/collector/temp/ahcpd-0.53/transport.c"
int next_duplicate  =    0;
#line 53 "/home/june/collector/temp/ahcpd-0.53/transport.c"
static int really_send_packet(struct sockaddr *sin , int sinlen , unsigned char hopcount ,
                              unsigned char original_hopcount , unsigned char const   *nonce ,
                              unsigned char const   *src , unsigned char const   *dest ,
                              unsigned char const   *data , size_t datalen ) 
{ 
  struct iovec iovec[2] ;
  struct msghdr msg ;
  unsigned char header[24] ;
  int rc ;
  int ret ;
  unsigned char const   *tmp ;
  ssize_t tmp___0 ;
  int save ;
  int *tmp___1 ;
  int *tmp___2 ;
  int i ;
  int saved_errno ;
  struct sockaddr_in6 sin6 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 65
  header[0] = (unsigned char)43;
#line 66
  header[1] = (unsigned char)1;
#line 67
  header[2] = hopcount;
#line 68
  header[3] = original_hopcount;
#line 69
  memcpy((void */* __restrict  */)(header + 4), (void const   */* __restrict  */)nonce,
         (size_t )4);
#line 70
  memcpy((void */* __restrict  */)(header + 8), (void const   */* __restrict  */)src,
         (size_t )8);
  }
#line 71
  if (dest) {
#line 71
    tmp = dest;
  } else {
#line 71
    tmp = ones;
  }
  {
#line 71
  memcpy((void */* __restrict  */)(header + 16), (void const   */* __restrict  */)tmp,
         (size_t )8);
#line 72
  iovec[0].iov_base = (void *)(header);
#line 73
  iovec[0].iov_len = sizeof(header);
#line 74
  iovec[1].iov_base = (void *)data;
#line 75
  iovec[1].iov_len = datalen;
#line 77
  memset((void *)(& msg), 0, sizeof(msg));
#line 78
  msg.msg_iov = iovec;
#line 79
  msg.msg_iovlen = (size_t )2;
  }
#line 80
  if (sin) {
    {
#line 81
    msg.msg_name = (void *)sin;
#line 82
    msg.msg_namelen = (socklen_t )sinlen;
#line 83
    tmp___0 = sendmsg(protocol_socket, (struct msghdr  const  *)(& msg), 0);
#line 83
    rc = (int )tmp___0;
    }
#line 84
    if (rc < 0) {
      {
#line 85
      tmp___1 = __errno_location();
#line 85
      save = *tmp___1;
#line 86
      perror("send");
#line 87
      tmp___2 = __errno_location();
#line 87
      *tmp___2 = save;
      }
#line 88
      return (-1);
    }
#line 90
    return (1);
  } else {
#line 92
    saved_errno = 113;
#line 93
    ret = -1;
#line 94
    i = 0;
    {
#line 94
    while (1) {
      while_continue: /* CIL Label */ ;
#line 94
      if (! (i < numnetworks)) {
#line 94
        goto while_break;
      }
#line 96
      if (networks[i].ifindex <= 0) {
#line 97
        goto __Cont;
      }
      {
#line 98
      memset((void *)(& sin6), 0, sizeof(sin6));
#line 99
      sin6.sin6_family = (sa_family_t )10;
#line 100
      memcpy((void */* __restrict  */)(& sin6.sin6_addr), (void const   */* __restrict  */)(& protocol_group),
             (size_t )16);
#line 101
      sin6.sin6_port = htons((uint16_t )protocol_port);
#line 102
      sin6.sin6_scope_id = (uint32_t )networks[i].ifindex;
#line 103
      msg.msg_name = (void *)((struct sockaddr *)(& sin6));
#line 104
      msg.msg_namelen = (socklen_t )sizeof(sin6);
#line 105
      tmp___3 = sendmsg(protocol_socket, (struct msghdr  const  *)(& msg), 0);
#line 105
      rc = (int )tmp___3;
      }
#line 106
      if (rc < 0) {
        {
#line 107
        tmp___4 = __errno_location();
#line 107
        saved_errno = *tmp___4;
#line 108
        perror("send");
        }
      } else {
#line 111
        ret = 1;
      }
      {
#line 113
      tmp___5 = __errno_location();
#line 113
      *tmp___5 = saved_errno;
      }
      __Cont: /* CIL Label */ 
#line 94
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 115
    return (ret);
  }
}
}
#line 119 "/home/june/collector/temp/ahcpd-0.53/transport.c"
int send_packet(struct sockaddr *sin , int sinlen , unsigned char const   *dest ,
                int hopcount , unsigned char const   *buf___0 , size_t bufsize ) 
{ 
  unsigned char nonce[4] ;
  int tmp ;

  {
#line 125
  if (hopcount <= 0) {
#line 126
    return (0);
  }
  {
#line 128
  memcpy((void */* __restrict  */)(nonce), (void const   */* __restrict  */)(& myseqno),
         (size_t )4);
#line 129
  myseqno ++;
#line 131
  tmp = really_send_packet(sin, sinlen, (unsigned char )hopcount, (unsigned char )hopcount,
                           (unsigned char const   *)(nonce), (unsigned char const   *)(myid),
                           dest, buf___0, bufsize);
  }
#line 131
  return (tmp);
}
}
#line 136 "/home/june/collector/temp/ahcpd-0.53/transport.c"
static int check_duplicate(unsigned char const   *header ) 
{ 
  int i ;
  struct timeval now___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 141
  gettime(& now___0, (time_t *)((void *)0));
#line 142
  i = 0;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < 64)) {
#line 142
      goto while_break;
    }
#line 143
    if (duplicate[i].time.tv_sec < now___0.tv_sec - 120L) {
#line 144
      goto __Cont;
    }
    {
#line 145
    tmp = memcmp((void const   *)(header + 4), (void const   *)(duplicate[i].nonce),
                 (size_t )4);
    }
#line 145
    if (tmp == 0) {
      {
#line 145
      tmp___0 = memcmp((void const   *)(header + 8), (void const   *)(duplicate[i].src),
                       (size_t )8);
      }
#line 145
      if (tmp___0 == 0) {
        {
#line 145
        tmp___1 = memcmp((void const   *)(header + 16), (void const   *)(duplicate[i].dest),
                         (size_t )8);
        }
#line 145
        if (tmp___1 == 0) {
#line 148
          return (1);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return (0);
}
}
#line 153 "/home/june/collector/temp/ahcpd-0.53/transport.c"
static void record_duplicate(unsigned char const   *header ) 
{ 


  {
  {
#line 156
  memcpy((void */* __restrict  */)(duplicate[next_duplicate].nonce), (void const   */* __restrict  */)(header + 4),
         (size_t )4);
#line 157
  memcpy((void */* __restrict  */)(duplicate[next_duplicate].src), (void const   */* __restrict  */)(header + 8),
         (size_t )8);
#line 158
  memcpy((void */* __restrict  */)(duplicate[next_duplicate].dest), (void const   */* __restrict  */)(header + 16),
         (size_t )8);
#line 159
  gettime(& duplicate[next_duplicate].time, (time_t *)((void *)0));
#line 161
  next_duplicate = (next_duplicate + 1) % 64;
  }
#line 162
  return;
}
}
#line 166 "/home/june/collector/temp/ahcpd-0.53/transport.c"
int handle_packet(int ll , unsigned char const   *buf___0 , size_t buflen ) 
{ 
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;

  {
#line 169
  if (buflen < 2UL) {
    {
#line 170
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 170
      tmp = __builtin_expect((long )(! (! (debug >= 1))), 0L);
      }
#line 170
      if (tmp) {
        {
#line 170
        do_debugf(1, "Received truncated packet.\n");
        }
      }
#line 170
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 171
    return (0);
  }
#line 174
  if ((int const   )*(buf___0 + 0) != 43) {
    {
#line 175
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 175
      tmp___0 = __builtin_expect((long )(! (! (debug >= 1))), 0L);
      }
#line 175
      if (tmp___0) {
        {
#line 175
        do_debugf(1, "Received corrupted packet.\n");
        }
      }
#line 175
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 176
    return (0);
  }
#line 179
  if ((int const   )*(buf___0 + 1) != 1) {
    {
#line 180
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 180
      tmp___1 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
      }
#line 180
      if (tmp___1) {
        {
#line 180
        do_debugf(2, "Received packet with version %d.\n", (int const   )*(buf___0 + 1));
        }
      }
#line 180
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 181
    return (0);
  }
#line 184
  if (buflen < 24UL) {
    {
#line 185
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 185
      tmp___2 = __builtin_expect((long )(! (! (debug >= 1))), 0L);
      }
#line 185
      if (tmp___2) {
        {
#line 185
        do_debugf(1, "Received truncated packet.\n");
        }
      }
#line 185
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 186
    return (0);
  }
#line 189
  if ((int const   )*(buf___0 + 2) <= 0) {
#line 189
    goto _L;
  } else
#line 189
  if ((int const   )*(buf___0 + 3) <= 0) {
#line 189
    goto _L;
  } else
#line 189
  if ((int const   )*(buf___0 + 2) > (int const   )*(buf___0 + 3)) {
    _L: /* CIL Label */ 
    {
#line 190
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 190
      tmp___3 = __builtin_expect((long )(! (! (debug >= 1))), 0L);
      }
#line 190
      if (tmp___3) {
        {
#line 190
        do_debugf(1, "Received packet with zero hop count.\n");
        }
      }
#line 190
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 191
    return (0);
  }
  {
#line 194
  tmp___5 = memcmp((void const   *)(buf___0 + 8), (void const   *)(zeroes), (size_t )8);
  }
#line 194
  if (tmp___5 == 0) {
#line 194
    goto _L___0;
  } else {
    {
#line 194
    tmp___6 = memcmp((void const   *)(buf___0 + 8), (void const   *)(ones), (size_t )8);
    }
#line 194
    if (tmp___6 == 0) {
      _L___0: /* CIL Label */ 
      {
#line 195
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 195
        tmp___4 = __builtin_expect((long )(! (! (debug >= 1))), 0L);
        }
#line 195
        if (tmp___4) {
          {
#line 195
          do_debugf(1, "Received packet with martian source.\n");
          }
        }
#line 195
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 196
      return (0);
    }
  }
  {
#line 199
  tmp___8 = memcmp((void const   *)(buf___0 + 16), (void const   *)(zeroes), (size_t )8);
  }
#line 199
  if (tmp___8 == 0) {
    {
#line 200
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 200
      tmp___7 = __builtin_expect((long )(! (! (debug >= 1))), 0L);
      }
#line 200
      if (tmp___7) {
        {
#line 200
        do_debugf(1, "Received packet with martian destination.\n");
        }
      }
#line 200
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 201
    return (0);
  }
  {
#line 206
  tmp___10 = memcmp((void const   *)(buf___0 + 8), (void const   *)(myid), (size_t )8);
  }
#line 206
  if (tmp___10 == 0) {
    {
#line 207
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 207
      tmp___9 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
      }
#line 207
      if (tmp___9) {
        {
#line 207
        do_debugf(3, "Suppressed packet from self.\n");
        }
      }
#line 207
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 208
    return (0);
  }
  {
#line 211
  tmp___12 = check_duplicate(buf___0);
  }
#line 211
  if (tmp___12) {
    {
#line 212
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 212
      tmp___11 = __builtin_expect((long )(! (! (debug >= 3))), 0L);
      }
#line 212
      if (tmp___11) {
        {
#line 212
        do_debugf(3, "Suppressed duplicate.\n");
        }
      }
#line 212
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 213
    return (0);
  }
  {
#line 216
  record_duplicate(buf___0);
#line 218
  tmp___13 = memcmp((void const   *)(buf___0 + 16), (void const   *)(myid), (size_t )8);
  }
#line 218
  if (tmp___13 == 0) {
#line 219
    return (2);
  }
#line 221
  if ((int const   )*(buf___0 + 2) >= 2) {
    {
#line 222
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 222
      tmp___14 = __builtin_expect((long )(! (! (debug >= 2))), 0L);
      }
#line 222
      if (tmp___14) {
        {
#line 222
        do_debugf(2, "Forwarding packet, %d/%d hops left.\n", (int const   )*(buf___0 + 2) - 1,
                  (int const   )*(buf___0 + 3));
        }
      }
#line 222
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 225
    tmp___15 = random();
#line 225
    usleep((__useconds_t )(tmp___15 % 50000L));
#line 226
    really_send_packet((struct sockaddr *)((void *)0), 0, (unsigned char )((int const   )*(buf___0 + 2) - 1),
                       (unsigned char )*(buf___0 + 3), buf___0 + 4, buf___0 + 8, buf___0 + 16,
                       buf___0 + 24, buflen - 24UL);
    }
  }
  {
#line 232
  tmp___16 = memcmp((void const   *)(buf___0 + 16), (void const   *)(ones), (size_t )8);
  }
#line 232
  if (tmp___16 == 0) {
#line 233
    return (2);
  } else {
#line 235
    return (1);
  }
}
}
