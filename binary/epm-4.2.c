/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 176 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
struct __anonstruct_file_t_36 {
   int type ;
   mode_t mode ;
   char user[32] ;
   char group[32] ;
   char src[512] ;
   char dst[512] ;
   char options[256] ;
   char const   *subpackage ;
};
#line 176 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
typedef struct __anonstruct_file_t_36 file_t;
#line 188 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
struct __anonstruct_command_t_37 {
   int type ;
   char *command ;
   char const   *subpackage ;
   char *section ;
};
#line 188 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
typedef struct __anonstruct_command_t_37 command_t;
#line 196 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
struct __anonstruct_depend_t_38 {
   int type ;
   char product[256] ;
   char version[2][256] ;
   int vernumber[2] ;
   char const   *subpackage ;
};
#line 196 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
typedef struct __anonstruct_depend_t_38 depend_t;
#line 205 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
struct __anonstruct_description_t_39 {
   char *description ;
   char const   *subpackage ;
};
#line 205 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
typedef struct __anonstruct_description_t_39 description_t;
#line 211 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
struct __anonstruct_dist_t_40 {
   char product[256] ;
   char version[256] ;
   char release[256] ;
   char copyright[256] ;
   char vendor[256] ;
   char packager[256] ;
   char license[256] ;
   char readme[256] ;
   int num_subpackages ;
   char **subpackages ;
   int num_descriptions ;
   description_t *descriptions ;
   int vernumber ;
   int epoch ;
   int num_commands ;
   command_t *commands ;
   int num_depends ;
   depend_t *depends ;
   int num_files ;
   file_t *files ;
};
#line 211 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
typedef struct __anonstruct_dist_t_40 dist_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 44 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
struct node {
   unsigned int id ;
   char *name ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epmstring.h"
extern size_t epm_strlcat(char * , char const   * , size_t  ) ;
#line 64
extern size_t epm_strlcpy(char * , char const   * , size_t  ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 240 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
int CompressFiles ;
#line 241
char const   *DataDir ;
#line 242
int KeepFiles ;
#line 243
char const   *SetupProgram ;
#line 244
char const   *SoftwareDir ;
#line 245
char const   *UninstProgram ;
#line 246
int Verbosity ;
#line 265
extern void free_dist(dist_t *dist ) ;
#line 267
extern void get_platform(struct utsname *platform ) ;
#line 272
extern int make_aix(char const   *prodname , char const   *directory , char const   *platname ,
                    dist_t *dist , struct utsname *platform ) ;
#line 275
extern int make_bsd(char const   *prodname , char const   *directory , char const   *platname ,
                    dist_t *dist , struct utsname *platform ) ;
#line 278
extern int make_deb(char const   *prodname , char const   *directory , char const   *platname ,
                    dist_t *dist , struct utsname *platform ) ;
#line 281
extern int make_directory(char const   *directory , mode_t mode , uid_t owner , gid_t group ) ;
#line 283
extern int make_inst(char const   *prodname , char const   *directory , char const   *platname ,
                     dist_t *dist , struct utsname *platform ) ;
#line 287
extern int make_osx(char const   *prodname , char const   *directory , char const   *platname ,
                    dist_t *dist , struct utsname *platform , char const   *setup ) ;
#line 290
extern int make_pkg(char const   *prodname , char const   *directory , char const   *platname ,
                    dist_t *dist , struct utsname *platform ) ;
#line 293
extern int make_portable(char const   *prodname , char const   *directory , char const   *platname ,
                         dist_t *dist , struct utsname *platform , char const   *setup ,
                         char const   *types ) ;
#line 297
extern int make_rpm(int format , char const   *prodname , char const   *directory ,
                    char const   *platname , dist_t *dist , struct utsname *platform ,
                    char const   *setup , char const   *types ) ;
#line 301
extern int make_setld(char const   *prodname , char const   *directory , char const   *platname ,
                      dist_t *dist , struct utsname *platform ) ;
#line 304
extern int make_slackware(char const   *prodname , char const   *directory , char const   *platname ,
                          dist_t *dist , struct utsname *platform ) ;
#line 307
extern int make_swinstall(char const   *prodname , char const   *directory , char const   *platname ,
                          dist_t *dist , struct utsname *platform ) ;
#line 312
extern dist_t *read_dist(char const   *filename , struct utsname *platform , char const   *format ) ;
#line 320
extern void strip_execs(dist_t *dist ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
int CompressFiles  =    1;
#line 38 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
char const   *DataDir  =    "/usr/share/epm";
#line 39 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
int KeepFiles  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
char const   *SetupProgram  =    "/usr/lib/epm/setup";
#line 41 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
char const   *SoftwareDir  =    "/etc/software";
#line 42 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
char const   *UninstProgram  =    "/usr/lib/epm/uninst";
#line 43 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
int Verbosity  =    0;
#line 50
static void depend(dist_t *dist ) ;
#line 51
static void info___0(void) ;
#line 52
static void usage___0(void) ;
#line 78
int main(int argc , char **argv ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
static char *formats[11]  = 
#line 78
  {      (char *)"portable",      (char *)"aix",      (char *)"bsd",      (char *)"deb", 
        (char *)"inst",      (char *)"osx",      (char *)"pkg",      (char *)"rpm", 
        (char *)"setld",      (char *)"slackware",      (char *)"swinstall"};
#line 59 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int strip ;
  struct utsname platform ;
  char *namefmt ;
  char *custom_name ;
  char platname[255] ;
  char prodname[256] ;
  char listname[256] ;
  char directory[255] ;
  char *temp ;
  char *setup ;
  char *types ;
  dist_t *dist ;
  int format ;
  int show_depend ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  unsigned short const   **tmp___29 ;
  __gid_t tmp___30 ;
  __uid_t tmp___31 ;
  int tmp___32 ;
  __uid_t tmp___33 ;
  __uid_t tmp___34 ;
  __uid_t tmp___35 ;

  {
  {
#line 98
  get_platform(& platform);
  }
#line 104
  if (argc < 2) {
    {
#line 106
    puts("epm: Too few arguments!");
#line 107
    usage___0();
    }
  }
#line 110
  strip = 1;
#line 111
  format = 0;
#line 112
  setup = (char *)((void *)0);
#line 113
  types = (char *)((void *)0);
#line 114
  namefmt = (char *)"srm";
#line 115
  custom_name = (char *)0;
#line 116
  prodname[0] = (char )'\000';
#line 117
  listname[0] = (char )'\000';
#line 118
  directory[0] = (char )'\000';
#line 119
  show_depend = 0;
#line 121
  i = 1;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < argc)) {
#line 121
      goto while_break;
    }
#line 122
    if ((int )*(*(argv + i) + 0) == 45) {
      {
#line 130
      if ((int )*(*(argv + i) + 1) == 97) {
#line 130
        goto case_97;
      }
#line 148
      if ((int )*(*(argv + i) + 1) == 102) {
#line 148
        goto case_102;
      }
#line 229
      if ((int )*(*(argv + i) + 1) == 103) {
#line 229
        goto case_103;
      }
#line 233
      if ((int )*(*(argv + i) + 1) == 107) {
#line 233
        goto case_107;
      }
#line 237
      if ((int )*(*(argv + i) + 1) == 109) {
#line 237
        goto case_109;
      }
#line 253
      if ((int )*(*(argv + i) + 1) == 110) {
#line 253
        goto case_110;
      }
#line 257
      if ((int )*(*(argv + i) + 1) == 115) {
#line 257
        goto case_115;
      }
#line 273
      if ((int )*(*(argv + i) + 1) == 116) {
#line 273
        goto case_116;
      }
#line 278
      if ((int )*(*(argv + i) + 1) == 117) {
#line 278
        goto case_117;
      }
#line 282
      if ((int )*(*(argv + i) + 1) == 118) {
#line 282
        goto case_118;
      }
#line 286
      if ((int )*(*(argv + i) + 1) == 122) {
#line 286
        goto case_122;
      }
#line 290
      if ((int )*(*(argv + i) + 1) == 45) {
#line 290
        goto case_45;
      }
#line 384
      goto switch_default;
      case_97: /* CIL Label */ 
#line 131
      if (*(*(argv + i) + 2)) {
#line 132
        temp = *(argv + i) + 2;
      } else {
#line 135
        i ++;
#line 136
        if (i >= argc) {
          {
#line 138
          puts("epm: Expected architecture name.");
#line 139
          usage___0();
          }
        }
#line 142
        temp = *(argv + i);
      }
      {
#line 145
      epm_strlcpy(platform.machine, (char const   *)temp, sizeof(platform.machine));
      }
#line 146
      goto switch_break;
      case_102: /* CIL Label */ 
#line 149
      if (*(*(argv + i) + 2)) {
#line 150
        temp = *(argv + i) + 2;
      } else {
#line 153
        i ++;
#line 154
        if (i >= argc) {
          {
#line 156
          puts("epm: Expected format name.");
#line 157
          usage___0();
          }
        }
#line 160
        temp = *(argv + i);
      }
      {
#line 163
      tmp___16 = strcasecmp((char const   *)temp, "portable");
      }
#line 163
      if (tmp___16) {
        {
#line 165
        tmp___15 = strcasecmp((char const   *)temp, "aix");
        }
#line 165
        if (tmp___15) {
          {
#line 167
          tmp___14 = strcasecmp((char const   *)temp, "bsd");
          }
#line 167
          if (tmp___14) {
            {
#line 169
            tmp___13 = strcasecmp((char const   *)temp, "deb");
            }
#line 169
            if (tmp___13) {
              {
#line 171
              tmp___11 = strcasecmp((char const   *)temp, "inst");
              }
#line 171
              if (tmp___11) {
                {
#line 171
                tmp___12 = strcasecmp((char const   *)temp, "tardist");
                }
#line 171
                if (tmp___12) {
                  {
#line 174
                  tmp___10 = strcasecmp((char const   *)temp, "lsb");
                  }
#line 174
                  if (tmp___10) {
                    {
#line 176
                    tmp___9 = strcasecmp((char const   *)temp, "lsb-signed");
                    }
#line 176
                    if (tmp___9) {
                      {
#line 178
                      tmp___8 = strcasecmp((char const   *)temp, "osx");
                      }
#line 178
                      if (tmp___8) {
                        {
#line 180
                        tmp___7 = strcasecmp((char const   *)temp, "pkg");
                        }
#line 180
                        if (tmp___7) {
                          {
#line 182
                          tmp___6 = strcasecmp((char const   *)temp, "rpm");
                          }
#line 182
                          if (tmp___6) {
                            {
#line 184
                            tmp___5 = strcasecmp((char const   *)temp, "rpm-signed");
                            }
#line 184
                            if (tmp___5) {
                              {
#line 186
                              tmp___4 = strcasecmp((char const   *)temp, "setld");
                              }
#line 186
                              if (tmp___4) {
                                {
#line 188
                                tmp___3 = strcasecmp((char const   *)temp, "slackware");
                                }
#line 188
                                if (tmp___3) {
                                  {
#line 190
                                  tmp___1 = strcasecmp((char const   *)temp, "swinstall");
                                  }
#line 190
                                  if (tmp___1) {
                                    {
#line 190
                                    tmp___2 = strcasecmp((char const   *)temp, "depot");
                                    }
#line 190
                                    if (tmp___2) {
                                      {
#line 193
                                      tmp___0 = strcasecmp((char const   *)temp, "native");
                                      }
#line 193
                                      if (tmp___0) {
                                        {
#line 224
                                        printf((char const   */* __restrict  */)"epm: Unknown format \"%s\".\n",
                                               temp);
#line 225
                                        usage___0();
                                        }
                                      } else {
                                        {
#line 200
                                        tmp = access("/usr/bin/dpkg", 0);
                                        }
#line 200
                                        if (tmp) {
#line 201
                                          format = 9;
                                        } else {
#line 203
                                          format = 3;
                                        }
                                      }
                                    } else {
#line 192
                                      format = 13;
                                    }
                                  } else {
#line 192
                                    format = 13;
                                  }
                                } else {
#line 189
                                  format = 12;
                                }
                              } else {
#line 187
                                format = 11;
                              }
                            } else {
#line 185
                              format = 10;
                            }
                          } else {
#line 183
                            format = 9;
                          }
                        } else {
#line 181
                          format = 8;
                        }
                      } else {
#line 179
                        format = 7;
                      }
                    } else {
#line 177
                      format = 6;
                    }
                  } else {
#line 175
                    format = 5;
                  }
                } else {
#line 173
                  format = 4;
                }
              } else {
#line 173
                format = 4;
              }
            } else {
#line 170
              format = 3;
            }
          } else {
#line 168
            format = 2;
          }
        } else {
#line 166
          format = 1;
        }
      } else {
#line 164
        format = 0;
      }
#line 227
      goto switch_break;
      case_103: /* CIL Label */ 
#line 230
      strip = 0;
#line 231
      goto switch_break;
      case_107: /* CIL Label */ 
#line 234
      KeepFiles = 1;
#line 235
      goto switch_break;
      case_109: /* CIL Label */ 
#line 238
      if (*(*(argv + i) + 2)) {
#line 239
        custom_name = *(argv + i) + 2;
      } else {
#line 242
        i ++;
#line 243
        if (i >= argc) {
          {
#line 245
          puts("epm: Expected custom system name string.");
#line 246
          usage___0();
          }
        }
#line 249
        custom_name = *(argv + i);
      }
#line 251
      goto switch_break;
      case_110: /* CIL Label */ 
#line 254
      namefmt = *(argv + i) + 2;
#line 255
      goto switch_break;
      case_115: /* CIL Label */ 
#line 258
      if (*(*(argv + i) + 2)) {
#line 259
        setup = *(argv + i) + 2;
      } else {
#line 262
        i ++;
#line 263
        if (i >= argc) {
          {
#line 265
          puts("epm: Expected setup image.");
#line 266
          usage___0();
          }
        }
#line 269
        setup = *(argv + i);
      }
#line 271
      goto switch_break;
      case_116: /* CIL Label */ 
      {
#line 274
      fputs((char const   */* __restrict  */)"epm: Sorry, the \"test\" option is no longer available!\n",
            (FILE */* __restrict  */)stderr);
      }
#line 276
      goto switch_break;
      case_117: /* CIL Label */ 
#line 279
      CompressFiles = 0;
#line 280
      goto switch_break;
      case_118: /* CIL Label */ 
      {
#line 283
      tmp___17 = strlen((char const   *)*(argv + i));
#line 283
      Verbosity = (int )((size_t )Verbosity + (tmp___17 - 1UL));
      }
#line 284
      goto switch_break;
      case_122: /* CIL Label */ 
#line 287
      CompressFiles = 1;
#line 288
      goto switch_break;
      case_45: /* CIL Label */ 
      {
#line 291
      tmp___27 = strcmp((char const   *)*(argv + i), "--data-dir");
      }
#line 291
      if (tmp___27) {
        {
#line 302
        tmp___26 = strcmp((char const   *)*(argv + i), "--depend");
        }
#line 302
        if (tmp___26) {
          {
#line 304
          tmp___25 = strcmp((char const   *)*(argv + i), "--keep-files");
          }
#line 304
          if (tmp___25) {
            {
#line 306
            tmp___24 = strcmp((char const   *)*(argv + i), "--output-dir");
            }
#line 306
            if (tmp___24) {
              {
#line 317
              tmp___23 = strcmp((char const   *)*(argv + i), "--setup-image");
              }
#line 317
              if (tmp___23) {
                {
#line 328
                tmp___22 = strcmp((char const   *)*(argv + i), "--setup-program");
                }
#line 328
                if (tmp___22) {
                  {
#line 339
                  tmp___21 = strcmp((char const   *)*(argv + i), "--setup-types");
                  }
#line 339
                  if (tmp___21) {
                    {
#line 350
                    tmp___20 = strcmp((char const   *)*(argv + i), "--software-dir");
                    }
#line 350
                    if (tmp___20) {
                      {
#line 361
                      tmp___19 = strcmp((char const   *)*(argv + i), "--uninstall-program");
                      }
#line 361
                      if (tmp___19) {
                        {
#line 372
                        tmp___18 = strcmp((char const   *)*(argv + i), "--version");
                        }
#line 372
                        if (tmp___18) {
                          {
#line 379
                          printf((char const   */* __restrict  */)"epm: Unknown option \"%s\".\n",
                                 *(argv + i));
#line 380
                          usage___0();
                          }
                        } else {
                          {
#line 374
                          info___0();
                          }
#line 375
                          return (0);
                        }
                      } else {
#line 363
                        i ++;
#line 364
                        if (i < argc) {
#line 365
                          UninstProgram = (char const   *)*(argv + i);
                        } else {
                          {
#line 368
                          puts("epm: Expected uninstall program.");
#line 369
                          usage___0();
                          }
                        }
                      }
                    } else {
#line 352
                      i ++;
#line 353
                      if (i < argc) {
#line 354
                        SoftwareDir = (char const   *)*(argv + i);
                      } else {
                        {
#line 357
                        puts("epm: Expected software directory.");
#line 358
                        usage___0();
                        }
                      }
                    }
                  } else {
#line 341
                    i ++;
#line 342
                    if (i < argc) {
#line 343
                      types = *(argv + i);
                    } else {
                      {
#line 346
                      puts("epm: Expected setup.types file.");
#line 347
                      usage___0();
                      }
                    }
                  }
                } else {
#line 330
                  i ++;
#line 331
                  if (i < argc) {
#line 332
                    SetupProgram = (char const   *)*(argv + i);
                  } else {
                    {
#line 335
                    puts("epm: Expected setup program.");
#line 336
                    usage___0();
                    }
                  }
                }
              } else {
#line 319
                i ++;
#line 320
                if (i < argc) {
#line 321
                  setup = *(argv + i);
                } else {
                  {
#line 324
                  puts("epm: Expected setup image.");
#line 325
                  usage___0();
                  }
                }
              }
            } else {
#line 308
              i ++;
#line 309
              if (i < argc) {
                {
#line 310
                epm_strlcpy(directory, (char const   *)*(argv + i), sizeof(directory));
                }
              } else {
                {
#line 313
                puts("epm: Expected output directory.");
#line 314
                usage___0();
                }
              }
            }
          } else {
#line 305
            KeepFiles = 1;
          }
        } else {
#line 303
          show_depend = 1;
        }
      } else {
#line 293
        i ++;
#line 294
        if (i < argc) {
#line 295
          DataDir = (char const   *)*(argv + i);
        } else {
          {
#line 298
          puts("epm: Expected data directory.");
#line 299
          usage___0();
          }
        }
      }
#line 382
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 385
      printf((char const   */* __restrict  */)"epm: Unknown option \"%s\".\n", *(argv + i));
#line 386
      usage___0();
      }
#line 387
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 390
      tmp___28 = strchr((char const   *)*(argv + i), '=');
      }
#line 390
      if ((unsigned long )tmp___28 != (unsigned long )((void *)0)) {
        {
#line 391
        putenv(*(argv + i));
        }
      } else
#line 392
      if ((int )prodname[0] == 0) {
        {
#line 393
        strcpy((char */* __restrict  */)(prodname), (char const   */* __restrict  */)*(argv + i));
        }
      } else
#line 394
      if ((int )listname[0] == 0) {
        {
#line 395
        strcpy((char */* __restrict  */)(listname), (char const   */* __restrict  */)*(argv + i));
        }
      } else {
        {
#line 398
        printf((char const   */* __restrict  */)"epm: Unknown argument \"%s\".\n",
               *(argv + i));
#line 399
        usage___0();
        }
      }
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  if (! prodname[0]) {
    {
#line 408
    puts("epm: No product name specified!");
#line 409
    usage___0();
    }
  }
#line 412
  i = 0;
  {
#line 412
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 412
    if (! prodname[i]) {
#line 412
      goto while_break___0;
    }
    {
#line 413
    tmp___29 = __ctype_b_loc();
    }
#line 413
    if (! ((int const   )*(*tmp___29 + ((int )prodname[i] & 255)) & 8)) {
      {
#line 415
      puts("epm: Product names should only contain letters and numbers!");
      }
#line 416
      goto while_break___0;
    }
#line 412
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 419
  if (! listname[0]) {
    {
#line 420
    snprintf((char */* __restrict  */)(listname), sizeof(listname), (char const   */* __restrict  */)"%s.list",
             prodname);
    }
  }
#line 426
  if (! directory[0]) {
#line 432
    if (custom_name) {
      {
#line 433
      sprintf((char */* __restrict  */)(directory), (char const   */* __restrict  */)"%s",
              custom_name);
      }
    } else {
      {
#line 435
      snprintf((char */* __restrict  */)(directory), sizeof(directory), (char const   */* __restrict  */)"%s-%s-%s",
               platform.sysname, platform.release, platform.machine);
      }
    }
  }
#line 439
  platname[0] = (char )'\000';
#line 441
  if (custom_name) {
    {
#line 442
    epm_strlcat(platname, (char const   *)custom_name, sizeof(platname));
    }
  } else {
#line 445
    temp = namefmt;
    {
#line 445
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 445
      if (! ((int )*temp != 0)) {
#line 445
        goto while_break___1;
      }
#line 447
      if (platname[0]) {
        {
#line 448
        epm_strlcat(platname, "-", sizeof(platname));
        }
      }
#line 450
      if ((int )*temp == 109) {
        {
#line 451
        epm_strlcat(platname, (char const   *)(platform.machine), sizeof(platname));
        }
      } else
#line 452
      if ((int )*temp == 114) {
        {
#line 453
        epm_strlcat(platname, (char const   *)(platform.release), sizeof(platname));
        }
      } else
#line 454
      if ((int )*temp == 115) {
        {
#line 455
        epm_strlcat(platname, (char const   *)(platform.sysname), sizeof(platname));
        }
      } else {
        {
#line 458
        printf((char const   */* __restrict  */)"epm: Bad name format character \"%c\" in \"%s\".\n",
               (int )*temp, namefmt);
#line 460
        usage___0();
        }
      }
#line 445
      temp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 469
  if (Verbosity) {
    {
#line 470
    info___0();
    }
  }
  {
#line 476
  dist = read_dist((char const   *)(listname), & platform, (char const   *)formats[format]);
  }
#line 476
  if ((unsigned long )dist == (unsigned long )((void *)0)) {
#line 477
    return (1);
  }
#line 483
  if (! dist->product[0]) {
    {
#line 489
    fputs((char const   */* __restrict  */)"epm: Error - missing %product, %copyright, %vendor, %license,\n",
          (FILE */* __restrict  */)stderr);
#line 490
    fputs((char const   */* __restrict  */)"     %readme, or %version attributes in list file!\n",
          (FILE */* __restrict  */)stderr);
#line 492
    free_dist(dist);
    }
#line 494
    return (1);
  } else
#line 483
  if (! dist->copyright[0]) {
    {
#line 489
    fputs((char const   */* __restrict  */)"epm: Error - missing %product, %copyright, %vendor, %license,\n",
          (FILE */* __restrict  */)stderr);
#line 490
    fputs((char const   */* __restrict  */)"     %readme, or %version attributes in list file!\n",
          (FILE */* __restrict  */)stderr);
#line 492
    free_dist(dist);
    }
#line 494
    return (1);
  } else
#line 483
  if (! dist->vendor[0]) {
    {
#line 489
    fputs((char const   */* __restrict  */)"epm: Error - missing %product, %copyright, %vendor, %license,\n",
          (FILE */* __restrict  */)stderr);
#line 490
    fputs((char const   */* __restrict  */)"     %readme, or %version attributes in list file!\n",
          (FILE */* __restrict  */)stderr);
#line 492
    free_dist(dist);
    }
#line 494
    return (1);
  } else
#line 483
  if (! dist->license[0]) {
#line 483
    if (! dist->readme[0]) {
      {
#line 489
      fputs((char const   */* __restrict  */)"epm: Error - missing %product, %copyright, %vendor, %license,\n",
            (FILE */* __restrict  */)stderr);
#line 490
      fputs((char const   */* __restrict  */)"     %readme, or %version attributes in list file!\n",
            (FILE */* __restrict  */)stderr);
#line 492
      free_dist(dist);
      }
#line 494
      return (1);
    } else {
#line 483
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 483
  if (! dist->version[0]) {
    {
#line 489
    fputs((char const   */* __restrict  */)"epm: Error - missing %product, %copyright, %vendor, %license,\n",
          (FILE */* __restrict  */)stderr);
#line 490
    fputs((char const   */* __restrict  */)"     %readme, or %version attributes in list file!\n",
          (FILE */* __restrict  */)stderr);
#line 492
    free_dist(dist);
    }
#line 494
    return (1);
  }
#line 497
  if (dist->num_files == 0) {
    {
#line 499
    fputs((char const   */* __restrict  */)"epm: Error - no files for installation in list file!\n",
          (FILE */* __restrict  */)stderr);
#line 501
    free_dist(dist);
    }
#line 503
    return (1);
  }
#line 510
  if (show_depend) {
    {
#line 512
    depend(dist);
#line 514
    free_dist(dist);
    }
#line 516
    return (0);
  }
#line 523
  if (strip) {
#line 525
    if (Verbosity) {
      {
#line 526
      puts("Stripping executables in distribution...");
      }
    }
    {
#line 528
    strip_execs(dist);
    }
  }
  {
#line 535
  tmp___30 = getgid();
#line 535
  tmp___31 = getuid();
#line 535
  make_directory((char const   *)(directory), (mode_t )511, tmp___31, tmp___30);
#line 541
  tmp___32 = access(SetupProgram, 0);
  }
#line 541
  if (tmp___32) {
#line 541
    if (setup) {
      {
#line 543
      puts("epm: Setup program not installed, creating non-GUI package.");
#line 544
      setup = (char *)((void *)0);
      }
    }
  }
  {
#line 549
  if (format == 0) {
#line 549
    goto case_0;
  }
#line 553
  if (format == 1) {
#line 553
    goto case_1;
  }
#line 556
  if (format == 2) {
#line 556
    goto case_2;
  }
#line 559
  if (format == 12) {
#line 559
    goto case_12;
  }
#line 562
  if (format == 3) {
#line 562
    goto case_3;
  }
#line 569
  if (format == 4) {
#line 569
    goto case_4;
  }
#line 572
  if (format == 7) {
#line 572
    goto case_7;
  }
#line 575
  if (format == 8) {
#line 575
    goto case_8;
  }
#line 581
  if (format == 10) {
#line 581
    goto case_10;
  }
#line 581
  if (format == 9) {
#line 581
    goto case_10;
  }
#line 581
  if (format == 6) {
#line 581
    goto case_10;
  }
#line 581
  if (format == 5) {
#line 581
    goto case_10;
  }
#line 585
  if (format == 11) {
#line 585
    goto case_11;
  }
#line 592
  if (format == 13) {
#line 592
    goto case_13;
  }
#line 547
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 550
  i = make_portable((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
                    dist, & platform, (char const   *)setup, (char const   *)types);
  }
#line 552
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 554
  i = make_aix((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
               dist, & platform);
  }
#line 555
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 557
  i = make_bsd((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
               dist, & platform);
  }
#line 558
  goto switch_break___0;
  case_12: /* CIL Label */ 
  {
#line 560
  i = make_slackware((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
                     dist, & platform);
  }
#line 561
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 563
  tmp___33 = geteuid();
  }
#line 563
  if (tmp___33) {
    {
#line 564
    fputs((char const   */* __restrict  */)"epm: Warning - file permissions and ownership may not be correct\n     in Debian packages unless you run EPM as root!\n",
          (FILE */* __restrict  */)stderr);
    }
  }
  {
#line 567
  i = make_deb((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
               dist, & platform);
  }
#line 568
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 570
  i = make_inst((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
                dist, & platform);
  }
#line 571
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 573
  i = make_osx((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
               dist, & platform, (char const   *)setup);
  }
#line 574
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 576
  i = make_pkg((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
               dist, & platform);
  }
#line 577
  goto switch_break___0;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 582
  i = make_rpm(format, (char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
               dist, & platform, (char const   *)setup, (char const   *)types);
  }
#line 584
  goto switch_break___0;
  case_11: /* CIL Label */ 
  {
#line 586
  tmp___34 = geteuid();
  }
#line 586
  if (tmp___34) {
    {
#line 587
    fputs((char const   */* __restrict  */)"epm: Warning - file permissions and ownership may not be correct\n     in Tru64 packages unless you run EPM as root!\n",
          (FILE */* __restrict  */)stderr);
    }
  }
  {
#line 590
  i = make_setld((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
                 dist, & platform);
  }
#line 591
  goto switch_break___0;
  case_13: /* CIL Label */ 
  {
#line 593
  tmp___35 = geteuid();
  }
#line 593
  if (tmp___35) {
    {
#line 595
    fputs((char const   */* __restrict  */)"epm: Error - HP-UX packages must be built as root!\n",
          (FILE */* __restrict  */)stderr);
#line 596
    i = 1;
    }
  } else {
    {
#line 599
    i = make_swinstall((char const   *)(prodname), (char const   *)(directory), (char const   *)(platname),
                       dist, & platform);
    }
  }
#line 600
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 607
  free_dist(dist);
  }
#line 609
  if (i) {
    {
#line 610
    puts("Packaging failed!");
    }
  } else
#line 611
  if (Verbosity) {
    {
#line 612
    puts("Done!");
    }
  }
#line 614
  return (i);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
static void depend(dist_t *dist ) 
{ 
  int i ;
  file_t *file ;

  {
#line 629
  i = dist->num_files;
#line 629
  file = dist->files;
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 629
    if (! (i > 0)) {
#line 629
      goto while_break;
    }
    {
#line 637
    if (file->type == 73) {
#line 637
      goto case_73;
    }
#line 637
    if (file->type == 70) {
#line 637
      goto case_73;
    }
#line 637
    if (file->type == 67) {
#line 637
      goto case_73;
    }
#line 637
    if (file->type == 105) {
#line 637
      goto case_73;
    }
#line 637
    if (file->type == 102) {
#line 637
      goto case_73;
    }
#line 637
    if (file->type == 99) {
#line 637
      goto case_73;
    }
#line 630
    goto switch_break;
    case_73: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_99: /* CIL Label */ 
    {
#line 638
    puts((char const   *)(file->src));
    }
#line 639
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 629
    i --;
#line 629
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  return;
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
static void info___0(void) 
{ 


  {
  {
#line 651
  puts("ESP Package Manager v4.2");
#line 652
  puts("Copyright 1999-2007 by Easy Software Products.");
#line 653
  puts("");
#line 654
  puts("EPM is free software and comes with ABSOLUTELY NO WARRANTY; for details");
#line 655
  puts("see the GNU General Public License in the file COPYING or at");
#line 656
  puts("\"http://www.fsf.org/gpl.html\".  Report all problems to \"epm@easysw.com\".");
#line 657
  puts("");
  }
#line 658
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.c"
static void usage___0(void) 
{ 


  {
  {
#line 668
  info___0();
#line 670
  puts("Usage: epm [options] [name=value ... name=value] product [list-file]");
#line 671
  puts("Options:");
#line 672
  puts("-a arch");
#line 673
  puts("    Use the named architecture instead of the local one.");
#line 674
  puts("-g");
#line 675
  puts("    Don\'t strip executables in distributions.");
#line 676
  puts("-f {aix,bsd,deb,depot,inst,native,pkg,portable,rpm,setld,slackware,swinstall,tardist}");
#line 677
  puts("    Set distribution format.");
#line 678
  puts("-k");
#line 679
  puts("    Keep intermediate files (spec files, etc.)");
#line 680
  puts("-m name");
#line 681
  puts("    Set distribution filename to include the specified platform name.");
#line 682
  puts("    This overrides \"-n\".");
#line 683
  puts("-n[mrs]");
#line 684
  puts("    Set distribution filename to include machine (m), OS release (r),");
#line 685
  puts("    and/or OS name (s).");
#line 686
  puts("-s setup.xpm");
#line 687
  puts("    Enable the setup GUI and use \"setup.xpm\" for the setup image.");
#line 688
  puts("-u");
#line 692
  puts("    Do not compress files in packages.");
#line 694
  puts("-v");
#line 695
  puts("    Be verbose.");
#line 696
  puts("-z");
#line 698
  puts("    Compress files in packages (default).");
#line 702
  puts("--data-dir /foo/bar/directory");
#line 703
  puts("    Use the named setup data file directory instead of /usr/share/epm.");
#line 704
  puts("--help");
#line 705
  puts("    Show this usage message.");
#line 706
  puts("--keep-files");
#line 707
  puts("    Keep temporary distribution files in the output directory.");
#line 708
  puts("--output-dir /foo/bar/directory");
#line 709
  puts("    Enable the setup GUI and use \"setup.xpm\" for the setup image.");
#line 710
  puts("--setup-image setup.xpm");
#line 711
  puts("    Enable the setup GUI and use \"setup.xpm\" for the setup image.");
#line 712
  puts("--setup-program /foo/bar/setup");
#line 713
  puts("    Use the named setup program instead of /usr/lib/epm/setup.");
#line 714
  puts("--setup-types setup.types");
#line 715
  puts("    Include the named setup.types file with the distribution.");
#line 716
  puts("--uninstalll-program /foo/bar/uninst");
#line 717
  puts("    Use the named uninstall program instead of /usr/lib/epm/uninst.");
#line 718
  puts("--version");
#line 719
  puts("    Show EPM version.");
#line 721
  exit(1);
  }
}
}
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 809 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 260 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
extern file_t *add_file(dist_t *dist , char const   *subpkg ) ;
#line 319
extern void sort_dist_files(dist_t *dist ) ;
#line 337
extern int write_dist(char const   *listname , dist_t *dist ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epminstall.c"
static file_t *find_file(dist_t *dist , char const   *dst ) ;
#line 45
static void info___1(void) ;
#line 46
static  __attribute__((__noreturn__)) void usage___1(void) ;
#line 356 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epminstall.c"
static file_t *find_file(dist_t *dist , char const   *dst ) 
{ 
  int i ;
  file_t *file ;
  int tmp ;

  {
#line 364
  i = dist->num_files;
#line 364
  file = dist->files;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (i > 0)) {
#line 364
      goto while_break;
    }
    {
#line 365
    tmp = strcmp((char const   *)(file->dst), dst);
    }
#line 365
    if (tmp == 0) {
#line 366
      return (file);
    }
#line 364
    i --;
#line 364
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return ((file_t *)((void *)0));
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epminstall.c"
static void info___1(void) 
{ 


  {
  {
#line 379
  puts("ESP Package Manager v4.2");
#line 380
  puts("Copyright 1999-2005 by Easy Software Products.");
#line 381
  puts("");
#line 382
  puts("EPM is free software and comes with ABSOLUTELY NO WARRANTY; for details");
#line 383
  puts("see the GNU General Public License in the file COPYING or at");
#line 384
  puts("\"http://www.fsf.org/gpl.html\".  Report all problems to \"epm@easysw.com\".");
#line 385
  puts("");
  }
#line 386
  return;
}
}
#line 393
static  __attribute__((__noreturn__)) void usage___1(void) ;
#line 393 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epminstall.c"
static void usage___1(void) 
{ 


  {
  {
#line 396
  info___1();
#line 398
  puts("Usage: epminstall [options] file1 file2 ... fileN directory");
#line 399
  puts("       epminstall [options] file1 file2");
#line 400
  puts("       epminstall [options] -d directory1 directory2 ... directoryN");
#line 401
  puts("Options:");
#line 402
  puts("-g group");
#line 403
  puts("    Set group of installed file(s).");
#line 404
  puts("-m mode");
#line 405
  puts("    Set permissions of installed file(s).");
#line 406
  puts("-u owner");
#line 407
  puts("    Set owner of installed file(s).");
#line 409
  exit(1);
  }
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 110
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 62 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 105
extern struct group *getgrgid(__gid_t __gid ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 311 "/home/june/repo/benchmarks/collector/temp/epm-4.2/epm.h"
extern int qprintf(FILE *fp , char const   *format  , ...) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
char *DefaultUser  =    (char *)((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
char *DefaultGroup  =    (char *)((void *)0);
#line 57 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
struct node Users[101]  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
struct node Groups[101]  ;
#line 65
char *get_group(gid_t gid ) ;
#line 66
char *get_user(uid_t uid ) ;
#line 67
void hash_deinit(struct node *a ) ;
#line 68
unsigned int hash_id(unsigned int id ) ;
#line 69
void hash_init(struct node *a ) ;
#line 70
char *hash_insert(struct node *a , unsigned int id , char const   *name ) ;
#line 72
char *hash_search(struct node *a , unsigned int id ) ;
#line 73
void info(void) ;
#line 74
int process_dir(char const   *srcpath , char const   *dstpath ) ;
#line 75
int process_file(char const   *src , char const   *dstpath ) ;
#line 76
void usage(void) ;
#line 236 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
char *get_group(gid_t gid ) 
{ 
  char *name ;
  struct group *gr ;
  char buf[16] ;
  char *tmp ;

  {
#line 248
  if (DefaultGroup) {
#line 249
    return (DefaultGroup);
  }
  {
#line 255
  name = hash_search(Groups, gid);
  }
#line 255
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 256
    return (name);
  }
  {
#line 262
  setgrent();
#line 264
  gr = getgrgid(gid);
  }
#line 264
  if ((unsigned long )gr != (unsigned long )((void *)0)) {
#line 265
    name = gr->gr_name;
  } else {
    {
#line 272
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%u",
            gid);
#line 273
    name = buf;
    }
  }
  {
#line 280
  tmp = hash_insert(Groups, gid, (char const   *)name);
  }
#line 280
  return (tmp);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
char *get_user(uid_t uid ) 
{ 
  char *name ;
  struct passwd *pw ;
  char buf[16] ;
  char *tmp ;

  {
#line 300
  if (DefaultUser) {
#line 301
    return (DefaultUser);
  }
  {
#line 307
  name = hash_search(Users, uid);
  }
#line 307
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 308
    return (name);
  }
  {
#line 314
  setpwent();
#line 316
  pw = getpwuid(uid);
  }
#line 316
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 317
    name = pw->pw_name;
  } else {
    {
#line 324
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%u",
            uid);
#line 325
    name = buf;
    }
  }
  {
#line 332
  tmp = hash_insert(Users, uid, (char const   *)name);
  }
#line 332
  return (tmp);
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
void hash_deinit(struct node *a ) 
{ 
  unsigned int h ;

  {
#line 346
  h = 0U;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (h < 101U)) {
#line 346
      goto while_break;
    }
#line 347
    if ((a + h)->name) {
      {
#line 349
      free((void *)(a + h)->name);
#line 350
      memset((void *)a, 0, sizeof(struct node ));
      }
    }
#line 346
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  return;
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
unsigned int hash_id(unsigned int id ) 
{ 


  {
#line 362
  return (id % 101U);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
void hash_init(struct node *a ) 
{ 


  {
  {
#line 377
  memset((void *)a, 0, 101UL * sizeof(struct node ));
  }
#line 378
  return;
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
char *hash_insert(struct node *a , unsigned int id , char const   *name ) 
{ 
  unsigned int h ;
  unsigned int start ;

  {
  {
#line 394
  start = hash_id(id);
#line 394
  h = start;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (a + h)->name) {
#line 394
      goto while_break;
    }
#line 396
    h = (h + 1U) % 101U;
#line 397
    if (h == start) {
#line 398
      return ((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 401
  (a + h)->id = id;
#line 402
  (a + h)->name = strdup(name);
  }
#line 404
  return ((a + h)->name);
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
char *hash_search(struct node *a , unsigned int id ) 
{ 
  unsigned int h ;
  unsigned int start ;

  {
  {
#line 420
  start = hash_id(id);
#line 420
  h = start;
  }
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! (a + h)->name) {
#line 420
      goto while_break;
    }
#line 422
    h = (h + 1U) % 101U;
#line 424
    if ((a + h)->id == id) {
#line 425
      return ((a + h)->name);
    }
#line 427
    if (h == start) {
#line 428
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  return ((char *)((void *)0));
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
void info(void) 
{ 


  {
  {
#line 442
  puts("ESP Package Manager v4.2");
#line 443
  puts("Copyright 1999-2005 by Easy Software Products.");
#line 444
  puts("");
#line 445
  puts("EPM is free software and comes with ABSOLUTELY NO WARRANTY; for details");
#line 446
  puts("see the GNU General Public License in the file COPYING or at");
#line 447
  puts("\"http://www.fsf.org/gpl.html\".  Report all problems to \"epm@easysw.com\".");
#line 448
  puts("");
  }
#line 449
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
int process_dir(char const   *srcpath , char const   *dstpath ) 
{ 
  DIR *dir ;
  struct dirent *dent ;
  int srclen ;
  char src[1024] ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 470
  dir = opendir(srcpath);
  }
#line 470
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 472
    tmp = __errno_location();
#line 472
    tmp___0 = strerror(*tmp);
#line 472
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mkepmlist: Unable to open directory \"%s\" - %s.\n",
            srcpath, tmp___0);
    }
#line 475
    return (-1);
  }
  {
#line 482
  tmp___1 = strlen(srcpath);
#line 482
  srclen = (int )tmp___1;
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 484
    dent = readdir(dir);
    }
#line 484
    if (! ((unsigned long )dent != (unsigned long )((void *)0))) {
#line 484
      goto while_break;
    }
    {
#line 490
    tmp___2 = strcmp((char const   *)(dent->d_name), ".");
    }
#line 490
    if (tmp___2 == 0) {
#line 492
      goto while_continue;
    } else {
      {
#line 490
      tmp___3 = strcmp((char const   *)(dent->d_name), "..");
      }
#line 490
      if (tmp___3 == 0) {
#line 492
        goto while_continue;
      }
    }
#line 498
    if (srclen > 0) {
#line 498
      if ((int const   )*(srcpath + (srclen - 1)) == 47) {
        {
#line 499
        snprintf((char */* __restrict  */)(src), sizeof(src), (char const   */* __restrict  */)"%s%s",
                 srcpath, dent->d_name);
        }
      } else {
        {
#line 501
        snprintf((char */* __restrict  */)(src), sizeof(src), (char const   */* __restrict  */)"%s/%s",
                 srcpath, dent->d_name);
        }
      }
    } else {
      {
#line 501
      snprintf((char */* __restrict  */)(src), sizeof(src), (char const   */* __restrict  */)"%s/%s",
               srcpath, dent->d_name);
      }
    }
    {
#line 503
    tmp___4 = process_file((char const   *)(src), dstpath);
    }
#line 503
    if (tmp___4) {
      {
#line 505
      closedir(dir);
      }
#line 506
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 510
  closedir(dir);
  }
#line 511
  return (0);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
int process_file(char const   *src , char const   *dstpath ) 
{ 
  char const   *srcptr ;
  struct stat srcinfo ;
  int linklen ;
  int dstlen ;
  char link___0[1024] ;
  char dst[1024] ;
  size_t tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  ssize_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 535
  tmp = strlen(dstpath);
#line 535
  dstlen = (int )tmp;
#line 537
  tmp___0 = strrchr(src, '/');
#line 537
  srcptr = (char const   *)tmp___0;
  }
#line 537
  if ((unsigned long )srcptr != (unsigned long )((void *)0)) {
#line 538
    srcptr ++;
  } else {
#line 540
    srcptr = src;
  }
#line 542
  if (dstlen > 0) {
#line 542
    if ((int const   )*(dstpath + (dstlen - 1)) == 47) {
      {
#line 543
      snprintf((char */* __restrict  */)(dst), sizeof(dst), (char const   */* __restrict  */)"%s%s",
               dstpath, srcptr);
      }
    } else {
      {
#line 545
      snprintf((char */* __restrict  */)(dst), sizeof(dst), (char const   */* __restrict  */)"%s/%s",
               dstpath, srcptr);
      }
    }
  } else {
    {
#line 545
    snprintf((char */* __restrict  */)(dst), sizeof(dst), (char const   */* __restrict  */)"%s/%s",
             dstpath, srcptr);
    }
  }
  {
#line 547
  tmp___3 = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& srcinfo));
  }
#line 547
  if (tmp___3) {
    {
#line 549
    tmp___1 = __errno_location();
#line 549
    tmp___2 = strerror(*tmp___1);
#line 549
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mkepmlist: Unable to stat \"%s\" - %s.\n",
            src, tmp___2);
    }
#line 551
    return (-1);
  }
#line 558
  if ((srcinfo.st_mode & 61440U) == 16384U) {
    {
#line 564
    tmp___4 = get_group(srcinfo.st_gid);
#line 564
    tmp___5 = get_user(srcinfo.st_uid);
#line 564
    qprintf(stdout, "d %o %s %s %s -\n", srcinfo.st_mode & 4095U, tmp___5, tmp___4,
            dst);
#line 567
    tmp___6 = process_dir(src, (char const   *)(dst));
    }
#line 567
    if (tmp___6) {
#line 568
      return (-1);
    }
  } else
#line 570
  if ((srcinfo.st_mode & 61440U) == 40960U) {
    {
#line 576
    tmp___9 = readlink((char const   */* __restrict  */)src, (char */* __restrict  */)(link___0),
                       sizeof(link___0) - 1UL);
#line 576
    linklen = (int )tmp___9;
    }
#line 576
    if (linklen < 0) {
      {
#line 578
      tmp___7 = __errno_location();
#line 578
      tmp___8 = strerror(*tmp___7);
#line 578
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mkepmlist: Unable to read symlink \"%s\" - %s.\n",
              src, tmp___8);
      }
#line 580
      return (-1);
    }
    {
#line 583
    link___0[linklen] = (char )'\000';
#line 585
    tmp___10 = get_group(srcinfo.st_gid);
#line 585
    tmp___11 = get_user(srcinfo.st_uid);
#line 585
    qprintf(stdout, "l %o %s %s %s %s\n", srcinfo.st_mode & 4095U, tmp___11, tmp___10,
            dst, link___0);
    }
  } else
#line 589
  if ((srcinfo.st_mode & 61440U) == 32768U) {
    {
#line 595
    tmp___12 = get_group(srcinfo.st_gid);
#line 595
    tmp___13 = get_user(srcinfo.st_uid);
#line 595
    qprintf(stdout, "f %o %s %s %s %s\n", srcinfo.st_mode & 4095U, tmp___13, tmp___12,
            dst, src);
    }
  }
#line 600
  return (0);
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/epm-4.2/mkepmlist.c"
void usage(void) 
{ 


  {
  {
#line 611
  info();
#line 613
  puts("Usage: mkepmlist [options] directory [... directory] >filename.list");
#line 614
  puts("Options:");
#line 615
  puts("-g group              Set group name for files.");
#line 616
  puts("-u user               Set user name for files.");
#line 617
  puts("--prefix directory    Set directory prefix for files.");
#line 619
  exit(1);
  }
}
}
