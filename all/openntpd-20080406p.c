/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 44 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.h"
struct l_fixedpt {
   u_int32_t int_partl ;
   u_int32_t fractionl ;
};
#line 49 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.h"
struct s_fixedpt {
   u_int16_t int_parts ;
   u_int16_t fractions ;
};
#line 98 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.h"
struct ntp_msg {
   u_int8_t status ;
   u_int8_t stratum ;
   u_int8_t ppoll ;
   int8_t precision ;
   struct s_fixedpt rootdelay ;
   struct s_fixedpt dispersion ;
   u_int32_t refid ;
   struct l_fixedpt reftime ;
   struct l_fixedpt orgtime ;
   struct l_fixedpt rectime ;
   struct l_fixedpt xmttime ;
};
#line 112 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.h"
struct ntp_query {
   int fd ;
   struct ntp_msg msg ;
   double xmttime ;
};
#line 75 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
enum client_state {
    STATE_NONE = 0,
    STATE_DNS_INPROGRESS = 1,
    STATE_DNS_TEMPFAIL = 2,
    STATE_DNS_DONE = 3,
    STATE_QUERY_SENT = 4,
    STATE_REPLY_RECEIVED = 5
} ;
#line 84 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct __anonstruct_entry_65 {
   struct listen_addr *tqe_next ;
   struct listen_addr **tqe_prev ;
};
#line 84 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct listen_addr {
   struct __anonstruct_entry_65 entry ;
   struct sockaddr_storage sa ;
   int fd ;
};
#line 90 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_addr {
   struct ntp_addr *next ;
   struct sockaddr_storage ss ;
};
#line 95 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_addr_wrap {
   char *name ;
   struct ntp_addr *a ;
   u_int8_t pool ;
};
#line 101 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_status {
   double rootdelay ;
   double rootdispersion ;
   double reftime ;
   u_int32_t refid ;
   u_int32_t refid4 ;
   u_int32_t send_refid ;
   u_int8_t synced ;
   u_int8_t leap ;
   int8_t precision ;
   u_int8_t poll ;
   u_int8_t stratum ;
};
#line 115 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_offset {
   struct ntp_status status ;
   double offset ;
   double delay ;
   double error ;
   time_t rcvd ;
   u_int8_t good ;
};
#line 124 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct __anonstruct_entry_66 {
   struct ntp_peer *tqe_next ;
   struct ntp_peer **tqe_prev ;
};
#line 124 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_peer {
   struct __anonstruct_entry_66 entry ;
   struct ntp_addr_wrap addr_head ;
   struct ntp_addr *addr ;
   struct ntp_query *query ;
   struct ntp_offset reply[8] ;
   struct ntp_offset update ;
   enum client_state state ;
   time_t next ;
   time_t deadline ;
   u_int32_t id ;
   u_int8_t shift ;
   u_int8_t trustlevel ;
   u_int8_t weight ;
   int lasterror ;
};
#line 141 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct __anonstruct_entry_67 {
   struct ntp_sensor *tqe_next ;
   struct ntp_sensor **tqe_prev ;
};
#line 141 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_sensor {
   struct __anonstruct_entry_67 entry ;
   struct ntp_offset offsets[7] ;
   struct ntp_offset update ;
   time_t next ;
   time_t last ;
   char *device ;
   int sensordevid ;
   int correction ;
   u_int8_t weight ;
   u_int8_t shift ;
};
#line 154 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct __anonstruct_entry_68 {
   struct ntp_conf_sensor *tqe_next ;
   struct ntp_conf_sensor **tqe_prev ;
};
#line 154 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_conf_sensor {
   struct __anonstruct_entry_68 entry ;
   char *device ;
   int correction ;
   u_int8_t weight ;
};
#line 161 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_freq {
   double overall_offset ;
   double x ;
   double y ;
   double xx ;
   double xy ;
   int samples ;
   u_int num ;
};
#line 169 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct listen_addrs {
   struct listen_addr *tqh_first ;
   struct listen_addr **tqh_last ;
};
#line 169 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_peers {
   struct ntp_peer *tqh_first ;
   struct ntp_peer **tqh_last ;
};
#line 169 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_sensors {
   struct ntp_sensor *tqh_first ;
   struct ntp_sensor **tqh_last ;
};
#line 169 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntp_conf_sensors {
   struct ntp_conf_sensor *tqh_first ;
   struct ntp_conf_sensor **tqh_last ;
};
#line 169 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntpd_conf {
   struct listen_addrs listen_addrs ;
   struct ntp_peers ntp_peers ;
   struct ntp_sensors ntp_sensors ;
   struct ntp_conf_sensors ntp_conf_sensors ;
   struct ntp_status status ;
   struct ntp_freq freq ;
   u_int8_t listen_all ;
   u_int8_t settime ;
   u_int8_t debug ;
   u_int32_t scale ;
   u_int8_t noaction ;
   char *pid_file ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 184 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct __anonstruct_entry_69 {
   struct buf *tqe_next ;
   struct buf **tqe_prev ;
};
#line 184 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct buf {
   struct __anonstruct_entry_69 entry ;
   u_char *buf ;
   size_t size ;
   size_t wpos ;
   size_t rpos ;
};
#line 192 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct __anonstruct_bufs_70 {
   struct buf *tqh_first ;
   struct buf **tqh_last ;
};
#line 192 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct msgbuf {
   struct __anonstruct_bufs_70 bufs ;
   u_int32_t queued ;
   int fd ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_11 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_12 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_11 __wait_terminated ;
   struct __anonstruct___wait_stopped_12 __wait_stopped ;
};
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 198 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct buf_read {
   size_t wpos ;
   u_char buf[8192] ;
   u_char *rptr ;
};
#line 209 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct imsgbuf {
   int fd ;
   pid_t pid ;
   struct buf_read r ;
   struct msgbuf w ;
};
#line 216
enum imsg_type {
    IMSG_NONE = 0,
    IMSG_ADJTIME = 1,
    IMSG_ADJFREQ = 2,
    IMSG_SETTIME = 3,
    IMSG_HOST_DNS = 4
} ;
#line 224 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct imsg_hdr {
   enum imsg_type type ;
   u_int32_t peerid ;
   pid_t pid ;
   u_int16_t len ;
};
#line 231 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct imsg {
   struct imsg_hdr hdr ;
   void *data ;
};
#line 281 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
union __anonunion_75 {
   int __in ;
   int __i ;
};
#line 286 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 285 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
union __anonunion_77 {
   int __in ;
   int __i ;
};
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 39 "/usr/src/usr.sbin/ntpd/parse.y"
struct file;
#line 39 "/usr/src/usr.sbin/ntpd/parse.y"
struct files {
   struct file *tqh_first ;
   struct file **tqh_last ;
};
#line 40 "/usr/src/usr.sbin/ntpd/parse.y"
struct __anonstruct_entry_71 {
   struct file *tqe_next ;
   struct file **tqe_prev ;
};
#line 40 "/usr/src/usr.sbin/ntpd/parse.y"
struct file {
   struct __anonstruct_entry_71 entry ;
   FILE *stream ;
   char *name ;
   int lineno ;
   int errors ;
};
#line 60 "/usr/src/usr.sbin/ntpd/parse.y"
struct opts {
   int weight ;
   int correction ;
};
#line 66 "/usr/src/usr.sbin/ntpd/parse.y"
union __anonunion_v_73 {
   int64_t number ;
   char *string ;
   struct ntp_addr_wrap *addr ;
   struct opts opts ;
};
#line 66 "/usr/src/usr.sbin/ntpd/parse.y"
struct __anonstruct_YYSTYPE_72 {
   union __anonunion_v_73 v ;
   int lineno ;
};
#line 66 "/usr/src/usr.sbin/ntpd/parse.y"
typedef struct __anonstruct_YYSTYPE_72 YYSTYPE;
#line 277 "/usr/src/usr.sbin/ntpd/parse.y"
struct keywords {
   char const   *k_name ;
   int k_val ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_62 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_62 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 29 "/usr/include/ifaddrs.h"
union __anonunion_ifa_ifu_65 {
   struct sockaddr *ifu_broadaddr ;
   struct sockaddr *ifu_dstaddr ;
};
#line 29 "/usr/include/ifaddrs.h"
struct ifaddrs {
   struct ifaddrs *ifa_next ;
   char *ifa_name ;
   unsigned int ifa_flags ;
   struct sockaddr *ifa_addr ;
   struct sockaddr *ifa_netmask ;
   union __anonunion_ifa_ifu_65 ifa_ifu ;
   void *ifa_data ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 98 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.h"
struct ntp_msg __packed  ;
#line 243 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
void log_debug(char const   *emsg  , ...) ;
#line 244
void fatal(char const   *emsg ) ;
#line 271
int priv_adjtime(void) ;
#line 274
int offset_compare(void const   *aa , void const   *bb ) ;
#line 275
struct ntpd_conf *conf ;
#line 311
time_t getmonotime(void) ;
#line 319
void sensor_init(void) ;
#line 329
int sensor_hotplugfd(void) ;
#line 58 "/home/wheatley/newnew/temp/openntpd-20080406p/sensors.c"
void sensor_add(int sensordev , char *dxname ) ;
#line 59
void sensor_remove(struct ntp_sensor *s ) ;
#line 60
void sensor_update(struct ntp_sensor *s ) ;
#line 62 "/home/wheatley/newnew/temp/openntpd-20080406p/sensors.c"
void sensor_init(void) 
{ 


  {
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    conf->ntp_sensors.tqh_first = (struct ntp_sensor *)((void *)0);
#line 65
    conf->ntp_sensors.tqh_last = & conf->ntp_sensors.tqh_first;
#line 65
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return;
}
}
#line 126 "/home/wheatley/newnew/temp/openntpd-20080406p/sensors.c"
void sensor_add(int sensordev , char *dxname ) 
{ 
  struct ntp_sensor *s ;
  struct ntp_conf_sensor *cs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 133
  s = conf->ntp_sensors.tqh_first;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 133
      goto while_break;
    }
    {
#line 134
    tmp = strcmp((char const   *)s->device, (char const   *)dxname);
    }
#line 134
    if (! tmp) {
#line 135
      return;
    }
#line 133
    s = s->entry.tqe_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  cs = conf->ntp_conf_sensors.tqh_first;
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    if ((unsigned long )cs != (unsigned long )((void *)0)) {
      {
#line 138
      tmp___0 = strcmp((char const   *)cs->device, (char const   *)dxname);
      }
#line 138
      if (tmp___0) {
        {
#line 138
        tmp___1 = strcmp((char const   *)cs->device, "*");
        }
#line 138
        if (! tmp___1) {
#line 138
          goto while_break___0;
        }
      } else {
#line 138
        goto while_break___0;
      }
    } else {
#line 138
      goto while_break___0;
    }
#line 138
    cs = cs->entry.tqe_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  if ((unsigned long )cs == (unsigned long )((void *)0)) {
#line 143
    return;
  }
  {
#line 145
  tmp___2 = calloc((size_t )1, sizeof(*s));
#line 145
  s = (struct ntp_sensor *)tmp___2;
  }
#line 145
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 146
    fatal("sensor_add calloc");
    }
  }
  {
#line 148
  s->next = getmonotime();
#line 149
  s->weight = cs->weight;
#line 150
  s->correction = cs->correction;
#line 151
  tmp___3 = strdup((char const   *)dxname);
#line 151
  s->device = tmp___3;
  }
#line 151
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 152
    fatal("sensor_add strdup");
    }
  }
#line 153
  s->sensordevid = sensordev;
  {
#line 155
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 155
    s->entry.tqe_next = (struct ntp_sensor *)((void *)0);
#line 155
    s->entry.tqe_prev = conf->ntp_sensors.tqh_last;
#line 155
    *(conf->ntp_sensors.tqh_last) = s;
#line 155
    conf->ntp_sensors.tqh_last = & s->entry.tqe_next;
#line 155
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 157
  log_debug("sensor %s added (weight %d, correction %.6f)", s->device, (int )s->weight,
            (double )s->correction / 1e6);
  }
#line 159
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/openntpd-20080406p/sensors.c"
void sensor_remove(struct ntp_sensor *s ) 
{ 


  {
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if ((unsigned long )s->entry.tqe_next != (unsigned long )((void *)0)) {
#line 164
      (s->entry.tqe_next)->entry.tqe_prev = s->entry.tqe_prev;
    } else {
#line 164
      conf->ntp_sensors.tqh_last = s->entry.tqe_prev;
    }
#line 164
    *(s->entry.tqe_prev) = s->entry.tqe_next;
#line 164
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  free((void *)s->device);
#line 166
  free((void *)s);
  }
#line 167
  return;
}
}
#line 231 "/home/wheatley/newnew/temp/openntpd-20080406p/sensors.c"
void sensor_update(struct ntp_sensor *s ) 
{ 
  struct ntp_offset **offsets ;
  int i ;
  void *tmp ;

  {
  {
#line 237
  tmp = calloc((size_t )7, sizeof(struct ntp_offset *));
#line 237
  offsets = (struct ntp_offset **)tmp;
  }
#line 237
  if ((unsigned long )offsets == (unsigned long )((void *)0)) {
    {
#line 239
    fatal("calloc sensor_update");
    }
  }
#line 241
  i = 0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! (i < 7)) {
#line 241
      goto while_break;
    }
#line 242
    *(offsets + i) = & s->offsets[i];
#line 241
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  qsort((void *)offsets, (size_t )7, sizeof(struct ntp_offset *), & offset_compare);
#line 247
  i = 3;
#line 248
  memcpy((void */* __restrict  */)(& s->update), (void const   */* __restrict  */)*(offsets + i),
         sizeof(s->update));
#line 253
  free((void *)offsets);
#line 255
  log_debug("sensor update %s: offset %f", s->device, s->update.offset);
#line 256
  priv_adjtime();
  }
#line 257
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/openntpd-20080406p/sensors.c"
int sensor_hotplugfd(void) 
{ 


  {
#line 278
  return (-1);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 459 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 249 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct buf *buf_open(size_t len ) ;
#line 250
int buf_add(struct buf *buf___0 , void *data , size_t len ) ;
#line 251
int buf_close(struct msgbuf *msgbuf , struct buf *buf___0 ) ;
#line 252
void buf_free(struct buf *buf___0 ) ;
#line 253
void msgbuf_init(struct msgbuf *msgbuf ) ;
#line 254
void msgbuf_clear(struct msgbuf *msgbuf ) ;
#line 255
int msgbuf_write(struct msgbuf *msgbuf ) ;
#line 33 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
void buf_enqueue(struct msgbuf *msgbuf , struct buf *buf___0 ) ;
#line 34
void buf_dequeue(struct msgbuf *msgbuf , struct buf *buf___0 ) ;
#line 36 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
struct buf *buf_open(size_t len ) 
{ 
  struct buf *buf___0 ;
  void *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 41
  tmp = calloc((size_t )1, sizeof(struct buf ));
#line 41
  buf___0 = (struct buf *)tmp;
  }
#line 41
  if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 42
    return ((struct buf *)((void *)0));
  }
  {
#line 43
  tmp___1 = malloc(len);
#line 43
  tmp___0 = (u_char *)tmp___1;
#line 43
  buf___0->buf = tmp___0;
  }
#line 43
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 44
    free((void *)buf___0);
    }
#line 45
    return ((struct buf *)((void *)0));
  }
#line 47
  buf___0->size = len;
#line 49
  return (buf___0);
}
}
#line 52 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
int buf_add(struct buf *buf___0 , void *data , size_t len ) 
{ 


  {
#line 55
  if (buf___0->wpos + len > buf___0->size) {
#line 56
    return (-1);
  }
  {
#line 58
  memcpy((void */* __restrict  */)(buf___0->buf + buf___0->wpos), (void const   */* __restrict  */)data,
         len);
#line 59
  buf___0->wpos += len;
  }
#line 60
  return (0);
}
}
#line 63 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
int buf_close(struct msgbuf *msgbuf , struct buf *buf___0 ) 
{ 


  {
  {
#line 66
  buf_enqueue(msgbuf, buf___0);
  }
#line 67
  return (1);
}
}
#line 70 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
void buf_free(struct buf *buf___0 ) 
{ 


  {
  {
#line 73
  free((void *)buf___0->buf);
#line 74
  free((void *)buf___0);
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
void msgbuf_init(struct msgbuf *msgbuf ) 
{ 


  {
#line 80
  msgbuf->queued = (u_int32_t )0;
#line 81
  msgbuf->fd = -1;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    msgbuf->bufs.tqh_first = (struct buf *)((void *)0);
#line 82
    msgbuf->bufs.tqh_last = & msgbuf->bufs.tqh_first;
#line 82
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
void msgbuf_clear(struct msgbuf *msgbuf ) 
{ 
  struct buf *buf___0 ;

  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    buf___0 = msgbuf->bufs.tqh_first;
#line 90
    if (! ((unsigned long )buf___0 != (unsigned long )((void *)0))) {
#line 90
      goto while_break;
    }
    {
#line 91
    buf_dequeue(msgbuf, buf___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
int msgbuf_write(struct msgbuf *msgbuf ) 
{ 
  struct iovec iov[1024] ;
  struct buf *buf___0 ;
  struct buf *next ;
  int i ;
  ssize_t n ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 99
  i = 0;
#line 102
  bzero((void *)(& iov), sizeof(iov));
#line 103
  buf___0 = msgbuf->bufs.tqh_first;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )buf___0 != (unsigned long )((void *)0))) {
#line 103
      goto while_break;
    }
#line 104
    if (i >= 1024) {
#line 105
      goto while_break;
    }
#line 106
    iov[i].iov_base = (void *)(buf___0->buf + buf___0->rpos);
#line 107
    iov[i].iov_len = buf___0->size - buf___0->rpos;
#line 108
    i ++;
#line 103
    buf___0 = buf___0->entry.tqe_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 111
  n = writev(msgbuf->fd, (struct iovec  const  *)(iov), i);
  }
#line 111
  if (n == -1L) {
    {
#line 112
    tmp = __errno_location();
    }
#line 112
    if (*tmp == 11) {
#line 114
      return (0);
    } else {
      {
#line 112
      tmp___0 = __errno_location();
      }
#line 112
      if (*tmp___0 == 4) {
#line 114
        return (0);
      } else {
        {
#line 112
        tmp___1 = __errno_location();
        }
#line 112
        if (*tmp___1 == 105) {
#line 114
          return (0);
        } else {
#line 116
          return (-1);
        }
      }
    }
  }
#line 119
  if (n == 0L) {
    {
#line 120
    tmp___2 = __errno_location();
#line 120
    *tmp___2 = 0;
    }
#line 121
    return (-2);
  }
#line 124
  buf___0 = msgbuf->bufs.tqh_first;
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 124
    if ((unsigned long )buf___0 != (unsigned long )((void *)0)) {
#line 124
      if (! (n > 0L)) {
#line 124
        goto while_break___0;
      }
    } else {
#line 124
      goto while_break___0;
    }
#line 126
    next = buf___0->entry.tqe_next;
#line 127
    if (buf___0->rpos + (size_t )n >= buf___0->size) {
      {
#line 128
      n = (ssize_t )((size_t )n - (buf___0->size - buf___0->rpos));
#line 129
      buf_dequeue(msgbuf, buf___0);
      }
    } else {
#line 131
      buf___0->rpos += (size_t )n;
#line 132
      n = (ssize_t )0;
    }
#line 124
    buf___0 = next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 136
  return (0);
}
}
#line 139 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
void buf_enqueue(struct msgbuf *msgbuf , struct buf *buf___0 ) 
{ 


  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    buf___0->entry.tqe_next = (struct buf *)((void *)0);
#line 142
    buf___0->entry.tqe_prev = msgbuf->bufs.tqh_last;
#line 142
    *(msgbuf->bufs.tqh_last) = buf___0;
#line 142
    msgbuf->bufs.tqh_last = & buf___0->entry.tqe_next;
#line 142
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  (msgbuf->queued) ++;
#line 144
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/openntpd-20080406p/buffer.c"
void buf_dequeue(struct msgbuf *msgbuf , struct buf *buf___0 ) 
{ 


  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if ((unsigned long )buf___0->entry.tqe_next != (unsigned long )((void *)0)) {
#line 149
      (buf___0->entry.tqe_next)->entry.tqe_prev = buf___0->entry.tqe_prev;
    } else {
#line 149
      msgbuf->bufs.tqh_last = buf___0->entry.tqe_prev;
    }
#line 149
    *(buf___0->entry.tqe_prev) = buf___0->entry.tqe_next;
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  (msgbuf->queued) --;
#line 151
  buf_free(buf___0);
  }
#line 152
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 937 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 119 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socketpair)(int __domain ,
                                                                                 int __type ,
                                                                                 int __protocol ,
                                                                                 int *__fds ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) settimeofday)(struct timeval  const  *__tv ,
                                                                                   struct timezone  const  *__tz ) ;
#line 85
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) adjtime)(struct timeval  const  *__delta ,
                                                                              struct timeval *__olddelta ) ;
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 28 "/home/wheatley/newnew/temp/openntpd-20080406p/openbsd-compat/openbsd-compat.h"
extern char *_compat_get_progname(char * ) ;
#line 31
extern void seed_rng(void) ;
#line 55
extern int _compat_adjfreq(int64_t const   * , int64_t * ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 125
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 273 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_init)(void) ;
#line 238 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
void log_init(int n_debug ) ;
#line 240
void log_warn(char const   *emsg  , ...) ;
#line 241
void log_warnx(char const   *emsg  , ...) ;
#line 242
void log_info(char const   *emsg  , ...) ;
#line 245
void fatalx(char const   *emsg ) ;
#line 258
void imsg_init(struct imsgbuf *ibuf___0 , int fd ) ;
#line 259
int imsg_read(struct imsgbuf *ibuf___0 ) ;
#line 260
int imsg_get(struct imsgbuf *ibuf___0 , struct imsg *imsg ) ;
#line 261
int imsg_compose(struct imsgbuf *ibuf___0 , enum imsg_type type , u_int32_t peerid ,
                 pid_t pid , void *data , u_int16_t datalen ) ;
#line 263
struct buf *imsg_create(struct imsgbuf *ibuf___0 , enum imsg_type type , u_int32_t peerid ,
                        pid_t pid , u_int16_t datalen ) ;
#line 265
int imsg_add(struct buf *msg , void *data , u_int16_t datalen ) ;
#line 266
int imsg_close(struct imsgbuf *ibuf___0 , struct buf *msg ) ;
#line 267
void imsg_free(struct imsg *imsg ) ;
#line 270
pid_t ntp_main(int *pipe_prnt , struct ntpd_conf *nconf ) ;
#line 278
int parse_config(char const   *filename , struct ntpd_conf *xconf ) ;
#line 282
int host_dns(char const   *s , struct ntp_addr **hn ) ;
#line 309
double getoffset(void) ;
#line 312
void d_to_tv(double d , struct timeval *tv ) ;
#line 42 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
void sighdlr(int sig ) ;
#line 43
void usage(void) ;
#line 44
int main(int argc , char **argv ) ;
#line 45
int check_child(pid_t pid , char const   *pname ) ;
#line 46
int dispatch_imsg(struct ntpd_conf *lconf ) ;
#line 47
void reset_adjtime(void) ;
#line 48
int ntpd_adjtime(double d ) ;
#line 49
void ntpd_adjfreq(double relfreq , int wrlog ) ;
#line 50
void ntpd_settime(double d ) ;
#line 51
void readfreq(void) ;
#line 52
void writefreq(double d ) ;
#line 54 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
int volatile   quit  =    (sig_atomic_t volatile   )0;
#line 55 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
int volatile   reconfig  =    (sig_atomic_t volatile   )0;
#line 56 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
int volatile   sigchld  =    (sig_atomic_t volatile   )0;
#line 57 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
struct imsgbuf *ibuf  ;
#line 58 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
int debugsyslog  =    0;
#line 60 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
void sighdlr(int sig ) 
{ 


  {
  {
#line 65
  if (sig == 2) {
#line 65
    goto case_2;
  }
#line 65
  if (sig == 15) {
#line 65
    goto case_2;
  }
#line 68
  if (sig == 17) {
#line 68
    goto case_17;
  }
#line 71
  if (sig == 1) {
#line 71
    goto case_1;
  }
#line 63
  goto switch_break;
  case_2: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 66
  quit = (int volatile   )1;
#line 67
  goto switch_break;
  case_17: /* CIL Label */ 
#line 69
  sigchld = (int volatile   )1;
#line 70
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  reconfig = (int volatile   )1;
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 80
extern char *__progname ;
#line 77 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
void usage(void) 
{ 


  {
  {
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-dnSsv] [-f file] [-p file]\n",
          __progname);
#line 83
  exit(1);
  }
}
}
#line 89 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
int main(int argc , char **argv ) 
{ 
  struct ntpd_conf lconf ;
  struct pollfd pfd[8] ;
  pid_t chld_pid ;
  pid_t pid ;
  char const   *conffile ;
  int ch ;
  int nfds ;
  int timeout ;
  int pipe_chld[2] ;
  time_t start_time ;
  int tmp ;
  __uid_t tmp___0 ;
  struct passwd *tmp___1 ;
  FILE *f ;
  FILE *tmp___2 ;
  __pid_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  FILE *f___0 ;
  FILE *tmp___8 ;
  __pid_t tmp___9 ;
  int tmp___10 ;
  time_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;

  {
  {
#line 94
  chld_pid = 0;
#line 96
  timeout = -1;
#line 101
  __progname = _compat_get_progname(*(argv + 0));
#line 103
  conffile = "/usr/local/etc/ntpd.conf";
#line 105
  bzero((void *)(& lconf), sizeof(lconf));
#line 107
  log_init(1);
#line 108
  __res_init();
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 110
    ch = getopt(argc, (char * const  *)argv, "df:np:sSv");
    }
#line 110
    if (! (ch != -1)) {
#line 110
      goto while_break;
    }
    {
#line 112
    if (ch == 100) {
#line 112
      goto case_100;
    }
#line 115
    if (ch == 102) {
#line 115
      goto case_102;
    }
#line 118
    if (ch == 110) {
#line 118
      goto case_110;
    }
#line 121
    if (ch == 112) {
#line 121
      goto case_112;
    }
#line 124
    if (ch == 115) {
#line 124
      goto case_115;
    }
#line 127
    if (ch == 83) {
#line 127
      goto case_83;
    }
#line 130
    if (ch == 118) {
#line 130
      goto case_118;
    }
#line 133
    goto switch_default;
    case_100: /* CIL Label */ 
#line 113
    lconf.debug = (u_int8_t )1;
#line 114
    goto switch_break;
    case_102: /* CIL Label */ 
#line 116
    conffile = (char const   *)optarg;
#line 117
    goto switch_break;
    case_110: /* CIL Label */ 
#line 119
    lconf.noaction = (u_int8_t )1;
#line 120
    goto switch_break;
    case_112: /* CIL Label */ 
#line 122
    lconf.pid_file = optarg;
#line 123
    goto switch_break;
    case_115: /* CIL Label */ 
#line 125
    lconf.settime = (u_int8_t )1;
#line 126
    goto switch_break;
    case_83: /* CIL Label */ 
#line 128
    lconf.settime = (u_int8_t )0;
#line 129
    goto switch_break;
    case_118: /* CIL Label */ 
#line 131
    debugsyslog = 1;
#line 132
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 134
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  tmp = parse_config(conffile, & lconf);
  }
#line 139
  if (tmp) {
    {
#line 140
    exit(1);
    }
  }
#line 142
  if (lconf.noaction) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"configuration OK\n");
#line 144
    exit(0);
    }
  }
  {
#line 147
  tmp___0 = geteuid();
  }
#line 147
  if (tmp___0) {
    {
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ntpd: need root privileges\n");
#line 149
    exit(1);
    }
  }
  {
#line 152
  tmp___1 = getpwnam("_ntp");
  }
#line 152
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 153
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ntpd: unknown user %s\n",
            "_ntp");
#line 154
    exit(1);
    }
  }
  {
#line 156
  endpwent();
#line 159
  seed_rng();
#line 162
  reset_adjtime();
  }
#line 163
  if (! lconf.settime) {
    {
#line 164
    log_init((int )lconf.debug);
    }
#line 165
    if (! lconf.debug) {
      {
#line 166
      tmp___4 = daemon(1, 0);
      }
#line 166
      if (tmp___4) {
        {
#line 167
        fatal("daemon");
        }
      } else
#line 168
      if ((unsigned long )lconf.pid_file != (unsigned long )((void *)0)) {
        {
#line 169
        tmp___2 = fopen((char const   */* __restrict  */)lconf.pid_file, (char const   */* __restrict  */)"w");
#line 169
        f = tmp___2;
        }
#line 170
        if ((unsigned long )f == (unsigned long )((void *)0)) {
          {
#line 171
          fatal("couldn\'t open pid file");
          }
        }
        {
#line 172
        tmp___3 = getpid();
#line 172
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld\n",
                (long )tmp___3);
#line 173
        fclose(f);
        }
      }
    }
  } else {
#line 177
    timeout = 15000;
  }
  {
#line 179
  tmp___5 = socketpair(1, 1, 0, (int *)(pipe_chld));
  }
#line 179
  if (tmp___5 == -1) {
    {
#line 180
    fatal("socketpair");
    }
  }
  {
#line 182
  signal(17, & sighdlr);
#line 184
  chld_pid = ntp_main((int *)(pipe_chld), & lconf);
#line 187
  readfreq();
#line 189
  signal(15, & sighdlr);
#line 190
  signal(2, & sighdlr);
#line 191
  signal(1, & sighdlr);
#line 193
  close(pipe_chld[1]);
#line 195
  tmp___6 = malloc(sizeof(struct imsgbuf ));
#line 195
  ibuf = (struct imsgbuf *)tmp___6;
  }
#line 195
  if ((unsigned long )ibuf == (unsigned long )((void *)0)) {
    {
#line 196
    fatal((char const   *)((void *)0));
    }
  }
  {
#line 197
  imsg_init(ibuf, pipe_chld[0]);
#line 199
  start_time = getmonotime();
  }
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (quit == (int volatile   )0)) {
#line 201
      goto while_break___0;
    }
#line 202
    pfd[0].fd = ibuf->fd;
#line 203
    pfd[0].events = (short)1;
#line 204
    if (ibuf->w.queued) {
#line 205
      pfd[0].events = (short )((int )pfd[0].events | 4);
    }
    {
#line 207
    nfds = poll(pfd, (nfds_t )1, timeout);
    }
#line 207
    if (nfds == -1) {
      {
#line 208
      tmp___7 = __errno_location();
      }
#line 208
      if (*tmp___7 != 4) {
        {
#line 209
        log_warn("poll error");
#line 210
        quit = (int volatile   )1;
        }
      }
    }
#line 213
    if (lconf.settime) {
#line 213
      if (nfds == 0) {
#line 213
        goto _L;
      } else {
        {
#line 213
        tmp___11 = getmonotime();
        }
#line 213
        if (tmp___11 > start_time + 15L) {
          _L: /* CIL Label */ 
          {
#line 215
          lconf.settime = (u_int8_t )0;
#line 216
          timeout = -1;
#line 217
          log_init((int )lconf.debug);
#line 218
          log_warnx("no reply received in time, skipping initial time setting");
          }
#line 220
          if (! lconf.debug) {
            {
#line 221
            tmp___10 = daemon(1, 0);
            }
#line 221
            if (tmp___10) {
              {
#line 222
              fatal("daemon");
              }
            } else
#line 223
            if ((unsigned long )lconf.pid_file != (unsigned long )((void *)0)) {
              {
#line 224
              tmp___8 = fopen((char const   */* __restrict  */)lconf.pid_file, (char const   */* __restrict  */)"w");
#line 224
              f___0 = tmp___8;
              }
#line 225
              if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
                {
#line 226
                fatal("couldn\'t open pid file");
                }
              }
              {
#line 227
              tmp___9 = getpid();
#line 227
              fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%ld\n",
                      (long )tmp___9);
#line 228
              fclose(f___0);
              }
            }
          }
        }
      }
    }
#line 233
    if (nfds > 0) {
#line 233
      if ((int )pfd[0].revents & 4) {
        {
#line 234
        tmp___12 = msgbuf_write(& ibuf->w);
        }
#line 234
        if (tmp___12 < 0) {
          {
#line 235
          log_warn("pipe write error (to child)");
#line 236
          quit = (int volatile   )1;
          }
        }
      }
    }
#line 239
    if (nfds > 0) {
#line 239
      if ((int )pfd[0].revents & 1) {
        {
#line 240
        nfds --;
#line 241
        tmp___13 = dispatch_imsg(& lconf);
        }
#line 241
        if (tmp___13 == -1) {
#line 242
          quit = (int volatile   )1;
        }
      }
    }
#line 245
    if (sigchld) {
      {
#line 246
      tmp___14 = check_child(chld_pid, "child");
      }
#line 246
      if (tmp___14) {
#line 247
        quit = (int volatile   )1;
#line 248
        chld_pid = 0;
      }
#line 250
      sigchld = (int volatile   )0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 255
  signal(17, (void (*)(int  ))0);
  }
#line 257
  if (chld_pid) {
    {
#line 258
    kill(chld_pid, 15);
    }
  }
  {
#line 260
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 261
    pid = wait((union wait *)((void *)0));
    }
#line 261
    if (pid == -1) {
      {
#line 261
      tmp___15 = __errno_location();
      }
#line 261
      if (*tmp___15 != 4) {
        {
#line 261
        tmp___16 = __errno_location();
        }
#line 261
        if (*tmp___16 != 10) {
          {
#line 263
          fatal("wait");
          }
        }
      }
    }
#line 260
    if (! (pid != -1)) {
#line 260
      if (pid == -1) {
        {
#line 260
        tmp___17 = __errno_location();
        }
#line 260
        if (! (*tmp___17 == 4)) {
#line 260
          goto while_break___1;
        }
      } else {
#line 260
        goto while_break___1;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 266
  msgbuf_clear(& ibuf->w);
#line 267
  free((void *)ibuf);
#line 268
  log_info("Terminating");
  }
#line 269
  if ((unsigned long )lconf.pid_file != (unsigned long )((void *)0)) {
    {
#line 270
    unlink((char const   *)lconf.pid_file);
    }
  }
#line 271
  return (0);
}
}
#line 274 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
int check_child(pid_t pid , char const   *pname ) 
{ 
  int status ;
  int sig ;
  char *signame ;
  union __anonunion_75 __constr_expr_0 ;
  union __anonunion_76 __constr_expr_1 ;
  char *tmp___0 ;
  char *tmp___1 ;
  union __anonunion_77 __constr_expr_2 ;
  __pid_t tmp___2 ;

  {
  {
#line 280
  tmp___2 = waitpid(pid, & status, 1);
  }
#line 280
  if (tmp___2 > 0) {
#line 281
    __constr_expr_0.__in = status;
#line 281
    if ((__constr_expr_0.__i & 127) == 0) {
      {
#line 282
      log_warnx("Lost child: %s exited", pname);
      }
#line 283
      return (1);
    }
#line 285
    __constr_expr_2.__in = status;
#line 285
    if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
      {
#line 286
      __constr_expr_1.__in = status;
#line 286
      sig = __constr_expr_1.__i & 127;
#line 287
      tmp___1 = strsignal(sig);
      }
#line 287
      if (tmp___1) {
        {
#line 287
        tmp___0 = strsignal(sig);
#line 287
        signame = tmp___0;
        }
      } else {
#line 287
        signame = (char *)"unknown";
      }
      {
#line 288
      log_warnx("Lost child: %s terminated; signal %d (%s)", pname, sig, signame);
      }
#line 290
      return (1);
    }
  }
#line 294
  return (0);
}
}
#line 297 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
int dispatch_imsg(struct ntpd_conf *lconf ) 
{ 
  struct imsg imsg ;
  int n ;
  int cnt ;
  double d ;
  char *name ;
  struct ntp_addr *h ;
  struct ntp_addr *hn ;
  struct buf *buf___0 ;
  FILE *f ;
  FILE *tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 307
  n = imsg_read(ibuf);
  }
#line 307
  if (n == -1) {
#line 308
    return (-1);
  }
#line 310
  if (n == 0) {
    {
#line 311
    log_warnx("dispatch_imsg in main: pipe closed");
    }
#line 312
    return (-1);
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 316
    n = imsg_get(ibuf, & imsg);
    }
#line 316
    if (n == -1) {
#line 317
      return (-1);
    }
#line 319
    if (n == 0) {
#line 320
      goto while_break;
    }
    {
#line 323
    if ((unsigned int )imsg.hdr.type == 1U) {
#line 323
      goto case_1;
    }
#line 330
    if ((unsigned int )imsg.hdr.type == 2U) {
#line 330
      goto case_2;
    }
#line 336
    if ((unsigned int )imsg.hdr.type == 3U) {
#line 336
      goto case_3;
    }
#line 358
    if ((unsigned int )imsg.hdr.type == 4U) {
#line 358
      goto case_4;
    }
#line 379
    goto switch_default;
    case_1: /* CIL Label */ 
#line 324
    if ((unsigned long )imsg.hdr.len != sizeof(struct imsg_hdr ) + sizeof(d)) {
      {
#line 325
      fatalx("invalid IMSG_ADJTIME received");
      }
    }
    {
#line 326
    memcpy((void */* __restrict  */)(& d), (void const   */* __restrict  */)imsg.data,
           sizeof(d));
#line 327
    n = ntpd_adjtime(d);
#line 328
    imsg_compose(ibuf, (enum imsg_type )1, (u_int32_t )0, 0, (void *)(& n), (u_int16_t )sizeof(n));
    }
#line 329
    goto switch_break;
    case_2: /* CIL Label */ 
#line 331
    if ((unsigned long )imsg.hdr.len != sizeof(struct imsg_hdr ) + sizeof(d)) {
      {
#line 332
      fatalx("invalid IMSG_ADJFREQ received");
      }
    }
    {
#line 333
    memcpy((void */* __restrict  */)(& d), (void const   */* __restrict  */)imsg.data,
           sizeof(d));
#line 334
    ntpd_adjfreq(d, 1);
    }
#line 335
    goto switch_break;
    case_3: /* CIL Label */ 
#line 337
    if ((unsigned long )imsg.hdr.len != sizeof(struct imsg_hdr ) + sizeof(d)) {
      {
#line 338
      fatalx("invalid IMSG_SETTIME received");
      }
    }
#line 339
    if (! lconf->settime) {
#line 340
      goto switch_break;
    }
    {
#line 341
    log_init((int )lconf->debug);
#line 342
    memcpy((void */* __restrict  */)(& d), (void const   */* __restrict  */)imsg.data,
           sizeof(d));
#line 343
    ntpd_settime(d);
    }
#line 345
    if (! lconf->debug) {
      {
#line 346
      tmp___1 = daemon(1, 0);
      }
#line 346
      if (tmp___1) {
        {
#line 347
        fatal("daemon");
        }
      } else
#line 348
      if ((unsigned long )lconf->pid_file != (unsigned long )((void *)0)) {
        {
#line 349
        tmp = fopen((char const   */* __restrict  */)lconf->pid_file, (char const   */* __restrict  */)"w");
#line 349
        f = tmp;
        }
#line 350
        if ((unsigned long )f == (unsigned long )((void *)0)) {
          {
#line 351
          fatal("couldn\'t open pid file");
          }
        }
        {
#line 352
        tmp___0 = getpid();
#line 352
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld\n",
                (long )tmp___0);
#line 353
        fclose(f);
        }
      }
    }
#line 356
    lconf->settime = (u_int8_t )0;
#line 357
    goto switch_break;
    case_4: /* CIL Label */ 
#line 359
    name = (char *)imsg.data;
#line 360
    if ((unsigned long )imsg.hdr.len < 1UL + sizeof(struct imsg_hdr )) {
      {
#line 361
      fatalx("invalid IMSG_HOST_DNS received");
      }
    }
#line 362
    imsg.hdr.len = (u_int16_t )((unsigned long )imsg.hdr.len - (1UL + sizeof(struct imsg_hdr )));
#line 363
    if ((int )*(name + imsg.hdr.len) != 0) {
      {
#line 365
      fatalx("invalid IMSG_HOST_DNS received");
      }
    } else {
      {
#line 363
      tmp___2 = strlen((char const   *)name);
      }
#line 363
      if (tmp___2 != (size_t )imsg.hdr.len) {
        {
#line 365
        fatalx("invalid IMSG_HOST_DNS received");
        }
      }
    }
    {
#line 366
    cnt = host_dns((char const   *)name, & hn);
    }
#line 366
    if (cnt == -1) {
#line 367
      goto switch_break;
    }
    {
#line 368
    buf___0 = imsg_create(ibuf, (enum imsg_type )4, imsg.hdr.peerid, 0, (u_int16_t )((unsigned long )cnt * sizeof(struct sockaddr_storage )));
    }
#line 371
    if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 372
      goto switch_break;
    }
#line 373
    if (cnt > 0) {
#line 374
      h = hn;
      {
#line 374
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 374
        if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 374
          goto while_break___0;
        }
        {
#line 375
        imsg_add(buf___0, (void *)(& h->ss), (u_int16_t )sizeof(h->ss));
#line 374
        h = h->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 377
    imsg_close(ibuf, buf___0);
    }
#line 378
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 380
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 382
    imsg_free(& imsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  return (0);
}
}
#line 387 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
void reset_adjtime(void) 
{ 
  struct timeval tv ;
  int tmp ;

  {
  {
#line 392
  tv.tv_sec = (__time_t )0;
#line 393
  tv.tv_usec = (__suseconds_t )0;
#line 394
  tmp = adjtime((struct timeval  const  *)(& tv), (struct timeval *)((void *)0));
  }
#line 394
  if (tmp == -1) {
    {
#line 395
    log_warn("reset adjtime failed");
    }
  }
#line 396
  return;
}
}
#line 403 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
static int firstadj  =    1;
#line 398 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
int ntpd_adjtime(double d ) 
{ 
  struct timeval tv ;
  struct timeval olddelta ;
  int synced ;
  double tmp ;
  int tmp___0 ;

  {
  {
#line 402
  synced = 0;
#line 405
  tmp = getoffset();
#line 405
  d += tmp;
  }
#line 406
  if (d >= (double )32 / (double )1000) {
    {
#line 408
    log_info("adjusting local clock by %fs", d);
    }
  } else
#line 406
  if (d <= ((double )-1 * (double )32) / (double )1000) {
    {
#line 408
    log_info("adjusting local clock by %fs", d);
    }
  } else {
    {
#line 410
    log_debug("adjusting local clock by %fs", d);
    }
  }
  {
#line 411
  d_to_tv(d, & tv);
#line 412
  tmp___0 = adjtime((struct timeval  const  *)(& tv), & olddelta);
  }
#line 412
  if (tmp___0 == -1) {
    {
#line 413
    log_warn("adjtime failed");
    }
  } else
#line 414
  if (! firstadj) {
#line 414
    if (olddelta.tv_sec == 0L) {
#line 414
      if (olddelta.tv_usec == 0L) {
#line 415
        synced = 1;
      }
    }
  }
#line 416
  firstadj = 0;
#line 417
  return (synced);
}
}
#line 420 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
void ntpd_adjfreq(double relfreq , int wrlog ) 
{ 
  int64_t curfreq ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 425
  tmp = _compat_adjfreq((int64_t const   *)((void *)0), & curfreq);
  }
#line 425
  if (tmp == -1) {
    {
#line 426
    log_warn("adjfreq failed");
    }
#line 427
    return;
  }
#line 434
  curfreq = (int64_t )((double )curfreq + (relfreq * 1e9) * (double )(1LL << 32));
#line 435
  if (wrlog) {
    {
#line 436
    log_info("adjusting clock frequency by %f to %fppm", relfreq * 1e6, ((double )curfreq / 1e3) / (double )(1LL << 32));
    }
  }
  {
#line 439
  tmp___0 = _compat_adjfreq((int64_t const   *)(& curfreq), (int64_t *)((void *)0));
  }
#line 439
  if (tmp___0 == -1) {
    {
#line 440
    log_warn("adjfreq failed");
    }
  }
  {
#line 441
  writefreq(((double )curfreq / 1e9) / (double )(1LL << 32));
  }
#line 442
  return;
}
}
#line 444 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
void ntpd_settime(double d ) 
{ 
  struct timeval tv ;
  struct timeval curtime ;
  char buf___0[80] ;
  time_t tval ;
  int tmp ;
  int tmp___0 ;
  struct tm *tmp___1 ;

  {
#line 452
  if (d < (double )180) {
#line 452
    if (d > (double )-180) {
#line 453
      return;
    }
  }
  {
#line 455
  tmp = gettimeofday((struct timeval */* __restrict  */)(& curtime), (__timezone_ptr_t )((void *)0));
  }
#line 455
  if (tmp == -1) {
    {
#line 456
    log_warn("gettimeofday");
    }
#line 457
    return;
  }
  {
#line 459
  d_to_tv(d, & tv);
#line 460
  curtime.tv_usec += tv.tv_usec + 1000000L;
#line 461
  curtime.tv_sec += (tv.tv_sec - 1L) + curtime.tv_usec / 1000000L;
#line 462
  curtime.tv_usec %= 1000000L;
#line 464
  tmp___0 = settimeofday((struct timeval  const  *)(& curtime), (struct timezone  const  *)((void *)0));
  }
#line 464
  if (tmp___0 == -1) {
    {
#line 465
    log_warn("settimeofday");
    }
#line 466
    return;
  }
  {
#line 468
  tval = curtime.tv_sec;
#line 469
  tmp___1 = localtime((time_t const   *)(& tval));
#line 469
  strftime((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%a %b %e %H:%M:%S %Z %Y",
           (struct tm  const  */* __restrict  */)tmp___1);
#line 471
  log_info("set local clock to %s (offset %fs)", buf___0, d);
  }
#line 472
  return;
}
}
#line 474 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
void readfreq(void) 
{ 
  FILE *fp ;
  int64_t current ;
  double d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 481
  fp = fopen((char const   */* __restrict  */)"/usr/local/var/ntpd.drift", (char const   */* __restrict  */)"r");
  }
#line 482
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 484
    current = (int64_t )0;
#line 485
    tmp = _compat_adjfreq((int64_t const   *)(& current), (int64_t *)((void *)0));
    }
#line 485
    if (tmp == -1) {
      {
#line 486
      log_warn("adjfreq reset failed");
      }
    }
#line 487
    return;
  }
  {
#line 491
  tmp___1 = _compat_adjfreq((int64_t const   *)((void *)0), & current);
  }
#line 491
  if (tmp___1 == -1) {
    {
#line 492
    log_warn("adjfreq failed");
    }
  } else
#line 493
  if (current == 0L) {
    {
#line 494
    tmp___0 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%le",
                     & d);
    }
#line 494
    if (tmp___0 == 1) {
      {
#line 495
      ntpd_adjfreq(d, 0);
      }
    }
  }
  {
#line 497
  fclose(fp);
  }
#line 498
  return;
}
}
#line 500 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.c"
void writefreq(double d ) 
{ 
  int r ;
  FILE *fp ;
  int tmp ;

  {
  {
#line 506
  fp = fopen((char const   */* __restrict  */)"/usr/local/var/ntpd.drift", (char const   */* __restrict  */)"w");
  }
#line 507
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 508
    return;
  }
  {
#line 510
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%e\n", d);
#line 511
  r = ferror(fp);
#line 512
  tmp = fclose(fp);
  }
#line 512
  if (tmp != 0) {
    {
#line 513
    unlink("/usr/local/var/ntpd.drift");
    }
  } else
#line 512
  if (r != 0) {
    {
#line 513
    unlink("/usr/local/var/ntpd.drift");
    }
  }
#line 514
  return;
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 342 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 308 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
double gettime_corrected(void) ;
#line 310
double gettime(void) ;
#line 313
double lfp_to_d(struct l_fixedpt lfp ) ;
#line 314
struct l_fixedpt d_to_lfp(double d ) ;
#line 315
double sfp_to_d(struct s_fixedpt sfp ) ;
#line 316
struct s_fixedpt d_to_sfp(double d ) ;
#line 24 "/home/wheatley/newnew/temp/openntpd-20080406p/util.c"
double gettime_corrected(void) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
#line 27
  tmp = gettime();
#line 27
  tmp___0 = getoffset();
  }
#line 27
  return (tmp + tmp___0);
}
}
#line 30 "/home/wheatley/newnew/temp/openntpd-20080406p/util.c"
double getoffset(void) 
{ 
  struct timeval tv ;
  int tmp ;

  {
  {
#line 34
  tmp = adjtime((struct timeval  const  *)((void *)0), & tv);
  }
#line 34
  if (tmp == -1) {
#line 35
    return (0.0);
  }
#line 36
  return ((double )tv.tv_sec + 1.0e-6 * (double )tv.tv_usec);
}
}
#line 39 "/home/wheatley/newnew/temp/openntpd-20080406p/util.c"
double gettime(void) 
{ 
  struct timeval tv ;
  int tmp ;

  {
  {
#line 44
  tmp = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 44
  if (tmp == -1) {
    {
#line 45
    fatal("gettimeofday");
    }
  }
#line 47
  return ((double )((unsigned long )tv.tv_sec + 2208988800UL) + 1.0e-6 * (double )tv.tv_usec);
}
}
#line 50 "/home/wheatley/newnew/temp/openntpd-20080406p/util.c"
time_t getmonotime(void) 
{ 
  struct timespec ts ;
  int tmp ;

  {
  {
#line 56
  tmp = clock_gettime(1, & ts);
  }
#line 56
  if (tmp != 0) {
    {
#line 60
    fatal("clock_gettime");
    }
  }
#line 62
  return (ts.tv_sec);
}
}
#line 66 "/home/wheatley/newnew/temp/openntpd-20080406p/util.c"
void d_to_tv(double d , struct timeval *tv ) 
{ 


  {
#line 69
  tv->tv_sec = (long )d;
#line 70
  tv->tv_usec = (__suseconds_t )((d - (double )tv->tv_sec) * (double )1000000);
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (tv->tv_usec < 0L)) {
#line 71
      goto while_break;
    }
#line 72
    tv->tv_usec += 1000000L;
#line 73
    (tv->tv_sec) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/openntpd-20080406p/util.c"
double lfp_to_d(struct l_fixedpt lfp ) 
{ 
  double ret ;

  {
  {
#line 82
  lfp.int_partl = ntohl(lfp.int_partl);
#line 83
  lfp.fractionl = ntohl(lfp.fractionl);
#line 85
  ret = (double )lfp.int_partl + (double )lfp.fractionl / (double )4294967295U;
  }
#line 87
  return (ret);
}
}
#line 90 "/home/wheatley/newnew/temp/openntpd-20080406p/util.c"
struct l_fixedpt d_to_lfp(double d ) 
{ 
  struct l_fixedpt lfp ;

  {
  {
#line 95
  lfp.int_partl = htonl((u_int32_t )d);
#line 96
  lfp.fractionl = htonl((u_int32_t )((d - (double )((u_int32_t )d)) * (double )4294967295U));
  }
#line 98
  return (lfp);
}
}
#line 101 "/home/wheatley/newnew/temp/openntpd-20080406p/util.c"
double sfp_to_d(struct s_fixedpt sfp ) 
{ 
  double ret ;

  {
  {
#line 106
  sfp.int_parts = ntohs(sfp.int_parts);
#line 107
  sfp.fractions = ntohs(sfp.fractions);
#line 109
  ret = (double )sfp.int_parts + (double )sfp.fractions / (double )65535;
  }
#line 111
  return (ret);
}
}
#line 114 "/home/wheatley/newnew/temp/openntpd-20080406p/util.c"
struct s_fixedpt d_to_sfp(double d ) 
{ 
  struct s_fixedpt sfp ;

  {
  {
#line 119
  sfp.int_parts = htons((u_int16_t )d);
#line 120
  sfp.fractions = htons((u_int16_t )((d - (double )((u_int16_t )d)) * (double )65535));
  }
#line 122
  return (sfp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 755
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 405 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 41 "/home/wheatley/newnew/temp/openntpd-20080406p/openbsd-compat/openbsd-compat.h"
extern long long strtonum(char const   * , long long  , long long  , char const   ** ) ;
#line 239 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
void vlog(int pri , char const   *fmt , va_list ap ) ;
#line 275 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
struct ntpd_conf *conf  ;
#line 281
int host(char const   *s , struct ntp_addr **hn ) ;
#line 283
struct ntp_peer *new_peer(void) ;
#line 284
struct ntp_conf_sensor *new_sensor(char *device ) ;
#line 39 "/usr/src/usr.sbin/ntpd/parse.y"
struct files files  =    {(struct file *)((void *)0), & files.tqh_first};
#line 40 "/usr/src/usr.sbin/ntpd/parse.y"
static struct file *file  ;
#line 47
struct file *pushfile(char const   *name ) ;
#line 48
int popfile(void) ;
#line 49
int yyparse(void) ;
#line 50
int yylex(void) ;
#line 51
int yyerror(char const   *fmt  , ...) ;
#line 52
int kw_cmp(void const   *k , void const   *e ) ;
#line 53
int lookup(char *s ) ;
#line 54
int lgetc(int quotec ) ;
#line 55
int lungetc(int c ) ;
#line 56
int findeol(void) ;
#line 60 "/usr/src/usr.sbin/ntpd/parse.y"
struct opts opts  ;
#line 64
void opts_default(void) ;
#line 86 "y.tab.c"
short const   yylhs[25]  = 
#line 86 "y.tab.c"
  {      (short const   )-1,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )10,      (short const   )10,      (short const   )10, 
        (short const   )10,      (short const   )1,      (short const   )11,      (short const   )2, 
        (short const   )2,      (short const   )3,      (short const   )3,      (short const   )4, 
        (short const   )12,      (short const   )5,      (short const   )5,      (short const   )6, 
        (short const   )6,      (short const   )7,      (short const   )7,      (short const   )8, 
        (short const   )9};
#line 96 "y.tab.c"
short const   yylen[25]  = 
#line 96
  {      (short const   )2,      (short const   )0,      (short const   )2,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )1,      (short const   )0,      (short const   )2, 
        (short const   )0,      (short const   )2,      (short const   )1,      (short const   )1, 
        (short const   )0,      (short const   )2,      (short const   )0,      (short const   )2, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )2, 
        (short const   )2};
#line 106 "y.tab.c"
short const   yydefred[35]  = 
#line 106
  {      (short const   )1,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )2, 
        (short const   )0,      (short const   )4,      (short const   )0,      (short const   )9, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )3, 
        (short const   )5,      (short const   )7,      (short const   )0,      (short const   )6, 
        (short const   )8,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )14,      (short const   )15,      (short const   )0,      (short const   )0, 
        (short const   )20,      (short const   )21,      (short const   )22,      (short const   )24, 
        (short const   )13,      (short const   )23,      (short const   )19};
#line 117 "y.tab.c"
short const   yydgoto[13]  = 
#line 117
  {      (short const   )1,      (short const   )12,      (short const   )17,      (short const   )23, 
        (short const   )24,      (short const   )20,      (short const   )27,      (short const   )28, 
        (short const   )29,      (short const   )25,      (short const   )8,      (short const   )18, 
        (short const   )21};
#line 126 "y.tab.c"
short const   yysindex[35]  = 
#line 126
  {      (short const   )0,      (short const   )-1,      (short const   )-5,      (short const   )-251, 
        (short const   )-255,      (short const   )-255,      (short const   )-253,      (short const   )0, 
        (short const   )3,      (short const   )0,      (short const   )-255,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )-249,      (short const   )0, 
        (short const   )0,      (short const   )-259,      (short const   )-250,      (short const   )-249, 
        (short const   )0,      (short const   )0,      (short const   )-248,      (short const   )-259, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0};
#line 136 "y.tab.c"
short const   yyrindex[35]  = 
#line 136
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )-9,      (short const   )-9,      (short const   )-10,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )5, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )7, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0};
#line 146 "y.tab.c"
short const   yygindex[13]  = 
#line 146
  {      (short const   )0,      (short const   )1,      (short const   )6,      (short const   )0, 
        (short const   )-3,      (short const   )0,      (short const   )0,      (short const   )-6, 
        (short const   )0,      (short const   )-19,      (short const   )0,      (short const   )0, 
        (short const   )0};
#line 156 "y.tab.c"
short const   yytable[261]  = 
#line 156
  {      (short const   )18,      (short const   )12,      (short const   )30,      (short const   )26, 
        (short const   )22,      (short const   )9,      (short const   )13,      (short const   )10, 
        (short const   )30,      (short const   )7,      (short const   )11,      (short const   )16, 
        (short const   )14,      (short const   )15,      (short const   )22,      (short const   )11, 
        (short const   )31,      (short const   )17,      (short const   )33,      (short const   )19, 
        (short const   )32,      (short const   )34,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )16,      (short const   )16,      (short const   )10,      (short const   )2, 
        (short const   )3,      (short const   )0,      (short const   )4,      (short const   )5, 
        (short const   )6};
#line 189 "y.tab.c"
short const   yycheck[261]  = 
#line 189
  {      (short const   )10,      (short const   )10,      (short const   )21,      (short const   )262, 
        (short const   )263,      (short const   )10,      (short const   )5,      (short const   )258, 
        (short const   )27,      (short const   )10,      (short const   )265,      (short const   )10, 
        (short const   )265,      (short const   )10,      (short const   )263,      (short const   )10, 
        (short const   )266,      (short const   )10,      (short const   )266,      (short const   )13, 
        (short const   )23,      (short const   )27,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )262,      (short const   )263,      (short const   )263,      (short const   )256, 
        (short const   )257,      (short const   )-1,      (short const   )259,      (short const   )260, 
        (short const   )261};
#line 287 "y.tab.c"
int yydebug  ;
#line 288 "y.tab.c"
int yynerrs  ;
#line 289 "y.tab.c"
int yyerrflag  ;
#line 290 "y.tab.c"
int yychar  ;
#line 291 "y.tab.c"
short *yyssp  ;
#line 292 "y.tab.c"
YYSTYPE *yyvsp  ;
#line 293 "y.tab.c"
YYSTYPE yyval  ;
#line 294 "y.tab.c"
YYSTYPE yylval  ;
#line 295 "y.tab.c"
short *yyss  ;
#line 296 "y.tab.c"
short *yysslim  ;
#line 297 "y.tab.c"
YYSTYPE *yyvs  ;
#line 298 "y.tab.c"
int yystacksize  ;
#line 270 "/usr/src/usr.sbin/ntpd/parse.y"
void opts_default(void) 
{ 


  {
  {
#line 273
  bzero((void *)(& opts), sizeof(opts));
#line 274
  opts.weight = 1;
  }
#line 275
  return;
}
}
#line 282 "/usr/src/usr.sbin/ntpd/parse.y"
int yyerror(char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *nfmt ;
  int tmp ;

  {
  {
#line 288
  (file->errors) ++;
#line 289
  __builtin_va_start(ap, fmt);
#line 290
  tmp = asprintf((char **/* __restrict  */)(& nfmt), (char const   */* __restrict  */)"%s:%d: %s",
                 file->name, yylval.lineno, fmt);
  }
#line 290
  if (tmp == -1) {
    {
#line 291
    fatalx("yyerror asprintf");
    }
  }
  {
#line 292
  vlog(2, (char const   *)nfmt, ap);
#line 293
  __builtin_va_end(ap);
#line 294
  free((void *)nfmt);
  }
#line 295
  return (0);
}
}
#line 298 "/usr/src/usr.sbin/ntpd/parse.y"
int kw_cmp(void const   *k , void const   *e ) 
{ 
  int tmp ;

  {
  {
#line 301
  tmp = strcmp((char const   *)k, (char const   *)((struct keywords  const  *)e)->k_name);
  }
#line 301
  return (tmp);
}
}
#line 308 "/usr/src/usr.sbin/ntpd/parse.y"
static struct keywords  const  keywords[7]  = {      {"correction", 262}, 
        {"listen", 257}, 
        {"on", 258}, 
        {"sensor", 261}, 
        {"server", 259}, 
        {"servers", 260}, 
        {"weight", 263}};
#line 304 "/usr/src/usr.sbin/ntpd/parse.y"
int lookup(char *s ) 
{ 
  struct keywords  const  *p ;
  void *tmp ;

  {
  {
#line 319
  tmp = bsearch((void const   *)s, (void const   *)(keywords), sizeof(keywords) / sizeof(keywords[0]),
                sizeof(keywords[0]), & kw_cmp);
#line 319
  p = (struct keywords  const  *)tmp;
  }
#line 322
  if (p) {
#line 323
    return ((int )p->k_val);
  } else {
#line 325
    return (265);
  }
}
}
#line 330 "/usr/src/usr.sbin/ntpd/parse.y"
char *parsebuf  ;
#line 331 "/usr/src/usr.sbin/ntpd/parse.y"
int parseindex  ;
#line 332 "/usr/src/usr.sbin/ntpd/parse.y"
char pushback_buffer[128]  ;
#line 333 "/usr/src/usr.sbin/ntpd/parse.y"
int pushback_index  =    0;
#line 335 "/usr/src/usr.sbin/ntpd/parse.y"
int lgetc(int quotec ) 
{ 
  int c ;
  int next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 340
  if (parsebuf) {
#line 342
    if (parseindex >= 0) {
#line 343
      tmp = parseindex;
#line 343
      parseindex ++;
#line 343
      c = (int )*(parsebuf + tmp);
#line 344
      if (c != 0) {
#line 345
        return (c);
      }
#line 346
      parsebuf = (char *)((void *)0);
    } else {
#line 348
      parseindex ++;
    }
  }
#line 351
  if (pushback_index) {
#line 352
    pushback_index --;
#line 352
    return ((int )pushback_buffer[pushback_index]);
  }
#line 354
  if (quotec) {
    {
#line 355
    c = _IO_getc(file->stream);
    }
#line 355
    if (c == -1) {
      {
#line 356
      yyerror("reached end of file while parsing quoted string");
#line 357
      tmp___0 = popfile();
      }
#line 357
      if (tmp___0 == -1) {
#line 358
        return (-1);
      }
#line 359
      return (quotec);
    }
#line 361
    return (c);
  }
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 364
    c = _IO_getc(file->stream);
    }
#line 364
    if (! (c == 92)) {
#line 364
      goto while_break;
    }
    {
#line 365
    next = _IO_getc(file->stream);
    }
#line 366
    if (next != 10) {
#line 367
      c = next;
#line 368
      goto while_break;
    }
#line 370
    yylval.lineno = file->lineno;
#line 371
    (file->lineno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  if (c == 9) {
#line 373
    goto _L;
  } else
#line 373
  if (c == 32) {
    _L: /* CIL Label */ 
    {
#line 375
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 376
      c = _IO_getc(file->stream);
      }
#line 375
      if (! (c == 9)) {
#line 375
        if (! (c == 32)) {
#line 375
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 378
    ungetc(c, file->stream);
#line 379
    c = ' ';
    }
  }
  {
#line 382
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 382
    if (! (c == -1)) {
#line 382
      goto while_break___1;
    }
    {
#line 383
    tmp___1 = popfile();
    }
#line 383
    if (tmp___1 == -1) {
#line 384
      return (-1);
    }
    {
#line 385
    c = _IO_getc(file->stream);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 387
  return (c);
}
}
#line 390 "/usr/src/usr.sbin/ntpd/parse.y"
int lungetc(int c ) 
{ 
  int tmp ;
  char tmp___0 ;

  {
#line 393
  if (c == -1) {
#line 394
    return (-1);
  }
#line 395
  if (parsebuf) {
#line 396
    parseindex --;
#line 397
    if (parseindex >= 0) {
#line 398
      return (c);
    }
  }
#line 400
  if (pushback_index < 127) {
#line 401
    tmp = pushback_index;
#line 401
    pushback_index ++;
#line 401
    tmp___0 = (char )c;
#line 401
    pushback_buffer[tmp] = tmp___0;
#line 401
    return ((int )tmp___0);
  } else {
#line 403
    return (-1);
  }
}
}
#line 406 "/usr/src/usr.sbin/ntpd/parse.y"
int findeol(void) 
{ 
  int c ;

  {
#line 411
  parsebuf = (char *)((void *)0);
#line 412
  pushback_index = 0;
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 416
    c = lgetc(0);
    }
#line 417
    if (c == 10) {
#line 418
      (file->lineno) ++;
#line 419
      goto while_break;
    }
#line 421
    if (c == -1) {
#line 422
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  return (264);
}
}
#line 427 "/usr/src/usr.sbin/ntpd/parse.y"
int yylex(void) 
{ 
  char buf___0[8096] ;
  char *p ;
  int quotec ;
  int next ;
  int c ;
  int token ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  char const   *errstr ;
  long long tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;

  {
#line 435
  p = buf___0;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 436
    c = lgetc(0);
    }
#line 436
    if (! (c == 32)) {
#line 436
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  yylval.lineno = file->lineno;
#line 440
  if (c == 35) {
    {
#line 441
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 441
      c = lgetc(0);
      }
#line 441
      if (c != 10) {
#line 441
        if (! (c != -1)) {
#line 441
          goto while_break___0;
        }
      } else {
#line 441
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 446
  if (c == 34) {
#line 446
    goto case_34;
  }
#line 446
  if (c == 39) {
#line 446
    goto case_34;
  }
#line 444
  goto switch_break;
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
#line 447
  quotec = c;
  {
#line 448
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 449
    c = lgetc(quotec);
    }
#line 449
    if (c == -1) {
#line 450
      return (0);
    }
#line 451
    if (c == 10) {
#line 452
      (file->lineno) ++;
#line 453
      goto while_continue___1;
    } else
#line 454
    if (c == 92) {
      {
#line 455
      next = lgetc(quotec);
      }
#line 455
      if (next == -1) {
#line 456
        return (0);
      }
#line 457
      if (next == quotec) {
#line 458
        c = next;
      } else
#line 457
      if (c == 32) {
#line 458
        c = next;
      } else
#line 457
      if (c == 9) {
#line 458
        c = next;
      } else
#line 459
      if (next == 10) {
#line 460
        goto while_continue___1;
      } else {
        {
#line 462
        lungetc(next);
        }
      }
    } else
#line 463
    if (c == quotec) {
#line 464
      *p = (char )'\000';
#line 465
      goto while_break___1;
    }
#line 467
    if ((unsigned long )(p + 1) >= (unsigned long )((buf___0 + sizeof(buf___0)) - 1)) {
      {
#line 468
      yyerror("string too long");
#line 469
      tmp = findeol();
      }
#line 469
      return (tmp);
    }
#line 471
    tmp___0 = p;
#line 471
    p ++;
#line 471
    *tmp___0 = (char )c;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 473
  yylval.v.string = strdup((char const   *)(buf___0));
  }
#line 474
  if ((unsigned long )yylval.v.string == (unsigned long )((void *)0)) {
    {
#line 475
    fatal("yylex: strdup");
    }
  }
#line 476
  return (265);
  switch_break: /* CIL Label */ ;
  }
#line 482
  if (c == 45) {
#line 482
    goto _L___1;
  } else {
    {
#line 482
    tmp___7 = __ctype_b_loc();
    }
#line 482
    if ((int const   )*(*tmp___7 + c) & 2048) {
      _L___1: /* CIL Label */ 
      {
#line 483
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 484
        tmp___1 = p;
#line 484
        p ++;
#line 484
        *tmp___1 = (char )c;
#line 485
        if ((unsigned long )((unsigned int )(p - buf___0)) >= sizeof(buf___0)) {
          {
#line 486
          yyerror("string too long");
#line 487
          tmp___2 = findeol();
          }
#line 487
          return (tmp___2);
        }
        {
#line 483
        c = lgetc(0);
        }
#line 483
        if (c != -1) {
          {
#line 483
          tmp___3 = __ctype_b_loc();
          }
#line 483
          if (! ((int const   )*(*tmp___3 + c) & 2048)) {
#line 483
            goto while_break___2;
          }
        } else {
#line 483
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 490
      lungetc(c);
      }
#line 491
      if ((unsigned long )p == (unsigned long )(buf___0 + 1)) {
#line 491
        if ((int )buf___0[0] == 45) {
#line 492
          goto nodigits;
        }
      }
#line 493
      if (c == -1) {
#line 493
        goto _L___0;
      } else {
        {
#line 493
        tmp___6 = __ctype_b_loc();
        }
#line 493
        if ((int const   )*(*tmp___6 + c) & 8192) {
#line 493
          goto _L___0;
        } else
#line 493
        if (c == 41) {
#line 493
          goto _L___0;
        } else
#line 493
        if (c == 44) {
#line 493
          goto _L___0;
        } else
#line 493
        if (c == 47) {
#line 493
          goto _L___0;
        } else
#line 493
        if (c == 125) {
#line 493
          goto _L___0;
        } else
#line 493
        if (c == 61) {
          _L___0: /* CIL Label */ 
          {
#line 494
          errstr = (char const   *)((void *)0);
#line 496
          *p = (char )'\000';
#line 497
          tmp___4 = strtonum((char const   *)(buf___0), (-0x7FFFFFFFFFFFFFFF-1), 9223372036854775807LL,
                             & errstr);
#line 497
          yylval.v.number = (int64_t )tmp___4;
          }
#line 499
          if (errstr) {
            {
#line 500
            yyerror("\"%s\" invalid number: %s", buf___0, errstr);
#line 502
            tmp___5 = findeol();
            }
#line 502
            return (tmp___5);
          }
#line 504
          return (266);
        } else {
          nodigits: 
          {
#line 507
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 507
            if (! ((unsigned long )p > (unsigned long )(buf___0 + 1))) {
#line 507
              goto while_break___3;
            }
            {
#line 508
            p --;
#line 508
            lungetc((int )*p);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 509
          p --;
#line 509
          c = (int )*p;
#line 510
          if (c == 45) {
#line 511
            return (c);
          }
        }
      }
    }
  }
  {
#line 521
  tmp___12 = __ctype_b_loc();
  }
#line 521
  if ((int const   )*(*tmp___12 + c) & 8) {
#line 521
    goto _L___2;
  } else
#line 521
  if (c == 58) {
#line 521
    goto _L___2;
  } else
#line 521
  if (c == 95) {
#line 521
    goto _L___2;
  } else
#line 521
  if (c == 42) {
    _L___2: /* CIL Label */ 
    {
#line 522
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 523
      tmp___8 = p;
#line 523
      p ++;
#line 523
      *tmp___8 = (char )c;
#line 524
      if ((unsigned long )((unsigned int )(p - buf___0)) >= sizeof(buf___0)) {
        {
#line 525
        yyerror("string too long");
#line 526
        tmp___9 = findeol();
        }
#line 526
        return (tmp___9);
      }
      {
#line 522
      c = lgetc(0);
      }
#line 522
      if (c != -1) {
        {
#line 522
        tmp___10 = __ctype_b_loc();
        }
#line 522
        if (! ((int const   )*(*tmp___10 + c) & 8)) {
          {
#line 522
          tmp___11 = __ctype_b_loc();
          }
#line 522
          if ((int const   )*(*tmp___11 + c) & 4) {
#line 522
            if (c != 40) {
#line 522
              if (c != 41) {
#line 522
                if (c != 123) {
#line 522
                  if (c != 125) {
#line 522
                    if (c != 60) {
#line 522
                      if (c != 62) {
#line 522
                        if (c != 33) {
#line 522
                          if (c != 61) {
#line 522
                            if (c != 47) {
#line 522
                              if (c != 35) {
#line 522
                                if (! (c != 44)) {
#line 522
                                  goto while_break___4;
                                }
                              } else {
#line 522
                                goto while_break___4;
                              }
                            } else {
#line 522
                              goto while_break___4;
                            }
                          } else {
#line 522
                            goto while_break___4;
                          }
                        } else {
#line 522
                          goto while_break___4;
                        }
                      } else {
#line 522
                        goto while_break___4;
                      }
                    } else {
#line 522
                      goto while_break___4;
                    }
                  } else {
#line 522
                    goto while_break___4;
                  }
                } else {
#line 522
                  goto while_break___4;
                }
              } else {
#line 522
                goto while_break___4;
              }
            } else {
#line 522
              goto while_break___4;
            }
          } else {
#line 522
            goto while_break___4;
          }
        }
      } else {
#line 522
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 529
    lungetc(c);
#line 530
    *p = (char )'\000';
#line 531
    token = lookup(buf___0);
    }
#line 531
    if (token == 265) {
      {
#line 532
      yylval.v.string = strdup((char const   *)(buf___0));
      }
#line 532
      if ((unsigned long )yylval.v.string == (unsigned long )((void *)0)) {
        {
#line 533
        fatal("yylex: strdup");
        }
      }
    }
#line 534
    return (token);
  }
#line 536
  if (c == 10) {
#line 537
    yylval.lineno = file->lineno;
#line 538
    (file->lineno) ++;
  }
#line 540
  if (c == -1) {
#line 541
    return (0);
  }
#line 542
  return (c);
}
}
#line 545 "/usr/src/usr.sbin/ntpd/parse.y"
struct file *pushfile(char const   *name ) 
{ 
  struct file *nfile ;
  void *tmp ;
  char *tmp___0 ;
  FILE *tmp___1 ;

  {
  {
#line 550
  tmp = calloc((size_t )1, sizeof(struct file ));
#line 550
  nfile = (struct file *)tmp;
  }
#line 550
  if ((unsigned long )nfile == (unsigned long )((void *)0)) {
    {
#line 552
    log_warn("malloc");
    }
#line 553
    return ((struct file *)((void *)0));
  } else {
    {
#line 550
    tmp___0 = strdup(name);
#line 550
    nfile->name = tmp___0;
    }
#line 550
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 552
      log_warn("malloc");
      }
#line 553
      return ((struct file *)((void *)0));
    }
  }
  {
#line 555
  tmp___1 = fopen((char const   */* __restrict  */)nfile->name, (char const   */* __restrict  */)"r");
#line 555
  nfile->stream = tmp___1;
  }
#line 555
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 556
    log_warn("%s", nfile->name);
#line 557
    free((void *)nfile->name);
#line 558
    free((void *)nfile);
    }
#line 559
    return ((struct file *)((void *)0));
  }
#line 561
  nfile->lineno = 1;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    nfile->entry.tqe_next = (struct file *)((void *)0);
#line 562
    nfile->entry.tqe_prev = files.tqh_last;
#line 562
    *(files.tqh_last) = nfile;
#line 562
    files.tqh_last = & nfile->entry.tqe_next;
#line 562
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  return (nfile);
}
}
#line 566 "/usr/src/usr.sbin/ntpd/parse.y"
int popfile(void) 
{ 
  struct file *prev ;

  {
#line 571
  prev = *(((struct files *)file->entry.tqe_prev)->tqh_last);
#line 571
  if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 572
    prev->errors += file->errors;
    {
#line 573
    while (1) {
      while_continue: /* CIL Label */ ;
#line 573
      if ((unsigned long )file->entry.tqe_next != (unsigned long )((void *)0)) {
#line 573
        (file->entry.tqe_next)->entry.tqe_prev = file->entry.tqe_prev;
      } else {
#line 573
        files.tqh_last = file->entry.tqe_prev;
      }
#line 573
      *(file->entry.tqe_prev) = file->entry.tqe_next;
#line 573
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 574
    fclose(file->stream);
#line 575
    free((void *)file->name);
#line 576
    free((void *)file);
#line 577
    file = prev;
    }
#line 578
    return (0);
  }
#line 580
  return (-1);
}
}
#line 583 "/usr/src/usr.sbin/ntpd/parse.y"
int parse_config(char const   *filename , struct ntpd_conf *xconf ) 
{ 
  int errors ;
  int tmp ;

  {
#line 586
  errors = 0;
#line 588
  conf = xconf;
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    conf->listen_addrs.tqh_first = (struct listen_addr *)((void *)0);
#line 589
    conf->listen_addrs.tqh_last = & conf->listen_addrs.tqh_first;
#line 589
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 590
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 590
    conf->ntp_peers.tqh_first = (struct ntp_peer *)((void *)0);
#line 590
    conf->ntp_peers.tqh_last = & conf->ntp_peers.tqh_first;
#line 590
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 591
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 591
    conf->ntp_conf_sensors.tqh_first = (struct ntp_conf_sensor *)((void *)0);
#line 591
    conf->ntp_conf_sensors.tqh_last = & conf->ntp_conf_sensors.tqh_first;
#line 591
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 593
  file = pushfile(filename);
  }
#line 593
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 594
    return (-1);
  }
  {
#line 597
  yyparse();
#line 598
  errors = file->errors;
#line 599
  popfile();
  }
#line 601
  if (errors) {
#line 601
    tmp = -1;
  } else {
#line 601
    tmp = 0;
  }
#line 601
  return (tmp);
}
}
#line 585 "y.tab.c"
static int yygrowstack(void) 
{ 
  int newsize ;
  int i ;
  short *newss ;
  YYSTYPE *newvs ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 594
  newsize = yystacksize;
#line 594
  if (newsize == 0) {
#line 595
    newsize = 200;
  } else
#line 596
  if (newsize >= 10000) {
#line 597
    return (-1);
  } else {
#line 598
    newsize *= 2;
#line 598
    if (newsize > 10000) {
#line 599
      newsize = 10000;
    }
  }
#line 600
  i = (int )(yyssp - yyss);
#line 606
  if (newsize) {
#line 606
    if (0xffffffffffffffffUL / (unsigned long )newsize < sizeof(*newss)) {
#line 607
      goto bail;
    }
  }
#line 608
  if (yyss) {
    {
#line 608
    tmp = realloc((void *)yyss, (unsigned long )newsize * sizeof(*newss));
#line 608
    newss = (short *)tmp;
    }
  } else {
    {
#line 608
    tmp___0 = malloc((unsigned long )newsize * sizeof(*newss));
#line 608
    newss = (short *)tmp___0;
    }
  }
#line 610
  if ((unsigned long )newss == (unsigned long )((void *)0)) {
#line 611
    goto bail;
  }
#line 612
  yyss = newss;
#line 613
  yyssp = newss + i;
#line 614
  if (newsize) {
#line 614
    if (0xffffffffffffffffUL / (unsigned long )newsize < sizeof(*newvs)) {
#line 615
      goto bail;
    }
  }
#line 616
  if (yyvs) {
    {
#line 616
    tmp___1 = realloc((void *)yyvs, (unsigned long )newsize * sizeof(*newvs));
#line 616
    newvs = (YYSTYPE *)tmp___1;
    }
  } else {
    {
#line 616
    tmp___2 = malloc((unsigned long )newsize * sizeof(*newvs));
#line 616
    newvs = (YYSTYPE *)tmp___2;
    }
  }
#line 618
  if ((unsigned long )newvs == (unsigned long )((void *)0)) {
#line 619
    goto bail;
  }
#line 620
  yyvs = newvs;
#line 621
  yyvsp = newvs + i;
#line 622
  yystacksize = newsize;
#line 623
  yysslim = (yyss + newsize) - 1;
#line 624
  return (0);
  bail: 
#line 626
  if (yyss) {
    {
#line 627
    free((void *)yyss);
    }
  }
#line 628
  if (yyvs) {
    {
#line 629
    free((void *)yyvs);
    }
  }
#line 630
  yyssp = (short *)((void *)0);
#line 630
  yyss = yyssp;
#line 631
  yyvsp = (YYSTYPE *)((void *)0);
#line 631
  yyvs = yyvsp;
#line 632
  yystacksize = 0;
#line 633
  return (-1);
}
}
#line 640 "y.tab.c"
int yyparse(void) 
{ 
  int yym ;
  int yyn ;
  int yystate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct listen_addr *la ;
  struct ntp_addr *h ;
  struct ntp_addr *next ;
  int tmp___2 ;
  void *tmp___3 ;
  struct ntp_peer *p ;
  struct ntp_addr *h___0 ;
  struct ntp_addr *next___0 ;
  struct ntp_peer *p___0 ;
  struct ntp_addr *h___1 ;
  struct ntp_addr *next___1 ;
  struct ntp_conf_sensor *s ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 663
  yynerrs = 0;
#line 664
  yyerrflag = 0;
#line 665
  yychar = -1;
#line 667
  if ((unsigned long )yyss == (unsigned long )((void *)0)) {
    {
#line 667
    tmp = yygrowstack();
    }
#line 667
    if (tmp) {
#line 667
      goto yyoverflow;
    }
  }
#line 668
  yyssp = yyss;
#line 669
  yyvsp = yyvs;
#line 670
  yystate = 0;
#line 670
  *yyssp = (short )yystate;
  yyloop: 
#line 673
  yyn = (int )yydefred[yystate];
#line 673
  if (yyn != 0) {
#line 673
    goto yyreduce;
  }
#line 674
  if (yychar < 0) {
    {
#line 676
    yychar = yylex();
    }
#line 676
    if (yychar < 0) {
#line 676
      yychar = 0;
    }
  }
#line 688
  yyn = (int )yysindex[yystate];
#line 688
  if (yyn) {
#line 688
    yyn += yychar;
#line 688
    if (yyn >= 0) {
#line 688
      if (yyn <= 260) {
#line 688
        if ((int const   )yycheck[yyn] == (int const   )yychar) {
#line 696
          if ((unsigned long )yyssp >= (unsigned long )yysslim) {
            {
#line 696
            tmp___0 = yygrowstack();
            }
#line 696
            if (tmp___0) {
#line 698
              goto yyoverflow;
            }
          }
#line 700
          yyssp ++;
#line 700
          yystate = (int )yytable[yyn];
#line 700
          *yyssp = (short )yystate;
#line 701
          yyvsp ++;
#line 701
          *yyvsp = yylval;
#line 702
          yychar = -1;
#line 703
          if (yyerrflag > 0) {
#line 703
            yyerrflag --;
          }
#line 704
          goto yyloop;
        }
      }
    }
  }
#line 706
  yyn = (int )yyrindex[yystate];
#line 706
  if (yyn) {
#line 706
    yyn += yychar;
#line 706
    if (yyn >= 0) {
#line 706
      if (yyn <= 260) {
#line 706
        if ((int const   )yycheck[yyn] == (int const   )yychar) {
#line 709
          yyn = (int )yytable[yyn];
#line 710
          goto yyreduce;
        }
      }
    }
  }
#line 712
  if (yyerrflag) {
#line 712
    goto yyinrecovery;
  }
#line 714
  goto yynewerror;
  yynewerror: 
  {
#line 717
  yyerror("syntax error");
  }
#line 719
  goto yyerrlab;
  yyerrlab: 
#line 722
  yynerrs ++;
  yyinrecovery: 
#line 724
  if (yyerrflag < 3) {
#line 726
    yyerrflag = 3;
    {
#line 727
    while (1) {
      while_continue: /* CIL Label */ ;
#line 729
      yyn = (int )yysindex[*yyssp];
#line 729
      if (yyn) {
#line 729
        yyn += 256;
#line 729
        if (yyn >= 0) {
#line 729
          if (yyn <= 260) {
#line 729
            if ((int const   )yycheck[yyn] == 256) {
#line 737
              if ((unsigned long )yyssp >= (unsigned long )yysslim) {
                {
#line 737
                tmp___1 = yygrowstack();
                }
#line 737
                if (tmp___1) {
#line 739
                  goto yyoverflow;
                }
              }
#line 741
              yyssp ++;
#line 741
              yystate = (int )yytable[yyn];
#line 741
              *yyssp = (short )yystate;
#line 742
              yyvsp ++;
#line 742
              *yyvsp = yylval;
#line 743
              goto yyloop;
            } else {
#line 729
              goto _L___1;
            }
          } else {
#line 729
            goto _L___1;
          }
        } else {
#line 729
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 752
        if ((unsigned long )yyssp <= (unsigned long )yyss) {
#line 752
          goto yyabort;
        }
#line 753
        yyssp --;
#line 754
        yyvsp --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 760
    if (yychar == 0) {
#line 760
      goto yyabort;
    }
#line 771
    yychar = -1;
#line 772
    goto yyloop;
  }
  yyreduce: 
#line 780
  yym = (int )yylen[yyn];
#line 781
  yyval = *(yyvsp + (1 - yym));
  {
#line 784
  if (yyn == 4) {
#line 784
    goto case_4;
  }
#line 95
  if (yyn == 5) {
#line 95 "/usr/src/usr.sbin/ntpd/parse.y"
    goto case_5;
  }
#line 129
  if (yyn == 6) {
#line 129
    goto case_6;
  }
#line 168
  if (yyn == 7) {
#line 168
    goto case_7;
  }
#line 201
  if (yyn == 8) {
#line 201
    goto case_8;
  }
#line 210
  if (yyn == 9) {
#line 210
    goto case_9;
  }
#line 225
  if (yyn == 10) {
#line 225
    goto case_10;
  }
#line 228
  if (yyn == 11) {
#line 228
    goto case_11;
  }
#line 230
  if (yyn == 12) {
#line 230
    goto case_12;
  }
#line 231
  if (yyn == 16) {
#line 231
    goto case_16;
  }
#line 239
  if (yyn == 17) {
#line 239
    goto case_17;
  }
#line 241
  if (yyn == 18) {
#line 241
    goto case_18;
  }
#line 242
  if (yyn == 23) {
#line 242
    goto case_23;
  }
#line 258
  if (yyn == 24) {
#line 258
    goto case_24;
  }
#line 782 "y.tab.c"
  goto switch_break;
  case_4: /* CIL Label */ 
#line 93 "/usr/src/usr.sbin/ntpd/parse.y"
  (file->errors) ++;
#line 94
  goto switch_break;
  case_5: /* CIL Label */ 
#line 100
  h = ((yyvsp + 0)->v.addr)->a;
#line 100
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 100
    tmp___2 = host_dns((char const   *)((yyvsp + 0)->v.addr)->name, & h);
    }
#line 100
    if (tmp___2 == -1) {
      {
#line 102
      yyerror("could not resolve \"%s\"", ((yyvsp + 0)->v.addr)->name);
#line 103
      free((void *)((yyvsp + 0)->v.addr)->name);
#line 104
      free((void *)(yyvsp + 0)->v.addr);
      }
#line 105
      goto yyerrlab;
    } else
#line 100
    if (! h) {
      {
#line 102
      yyerror("could not resolve \"%s\"", ((yyvsp + 0)->v.addr)->name);
#line 103
      free((void *)((yyvsp + 0)->v.addr)->name);
#line 104
      free((void *)(yyvsp + 0)->v.addr);
      }
#line 105
      goto yyerrlab;
    }
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 108
      goto while_break___0;
    }
#line 109
    next = h->next;
#line 110
    if ((int )h->ss.ss_family == 0) {
      {
#line 111
      conf->listen_all = (u_int8_t )1;
#line 112
      free((void *)h);
      }
#line 113
      goto __Cont;
    }
    {
#line 115
    tmp___3 = calloc((size_t )1, sizeof(struct listen_addr ));
#line 115
    la = (struct listen_addr *)tmp___3;
    }
#line 116
    if ((unsigned long )la == (unsigned long )((void *)0)) {
      {
#line 117
      fatal("listen on calloc");
      }
    }
    {
#line 118
    la->fd = -1;
#line 119
    memcpy((void */* __restrict  */)(& la->sa), (void const   */* __restrict  */)(& h->ss),
           sizeof(struct sockaddr_storage ));
    }
    {
#line 121
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 121
      la->entry.tqe_next = (struct listen_addr *)((void *)0);
#line 121
      la->entry.tqe_prev = conf->listen_addrs.tqh_last;
#line 121
      *(conf->listen_addrs.tqh_last) = la;
#line 121
      conf->listen_addrs.tqh_last = & la->entry.tqe_next;
#line 121
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 123
    free((void *)h);
    }
    __Cont: /* CIL Label */ 
#line 108
    h = next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 125
  free((void *)((yyvsp + 0)->v.addr)->name);
#line 126
  free((void *)(yyvsp + 0)->v.addr);
  }
#line 128
  goto switch_break;
  case_6: /* CIL Label */ 
#line 132
  h___0 = ((yyvsp + -1)->v.addr)->a;
  {
#line 133
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 134
    if ((unsigned long )h___0 != (unsigned long )((void *)0)) {
#line 135
      next___0 = h___0->next;
#line 136
      if ((int )h___0->ss.ss_family != 2) {
#line 136
        if ((int )h___0->ss.ss_family != 10) {
          {
#line 138
          yyerror("IPv4 or IPv6 address or hostname expected");
#line 140
          free((void *)h___0);
#line 141
          free((void *)((yyvsp + -1)->v.addr)->name);
#line 142
          free((void *)(yyvsp + -1)->v.addr);
          }
#line 143
          goto yyerrlab;
        }
      }
#line 145
      h___0->next = (struct ntp_addr *)((void *)0);
    } else {
#line 147
      next___0 = (struct ntp_addr *)((void *)0);
    }
    {
#line 149
    p = new_peer();
#line 150
    p->weight = (u_int8_t )(yyvsp + 0)->v.opts.weight;
#line 151
    p->addr = h___0;
#line 152
    p->addr_head.a = h___0;
#line 153
    p->addr_head.pool = (u_int8_t )1;
#line 154
    p->addr_head.name = strdup((char const   *)((yyvsp + -1)->v.addr)->name);
    }
#line 155
    if ((unsigned long )p->addr_head.name == (unsigned long )((void *)0)) {
      {
#line 156
      fatal((char const   *)((void *)0));
      }
    }
#line 157
    if ((unsigned long )p->addr != (unsigned long )((void *)0)) {
#line 158
      p->state = (enum client_state )3;
    }
    {
#line 159
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 159
      p->entry.tqe_next = (struct ntp_peer *)((void *)0);
#line 159
      p->entry.tqe_prev = conf->ntp_peers.tqh_last;
#line 159
      *(conf->ntp_peers.tqh_last) = p;
#line 159
      conf->ntp_peers.tqh_last = & p->entry.tqe_next;
#line 159
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 161
    h___0 = next___0;
#line 133
    if (! ((unsigned long )h___0 != (unsigned long )((void *)0))) {
#line 133
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 164
  free((void *)((yyvsp + -1)->v.addr)->name);
#line 165
  free((void *)(yyvsp + -1)->v.addr);
  }
#line 167
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 171
  p___0 = new_peer();
#line 172
  h___1 = ((yyvsp + -1)->v.addr)->a;
  }
  {
#line 172
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 172
    if (! ((unsigned long )h___1 != (unsigned long )((void *)0))) {
#line 172
      goto while_break___4;
    }
#line 173
    next___1 = h___1->next;
#line 174
    if ((int )h___1->ss.ss_family != 2) {
#line 174
      if ((int )h___1->ss.ss_family != 10) {
        {
#line 176
        yyerror("IPv4 or IPv6 address or hostname expected");
#line 178
        free((void *)h___1);
#line 179
        free((void *)p___0);
#line 180
        free((void *)((yyvsp + -1)->v.addr)->name);
#line 181
        free((void *)(yyvsp + -1)->v.addr);
        }
#line 182
        goto yyerrlab;
      }
    }
#line 184
    h___1->next = p___0->addr;
#line 185
    p___0->addr = h___1;
#line 172
    h___1 = next___1;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 188
  p___0->weight = (u_int8_t )(yyvsp + 0)->v.opts.weight;
#line 189
  p___0->addr_head.a = p___0->addr;
#line 190
  p___0->addr_head.pool = (u_int8_t )0;
#line 191
  p___0->addr_head.name = strdup((char const   *)((yyvsp + -1)->v.addr)->name);
  }
#line 192
  if ((unsigned long )p___0->addr_head.name == (unsigned long )((void *)0)) {
    {
#line 193
    fatal((char const   *)((void *)0));
    }
  }
#line 194
  if ((unsigned long )p___0->addr != (unsigned long )((void *)0)) {
#line 195
    p___0->state = (enum client_state )3;
  }
  {
#line 196
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 196
    p___0->entry.tqe_next = (struct ntp_peer *)((void *)0);
#line 196
    p___0->entry.tqe_prev = conf->ntp_peers.tqh_last;
#line 196
    *(conf->ntp_peers.tqh_last) = p___0;
#line 196
    conf->ntp_peers.tqh_last = & p___0->entry.tqe_next;
#line 196
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)((yyvsp + -1)->v.addr)->name);
#line 198
  free((void *)(yyvsp + -1)->v.addr);
  }
#line 200
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 203
  s = new_sensor((yyvsp + -1)->v.string);
#line 204
  s->weight = (u_int8_t )(yyvsp + 0)->v.opts.weight;
#line 205
  s->correction = (yyvsp + 0)->v.opts.correction;
#line 206
  free((void *)(yyvsp + -1)->v.string);
  }
  {
#line 207
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 207
    s->entry.tqe_next = (struct ntp_conf_sensor *)((void *)0);
#line 207
    s->entry.tqe_prev = conf->ntp_conf_sensors.tqh_last;
#line 207
    *(conf->ntp_conf_sensors.tqh_last) = s;
#line 207
    conf->ntp_conf_sensors.tqh_last = & s->entry.tqe_next;
#line 207
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 209
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 212
  tmp___4 = calloc((size_t )1, sizeof(struct ntp_addr_wrap ));
#line 212
  yyval.v.addr = (struct ntp_addr_wrap *)tmp___4;
  }
#line 212
  if ((unsigned long )yyval.v.addr == (unsigned long )((void *)0)) {
    {
#line 214
    fatal((char const   *)((void *)0));
    }
  }
  {
#line 215
  tmp___5 = host((char const   *)(yyvsp + 0)->v.string, & (yyval.v.addr)->a);
  }
#line 215
  if (tmp___5 == -1) {
    {
#line 216
    yyerror("could not parse address spec \"%s\"", (yyvsp + 0)->v.string);
#line 218
    free((void *)(yyvsp + 0)->v.string);
#line 219
    free((void *)yyval.v.addr);
    }
#line 220
    goto yyerrlab;
  }
#line 222
  (yyval.v.addr)->name = (yyvsp + 0)->v.string;
#line 224
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 226
  opts_default();
  }
#line 227
  goto switch_break;
  case_11: /* CIL Label */ 
#line 228
  yyval.v.opts = opts;
#line 229
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 229
  opts_default();
#line 229
  yyval.v.opts = opts;
  }
#line 230
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 237
  opts_default();
  }
#line 238
  goto switch_break;
  case_17: /* CIL Label */ 
#line 239
  yyval.v.opts = opts;
#line 240
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 240
  opts_default();
#line 240
  yyval.v.opts = opts;
  }
#line 241
  goto switch_break;
  case_23: /* CIL Label */ 
#line 250
  if ((yyvsp + 0)->v.number < -127000000L) {
    {
#line 251
    yyerror("correction must be between -127000000 and 127000000 microseconds");
    }
#line 253
    goto yyerrlab;
  } else
#line 250
  if ((yyvsp + 0)->v.number > 127000000L) {
    {
#line 251
    yyerror("correction must be between -127000000 and 127000000 microseconds");
    }
#line 253
    goto yyerrlab;
  }
#line 255
  opts.correction = (int )(yyvsp + 0)->v.number;
#line 257
  goto switch_break;
  case_24: /* CIL Label */ 
#line 260
  if ((yyvsp + 0)->v.number < 1L) {
    {
#line 261
    yyerror("weight must be between 1 and 10");
    }
#line 262
    goto yyerrlab;
  } else
#line 260
  if ((yyvsp + 0)->v.number > 10L) {
    {
#line 261
    yyerror("weight must be between 1 and 10");
    }
#line 262
    goto yyerrlab;
  }
#line 264
  opts.weight = (int )(yyvsp + 0)->v.number;
#line 266
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 976 "y.tab.c"
  yyssp -= yym;
#line 977
  yystate = (int )*yyssp;
#line 978
  yyvsp -= yym;
#line 979
  yym = (int )yylhs[yyn];
#line 980
  if (yystate == 0) {
#line 980
    if (yym == 0) {
#line 987
      yystate = 1;
#line 988
      yyssp ++;
#line 988
      *yyssp = (short)1;
#line 989
      yyvsp ++;
#line 989
      *yyvsp = yyval;
#line 990
      if (yychar < 0) {
        {
#line 992
        yychar = yylex();
        }
#line 992
        if (yychar < 0) {
#line 992
          yychar = 0;
        }
      }
#line 1004
      if (yychar == 0) {
#line 1004
        goto yyaccept;
      }
#line 1005
      goto yyloop;
    }
  }
#line 1007
  yyn = (int )yygindex[yym];
#line 1007
  if (yyn) {
#line 1007
    yyn += yystate;
#line 1007
    if (yyn >= 0) {
#line 1007
      if (yyn <= 260) {
#line 1007
        if ((int const   )yycheck[yyn] == (int const   )yystate) {
#line 1009
          yystate = (int )yytable[yyn];
        } else {
#line 1011
          yystate = (int )yydgoto[yym];
        }
      } else {
#line 1011
        yystate = (int )yydgoto[yym];
      }
    } else {
#line 1011
      yystate = (int )yydgoto[yym];
    }
  } else {
#line 1011
    yystate = (int )yydgoto[yym];
  }
#line 1017
  if ((unsigned long )yyssp >= (unsigned long )yysslim) {
    {
#line 1017
    tmp___6 = yygrowstack();
    }
#line 1017
    if (tmp___6) {
#line 1019
      goto yyoverflow;
    }
  }
#line 1021
  yyssp ++;
#line 1021
  *yyssp = (short )yystate;
#line 1022
  yyvsp ++;
#line 1022
  *yyvsp = yyval;
#line 1023
  goto yyloop;
  yyoverflow: 
  {
#line 1025
  yyerror("yacc stack overflow");
  }
  yyabort: 
#line 1027
  if (yyss) {
    {
#line 1028
    free((void *)yyss);
    }
  }
#line 1029
  if (yyvs) {
    {
#line 1030
    free((void *)yyvs);
    }
  }
#line 1031
  yyssp = (short *)((void *)0);
#line 1031
  yyss = yyssp;
#line 1032
  yyvsp = (YYSTYPE *)((void *)0);
#line 1032
  yyvs = yyvsp;
#line 1033
  yystacksize = 0;
#line 1034
  return (1);
  yyaccept: 
#line 1036
  if (yyss) {
    {
#line 1037
    free((void *)yyss);
    }
  }
#line 1038
  if (yyvs) {
    {
#line 1039
    free((void *)yyvs);
    }
  }
#line 1040
  yyssp = (short *)((void *)0);
#line 1040
  yyss = yyssp;
#line 1041
  yyvsp = (YYSTYPE *)((void *)0);
#line 1041
  yyvs = yyvsp;
#line 1042
  yystacksize = 0;
#line 1043
  return (0);
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 293 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 677 "/usr/include/netdb.h"
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 246 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
char const   *log_sockaddr(struct sockaddr *sa ) ;
#line 31 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
int debug  ;
#line 34
void logit(int pri , char const   *fmt  , ...) ;
#line 36 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
void log_init(int n_debug ) 
{ 


  {
#line 41
  debug = n_debug;
#line 43
  if (! debug) {
    {
#line 44
    openlog((char const   *)__progname, 9, 3 << 3);
    }
  }
  {
#line 46
  tzset();
  }
#line 47
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
void logit(int pri , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 54
  __builtin_va_start(ap, fmt);
#line 55
  vlog(pri, fmt, ap);
#line 56
  __builtin_va_end(ap);
  }
#line 57
  return;
}
}
#line 59 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
void vlog(int pri , char const   *fmt , va_list ap ) 
{ 
  char *nfmt ;
  int tmp ;

  {
#line 64
  if (debug) {
    {
#line 66
    tmp = asprintf((char **/* __restrict  */)(& nfmt), (char const   */* __restrict  */)"%s\n",
                   fmt);
    }
#line 66
    if (tmp == -1) {
      {
#line 67
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
               ap);
#line 68
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 70
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)nfmt,
               ap);
#line 71
      free((void *)nfmt);
      }
    }
    {
#line 73
    fflush(stderr);
    }
  } else {
    {
#line 75
    vsyslog(pri, fmt, ap);
    }
  }
#line 76
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
void log_warn(char const   *emsg  , ...) 
{ 
  char *nfmt ;
  va_list ap ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 86
  if ((unsigned long )emsg == (unsigned long )((void *)0)) {
    {
#line 87
    tmp = __errno_location();
#line 87
    tmp___0 = strerror(*tmp);
#line 87
    logit(2, "%s", tmp___0);
    }
  } else {
    {
#line 89
    __builtin_va_start(ap, emsg);
#line 91
    tmp___3 = __errno_location();
#line 91
    tmp___4 = strerror(*tmp___3);
#line 91
    tmp___5 = asprintf((char **/* __restrict  */)(& nfmt), (char const   */* __restrict  */)"%s: %s",
                       emsg, tmp___4);
    }
#line 91
    if (tmp___5 == -1) {
      {
#line 93
      vlog(2, emsg, ap);
#line 94
      tmp___1 = __errno_location();
#line 94
      tmp___2 = strerror(*tmp___1);
#line 94
      logit(2, "%s", tmp___2);
      }
    } else {
      {
#line 96
      vlog(2, (char const   *)nfmt, ap);
#line 97
      free((void *)nfmt);
      }
    }
    {
#line 99
    __builtin_va_end(ap);
    }
  }
#line 101
  return;
}
}
#line 103 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
void log_warnx(char const   *emsg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 108
  __builtin_va_start(ap, emsg);
#line 109
  vlog(2, emsg, ap);
#line 110
  __builtin_va_end(ap);
  }
#line 111
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
void log_info(char const   *emsg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 118
  __builtin_va_start(ap, emsg);
#line 119
  vlog(6, emsg, ap);
#line 120
  __builtin_va_end(ap);
  }
#line 121
  return;
}
}
#line 123 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
void log_debug(char const   *emsg  , ...) 
{ 
  va_list ap ;

  {
#line 128
  if (debug) {
    {
#line 129
    __builtin_va_start(ap, emsg);
#line 130
    vlog(7, emsg, ap);
#line 131
    __builtin_va_end(ap);
    }
  } else
#line 128
  if (debugsyslog) {
    {
#line 129
    __builtin_va_start(ap, emsg);
#line 130
    vlog(7, emsg, ap);
#line 131
    __builtin_va_end(ap);
    }
  }
#line 133
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
void fatal(char const   *emsg ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 138
  if ((unsigned long )emsg == (unsigned long )((void *)0)) {
    {
#line 139
    tmp = __errno_location();
#line 139
    tmp___0 = strerror(*tmp);
#line 139
    logit(2, "fatal: %s", tmp___0);
    }
  } else {
    {
#line 141
    tmp___3 = __errno_location();
    }
#line 141
    if (*tmp___3) {
      {
#line 142
      tmp___1 = __errno_location();
#line 142
      tmp___2 = strerror(*tmp___1);
#line 142
      logit(2, "fatal: %s: %s", emsg, tmp___2);
      }
    } else {
      {
#line 145
      logit(2, "fatal: %s", emsg);
      }
    }
  }
  {
#line 147
  exit(1);
  }
}
}
#line 150 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
void fatalx(char const   *emsg ) 
{ 
  int *tmp ;

  {
  {
#line 153
  tmp = __errno_location();
#line 153
  *tmp = 0;
#line 154
  fatal(emsg);
  }
#line 155
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
static char buf[1025]  ;
#line 157 "/home/wheatley/newnew/temp/openntpd-20080406p/log.c"
char const   *log_sockaddr(struct sockaddr *sa ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 162
  if ((int )sa->sa_family == 10) {
#line 162
    tmp = sizeof(struct sockaddr_in6 );
  } else {
#line 162
    tmp = sizeof(struct sockaddr_in );
  }
  {
#line 162
  tmp___0 = getnameinfo((struct sockaddr  const  */* __restrict  */)sa, (socklen_t )tmp,
                        (char */* __restrict  */)(buf), (socklen_t )sizeof(buf), (char */* __restrict  */)((void *)0),
                        (socklen_t )0, 1);
  }
#line 162
  if (tmp___0) {
#line 164
    return ("(unknown)");
  } else {
#line 166
    return ((char const   *)(buf));
  }
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 66 "/usr/include/ifaddrs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getifaddrs)(struct ifaddrs **__ifap ) ;
#line 69
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeifaddrs)(struct ifaddrs *__ifa ) ;
#line 287 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
int ntp_getmsg(struct sockaddr *sa , char *p , ssize_t len , struct ntp_msg *msg ) ;
#line 288
int ntp_sendmsg(int fd , struct sockaddr *sa , struct ntp_msg *msg , ssize_t len ,
                int auth ) ;
#line 291
int setup_listeners(struct servent *se , struct ntpd_conf *lconf , u_int *cnt ) ;
#line 293
int server_dispatch(int fd , struct ntpd_conf *lconf ) ;
#line 35 "/home/wheatley/newnew/temp/openntpd-20080406p/server.c"
int setup_listeners(struct servent *se , struct ntpd_conf *lconf , u_int *cnt ) 
{ 
  struct listen_addr *la ;
  struct ifaddrs *ifa ;
  struct ifaddrs *ifap ;
  struct sockaddr *sa ;
  u_int8_t *a6 ;
  size_t sa6len ;
  u_int new_cnt ;
  int tos ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;

  {
#line 42
  sa6len = sizeof(struct in6_addr );
#line 43
  new_cnt = (u_int )0;
#line 44
  tos = 16;
#line 46
  if (lconf->listen_all) {
    {
#line 47
    tmp = getifaddrs(& ifa);
    }
#line 47
    if (tmp == -1) {
      {
#line 48
      fatal("getifaddrs");
      }
    }
#line 50
    ifap = ifa;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! ((unsigned long )ifap != (unsigned long )((void *)0))) {
#line 50
        goto while_break;
      }
#line 51
      sa = ifap->ifa_addr;
#line 53
      if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 56
        goto __Cont;
      } else
#line 53
      if ((int )sa->sa_family != 2) {
#line 53
        if ((int )sa->sa_family != 10) {
#line 56
          goto __Cont;
        }
      }
#line 57
      if ((int )sa->sa_family == 10) {
#line 57
        tmp___0 = sizeof(struct sockaddr_in6 );
      } else {
#line 57
        tmp___0 = sizeof(struct sockaddr_in );
      }
#line 57
      if (tmp___0 == 0UL) {
#line 58
        goto __Cont;
      }
#line 60
      if ((int )sa->sa_family == 2) {
#line 60
        if (((struct sockaddr_in *)sa)->sin_addr.s_addr == 0U) {
#line 63
          goto __Cont;
        }
      }
#line 65
      if ((int )sa->sa_family == 10) {
        {
#line 66
        a6 = ((struct sockaddr_in6 *)sa)->sin6_addr.__in6_u.__u6_addr8;
#line 68
        tmp___1 = memcmp((void const   *)a6, (void const   *)(& in6addr_any), sa6len);
        }
#line 68
        if (tmp___1 == 0) {
#line 69
          goto __Cont;
        }
      }
      {
#line 72
      tmp___2 = calloc((size_t )1, sizeof(struct listen_addr ));
#line 72
      la = (struct listen_addr *)tmp___2;
      }
#line 72
      if ((unsigned long )la == (unsigned long )((void *)0)) {
        {
#line 74
        fatal("setup_listeners calloc");
        }
      }
#line 76
      if ((int )sa->sa_family == 10) {
#line 76
        tmp___3 = sizeof(struct sockaddr_in6 );
      } else {
#line 76
        tmp___3 = sizeof(struct sockaddr_in );
      }
      {
#line 76
      memcpy((void */* __restrict  */)(& la->sa), (void const   */* __restrict  */)sa,
             tmp___3);
      }
      {
#line 77
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 77
        la->entry.tqe_next = (struct listen_addr *)((void *)0);
#line 77
        la->entry.tqe_prev = lconf->listen_addrs.tqh_last;
#line 77
        *(lconf->listen_addrs.tqh_last) = la;
#line 77
        lconf->listen_addrs.tqh_last = & la->entry.tqe_next;
#line 77
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 50
      ifap = ifap->ifa_next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 80
    freeifaddrs(ifa);
    }
  }
#line 83
  la = lconf->listen_addrs.tqh_first;
  {
#line 83
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 83
    if (! ((unsigned long )la != (unsigned long )((void *)0))) {
#line 83
      goto while_break___1;
    }
#line 84
    new_cnt ++;
    {
#line 87
    if ((int )la->sa.ss_family == 2) {
#line 87
      goto case_2;
    }
#line 92
    if ((int )la->sa.ss_family == 10) {
#line 92
      goto case_10;
    }
#line 97
    goto switch_default;
    case_2: /* CIL Label */ 
#line 88
    if ((int )((struct sockaddr_in *)(& la->sa))->sin_port == 0) {
#line 89
      ((struct sockaddr_in *)(& la->sa))->sin_port = (in_port_t )se->s_port;
    }
#line 91
    goto switch_break;
    case_10: /* CIL Label */ 
#line 93
    if ((int )((struct sockaddr_in6 *)(& la->sa))->sin6_port == 0) {
#line 94
      ((struct sockaddr_in6 *)(& la->sa))->sin6_port = (in_port_t )se->s_port;
    }
#line 96
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 98
    fatalx("king bula sez: af borked");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 101
    tmp___4 = log_sockaddr((struct sockaddr *)(& la->sa));
#line 101
    log_info("listening on %s", tmp___4);
#line 104
    tmp___5 = socket((int )la->sa.ss_family, 2, 0);
#line 104
    la->fd = tmp___5;
    }
#line 104
    if (tmp___5 == -1) {
      {
#line 105
      fatal("socket");
      }
    }
#line 107
    if ((int )la->sa.ss_family == 2) {
      {
#line 107
      tmp___6 = setsockopt(la->fd, 0, 1, (void const   *)(& tos), (socklen_t )sizeof(tos));
      }
#line 107
      if (tmp___6 == -1) {
        {
#line 109
        log_warn("setsockopt IPTOS_LOWDELAY");
        }
      }
    }
#line 111
    if ((int )((struct sockaddr *)(& la->sa))->sa_family == 10) {
#line 111
      tmp___7 = sizeof(struct sockaddr_in6 );
    } else {
#line 111
      tmp___7 = sizeof(struct sockaddr_in );
    }
    {
#line 111
    tmp___8 = bind(la->fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& la->sa)),
                   (socklen_t )tmp___7);
    }
#line 111
    if (tmp___8 == -1) {
      {
#line 113
      fatal("bind");
      }
    }
#line 83
    la = la->entry.tqe_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 116
  *cnt = new_cnt;
#line 118
  return (0);
}
}
#line 121 "/home/wheatley/newnew/temp/openntpd-20080406p/server.c"
int server_dispatch(int fd , struct ntpd_conf *lconf ) 
{ 
  ssize_t size ;
  u_int8_t version ;
  double rectime ;
  struct sockaddr_storage fsa ;
  socklen_t fsa_len ;
  struct ntp_msg query ;
  struct ntp_msg reply ;
  char buf___0[68] ;
  char const   *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;

  {
  {
#line 132
  fsa_len = (socklen_t )sizeof(fsa);
#line 133
  size = recvfrom(fd, (void */* __restrict  */)(& buf___0), sizeof(buf___0), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& fsa)),
                  (socklen_t */* __restrict  */)(& fsa_len));
  }
#line 133
  if (size == -1L) {
    {
#line 135
    tmp___0 = __errno_location();
    }
#line 135
    if (*tmp___0 == 113) {
      {
#line 137
      tmp = log_sockaddr((struct sockaddr *)(& fsa));
#line 137
      log_warn("recvfrom %s", tmp);
      }
#line 139
      return (0);
    } else {
      {
#line 135
      tmp___1 = __errno_location();
      }
#line 135
      if (*tmp___1 == 112) {
        {
#line 137
        tmp = log_sockaddr((struct sockaddr *)(& fsa));
#line 137
        log_warn("recvfrom %s", tmp);
        }
#line 139
        return (0);
      } else {
        {
#line 135
        tmp___2 = __errno_location();
        }
#line 135
        if (*tmp___2 == 101) {
          {
#line 137
          tmp = log_sockaddr((struct sockaddr *)(& fsa));
#line 137
          log_warn("recvfrom %s", tmp);
          }
#line 139
          return (0);
        } else {
          {
#line 135
          tmp___3 = __errno_location();
          }
#line 135
          if (*tmp___3 == 100) {
            {
#line 137
            tmp = log_sockaddr((struct sockaddr *)(& fsa));
#line 137
            log_warn("recvfrom %s", tmp);
            }
#line 139
            return (0);
          } else {
            {
#line 141
            fatal("recvfrom");
            }
          }
        }
      }
    }
  }
  {
#line 144
  rectime = gettime_corrected();
#line 146
  tmp___4 = ntp_getmsg((struct sockaddr *)(& fsa), buf___0, size, & query);
  }
#line 146
  if (tmp___4 == -1) {
#line 147
    return (0);
  }
  {
#line 149
  version = (u_int8_t )(((int )query.status & (7 << 3)) >> 3);
#line 151
  bzero((void *)(& reply), sizeof(reply));
  }
#line 152
  if (lconf->status.synced) {
#line 153
    reply.status = lconf->status.leap;
  } else {
#line 155
    reply.status = (u_int8_t )(3 << 6);
  }
#line 156
  reply.status = (u_int8_t )((int )reply.status | ((int )query.status & (7 << 3)));
#line 157
  if (((int )query.status & 7) == 3) {
#line 158
    reply.status = (u_int8_t )((int )reply.status | 4);
  } else {
#line 160
    reply.status = (u_int8_t )((int )reply.status | 2);
  }
  {
#line 162
  reply.stratum = lconf->status.stratum;
#line 163
  reply.ppoll = query.ppoll;
#line 164
  reply.precision = lconf->status.precision;
#line 165
  reply.rectime = d_to_lfp(rectime);
#line 166
  reply.reftime = d_to_lfp(lconf->status.reftime);
#line 167
  tmp___5 = gettime_corrected();
#line 167
  reply.xmttime = d_to_lfp(tmp___5);
#line 168
  reply.orgtime = query.xmttime;
#line 169
  reply.rootdelay = d_to_sfp(lconf->status.rootdelay);
  }
#line 171
  if ((int )version > 3) {
#line 172
    reply.refid = lconf->status.refid4;
  } else {
#line 174
    reply.refid = lconf->status.refid;
  }
  {
#line 176
  ntp_sendmsg(fd, (struct sockaddr *)(& fsa), & reply, size, 0);
  }
#line 177
  return (0);
}
}
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 36 "/home/wheatley/newnew/temp/openntpd-20080406p/config.c"
struct ntp_addr *host_v4(char const   *s ) ;
#line 37
struct ntp_addr *host_v6(char const   *s ) ;
#line 39 "/home/wheatley/newnew/temp/openntpd-20080406p/config.c"
static u_int32_t maxid  =    (u_int32_t )0;
#line 41 "/home/wheatley/newnew/temp/openntpd-20080406p/config.c"
int host(char const   *s , struct ntp_addr **hn ) 
{ 
  struct ntp_addr *h ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 44
  h = (struct ntp_addr *)((void *)0);
#line 46
  tmp___0 = strcmp(s, "*");
  }
#line 46
  if (! tmp___0) {
    {
#line 47
    tmp = calloc((size_t )1, sizeof(struct ntp_addr ));
#line 47
    h = (struct ntp_addr *)tmp;
    }
#line 47
    if ((unsigned long )h == (unsigned long )((void *)0)) {
      {
#line 48
      fatal((char const   *)((void *)0));
      }
    }
  }
#line 51
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 52
    h = host_v4(s);
    }
  }
#line 55
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 56
    h = host_v6(s);
    }
  }
#line 58
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 59
    return (0);
  }
#line 61
  *hn = h;
#line 63
  return (1);
}
}
#line 66 "/home/wheatley/newnew/temp/openntpd-20080406p/config.c"
struct ntp_addr *host_v4(char const   *s ) 
{ 
  struct in_addr ina ;
  struct sockaddr_in *sa_in ;
  struct ntp_addr *h ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 73
  bzero((void *)(& ina), sizeof(struct in_addr ));
#line 74
  tmp = inet_pton(2, (char const   */* __restrict  */)s, (void */* __restrict  */)(& ina));
  }
#line 74
  if (tmp != 1) {
#line 75
    return ((struct ntp_addr *)((void *)0));
  }
  {
#line 77
  tmp___0 = calloc((size_t )1, sizeof(struct ntp_addr ));
#line 77
  h = (struct ntp_addr *)tmp___0;
  }
#line 77
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 78
    fatal((char const   *)((void *)0));
    }
  }
#line 79
  sa_in = (struct sockaddr_in *)(& h->ss);
#line 83
  sa_in->sin_family = (sa_family_t )2;
#line 84
  sa_in->sin_addr.s_addr = ina.s_addr;
#line 86
  return (h);
}
}
#line 89 "/home/wheatley/newnew/temp/openntpd-20080406p/config.c"
struct ntp_addr *host_v6(char const   *s ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct sockaddr_in6 *sa_in6 ;
  struct ntp_addr *h ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 94
  h = (struct ntp_addr *)((void *)0);
#line 96
  bzero((void *)(& hints), sizeof(hints));
#line 97
  hints.ai_family = 10;
#line 98
  hints.ai_socktype = 2;
#line 99
  hints.ai_flags = 4;
#line 100
  tmp___0 = getaddrinfo((char const   */* __restrict  */)s, (char const   */* __restrict  */)"0",
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 100
  if (tmp___0 == 0) {
    {
#line 101
    tmp = calloc((size_t )1, sizeof(struct ntp_addr ));
#line 101
    h = (struct ntp_addr *)tmp;
    }
#line 101
    if ((unsigned long )h == (unsigned long )((void *)0)) {
      {
#line 102
      fatal((char const   *)((void *)0));
      }
    }
    {
#line 103
    sa_in6 = (struct sockaddr_in6 *)(& h->ss);
#line 107
    sa_in6->sin6_family = (sa_family_t )10;
#line 108
    memcpy((void */* __restrict  */)(& sa_in6->sin6_addr), (void const   */* __restrict  */)(& ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr),
           sizeof(sa_in6->sin6_addr));
#line 112
    sa_in6->sin6_scope_id = ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;
#line 116
    freeaddrinfo(res);
    }
  }
#line 119
  return (h);
}
}
#line 122 "/home/wheatley/newnew/temp/openntpd-20080406p/config.c"
int host_dns(char const   *s , struct ntp_addr **hn ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *res0 ;
  struct addrinfo *res ;
  int error ;
  int cnt ;
  struct sockaddr_in *sa_in ;
  struct sockaddr_in6 *sa_in6 ;
  struct ntp_addr *h ;
  struct ntp_addr *hh ;
  char const   *tmp ;
  void *tmp___0 ;

  {
  {
#line 126
  cnt = 0;
#line 129
  hh = (struct ntp_addr *)((void *)0);
#line 131
  bzero((void *)(& hints), sizeof(hints));
#line 132
  hints.ai_family = 0;
#line 133
  hints.ai_socktype = 2;
#line 134
  error = getaddrinfo((char const   */* __restrict  */)s, (char const   */* __restrict  */)((void *)0),
                      (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res0));
  }
#line 135
  if (error == -3) {
#line 136
    return (0);
  } else
#line 135
  if (error == -5) {
#line 136
    return (0);
  } else
#line 135
  if (error == -2) {
#line 136
    return (0);
  }
#line 137
  if (error) {
    {
#line 138
    tmp = gai_strerror(error);
#line 138
    log_warnx("could not parse \"%s\": %s", s, tmp);
    }
#line 140
    return (-1);
  }
#line 143
  res = res0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (res) {
#line 143
      if (! (cnt < 8)) {
#line 143
        goto while_break;
      }
    } else {
#line 143
      goto while_break;
    }
#line 144
    if (res->ai_family != 2) {
#line 144
      if (res->ai_family != 10) {
#line 146
        goto __Cont;
      }
    }
    {
#line 147
    tmp___0 = calloc((size_t )1, sizeof(struct ntp_addr ));
#line 147
    h = (struct ntp_addr *)tmp___0;
    }
#line 147
    if ((unsigned long )h == (unsigned long )((void *)0)) {
      {
#line 148
      fatal((char const   *)((void *)0));
      }
    }
#line 149
    h->ss.ss_family = (sa_family_t )res->ai_family;
#line 150
    if (res->ai_family == 2) {
#line 151
      sa_in = (struct sockaddr_in *)(& h->ss);
#line 155
      sa_in->sin_addr.s_addr = ((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr;
    } else {
      {
#line 158
      sa_in6 = (struct sockaddr_in6 *)(& h->ss);
#line 162
      memcpy((void */* __restrict  */)(& sa_in6->sin6_addr), (void const   */* __restrict  */)(& ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr),
             sizeof(struct in6_addr ));
      }
    }
#line 166
    h->next = hh;
#line 167
    hh = h;
#line 168
    cnt ++;
    __Cont: /* CIL Label */ 
#line 143
    res = res->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  freeaddrinfo(res0);
#line 172
  *hn = hh;
  }
#line 173
  return (cnt);
}
}
#line 176 "/home/wheatley/newnew/temp/openntpd-20080406p/config.c"
struct ntp_peer *new_peer(void) 
{ 
  struct ntp_peer *p ;
  void *tmp ;

  {
  {
#line 181
  tmp = calloc((size_t )1, sizeof(struct ntp_peer ));
#line 181
  p = (struct ntp_peer *)tmp;
  }
#line 181
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 182
    fatal("new_peer calloc");
    }
  }
#line 183
  maxid ++;
#line 183
  p->id = maxid;
#line 185
  return (p);
}
}
#line 188 "/home/wheatley/newnew/temp/openntpd-20080406p/config.c"
struct ntp_conf_sensor *new_sensor(char *device ) 
{ 
  struct ntp_conf_sensor *s ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 193
  tmp = calloc((size_t )1, sizeof(struct ntp_conf_sensor ));
#line 193
  s = (struct ntp_conf_sensor *)tmp;
  }
#line 193
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 194
    fatal("new_sensor calloc");
    }
  }
  {
#line 195
  tmp___0 = strdup((char const   *)device);
#line 195
  s->device = tmp___0;
  }
#line 195
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 196
    fatal("new_sensor strdup");
    }
  }
#line 198
  return (s);
}
}
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 28 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp_msg.c"
int ntp_getmsg(struct sockaddr *sa , char *p , ssize_t len , struct ntp_msg *msg ) 
{ 
  char const   *tmp ;

  {
#line 31
  if (len != 48L) {
#line 31
    if (len != 68L) {
      {
#line 32
      tmp = log_sockaddr(sa);
#line 32
      log_warnx("malformed packet received from %s", tmp);
      }
#line 34
      return (-1);
    }
  }
  {
#line 37
  memcpy((void */* __restrict  */)msg, (void const   */* __restrict  */)p, sizeof(*msg));
  }
#line 39
  return (0);
}
}
#line 42 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp_msg.c"
int ntp_sendmsg(int fd , struct sockaddr *sa , struct ntp_msg *msg , ssize_t len ,
                int auth ) 
{ 
  char buf___0[68] ;
  char *p ;
  socklen_t salen ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 47
  p = buf___0;
#line 52
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->status),
         sizeof(msg->status));
#line 52
  p += sizeof(msg->status);
#line 53
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->stratum),
         sizeof(msg->stratum));
#line 53
  p += sizeof(msg->stratum);
#line 54
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->ppoll),
         sizeof(msg->ppoll));
#line 54
  p += sizeof(msg->ppoll);
#line 55
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->precision),
         sizeof(msg->precision));
#line 55
  p += sizeof(msg->precision);
#line 56
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->rootdelay.int_parts),
         sizeof(msg->rootdelay.int_parts));
#line 56
  p += sizeof(msg->rootdelay.int_parts);
#line 57
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->rootdelay.fractions),
         sizeof(msg->rootdelay.fractions));
#line 57
  p += sizeof(msg->rootdelay.fractions);
#line 58
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->dispersion.int_parts),
         sizeof(msg->dispersion.int_parts));
#line 58
  p += sizeof(msg->dispersion.int_parts);
#line 59
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->dispersion.fractions),
         sizeof(msg->dispersion.fractions));
#line 59
  p += sizeof(msg->dispersion.fractions);
#line 60
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->refid),
         sizeof(msg->refid));
#line 60
  p += sizeof(msg->refid);
#line 61
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->reftime.int_partl),
         sizeof(msg->reftime.int_partl));
#line 61
  p += sizeof(msg->reftime.int_partl);
#line 62
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->reftime.fractionl),
         sizeof(msg->reftime.fractionl));
#line 62
  p += sizeof(msg->reftime.fractionl);
#line 63
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->orgtime.int_partl),
         sizeof(msg->orgtime.int_partl));
#line 63
  p += sizeof(msg->orgtime.int_partl);
#line 64
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->orgtime.fractionl),
         sizeof(msg->orgtime.fractionl));
#line 64
  p += sizeof(msg->orgtime.fractionl);
#line 65
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->rectime.int_partl),
         sizeof(msg->rectime.int_partl));
#line 65
  p += sizeof(msg->rectime.int_partl);
#line 66
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->rectime.fractionl),
         sizeof(msg->rectime.fractionl));
#line 66
  p += sizeof(msg->rectime.fractionl);
#line 67
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->xmttime.int_partl),
         sizeof(msg->xmttime.int_partl));
#line 67
  p += sizeof(msg->xmttime.int_partl);
#line 68
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(& msg->xmttime.fractionl),
         sizeof(msg->xmttime.fractionl));
#line 68
  p += sizeof(msg->xmttime.fractionl);
  }
#line 70
  if ((unsigned long )sa != (unsigned long )((void *)0)) {
#line 71
    if ((int )sa->sa_family == 10) {
#line 71
      salen = (socklen_t )sizeof(struct sockaddr_in6 );
    } else {
#line 71
      salen = (socklen_t )sizeof(struct sockaddr_in );
    }
  } else {
#line 73
    salen = (socklen_t )0;
  }
  {
#line 75
  tmp___3 = sendto(fd, (void const   *)(& buf___0), (size_t )len, 0, (struct sockaddr  const  */* __restrict  */)sa,
                   salen);
  }
#line 75
  if (tmp___3 != len) {
    {
#line 76
    tmp = __errno_location();
    }
#line 76
    if (*tmp == 105) {
#line 79
      return (-1);
    } else {
      {
#line 76
      tmp___0 = __errno_location();
      }
#line 76
      if (*tmp___0 == 113) {
#line 79
        return (-1);
      } else {
        {
#line 76
        tmp___1 = __errno_location();
        }
#line 76
        if (*tmp___1 == 100) {
#line 79
          return (-1);
        } else {
          {
#line 76
          tmp___2 = __errno_location();
          }
#line 76
          if (*tmp___2 == 112) {
#line 79
            return (-1);
          }
        }
      }
    }
    {
#line 81
    log_warn("sendto");
    }
#line 82
    return (-1);
  }
#line 85
  return (0);
}
}
#line 137 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 32 "/home/wheatley/newnew/temp/openntpd-20080406p/openbsd-compat/openbsd-compat.h"
extern unsigned int arc4random(void) ;
#line 272 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
void priv_settime(double offset ) ;
#line 273
void priv_host_dns(char *name , u_int32_t peerid ) ;
#line 296
int client_peer_init(struct ntp_peer *p ) ;
#line 297
int client_addr_init(struct ntp_peer *p ) ;
#line 298
int client_nextaddr(struct ntp_peer *p ) ;
#line 299
int client_query(struct ntp_peer *p ) ;
#line 300
int client_dispatch(struct ntp_peer *p , u_int8_t settime ) ;
#line 301
void client_log_error(struct ntp_peer *peer , char const   *operation , int error ) ;
#line 303
time_t scale_interval(time_t requested ) ;
#line 304
time_t error_interval(void) ;
#line 305
void set_next(struct ntp_peer *p , time_t t ) ;
#line 29 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
int client_update(struct ntp_peer *p ) ;
#line 30
void set_deadline(struct ntp_peer *p , time_t t ) ;
#line 32 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
void set_next(struct ntp_peer *p , time_t t ) 
{ 
  time_t tmp ;

  {
  {
#line 35
  tmp = getmonotime();
#line 35
  p->next = tmp + t;
#line 36
  p->deadline = (time_t )0;
  }
#line 37
  return;
}
}
#line 39 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
void set_deadline(struct ntp_peer *p , time_t t ) 
{ 
  time_t tmp ;

  {
  {
#line 42
  tmp = getmonotime();
#line 42
  p->deadline = tmp + t;
#line 43
  p->next = (time_t )0;
  }
#line 44
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
int client_peer_init(struct ntp_peer *p ) 
{ 
  struct ntp_query *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 49
  tmp___0 = calloc((size_t )1, sizeof(struct ntp_query ));
#line 49
  tmp = (struct ntp_query *)tmp___0;
#line 49
  p->query = tmp;
  }
#line 49
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 50
    fatal("client_peer_init calloc");
    }
  }
  {
#line 51
  (p->query)->fd = -1;
#line 52
  (p->query)->msg.status = (u_int8_t )(3 | (4 << 3));
#line 53
  p->state = (enum client_state )0;
#line 54
  p->shift = (u_int8_t )0;
#line 55
  p->trustlevel = (u_int8_t )2;
#line 56
  p->lasterror = 0;
#line 58
  tmp___1 = client_addr_init(p);
  }
#line 58
  return (tmp___1);
}
}
#line 61 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
int client_addr_init(struct ntp_peer *p ) 
{ 
  struct sockaddr_in *sa_in ;
  struct sockaddr_in6 *sa_in6 ;
  struct ntp_addr *h ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
#line 68
  h = p->addr;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 68
      goto while_break;
    }
    {
#line 70
    if ((int )h->ss.ss_family == 2) {
#line 70
      goto case_2;
    }
#line 76
    if ((int )h->ss.ss_family == 10) {
#line 76
      goto case_10;
    }
#line 82
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 71
    sa_in = (struct sockaddr_in *)(& h->ss);
#line 72
    tmp = ntohs(sa_in->sin_port);
    }
#line 72
    if ((int )tmp == 0) {
      {
#line 73
      sa_in->sin_port = htons((uint16_t )123);
      }
    }
#line 74
    p->state = (enum client_state )3;
#line 75
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 77
    sa_in6 = (struct sockaddr_in6 *)(& h->ss);
#line 78
    tmp___0 = ntohs(sa_in6->sin6_port);
    }
#line 78
    if ((int )tmp___0 == 0) {
      {
#line 79
      sa_in6->sin6_port = htons((uint16_t )123);
      }
    }
#line 80
    p->state = (enum client_state )3;
#line 81
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 83
    fatal("king bula sez: wrong AF in client_addr_init");
    }
    switch_break: /* CIL Label */ ;
    }
#line 68
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  (p->query)->fd = -1;
#line 89
  set_next(p, (time_t )0);
  }
#line 91
  return (0);
}
}
#line 94 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
int client_nextaddr(struct ntp_peer *p ) 
{ 
  struct ntp_addr *tmp ;

  {
#line 97
  if ((p->query)->fd != -1) {
    {
#line 98
    close((p->query)->fd);
#line 99
    (p->query)->fd = -1;
    }
  }
#line 102
  if ((unsigned int )p->state == 1U) {
#line 103
    return (-1);
  }
#line 105
  if ((unsigned long )p->addr_head.a == (unsigned long )((void *)0)) {
    {
#line 106
    priv_host_dns(p->addr_head.name, p->id);
#line 107
    p->state = (enum client_state )1;
    }
#line 108
    return (-1);
  }
#line 111
  tmp = (p->addr)->next;
#line 111
  p->addr = tmp;
#line 111
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 112
    p->addr = p->addr_head.a;
  }
#line 114
  p->shift = (u_int8_t )0;
#line 115
  p->trustlevel = (u_int8_t )2;
#line 117
  return (0);
}
}
#line 120 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
int client_query(struct ntp_peer *p ) 
{ 
  int tos ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;
  struct sockaddr *sa ;
  time_t tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  time_t tmp___8 ;
  time_t tmp___9 ;
  time_t tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  unsigned long tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 123
  tos = 16;
#line 125
  if ((unsigned long )p->addr == (unsigned long )((void *)0)) {
    {
#line 125
    tmp___3 = client_nextaddr(p);
    }
#line 125
    if (tmp___3 == -1) {
      {
#line 126
      tmp___2 = scale_interval((time_t )5);
      }
#line 126
      if (15L > tmp___2) {
#line 126
        tmp___1 = (time_t )15;
      } else {
        {
#line 126
        tmp___0 = scale_interval((time_t )5);
#line 126
        tmp___1 = tmp___0;
        }
      }
      {
#line 126
      set_next(p, tmp___1);
      }
#line 128
      return (0);
    }
  }
#line 131
  if ((unsigned int )p->state < 3U) {
#line 132
    return (-1);
  } else
#line 131
  if ((unsigned long )p->addr == (unsigned long )((void *)0)) {
#line 132
    return (-1);
  }
#line 134
  if ((p->query)->fd == -1) {
    {
#line 135
    sa = (struct sockaddr *)(& (p->addr)->ss);
#line 137
    tmp___6 = socket((int )(p->addr)->ss.ss_family, 2, 0);
#line 137
    (p->query)->fd = tmp___6;
    }
#line 137
    if (tmp___6 == -1) {
      {
#line 140
      tmp___5 = __errno_location();
      }
#line 140
      if (*tmp___5 == 97) {
        {
#line 141
        log_warn("client_query socket");
#line 142
        client_nextaddr(p);
#line 143
        tmp___4 = error_interval();
#line 143
        set_next(p, tmp___4);
        }
#line 144
        return (-1);
      } else {
        {
#line 147
        fatal("client_query socket");
        }
      }
    }
#line 149
    if ((int )sa->sa_family == 10) {
#line 149
      tmp___15 = sizeof(struct sockaddr_in6 );
    } else {
#line 149
      tmp___15 = sizeof(struct sockaddr_in );
    }
    {
#line 149
    tmp___16 = connect((p->query)->fd, (struct sockaddr  const  */* __restrict  */)sa,
                       (socklen_t )tmp___15);
    }
#line 149
    if (tmp___16 == -1) {
      {
#line 150
      tmp___11 = __errno_location();
      }
#line 150
      if (*tmp___11 == 111) {
#line 150
        goto _L;
      } else {
        {
#line 150
        tmp___12 = __errno_location();
        }
#line 150
        if (*tmp___12 == 101) {
#line 150
          goto _L;
        } else {
          {
#line 150
          tmp___13 = __errno_location();
          }
#line 150
          if (*tmp___13 == 113) {
#line 150
            goto _L;
          } else {
            {
#line 150
            tmp___14 = __errno_location();
            }
#line 150
            if (*tmp___14 == 99) {
              _L: /* CIL Label */ 
              {
#line 152
              client_nextaddr(p);
#line 153
              tmp___10 = scale_interval((time_t )5);
              }
#line 153
              if (15L > tmp___10) {
#line 153
                tmp___9 = (time_t )15;
              } else {
                {
#line 153
                tmp___8 = scale_interval((time_t )5);
#line 153
                tmp___9 = tmp___8;
                }
              }
              {
#line 153
              set_next(p, tmp___9);
              }
#line 155
              return (-1);
            } else {
              {
#line 157
              fatal("client_query connect");
              }
            }
          }
        }
      }
    }
#line 159
    if ((int )(p->addr)->ss.ss_family == 2) {
      {
#line 159
      tmp___17 = setsockopt((p->query)->fd, 0, 1, (void const   *)(& tos), (socklen_t )sizeof(tos));
      }
#line 159
      if (tmp___17 == -1) {
        {
#line 161
        log_warn("setsockopt IPTOS_LOWDELAY");
        }
      }
    }
  }
  {
#line 178
  (p->query)->msg.xmttime.int_partl = arc4random();
#line 179
  (p->query)->msg.xmttime.fractionl = arc4random();
#line 180
  (p->query)->xmttime = gettime_corrected();
#line 182
  tmp___18 = ntp_sendmsg((p->query)->fd, (struct sockaddr *)((void *)0), & (p->query)->msg,
                         (ssize_t )48, 0);
  }
#line 182
  if (tmp___18 == -1) {
    {
#line 184
    set_next(p, (time_t )60);
#line 185
    p->trustlevel = (u_int8_t )2;
    }
#line 186
    return (-1);
  }
  {
#line 189
  p->state = (enum client_state )4;
#line 190
  set_deadline(p, (time_t )15);
  }
#line 192
  return (0);
}
}
#line 195 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
int client_dispatch(struct ntp_peer *p , u_int8_t settime ) 
{ 
  char buf___0[68] ;
  ssize_t size ;
  struct ntp_msg msg ;
  double T1 ;
  double T2 ;
  double T3 ;
  double T4 ;
  time_t interval ;
  int *tmp ;
  time_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
  {
#line 204
  size = recvfrom((p->query)->fd, (void */* __restrict  */)(& buf___0), sizeof(buf___0),
                  0, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)((void *)0));
  }
#line 204
  if (size == -1L) {
    {
#line 206
    tmp___1 = __errno_location();
    }
#line 206
    if (*tmp___1 == 113) {
      {
#line 209
      tmp = __errno_location();
#line 209
      client_log_error(p, "recvfrom", *tmp);
#line 210
      tmp___0 = error_interval();
#line 210
      set_next(p, tmp___0);
      }
#line 211
      return (0);
    } else {
      {
#line 206
      tmp___2 = __errno_location();
      }
#line 206
      if (*tmp___2 == 112) {
        {
#line 209
        tmp = __errno_location();
#line 209
        client_log_error(p, "recvfrom", *tmp);
#line 210
        tmp___0 = error_interval();
#line 210
        set_next(p, tmp___0);
        }
#line 211
        return (0);
      } else {
        {
#line 206
        tmp___3 = __errno_location();
        }
#line 206
        if (*tmp___3 == 101) {
          {
#line 209
          tmp = __errno_location();
#line 209
          client_log_error(p, "recvfrom", *tmp);
#line 210
          tmp___0 = error_interval();
#line 210
          set_next(p, tmp___0);
          }
#line 211
          return (0);
        } else {
          {
#line 206
          tmp___4 = __errno_location();
          }
#line 206
          if (*tmp___4 == 100) {
            {
#line 209
            tmp = __errno_location();
#line 209
            client_log_error(p, "recvfrom", *tmp);
#line 210
            tmp___0 = error_interval();
#line 210
            set_next(p, tmp___0);
            }
#line 211
            return (0);
          } else {
            {
#line 206
            tmp___5 = __errno_location();
            }
#line 206
            if (*tmp___5 == 111) {
              {
#line 209
              tmp = __errno_location();
#line 209
              client_log_error(p, "recvfrom", *tmp);
#line 210
              tmp___0 = error_interval();
#line 210
              set_next(p, tmp___0);
              }
#line 211
              return (0);
            } else {
              {
#line 206
              tmp___6 = __errno_location();
              }
#line 206
              if (*tmp___6 == 99) {
                {
#line 209
                tmp = __errno_location();
#line 209
                client_log_error(p, "recvfrom", *tmp);
#line 210
                tmp___0 = error_interval();
#line 210
                set_next(p, tmp___0);
                }
#line 211
                return (0);
              } else {
                {
#line 213
                fatal("recvfrom");
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 216
  T4 = gettime_corrected();
#line 218
  ntp_getmsg((struct sockaddr *)(& (p->addr)->ss), buf___0, size, & msg);
  }
#line 220
  if (msg.orgtime.int_partl != (p->query)->msg.xmttime.int_partl) {
#line 222
    return (0);
  } else
#line 220
  if (msg.orgtime.fractionl != (p->query)->msg.xmttime.fractionl) {
#line 222
    return (0);
  }
#line 224
  if (((int )msg.status & (3 << 6)) == 3 << 6) {
    {
#line 226
    interval = error_interval();
#line 227
    set_next(p, interval);
#line 228
    tmp___7 = log_sockaddr((struct sockaddr *)(& (p->addr)->ss));
#line 228
    log_info("reply from %s: not synced, next query %ds", tmp___7, interval);
    }
#line 230
    return (0);
  } else
#line 224
  if ((int )msg.stratum == 0) {
    {
#line 226
    interval = error_interval();
#line 227
    set_next(p, interval);
#line 228
    tmp___7 = log_sockaddr((struct sockaddr *)(& (p->addr)->ss));
#line 228
    log_info("reply from %s: not synced, next query %ds", tmp___7, interval);
    }
#line 230
    return (0);
  } else
#line 224
  if ((int )msg.stratum > 15) {
    {
#line 226
    interval = error_interval();
#line 227
    set_next(p, interval);
#line 228
    tmp___7 = log_sockaddr((struct sockaddr *)(& (p->addr)->ss));
#line 228
    log_info("reply from %s: not synced, next query %ds", tmp___7, interval);
    }
#line 230
    return (0);
  }
  {
#line 248
  T1 = (p->query)->xmttime;
#line 249
  T2 = lfp_to_d(msg.rectime);
#line 250
  T3 = lfp_to_d(msg.xmttime);
#line 252
  p->reply[p->shift].offset = ((T2 - T1) + (T3 - T4)) / (double )2;
#line 253
  p->reply[p->shift].delay = (T4 - T1) - (T3 - T2);
  }
#line 254
  if (p->reply[p->shift].delay < (double )0) {
    {
#line 255
    interval = error_interval();
#line 256
    set_next(p, interval);
#line 257
    tmp___8 = log_sockaddr((struct sockaddr *)(& (p->addr)->ss));
#line 257
    log_info("reply from %s: negative delay %fs, next query %ds", tmp___8, p->reply[p->shift].delay,
             interval);
    }
#line 261
    return (0);
  }
  {
#line 263
  p->reply[p->shift].error = (T2 - T1) - (T3 - T4);
#line 264
  p->reply[p->shift].rcvd = getmonotime();
#line 265
  p->reply[p->shift].good = (u_int8_t )1;
#line 267
  p->reply[p->shift].status.leap = (u_int8_t )((int )msg.status & (3 << 6));
#line 268
  p->reply[p->shift].status.precision = msg.precision;
#line 269
  p->reply[p->shift].status.rootdelay = sfp_to_d(msg.rootdelay);
#line 270
  p->reply[p->shift].status.rootdispersion = sfp_to_d(msg.dispersion);
#line 271
  p->reply[p->shift].status.refid = ntohl(msg.refid);
#line 272
  p->reply[p->shift].status.refid4 = msg.xmttime.fractionl;
#line 273
  p->reply[p->shift].status.reftime = lfp_to_d(msg.reftime);
#line 274
  p->reply[p->shift].status.poll = msg.ppoll;
#line 275
  p->reply[p->shift].status.stratum = msg.stratum;
  }
#line 277
  if ((int )(p->addr)->ss.ss_family == 2) {
#line 278
    p->reply[p->shift].status.send_refid = ((struct sockaddr_in *)(& (p->addr)->ss))->sin_addr.s_addr;
  } else {
#line 281
    p->reply[p->shift].status.send_refid = msg.xmttime.fractionl;
  }
#line 283
  if ((int )p->trustlevel < 2) {
    {
#line 284
    interval = scale_interval((time_t )60);
    }
  } else
#line 285
  if ((int )p->trustlevel < 8) {
    {
#line 286
    interval = scale_interval((time_t )5);
    }
  } else {
    {
#line 288
    interval = scale_interval((time_t )30);
    }
  }
  {
#line 290
  set_next(p, interval);
#line 291
  p->state = (enum client_state )5;
  }
#line 294
  if ((int )p->trustlevel < 10) {
#line 295
    if ((int )p->trustlevel < 6) {
#line 295
      if ((int )p->trustlevel + 1 >= 6) {
        {
#line 297
        tmp___9 = log_sockaddr((struct sockaddr *)(& (p->addr)->ss));
#line 297
        log_info("peer %s now valid", tmp___9);
        }
      }
    }
#line 299
    p->trustlevel = (u_int8_t )((int )p->trustlevel + 1);
  }
  {
#line 302
  tmp___10 = log_sockaddr((struct sockaddr *)(& (p->addr)->ss));
#line 302
  log_debug("reply from %s: offset %f delay %f, next query %ds", tmp___10, p->reply[p->shift].offset,
            p->reply[p->shift].delay, interval);
#line 306
  client_update(p);
  }
#line 307
  if (settime) {
    {
#line 308
    priv_settime(p->reply[p->shift].offset);
    }
  }
#line 310
  p->shift = (u_int8_t )((int )p->shift + 1);
#line 310
  if ((int )p->shift >= 8) {
#line 311
    p->shift = (u_int8_t )0;
  }
#line 313
  return (0);
}
}
#line 316 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
int client_update(struct ntp_peer *p ) 
{ 
  int i ;
  int best ;
  int good ;
  int tmp ;

  {
#line 319
  best = 0;
#line 319
  good = 0;
#line 328
  i = 0;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (good == 0) {
#line 328
      if (! (i < 8)) {
#line 328
        goto while_break;
      }
    } else {
#line 328
      goto while_break;
    }
#line 329
    if (p->reply[i].good) {
#line 330
      good ++;
#line 331
      best = i;
    }
#line 328
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 334
    if (! (i < 8)) {
#line 334
      goto while_break___0;
    }
#line 335
    if (p->reply[i].good) {
#line 336
      good ++;
#line 337
      if (p->reply[i].delay < p->reply[best].delay) {
#line 338
        best = i;
      }
    }
#line 334
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 341
  if (good < 8) {
#line 342
    return (-1);
  }
  {
#line 344
  memcpy((void */* __restrict  */)(& p->update), (void const   */* __restrict  */)(& p->reply[best]),
         sizeof(p->update));
#line 345
  tmp = priv_adjtime();
  }
#line 345
  if (tmp == 0) {
#line 346
    i = 0;
    {
#line 346
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 346
      if (! (i < 8)) {
#line 346
        goto while_break___1;
      }
#line 347
      if (p->reply[i].rcvd <= p->reply[best].rcvd) {
#line 348
        p->reply[i].good = (u_int8_t )0;
      }
#line 346
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 350
  return (0);
}
}
#line 353 "/home/wheatley/newnew/temp/openntpd-20080406p/client.c"
void client_log_error(struct ntp_peer *peer , char const   *operation , int error ) 
{ 
  char const   *address ;
  char *tmp ;

  {
  {
#line 358
  address = log_sockaddr((struct sockaddr *)(& (peer->addr)->ss));
  }
#line 359
  if (peer->lasterror == error) {
    {
#line 360
    tmp = strerror(error);
#line 360
    log_debug("%s %s: %s", operation, address, tmp);
    }
#line 361
    return;
  }
  {
#line 363
  peer->lasterror = error;
#line 364
  log_warn("%s %s", operation, address);
  }
#line 365
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 28 "/home/wheatley/newnew/temp/openntpd-20080406p/imsg.c"
void imsg_init(struct imsgbuf *ibuf___0 , int fd ) 
{ 


  {
  {
#line 31
  msgbuf_init(& ibuf___0->w);
#line 32
  bzero((void *)(& ibuf___0->r), sizeof(ibuf___0->r));
#line 33
  ibuf___0->fd = fd;
#line 34
  ibuf___0->w.fd = fd;
#line 35
  ibuf___0->pid = getpid();
  }
#line 36
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/openntpd-20080406p/imsg.c"
int imsg_read(struct imsgbuf *ibuf___0 ) 
{ 
  ssize_t n ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 43
  n = read(ibuf___0->fd, (void *)(ibuf___0->r.buf + ibuf___0->r.wpos), sizeof(ibuf___0->r.buf) - ibuf___0->r.wpos);
  }
#line 43
  if (n == -1L) {
    {
#line 45
    tmp = __errno_location();
    }
#line 45
    if (*tmp != 4) {
      {
#line 45
      tmp___0 = __errno_location();
      }
#line 45
      if (*tmp___0 != 11) {
        {
#line 46
        log_warn("imsg_read: pipe read error");
        }
#line 47
        return (-1);
      }
    }
#line 49
    return (-2);
  }
#line 52
  ibuf___0->r.wpos += (size_t )n;
#line 54
  return ((int )n);
}
}
#line 57 "/home/wheatley/newnew/temp/openntpd-20080406p/imsg.c"
int imsg_get(struct imsgbuf *ibuf___0 , struct imsg *imsg ) 
{ 
  size_t av ;
  size_t left ;
  size_t datalen ;
  void *tmp ;

  {
#line 62
  av = ibuf___0->r.wpos;
#line 64
  if (sizeof(struct imsg_hdr ) > av) {
#line 65
    return (0);
  }
  {
#line 67
  memcpy((void */* __restrict  */)(& imsg->hdr), (void const   */* __restrict  */)(ibuf___0->r.buf),
         sizeof(imsg->hdr));
  }
#line 68
  if ((unsigned long )imsg->hdr.len < sizeof(struct imsg_hdr )) {
    {
#line 70
    log_warnx("imsg_get: imsg hdr len %u out of bounds, type=%u", (int )imsg->hdr.len,
              (unsigned int )imsg->hdr.type);
    }
#line 72
    return (-1);
  } else
#line 68
  if ((int )imsg->hdr.len > 8192) {
    {
#line 70
    log_warnx("imsg_get: imsg hdr len %u out of bounds, type=%u", (int )imsg->hdr.len,
              (unsigned int )imsg->hdr.type);
    }
#line 72
    return (-1);
  }
#line 74
  if ((size_t )imsg->hdr.len > av) {
#line 75
    return (0);
  }
  {
#line 76
  datalen = (unsigned long )imsg->hdr.len - sizeof(struct imsg_hdr );
#line 77
  ibuf___0->r.rptr = ibuf___0->r.buf + sizeof(struct imsg_hdr );
#line 78
  tmp = malloc(datalen);
#line 78
  imsg->data = tmp;
  }
#line 78
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 79
    log_warn("imsg_get");
    }
#line 80
    return (-1);
  }
  {
#line 82
  memcpy((void */* __restrict  */)imsg->data, (void const   */* __restrict  */)ibuf___0->r.rptr,
         datalen);
  }
#line 84
  if ((size_t )imsg->hdr.len < av) {
    {
#line 85
    left = av - (size_t )imsg->hdr.len;
#line 86
    memmove((void *)(& ibuf___0->r.buf), (void const   *)(ibuf___0->r.buf + (int )imsg->hdr.len),
            left);
#line 87
    ibuf___0->r.wpos = left;
    }
  } else {
#line 89
    ibuf___0->r.wpos = (size_t )0;
  }
#line 91
  return ((int )(datalen + sizeof(struct imsg_hdr )));
}
}
#line 94 "/home/wheatley/newnew/temp/openntpd-20080406p/imsg.c"
int imsg_compose(struct imsgbuf *ibuf___0 , enum imsg_type type , u_int32_t peerid ,
                 pid_t pid , void *data , u_int16_t datalen ) 
{ 
  struct buf *wbuf ;
  int n ;
  int tmp ;

  {
  {
#line 101
  wbuf = imsg_create(ibuf___0, type, peerid, pid, datalen);
  }
#line 101
  if ((unsigned long )wbuf == (unsigned long )((void *)0)) {
#line 102
    return (-1);
  }
  {
#line 104
  tmp = imsg_add(wbuf, data, datalen);
  }
#line 104
  if (tmp == -1) {
#line 105
    return (-1);
  }
  {
#line 107
  n = imsg_close(ibuf___0, wbuf);
  }
#line 107
  if (n < 0) {
#line 108
    return (-1);
  }
#line 110
  return (n);
}
}
#line 113 "/home/wheatley/newnew/temp/openntpd-20080406p/imsg.c"
struct buf *imsg_create(struct imsgbuf *ibuf___0 , enum imsg_type type , u_int32_t peerid ,
                        pid_t pid , u_int16_t datalen ) 
{ 
  struct buf *wbuf ;
  struct imsg_hdr hdr ;
  int tmp ;

  {
#line 120
  if ((unsigned long )datalen > 8192UL - sizeof(struct imsg_hdr )) {
    {
#line 121
    log_warnx("imsg_create: len %u > MAX_IMSGSIZE; type %u peerid %lu", (unsigned long )datalen + sizeof(struct imsg_hdr ),
              (unsigned int )type, peerid);
    }
#line 124
    return ((struct buf *)((void *)0));
  }
  {
#line 127
  hdr.len = (u_int16_t )((unsigned long )datalen + sizeof(struct imsg_hdr ));
#line 128
  hdr.type = type;
#line 129
  hdr.peerid = peerid;
#line 130
  hdr.pid = pid;
#line 131
  wbuf = buf_open((size_t )hdr.len);
  }
#line 131
  if ((unsigned long )wbuf == (unsigned long )((void *)0)) {
    {
#line 132
    log_warn("imsg_create: buf_open");
    }
#line 133
    return ((struct buf *)((void *)0));
  }
  {
#line 135
  tmp = imsg_add(wbuf, (void *)(& hdr), (u_int16_t )sizeof(hdr));
  }
#line 135
  if (tmp == -1) {
#line 136
    return ((struct buf *)((void *)0));
  }
#line 138
  return (wbuf);
}
}
#line 141 "/home/wheatley/newnew/temp/openntpd-20080406p/imsg.c"
int imsg_add(struct buf *msg , void *data , u_int16_t datalen ) 
{ 
  int tmp ;

  {
#line 144
  if (datalen) {
    {
#line 145
    tmp = buf_add(msg, data, (size_t )datalen);
    }
#line 145
    if (tmp == -1) {
      {
#line 146
      log_warnx("imsg_add: buf_add error");
#line 147
      buf_free(msg);
      }
#line 148
      return (-1);
    }
  }
#line 150
  return ((int )datalen);
}
}
#line 153 "/home/wheatley/newnew/temp/openntpd-20080406p/imsg.c"
int imsg_close(struct imsgbuf *ibuf___0 , struct buf *msg ) 
{ 
  int n ;

  {
  {
#line 158
  n = buf_close(& ibuf___0->w, msg);
  }
#line 158
  if (n < 0) {
    {
#line 159
    log_warnx("imsg_close: buf_close error");
#line 160
    buf_free(msg);
    }
#line 161
    return (-1);
  }
#line 163
  return (n);
}
}
#line 166 "/home/wheatley/newnew/temp/openntpd-20080406p/imsg.c"
void imsg_free(struct imsg *imsg ) 
{ 


  {
  {
#line 169
  free(imsg->data);
  }
#line 170
  return;
}
}
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 743
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setresuid)(__uid_t __ruid ,
                                                                                __uid_t __euid ,
                                                                                __uid_t __suid ) ;
#line 748
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setresgid)(__gid_t __rgid ,
                                                                                __gid_t __egid ,
                                                                                __gid_t __sgid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 180 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 339
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_getres)(clockid_t __clock_id ,
                                                                                   struct timespec *__res ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 276 "/usr/include/netdb.h"
extern void endservent(void) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 302 "/home/wheatley/newnew/temp/openntpd-20080406p/ntpd.h"
void update_scale(double offset ) ;
#line 46 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
int volatile   ntp_quit  =    (sig_atomic_t volatile   )0;
#line 47 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
int volatile   ntp_report  =    (sig_atomic_t volatile   )0;
#line 48 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
struct imsgbuf *ibuf_main  ;
#line 50 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
u_int peer_cnt  ;
#line 51 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
u_int sensors_cnt  ;
#line 52 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
time_t lastreport  ;
#line 54
void ntp_sighdlr(int sig ) ;
#line 55
int ntp_dispatch_imsg(void) ;
#line 56
void peer_add(struct ntp_peer *p ) ;
#line 57
void peer_remove(struct ntp_peer *p ) ;
#line 58
void report_peers(int always ) ;
#line 60 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
void ntp_sighdlr(int sig ) 
{ 


  {
  {
#line 65
  if (sig == 15) {
#line 65
    goto case_15;
  }
#line 65
  if (sig == 2) {
#line 65
    goto case_15;
  }
#line 63
  goto switch_break;
  case_15: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 66
  ntp_quit = (int volatile   )1;
#line 67
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
pid_t ntp_main(int *pipe_prnt , struct ntpd_conf *nconf ) 
{ 
  int a ;
  int b ;
  int nfds ;
  int i ;
  int j ;
  int idx_peers ;
  int timeout ;
  int hotplugfd ;
  int nullfd ;
  u_int pfd_elms ;
  u_int idx2peer_elms ;
  u_int listener_cnt ;
  u_int new_cnt ;
  u_int sent_cnt ;
  u_int trial_cnt ;
  pid_t pid ;
  struct pollfd *pfd ;
  struct passwd *pw ;
  struct servent *se ;
  struct listen_addr *la ;
  struct ntp_peer *p ;
  struct ntp_peer **idx2peer ;
  struct ntp_sensor *s ;
  struct ntp_sensor *next_s ;
  struct timespec tp ;
  struct stat stb ;
  time_t nextaction ;
  time_t last_sensor_scan ;
  void *newp ;
  char *chrootdir ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  time_t tmp___7 ;
  time_t tmp___8 ;
  int tmp___9 ;
  time_t tmp___10 ;
  time_t tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  u_int8_t tmp___14 ;
  time_t tmp___15 ;
  time_t tmp___16 ;
  time_t tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  time_t tmp___23 ;

  {
  {
#line 81
  pfd_elms = (u_int )0;
#line 81
  idx2peer_elms = (u_int )0;
#line 84
  pfd = (struct pollfd *)((void *)0);
#line 89
  idx2peer = (struct ntp_peer **)((void *)0);
#line 93
  last_sensor_scan = (time_t )0;
#line 97
  pid = fork();
  }
  {
#line 98
  if (pid == -1) {
#line 98
    goto case_neg_1;
  }
#line 101
  if (pid == 0) {
#line 101
    goto case_0;
  }
#line 103
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 99
  fatal("cannot fork");
  }
#line 100
  goto switch_break;
  case_0: /* CIL Label */ 
#line 102
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 104
  return (pid);
  switch_break: /* CIL Label */ ;
  }
#line 108
  if (nconf->settime) {
#line 108
    if (! nconf->debug) {
      {
#line 109
      log_init((int )nconf->debug);
#line 110
      tmp = setsid();
      }
#line 110
      if (tmp == -1) {
        {
#line 111
        fatal("setsid");
        }
      }
    }
  }
  {
#line 113
  se = getservbyname("ntp", "udp");
  }
#line 113
  if ((unsigned long )se == (unsigned long )((void *)0)) {
    {
#line 114
    fatal("getservbyname");
    }
  }
  {
#line 116
  pw = getpwnam("_ntp");
  }
#line 116
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 117
    fatal("getpwnam");
    }
  }
  {
#line 119
  nullfd = open("/dev/null", 2, 0);
  }
#line 119
  if (nullfd == -1) {
    {
#line 120
    fatal((char const   *)((void *)0));
    }
  }
  {
#line 121
  hotplugfd = sensor_hotplugfd();
#line 126
  chrootdir = pw->pw_dir;
#line 129
  tmp___0 = stat((char const   */* __restrict  */)chrootdir, (struct stat */* __restrict  */)(& stb));
  }
#line 129
  if (tmp___0 == -1) {
    {
#line 130
    fatal("stat");
    }
  }
#line 131
  if (stb.st_uid != 0U) {
    {
#line 132
    fatal("bad privsep dir permissions");
    }
  } else
#line 131
  if ((stb.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
    {
#line 132
    fatal("bad privsep dir permissions");
    }
  }
  {
#line 133
  tmp___1 = chroot((char const   *)chrootdir);
  }
#line 133
  if (tmp___1 == -1) {
    {
#line 134
    fatal("chroot");
    }
  }
  {
#line 135
  tmp___2 = chdir("/");
  }
#line 135
  if (tmp___2 == -1) {
    {
#line 136
    fatal("chdir(\"/\")");
    }
  }
#line 138
  if (! nconf->debug) {
    {
#line 139
    dup2(nullfd, 0);
#line 140
    dup2(nullfd, 1);
#line 141
    dup2(nullfd, 2);
    }
  }
  {
#line 143
  close(nullfd);
#line 147
  conf = nconf;
#line 148
  setup_listeners(se, conf, & listener_cnt);
#line 150
  tmp___3 = setgroups((size_t )1, (__gid_t const   *)(& pw->pw_gid));
  }
#line 150
  if (tmp___3) {
    {
#line 153
    fatal("can\'t drop privileges");
    }
  } else {
    {
#line 150
    tmp___4 = setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid);
    }
#line 150
    if (tmp___4) {
      {
#line 153
      fatal("can\'t drop privileges");
      }
    } else {
      {
#line 150
      tmp___5 = setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid);
      }
#line 150
      if (tmp___5) {
        {
#line 153
        fatal("can\'t drop privileges");
        }
      }
    }
  }
  {
#line 155
  endservent();
#line 157
  signal(15, & ntp_sighdlr);
#line 158
  signal(2, & ntp_sighdlr);
#line 162
  signal(13, (void (*)(int  ))1);
#line 163
  signal(1, (void (*)(int  ))1);
#line 164
  signal(17, (void (*)(int  ))0);
#line 166
  close(*(pipe_prnt + 0));
#line 167
  tmp___6 = malloc(sizeof(struct imsgbuf ));
#line 167
  ibuf_main = (struct imsgbuf *)tmp___6;
  }
#line 167
  if ((unsigned long )ibuf_main == (unsigned long )((void *)0)) {
    {
#line 168
    fatal((char const   *)((void *)0));
    }
  }
  {
#line 169
  imsg_init(ibuf_main, *(pipe_prnt + 1));
#line 171
  p = conf->ntp_peers.tqh_first;
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 171
      goto while_break;
    }
    {
#line 172
    client_peer_init(p);
#line 171
    p = p->entry.tqe_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  bzero((void *)(& conf->status), sizeof(conf->status));
#line 176
  conf->freq.num = (u_int )0;
#line 177
  conf->freq.samples = 0;
#line 178
  conf->freq.x = 0.0;
#line 179
  conf->freq.xx = 0.0;
#line 180
  conf->freq.xy = 0.0;
#line 181
  conf->freq.y = 0.0;
#line 182
  conf->freq.overall_offset = 0.0;
#line 184
  conf->status.synced = (u_int8_t )0;
#line 185
  clock_getres(0, & tp);
#line 186
  b = (int )(1000000000L / tp.tv_nsec);
#line 187
  a = 0;
  }
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (! (b > 1)) {
#line 187
      goto while_break___0;
    }
#line 187
    a --;
#line 187
    b >>= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 189
  conf->status.precision = (int8_t )a;
#line 190
  conf->scale = (u_int32_t )1;
#line 192
  sensor_init();
#line 194
  log_info("ntp engine ready");
#line 196
  peer_cnt = (u_int )0;
#line 197
  p = conf->ntp_peers.tqh_first;
  }
  {
#line 197
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 197
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 197
      goto while_break___1;
    }
#line 198
    peer_cnt ++;
#line 197
    p = p->entry.tqe_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 201
  tmp___7 = time((time_t *)((void *)0));
#line 201
  lastreport = (tmp___7 + 300L) - 86400L;
  }
  {
#line 203
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 203
    if (! (ntp_quit == (int volatile   )0)) {
#line 203
      goto while_break___2;
    }
#line 204
    if (peer_cnt > idx2peer_elms) {
      {
#line 205
      newp = realloc((void *)idx2peer, sizeof(void *) * (unsigned long )peer_cnt);
      }
#line 205
      if ((unsigned long )newp == (unsigned long )((void *)0)) {
        {
#line 208
        log_warn("could not resize idx2peer from %u -> %u entries", idx2peer_elms,
                 peer_cnt);
#line 210
        fatalx("exiting");
        }
      }
#line 212
      idx2peer = (struct ntp_peer **)newp;
#line 213
      idx2peer_elms = peer_cnt;
    }
#line 216
    new_cnt = (2U + peer_cnt) + listener_cnt;
#line 217
    if (new_cnt > pfd_elms) {
      {
#line 218
      newp = realloc((void *)pfd, sizeof(struct pollfd ) * (unsigned long )new_cnt);
      }
#line 218
      if ((unsigned long )newp == (unsigned long )((void *)0)) {
        {
#line 221
        log_warn("could not resize pfd from %u -> %u entries", pfd_elms, new_cnt);
#line 223
        fatalx("exiting");
        }
      }
#line 225
      pfd = (struct pollfd *)newp;
#line 226
      pfd_elms = new_cnt;
    }
    {
#line 229
    bzero((void *)pfd, sizeof(struct pollfd ) * (unsigned long )pfd_elms);
#line 230
    bzero((void *)idx2peer, sizeof(void *) * (unsigned long )idx2peer_elms);
#line 231
    tmp___8 = getmonotime();
#line 231
    nextaction = tmp___8 + 3600L;
#line 232
    (pfd + 0)->fd = ibuf_main->fd;
#line 233
    (pfd + 0)->events = (short)1;
#line 234
    (pfd + 1)->fd = hotplugfd;
#line 235
    (pfd + 1)->events = (short)1;
#line 237
    i = 2;
#line 238
    la = conf->listen_addrs.tqh_first;
    }
    {
#line 238
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 238
      if (! ((unsigned long )la != (unsigned long )((void *)0))) {
#line 238
        goto while_break___3;
      }
#line 239
      (pfd + i)->fd = la->fd;
#line 240
      (pfd + i)->events = (short)1;
#line 241
      i ++;
#line 238
      la = la->entry.tqe_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 244
    idx_peers = i;
#line 245
    trial_cnt = (u_int )0;
#line 245
    sent_cnt = trial_cnt;
#line 246
    p = conf->ntp_peers.tqh_first;
    {
#line 246
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 246
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 246
        goto while_break___4;
      }
#line 247
      if (p->next > 0L) {
        {
#line 247
        tmp___10 = getmonotime();
        }
#line 247
        if (p->next <= tmp___10) {
#line 248
          if ((unsigned int )p->state > 1U) {
#line 249
            trial_cnt ++;
          }
          {
#line 250
          tmp___9 = client_query(p);
          }
#line 250
          if (tmp___9 == 0) {
#line 251
            sent_cnt ++;
          }
        }
      }
#line 253
      if (p->next > 0L) {
#line 253
        if (p->next < nextaction) {
#line 254
          nextaction = p->next;
        }
      }
#line 256
      if (p->deadline > 0L) {
#line 256
        if (p->deadline < nextaction) {
#line 257
          nextaction = p->deadline;
        }
      }
#line 258
      if (p->deadline > 0L) {
        {
#line 258
        tmp___15 = getmonotime();
        }
#line 258
        if (p->deadline <= tmp___15) {
          {
#line 259
          tmp___11 = error_interval();
#line 259
          timeout = (int )tmp___11;
#line 260
          tmp___12 = log_sockaddr((struct sockaddr *)(& (p->addr)->ss));
#line 260
          log_debug("no reply from %s received in time, next query %ds", tmp___12,
                    timeout);
          }
#line 263
          if ((int )p->trustlevel >= 6) {
#line 263
            tmp___14 = (u_int8_t )((int )p->trustlevel / 2);
#line 263
            p->trustlevel = tmp___14;
#line 263
            if ((int )tmp___14 < 6) {
              {
#line 265
              tmp___13 = log_sockaddr((struct sockaddr *)(& (p->addr)->ss));
#line 265
              log_info("peer %s now invalid", tmp___13);
              }
            }
          }
          {
#line 268
          client_nextaddr(p);
#line 269
          set_next(p, (time_t )timeout);
          }
        }
      }
#line 272
      if ((unsigned int )p->state == 4U) {
#line 272
        if ((p->query)->fd != -1) {
#line 274
          (pfd + i)->fd = (p->query)->fd;
#line 275
          (pfd + i)->events = (short)1;
#line 276
          *(idx2peer + (i - idx_peers)) = p;
#line 277
          i ++;
        }
      }
#line 246
      p = p->entry.tqe_next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 281
    if (last_sensor_scan == 0L) {
      {
#line 283
      sensors_cnt = (u_int )0;
#line 284
      last_sensor_scan = getmonotime();
      }
    } else {
      {
#line 281
      tmp___16 = getmonotime();
      }
#line 281
      if (last_sensor_scan + 300L < tmp___16) {
        {
#line 283
        sensors_cnt = (u_int )0;
#line 284
        last_sensor_scan = getmonotime();
        }
      }
    }
#line 286
    if (! ((unsigned long )conf->ntp_conf_sensors.tqh_first == (unsigned long )((void *)0))) {
#line 286
      if (sensors_cnt == 0U) {
#line 286
        if (nextaction > last_sensor_scan + 300L) {
#line 288
          nextaction = last_sensor_scan + 300L;
        }
      }
    }
#line 289
    sensors_cnt = (u_int )0;
#line 290
    s = conf->ntp_sensors.tqh_first;
    {
#line 290
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 290
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 290
        goto while_break___5;
      }
#line 291
      if (conf->settime) {
#line 291
        if (s->offsets[0].offset) {
          {
#line 292
          priv_settime(s->offsets[0].offset);
          }
        }
      }
#line 293
      sensors_cnt ++;
#line 294
      if (s->next > 0L) {
#line 294
        if (s->next < nextaction) {
#line 295
          nextaction = s->next;
        }
      }
#line 290
      s = s->entry.tqe_next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 298
    if (conf->settime) {
#line 298
      if (trial_cnt > 0U) {
#line 298
        if (sent_cnt == 0U) {
          {
#line 301
          priv_settime((double )0);
          }
        } else {
#line 298
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 298
      if (peer_cnt == 0U) {
#line 298
        if (sensors_cnt == 0U) {
          {
#line 301
          priv_settime((double )0);
          }
        }
      }
    }
#line 303
    if (ibuf_main->w.queued > 0U) {
#line 304
      (pfd + 0)->events = (short )((int )(pfd + 0)->events | 4);
    }
    {
#line 306
    tmp___17 = getmonotime();
#line 306
    timeout = (int )(nextaction - tmp___17);
    }
#line 307
    if (timeout < 0) {
#line 308
      timeout = 0;
    }
    {
#line 310
    nfds = poll(pfd, (nfds_t )i, timeout * 1000);
    }
#line 310
    if (nfds == -1) {
      {
#line 311
      tmp___18 = __errno_location();
      }
#line 311
      if (*tmp___18 != 4) {
        {
#line 312
        log_warn("poll error");
#line 313
        ntp_quit = (int volatile   )1;
        }
      }
    }
#line 316
    if (nfds > 0) {
#line 316
      if ((int )(pfd + 0)->revents & 4) {
        {
#line 317
        tmp___19 = msgbuf_write(& ibuf_main->w);
        }
#line 317
        if (tmp___19 < 0) {
          {
#line 318
          log_warn("pipe write error (to parent)");
#line 319
          ntp_quit = (int volatile   )1;
          }
        }
      }
    }
#line 322
    if (nfds > 0) {
#line 322
      if ((int )(pfd + 0)->revents & 9) {
        {
#line 323
        nfds --;
#line 324
        tmp___20 = ntp_dispatch_imsg();
        }
#line 324
        if (tmp___20 == -1) {
#line 325
          ntp_quit = (int volatile   )1;
        }
      }
    }
#line 328
    if (nfds > 0) {
#line 328
      if ((int )(pfd + 1)->revents & 9) {
#line 329
        nfds --;
#line 330
        goto while_continue___2;
      }
    }
#line 333
    j = 1;
    {
#line 333
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 333
      if (nfds > 0) {
#line 333
        if (! (j < idx_peers)) {
#line 333
          goto while_break___6;
        }
      } else {
#line 333
        goto while_break___6;
      }
#line 334
      if ((int )(pfd + j)->revents & 9) {
        {
#line 335
        nfds --;
#line 336
        tmp___21 = server_dispatch((pfd + j)->fd, conf);
        }
#line 336
        if (tmp___21 == -1) {
#line 337
          ntp_quit = (int volatile   )1;
        }
      }
#line 333
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 340
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 340
      if (nfds > 0) {
#line 340
        if (! (j < i)) {
#line 340
          goto while_break___7;
        }
      } else {
#line 340
        goto while_break___7;
      }
#line 341
      if ((int )(pfd + j)->revents & 9) {
        {
#line 342
        nfds --;
#line 343
        tmp___22 = client_dispatch(*(idx2peer + (j - idx_peers)), conf->settime);
        }
#line 343
        if (tmp___22 == -1) {
#line 345
          ntp_quit = (int volatile   )1;
        }
      }
#line 340
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 348
    s = conf->ntp_sensors.tqh_first;
    {
#line 348
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 348
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 348
        goto while_break___8;
      }
      {
#line 350
      next_s = s->entry.tqe_next;
#line 351
      tmp___23 = getmonotime();
      }
#line 351
      if (s->next <= tmp___23) {

      }
#line 348
      s = next_s;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 354
    report_peers((int )ntp_report);
#line 355
    ntp_report = (int volatile   )0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 358
  msgbuf_write(& ibuf_main->w);
#line 359
  msgbuf_clear(& ibuf_main->w);
#line 360
  free((void *)ibuf_main);
#line 362
  log_info("ntp engine exiting");
#line 363
  _exit(0);
  }
}
}
#line 366 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
int ntp_dispatch_imsg(void) 
{ 
  struct imsg imsg ;
  int n ;
  struct ntp_peer *peer ;
  struct ntp_peer *npeer ;
  u_int16_t dlen ;
  u_char *p ;
  struct ntp_addr *h ;
  void *tmp ;

  {
  {
#line 376
  n = imsg_read(ibuf_main);
  }
#line 376
  if (n == -1) {
#line 377
    return (-1);
  }
#line 379
  if (n == 0) {
    {
#line 380
    log_warnx("ntp_dispatch_imsg in ntp engine: pipe closed");
    }
#line 381
    return (-1);
  }
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 385
    n = imsg_get(ibuf_main, & imsg);
    }
#line 385
    if (n == -1) {
#line 386
      return (-1);
    }
#line 388
    if (n == 0) {
#line 389
      goto while_break;
    }
    {
#line 392
    if ((unsigned int )imsg.hdr.type == 1U) {
#line 392
      goto case_1;
    }
#line 402
    if ((unsigned int )imsg.hdr.type == 4U) {
#line 402
      goto case_4;
    }
#line 455
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 393
    memcpy((void */* __restrict  */)(& n), (void const   */* __restrict  */)imsg.data,
           sizeof(n));
    }
#line 394
    if (n == 1) {
#line 394
      if (! conf->status.synced) {
        {
#line 395
        log_info("clock is now synced");
#line 396
        conf->status.synced = (u_int8_t )1;
        }
      } else {
#line 394
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 397
    if (n == 0) {
#line 397
      if (conf->status.synced) {
        {
#line 398
        log_info("clock is now unsynced");
#line 399
        conf->status.synced = (u_int8_t )0;
        }
      }
    }
#line 401
    goto switch_break;
    case_4: /* CIL Label */ 
#line 403
    peer = conf->ntp_peers.tqh_first;
    {
#line 403
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 403
      if (! ((unsigned long )peer != (unsigned long )((void *)0))) {
#line 403
        goto while_break___0;
      }
#line 404
      if (peer->id == imsg.hdr.peerid) {
#line 405
        goto while_break___0;
      }
#line 403
      peer = peer->entry.tqe_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 406
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
      {
#line 407
      log_warnx("IMSG_HOST_DNS with invalid peerID");
      }
#line 408
      goto switch_break;
    }
#line 410
    if ((unsigned long )peer->addr != (unsigned long )((void *)0)) {
      {
#line 411
      log_warnx("IMSG_HOST_DNS but addr != NULL!");
      }
#line 412
      goto switch_break;
    }
#line 415
    dlen = (u_int16_t )((unsigned long )imsg.hdr.len - sizeof(struct imsg_hdr ));
#line 416
    if ((int )dlen == 0) {
#line 417
      peer->state = (enum client_state )2;
#line 418
      goto switch_break;
    }
#line 421
    p = (u_char *)imsg.data;
    {
#line 422
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 422
      if (! ((unsigned long )dlen >= sizeof(struct sockaddr_storage ))) {
#line 422
        goto while_break___1;
      }
      {
#line 423
      tmp = calloc((size_t )1, sizeof(struct ntp_addr ));
#line 423
      h = (struct ntp_addr *)tmp;
      }
#line 423
      if ((unsigned long )h == (unsigned long )((void *)0)) {
        {
#line 425
        fatal((char const   *)((void *)0));
        }
      }
      {
#line 426
      memcpy((void */* __restrict  */)(& h->ss), (void const   */* __restrict  */)p,
             sizeof(h->ss));
#line 427
      p += sizeof(h->ss);
#line 428
      dlen = (u_int16_t )((unsigned long )dlen - sizeof(h->ss));
      }
#line 429
      if (peer->addr_head.pool) {
        {
#line 430
        npeer = new_peer();
#line 431
        npeer->weight = peer->weight;
#line 432
        h->next = (struct ntp_addr *)((void *)0);
#line 433
        npeer->addr = h;
#line 434
        npeer->addr_head.a = h;
#line 435
        npeer->addr_head.name = peer->addr_head.name;
#line 437
        npeer->addr_head.pool = (u_int8_t )1;
#line 438
        client_peer_init(npeer);
#line 439
        npeer->state = (enum client_state )3;
#line 440
        peer_add(npeer);
        }
      } else {
#line 442
        h->next = peer->addr;
#line 443
        peer->addr = h;
#line 444
        peer->addr_head.a = peer->addr;
#line 445
        peer->state = (enum client_state )3;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 448
    if ((int )dlen != 0) {
      {
#line 449
      fatalx("IMSG_HOST_DNS: dlen != 0");
      }
    }
#line 450
    if (peer->addr_head.pool) {
      {
#line 451
      peer_remove(peer);
      }
    } else {
      {
#line 453
      client_addr_init(peer);
      }
    }
#line 454
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 456
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 458
    imsg_free(& imsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  return (0);
}
}
#line 463 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
void peer_add(struct ntp_peer *p ) 
{ 


  {
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    p->entry.tqe_next = (struct ntp_peer *)((void *)0);
#line 466
    p->entry.tqe_prev = conf->ntp_peers.tqh_last;
#line 466
    *(conf->ntp_peers.tqh_last) = p;
#line 466
    conf->ntp_peers.tqh_last = & p->entry.tqe_next;
#line 466
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  peer_cnt ++;
#line 468
  return;
}
}
#line 470 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
void peer_remove(struct ntp_peer *p ) 
{ 


  {
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if ((unsigned long )p->entry.tqe_next != (unsigned long )((void *)0)) {
#line 473
      (p->entry.tqe_next)->entry.tqe_prev = p->entry.tqe_prev;
    } else {
#line 473
      conf->ntp_peers.tqh_last = p->entry.tqe_prev;
    }
#line 473
    *(p->entry.tqe_prev) = p->entry.tqe_next;
#line 473
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 474
  free((void *)p);
#line 475
  peer_cnt --;
  }
#line 476
  return;
}
}
#line 478 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
static void priv_adjfreq(double offset ) 
{ 
  double curtime ;
  double freq ;

  {
#line 483
  if (! conf->status.synced) {
#line 484
    return;
  }
#line 486
  (conf->freq.samples) ++;
#line 488
  if (conf->freq.samples <= 0) {
#line 489
    return;
  }
  {
#line 491
  conf->freq.overall_offset += offset;
#line 492
  offset = conf->freq.overall_offset;
#line 494
  curtime = gettime_corrected();
#line 495
  conf->freq.xy += offset * curtime;
#line 496
  conf->freq.x += curtime;
#line 497
  conf->freq.y += offset;
#line 498
  conf->freq.xx += curtime * curtime;
  }
#line 500
  if (conf->freq.samples % 8 != 0) {
#line 501
    return;
  }
#line 503
  freq = (conf->freq.xy - (conf->freq.x * conf->freq.y) / (double )conf->freq.samples) / (conf->freq.xx - (conf->freq.x * conf->freq.x) / (double )conf->freq.samples);
#line 508
  if (freq > 128e-5) {
#line 509
    freq = 128e-5;
  } else
#line 510
  if (freq < - 128e-5) {
#line 511
    freq = - 128e-5;
  }
  {
#line 513
  imsg_compose(ibuf_main, (enum imsg_type )2, (u_int32_t )0, 0, (void *)(& freq),
               (u_int16_t )sizeof(freq));
#line 514
  conf->freq.xy = 0.0;
#line 515
  conf->freq.x = 0.0;
#line 516
  conf->freq.y = 0.0;
#line 517
  conf->freq.xx = 0.0;
#line 518
  conf->freq.samples = 0;
#line 519
  conf->freq.overall_offset = 0.0;
#line 520
  (conf->freq.num) ++;
  }
#line 521
  return;
}
}
#line 523 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
int priv_adjtime(void) 
{ 
  struct ntp_peer *p ;
  struct ntp_sensor *s ;
  int offset_cnt ;
  int i ;
  int j ;
  struct ntp_offset **offsets ;
  double offset_median ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 528
  offset_cnt = 0;
#line 528
  i = 0;
#line 532
  p = conf->ntp_peers.tqh_first;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 532
      goto while_break;
    }
#line 533
    if ((int )p->trustlevel < 6) {
#line 534
      goto __Cont;
    }
#line 535
    if (! p->update.good) {
#line 536
      return (1);
    }
#line 537
    offset_cnt += (int )p->weight;
    __Cont: /* CIL Label */ 
#line 532
    p = p->entry.tqe_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  s = conf->ntp_sensors.tqh_first;
  {
#line 540
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 540
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 540
      goto while_break___0;
    }
#line 541
    if (! s->update.good) {
#line 542
      goto __Cont___0;
    }
#line 543
    offset_cnt += (int )s->weight;
    __Cont___0: /* CIL Label */ 
#line 540
    s = s->entry.tqe_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 546
  if (offset_cnt == 0) {
#line 547
    return (1);
  }
  {
#line 549
  tmp = calloc((size_t )offset_cnt, sizeof(struct ntp_offset *));
#line 549
  offsets = (struct ntp_offset **)tmp;
  }
#line 549
  if ((unsigned long )offsets == (unsigned long )((void *)0)) {
    {
#line 550
    fatal("calloc priv_adjtime");
    }
  }
#line 552
  p = conf->ntp_peers.tqh_first;
  {
#line 552
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 552
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 552
      goto while_break___1;
    }
#line 553
    if ((int )p->trustlevel < 6) {
#line 554
      goto __Cont___1;
    }
#line 555
    j = 0;
    {
#line 555
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 555
      if (! (j < (int )p->weight)) {
#line 555
        goto while_break___2;
      }
#line 556
      tmp___0 = i;
#line 556
      i ++;
#line 556
      *(offsets + tmp___0) = & p->update;
#line 555
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont___1: /* CIL Label */ 
#line 552
    p = p->entry.tqe_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 559
  s = conf->ntp_sensors.tqh_first;
  {
#line 559
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 559
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 559
      goto while_break___3;
    }
#line 560
    if (! s->update.good) {
#line 561
      goto __Cont___2;
    }
#line 562
    j = 0;
    {
#line 562
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 562
      if (! (j < (int )s->weight)) {
#line 562
        goto while_break___4;
      }
#line 563
      tmp___1 = i;
#line 563
      i ++;
#line 563
      *(offsets + tmp___1) = & s->update;
#line 562
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    __Cont___2: /* CIL Label */ 
#line 559
    s = s->entry.tqe_next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 566
  qsort((void *)offsets, (size_t )offset_cnt, sizeof(struct ntp_offset *), & offset_compare);
#line 568
  i = offset_cnt / 2;
  }
#line 569
  if (offset_cnt % 2 == 0) {
#line 570
    offset_median = ((*(offsets + (i - 1)))->offset + (*(offsets + i))->offset) / (double )2;
#line 572
    conf->status.rootdelay = ((*(offsets + (i - 1)))->delay + (*(offsets + i))->delay) / (double )2;
#line 574
    if ((int )(*(offsets + (i - 1)))->status.stratum > (int )(*(offsets + i))->status.stratum) {
#line 574
      conf->status.stratum = (*(offsets + (i - 1)))->status.stratum;
    } else {
#line 574
      conf->status.stratum = (*(offsets + i))->status.stratum;
    }
  } else {
#line 577
    offset_median = (*(offsets + i))->offset;
#line 578
    conf->status.rootdelay = (*(offsets + i))->delay;
#line 579
    conf->status.stratum = (*(offsets + i))->status.stratum;
  }
  {
#line 581
  conf->status.leap = (*(offsets + i))->status.leap;
#line 583
  imsg_compose(ibuf_main, (enum imsg_type )1, (u_int32_t )0, 0, (void *)(& offset_median),
               (u_int16_t )sizeof(offset_median));
#line 586
  priv_adjfreq(offset_median);
#line 588
  conf->status.reftime = gettime();
#line 589
  conf->status.stratum = (u_int8_t )((int )conf->status.stratum + 1);
#line 590
  update_scale(offset_median);
#line 592
  conf->status.refid4 = (*(offsets + i))->status.refid4;
#line 593
  conf->status.refid = (*(offsets + i))->status.send_refid;
#line 595
  free((void *)offsets);
#line 597
  p = conf->ntp_peers.tqh_first;
  }
  {
#line 597
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 597
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 597
      goto while_break___5;
    }
#line 598
    i = 0;
    {
#line 598
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 598
      if (! (i < 8)) {
#line 598
        goto while_break___6;
      }
#line 599
      p->reply[i].offset -= offset_median;
#line 598
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 600
    p->update.good = (u_int8_t )0;
#line 597
    p = p->entry.tqe_next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 602
  s = conf->ntp_sensors.tqh_first;
  {
#line 602
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 602
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 602
      goto while_break___7;
    }
#line 603
    i = 0;
    {
#line 603
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 603
      if (! (i < 7)) {
#line 603
        goto while_break___8;
      }
#line 604
      s->offsets[i].offset -= offset_median;
#line 603
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 605
    s->update.offset -= offset_median;
#line 602
    s = s->entry.tqe_next;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 608
  return (0);
}
}
#line 611 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
int offset_compare(void const   *aa , void const   *bb ) 
{ 
  struct ntp_offset  const  * const  *a ;
  struct ntp_offset  const  * const  *b ;

  {
#line 617
  a = (struct ntp_offset  const  * const  *)aa;
#line 618
  b = (struct ntp_offset  const  * const  *)bb;
#line 620
  if ((*a)->offset < (*b)->offset) {
#line 621
    return (-1);
  } else
#line 622
  if ((*a)->offset > (*b)->offset) {
#line 623
    return (1);
  } else {
#line 625
    return (0);
  }
}
}
#line 628 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
void priv_settime(double offset ) 
{ 
  struct ntp_peer *p ;

  {
  {
#line 633
  imsg_compose(ibuf_main, (enum imsg_type )3, (u_int32_t )0, 0, (void *)(& offset),
               (u_int16_t )sizeof(offset));
#line 634
  conf->settime = (u_int8_t )0;
#line 636
  p = conf->ntp_peers.tqh_first;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 636
      goto while_break;
    }
#line 637
    if (p->next) {
#line 638
      p->next = (time_t )((double )p->next - offset);
    }
#line 639
    if (p->deadline) {
#line 640
      p->deadline = (time_t )((double )p->deadline - offset);
    }
#line 636
    p = p->entry.tqe_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  return;
}
}
#line 644 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
void priv_host_dns(char *name , u_int32_t peerid ) 
{ 
  u_int16_t dlen ;
  size_t tmp ;

  {
  {
#line 649
  tmp = strlen((char const   *)name);
#line 649
  dlen = (u_int16_t )(tmp + 1UL);
#line 650
  imsg_compose(ibuf_main, (enum imsg_type )4, peerid, 0, (void *)name, dlen);
  }
#line 651
  return;
}
}
#line 653 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
void update_scale(double offset ) 
{ 
  double tmp ;

  {
  {
#line 656
  tmp = getoffset();
#line 656
  offset += tmp;
  }
#line 657
  if (offset < (double )0) {
#line 658
    offset = - offset;
  }
#line 660
  if (offset > 0.050) {
#line 662
    conf->scale = (u_int32_t )1;
  } else
#line 660
  if (! conf->status.synced) {
#line 662
    conf->scale = (u_int32_t )1;
  } else
#line 660
  if (conf->freq.num < 3U) {
#line 662
    conf->scale = (u_int32_t )1;
  } else
#line 663
  if (offset < 0.001) {
#line 664
    conf->scale = (u_int32_t )(0.050 / 0.001);
  } else {
#line 666
    conf->scale = (u_int32_t )(0.050 / offset);
  }
#line 667
  return;
}
}
#line 669 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
time_t scale_interval(time_t requested ) 
{ 
  time_t interval ;
  time_t r ;
  unsigned int tmp ;
  time_t tmp___0 ;

  {
  {
#line 674
  interval = requested * (time_t )conf->scale;
#line 675
  tmp = arc4random();
  }
#line 675
  if (5L > interval / 10L) {
#line 675
    tmp___0 = (time_t )5;
  } else {
#line 675
    tmp___0 = interval / 10L;
  }
#line 675
  r = (long )tmp % tmp___0;
#line 676
  return (interval + r);
}
}
#line 679 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
time_t error_interval(void) 
{ 
  time_t interval ;
  time_t r ;
  unsigned int tmp ;

  {
  {
#line 684
  interval = (time_t )(((double )60 * 0.050) / 0.001);
#line 685
  tmp = arc4random();
#line 685
  r = (long )tmp % (interval / 10L);
  }
#line 686
  return (interval + r);
}
}
#line 689 "/home/wheatley/newnew/temp/openntpd-20080406p/ntp.c"
void report_peers(int always ) 
{ 
  time_t now ;
  u_int badpeers ;
  u_int badsensors ;
  struct ntp_peer *p ;
  struct ntp_sensor *s ;
  char const   *a ;
  char const   *pool ;

  {
#line 693
  badpeers = (u_int )0;
#line 694
  badsensors = (u_int )0;
#line 698
  p = conf->ntp_peers.tqh_first;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 698
      goto while_break;
    }
#line 699
    if ((int )p->trustlevel < 6) {
#line 700
      badpeers ++;
    }
#line 698
    p = p->entry.tqe_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 702
  s = conf->ntp_sensors.tqh_first;
  {
#line 702
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 702
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 702
      goto while_break___0;
    }
#line 703
    if (! s->update.good) {
#line 704
      badsensors ++;
    }
#line 702
    s = s->entry.tqe_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 707
  now = time((time_t *)((void *)0));
  }
#line 708
  if (! always) {
#line 709
    if (peer_cnt == 0U) {
#line 709
      goto _L;
    } else
#line 709
    if (badpeers == 0U) {
#line 709
      goto _L;
    } else
#line 709
    if (badpeers < peer_cnt / 2U) {
      _L: /* CIL Label */ 
#line 709
      if (sensors_cnt == 0U) {
#line 712
        return;
      } else
#line 709
      if (badsensors == 0U) {
#line 712
        return;
      } else
#line 709
      if (badsensors < sensors_cnt / 2U) {
#line 712
        return;
      }
    }
#line 714
    if (lastreport + 86400L > now) {
#line 715
      return;
    }
  }
#line 717
  lastreport = now;
#line 718
  if (peer_cnt > 0U) {
    {
#line 719
    log_warnx("%u out of %u peers valid", peer_cnt - badpeers, peer_cnt);
#line 721
    p = conf->ntp_peers.tqh_first;
    }
    {
#line 721
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 721
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 721
        goto while_break___1;
      }
#line 722
      if ((int )p->trustlevel < 6) {
#line 723
        a = "not resolved";
#line 724
        pool = "";
#line 725
        if (p->addr) {
          {
#line 726
          a = log_sockaddr((struct sockaddr *)(& (p->addr)->ss));
          }
        }
#line 728
        if (p->addr_head.pool) {
#line 729
          pool = "from pool ";
        }
        {
#line 730
        log_warnx("bad peer %s%s (%s)", pool, p->addr_head.name, a);
        }
      }
#line 721
      p = p->entry.tqe_next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 735
  if (sensors_cnt > 0U) {
    {
#line 736
    log_warnx("%u out of %u sensors valid", sensors_cnt - badsensors, sensors_cnt);
#line 738
    s = conf->ntp_sensors.tqh_first;
    }
    {
#line 738
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 738
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 738
        goto while_break___2;
      }
#line 739
      if (! s->update.good) {
        {
#line 740
        log_warnx("bad sensor %s", s->device);
        }
      }
#line 738
      s = s->entry.tqe_next;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 743
  return;
}
}
