/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 12 "/home/june/collector/temp/alac-decoder-0.2.0/stream.h"
struct stream_tTAG;
#line 12 "/home/june/collector/temp/alac-decoder-0.2.0/stream.h"
typedef struct stream_tTAG stream_t;
#line 12 "/home/june/collector/temp/alac-decoder-0.2.0/demux.h"
typedef uint32_t fourcc_t;
#line 14 "/home/june/collector/temp/alac-decoder-0.2.0/demux.h"
struct __anonstruct_time_to_sample_27 {
   uint32_t sample_count ;
   uint32_t sample_duration ;
};
#line 14 "/home/june/collector/temp/alac-decoder-0.2.0/demux.h"
struct __anonstruct_demux_res_t_26 {
   int format_read ;
   uint16_t num_channels ;
   uint16_t sample_size ;
   uint32_t sample_rate ;
   fourcc_t format ;
   void *buf ;
   struct __anonstruct_time_to_sample_27 *time_to_sample ;
   uint32_t num_time_to_samples ;
   uint32_t *sample_byte_size ;
   uint32_t num_sample_byte_sizes ;
   uint32_t codecdata_len ;
   void *codecdata ;
   uint32_t mdat_len ;
};
#line 14 "/home/june/collector/temp/alac-decoder-0.2.0/demux.h"
typedef struct __anonstruct_demux_res_t_26 demux_res_t;
#line 4 "/home/june/collector/temp/alac-decoder-0.2.0/decomp.h"
struct alac_file;
#line 4 "/home/june/collector/temp/alac-decoder-0.2.0/decomp.h"
typedef struct alac_file alac_file;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 45 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
struct __anonstruct_qtmovie_t_27 {
   stream_t *stream ;
   demux_res_t *res ;
   long saved_mdat_pos ;
};
#line 45 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
typedef struct __anonstruct_qtmovie_t_27 qtmovie_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 54 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
struct __anonstruct_se_struct_24_25 {
   int x : 24 ;
};
#line 59 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
struct alac_file {
   unsigned char *input_buffer ;
   int input_buffer_bitaccumulator ;
   int samplesize ;
   int numchannels ;
   int bytespersample ;
   int32_t *predicterror_buffer_a ;
   int32_t *predicterror_buffer_b ;
   int32_t *outputsamples_buffer_a ;
   int32_t *outputsamples_buffer_b ;
   int32_t *uncompressed_bytes_buffer_a ;
   int32_t *uncompressed_bytes_buffer_b ;
   uint32_t setinfo_max_samples_per_frame ;
   uint8_t setinfo_7a ;
   uint8_t setinfo_sample_size ;
   uint8_t setinfo_rice_historymult ;
   uint8_t setinfo_rice_initialhistory ;
   uint8_t setinfo_rice_kmodifier ;
   uint8_t setinfo_7f ;
   uint16_t setinfo_80 ;
   uint32_t setinfo_82 ;
   uint32_t setinfo_86 ;
   uint32_t setinfo_8a_rate ;
};
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 56 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
struct stream_tTAG {
   FILE *f ;
   int bigendian ;
   int eof ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 14 "/home/june/collector/temp/alac-decoder-0.2.0/stream.h"
void stream_read(stream_t *stream , size_t size , void *buf ) ;
#line 32
stream_t *stream_create_file(FILE *file , int bigendian ) ;
#line 34
void stream_destroy(stream_t *stream ) ;
#line 42 "/home/june/collector/temp/alac-decoder-0.2.0/demux.h"
int qtmovie_read(stream_t *file , demux_res_t *demux_res ) ;
#line 6 "/home/june/collector/temp/alac-decoder-0.2.0/decomp.h"
alac_file *create_alac(int samplesize , int numchannels ) ;
#line 7
void decode_frame(alac_file *alac___0 , unsigned char *inbuffer , void *outbuffer ,
                  int *outputsize ) ;
#line 10
void alac_set_info(alac_file *alac___0 , char *inputbuffer ) ;
#line 4 "/home/june/collector/temp/alac-decoder-0.2.0/wavwriter.h"
void wavwriter_writeheaders(FILE *f , int datasize , int numchannels , int samplerate ,
                            int bitspersample ) ;
#line 51 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
int host_bigendian  =    0;
#line 53 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
alac_file *alac  =    (alac_file *)((void *)0);
#line 55 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static FILE *input_file  =    (FILE *)((void *)0);
#line 56 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static int input_opened  =    0;
#line 57 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static stream_t *input_stream  ;
#line 59 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static FILE *output_file  =    (FILE *)((void *)0);
#line 60 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static int output_opened  =    0;
#line 62 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static int write_wav_format  =    1;
#line 63 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static int verbose  =    0;
#line 64 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static int test_file_type  =    0;
#line 66 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static int get_sample_info(demux_res_t *demux_res , uint32_t samplenum , uint32_t *sample_duration ,
                           uint32_t *sample_byte_size ) 
{ 
  unsigned int duration_index_accum ;
  unsigned int duration_cur_index ;

  {
#line 70
  duration_index_accum = 0U;
#line 71
  duration_cur_index = 0U;
#line 73
  if (samplenum >= demux_res->num_sample_byte_sizes) {
    {
#line 75
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sample %i does not exist\n",
            samplenum);
    }
#line 76
    return (0);
  }
#line 79
  if (! demux_res->num_time_to_samples) {
    {
#line 81
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no time to samples\n");
    }
#line 82
    return (0);
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((demux_res->time_to_sample + duration_cur_index)->sample_count + duration_index_accum <= samplenum)) {
#line 84
      goto while_break;
    }
#line 87
    duration_index_accum += (demux_res->time_to_sample + duration_cur_index)->sample_count;
#line 88
    duration_cur_index ++;
#line 89
    if (duration_cur_index >= demux_res->num_time_to_samples) {
      {
#line 91
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sample %i does not have a duration\n",
              samplenum);
      }
#line 92
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  *sample_duration = (demux_res->time_to_sample + duration_cur_index)->sample_duration;
#line 97
  *sample_byte_size = *(demux_res->sample_byte_size + samplenum);
#line 99
  return (1);
}
}
#line 102 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static void GetBuffer(demux_res_t *demux_res ) 
{ 
  unsigned long destBufferSize ;
  void *pDestBuffer ;
  void *tmp ;
  int bytes_read ;
  unsigned int buffer_size ;
  void *buffer ;
  unsigned int i ;
  uint32_t sample_duration ;
  uint32_t sample_byte_size ;
  int outputBytes ;
  int tmp___0 ;

  {
  {
#line 104
  destBufferSize = 24576UL;
#line 105
  tmp = malloc(destBufferSize);
#line 105
  pDestBuffer = tmp;
#line 106
  bytes_read = 0;
#line 108
  buffer_size = 81920U;
#line 113
  buffer = malloc((size_t )buffer_size);
#line 115
  i = 0U;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i < demux_res->num_sample_byte_sizes)) {
#line 115
      goto while_break;
    }
    {
#line 123
    tmp___0 = get_sample_info(demux_res, i, & sample_duration, & sample_byte_size);
    }
#line 123
    if (! tmp___0) {
      {
#line 126
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sample failed\n");
      }
#line 127
      return;
    }
#line 130
    if (buffer_size < sample_byte_size) {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sorry buffer too small! (is %i want %i)\n",
              buffer_size, sample_byte_size);
      }
#line 135
      return;
    }
    {
#line 138
    stream_read(input_stream, (size_t )sample_byte_size, buffer);
#line 142
    outputBytes = (int )destBufferSize;
#line 143
    decode_frame(alac, (unsigned char *)buffer, pDestBuffer, & outputBytes);
#line 146
    bytes_read += outputBytes;
    }
#line 148
    if (verbose) {
      {
#line 149
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read %i bytes. total: %i\n",
              outputBytes, bytes_read);
      }
    }
    {
#line 151
    fwrite((void const   */* __restrict  */)pDestBuffer, (size_t )outputBytes, (size_t )1,
           (FILE */* __restrict  */)output_file);
#line 115
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  if (verbose) {
    {
#line 154
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done reading, read %i frames\n",
            i);
    }
  }
#line 155
  return;
}
}
#line 157 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static void init_sound_converter(demux_res_t *demux_res ) 
{ 


  {
  {
#line 159
  alac = create_alac((int )demux_res->sample_size, (int )demux_res->num_channels);
#line 161
  alac_set_info(alac, (char *)demux_res->codecdata);
  }
#line 162
  return;
}
}
#line 164 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static void usage(void) 
{ 


  {
  {
#line 166
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: alac [options] [--] file\nDecompresses the ALAC file specified\n\nOptions:\n  -f output.wav     outputs the decompressed data to the\n                    specified file, in WAV format. Default\n                    is stdout.\n  -r                write output as raw PCM data. Default\n                    is in WAV format.\n  -v                verbose output.\n  -t                test that file is ALAC, also tests for\n                    other m4a file types.\n\nThis software is Copyright (c) 2005 David Hammerton\nAll rights reserved\nhttp://crazney.net/\n");
#line 182
  exit(1);
  }
}
}
#line 185 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
static void setup_environment(int argc , char **argv ) 
{ 
  int i ;
  char *input_file_n ;
  char *output_file_n ;
  int escaped ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 187
  i = argc;
#line 189
  input_file_n = (char *)((void *)0);
#line 190
  output_file_n = (char *)((void *)0);
#line 192
  escaped = 0;
#line 194
  if (argc < 2) {
    {
#line 194
    usage();
    }
  }
#line 196
  i = argc - 1;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i > 1)) {
#line 196
      goto while_break;
    }
    {
#line 198
    tmp___3 = strcmp((char const   *)*(argv + (argc - i)), "-f");
    }
#line 198
    if (tmp___3 == 0) {
#line 200
      i --;
#line 200
      if (! i) {
        {
#line 200
        usage();
        }
      }
#line 201
      output_file_n = *(argv + (argc - i));
    } else {
      {
#line 203
      tmp___2 = strcmp((char const   *)*(argv + (argc - i)), "-r");
      }
#line 203
      if (tmp___2 == 0) {
#line 205
        write_wav_format = 0;
      } else {
        {
#line 207
        tmp___1 = strcmp((char const   *)*(argv + (argc - i)), "-v");
        }
#line 207
        if (tmp___1 == 0) {
#line 209
          verbose = 1;
        } else {
          {
#line 211
          tmp___0 = strcmp((char const   *)*(argv + (argc - i)), "-t");
          }
#line 211
          if (tmp___0 == 0) {
#line 213
            test_file_type = 1;
          } else {
            {
#line 215
            tmp = strcmp((char const   *)*(argv + (argc - i)), "--");
            }
#line 215
            if (tmp == 0) {
#line 218
              if (i != 2) {
                {
#line 218
                usage();
                }
              }
#line 219
              escaped = 1;
            } else {
              {
#line 222
              usage();
              }
            }
          }
        }
      }
    }
#line 196
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if (i != 1) {
    {
#line 225
    usage();
    }
  }
#line 227
  input_file_n = *(argv + (argc - 1));
#line 233
  if (! escaped) {
#line 233
    if ((int )*(input_file_n + 0) == 45) {
#line 233
      if ((int )*(input_file_n + 1) != 0) {
        {
#line 233
        usage();
        }
      }
    }
  }
#line 235
  if (! input_file_n) {
    {
#line 235
    usage();
    }
  }
#line 237
  if (output_file_n) {
    {
#line 239
    output_file = fopen((char const   */* __restrict  */)output_file_n, (char const   */* __restrict  */)"wb");
    }
#line 240
    if (! output_file) {
      {
#line 242
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open output file \'%s\': ",
              output_file_n);
#line 243
      perror((char const   *)((void *)0));
#line 244
      exit(1);
      }
    }
#line 246
    output_opened = 1;
  } else {
#line 250
    output_file = stdout;
  }
  {
#line 253
  tmp___4 = strcmp((char const   *)input_file_n, "-");
  }
#line 253
  if (tmp___4 == 0) {
#line 255
    input_file = stdin;
  } else {
    {
#line 259
    input_file = fopen((char const   */* __restrict  */)input_file_n, (char const   */* __restrict  */)"rb");
    }
#line 260
    if (! input_file) {
      {
#line 262
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open input file \'%s\': ",
              input_file_n);
#line 263
      perror((char const   *)((void *)0));
#line 264
      exit(1);
      }
    }
#line 266
    input_opened = 1;
  }
#line 268
  return;
}
}
#line 275 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
void set_endian(void) 
{ 
  uint32_t integer ;
  unsigned char *p ;

  {
#line 277
  integer = (uint32_t )170;
#line 278
  p = (unsigned char *)(& integer);
#line 280
  if ((int )*(p + 0) == 170) {
#line 280
    host_bigendian = 0;
  } else {
#line 281
    host_bigendian = 1;
  }
#line 282
  return;
}
}
#line 284 "/home/june/collector/temp/alac-decoder-0.2.0/main.c"
int main(int argc , char **argv ) 
{ 
  demux_res_t demux_res ;
  unsigned int output_size ;
  unsigned int i ;
  int tmp ;
  unsigned int thissample_duration ;
  unsigned int thissample_bytesize ;

  {
  {
#line 289
  memset((void *)(& demux_res), 0, sizeof(demux_res));
#line 291
  set_endian();
#line 293
  setup_environment(argc, argv);
#line 300
  input_stream = stream_create_file(input_file, 1);
  }
#line 301
  if (! input_stream) {
    {
#line 303
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to create input stream from file\n");
    }
#line 304
    return (1);
  }
  {
#line 309
  tmp = qtmovie_read(input_stream, & demux_res);
  }
#line 309
  if (! tmp) {
#line 311
    if (! test_file_type) {
#line 311
      goto _L;
    } else
#line 311
    if (! demux_res.format_read) {
      _L: /* CIL Label */ 
      {
#line 313
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to load the QuickTime movie headers");
      }
#line 314
      if (demux_res.format_read) {
        {
#line 315
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (file type: %c%c%c%c)\n",
                (int )((char )((int32_t )demux_res.format >> 24)), (int )((char )((int32_t )demux_res.format >> 16)),
                (int )((char )((int32_t )demux_res.format >> 8)), (int )((char )demux_res.format));
        }
      } else {
        {
#line 318
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 319
      return (1);
    }
  }
#line 322
  if (test_file_type) {
#line 325
    if (! demux_res.format_read) {
      {
#line 327
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to load the QUickTime movie headers. Probably not a quicktime file\n");
      }
#line 329
      return (1);
    }
    {
#line 331
    printf((char const   */* __restrict  */)"file type: %c%c%c%c\n", (int )((char )((int32_t )demux_res.format >> 24)),
           (int )((char )((int32_t )demux_res.format >> 16)), (int )((char )((int32_t )demux_res.format >> 8)),
           (int )((char )demux_res.format));
    }
    {
#line 335
    if (demux_res.format == (fourcc_t )((((97 << 24) | (108 << 16)) | (97 << 8)) | 99)) {
#line 335
      goto case_exp;
    }
#line 337
    if (demux_res.format == (fourcc_t )((((109 << 24) | (112 << 16)) | (52 << 8)) | 97)) {
#line 337
      goto case_exp___0;
    }
#line 333
    goto switch_break;
    case_exp: /* CIL Label */ 
#line 336
    return (0);
    case_exp___0: /* CIL Label */ 
#line 338
    return (100);
    switch_break: /* CIL Label */ ;
    }
#line 340
    return (1);
  }
  {
#line 344
  init_sound_converter(& demux_res);
  }
#line 347
  if (write_wav_format) {
#line 350
    output_size = 0U;
#line 351
    i = 0U;
    {
#line 351
    while (1) {
      while_continue: /* CIL Label */ ;
#line 351
      if (! (i < demux_res.num_sample_byte_sizes)) {
#line 351
        goto while_break;
      }
      {
#line 353
      thissample_duration = 0U;
#line 354
      thissample_bytesize = 0U;
#line 356
      get_sample_info(& demux_res, i, & thissample_duration, & thissample_bytesize);
#line 359
      output_size += (thissample_duration * (unsigned int )((int )demux_res.sample_size / 8)) * (unsigned int )demux_res.num_channels;
#line 351
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 362
    wavwriter_writeheaders(output_file, (int )output_size, (int )demux_res.num_channels,
                           (int )demux_res.sample_rate, (int )demux_res.sample_size);
    }
  }
  {
#line 370
  GetBuffer(& demux_res);
#line 372
  stream_destroy(input_stream);
  }
#line 374
  if (output_opened) {
    {
#line 375
    fclose(output_file);
    }
  }
#line 377
  if (input_opened) {
    {
#line 378
    fclose(input_file);
    }
  }
#line 380
  return (0);
}
}
#line 61 "/home/june/collector/temp/alac-decoder-0.2.0/wavwriter.c"
static void write_uint32(FILE *f , uint32_t v , int bigendian ) 
{ 


  {
#line 63
  if (bigendian ^ host_bigendian) {
    {
#line 63
    while (1) {
      while_continue: /* CIL Label */ ;
#line 63
      v = ((((v & 255U) << 24) | ((v & 65280U) << 8)) | ((v & 16711680U) >> 8)) | ((v & 4278190080U) >> 24);
#line 63
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 64
  fwrite((void const   */* __restrict  */)(& v), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
  }
#line 65
  return;
}
}
#line 67 "/home/june/collector/temp/alac-decoder-0.2.0/wavwriter.c"
static void write_uint16(FILE *f , uint16_t v , int bigendian ) 
{ 


  {
#line 69
  if (bigendian ^ host_bigendian) {
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
#line 69
      v = (uint16_t )((((int )v & 255) << 8) | (((int )v & 65280) >> 8));
#line 69
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 70
  fwrite((void const   */* __restrict  */)(& v), (size_t )2, (size_t )1, (FILE */* __restrict  */)f);
  }
#line 71
  return;
}
}
#line 73 "/home/june/collector/temp/alac-decoder-0.2.0/wavwriter.c"
void wavwriter_writeheaders(FILE *f , int datasize , int numchannels , int samplerate ,
                            int bitspersample ) 
{ 


  {
  {
#line 78
  write_uint32(f, (uint32_t )((((82 << 24) | (73 << 16)) | (70 << 8)) | 70), 1);
#line 79
  write_uint32(f, (uint32_t )(36 + datasize), 0);
#line 80
  write_uint32(f, (uint32_t )((((87 << 24) | (65 << 16)) | (86 << 8)) | 69), 1);
#line 83
  write_uint32(f, (uint32_t )((((102 << 24) | (109 << 16)) | (116 << 8)) | 32), 1);
#line 84
  write_uint32(f, (uint32_t )16, 0);
#line 85
  write_uint16(f, (uint16_t )1, 0);
#line 86
  write_uint16(f, (uint16_t )numchannels, 0);
#line 87
  write_uint32(f, (uint32_t )samplerate, 0);
#line 88
  write_uint32(f, (uint32_t )((samplerate * numchannels) * (bitspersample / 8)), 0);
#line 89
  write_uint16(f, (uint16_t )(numchannels * (bitspersample / 8)), 0);
#line 90
  write_uint16(f, (uint16_t )bitspersample, 0);
#line 93
  write_uint32(f, (uint32_t )((((100 << 24) | (97 << 16)) | (116 << 8)) | 97), 1);
#line 94
  write_uint32(f, (uint32_t )datasize, 0);
  }
#line 95
  return;
}
}
#line 17 "/home/june/collector/temp/alac-decoder-0.2.0/stream.h"
uint32_t stream_read_uint32(stream_t *stream ) ;
#line 20
uint16_t stream_read_uint16(stream_t *stream ) ;
#line 23
uint8_t stream_read_uint8(stream_t *stream ) ;
#line 25
void stream_skip(stream_t *stream , size_t skip ) ;
#line 27
int stream_eof(stream_t *stream ) ;
#line 29
long stream_tell(stream_t *stream ) ;
#line 30
int stream_setpos(stream_t *stream , long pos ) ;
#line 54 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_ftyp(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  fourcc_t type ;
  uint32_t minor_ver ;
  size_t size_remaining ;

  {
  {
#line 58
  size_remaining = chunk_len - 8UL;
#line 60
  type = stream_read_uint32(qtmovie->stream);
#line 61
  size_remaining -= 4UL;
  }
#line 62
  if (type != (fourcc_t )((((77 << 24) | (52 << 16)) | (65 << 8)) | 32)) {
    {
#line 64
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not M4A file\n");
    }
#line 65
    return;
  }
  {
#line 67
  minor_ver = stream_read_uint32(qtmovie->stream);
#line 68
  size_remaining -= 4UL;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! size_remaining) {
#line 71
      goto while_break;
    }
    {
#line 74
    stream_read_uint32(qtmovie->stream);
#line 75
    size_remaining -= 4UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return;
}
}
#line 79 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_tkhd(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 82
  size_remaining = chunk_len - 8UL;
#line 84
  stream_skip(qtmovie->stream, size_remaining);
  }
#line 85
  return;
}
}
#line 87 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_mdhd(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 90
  size_remaining = chunk_len - 8UL;
#line 92
  stream_skip(qtmovie->stream, size_remaining);
  }
#line 93
  return;
}
}
#line 95 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_edts(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 98
  size_remaining = chunk_len - 8UL;
#line 100
  stream_skip(qtmovie->stream, size_remaining);
  }
#line 101
  return;
}
}
#line 103 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_elst(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 106
  size_remaining = chunk_len - 8UL;
#line 108
  stream_skip(qtmovie->stream, size_remaining);
  }
#line 109
  return;
}
}
#line 112 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_hdlr(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  fourcc_t comptype ;
  fourcc_t compsubtype ;
  size_t size_remaining ;
  int strlen___0 ;
  char str[256] ;
  unsigned int tmp ;
  uint8_t tmp___0 ;

  {
#line 115
  size_remaining = chunk_len - 8UL;
#line 118
  str[0] = (char)0;
#line 118
  tmp = 1U;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (tmp >= 256U) {
#line 118
      goto while_break;
    }
#line 118
    str[tmp] = (char)0;
#line 118
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  stream_read_uint8(qtmovie->stream);
#line 122
  size_remaining --;
#line 124
  stream_read_uint8(qtmovie->stream);
#line 125
  stream_read_uint8(qtmovie->stream);
#line 126
  stream_read_uint8(qtmovie->stream);
#line 127
  size_remaining -= 3UL;
#line 130
  comptype = stream_read_uint32(qtmovie->stream);
#line 131
  compsubtype = stream_read_uint32(qtmovie->stream);
#line 132
  size_remaining -= 8UL;
#line 135
  stream_read_uint32(qtmovie->stream);
#line 136
  size_remaining -= 4UL;
#line 139
  stream_read_uint32(qtmovie->stream);
#line 140
  stream_read_uint32(qtmovie->stream);
#line 141
  size_remaining -= 8UL;
#line 144
  tmp___0 = stream_read_uint8(qtmovie->stream);
#line 144
  strlen___0 = (int )tmp___0;
#line 145
  stream_read(qtmovie->stream, (size_t )strlen___0, (void *)(str));
#line 146
  size_remaining -= (size_t )(1 + strlen___0);
  }
#line 148
  if (size_remaining) {
    {
#line 150
    stream_skip(qtmovie->stream, size_remaining);
    }
  }
#line 153
  return;
}
}
#line 155 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static int read_chunk_stsd(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  unsigned int i ;
  uint32_t numentries ;
  size_t size_remaining ;
  uint32_t entry_size ;
  uint16_t version ;
  uint32_t entry_remaining ;
  uint16_t tmp ;

  {
  {
#line 159
  size_remaining = chunk_len - 8UL;
#line 162
  stream_read_uint8(qtmovie->stream);
#line 163
  size_remaining --;
#line 165
  stream_read_uint8(qtmovie->stream);
#line 166
  stream_read_uint8(qtmovie->stream);
#line 167
  stream_read_uint8(qtmovie->stream);
#line 168
  size_remaining -= 3UL;
#line 170
  numentries = stream_read_uint32(qtmovie->stream);
#line 171
  size_remaining -= 4UL;
  }
#line 173
  if (numentries != 1U) {
    {
#line 175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"only expecting one entry in sample description atom!\n");
    }
#line 176
    return (0);
  }
#line 179
  i = 0U;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < numentries)) {
#line 179
      goto while_break;
    }
    {
#line 186
    entry_size = stream_read_uint32(qtmovie->stream);
#line 187
    (qtmovie->res)->format = stream_read_uint32(qtmovie->stream);
#line 188
    entry_remaining = entry_size;
#line 189
    entry_remaining -= 8U;
#line 193
    stream_skip(qtmovie->stream, (size_t )6);
#line 194
    entry_remaining -= 6U;
#line 196
    version = stream_read_uint16(qtmovie->stream);
    }
#line 197
    if ((int )version != 1) {
      {
#line 198
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown version??\n");
      }
    }
    {
#line 199
    entry_remaining -= 2U;
#line 202
    stream_read_uint16(qtmovie->stream);
#line 204
    stream_read_uint32(qtmovie->stream);
#line 205
    entry_remaining -= 6U;
#line 208
    stream_read_uint16(qtmovie->stream);
#line 209
    entry_remaining -= 2U;
#line 211
    (qtmovie->res)->num_channels = stream_read_uint16(qtmovie->stream);
#line 213
    (qtmovie->res)->sample_size = stream_read_uint16(qtmovie->stream);
#line 214
    entry_remaining -= 4U;
#line 217
    stream_read_uint16(qtmovie->stream);
#line 219
    stream_read_uint16(qtmovie->stream);
#line 220
    entry_remaining -= 4U;
#line 223
    tmp = stream_read_uint16(qtmovie->stream);
#line 223
    (qtmovie->res)->sample_rate = (uint32_t )tmp;
#line 224
    entry_remaining -= 2U;
#line 227
    stream_skip(qtmovie->stream, (size_t )2);
#line 228
    entry_remaining -= 2U;
#line 250
    (qtmovie->res)->codecdata_len = (entry_remaining + 12U) + 8U;
#line 251
    (qtmovie->res)->codecdata = malloc((size_t )(qtmovie->res)->codecdata_len);
#line 252
    memset((qtmovie->res)->codecdata, 0, (size_t )(qtmovie->res)->codecdata_len);
#line 254
    *((unsigned int *)(qtmovie->res)->codecdata + 0) = 201326592U;
#line 255
    *((unsigned int *)(qtmovie->res)->codecdata + 1) = (unsigned int )((((97 << 24) | (109 << 16)) | (114 << 8)) | 102);
#line 256
    *((unsigned int *)(qtmovie->res)->codecdata + 2) = (unsigned int )((((99 << 24) | (97 << 16)) | (108 << 8)) | 97);
#line 258
    stream_read(qtmovie->stream, (size_t )entry_remaining, (void *)((char *)(qtmovie->res)->codecdata + 12));
#line 261
    entry_remaining -= entry_remaining;
    }
#line 264
    if (entry_remaining) {
      {
#line 265
      stream_skip(qtmovie->stream, (size_t )entry_remaining);
      }
    }
#line 267
    (qtmovie->res)->format_read = 1;
#line 268
    if ((qtmovie->res)->format != (fourcc_t )((((97 << 24) | (108 << 16)) | (97 << 8)) | 99)) {
#line 272
      return (0);
    }
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return (1);
}
}
#line 279 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_stts(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  unsigned int i ;
  uint32_t numentries ;
  size_t size_remaining ;
  void *tmp ;

  {
  {
#line 283
  size_remaining = chunk_len - 8UL;
#line 286
  stream_read_uint8(qtmovie->stream);
#line 287
  size_remaining --;
#line 289
  stream_read_uint8(qtmovie->stream);
#line 290
  stream_read_uint8(qtmovie->stream);
#line 291
  stream_read_uint8(qtmovie->stream);
#line 292
  size_remaining -= 3UL;
#line 294
  numentries = stream_read_uint32(qtmovie->stream);
#line 295
  size_remaining -= 4UL;
#line 297
  (qtmovie->res)->num_time_to_samples = numentries;
#line 298
  tmp = malloc((unsigned long )numentries * sizeof(*((qtmovie->res)->time_to_sample)));
#line 298
  (qtmovie->res)->time_to_sample = (struct __anonstruct_time_to_sample_27 *)tmp;
#line 300
  i = 0U;
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (i < numentries)) {
#line 300
      goto while_break;
    }
    {
#line 302
    ((qtmovie->res)->time_to_sample + i)->sample_count = stream_read_uint32(qtmovie->stream);
#line 303
    ((qtmovie->res)->time_to_sample + i)->sample_duration = stream_read_uint32(qtmovie->stream);
#line 304
    size_remaining -= 8UL;
#line 300
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if (size_remaining) {
    {
#line 309
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ehm, size remianing?\n");
#line 310
    stream_skip(qtmovie->stream, size_remaining);
    }
  }
#line 312
  return;
}
}
#line 314 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_stsz(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  unsigned int i ;
  uint32_t numentries ;
  size_t size_remaining ;
  uint32_t tmp ;
  void *tmp___0 ;

  {
  {
#line 318
  size_remaining = chunk_len - 8UL;
#line 321
  stream_read_uint8(qtmovie->stream);
#line 322
  size_remaining --;
#line 324
  stream_read_uint8(qtmovie->stream);
#line 325
  stream_read_uint8(qtmovie->stream);
#line 326
  stream_read_uint8(qtmovie->stream);
#line 327
  size_remaining -= 3UL;
#line 330
  tmp = stream_read_uint32(qtmovie->stream);
  }
#line 330
  if (tmp != 0U) {
    {
#line 332
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"i was expecting variable samples sizes\n");
#line 333
    stream_read_uint32(qtmovie->stream);
#line 334
    size_remaining -= 4UL;
    }
#line 335
    return;
  }
  {
#line 337
  size_remaining -= 4UL;
#line 339
  numentries = stream_read_uint32(qtmovie->stream);
#line 340
  size_remaining -= 4UL;
#line 342
  (qtmovie->res)->num_sample_byte_sizes = numentries;
#line 343
  tmp___0 = malloc((unsigned long )numentries * sizeof(*((qtmovie->res)->sample_byte_size)));
#line 343
  (qtmovie->res)->sample_byte_size = (uint32_t *)tmp___0;
#line 345
  i = 0U;
  }
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (i < numentries)) {
#line 345
      goto while_break;
    }
    {
#line 347
    *((qtmovie->res)->sample_byte_size + i) = stream_read_uint32(qtmovie->stream);
#line 348
    size_remaining -= 4UL;
#line 345
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  if (size_remaining) {
    {
#line 353
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ehm, size remianing?\n");
#line 354
    stream_skip(qtmovie->stream, size_remaining);
    }
  }
#line 356
  return;
}
}
#line 358 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static int read_chunk_stbl(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  uint32_t tmp ;
  int tmp___0 ;

  {
#line 360
  size_remaining = chunk_len - 8UL;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! size_remaining) {
#line 362
      goto while_break;
    }
    {
#line 367
    tmp = stream_read_uint32(qtmovie->stream);
#line 367
    sub_chunk_len = (size_t )tmp;
    }
#line 368
    if (sub_chunk_len <= 1UL) {
      {
#line 370
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside stbl (%lu) (remaining: %lu)\n",
              sub_chunk_len, size_remaining);
      }
#line 372
      return (0);
    } else
#line 368
    if (sub_chunk_len > size_remaining) {
      {
#line 370
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside stbl (%lu) (remaining: %lu)\n",
              sub_chunk_len, size_remaining);
      }
#line 372
      return (0);
    }
    {
#line 375
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    {
#line 379
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (115 << 8)) | 100)) {
#line 379
      goto case_exp;
    }
#line 383
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (116 << 8)) | 115)) {
#line 383
      goto case_exp___0;
    }
#line 386
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (115 << 8)) | 122)) {
#line 386
      goto case_exp___1;
    }
#line 390
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (99 << 8)) | 111)) {
#line 390
      goto case_exp___2;
    }
#line 390
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (115 << 8)) | 99)) {
#line 390
      goto case_exp___2;
    }
#line 394
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
#line 380
    tmp___0 = read_chunk_stsd(qtmovie, sub_chunk_len);
    }
#line 380
    if (tmp___0 == 0) {
#line 381
      return (0);
    }
#line 382
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 384
    read_chunk_stts(qtmovie, sub_chunk_len);
    }
#line 385
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 387
    read_chunk_stsz(qtmovie, sub_chunk_len);
    }
#line 388
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    case_exp___3: /* CIL Label */ 
    {
#line 392
    stream_skip(qtmovie->stream, sub_chunk_len - 8UL);
    }
#line 393
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 395
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(stbl) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
#line 397
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 400
    size_remaining -= sub_chunk_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (1);
}
}
#line 406 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static int read_chunk_minf(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t dinf_size ;
  size_t stbl_size ;
  size_t size_remaining ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 409
  size_remaining = chunk_len - 8UL;
#line 412
  tmp = stream_read_uint32(qtmovie->stream);
  }
#line 412
  if (tmp != 16U) {
    {
#line 414
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected size in media info\n");
    }
#line 415
    return (0);
  }
  {
#line 417
  tmp___0 = stream_read_uint32(qtmovie->stream);
  }
#line 417
  if (tmp___0 != (uint32_t )((((115 << 24) | (109 << 16)) | (104 << 8)) | 100)) {
    {
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a sound header! can\'t handle this.\n");
    }
#line 420
    return (0);
  }
  {
#line 423
  stream_skip(qtmovie->stream, (size_t )8);
#line 424
  size_remaining -= 16UL;
#line 428
  tmp___1 = stream_read_uint32(qtmovie->stream);
#line 428
  dinf_size = (size_t )tmp___1;
#line 429
  tmp___2 = stream_read_uint32(qtmovie->stream);
  }
#line 429
  if (tmp___2 != (uint32_t )((((100 << 24) | (105 << 16)) | (110 << 8)) | 102)) {
    {
#line 431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected dinf, didn\'t get it.\n");
    }
#line 432
    return (0);
  }
  {
#line 435
  stream_skip(qtmovie->stream, dinf_size - 8UL);
#line 436
  size_remaining -= dinf_size;
#line 441
  tmp___3 = stream_read_uint32(qtmovie->stream);
#line 441
  stbl_size = (size_t )tmp___3;
#line 442
  tmp___4 = stream_read_uint32(qtmovie->stream);
  }
#line 442
  if (tmp___4 != (uint32_t )((((115 << 24) | (116 << 16)) | (98 << 8)) | 108)) {
    {
#line 444
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected stbl, didn\'t get it.\n");
    }
#line 445
    return (0);
  }
  {
#line 447
  tmp___5 = read_chunk_stbl(qtmovie, stbl_size);
  }
#line 447
  if (tmp___5 == 0) {
#line 448
    return (0);
  }
#line 449
  size_remaining -= stbl_size;
#line 451
  if (size_remaining) {
    {
#line 453
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"oops\n");
#line 454
    stream_skip(qtmovie->stream, size_remaining);
    }
  }
#line 457
  return (1);
}
}
#line 460 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static int read_chunk_mdia(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  uint32_t tmp ;
  int tmp___0 ;

  {
#line 462
  size_remaining = chunk_len - 8UL;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! size_remaining) {
#line 464
      goto while_break;
    }
    {
#line 469
    tmp = stream_read_uint32(qtmovie->stream);
#line 469
    sub_chunk_len = (size_t )tmp;
    }
#line 470
    if (sub_chunk_len <= 1UL) {
      {
#line 472
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside mdia\n");
      }
#line 473
      return (0);
    } else
#line 470
    if (sub_chunk_len > size_remaining) {
      {
#line 472
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside mdia\n");
      }
#line 473
      return (0);
    }
    {
#line 476
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    {
#line 480
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (100 << 16)) | (104 << 8)) | 100)) {
#line 480
      goto case_exp;
    }
#line 483
    if (sub_chunk_id == (fourcc_t )((((104 << 24) | (100 << 16)) | (108 << 8)) | 114)) {
#line 483
      goto case_exp___0;
    }
#line 486
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (105 << 16)) | (110 << 8)) | 102)) {
#line 486
      goto case_exp___1;
    }
#line 490
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
#line 481
    read_chunk_mdhd(qtmovie, sub_chunk_len);
    }
#line 482
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 484
    read_chunk_hdlr(qtmovie, sub_chunk_len);
    }
#line 485
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 487
    tmp___0 = read_chunk_minf(qtmovie, sub_chunk_len);
    }
#line 487
    if (tmp___0 == 0) {
#line 488
      return (0);
    }
#line 489
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 491
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(mdia) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
#line 493
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 496
    size_remaining -= sub_chunk_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  return (1);
}
}
#line 503 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static int read_chunk_trak(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  uint32_t tmp ;
  int tmp___0 ;

  {
#line 505
  size_remaining = chunk_len - 8UL;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! size_remaining) {
#line 507
      goto while_break;
    }
    {
#line 512
    tmp = stream_read_uint32(qtmovie->stream);
#line 512
    sub_chunk_len = (size_t )tmp;
    }
#line 513
    if (sub_chunk_len <= 1UL) {
      {
#line 515
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside trak\n");
      }
#line 516
      return (0);
    } else
#line 513
    if (sub_chunk_len > size_remaining) {
      {
#line 515
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside trak\n");
      }
#line 516
      return (0);
    }
    {
#line 519
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    {
#line 523
    if (sub_chunk_id == (fourcc_t )((((116 << 24) | (107 << 16)) | (104 << 8)) | 100)) {
#line 523
      goto case_exp;
    }
#line 526
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (100 << 16)) | (105 << 8)) | 97)) {
#line 526
      goto case_exp___0;
    }
#line 530
    if (sub_chunk_id == (fourcc_t )((((101 << 24) | (100 << 16)) | (116 << 8)) | 115)) {
#line 530
      goto case_exp___1;
    }
#line 533
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
#line 524
    read_chunk_tkhd(qtmovie, sub_chunk_len);
    }
#line 525
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 527
    tmp___0 = read_chunk_mdia(qtmovie, sub_chunk_len);
    }
#line 527
    if (tmp___0 == 0) {
#line 528
      return (0);
    }
#line 529
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 531
    read_chunk_edts(qtmovie, sub_chunk_len);
    }
#line 532
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(trak) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
#line 536
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 539
    size_remaining -= sub_chunk_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (1);
}
}
#line 546 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_mvhd(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 549
  size_remaining = chunk_len - 8UL;
#line 551
  stream_skip(qtmovie->stream, size_remaining);
  }
#line 552
  return;
}
}
#line 555 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_udta(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 558
  size_remaining = chunk_len - 8UL;
#line 560
  stream_skip(qtmovie->stream, size_remaining);
  }
#line 561
  return;
}
}
#line 564 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_iods(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 567
  size_remaining = chunk_len - 8UL;
#line 569
  stream_skip(qtmovie->stream, size_remaining);
  }
#line 570
  return;
}
}
#line 573 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static int read_chunk_moov(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  uint32_t tmp ;
  int tmp___0 ;

  {
#line 575
  size_remaining = chunk_len - 8UL;
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! size_remaining) {
#line 577
      goto while_break;
    }
    {
#line 582
    tmp = stream_read_uint32(qtmovie->stream);
#line 582
    sub_chunk_len = (size_t )tmp;
    }
#line 583
    if (sub_chunk_len <= 1UL) {
      {
#line 585
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside moov\n");
      }
#line 586
      return (0);
    } else
#line 583
    if (sub_chunk_len > size_remaining) {
      {
#line 585
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside moov\n");
      }
#line 586
      return (0);
    }
    {
#line 589
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    {
#line 593
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (118 << 16)) | (104 << 8)) | 100)) {
#line 593
      goto case_exp;
    }
#line 596
    if (sub_chunk_id == (fourcc_t )((((116 << 24) | (114 << 16)) | (97 << 8)) | 107)) {
#line 596
      goto case_exp___0;
    }
#line 600
    if (sub_chunk_id == (fourcc_t )((((117 << 24) | (100 << 16)) | (116 << 8)) | 97)) {
#line 600
      goto case_exp___1;
    }
#line 603
    if (sub_chunk_id == (fourcc_t )((((101 << 24) | (108 << 16)) | (115 << 8)) | 116)) {
#line 603
      goto case_exp___2;
    }
#line 606
    if (sub_chunk_id == (fourcc_t )((((105 << 24) | (111 << 16)) | (100 << 8)) | 115)) {
#line 606
      goto case_exp___3;
    }
#line 609
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
#line 594
    read_chunk_mvhd(qtmovie, sub_chunk_len);
    }
#line 595
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 597
    tmp___0 = read_chunk_trak(qtmovie, sub_chunk_len);
    }
#line 597
    if (tmp___0 == 0) {
#line 598
      return (0);
    }
#line 599
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 601
    read_chunk_udta(qtmovie, sub_chunk_len);
    }
#line 602
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
#line 604
    read_chunk_elst(qtmovie, sub_chunk_len);
    }
#line 605
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    {
#line 607
    read_chunk_iods(qtmovie, sub_chunk_len);
    }
#line 608
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 610
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(moov) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
#line 612
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 615
    size_remaining -= sub_chunk_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  return (1);
}
}
#line 621 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static void read_chunk_mdat(qtmovie_t *qtmovie , size_t chunk_len , int skip_mdat ) 
{ 
  size_t size_remaining ;

  {
#line 623
  size_remaining = chunk_len - 8UL;
#line 625
  if (size_remaining == 0UL) {
#line 625
    return;
  }
#line 627
  (qtmovie->res)->mdat_len = (uint32_t )size_remaining;
#line 628
  if (skip_mdat) {
    {
#line 630
    qtmovie->saved_mdat_pos = stream_tell(qtmovie->stream);
#line 631
    stream_skip(qtmovie->stream, size_remaining);
    }
  }
#line 638
  return;
}
}
#line 640 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
static int set_saved_mdat(qtmovie_t *qtmovie ) 
{ 
  int tmp ;

  {
#line 642
  if (qtmovie->saved_mdat_pos == -1L) {
    {
#line 644
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stream contains mdat before moov but is not seekable\n");
    }
#line 645
    return (0);
  }
  {
#line 648
  tmp = stream_setpos(qtmovie->stream, qtmovie->saved_mdat_pos);
  }
#line 648
  if (tmp) {
    {
#line 650
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error while seeking stream to mdat pos\n");
    }
#line 651
    return (0);
  }
#line 654
  return (1);
}
}
#line 657 "/home/june/collector/temp/alac-decoder-0.2.0/demux.c"
int qtmovie_read(stream_t *file , demux_res_t *demux_res ) 
{ 
  int found_moov ;
  int found_mdat ;
  qtmovie_t *qtmovie ;
  void *tmp ;
  size_t chunk_len ;
  fourcc_t chunk_id ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 659
  found_moov = 0;
#line 660
  found_mdat = 0;
#line 663
  tmp = malloc(sizeof(qtmovie_t ));
#line 663
  qtmovie = (qtmovie_t *)tmp;
#line 666
  qtmovie->stream = file;
#line 668
  qtmovie->res = demux_res;
#line 670
  memset((void *)demux_res, 0, sizeof(demux_res_t ));
  }
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 678
    tmp___0 = stream_read_uint32(qtmovie->stream);
#line 678
    chunk_len = (size_t )tmp___0;
#line 679
    tmp___1 = stream_eof(qtmovie->stream);
    }
#line 679
    if (tmp___1) {
#line 681
      return (0);
    }
#line 684
    if (chunk_len == 1UL) {
      {
#line 686
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"need 64bit support\n");
      }
#line 687
      return (0);
    }
    {
#line 689
    chunk_id = stream_read_uint32(qtmovie->stream);
    }
    {
#line 693
    if (chunk_id == (fourcc_t )((((102 << 24) | (116 << 16)) | (121 << 8)) | 112)) {
#line 693
      goto case_exp;
    }
#line 696
    if (chunk_id == (fourcc_t )((((109 << 24) | (111 << 16)) | (111 << 8)) | 118)) {
#line 696
      goto case_exp___0;
    }
#line 709
    if (chunk_id == (fourcc_t )((((109 << 24) | (100 << 16)) | (97 << 8)) | 116)) {
#line 709
      goto case_exp___1;
    }
#line 717
    if (chunk_id == (fourcc_t )((((102 << 24) | (114 << 16)) | (101 << 8)) | 101)) {
#line 717
      goto case_exp___2;
    }
#line 720
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
#line 694
    read_chunk_ftyp(qtmovie, chunk_len);
    }
#line 695
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 697
    tmp___2 = read_chunk_moov(qtmovie, chunk_len);
    }
#line 697
    if (tmp___2 == 0) {
#line 698
      return (0);
    }
#line 699
    if (found_mdat) {
      {
#line 701
      tmp___3 = set_saved_mdat(qtmovie);
      }
#line 701
      return (tmp___3);
    }
#line 703
    found_moov = 1;
#line 704
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 710
    read_chunk_mdat(qtmovie, chunk_len, ! found_moov);
    }
#line 711
    if (found_moov) {
#line 712
      return (1);
    }
#line 713
    found_mdat = 1;
#line 714
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
#line 718
    stream_skip(qtmovie->stream, chunk_len - 8UL);
    }
#line 719
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 721
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(top) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )chunk_id >> 24)), (int )((char )((int32_t )chunk_id >> 16)),
            (int )((char )((int32_t )chunk_id >> 8)), (int )((char )chunk_id));
    }
#line 723
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (0);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 54 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
struct __anonstruct_se_struct_24_25 se_struct_24  ;
#line 99 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
static void allocate_buffers(alac_file *alac___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 101
  tmp = malloc((size_t )(alac___0->setinfo_max_samples_per_frame * 4U));
#line 101
  alac___0->predicterror_buffer_a = (int32_t *)tmp;
#line 102
  tmp___0 = malloc((size_t )(alac___0->setinfo_max_samples_per_frame * 4U));
#line 102
  alac___0->predicterror_buffer_b = (int32_t *)tmp___0;
#line 104
  tmp___1 = malloc((size_t )(alac___0->setinfo_max_samples_per_frame * 4U));
#line 104
  alac___0->outputsamples_buffer_a = (int32_t *)tmp___1;
#line 105
  tmp___2 = malloc((size_t )(alac___0->setinfo_max_samples_per_frame * 4U));
#line 105
  alac___0->outputsamples_buffer_b = (int32_t *)tmp___2;
#line 107
  tmp___3 = malloc((size_t )(alac___0->setinfo_max_samples_per_frame * 4U));
#line 107
  alac___0->uncompressed_bytes_buffer_a = (int32_t *)tmp___3;
#line 108
  tmp___4 = malloc((size_t )(alac___0->setinfo_max_samples_per_frame * 4U));
#line 108
  alac___0->uncompressed_bytes_buffer_b = (int32_t *)tmp___4;
  }
#line 109
  return;
}
}
#line 111 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
void alac_set_info(alac_file *alac___0 , char *inputbuffer ) 
{ 
  char *ptr ;

  {
#line 113
  ptr = inputbuffer;
#line 114
  ptr += 4;
#line 115
  ptr += 4;
#line 116
  ptr += 4;
#line 117
  ptr += 4;
#line 118
  ptr += 4;
#line 120
  ptr += 4;
#line 122
  alac___0->setinfo_max_samples_per_frame = *((uint32_t *)ptr);
#line 123
  if (! host_bigendian) {
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      alac___0->setinfo_max_samples_per_frame = ((((alac___0->setinfo_max_samples_per_frame & 255U) << 24) | ((alac___0->setinfo_max_samples_per_frame & 65280U) << 8)) | ((alac___0->setinfo_max_samples_per_frame & 16711680U) >> 8)) | ((alac___0->setinfo_max_samples_per_frame & 4278190080U) >> 24);
#line 124
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 125
  ptr += 4;
#line 126
  alac___0->setinfo_7a = *((uint8_t *)ptr);
#line 127
  ptr ++;
#line 128
  alac___0->setinfo_sample_size = *((uint8_t *)ptr);
#line 129
  ptr ++;
#line 130
  alac___0->setinfo_rice_historymult = *((uint8_t *)ptr);
#line 131
  ptr ++;
#line 132
  alac___0->setinfo_rice_initialhistory = *((uint8_t *)ptr);
#line 133
  ptr ++;
#line 134
  alac___0->setinfo_rice_kmodifier = *((uint8_t *)ptr);
#line 135
  ptr ++;
#line 136
  alac___0->setinfo_7f = *((uint8_t *)ptr);
#line 137
  ptr ++;
#line 138
  alac___0->setinfo_80 = *((uint16_t *)ptr);
#line 139
  if (! host_bigendian) {
    {
#line 140
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 140
      alac___0->setinfo_80 = (uint16_t )((((int )alac___0->setinfo_80 & 255) << 8) | (((int )alac___0->setinfo_80 & 65280) >> 8));
#line 140
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 141
  ptr += 2;
#line 142
  alac___0->setinfo_82 = *((uint32_t *)ptr);
#line 143
  if (! host_bigendian) {
    {
#line 144
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 144
      alac___0->setinfo_82 = ((((alac___0->setinfo_82 & 255U) << 24) | ((alac___0->setinfo_82 & 65280U) << 8)) | ((alac___0->setinfo_82 & 16711680U) >> 8)) | ((alac___0->setinfo_82 & 4278190080U) >> 24);
#line 144
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 145
  ptr += 4;
#line 146
  alac___0->setinfo_86 = *((uint32_t *)ptr);
#line 147
  if (! host_bigendian) {
    {
#line 148
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 148
      alac___0->setinfo_86 = ((((alac___0->setinfo_86 & 255U) << 24) | ((alac___0->setinfo_86 & 65280U) << 8)) | ((alac___0->setinfo_86 & 16711680U) >> 8)) | ((alac___0->setinfo_86 & 4278190080U) >> 24);
#line 148
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 149
  ptr += 4;
#line 150
  alac___0->setinfo_8a_rate = *((uint32_t *)ptr);
#line 151
  if (! host_bigendian) {
    {
#line 152
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 152
      alac___0->setinfo_8a_rate = ((((alac___0->setinfo_8a_rate & 255U) << 24) | ((alac___0->setinfo_8a_rate & 65280U) << 8)) | ((alac___0->setinfo_8a_rate & 16711680U) >> 8)) | ((alac___0->setinfo_8a_rate & 4278190080U) >> 24);
#line 152
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 153
  ptr += 4;
#line 155
  allocate_buffers(alac___0);
  }
#line 157
  return;
}
}
#line 162 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
static uint32_t readbits_16(alac_file *alac___0 , int bits ) 
{ 
  uint32_t result ;
  int new_accumulator ;

  {
#line 167
  result = (uint32_t )((((int )*(alac___0->input_buffer + 0) << 16) | ((int )*(alac___0->input_buffer + 1) << 8)) | (int )*(alac___0->input_buffer + 2));
#line 174
  result <<= alac___0->input_buffer_bitaccumulator;
#line 176
  result &= 16777215U;
#line 180
  result >>= 24 - bits;
#line 182
  new_accumulator = alac___0->input_buffer_bitaccumulator + bits;
#line 185
  alac___0->input_buffer += new_accumulator >> 3;
#line 188
  alac___0->input_buffer_bitaccumulator = new_accumulator & 7;
#line 190
  return (result);
}
}
#line 194 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
static uint32_t readbits(alac_file *alac___0 , int bits ) 
{ 
  int32_t result ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 196
  result = 0;
#line 198
  if (bits > 16) {
    {
#line 200
    bits -= 16;
#line 201
    tmp = readbits_16(alac___0, 16);
#line 201
    result = (int32_t )(tmp << bits);
    }
  }
  {
#line 204
  tmp___0 = readbits_16(alac___0, bits);
#line 204
  result = (int32_t )((unsigned int )result | tmp___0);
  }
#line 206
  return ((uint32_t )result);
}
}
#line 210 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
static int readbit(alac_file *alac___0 ) 
{ 
  int result ;
  int new_accumulator ;

  {
#line 215
  result = (int )*(alac___0->input_buffer + 0);
#line 217
  result <<= alac___0->input_buffer_bitaccumulator;
#line 219
  result = (result >> 7) & 1;
#line 221
  new_accumulator = alac___0->input_buffer_bitaccumulator + 1;
#line 223
  alac___0->input_buffer += new_accumulator / 8;
#line 225
  alac___0->input_buffer_bitaccumulator = new_accumulator % 8;
#line 227
  return (result);
}
}
#line 230 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
static void unreadbits(alac_file *alac___0 , int bits ) 
{ 
  int new_accumulator ;

  {
#line 232
  new_accumulator = alac___0->input_buffer_bitaccumulator - bits;
#line 234
  alac___0->input_buffer += new_accumulator >> 3;
#line 236
  alac___0->input_buffer_bitaccumulator = new_accumulator & 7;
#line 237
  if (alac___0->input_buffer_bitaccumulator < 0) {
#line 238
    alac___0->input_buffer_bitaccumulator *= -1;
  }
#line 239
  return;
}
}
#line 292 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
static int count_leading_zeros(int input ) 
{ 
  int output ;
  int curbyte ;

  {
#line 294
  output = 0;
#line 295
  curbyte = 0;
#line 297
  curbyte = input >> 24;
#line 298
  if (curbyte) {
#line 298
    goto found;
  }
#line 299
  output += 8;
#line 301
  curbyte = input >> 16;
#line 302
  if (curbyte & 255) {
#line 302
    goto found;
  }
#line 303
  output += 8;
#line 305
  curbyte = input >> 8;
#line 306
  if (curbyte & 255) {
#line 306
    goto found;
  }
#line 307
  output += 8;
#line 309
  curbyte = input;
#line 310
  if (curbyte & 255) {
#line 310
    goto found;
  }
#line 311
  output += 8;
#line 313
  return (output);
  found: 
#line 316
  if (! (curbyte & 240)) {
#line 318
    output += 4;
  } else {
#line 321
    curbyte >>= 4;
  }
#line 323
  if (curbyte & 8) {
#line 324
    return (output);
  }
#line 325
  if (curbyte & 4) {
#line 326
    return (output + 1);
  }
#line 327
  if (curbyte & 2) {
#line 328
    return (output + 2);
  }
#line 329
  if (curbyte & 1) {
#line 330
    return (output + 3);
  }
#line 333
  return (output + 4);
}
}
#line 339 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
int32_t entropy_decode_value(alac_file *alac___0 , int readSampleSize , int k , int rice_kmodifier_mask ) 
{ 
  int32_t x ;
  int tmp ;
  int32_t value ;
  uint32_t tmp___0 ;
  int extraBits ;
  uint32_t tmp___1 ;

  {
#line 344
  x = 0;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (x <= 8) {
      {
#line 347
      tmp = readbit(alac___0);
      }
#line 347
      if (! tmp) {
#line 347
        goto while_break;
      }
    } else {
#line 347
      goto while_break;
    }
#line 349
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  if (x > 8) {
    {
#line 357
    tmp___0 = readbits(alac___0, readSampleSize);
#line 357
    value = (int32_t )tmp___0;
#line 360
    value = (int32_t )((unsigned int )value & (4294967295U >> (32 - readSampleSize)));
#line 362
    x = value;
    }
  } else
#line 366
  if (k != 1) {
    {
#line 368
    tmp___1 = readbits(alac___0, k);
#line 368
    extraBits = (int )tmp___1;
#line 371
    x *= ((1 << k) - 1) & rice_kmodifier_mask;
    }
#line 373
    if (extraBits > 1) {
#line 374
      x += extraBits - 1;
    } else {
      {
#line 376
      unreadbits(alac___0, 1);
      }
    }
  }
#line 380
  return (x);
}
}
#line 383 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
void entropy_rice_decode(alac_file *alac___0 , int32_t *outputBuffer , int outputSize ,
                         int readSampleSize , int rice_initialhistory , int rice_kmodifier ,
                         int rice_historymult , int rice_kmodifier_mask ) 
{ 
  int outputCount ;
  int history ;
  int signModifier ;
  int32_t decodedValue ;
  int32_t finalValue ;
  int32_t k ;
  int tmp ;
  int32_t blockSize ;
  int tmp___0 ;

  {
#line 393
  history = rice_initialhistory;
#line 394
  signModifier = 0;
#line 396
  outputCount = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (outputCount < outputSize)) {
#line 396
      goto while_break;
    }
    {
#line 402
    tmp = count_leading_zeros((history >> 9) + 3);
#line 402
    k = (31 - rice_kmodifier) - tmp;
    }
#line 404
    if (k < 0) {
#line 404
      k += rice_kmodifier;
    } else {
#line 405
      k = rice_kmodifier;
    }
    {
#line 408
    decodedValue = entropy_decode_value(alac___0, readSampleSize, k, -1);
#line 410
    decodedValue += signModifier;
#line 411
    finalValue = (decodedValue + 1) / 2;
    }
#line 412
    if (decodedValue & 1) {
#line 413
      finalValue *= -1;
    }
#line 415
    *(outputBuffer + outputCount) = finalValue;
#line 417
    signModifier = 0;
#line 420
    history += decodedValue * rice_historymult - (history * rice_historymult >> 9);
#line 423
    if (decodedValue > 65535) {
#line 424
      history = 65535;
    }
#line 427
    if (history < 128) {
#line 427
      if (outputCount + 1 < outputSize) {
        {
#line 431
        signModifier = 1;
#line 433
        tmp___0 = count_leading_zeros(history);
#line 433
        k = (tmp___0 + (history + 16) / 64) - 24;
#line 436
        blockSize = entropy_decode_value(alac___0, 16, k, rice_kmodifier_mask);
        }
#line 439
        if (blockSize > 0) {
          {
#line 441
          memset((void *)(outputBuffer + (outputCount + 1)), 0, (unsigned long )blockSize * sizeof(*outputBuffer));
#line 442
          outputCount += blockSize;
          }
        }
#line 445
        if (blockSize > 65535) {
#line 446
          signModifier = 0;
        }
#line 448
        history = 0;
      }
    }
#line 396
    outputCount ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return;
}
}
#line 460 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
static void predictor_decompress_fir_adapt(int32_t *error_buffer , int32_t *buffer_out ,
                                           int output_size , int readsamplesize ,
                                           int16_t *predictor_coef_table , int predictor_coef_num ,
                                           int predictor_quantitization ) 
{ 
  int i ;
  int32_t prev_value ;
  int32_t error_value ;
  int i___0 ;
  int32_t val ;
  int j ;
  int sum ;
  int outval ;
  int error_val ;
  int predictor_num ;
  int val___0 ;
  int sign ;
  int tmp ;
  int tmp___0 ;
  int predictor_num___0 ;
  int val___1 ;
  int sign___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 471
  *buffer_out = *error_buffer;
#line 473
  if (! predictor_coef_num) {
#line 475
    if (output_size <= 1) {
#line 475
      return;
    }
    {
#line 476
    memcpy((void */* __restrict  */)(buffer_out + 1), (void const   */* __restrict  */)(error_buffer + 1),
           (size_t )((output_size - 1) * 4));
    }
#line 477
    return;
  }
#line 480
  if (predictor_coef_num == 31) {
#line 484
    if (output_size <= 1) {
#line 484
      return;
    }
#line 485
    i = 0;
    {
#line 485
    while (1) {
      while_continue: /* CIL Label */ ;
#line 485
      if (! (i < output_size - 1)) {
#line 485
        goto while_break;
      }
#line 490
      prev_value = *(buffer_out + i);
#line 491
      error_value = *(error_buffer + (i + 1));
#line 492
      *(buffer_out + (i + 1)) = ((prev_value + error_value) << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 485
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 494
    return;
  }
#line 498
  if (predictor_coef_num > 0) {
#line 501
    i___0 = 0;
    {
#line 501
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 501
      if (! (i___0 < predictor_coef_num)) {
#line 501
        goto while_break___0;
      }
#line 505
      val = *(buffer_out + i___0) + *(error_buffer + (i___0 + 1));
#line 507
      val = (val << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 509
      *(buffer_out + (i___0 + 1)) = val;
#line 501
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 532
  if (predictor_coef_num > 0) {
#line 534
    i = predictor_coef_num + 1;
    {
#line 534
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 534
      if (! (i < output_size)) {
#line 534
        goto while_break___1;
      }
#line 539
      sum = 0;
#line 541
      error_val = *(error_buffer + i);
#line 543
      j = 0;
      {
#line 543
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 543
        if (! (j < predictor_coef_num)) {
#line 543
          goto while_break___2;
        }
#line 545
        sum += (*(buffer_out + (predictor_coef_num - j)) - *(buffer_out + 0)) * (int32_t )*(predictor_coef_table + j);
#line 543
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 549
      outval = (1 << (predictor_quantitization - 1)) + sum;
#line 550
      outval >>= predictor_quantitization;
#line 551
      outval = (outval + *(buffer_out + 0)) + error_val;
#line 552
      outval = (outval << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 554
      *(buffer_out + (predictor_coef_num + 1)) = outval;
#line 556
      if (error_val > 0) {
#line 558
        predictor_num = predictor_coef_num - 1;
        {
#line 560
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 560
          if (predictor_num >= 0) {
#line 560
            if (! (error_val > 0)) {
#line 560
              goto while_break___3;
            }
          } else {
#line 560
            goto while_break___3;
          }
#line 562
          val___0 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num));
#line 563
          if (val___0 < 0) {
#line 563
            tmp___0 = -1;
          } else {
#line 563
            if (val___0 > 0) {
#line 563
              tmp = 1;
            } else {
#line 563
              tmp = 0;
            }
#line 563
            tmp___0 = tmp;
          }
#line 563
          sign = tmp___0;
#line 565
          *(predictor_coef_table + predictor_num) = (int16_t )((int )*(predictor_coef_table + predictor_num) - sign);
#line 567
          val___0 *= sign;
#line 569
          error_val -= (val___0 >> predictor_quantitization) * (predictor_coef_num - predictor_num);
#line 572
          predictor_num --;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 575
      if (error_val < 0) {
#line 577
        predictor_num___0 = predictor_coef_num - 1;
        {
#line 579
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 579
          if (predictor_num___0 >= 0) {
#line 579
            if (! (error_val < 0)) {
#line 579
              goto while_break___4;
            }
          } else {
#line 579
            goto while_break___4;
          }
#line 581
          val___1 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num___0));
#line 582
          if (val___1 < 0) {
#line 582
            tmp___2 = -1;
          } else {
#line 582
            if (val___1 > 0) {
#line 582
              tmp___1 = 1;
            } else {
#line 582
              tmp___1 = 0;
            }
#line 582
            tmp___2 = tmp___1;
          }
#line 582
          sign___0 = - tmp___2;
#line 584
          *(predictor_coef_table + predictor_num___0) = (int16_t )((int )*(predictor_coef_table + predictor_num___0) - sign___0);
#line 586
          val___1 *= sign___0;
#line 588
          error_val -= (val___1 >> predictor_quantitization) * (predictor_coef_num - predictor_num___0);
#line 591
          predictor_num___0 --;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 595
      buffer_out ++;
#line 534
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 598
  return;
}
}
#line 600 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
void deinterlace_16(int32_t *buffer_a , int32_t *buffer_b , int16_t *buffer_out ,
                    int numchannels , int numsamples , uint8_t interlacing_shift ,
                    uint8_t interlacing_leftweight ) 
{ 
  int i ;
  int32_t difference ;
  int32_t midright ;
  int16_t left ;
  int16_t right ;
  int16_t left___0 ;
  int16_t right___0 ;

  {
#line 607
  if (numsamples <= 0) {
#line 607
    return;
  }
#line 610
  if (interlacing_leftweight) {
#line 612
    i = 0;
    {
#line 612
    while (1) {
      while_continue: /* CIL Label */ ;
#line 612
      if (! (i < numsamples)) {
#line 612
        goto while_break;
      }
#line 618
      midright = *(buffer_a + i);
#line 619
      difference = *(buffer_b + i);
#line 622
      right = (int16_t )(midright - (difference * (int32_t )interlacing_leftweight >> (int )interlacing_shift));
#line 623
      left = (int16_t )((int )right + difference);
#line 626
      if (host_bigendian) {
        {
#line 628
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 628
          left = (int16_t )((((int )left & 255) << 8) | (((int )left & 65280) >> 8));
#line 628
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 629
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 629
          right = (int16_t )((((int )right & 255) << 8) | (((int )right & 65280) >> 8));
#line 629
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 632
      *(buffer_out + i * numchannels) = left;
#line 633
      *(buffer_out + (i * numchannels + 1)) = right;
#line 612
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 636
    return;
  }
#line 640
  i = 0;
  {
#line 640
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 640
    if (! (i < numsamples)) {
#line 640
      goto while_break___2;
    }
#line 644
    left___0 = (int16_t )*(buffer_a + i);
#line 645
    right___0 = (int16_t )*(buffer_b + i);
#line 648
    if (host_bigendian) {
      {
#line 650
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 650
        left___0 = (int16_t )((((int )left___0 & 255) << 8) | (((int )left___0 & 65280) >> 8));
#line 650
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 651
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 651
        right___0 = (int16_t )((((int )right___0 & 255) << 8) | (((int )right___0 & 65280) >> 8));
#line 651
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 654
    *(buffer_out + i * numchannels) = left___0;
#line 655
    *(buffer_out + (i * numchannels + 1)) = right___0;
#line 640
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 657
  return;
}
}
#line 659 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
void deinterlace_24(int32_t *buffer_a , int32_t *buffer_b , int uncompressed_bytes ,
                    int32_t *uncompressed_bytes_buffer_a , int32_t *uncompressed_bytes_buffer_b ,
                    void *buffer_out , int numchannels , int numsamples , uint8_t interlacing_shift ,
                    uint8_t interlacing_leftweight ) 
{ 
  int i ;
  int32_t difference ;
  int32_t midright ;
  int32_t left ;
  int32_t right ;
  uint32_t mask ;
  int32_t left___0 ;
  int32_t right___0 ;
  uint32_t mask___0 ;

  {
#line 668
  if (numsamples <= 0) {
#line 668
    return;
  }
#line 671
  if (interlacing_leftweight) {
#line 673
    i = 0;
    {
#line 673
    while (1) {
      while_continue: /* CIL Label */ ;
#line 673
      if (! (i < numsamples)) {
#line 673
        goto while_break;
      }
#line 679
      midright = *(buffer_a + i);
#line 680
      difference = *(buffer_b + i);
#line 682
      right = midright - (difference * (int32_t )interlacing_leftweight >> (int )interlacing_shift);
#line 683
      left = right + difference;
#line 685
      if (uncompressed_bytes) {
#line 687
        mask = ~ (4294967295U << uncompressed_bytes * 8);
#line 688
        left <<= uncompressed_bytes * 8;
#line 689
        right <<= uncompressed_bytes * 8;
#line 691
        left = (int32_t )((unsigned int )left | ((unsigned int )*(uncompressed_bytes_buffer_a + i) & mask));
#line 692
        right = (int32_t )((unsigned int )right | ((unsigned int )*(uncompressed_bytes_buffer_b + i) & mask));
      }
#line 695
      *((uint8_t *)buffer_out + (i * numchannels) * 3) = (uint8_t )(left & 255);
#line 696
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 1)) = (uint8_t )((left >> 8) & 255);
#line 697
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 2)) = (uint8_t )((left >> 16) & 255);
#line 699
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 3)) = (uint8_t )(right & 255);
#line 700
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 4)) = (uint8_t )((right >> 8) & 255);
#line 701
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 5)) = (uint8_t )((right >> 16) & 255);
#line 673
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 704
    return;
  }
#line 708
  i = 0;
  {
#line 708
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 708
    if (! (i < numsamples)) {
#line 708
      goto while_break___0;
    }
#line 712
    left___0 = *(buffer_a + i);
#line 713
    right___0 = *(buffer_b + i);
#line 715
    if (uncompressed_bytes) {
#line 717
      mask___0 = ~ (4294967295U << uncompressed_bytes * 8);
#line 718
      left___0 <<= uncompressed_bytes * 8;
#line 719
      right___0 <<= uncompressed_bytes * 8;
#line 721
      left___0 = (int32_t )((unsigned int )left___0 | ((unsigned int )*(uncompressed_bytes_buffer_a + i) & mask___0));
#line 722
      right___0 = (int32_t )((unsigned int )right___0 | ((unsigned int )*(uncompressed_bytes_buffer_b + i) & mask___0));
    }
#line 725
    *((uint8_t *)buffer_out + (i * numchannels) * 3) = (uint8_t )(left___0 & 255);
#line 726
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 1)) = (uint8_t )((left___0 >> 8) & 255);
#line 727
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 2)) = (uint8_t )((left___0 >> 16) & 255);
#line 729
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 3)) = (uint8_t )(right___0 & 255);
#line 730
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 4)) = (uint8_t )((right___0 >> 8) & 255);
#line 731
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 5)) = (uint8_t )((right___0 >> 16) & 255);
#line 708
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 735
  return;
}
}
#line 737 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
void decode_frame(alac_file *alac___0 , unsigned char *inbuffer , void *outbuffer ,
                  int *outputsize ) 
{ 
  int channels ;
  int32_t outputsamples ;
  uint32_t tmp ;
  int hassize ;
  int isnotcompressed ;
  int readsamplesize ;
  int uncompressed_bytes ;
  int ricemodifier ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int16_t predictor_coef_table[32] ;
  int predictor_coef_num ;
  int prediction_type ;
  int prediction_quantitization ;
  int i ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  int i___0 ;
  uint32_t tmp___9 ;
  int i___1 ;
  int32_t audiobits ;
  uint32_t tmp___10 ;
  int i___2 ;
  int32_t audiobits___0 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  int i___3 ;
  int16_t sample ;
  int i___4 ;
  int32_t sample___0 ;
  uint32_t mask ;
  int hassize___0 ;
  int isnotcompressed___0 ;
  int readsamplesize___0 ;
  int uncompressed_bytes___0 ;
  uint8_t interlacing_shift ;
  uint8_t interlacing_leftweight ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  int16_t predictor_coef_table_a[32] ;
  int predictor_coef_num_a ;
  int prediction_type_a ;
  int prediction_quantitization_a ;
  int ricemodifier_a ;
  int16_t predictor_coef_table_b[32] ;
  int predictor_coef_num_b ;
  int prediction_type_b ;
  int prediction_quantitization_b ;
  int ricemodifier_b ;
  int i___5 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  int i___6 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  int i___7 ;
  int32_t audiobits_a ;
  int32_t audiobits_b ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  int i___8 ;
  int32_t audiobits_a___0 ;
  int32_t audiobits_b___0 ;
  uint32_t tmp___33 ;
  uint32_t tmp___34 ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;

  {
  {
#line 742
  outputsamples = (int32_t )alac___0->setinfo_max_samples_per_frame;
#line 745
  alac___0->input_buffer = inbuffer;
#line 746
  alac___0->input_buffer_bitaccumulator = 0;
#line 748
  tmp = readbits(alac___0, 3);
#line 748
  channels = (int )tmp;
#line 750
  *outputsize = outputsamples * alac___0->bytespersample;
  }
  {
#line 754
  if (channels == 0) {
#line 754
    goto case_0;
  }
#line 929
  if (channels == 1) {
#line 929
    goto case_1;
  }
#line 752
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 766
  readbits(alac___0, 4);
#line 768
  readbits(alac___0, 12);
#line 770
  tmp___0 = readbits(alac___0, 1);
#line 770
  hassize = (int )tmp___0;
#line 772
  tmp___1 = readbits(alac___0, 2);
#line 772
  uncompressed_bytes = (int )tmp___1;
#line 774
  tmp___2 = readbits(alac___0, 1);
#line 774
  isnotcompressed = (int )tmp___2;
  }
#line 776
  if (hassize) {
    {
#line 780
    tmp___3 = readbits(alac___0, 32);
#line 780
    outputsamples = (int32_t )tmp___3;
#line 781
    *outputsize = outputsamples * alac___0->bytespersample;
    }
  }
#line 784
  readsamplesize = (int )alac___0->setinfo_sample_size - uncompressed_bytes * 8;
#line 786
  if (! isnotcompressed) {
    {
#line 796
    readbits(alac___0, 8);
#line 797
    readbits(alac___0, 8);
#line 799
    tmp___4 = readbits(alac___0, 4);
#line 799
    prediction_type = (int )tmp___4;
#line 800
    tmp___5 = readbits(alac___0, 4);
#line 800
    prediction_quantitization = (int )tmp___5;
#line 802
    tmp___6 = readbits(alac___0, 3);
#line 802
    ricemodifier = (int )tmp___6;
#line 803
    tmp___7 = readbits(alac___0, 5);
#line 803
    predictor_coef_num = (int )tmp___7;
#line 806
    i = 0;
    }
    {
#line 806
    while (1) {
      while_continue: /* CIL Label */ ;
#line 806
      if (! (i < predictor_coef_num)) {
#line 806
        goto while_break;
      }
      {
#line 808
      tmp___8 = readbits(alac___0, 16);
#line 808
      predictor_coef_table[i] = (int16_t )tmp___8;
#line 806
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 811
    if (uncompressed_bytes) {
#line 814
      i___0 = 0;
      {
#line 814
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 814
        if (! (i___0 < outputsamples)) {
#line 814
          goto while_break___0;
        }
        {
#line 816
        tmp___9 = readbits(alac___0, uncompressed_bytes * 8);
#line 816
        *(alac___0->uncompressed_bytes_buffer_a + i___0) = (int32_t )tmp___9;
#line 814
        i___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 820
    entropy_rice_decode(alac___0, alac___0->predicterror_buffer_a, outputsamples,
                        readsamplesize, (int )alac___0->setinfo_rice_initialhistory,
                        (int )alac___0->setinfo_rice_kmodifier, (ricemodifier * (int )alac___0->setinfo_rice_historymult) / 4,
                        (1 << (int )alac___0->setinfo_rice_kmodifier) - 1);
    }
#line 829
    if (prediction_type == 0) {
      {
#line 831
      predictor_decompress_fir_adapt(alac___0->predicterror_buffer_a, alac___0->outputsamples_buffer_a,
                                     outputsamples, readsamplesize, predictor_coef_table,
                                     predictor_coef_num, prediction_quantitization);
      }
    } else {
      {
#line 841
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unhandled predicition type: %i\n",
              prediction_type);
      }
    }
  } else {
#line 853
    if ((int )alac___0->setinfo_sample_size <= 16) {
#line 856
      i___1 = 0;
      {
#line 856
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 856
        if (! (i___1 < outputsamples)) {
#line 856
          goto while_break___1;
        }
        {
#line 858
        tmp___10 = readbits(alac___0, (int )alac___0->setinfo_sample_size);
#line 858
        audiobits = (int32_t )tmp___10;
#line 860
        audiobits = (audiobits << (32 - (int )alac___0->setinfo_sample_size)) >> (32 - (int )alac___0->setinfo_sample_size);
#line 862
        *(alac___0->outputsamples_buffer_a + i___1) = audiobits;
#line 856
        i___1 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 868
      i___2 = 0;
      {
#line 868
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 868
        if (! (i___2 < outputsamples)) {
#line 868
          goto while_break___2;
        }
        {
#line 872
        tmp___11 = readbits(alac___0, 16);
#line 872
        audiobits___0 = (int32_t )tmp___11;
#line 875
        audiobits___0 <<= (int )alac___0->setinfo_sample_size - 16;
#line 876
        tmp___12 = readbits(alac___0, (int )alac___0->setinfo_sample_size - 16);
#line 876
        audiobits___0 = (int32_t )((unsigned int )audiobits___0 | tmp___12);
#line 877
        se_struct_24.x = audiobits___0;
#line 877
        audiobits___0 = se_struct_24.x;
#line 879
        *(alac___0->outputsamples_buffer_a + i___2) = audiobits___0;
#line 868
        i___2 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 882
    uncompressed_bytes = 0;
  }
  {
#line 887
  if ((int )alac___0->setinfo_sample_size == 16) {
#line 887
    goto case_16;
  }
#line 899
  if ((int )alac___0->setinfo_sample_size == 24) {
#line 899
    goto case_24;
  }
#line 921
  if ((int )alac___0->setinfo_sample_size == 32) {
#line 921
    goto case_32;
  }
#line 921
  if ((int )alac___0->setinfo_sample_size == 20) {
#line 921
    goto case_32;
  }
#line 924
  goto switch_default;
  case_16: /* CIL Label */ 
#line 890
  i___3 = 0;
  {
#line 890
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 890
    if (! (i___3 < outputsamples)) {
#line 890
      goto while_break___3;
    }
#line 892
    sample = (int16_t )*(alac___0->outputsamples_buffer_a + i___3);
#line 893
    if (host_bigendian) {
      {
#line 894
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 894
        sample = (int16_t )((((int )sample & 255) << 8) | (((int )sample & 65280) >> 8));
#line 894
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 895
    *((int16_t *)outbuffer + i___3 * alac___0->numchannels) = sample;
#line 890
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 897
  goto switch_break___0;
  case_24: /* CIL Label */ 
#line 902
  i___4 = 0;
  {
#line 902
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 902
    if (! (i___4 < outputsamples)) {
#line 902
      goto while_break___5;
    }
#line 904
    sample___0 = *(alac___0->outputsamples_buffer_a + i___4);
#line 906
    if (uncompressed_bytes) {
#line 909
      sample___0 <<= uncompressed_bytes * 8;
#line 910
      mask = ~ (4294967295U << uncompressed_bytes * 8);
#line 911
      sample___0 = (int32_t )((unsigned int )sample___0 | ((unsigned int )*(alac___0->uncompressed_bytes_buffer_a + i___4) & mask));
    }
#line 914
    *((uint8_t *)outbuffer + (i___4 * alac___0->numchannels) * 3) = (uint8_t )(sample___0 & 255);
#line 915
    *((uint8_t *)outbuffer + ((i___4 * alac___0->numchannels) * 3 + 1)) = (uint8_t )((sample___0 >> 8) & 255);
#line 916
    *((uint8_t *)outbuffer + ((i___4 * alac___0->numchannels) * 3 + 2)) = (uint8_t )((sample___0 >> 16) & 255);
#line 902
    i___4 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 918
  goto switch_break___0;
  case_32: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
#line 922
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unimplemented sample size %i\n",
          (int )alac___0->setinfo_sample_size);
  }
#line 923
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 925
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 927
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 943
  readbits(alac___0, 4);
#line 945
  readbits(alac___0, 12);
#line 947
  tmp___13 = readbits(alac___0, 1);
#line 947
  hassize___0 = (int )tmp___13;
#line 949
  tmp___14 = readbits(alac___0, 2);
#line 949
  uncompressed_bytes___0 = (int )tmp___14;
#line 951
  tmp___15 = readbits(alac___0, 1);
#line 951
  isnotcompressed___0 = (int )tmp___15;
  }
#line 953
  if (hassize___0) {
    {
#line 957
    tmp___16 = readbits(alac___0, 32);
#line 957
    outputsamples = (int32_t )tmp___16;
#line 958
    *outputsize = outputsamples * alac___0->bytespersample;
    }
  }
#line 961
  readsamplesize___0 = ((int )alac___0->setinfo_sample_size - uncompressed_bytes___0 * 8) + 1;
#line 963
  if (! isnotcompressed___0) {
    {
#line 979
    tmp___17 = readbits(alac___0, 8);
#line 979
    interlacing_shift = (uint8_t )tmp___17;
#line 980
    tmp___18 = readbits(alac___0, 8);
#line 980
    interlacing_leftweight = (uint8_t )tmp___18;
#line 983
    tmp___19 = readbits(alac___0, 4);
#line 983
    prediction_type_a = (int )tmp___19;
#line 984
    tmp___20 = readbits(alac___0, 4);
#line 984
    prediction_quantitization_a = (int )tmp___20;
#line 986
    tmp___21 = readbits(alac___0, 3);
#line 986
    ricemodifier_a = (int )tmp___21;
#line 987
    tmp___22 = readbits(alac___0, 5);
#line 987
    predictor_coef_num_a = (int )tmp___22;
#line 990
    i___5 = 0;
    }
    {
#line 990
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 990
      if (! (i___5 < predictor_coef_num_a)) {
#line 990
        goto while_break___6;
      }
      {
#line 992
      tmp___23 = readbits(alac___0, 16);
#line 992
      predictor_coef_table_a[i___5] = (int16_t )tmp___23;
#line 990
      i___5 ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 996
    tmp___24 = readbits(alac___0, 4);
#line 996
    prediction_type_b = (int )tmp___24;
#line 997
    tmp___25 = readbits(alac___0, 4);
#line 997
    prediction_quantitization_b = (int )tmp___25;
#line 999
    tmp___26 = readbits(alac___0, 3);
#line 999
    ricemodifier_b = (int )tmp___26;
#line 1000
    tmp___27 = readbits(alac___0, 5);
#line 1000
    predictor_coef_num_b = (int )tmp___27;
#line 1003
    i___5 = 0;
    }
    {
#line 1003
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1003
      if (! (i___5 < predictor_coef_num_b)) {
#line 1003
        goto while_break___7;
      }
      {
#line 1005
      tmp___28 = readbits(alac___0, 16);
#line 1005
      predictor_coef_table_b[i___5] = (int16_t )tmp___28;
#line 1003
      i___5 ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1009
    if (uncompressed_bytes___0) {
#line 1012
      i___6 = 0;
      {
#line 1012
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1012
        if (! (i___6 < outputsamples)) {
#line 1012
          goto while_break___8;
        }
        {
#line 1014
        tmp___29 = readbits(alac___0, uncompressed_bytes___0 * 8);
#line 1014
        *(alac___0->uncompressed_bytes_buffer_a + i___6) = (int32_t )tmp___29;
#line 1015
        tmp___30 = readbits(alac___0, uncompressed_bytes___0 * 8);
#line 1015
        *(alac___0->uncompressed_bytes_buffer_b + i___6) = (int32_t )tmp___30;
#line 1012
        i___6 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    }
    {
#line 1020
    entropy_rice_decode(alac___0, alac___0->predicterror_buffer_a, outputsamples,
                        readsamplesize___0, (int )alac___0->setinfo_rice_initialhistory,
                        (int )alac___0->setinfo_rice_kmodifier, (ricemodifier_a * (int )alac___0->setinfo_rice_historymult) / 4,
                        (1 << (int )alac___0->setinfo_rice_kmodifier) - 1);
    }
#line 1029
    if (prediction_type_a == 0) {
      {
#line 1031
      predictor_decompress_fir_adapt(alac___0->predicterror_buffer_a, alac___0->outputsamples_buffer_a,
                                     outputsamples, readsamplesize___0, predictor_coef_table_a,
                                     predictor_coef_num_a, prediction_quantitization_a);
      }
    } else {
      {
#line 1041
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unhandled predicition type: %i\n",
              prediction_type_a);
      }
    }
    {
#line 1045
    entropy_rice_decode(alac___0, alac___0->predicterror_buffer_b, outputsamples,
                        readsamplesize___0, (int )alac___0->setinfo_rice_initialhistory,
                        (int )alac___0->setinfo_rice_kmodifier, (ricemodifier_b * (int )alac___0->setinfo_rice_historymult) / 4,
                        (1 << (int )alac___0->setinfo_rice_kmodifier) - 1);
    }
#line 1054
    if (prediction_type_b == 0) {
      {
#line 1056
      predictor_decompress_fir_adapt(alac___0->predicterror_buffer_b, alac___0->outputsamples_buffer_b,
                                     outputsamples, readsamplesize___0, predictor_coef_table_b,
                                     predictor_coef_num_b, prediction_quantitization_b);
      }
    } else {
      {
#line 1066
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unhandled predicition type: %i\n",
              prediction_type_b);
      }
    }
  } else {
#line 1071
    if ((int )alac___0->setinfo_sample_size <= 16) {
#line 1074
      i___7 = 0;
      {
#line 1074
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1074
        if (! (i___7 < outputsamples)) {
#line 1074
          goto while_break___9;
        }
        {
#line 1078
        tmp___31 = readbits(alac___0, (int )alac___0->setinfo_sample_size);
#line 1078
        audiobits_a = (int32_t )tmp___31;
#line 1079
        tmp___32 = readbits(alac___0, (int )alac___0->setinfo_sample_size);
#line 1079
        audiobits_b = (int32_t )tmp___32;
#line 1081
        audiobits_a = (audiobits_a << (32 - (int )alac___0->setinfo_sample_size)) >> (32 - (int )alac___0->setinfo_sample_size);
#line 1082
        audiobits_b = (audiobits_b << (32 - (int )alac___0->setinfo_sample_size)) >> (32 - (int )alac___0->setinfo_sample_size);
#line 1084
        *(alac___0->outputsamples_buffer_a + i___7) = audiobits_a;
#line 1085
        *(alac___0->outputsamples_buffer_b + i___7) = audiobits_b;
#line 1074
        i___7 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
    } else {
#line 1091
      i___8 = 0;
      {
#line 1091
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1091
        if (! (i___8 < outputsamples)) {
#line 1091
          goto while_break___10;
        }
        {
#line 1095
        tmp___33 = readbits(alac___0, 16);
#line 1095
        audiobits_a___0 = (int32_t )tmp___33;
#line 1096
        audiobits_a___0 <<= (int )alac___0->setinfo_sample_size - 16;
#line 1097
        tmp___34 = readbits(alac___0, (int )alac___0->setinfo_sample_size - 16);
#line 1097
        audiobits_a___0 = (int32_t )((unsigned int )audiobits_a___0 | tmp___34);
#line 1098
        se_struct_24.x = audiobits_a___0;
#line 1098
        audiobits_a___0 = se_struct_24.x;
#line 1100
        tmp___35 = readbits(alac___0, 16);
#line 1100
        audiobits_b___0 = (int32_t )tmp___35;
#line 1101
        audiobits_b___0 <<= (int )alac___0->setinfo_sample_size - 16;
#line 1102
        tmp___36 = readbits(alac___0, (int )alac___0->setinfo_sample_size - 16);
#line 1102
        audiobits_b___0 = (int32_t )((unsigned int )audiobits_b___0 | tmp___36);
#line 1103
        se_struct_24.x = audiobits_b___0;
#line 1103
        audiobits_b___0 = se_struct_24.x;
#line 1105
        *(alac___0->outputsamples_buffer_a + i___8) = audiobits_a___0;
#line 1106
        *(alac___0->outputsamples_buffer_b + i___8) = audiobits_b___0;
#line 1091
        i___8 ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 1109
    uncompressed_bytes___0 = 0;
#line 1110
    interlacing_shift = (uint8_t )0;
#line 1111
    interlacing_leftweight = (uint8_t )0;
  }
  {
#line 1116
  if ((int )alac___0->setinfo_sample_size == 16) {
#line 1116
    goto case_16___0;
  }
#line 1127
  if ((int )alac___0->setinfo_sample_size == 24) {
#line 1127
    goto case_24___0;
  }
#line 1142
  if ((int )alac___0->setinfo_sample_size == 32) {
#line 1142
    goto case_32___0;
  }
#line 1142
  if ((int )alac___0->setinfo_sample_size == 20) {
#line 1142
    goto case_32___0;
  }
#line 1145
  goto switch_default___0;
  case_16___0: /* CIL Label */ 
  {
#line 1118
  deinterlace_16(alac___0->outputsamples_buffer_a, alac___0->outputsamples_buffer_b,
                 (int16_t *)outbuffer, alac___0->numchannels, outputsamples, interlacing_shift,
                 interlacing_leftweight);
  }
#line 1125
  goto switch_break___1;
  case_24___0: /* CIL Label */ 
  {
#line 1129
  deinterlace_24(alac___0->outputsamples_buffer_a, alac___0->outputsamples_buffer_b,
                 uncompressed_bytes___0, alac___0->uncompressed_bytes_buffer_a, alac___0->uncompressed_bytes_buffer_b,
                 (void *)((int16_t *)outbuffer), alac___0->numchannels, outputsamples,
                 interlacing_shift, interlacing_leftweight);
  }
#line 1139
  goto switch_break___1;
  case_32___0: /* CIL Label */ 
  case_20___0: /* CIL Label */ 
  {
#line 1143
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unimplemented sample size %i\n",
          (int )alac___0->setinfo_sample_size);
  }
#line 1144
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 1146
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1149
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1152
  return;
}
}
#line 1154 "/home/june/collector/temp/alac-decoder-0.2.0/alac.c"
alac_file *create_alac(int samplesize , int numchannels ) 
{ 
  alac_file *newfile ;
  void *tmp ;

  {
  {
#line 1156
  tmp = malloc(sizeof(alac_file ));
#line 1156
  newfile = (alac_file *)tmp;
#line 1158
  newfile->samplesize = samplesize;
#line 1159
  newfile->numchannels = numchannels;
#line 1160
  newfile->bytespersample = (samplesize / 8) * numchannels;
  }
#line 1162
  return (newfile);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 16 "/home/june/collector/temp/alac-decoder-0.2.0/stream.h"
int32_t stream_read_int32(stream_t *stream ) ;
#line 19
int16_t stream_read_int16(stream_t *stream ) ;
#line 22
int8_t stream_read_int8(stream_t *stream ) ;
#line 62 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
void stream_read(stream_t *stream , size_t size , void *buf ) 
{ 
  size_t ret ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 66
  tmp = fread((void */* __restrict  */)buf, (size_t )4, size >> 2, (FILE */* __restrict  */)stream->f);
#line 66
  ret = tmp * 4UL;
#line 67
  tmp___0 = fread((void */* __restrict  */)((char *)buf + ret), (size_t )1, size - ret,
                  (FILE */* __restrict  */)stream->f);
#line 67
  ret += tmp___0;
  }
#line 69
  if (ret == 0UL) {
#line 69
    if (size != 0UL) {
#line 69
      stream->eof = 1;
    }
  }
#line 70
  return;
}
}
#line 72 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
int32_t stream_read_int32(stream_t *stream ) 
{ 
  int32_t v ;

  {
  {
#line 75
  stream_read(stream, (size_t )4, (void *)(& v));
  }
#line 76
  if (stream->bigendian) {
#line 76
    if (! host_bigendian) {
#line 76
      goto _L;
    } else {
#line 76
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 76
  if (! stream->bigendian) {
#line 76
    if (host_bigendian) {
      _L: /* CIL Label */ 
      {
#line 79
      while (1) {
        while_continue: /* CIL Label */ ;
#line 79
        v = (int32_t )((unsigned int )((((v & 255) << 24) | ((v & 65280) << 8)) | ((v & 16711680) >> 8)) | (((unsigned int )v & 4278190080U) >> 24));
#line 79
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 81
  return (v);
}
}
#line 84 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
uint32_t stream_read_uint32(stream_t *stream ) 
{ 
  uint32_t v ;

  {
  {
#line 87
  stream_read(stream, (size_t )4, (void *)(& v));
  }
#line 88
  if (stream->bigendian) {
#line 88
    if (! host_bigendian) {
#line 88
      goto _L;
    } else {
#line 88
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 88
  if (! stream->bigendian) {
#line 88
    if (host_bigendian) {
      _L: /* CIL Label */ 
      {
#line 91
      while (1) {
        while_continue: /* CIL Label */ ;
#line 91
        v = ((((v & 255U) << 24) | ((v & 65280U) << 8)) | ((v & 16711680U) >> 8)) | ((v & 4278190080U) >> 24);
#line 91
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 93
  return (v);
}
}
#line 96 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
int16_t stream_read_int16(stream_t *stream ) 
{ 
  int16_t v ;

  {
  {
#line 99
  stream_read(stream, (size_t )2, (void *)(& v));
  }
#line 100
  if (stream->bigendian) {
#line 100
    if (! host_bigendian) {
#line 100
      goto _L;
    } else {
#line 100
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 100
  if (! stream->bigendian) {
#line 100
    if (host_bigendian) {
      _L: /* CIL Label */ 
      {
#line 103
      while (1) {
        while_continue: /* CIL Label */ ;
#line 103
        v = (int16_t )((((int )v & 255) << 8) | (((int )v & 65280) >> 8));
#line 103
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 105
  return (v);
}
}
#line 108 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
uint16_t stream_read_uint16(stream_t *stream ) 
{ 
  uint16_t v ;

  {
  {
#line 111
  stream_read(stream, (size_t )2, (void *)(& v));
  }
#line 112
  if (stream->bigendian) {
#line 112
    if (! host_bigendian) {
#line 112
      goto _L;
    } else {
#line 112
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 112
  if (! stream->bigendian) {
#line 112
    if (host_bigendian) {
      _L: /* CIL Label */ 
      {
#line 115
      while (1) {
        while_continue: /* CIL Label */ ;
#line 115
        v = (uint16_t )((((int )v & 255) << 8) | (((int )v & 65280) >> 8));
#line 115
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 117
  return (v);
}
}
#line 120 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
int8_t stream_read_int8(stream_t *stream ) 
{ 
  int8_t v ;

  {
  {
#line 123
  stream_read(stream, (size_t )1, (void *)(& v));
  }
#line 124
  return (v);
}
}
#line 127 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
uint8_t stream_read_uint8(stream_t *stream ) 
{ 
  uint8_t v ;

  {
  {
#line 130
  stream_read(stream, (size_t )1, (void *)(& v));
  }
#line 131
  return (v);
}
}
#line 135 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
void stream_skip(stream_t *stream , size_t skip ) 
{ 
  int tmp ;
  char *buffer ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 137
  tmp = fseek(stream->f, (long )skip, 1);
  }
#line 137
  if (tmp == 0) {
#line 137
    return;
  }
  {
#line 138
  tmp___1 = __errno_location();
  }
#line 138
  if (*tmp___1 == 29) {
    {
#line 140
    tmp___0 = malloc(skip);
#line 140
    buffer = (char *)tmp___0;
#line 141
    stream_read(stream, skip, (void *)buffer);
#line 142
    free((void *)buffer);
    }
  }
#line 144
  return;
}
}
#line 146 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
int stream_eof(stream_t *stream ) 
{ 


  {
#line 148
  return (stream->eof);
}
}
#line 151 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
long stream_tell(stream_t *stream ) 
{ 
  long tmp ;

  {
  {
#line 153
  tmp = ftell(stream->f);
  }
#line 153
  return (tmp);
}
}
#line 156 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
int stream_setpos(stream_t *stream , long pos ) 
{ 
  int tmp ;

  {
  {
#line 158
  tmp = fseek(stream->f, pos, 0);
  }
#line 158
  return (tmp);
}
}
#line 161 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
stream_t *stream_create_file(FILE *file , int bigendian ) 
{ 
  stream_t *new_stream ;
  void *tmp ;

  {
  {
#line 166
  tmp = malloc(sizeof(stream_t ));
#line 166
  new_stream = (stream_t *)tmp;
#line 167
  new_stream->f = file;
#line 168
  new_stream->bigendian = bigendian;
#line 169
  new_stream->eof = 0;
  }
#line 171
  return (new_stream);
}
}
#line 174 "/home/june/collector/temp/alac-decoder-0.2.0/stream.c"
void stream_destroy(stream_t *stream ) 
{ 


  {
  {
#line 176
  free((void *)stream);
  }
#line 177
  return;
}
}
