/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 43 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef unsigned char uchar;
#line 45 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _hash_node_t {
   unsigned int ecode ;
   unsigned int pos ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _hash_node_t hash_node_t;
#line 45 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _hash_node_t *hash_node_p_t;
#line 50 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _hash_env_t {
   void **hashtab ;
   uchar *seq ;
   unsigned int len ;
   int *next_pos ;
   unsigned int mask ;
   unsigned int W ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _hash_env_t hash_env_t;
#line 50 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _hash_env_t *hash_env_p_t;
#line 59 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _read_buf_t {
   char *line ;
   unsigned int lmax ;
   unsigned int lc ;
   unsigned int ic ;
   char in[4096] ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _read_buf_t read_buf_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _seq_t {
   char const   *fName ;
   char *header ;
   unsigned char *seq ;
   read_buf_t rb ;
   int fd ;
   unsigned int len ;
   unsigned int maxHead ;
   unsigned int max ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _seq_t *seq_p_t;
#line 78 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _exon_t {
   unsigned int from1 ;
   unsigned int from2 ;
   unsigned int to1 ;
   unsigned int to2 ;
   unsigned int score ;
   unsigned int Score ;
   int prev ;
   int direction ;
   unsigned int splScore ;
   unsigned int top : 1 ;
   unsigned int bot : 1 ;
   int type : 30 ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _exon_t exon_t;
#line 78 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _exon_t *exon_p_t;
#line 90 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _sim4_stats {
   unsigned int nmatches ;
   int polyA_cut ;
   int polyT_cut ;
};
#line 90 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _sim4_stats sim4_stats_t;
#line 90 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _sim4_stats *sim4_stats_p_t;
#line 97 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _edit_script {
   struct _edit_script *next ;
   int num ;
   char op_type ;
};
#line 97 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _edit_script edit_script_t;
#line 97 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _edit_script *edit_script_p_t;
#line 103 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _edit_script_list {
   struct _edit_script_list *next_script ;
   edit_script_p_t script ;
   unsigned int offset1 ;
   unsigned int offset2 ;
   unsigned int len1 ;
   unsigned int len2 ;
   int score ;
};
#line 103 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _edit_script_list edit_script_list_t;
#line 103 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _edit_script_list *edit_script_list_p_t;
#line 111
struct _result_t;
#line 111 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
union _collec_elt_t {
   void **elt ;
   exon_p_t *exon ;
   struct _result_t **result ;
};
#line 111 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef union _collec_elt_t collec_elt_t;
#line 117 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _collec_t {
   collec_elt_t e ;
   unsigned int nb ;
   unsigned int size ;
};
#line 117 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _collec_t collec_t;
#line 117 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _collec_t *collec_p_t;
#line 123 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _result_t {
   edit_script_list_p_t sList ;
   collec_t eCol ;
   unsigned int dStart ;
   unsigned int dLen ;
   int direction ;
   int chimera ;
   sim4_stats_t st ;
};
#line 123 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _result_t result_t;
#line 123 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _result_t *result_p_t;
#line 133 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _junction_t {
   uchar fwd[4] ;
   uchar rev[4] ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _junction_t *junction_p_t;
#line 138 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _splice_score_t {
   unsigned int to1 ;
   unsigned int to2 ;
   unsigned int nFrom1 ;
   int type ;
   unsigned int score ;
   unsigned int splScore ;
   int direction ;
};
#line 138 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _splice_score_t splice_score_t;
#line 138 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _splice_score_t *splice_score_p_t;
#line 148 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
struct _options_t {
   unsigned char *splice_type_list ;
   junction_p_t splice ;
   unsigned int nbSplice ;
   int ali_flag ;
   unsigned int C ;
   int cutoff ;
   unsigned int gapPct ;
   unsigned int intron_window ;
   unsigned int K ;
   unsigned int scoreSplice_window ;
   int mismatchScore ;
   unsigned int reverse ;
   int matchScore ;
   unsigned int W ;
   unsigned int X ;
   unsigned int dnaOffset ;
   unsigned int filterPct ;
   unsigned int minScore_cutoff ;
   unsigned int splitScorePct ;
   unsigned int huntChimera ;
   unsigned int spliceInDel ;
};
#line 148 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _options_t options_t;
#line 112 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
struct __anonstruct_best_31 {
   int score ;
   unsigned int cnt ;
   unsigned int d ;
};
#line 925 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
struct __anonstruct_best_32 {
   unsigned int elt ;
   unsigned int score ;
};
#line 965 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
struct __anonstruct_best_33 {
   unsigned int elt ;
   unsigned int score ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 59 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _read_buf_t *read_buf_p_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _seq_t seq_t;
#line 133 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
typedef struct _junction_t junction_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/misc.h"
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *fmt 
                                                                     , ...) ;
#line 22
void *xmalloc(size_t size ) ;
#line 23
void *xcalloc(size_t nmemb , size_t size ) ;
#line 24
void *xrealloc(void *ptr , size_t size ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/misc.c"
char *argv0 ;
#line 22
char dna_seq_head[256] ;
#line 23
char rna_seq_head[256] ;
#line 18
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *fmt 
                                                                     , ...) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/misc.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 25
  __builtin_va_start(ap, fmt);
#line 26
  fflush(stdout);
  }
#line 27
  if (argv0) {
    {
#line 28
    tmp = strrchr((char const   *)argv0, '/');
#line 28
    p = tmp;
    }
#line 29
    if (p) {
#line 29
      tmp___0 = p + 1;
    } else {
#line 29
      tmp___0 = argv0;
    }
    {
#line 29
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            tmp___0);
    }
  }
  {
#line 31
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 32
  __builtin_va_end(ap);
#line 33
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n while processing:\n%.256s\n%.256s\n",
          dna_seq_head, rna_seq_head);
#line 38
  exit(1);
  }
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/misc.c"
void *xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 45
  tmp = malloc(size);
#line 45
  res = tmp;
  }
#line 46
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___0 = __errno_location();
#line 47
    tmp___1 = __errno_location();
#line 47
    tmp___2 = strerror(*tmp___1);
#line 47
    fatal("malloc of %zd failed: %s (%d)\n", size, tmp___2, *tmp___0);
    }
  }
#line 49
  return (res);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/misc.c"
void *xcalloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  tmp = calloc(nmemb, size);
#line 55
  res = tmp;
  }
#line 56
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 57
    tmp___0 = __errno_location();
#line 57
    tmp___1 = __errno_location();
#line 57
    tmp___2 = strerror(*tmp___1);
#line 57
    fatal("calloc of %zd, %zd failed: %s (%d)\n", nmemb, size, tmp___2, *tmp___0);
    }
  }
#line 59
  return (res);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/misc.c"
void *xrealloc(void *ptr , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 65
  tmp = realloc(ptr, size);
#line 65
  res = tmp;
  }
#line 66
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 67
    tmp___0 = __errno_location();
#line 67
    tmp___1 = __errno_location();
#line 67
    tmp___2 = strerror(*tmp___1);
#line 67
    fatal("realloc of %p to %zd failed: %s (%d)\n", ptr, size, tmp___2, *tmp___0);
    }
  }
#line 69
  return (res);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 129 "/usr/include/search.h"
extern void *tsearch(void const   *__key , void **__rootp , int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 134
extern void *tfind(void const   *__key , void * const  *__rootp , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
#line 158
extern void tdestroy(void *__root , void (*__freefct)(void *__nodep ) ) ;
#line 171 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
options_t options ;
#line 12 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.h"
void free_align(edit_script_list_p_t aligns ) ;
#line 13
void print_exons(collec_p_t eCol , int direction ) ;
#line 14
void SIM4(hash_env_p_t he , seq_p_t seq2 , collec_p_t res ) ;
#line 15
void init_encoding(void) ;
#line 16
void init_hash_env(hash_env_p_t he , unsigned int W , uchar *seq , unsigned int len ) ;
#line 17
void free_hash_env(hash_env_p_t he ) ;
#line 18
void bld_table(hash_env_p_t he ) ;
#line 19
void init_col(collec_p_t c , unsigned int size ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.h"
void align_path(uchar *seq1 , uchar *seq2 , int i1 , int j1 , int i2 , int j2 , int dist ,
                edit_script_p_t *head , edit_script_p_t *tail , int M , int N ) ;
#line 12
int align_get_dist(uchar *seq1 , uchar *seq2 , int i1 , int j1 , int i2 , int j2 ,
                   int limit ) ;
#line 13
void Condense_both_Ends(edit_script_p_t *head , edit_script_p_t *tail , edit_script_p_t *prev ) ;
#line 18
void Free_script(edit_script_p_t head ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static unsigned int encoding[128]  ;
#line 25
static void merge(collec_p_t eCol , collec_p_t aCol , unsigned int pos , unsigned int W ) ;
#line 26
static void slide_intron(result_p_t r , uchar *seq1 , uchar *seq2 ) ;
#line 27
static void compact_exons(collec_p_t eCol , unsigned int W ) ;
#line 28
static unsigned int greedy(uchar *s1 , uchar *s2 , unsigned int m , unsigned int n ,
                           unsigned int offset1 , unsigned int offset2 , unsigned int W ,
                           collec_p_t eCol ) ;
#line 30
static int extend_bw(uchar *s1 , uchar *s2 , int m , int n , int offset1 , int offset2 ,
                     int *line1 , int *line2 , unsigned int W ) ;
#line 32
static int extend_fw(uchar *s1 , uchar *s2 , int m , int n , int offset1 , int offset2 ,
                     int *line1 , int *line2 , unsigned int W ) ;
#line 34
static int pluri_align(uchar *seq1 , uchar *seq2 , unsigned int *num_matches , collec_p_t eCol ,
                       edit_script_list_p_t *Aligns , unsigned int M , unsigned int N ) ;
#line 36
static exon_p_t new_exon(unsigned int f1 , unsigned int f2 , unsigned int t1 , unsigned int t2 ) ;
#line 38
static void extend_hit(int pos1 , int pos2 , hash_env_p_t he , uchar const   * const  s2 ,
                       unsigned int len2 , unsigned int K , collec_p_t mCol , int *diag_lev ) ;
#line 40
static int msp_compare(void const   *a , void const   *b ) ;
#line 41
static int chimera_compare(void const   *a , void const   *b ) ;
#line 42
static int msp_rna_compare(void const   *a , void const   *b ) ;
#line 43
static void search(hash_env_p_t he , uchar *s2 , unsigned int len2 , unsigned int K ,
                   collec_p_t mCol ) ;
#line 45
static void trim_small_repeated_msps(collec_p_t mCol ) ;
#line 46
static void combine_msps(collec_p_t mCol ) ;
#line 47
static int link_msps(collec_p_t mCol , unsigned int start , unsigned int stop ) ;
#line 48
static int link_chimera(collec_p_t mCol , unsigned int start , unsigned int stop ) ;
#line 49
static void msp2exons(exon_p_t *msp , int last_msp , collec_p_t eCol , int swapped ,
                      int copy ) ;
#line 50
static void exon_cores(hash_env_p_t he , uchar *s2 , unsigned int len2 , unsigned int offset1 ,
                       unsigned int offset2 , unsigned int K , collec_p_t mCol , collec_p_t res ,
                       collec_p_t eCol ) ;
#line 52
static int good_ratio(int l , unsigned int W ) ;
#line 53
static void swap_seqs(collec_p_t eCol ) ;
#line 54
static unsigned int SWscore(uchar *s1 , uchar *s2 , unsigned int len ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int is_polyAT_exon_p(exon_p_t e , unsigned char const   *s ) 
{ 
  unsigned int cntA ;
  unsigned int cntC ;
  unsigned int cntG ;
  unsigned int cntT ;
  unsigned int cntN ;
  unsigned int i ;
  unsigned int len ;

  {
#line 64
  cntA = 0U;
#line 65
  cntC = 0U;
#line 66
  cntG = 0U;
#line 67
  cntT = 0U;
#line 68
  cntN = 0U;
#line 70
  len = (e->to2 - e->from2) + 1U;
#line 71
  i = e->from2 - 1U;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < e->to2)) {
#line 71
      goto while_break;
    }
    {
#line 73
    if ((int const   )*(s + i) == 65) {
#line 73
      goto case_65;
    }
#line 76
    if ((int const   )*(s + i) == 67) {
#line 76
      goto case_67;
    }
#line 79
    if ((int const   )*(s + i) == 71) {
#line 79
      goto case_71;
    }
#line 82
    if ((int const   )*(s + i) == 84) {
#line 82
      goto case_84;
    }
#line 85
    goto switch_default;
    case_65: /* CIL Label */ 
#line 74
    cntA ++;
#line 75
    goto switch_break;
    case_67: /* CIL Label */ 
#line 77
    cntC ++;
#line 78
    goto switch_break;
    case_71: /* CIL Label */ 
#line 80
    cntG ++;
#line 81
    goto switch_break;
    case_84: /* CIL Label */ 
#line 83
    cntT ++;
#line 84
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 86
    cntN ++;
    switch_break: /* CIL Label */ ;
    }
#line 71
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  len -= cntN;
#line 89
  if (len < 30U) {
#line 90
    if ((cntA * 10U) / len >= 7U) {
#line 94
      return (1);
    } else
#line 90
    if (((cntA + cntG) * 10U) / len >= 8U) {
#line 94
      return (1);
    } else
#line 90
    if ((cntT * 10U) / len >= 7U) {
#line 94
      return (1);
    } else
#line 90
    if (((cntT + cntC) * 10U) / len >= 8U) {
#line 94
      return (1);
    }
  } else
#line 96
  if ((cntA * 10U) / len >= 8U) {
#line 100
    return (1);
  } else
#line 96
  if (((cntA + cntG) * 100U) / len >= 95U) {
#line 100
    return (1);
  } else
#line 96
  if ((cntT * 10U) / len >= 8U) {
#line 100
    return (1);
  } else
#line 96
  if (((cntT + cntC) * 100U) / len >= 95U) {
#line 100
    return (1);
  }
#line 102
  return (0);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void kill_polyA(result_p_t res , unsigned char const   *s1 , unsigned char const   *s2 ) 
{ 
  unsigned int i ;
  collec_p_t eCol ;
  struct __anonstruct_best_31 best ;
  int tmp ;
  unsigned int j ;
  int tmp___0 ;
  unsigned int j___0 ;
  exon_p_t e ;
  unsigned int cntAs1 ;
  unsigned int cntAs2 ;
  unsigned int j___1 ;
  int score ;
  unsigned char const   *s ;
  exon_p_t e___0 ;
  unsigned int cntTs1 ;
  unsigned int cntTs2 ;
  unsigned int j___2 ;
  int score___0 ;
  unsigned char const   *s___0 ;

  {
#line 109
  eCol = & res->eCol;
#line 112
  best = best;
#line 113
  i = 0U;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (i < eCol->nb) {
      {
#line 114
      tmp = is_polyAT_exon_p(*(eCol->e.exon + i), s2);
      }
#line 114
      if (! tmp) {
#line 114
        goto while_break;
      }
    } else {
#line 114
      goto while_break;
    }
#line 115
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if (i > 0U) {
#line 118
    j = 0U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (! (j < i)) {
#line 118
        goto while_break___0;
      }
      {
#line 119
      free((void *)*(eCol->e.exon + j));
#line 118
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 120
    memmove((void *)eCol->e.elt, (void const   *)(eCol->e.elt + i), (unsigned long )(eCol->nb - i) * sizeof(void *));
#line 122
    eCol->nb -= i;
    }
  }
#line 124
  i = 0U;
  {
#line 125
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 125
    if (i < eCol->nb) {
      {
#line 125
      tmp___0 = is_polyAT_exon_p(*(eCol->e.exon + ((eCol->nb - i) - 1U)), s2);
      }
#line 125
      if (! tmp___0) {
#line 125
        goto while_break___1;
      }
    } else {
#line 125
      goto while_break___1;
    }
#line 127
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 128
  if (i > 0U) {
#line 130
    j___0 = eCol->nb - i;
    {
#line 130
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 130
      if (! (j___0 < eCol->nb)) {
#line 130
        goto while_break___2;
      }
      {
#line 131
      free((void *)*(eCol->e.exon + j___0));
#line 130
      j___0 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 132
    eCol->nb -= i;
  }
#line 134
  if (eCol->nb > 0U) {
#line 135
    e = *(eCol->e.exon + (eCol->nb - 1U));
#line 136
    cntAs1 = 0U;
#line 136
    cntAs2 = 0U;
#line 136
    j___1 = 0U;
#line 137
    score = 0;
#line 138
    s = s2 + e->to2;
#line 139
    best.score = 0;
    {
#line 140
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 140
      if (*s) {
#line 140
        if (! (best.score - score < 10)) {
#line 140
          goto while_break___3;
        }
      } else {
#line 140
        goto while_break___3;
      }
#line 141
      j___1 ++;
      {
#line 143
      if ((int const   )*s == 65) {
#line 143
        goto case_65;
      }
#line 152
      if ((int const   )*s == 78) {
#line 152
        goto case_78;
      }
#line 154
      goto switch_default;
      case_65: /* CIL Label */ 
#line 144
      cntAs2 ++;
#line 145
      score ++;
#line 146
      if (score > best.score) {
#line 147
        best.score = score;
#line 148
        best.cnt = cntAs2;
#line 149
        best.d = j___1;
      }
#line 151
      goto switch_break;
      case_78: /* CIL Label */ 
#line 153
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 155
      score -= 2;
      switch_break: /* CIL Label */ ;
      }
#line 157
      s ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 159
    if (best.score > 0) {
#line 159
      if (best.cnt >= 8U) {
#line 159
        if ((best.cnt * 10U) / best.d >= 8U) {
#line 160
          s = s1 + e->to1;
#line 161
          j___1 = 0U;
          {
#line 162
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 162
            if (*s) {
#line 162
              if (! (j___1 < best.d)) {
#line 162
                goto while_break___4;
              }
            } else {
#line 162
              goto while_break___4;
            }
#line 163
            j___1 ++;
#line 164
            if ((int const   )*s == 65) {
#line 165
              cntAs1 ++;
            }
#line 166
            s ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 168
          if (j___1 > 0U) {
#line 168
            if ((cntAs1 * 10U) / j___1 < 8U) {
#line 169
              res->st.polyA_cut = 1;
            }
          }
        }
      }
    }
  }
#line 173
  if (eCol->nb > 0U) {
#line 174
    e___0 = *(eCol->e.exon + 0);
#line 175
    cntTs1 = 0U;
#line 175
    cntTs2 = 0U;
#line 175
    j___2 = 0U;
#line 176
    score___0 = 0;
#line 177
    s___0 = (s2 + e___0->from2) - 2;
#line 178
    best.score = 0;
    {
#line 179
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 179
      if ((unsigned long )s___0 >= (unsigned long )s2) {
#line 179
        if (! (best.score - score___0 < 10)) {
#line 179
          goto while_break___5;
        }
      } else {
#line 179
        goto while_break___5;
      }
#line 180
      j___2 ++;
      {
#line 182
      if ((int const   )*s___0 == 84) {
#line 182
        goto case_84;
      }
#line 191
      if ((int const   )*s___0 == 78) {
#line 191
        goto case_78___0;
      }
#line 193
      goto switch_default___0;
      case_84: /* CIL Label */ 
#line 183
      cntTs2 ++;
#line 184
      score___0 ++;
#line 185
      if (score___0 > best.score) {
#line 186
        best.score = score___0;
#line 187
        best.cnt = cntTs2;
#line 188
        best.d = j___2;
      }
#line 190
      goto switch_break___0;
      case_78___0: /* CIL Label */ 
#line 192
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 194
      score___0 -= 2;
      switch_break___0: /* CIL Label */ ;
      }
#line 196
      s___0 --;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 198
    if (best.score > 0) {
#line 198
      if (best.cnt >= 8U) {
#line 198
        if ((best.cnt * 10U) / best.d >= 8U) {
#line 199
          s___0 = (s1 + e___0->from1) - 2;
#line 200
          j___2 = 0U;
          {
#line 201
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 201
            if ((unsigned long )s___0 >= (unsigned long )s1) {
#line 201
              if (! (j___2 < best.d)) {
#line 201
                goto while_break___6;
              }
            } else {
#line 201
              goto while_break___6;
            }
#line 202
            j___2 ++;
#line 203
            if ((int const   )*s___0 == 84) {
#line 204
              cntTs1 ++;
            }
#line 205
            s___0 --;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 207
          if (j___2 > 0U) {
#line 207
            if ((cntTs1 * 10U) / j___2 < 8U) {
#line 208
              res->st.polyT_cut = 1;
            }
          }
        }
      }
    }
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void grow_exon_left(exon_p_t e , uchar *s1 , uchar *s2 ) 
{ 
  uchar *p1 ;
  uchar *p2 ;

  {
#line 217
  p1 = (s1 + e->from1) - 2;
#line 218
  p2 = (s2 + e->from2) - 2;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if ((unsigned long )p1 >= (unsigned long )s1) {
#line 219
      if ((unsigned long )p2 >= (unsigned long )s2) {
#line 219
        if (! ((int )*p1 == (int )*p2)) {
#line 219
          goto while_break;
        }
      } else {
#line 219
        goto while_break;
      }
    } else {
#line 219
      goto while_break;
    }
#line 220
    p1 --;
#line 221
    p2 --;
#line 222
    (e->from1) --;
#line 223
    (e->from2) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void grow_exon_right(exon_p_t e , uchar *s1 , unsigned int l1 , uchar *s2 ,
                            unsigned int l2 ) 
{ 


  {
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (e->to1 < l1) {
#line 231
      if (e->to2 < l2) {
#line 231
        if (! ((int )*(s1 + e->to1) == (int )*(s2 + e->to2))) {
#line 231
          goto while_break;
        }
      } else {
#line 231
        goto while_break;
      }
    } else {
#line 231
      goto while_break;
    }
#line 232
    (e->to1) ++;
#line 233
    (e->to2) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
void SIM4(hash_env_p_t he , seq_p_t seq2 , collec_p_t res ) 
{ 
  collec_t mCol ;
  collec_t tem_eCol ;
  int align_status ;
  unsigned int curRes ;
  result_p_t r ;
  collec_p_t eCol ;
  sim4_stats_p_t st ;
  exon_p_t e ;
  unsigned int i ;
  hash_env_t tem_he ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int j ;
  int diff ;
  unsigned int tmp___1 ;
  int u ;
  int tmp___2 ;
  int I ;
  int J ;
  int cost ;
  exon_p_t e___0 ;
  unsigned int i___0 ;
  hash_env_t tem_he___0 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned int j___0 ;
  int diff___0 ;
  unsigned int tmp___5 ;
  int cost___0 ;
  int I___0 ;
  int J___0 ;
  int tmp___6 ;
  unsigned int i___1 ;
  exon_p_t cur ;
  exon_p_t next ;
  int diff___1 ;
  hash_env_t tem_he___1 ;
  unsigned int cost___1 ;
  double tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int i___2 ;
  exon_p_t e___1 ;
  int i___3 ;
  exon_p_t e___2 ;

  {
#line 246
  if (he->len == 0U) {
#line 247
    return;
  } else
#line 246
  if (seq2->len == 0U) {
#line 247
    return;
  }
  {
#line 248
  init_col(& mCol, 5U);
#line 250
  exon_cores(he, seq2->seq, seq2->len, 1U, 1U, options.K, & mCol, res, (collec_p_t )((void *)0));
#line 251
  init_col(& tem_eCol, 0U);
#line 252
  curRes = 0U;
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (curRes < res->nb)) {
#line 252
      goto while_break;
    }
    {
#line 253
    r = *(res->e.result + curRes);
#line 254
    eCol = & r->eCol;
#line 255
    st = & r->st;
#line 262
    st->polyA_cut = 0;
#line 263
    st->polyT_cut = 0;
#line 264
    kill_polyA(r, (unsigned char const   *)he->seq, (unsigned char const   *)seq2->seq);
    }
#line 268
    if (eCol->nb == 0U) {
#line 269
      goto __Cont;
    }
#line 271
    if (! st->polyT_cut) {
#line 271
      if ((*(eCol->e.exon + 0))->from2 > 1U) {
#line 272
        e = *(eCol->e.exon + 0);
#line 273
        i = 0U;
#line 274
        if (e->from2 - 1U > (unsigned int )(30 << 1)) {
#line 274
          if (e->from1 - 1U > r->dStart) {
#line 280
            if (10U > he->W) {
#line 280
              tmp = he->W;
            } else {
#line 280
              tmp = 10U;
            }
            {
#line 280
            init_hash_env(& tem_he, tmp, seq2->seq, e->from2 - 1U);
#line 281
            bld_table(& tem_he);
#line 282
            exon_cores(& tem_he, he->seq + r->dStart, (e->from1 - r->dStart) - 1U,
                       1U, r->dStart + 1U, options.C, & mCol, (collec_p_t )((void *)0),
                       & tem_eCol);
#line 284
            free_hash_env(& tem_he);
            }
#line 286
            if (tem_eCol.nb > 0U) {
              {
#line 287
              swap_seqs(& tem_eCol);
#line 288
              grow_exon_right(*(tem_eCol.e.exon + (tem_eCol.nb - 1U)), he->seq, he->len,
                              seq2->seq, seq2->len);
#line 290
              merge(eCol, & tem_eCol, 0U, he->W);
#line 291
              tem_eCol.nb = 0U;
#line 292
              e = *(eCol->e.exon + 0);
              }
            }
          }
        }
        {
#line 295
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 295
          if (i < eCol->nb) {
            {
#line 295
            tmp___0 = is_polyAT_exon_p(*(eCol->e.exon + i), (unsigned char const   *)seq2->seq);
            }
#line 295
            if (! tmp___0) {
#line 295
              goto while_break___0;
            }
          } else {
#line 295
            goto while_break___0;
          }
#line 296
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 297
        if (i > 0U) {
#line 299
          j = 0U;
          {
#line 299
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 299
            if (! (j < i)) {
#line 299
              goto while_break___1;
            }
            {
#line 300
            free((void *)*(eCol->e.exon + j));
#line 299
            j ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 301
          memmove((void *)eCol->e.elt, (void const   *)(eCol->e.elt + i), (unsigned long )(eCol->nb - i) * sizeof(void *));
#line 303
          eCol->nb -= i;
          }
#line 304
          if (eCol->nb == 0U) {
#line 305
            goto __Cont;
          }
#line 306
          e = *(eCol->e.exon + 0);
        }
#line 308
        if (e->from2 - 1U > 0U) {
#line 309
          if (e->from2 - 1U > (unsigned int )(500 >> 1)) {
#line 309
            tmp___1 = (unsigned int )(500 >> 1);
          } else {
#line 309
            tmp___1 = e->from2 - 1U;
          }
#line 309
          diff = (int )tmp___1;
#line 310
          if (4 * diff > (int )e->from1 - 1) {
#line 310
            tmp___2 = (int )e->from1 - 1;
          } else {
#line 310
            tmp___2 = 4 * diff;
          }
          {
#line 310
          u = tmp___2;
#line 315
          cost = extend_bw(((seq2->seq + e->from2) - 1) - diff, ((he->seq + e->from1) - 1) - u,
                           diff, u, ((int )e->from2 - 1) - diff, ((int )e->from1 - 1) - u,
                           & I, & J, he->W);
          }
#line 322
          if ((((int )e->from2 - 1) - I) * options.matchScore + cost * options.mismatchScore >= 0) {
#line 324
            e->from2 = (unsigned int )I + 1U;
#line 325
            e->from1 = (unsigned int )J + 1U;
          }
        }
      }
    }
#line 330
    if (! st->polyA_cut) {
#line 330
      if ((*(eCol->e.exon + (eCol->nb - 1U)))->to2 < seq2->len) {
#line 331
        e___0 = *(eCol->e.exon + (eCol->nb - 1U));
#line 332
        i___0 = 0U;
#line 333
        if (seq2->len - e___0->to2 > (unsigned int )(30 << 1)) {
#line 333
          if (e___0->to1 < r->dStart + r->dLen) {
#line 339
            if (10U > he->W) {
#line 339
              tmp___3 = he->W;
            } else {
#line 339
              tmp___3 = 10U;
            }
            {
#line 339
            init_hash_env(& tem_he___0, tmp___3, seq2->seq + e___0->to2, seq2->len - e___0->to2);
#line 341
            bld_table(& tem_he___0);
#line 342
            exon_cores(& tem_he___0, he->seq + e___0->to1, (r->dStart + r->dLen) - e___0->to1,
                       e___0->to2 + 1U, e___0->to1 + 1U, options.C, & mCol, (collec_p_t )((void *)0),
                       & tem_eCol);
#line 344
            free_hash_env(& tem_he___0);
            }
#line 346
            if (tem_eCol.nb > 0U) {
              {
#line 347
              swap_seqs(& tem_eCol);
#line 348
              grow_exon_left(*(tem_eCol.e.exon + 0), he->seq, seq2->seq);
#line 349
              merge(eCol, & tem_eCol, eCol->nb, he->W);
#line 350
              tem_eCol.nb = 0U;
#line 351
              e___0 = *(eCol->e.exon + (eCol->nb - 1U));
              }
            }
          }
        }
        {
#line 354
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 354
          if (i___0 < eCol->nb) {
            {
#line 354
            tmp___4 = is_polyAT_exon_p(*(eCol->e.exon + ((eCol->nb - i___0) - 1U)),
                                       (unsigned char const   *)seq2->seq);
            }
#line 354
            if (! tmp___4) {
#line 354
              goto while_break___2;
            }
          } else {
#line 354
            goto while_break___2;
          }
#line 356
          i___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 357
        if (i___0 > 0U) {
#line 359
          j___0 = eCol->nb - i___0;
          {
#line 359
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 359
            if (! (j___0 < eCol->nb)) {
#line 359
              goto while_break___3;
            }
            {
#line 360
            free((void *)*(eCol->e.exon + j___0));
#line 359
            j___0 ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 361
          eCol->nb -= i___0;
#line 362
          if (eCol->nb == 0U) {
#line 363
            goto __Cont;
          }
#line 364
          e___0 = *(eCol->e.exon + (eCol->nb - 1U));
        }
#line 366
        if (seq2->len - e___0->to2 > 0U) {
#line 367
          if (seq2->len - e___0->to2 > (unsigned int )(500 >> 1)) {
#line 367
            tmp___5 = (unsigned int )(500 >> 1);
          } else {
#line 367
            tmp___5 = seq2->len - e___0->to2;
          }
#line 367
          diff___0 = (int )tmp___5;
#line 372
          if (4 * diff___0 > (int )(he->len - e___0->to1)) {
#line 372
            tmp___6 = (int )(he->len - e___0->to1);
          } else {
#line 372
            tmp___6 = 4 * diff___0;
          }
          {
#line 372
          cost___0 = extend_fw(seq2->seq + e___0->to2, he->seq + e___0->to1, diff___0,
                               tmp___6, (int )e___0->to2, (int )e___0->to1, & I___0,
                               & J___0, he->W);
          }
#line 378
          if ((I___0 - (int )e___0->to2) * options.matchScore + cost___0 * options.mismatchScore >= 0) {
#line 380
            e___0->to2 = (unsigned int )I___0;
#line 381
            e___0->to1 = (unsigned int )J___0;
          }
        }
      }
    }
#line 386
    if (eCol->nb > 1U) {
#line 388
      i___1 = 1U;
      {
#line 388
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 388
        if (! (i___1 < eCol->nb)) {
#line 388
          goto while_break___4;
        }
#line 389
        cur = *(eCol->e.exon + (i___1 - 1U));
#line 390
        next = *(eCol->e.exon + i___1);
#line 391
        diff___1 = ((int )next->from2 - (int )cur->to2) - 1;
#line 392
        if (diff___1 > 0) {
#line 394
          if (next->from1 - 1U > cur->to1) {
#line 396
            if (diff___1 <= 500) {
              {
#line 402
              cost___1 = greedy(seq2->seq + cur->to2, he->seq + cur->to1, (unsigned int )diff___1,
                                (next->from1 - cur->to1) - 1U, cur->to2, cur->to1,
                                he->W, & tem_eCol);
              }
#line 406
              if (tem_eCol.nb > 0U) {
#line 406
                if ((double )he->W < .2 * (double )diff___1 + (double )1) {
#line 406
                  tmp___7 = .2 * (double )diff___1 + (double )1;
                } else {
#line 406
                  tmp___7 = (double )he->W;
                }
#line 406
                if ((double )cost___1 <= tmp___7) {
                  {
#line 408
                  grow_exon_left(*(tem_eCol.e.exon + 0), he->seq, seq2->seq);
#line 409
                  grow_exon_right(*(tem_eCol.e.exon + (tem_eCol.nb - 1U)), he->seq,
                                  he->len, seq2->seq, seq2->len);
#line 411
                  merge(eCol, & tem_eCol, i___1, he->W);
#line 412
                  tem_eCol.nb = 0U;
#line 413
                  i___1 --;
                  }
#line 414
                  goto __Cont___0;
                }
              }
            }
#line 421
            if (8U > he->W) {
#line 421
              tmp___8 = he->W;
            } else {
#line 421
              tmp___8 = 8U;
            }
            {
#line 421
            init_hash_env(& tem_he___1, tmp___8, he->seq + cur->to1, (next->from1 - cur->to1) - 1U);
#line 423
            bld_table(& tem_he___1);
#line 424
            exon_cores(& tem_he___1, seq2->seq + cur->to2, (unsigned int )diff___1,
                       cur->to1 + 1U, cur->to2 + 1U, options.C, & mCol, (collec_p_t )((void *)0),
                       & tem_eCol);
#line 427
            free_hash_env(& tem_he___1);
            }
#line 428
            if (tem_eCol.nb > 0U) {
              {
#line 429
              grow_exon_left(*(tem_eCol.e.exon + 0), he->seq, seq2->seq);
#line 430
              grow_exon_right(*(tem_eCol.e.exon + (tem_eCol.nb - 1U)), he->seq, he->len,
                              seq2->seq, seq2->len);
#line 432
              merge(eCol, & tem_eCol, i___1, he->W);
#line 433
              tem_eCol.nb = 0U;
#line 434
              i___1 --;
              }
            }
          }
        }
        __Cont___0: /* CIL Label */ 
#line 388
        i___1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 441
    kill_polyA(r, (unsigned char const   *)he->seq, (unsigned char const   *)seq2->seq);
    }
#line 450
    if (! r->chimera) {
      {
#line 451
      compact_exons(eCol, he->W);
      }
    }
#line 459
    if (eCol->nb > 0U) {
#line 460
      i___2 = 0U;
      {
#line 461
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 461
        if (! (i___2 < eCol->nb)) {
#line 461
          goto while_break___5;
        }
#line 462
        e___1 = *(eCol->e.exon + i___2);
#line 463
        if ((e___1->to2 - e___1->from2) + 1U >= he->W) {
#line 464
          goto while_break___5;
        }
        {
#line 465
        free((void *)e___1);
#line 466
        i___2 ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 468
      if (i___2 > 0U) {
        {
#line 469
        memmove((void *)eCol->e.elt, (void const   *)(eCol->e.elt + i___2), (unsigned long )(eCol->nb - i___2) * sizeof(void *));
#line 471
        eCol->nb -= i___2;
        }
      }
    }
#line 476
    if (eCol->nb > 0U) {
#line 477
      i___3 = (int )eCol->nb - 1;
      {
#line 478
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 478
        if (! (i___3 >= 0)) {
#line 478
          goto while_break___6;
        }
#line 479
        e___2 = *(eCol->e.exon + i___3);
#line 480
        if ((e___2->to2 - e___2->from2) + 1U >= he->W) {
#line 481
          goto while_break___6;
        }
        {
#line 482
        free((void *)e___2);
#line 483
        i___3 --;
#line 484
        (eCol->nb) --;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 489
    slide_intron(r, he->seq, seq2->seq);
#line 492
    align_status = pluri_align(he->seq, seq2->seq, & st->nmatches, eCol, & r->sList,
                               he->len, seq2->len);
    }
#line 494
    if (align_status != 0) {
      {
#line 495
      free_align(r->sList);
#line 496
      r->sList = (edit_script_list_p_t )((void *)0);
      }
    } else
#line 494
    if (! options.ali_flag) {
      {
#line 495
      free_align(r->sList);
#line 496
      r->sList = (edit_script_list_p_t )((void *)0);
      }
    }
    __Cont: /* CIL Label */ 
#line 252
    curRes ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 499
  free((void *)mCol.e.elt);
#line 500
  free((void *)tem_eCol.e.elt);
  }
#line 501
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
void init_col(collec_p_t c , unsigned int size ) 
{ 
  void *tmp ;

  {
#line 506
  c->size = size;
#line 507
  c->nb = 0U;
#line 508
  if (size > 0U) {
    {
#line 509
    tmp = xmalloc((unsigned long )size * sizeof(void *));
#line 509
    c->e.elt = (void **)tmp;
    }
  } else {
#line 511
    c->e.elt = (void **)((void *)0);
  }
#line 512
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void add_col_elt(collec_p_t c , void *elt ) 
{ 
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 517
  if (c->size <= c->nb) {
    {
#line 518
    c->size += 5U;
#line 519
    tmp = xrealloc((void *)c->e.elt, (unsigned long )c->size * sizeof(void *));
#line 519
    c->e.elt = (void **)tmp;
    }
  }
#line 521
  tmp___0 = c->nb;
#line 521
  (c->nb) ++;
#line 521
  *(c->e.elt + tmp___0) = elt;
#line 522
  return;
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void exon_cores(hash_env_p_t he , uchar *s2 , unsigned int len2 , unsigned int offset1 ,
                       unsigned int offset2 , unsigned int K , collec_p_t mCol , collec_p_t res ,
                       collec_p_t eCol ) 
{ 
  unsigned int j ;
  int last_msp ;
  int swapped ;
  result_p_t r ;
  unsigned int minMPos ;
  unsigned int maxMPos ;
  unsigned int cov ;
  unsigned int covM ;
  unsigned int covR ;
  unsigned int globScore ;
  unsigned int minPartScore ;
  int tested ;
  unsigned int *coverage ;
  void *tmp ;
  unsigned int k ;
  exon_p_t m ;
  exon_p_t m___0 ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  exon_p_t e ;
  unsigned int *coverageL ;
  void *tmp___2 ;
  unsigned int covL ;
  exon_p_t p ;
  exon_p_t m___1 ;
  unsigned int jj ;
  int lLast ;
  unsigned int lScore ;
  unsigned int rScore ;
  unsigned int k___0 ;
  void *tmp___3 ;
  exon_p_t e___0 ;
  void *tmp___4 ;
  exon_p_t e___1 ;

  {
  {
#line 573
  swapped = (unsigned long )eCol != (unsigned long )((void *)0);
#line 575
  search(he, s2, len2, K, mCol);
#line 580
  qsort((void *)mCol->e.exon, (size_t )mCol->nb, sizeof(exon_p_t ), & msp_rna_compare);
#line 581
  trim_small_repeated_msps(mCol);
#line 586
  qsort((void *)mCol->e.exon, (size_t )mCol->nb, sizeof(exon_p_t ), & msp_compare);
#line 587
  combine_msps(mCol);
  }
#line 592
  if ((unsigned long )eCol == (unsigned long )((void *)0)) {
    {
#line 594
    minMPos = len2;
#line 595
    maxMPos = 0U;
#line 596
    covM = 0U;
#line 596
    covR = 0U;
#line 598
    tested = 0;
#line 599
    tmp = xcalloc((size_t )len2, sizeof(unsigned int ));
#line 599
    coverage = (unsigned int *)tmp;
    }
#line 601
    if (! ((unsigned long )res != (unsigned long )((void *)0))) {
      {
#line 601
      __assert_fail("res != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c",
                    601U, "exon_cores");
      }
    }
#line 603
    j = 0U;
    {
#line 603
    while (1) {
      while_continue: /* CIL Label */ ;
#line 603
      if (! (j < mCol->nb)) {
#line 603
        goto while_break;
      }
#line 605
      m = *(mCol->e.exon + j);
#line 606
      if (m->from2 < minMPos) {
#line 607
        minMPos = m->from2;
      }
#line 608
      if (m->to2 > maxMPos) {
#line 609
        maxMPos = m->to2;
      }
#line 610
      k = m->from2;
      {
#line 610
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 610
        if (! (k <= m->to2)) {
#line 610
          goto while_break___0;
        }
#line 611
        (*(coverage + k)) ++;
#line 610
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 603
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 613
    j = 0U;
    {
#line 613
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 613
      if (! (j < len2)) {
#line 613
        goto while_break___1;
      }
#line 614
      if (*(coverage + j) > 0U) {
#line 615
        covR ++;
      }
#line 616
      if (*(coverage + j) > 1U) {
#line 617
        covM ++;
      }
#line 613
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 619
    cov = (maxMPos - minMPos) + 1U;
#line 620
    cov /= 4U;
#line 621
    minMPos += cov;
#line 622
    if (maxMPos > cov) {
#line 623
      maxMPos -= cov;
    }
#line 624
    j = 0U;
    {
#line 624
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 624
      if (! (j < mCol->nb)) {
#line 624
        goto while_break___2;
      }
#line 625
      m___0 = *(mCol->e.exon + j);
#line 626
      tmp___0 = 0U;
#line 626
      m___0->top = tmp___0;
#line 626
      m___0->bot = tmp___0;
#line 627
      if (m___0->from2 < minMPos) {
#line 628
        m___0->bot = 1U;
      }
#line 629
      if (m___0->to2 > maxMPos) {
#line 630
        m___0->top = 1U;
      }
#line 624
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 641
    last_msp = link_msps(mCol, 0U, mCol->nb);
    }
#line 642
    if (last_msp < 0) {
      {
#line 643
      free((void *)coverage);
      }
#line 644
      return;
    }
#line 646
    minMPos = 0U;
#line 647
    maxMPos = 0U;
#line 648
    globScore = (*(mCol->e.exon + last_msp))->Score;
#line 649
    minPartScore = (globScore * options.splitScorePct) / 100U;
#line 656
    if (options.huntChimera > 0U) {
#line 656
      if ((covR * options.huntChimera) / 100U > globScore) {
        {
#line 659
        qsort((void *)mCol->e.exon, (size_t )mCol->nb, sizeof(exon_p_t ), & chimera_compare);
#line 663
        last_msp = link_chimera(mCol, 0U, mCol->nb);
#line 664
        tmp___1 = xcalloc(1UL, sizeof(result_t ));
#line 664
        add_col_elt(res, tmp___1);
#line 665
        r = *(res->e.result + (res->nb - 1U));
#line 666
        r->dStart = 0U;
#line 667
        r->dLen = he->len;
#line 668
        r->chimera = 1;
#line 669
        eCol = & r->eCol;
#line 673
        init_col(eCol, mCol->nb);
#line 674
        msp2exons(mCol->e.exon, last_msp, eCol, 0, 1);
#line 675
        j = 0U;
        }
        {
#line 675
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 675
          if (! (j < eCol->nb)) {
#line 675
            goto while_break___3;
          }
#line 676
          e = *(eCol->e.exon + j);
#line 677
          e->to1 += offset1;
#line 678
          e->from1 += offset1;
#line 679
          e->to2 += offset2;
#line 680
          e->from2 += offset2;
#line 675
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 683
        qsort((void *)mCol->e.exon, (size_t )mCol->nb, sizeof(exon_p_t ), & msp_compare);
#line 684
        last_msp = link_msps(mCol, 0U, mCol->nb);
        }
      }
    }
#line 689
    if (globScore > len2 >> 1) {
#line 689
      if (covM >= minPartScore) {
        {
#line 690
        tmp___2 = xcalloc((size_t )len2, sizeof(unsigned int ));
#line 690
        coverageL = (unsigned int *)tmp___2;
#line 692
        covL = 0U;
#line 695
        j = 1U;
        }
        {
#line 695
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 695
          if (! (j < mCol->nb)) {
#line 695
            goto while_break___4;
          }
#line 696
          p = *(mCol->e.exon + (j - 1U));
#line 697
          m___1 = *(mCol->e.exon + j);
#line 700
          jj = p->from2;
          {
#line 700
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 700
            if (! (jj <= p->to2)) {
#line 700
              goto while_break___5;
            }
#line 701
            if (*(coverageL + jj) == 0U) {
#line 702
              covL ++;
            }
#line 703
            (*(coverageL + jj)) ++;
#line 704
            (*(coverage + jj)) --;
#line 705
            if (*(coverage + jj) == 0U) {
#line 706
              covR --;
            }
#line 700
            jj ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 708
          if (covL >= minPartScore) {
#line 708
            if (covR >= minPartScore) {
#line 708
              if (p->top) {
#line 708
                if (! m___1->top) {
#line 708
                  goto _L;
                } else {
#line 708
                  goto _L___1;
                }
              } else
              _L___1: /* CIL Label */ 
#line 708
              if (! p->bot) {
#line 708
                if (m___1->bot) {
#line 708
                  goto _L;
                } else {
#line 708
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 708
              if (p->top) {
#line 708
                if (m___1->bot) {
                  _L: /* CIL Label */ 
                  {
#line 716
                  tested = 1;
#line 717
                  lLast = link_msps(mCol, minMPos, j);
                  }
#line 718
                  if (! (lLast >= 0)) {
                    {
#line 718
                    __assert_fail("lLast >= 0", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c",
                                  718U, "exon_cores");
                    }
                  }
                  {
#line 719
                  lScore = (*(mCol->e.exon + lLast))->Score;
#line 720
                  last_msp = link_msps(mCol, j, mCol->nb);
                  }
#line 721
                  if (! (last_msp >= 0)) {
                    {
#line 721
                    __assert_fail("last_msp >= 0", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c",
                                  721U, "exon_cores");
                    }
                  }
#line 722
                  rScore = (*(mCol->e.exon + last_msp))->Score;
#line 728
                  if (lScore >= minPartScore) {
#line 728
                    if (rScore >= minPartScore) {
                      {
#line 731
                      tmp___3 = xcalloc(1UL, sizeof(result_t ));
#line 731
                      add_col_elt(res, tmp___3);
#line 732
                      r = *(res->e.result + (res->nb - 1U));
#line 733
                      r->dStart = maxMPos;
#line 734
                      r->dLen = m___1->from1 - maxMPos;
#line 735
                      eCol = & r->eCol;
#line 740
                      init_col(eCol, j - minMPos);
#line 741
                      msp2exons(mCol->e.exon, lLast, eCol, 0, 0);
#line 742
                      k___0 = 0U;
                      }
                      {
#line 742
                      while (1) {
                        while_continue___6: /* CIL Label */ ;
#line 742
                        if (! (k___0 < eCol->nb)) {
#line 742
                          goto while_break___6;
                        }
#line 743
                        e___0 = *(eCol->e.exon + k___0);
#line 744
                        e___0->to1 += offset1;
#line 745
                        e___0->from1 += offset1;
#line 746
                        e___0->to2 += offset2;
#line 747
                        e___0->from2 += offset2;
#line 742
                        k___0 ++;
                      }
                      while_break___6: /* CIL Label */ ;
                      }
                      {
#line 750
                      memset((void *)coverageL, 0, (unsigned long )len2 * sizeof(unsigned int ));
#line 751
                      minMPos = j;
#line 752
                      maxMPos = (*(mCol->e.exon + lLast))->to1;
#line 753
                      tested = 0;
                      }
                    }
                  }
                }
              }
            }
          }
#line 695
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 757
        free((void *)coverageL);
        }
      }
    }
    {
#line 759
    free((void *)coverage);
    }
#line 760
    if (tested) {
      {
#line 761
      last_msp = link_msps(mCol, minMPos, mCol->nb);
      }
    }
    {
#line 762
    tmp___4 = xcalloc(1UL, sizeof(result_t ));
#line 762
    add_col_elt(res, tmp___4);
#line 763
    r = *(res->e.result + (res->nb - 1U));
#line 764
    r->dStart = maxMPos;
#line 765
    r->dLen = he->len - maxMPos;
#line 769
    eCol = & r->eCol;
    }
  } else {
    {
#line 771
    last_msp = link_msps(mCol, 0U, mCol->nb);
    }
  }
#line 776
  if (eCol->size == 0U) {
    {
#line 777
    init_col(eCol, mCol->nb);
    }
  }
  {
#line 778
  msp2exons(mCol->e.exon, last_msp, eCol, swapped, 0);
#line 779
  j = 0U;
  }
  {
#line 779
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 779
    if (! (j < eCol->nb)) {
#line 779
      goto while_break___7;
    }
#line 780
    e___1 = *(eCol->e.exon + j);
#line 781
    e___1->to1 += offset1;
#line 782
    e___1->from1 += offset1;
#line 783
    e___1->to2 += offset2;
#line 784
    e___1->from2 += offset2;
#line 779
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 786
  mCol->nb = 0U;
#line 787
  return;
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
__inline static int lies_after_p(exon_p_t a , exon_p_t b ) 
{ 
  unsigned int p1 ;
  unsigned int p2 ;
  unsigned int p3 ;
  unsigned int p1___0 ;
  unsigned int p2___0 ;
  unsigned int p3___0 ;

  {
#line 797
  if (b->from1 > a->to1) {
#line 801
    if (b->from2 > a->to2) {
#line 802
      return (1);
    }
#line 803
    if (b->from2 < a->from2) {
#line 804
      return (0);
    } else
#line 803
    if (b->to2 < a->to2) {
#line 804
      return (0);
    }
#line 805
    p1 = b->from2 - a->from2;
#line 806
    p2 = a->to2 - b->from2;
#line 807
    p3 = b->to2 - a->to2;
#line 808
    if (p1 > p2) {
#line 808
      if (p3 > p2) {
#line 808
        if (p1 > options.K) {
#line 808
          if (p3 > options.K) {
#line 809
            return (1);
          }
        }
      }
    }
  } else
#line 810
  if (b->from2 > a->to2) {
#line 814
    if (b->from1 < a->from1) {
#line 815
      return (0);
    } else
#line 814
    if (b->to1 < a->to1) {
#line 815
      return (0);
    }
#line 816
    p1___0 = b->from1 - a->from1;
#line 817
    p2___0 = a->to1 - b->from1;
#line 818
    p3___0 = b->to1 - a->to1;
#line 819
    if (p1___0 > p2___0) {
#line 819
      if (p3___0 > p2___0) {
#line 819
        if (p1___0 > options.K) {
#line 819
          if (p3___0 > options.K) {
#line 820
            return (1);
          }
        }
      }
    }
  }
#line 822
  return (0);
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
__inline static int lies_after_chimera_p(exon_p_t a , exon_p_t b ) 
{ 
  unsigned int p1 ;
  unsigned int p2 ;
  unsigned int p3 ;

  {
#line 836
  if (b->from2 > a->to2) {
#line 837
    return (1);
  }
#line 838
  if (b->from2 < a->from2) {
#line 839
    return (0);
  } else
#line 838
  if (b->to2 < a->to2) {
#line 839
    return (0);
  }
#line 840
  p1 = b->from2 - a->from2;
#line 841
  p2 = a->to2 - b->from2;
#line 842
  p3 = b->to2 - a->to2;
#line 843
  if (p1 > p2) {
#line 843
    if (p3 > p2) {
#line 843
      if (p1 > options.K) {
#line 843
        if (p3 > options.K) {
#line 844
          return (1);
        }
      }
    }
  }
#line 845
  return (0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void trim_small_repeated_msps(collec_p_t mCol ) 
{ 
  unsigned int i ;
  exon_p_t m ;
  unsigned int j ;
  unsigned int k ;
  unsigned int end ;

  {
#line 855
  i = 0U;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < mCol->nb)) {
#line 856
      goto while_break;
    }
#line 857
    m = *(mCol->e.exon + i);
#line 859
    if (m->to2 - m->from2 >= 50U) {
#line 860
      i ++;
#line 861
      goto while_continue;
    }
#line 863
    end = m->to2 + 5U;
#line 864
    j = i + 1U;
    {
#line 865
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 865
      if (j < mCol->nb) {
#line 865
        if (! ((*(mCol->e.exon + j))->to2 <= end)) {
#line 865
          goto while_break___0;
        }
      } else {
#line 865
        goto while_break___0;
      }
#line 866
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 867
    if (j - i < 20U) {
#line 868
      i ++;
#line 869
      goto while_continue;
    }
#line 871
    k = i;
    {
#line 871
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 871
      if (! (k < j)) {
#line 871
        goto while_break___1;
      }
      {
#line 872
      free((void *)*(mCol->e.exon + k));
#line 871
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 873
    memmove((void *)(mCol->e.exon + i), (void const   *)(mCol->e.exon + j), (unsigned long )(mCol->nb - j) * sizeof(exon_p_t ));
#line 875
    mCol->nb -= j - i;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 877
  return;
}
}
#line 879 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void combine_msps(collec_p_t mCol ) 
{ 
  unsigned int i ;
  exon_p_t m ;
  unsigned int ovl ;
  unsigned int j ;
  exon_p_t n ;
  unsigned int o ;
  int tmp ;
  exon_p_t n___0 ;
  unsigned int nScore ;

  {
#line 882
  i = 0U;
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 883
    if (! (i < mCol->nb)) {
#line 883
      goto while_break;
    }
#line 884
    m = *(mCol->e.exon + i);
#line 885
    ovl = 0U;
#line 887
    j = i + 1U;
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (j < mCol->nb)) {
#line 887
        goto while_break___0;
      }
#line 888
      n = *(mCol->e.exon + j);
#line 889
      o = 0U;
#line 890
      if (n->from2 <= m->to2 + 1U) {
#line 891
        ovl = (m->to2 - n->from2) + 2U;
      }
#line 892
      if (n->from1 > m->from1) {
#line 892
        if (n->from1 <= m->to1 + 1U) {
#line 894
          o = (m->to1 - n->from1) + 2U;
        }
      }
#line 895
      if ((ovl == 0U) == (o == 0U)) {
        {
#line 895
        tmp = abs((int )ovl - (int )o);
        }
#line 895
        if (tmp <= 10) {
#line 897
          goto while_break___0;
        }
      }
#line 898
      ovl = 0U;
#line 887
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 900
    if (ovl != 0U) {
#line 901
      n___0 = *(mCol->e.exon + j);
#line 902
      nScore = m->score + n___0->score;
#line 903
      if (nScore >= ovl + 1U) {
#line 904
        nScore -= ovl + 1U;
      } else {
#line 906
        nScore = 0U;
      }
#line 907
      if (m->from1 > n___0->from1) {
#line 907
        m->from1 = n___0->from1;
      } else {
#line 907
        m->from1 = m->from1;
      }
#line 908
      if (m->from2 > n___0->from2) {
#line 908
        m->from2 = n___0->from2;
      } else {
#line 908
        m->from2 = m->from2;
      }
#line 909
      if (m->to1 < n___0->to1) {
#line 909
        m->to1 = n___0->to1;
      } else {
#line 909
        m->to1 = m->to1;
      }
#line 910
      if (m->to2 < n___0->to2) {
#line 910
        m->to2 = n___0->to2;
      } else {
#line 910
        m->to2 = m->to2;
      }
#line 911
      if (nScore > m->score) {
#line 912
        m->score = nScore;
      }
      {
#line 913
      (mCol->nb) --;
#line 914
      free((void *)n___0);
#line 915
      memmove((void *)(mCol->e.exon + j), (void const   *)((mCol->e.exon + j) + 1),
              (unsigned long )(mCol->nb - j) * sizeof(exon_p_t ));
      }
    } else {
#line 918
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return;
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int link_msps(collec_p_t mCol , unsigned int start , unsigned int stop ) 
{ 
  struct __anonstruct_best_32 best ;
  unsigned int i ;
  exon_p_t m ;
  exon_p_t m___0 ;
  unsigned int j ;
  exon_p_t n ;
  unsigned int penalty ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 930
  if (start >= stop) {
#line 931
    return (-1);
  }
  {
#line 932
  memset((void *)(& best), 0, sizeof(best));
#line 933
  i = start;
  }
  {
#line 933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 933
    if (! (i < stop)) {
#line 933
      goto while_break;
    }
#line 934
    m = *(mCol->e.exon + i);
#line 935
    m->Score = 0U;
#line 936
    m->prev = -1;
#line 933
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 938
  i = start;
  {
#line 938
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 938
    if (! (i < stop)) {
#line 938
      goto while_break___0;
    }
#line 939
    m___0 = *(mCol->e.exon + i);
#line 941
    m___0->Score += m___0->score;
#line 942
    if (m___0->Score > best.score) {
#line 943
      best.score = m___0->Score;
#line 944
      best.elt = i;
    }
#line 946
    j = i + 1U;
    {
#line 946
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 946
      if (! (j < stop)) {
#line 946
        goto while_break___1;
      }
      {
#line 947
      n = *(mCol->e.exon + j);
#line 948
      tmp___1 = lies_after_p(m___0, n);
      }
#line 948
      if (tmp___1) {
#line 948
        if (m___0->Score >= n->Score) {
          {
#line 950
          tmp = abs((int )n->from1 - (int )m___0->from1);
#line 950
          penalty = (unsigned int )tmp >> 15;
#line 951
          tmp___0 = abs((int )n->from2 - (int )m___0->from2);
#line 951
          penalty += (unsigned int )tmp___0 >> 15;
          }
#line 952
          if (penalty < m___0->Score) {
#line 953
            n->Score = m___0->Score - penalty;
#line 954
            n->prev = (int )i;
          }
        }
      }
#line 946
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 938
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 959
  return ((int )best.elt);
}
}
#line 962 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int link_chimera(collec_p_t mCol , unsigned int start , unsigned int stop ) 
{ 
  struct __anonstruct_best_33 best ;
  unsigned int i ;
  exon_p_t m ;
  exon_p_t m___0 ;
  unsigned int j ;
  exon_p_t n ;
  unsigned int penalty ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 970
  if (start >= stop) {
#line 971
    return (-1);
  }
  {
#line 972
  memset((void *)(& best), 0, sizeof(best));
#line 973
  i = start;
  }
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < stop)) {
#line 973
      goto while_break;
    }
#line 974
    m = *(mCol->e.exon + i);
#line 975
    m->Score = 0U;
#line 976
    m->prev = -1;
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 978
  i = start;
  {
#line 978
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 978
    if (! (i < stop)) {
#line 978
      goto while_break___0;
    }
#line 979
    m___0 = *(mCol->e.exon + i);
#line 981
    m___0->Score += m___0->score;
#line 982
    if (m___0->Score > best.score) {
#line 983
      best.score = m___0->Score;
#line 984
      best.elt = i;
    }
#line 986
    j = i + 1U;
    {
#line 986
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 986
      if (! (j < stop)) {
#line 986
        goto while_break___1;
      }
      {
#line 987
      n = *(mCol->e.exon + j);
#line 988
      tmp___1 = lies_after_chimera_p(m___0, n);
      }
#line 988
      if (tmp___1) {
#line 988
        if (m___0->Score >= n->Score) {
          {
#line 990
          tmp = abs((int )n->from1 - (int )m___0->from1);
#line 990
          penalty = (unsigned int )tmp >> 15;
#line 991
          tmp___0 = abs((int )n->from2 - (int )m___0->from2);
#line 991
          penalty += (unsigned int )tmp___0 >> 15;
          }
#line 994
          if (n->from1 < m___0->from1) {
#line 995
            penalty += m___0->score / 10U;
          }
#line 996
          if (penalty < m___0->Score) {
#line 997
            n->Score = m___0->Score - penalty;
#line 998
            n->prev = (int )i;
          }
        }
      }
#line 986
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 978
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1003
  return ((int )best.elt);
}
}
#line 1006 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
void init_encoding(void) 
{ 
  unsigned int i ;

  {
#line 1010
  i = 0U;
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1010
    if (! (i < 128U)) {
#line 1010
      goto while_break;
    }
#line 1011
    encoding[i] = 4U;
#line 1010
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1012
  encoding['A'] = 0U;
#line 1013
  encoding['C'] = 1U;
#line 1014
  encoding['G'] = 2U;
#line 1015
  encoding['T'] = 3U;
#line 1016
  return;
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
void init_hash_env(hash_env_p_t he , unsigned int W , uchar *seq , unsigned int len ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1021
  he->W = W;
#line 1022
  he->seq = seq;
#line 1023
  he->len = len;
#line 1024
  he->mask = (1U << ((W + W) - 2U)) - 1U;
#line 1025
  tmp = xmalloc((unsigned long )(len + 1U) * sizeof(int ));
#line 1025
  he->next_pos = (int *)tmp;
#line 1026
  tmp___0 = xcalloc(1UL << 19, sizeof(void *));
#line 1026
  he->hashtab = (void **)tmp___0;
  }
#line 1028
  return;
}
}
#line 1037 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
void free_hash_env(hash_env_p_t he ) 
{ 
  unsigned int hval ;

  {
  {
#line 1041
  free((void *)he->next_pos);
#line 1042
  hval = 0U;
  }
  {
#line 1042
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1042
    if (! ((unsigned long )hval < 1UL << 19)) {
#line 1042
      goto while_break;
    }
    {
#line 1043
    tdestroy(*(he->hashtab + hval), (void (*)(void *__nodep ))(& free));
#line 1042
    hval ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1045
  free((void *)he->hashtab);
  }
#line 1046
  return;
}
}
#line 1048 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int hash_node_compare(void const   *a , void const   *b ) 
{ 
  hash_node_p_t ha ;
  hash_node_p_t hb ;

  {
#line 1051
  ha = (hash_node_p_t )a;
#line 1051
  hb = (hash_node_p_t )b;
#line 1052
  if (ha->ecode < hb->ecode) {
#line 1053
    return (-1);
  }
#line 1054
  if (ha->ecode > hb->ecode) {
#line 1055
    return (1);
  }
#line 1056
  return (0);
}
}
#line 1060 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
__inline static void add_word(hash_env_p_t he , unsigned int ecode , unsigned int pos ) 
{ 
  hash_node_p_t h ;
  void *tmp ;
  hash_node_p_t *key ;
  void *tmp___0 ;

  {
  {
#line 1063
  tmp = xmalloc(sizeof(hash_node_t ));
#line 1063
  h = (hash_node_p_t )tmp;
#line 1066
  h->ecode = ecode;
#line 1067
  tmp___0 = tsearch((void const   *)h, he->hashtab + ((unsigned long )ecode & ((1UL << 19) - 1UL)),
                    & hash_node_compare);
#line 1067
  key = (hash_node_p_t *)tmp___0;
  }
#line 1068
  if (! ((unsigned long )key != (unsigned long )((void *)0))) {
    {
#line 1068
    __assert_fail("key != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c",
                  1068U, "add_word");
    }
  }
#line 1069
  if ((unsigned long )*key != (unsigned long )h) {
    {
#line 1070
    free((void *)h);
#line 1071
    *(he->next_pos + pos) = (int )(*key)->pos;
    }
  } else {
#line 1073
    *(he->next_pos + pos) = -1;
  }
#line 1075
  (*key)->pos = pos;
#line 1076
  return;
}
}
#line 1079 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
void bld_table(hash_env_p_t he ) 
{ 
  unsigned int ecode ;
  unsigned int i ;
  uchar *t ;
  unsigned int j ;
  unsigned int tmp ;
  uchar *tmp___0 ;
  unsigned int tmp___1 ;
  uchar *tmp___2 ;

  {
#line 1083
  i = 0U;
#line 1086
  t = he->seq;
  {
#line 1087
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1087
    if (! (i < he->len)) {
#line 1087
      goto while_break;
    }
    restart: 
#line 1090
    ecode = 0U;
#line 1091
    j = 1U;
    {
#line 1091
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1091
      if (j < he->W) {
#line 1091
        if (! (i < he->len)) {
#line 1091
          goto while_break___0;
        }
      } else {
#line 1091
        goto while_break___0;
      }
#line 1092
      tmp___0 = t;
#line 1092
      t ++;
#line 1092
      tmp = encoding[*tmp___0];
#line 1093
      i ++;
#line 1094
      if (tmp > 3U) {
#line 1094
        goto restart;
      }
#line 1095
      ecode = (ecode << 2) + tmp;
#line 1091
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1098
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1098
      if (! (i < he->len)) {
#line 1098
        goto while_break___1;
      }
#line 1099
      tmp___2 = t;
#line 1099
      t ++;
#line 1099
      tmp___1 = encoding[*tmp___2];
#line 1100
      i ++;
#line 1101
      if (tmp___1 > 3U) {
#line 1101
        goto restart;
      }
      {
#line 1102
      ecode = ((ecode & he->mask) << 2) + tmp___1;
#line 1103
      add_word(he, ecode, i);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return;
}
}
#line 1110 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void search(hash_env_p_t he , uchar *s2 , unsigned int len2 , unsigned int K ,
                   collec_p_t mCol ) 
{ 
  uchar *t ;
  unsigned int i ;
  int *allocated ;
  void *tmp ;
  int *diag_lev ;
  unsigned int j ;
  hash_node_t hn ;
  unsigned int tmp___0 ;
  uchar *tmp___1 ;
  unsigned int tmp___2 ;
  uchar *tmp___3 ;
  hash_node_p_t *key ;
  void *tmp___4 ;
  int p ;

  {
  {
#line 1115
  i = 0U;
#line 1116
  tmp = xcalloc((size_t )((he->len + len2) + 1U), sizeof(int ));
#line 1116
  allocated = (int *)tmp;
#line 1117
  diag_lev = allocated + he->len;
#line 1118
  t = s2;
  }
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1119
    if (! (i < len2)) {
#line 1119
      goto while_break;
    }
    restart: 
#line 1123
    hn.ecode = 0U;
#line 1124
    j = 1U;
    {
#line 1124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1124
      if (j < he->W) {
#line 1124
        if (! (i < len2)) {
#line 1124
          goto while_break___0;
        }
      } else {
#line 1124
        goto while_break___0;
      }
#line 1125
      tmp___1 = t;
#line 1125
      t ++;
#line 1125
      tmp___0 = encoding[*tmp___1];
#line 1126
      i ++;
#line 1127
      if (tmp___0 > 3U) {
#line 1127
        goto restart;
      }
#line 1128
      hn.ecode = (hn.ecode << 2) + tmp___0;
#line 1124
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1130
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1130
      if (! (i < len2)) {
#line 1130
        goto while_break___1;
      }
#line 1131
      tmp___3 = t;
#line 1131
      t ++;
#line 1131
      tmp___2 = encoding[*tmp___3];
#line 1133
      i ++;
#line 1134
      if (tmp___2 > 3U) {
#line 1134
        goto restart;
      }
      {
#line 1135
      hn.ecode = ((hn.ecode & he->mask) << 2) + tmp___2;
#line 1136
      tmp___4 = tfind((void const   *)(& hn), (void * const  *)(he->hashtab + ((unsigned long )hn.ecode & ((1UL << 19) - 1UL))),
                      & hash_node_compare);
#line 1136
      key = (hash_node_p_t *)tmp___4;
      }
#line 1138
      if ((unsigned long )key != (unsigned long )((void *)0)) {
#line 1140
        p = (int )(*key)->pos;
        {
#line 1140
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1140
          if (! (p >= 0)) {
#line 1140
            goto while_break___2;
          }
          {
#line 1141
          extend_hit(p, (int )i, he, (uchar const   */* const  */)s2, len2, K, mCol,
                     diag_lev);
#line 1140
          p = *(he->next_pos + p);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1145
  free((void *)allocated);
  }
#line 1146
  return;
}
}
#line 1149 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void extend_hit(int pos1 , int pos2 , hash_env_p_t he , uchar const   * const  s2 ,
                       unsigned int len2 , unsigned int K , collec_p_t mCol , int *diag_lev ) 
{ 
  uchar const   *beg2 ;
  uchar const   *beg1 ;
  uchar const   *end1 ;
  uchar const   *q ;
  uchar const   *s ;
  int right_sum ;
  int left_sum ;
  int sum ;
  int diag ;
  int score ;
  int tmp___1 ;
  uchar const   *tmp___2 ;
  uchar const   *tmp___3 ;
  int tmp___4 ;
  exon_p_t tmp___5 ;

  {
#line 1156
  diag = pos2 - pos1;
#line 1157
  if (*(diag_lev + diag) > pos1) {
#line 1158
    return;
  }
#line 1161
  sum = 0;
#line 1161
  left_sum = sum;
#line 1162
  q = (uchar const   *)(he->seq + pos1);
#line 1163
  s = (uchar const   *)(s2 + pos2);
#line 1164
  end1 = q;
  {
#line 1165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1165
    if ((unsigned long )s < (unsigned long )(s2 + len2)) {
#line 1165
      if ((unsigned long )q < (unsigned long )(he->seq + he->len)) {
#line 1165
        if (! (sum >= left_sum - (int )options.X)) {
#line 1165
          goto while_break;
        }
      } else {
#line 1165
        goto while_break;
      }
    } else {
#line 1165
      goto while_break;
    }
#line 1168
    tmp___2 = s;
#line 1168
    s ++;
#line 1168
    tmp___3 = q;
#line 1168
    q ++;
#line 1168
    if ((int const   )*tmp___2 == (int const   )*tmp___3) {
#line 1168
      tmp___1 = options.matchScore;
    } else {
#line 1168
      tmp___1 = options.mismatchScore;
    }
#line 1168
    sum += tmp___1;
#line 1171
    if (sum > left_sum) {
#line 1172
      left_sum = sum;
#line 1173
      end1 = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  sum = 0;
#line 1178
  right_sum = sum;
#line 1179
  q = (uchar const   *)((he->seq + pos1) - he->W);
#line 1179
  beg1 = q;
#line 1180
  s = (uchar const   *)((s2 + pos2) - he->W);
#line 1180
  beg2 = s;
  {
#line 1181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1181
    if ((unsigned long )s > (unsigned long )s2) {
#line 1181
      if ((unsigned long )q > (unsigned long )he->seq) {
#line 1181
        if (! (sum >= right_sum - (int )options.X)) {
#line 1181
          goto while_break___0;
        }
      } else {
#line 1181
        goto while_break___0;
      }
    } else {
#line 1181
      goto while_break___0;
    }
#line 1182
    s --;
#line 1182
    q --;
#line 1182
    if ((int const   )*s == (int const   )*q) {
#line 1182
      tmp___4 = options.matchScore;
    } else {
#line 1182
      tmp___4 = options.mismatchScore;
    }
#line 1182
    sum += tmp___4;
#line 1185
    if (sum > right_sum) {
#line 1186
      right_sum = sum;
#line 1187
      beg2 = s;
#line 1188
      beg1 = q;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1192
  score = ((int )he->W + left_sum) + right_sum;
#line 1193
  if (score >= (int )K) {
    {
#line 1194
    tmp___5 = new_exon((unsigned int )(beg1 - (uchar const   *)he->seq), (unsigned int )(beg2 - (uchar const   *)s2),
                       (unsigned int )(end1 - (uchar const   *)he->seq) - 1U, ((unsigned int )(beg2 - (uchar const   *)s2) + (unsigned int )(end1 - beg1)) - 1U);
#line 1194
    add_col_elt(mCol, (void *)tmp___5);
#line 1200
    (*(mCol->e.exon + (mCol->nb - 1U)))->score = (unsigned int )score;
    }
  }
#line 1202
  *(diag_lev + diag) = (int )((end1 - (uchar const   *)he->seq) + (long )he->W);
#line 1203
  return;
}
}
#line 1208 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int msp_compare(void const   *a , void const   *b ) 
{ 
  exon_p_t ki ;
  exon_p_t kj ;

  {
#line 1211
  ki = *((exon_p_t *)a);
#line 1211
  kj = *((exon_p_t *)b);
#line 1213
  if (ki->from1 > kj->from1) {
#line 1214
    return (1);
  }
#line 1215
  if (ki->from1 < kj->from1) {
#line 1216
    return (-1);
  }
#line 1217
  if (ki->from2 > kj->from2) {
#line 1218
    return (1);
  }
#line 1219
  if (ki->from2 < kj->from2) {
#line 1220
    return (-1);
  }
#line 1221
  return (0);
}
}
#line 1225 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int chimera_compare(void const   *a , void const   *b ) 
{ 
  exon_p_t ki ;
  exon_p_t kj ;

  {
#line 1228
  ki = *((exon_p_t *)a);
#line 1228
  kj = *((exon_p_t *)b);
#line 1230
  if (ki->from2 > kj->from2) {
#line 1231
    return (1);
  }
#line 1232
  if (ki->from2 < kj->from2) {
#line 1233
    return (-1);
  }
#line 1234
  if (ki->from1 > kj->from1) {
#line 1235
    return (1);
  }
#line 1236
  if (ki->from1 < kj->from1) {
#line 1237
    return (-1);
  }
#line 1238
  return (0);
}
}
#line 1242 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int msp_rna_compare(void const   *a , void const   *b ) 
{ 
  exon_p_t ki ;
  exon_p_t kj ;

  {
#line 1245
  ki = *((exon_p_t *)a);
#line 1245
  kj = *((exon_p_t *)b);
#line 1247
  if (ki->from2 > kj->from2) {
#line 1248
    return (1);
  }
#line 1249
  if (ki->from2 < kj->from2) {
#line 1250
    return (-1);
  }
#line 1251
  if (ki->to2 > kj->to2) {
#line 1252
    return (-1);
  }
#line 1253
  if (ki->to2 < kj->to2) {
#line 1254
    return (1);
  }
#line 1255
  return (0);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void msp2exons(exon_p_t *msp , int last_msp , collec_p_t eCol , int swapped ,
                      int copy ) 
{ 
  exon_p_t mp ;
  exon_p_t next ;
  exon_p_t c ;
  void *tmp ;
  unsigned int i ;
  unsigned int j ;
  exon_p_t e ;

  {
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    if (! (last_msp >= 0)) {
#line 1263
      goto while_break;
    }
#line 1264
    mp = *(msp + last_msp);
#line 1265
    if (eCol->nb > 0U) {
#line 1265
      if (! copy) {
#line 1267
        next = *(eCol->e.exon + (eCol->nb - 1U));
#line 1268
        if (! swapped) {
#line 1268
          if (next->to1 > mp->to1) {
#line 1268
            if (next->from1 < mp->to1 + 30U) {
#line 1268
              if (next->from2 > mp->to2 - 1U) {
#line 1268
                if (next->from2 < mp->to2 + 30U) {
#line 1278
                  if (next->to1 < mp->to1) {
#line 1278
                    next->to1 = mp->to1;
                  } else {
#line 1278
                    next->to1 = next->to1;
                  }
#line 1279
                  if (next->to2 < mp->to2) {
#line 1279
                    next->to2 = mp->to2;
                  } else {
#line 1279
                    next->to2 = next->to2;
                  }
#line 1280
                  if (next->from1 > mp->from1) {
#line 1280
                    next->from1 = mp->from1;
                  } else {
#line 1280
                    next->from1 = next->from1;
                  }
#line 1281
                  if (next->from2 > mp->from2) {
#line 1281
                    next->from2 = mp->from2;
                  } else {
#line 1281
                    next->from2 = next->from2;
                  }
                  {
#line 1282
                  last_msp = mp->prev;
#line 1283
                  free((void *)mp);
                  }
#line 1284
                  goto while_continue;
                }
              }
            }
          }
        }
      }
    }
#line 1287
    if (copy) {
      {
#line 1288
      tmp = xmalloc(sizeof(exon_t ));
#line 1288
      c = (exon_p_t )tmp;
#line 1289
      memcpy((void */* __restrict  */)c, (void const   */* __restrict  */)mp, sizeof(exon_t ));
#line 1290
      mp = c;
      }
    }
    {
#line 1292
    add_col_elt(eCol, (void *)mp);
#line 1293
    last_msp = mp->prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1296
  if (eCol->nb > 1U) {
#line 1298
    i = 0U;
#line 1298
    j = eCol->nb - 1U;
    {
#line 1298
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1298
      if (! (j > i)) {
#line 1298
        goto while_break___0;
      }
#line 1299
      e = *(eCol->e.exon + i);
#line 1300
      *(eCol->e.exon + i) = *(eCol->e.exon + j);
#line 1301
      *(eCol->e.exon + j) = e;
#line 1298
      i ++;
#line 1298
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1304
  return;
}
}
#line 1308 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
void print_exons(collec_p_t eCol , int direction ) 
{ 
  unsigned int i ;
  unsigned int last ;
  exon_p_t cur ;
  char const   *tmp ;

  {
#line 1312
  last = eCol->nb - 1U;
#line 1314
  if (! (eCol->nb > 0U)) {
    {
#line 1314
    __assert_fail("eCol->nb > 0", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c",
                  1314U, "print_exons");
    }
  }
#line 1315
  i = 0U;
  {
#line 1315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1315
    if (! (i < last)) {
#line 1315
      goto while_break;
    }
#line 1316
    cur = *(eCol->e.exon + i);
#line 1317
    if (direction == 0) {
      {
#line 1318
      printf((char const   */* __restrict  */)"%u-%u  (%u-%u)   %u%% ==\n", cur->from1 + options.dnaOffset,
             cur->to1 + options.dnaOffset, cur->from2, cur->to2, cur->score);
      }
    } else
#line 1317
    if (cur->type < 0) {
      {
#line 1318
      printf((char const   */* __restrict  */)"%u-%u  (%u-%u)   %u%% ==\n", cur->from1 + options.dnaOffset,
             cur->to1 + options.dnaOffset, cur->from2, cur->to2, cur->score);
      }
    } else {
#line 1322
      if (direction > 0) {
#line 1322
        tmp = "->";
      } else {
#line 1322
        tmp = "<-";
      }
      {
#line 1322
      printf((char const   */* __restrict  */)"%u-%u  (%u-%u)   %u%% %s (%.2s/%.2s) %u\n",
             cur->from1 + options.dnaOffset, cur->to1 + options.dnaOffset, cur->from2,
             cur->to2, cur->score, tmp, (options.splice + cur->type)->fwd, (options.splice + cur->type)->fwd + 2,
             cur->splScore);
      }
    }
#line 1315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1330
  cur = *(eCol->e.exon + last);
#line 1331
  printf((char const   */* __restrict  */)"%u-%u  (%u-%u)   %u%%\n", cur->from1 + options.dnaOffset,
         cur->to1 + options.dnaOffset, cur->from2, cur->to2, cur->score);
  }
#line 1334
  return;
}
}
#line 1336 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int pluri_align(uchar *seq1 , uchar *seq2 , unsigned int *num_matches , collec_p_t eCol ,
                       edit_script_list_p_t *Aligns , unsigned int M , unsigned int N ) 
{ 
  exon_t eFake ;
  exon_p_t cur ;
  int diff ;
  int ali_dist ;
  unsigned int end1 ;
  unsigned int end2 ;
  unsigned int nmatches ;
  edit_script_p_t head ;
  int ii ;
  exon_p_t prev ;
  edit_script_p_t left ;
  edit_script_p_t right ;
  edit_script_p_t prevE ;
  edit_script_p_t tmp_script ;
  uchar *a ;
  uchar *b ;
  int tmpi ;
  int di_count ;
  int alen ;
  edit_script_list_p_t enew ;
  void *tmp ;
  edit_script_p_t new ;
  void *tmp___0 ;
  int tmp___1 ;
  int j ;
  edit_script_list_p_t enew___0 ;
  void *tmp___2 ;
  edit_script_list_p_t enew___1 ;
  void *tmp___3 ;

  {
#line 1342
  cur = & eFake;
#line 1345
  nmatches = 0U;
#line 1349
  head = (edit_script_p_t )((void *)0);
#line 1350
  *Aligns = (edit_script_list_p_t )((void *)0);
#line 1351
  ali_dist = 0;
#line 1352
  end1 = M;
#line 1353
  end2 = N;
#line 1354
  eFake.from1 = M + 1U;
#line 1355
  eFake.from2 = N + 1U;
#line 1356
  eFake.to1 = 0U;
#line 1357
  eFake.to2 = 0U;
#line 1359
  ii = (int )eCol->nb - 1;
  {
#line 1359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1359
    if (! (ii >= 0)) {
#line 1359
      goto while_break;
    }
#line 1360
    prev = *(eCol->e.exon + ii);
#line 1364
    diff = (int )(cur->from2 - prev->to2) - 1;
#line 1364
    if (diff != 0) {
#line 1365
      if (cur->to1) {
        {
#line 1366
        tmp = xmalloc(sizeof(edit_script_list_t ));
#line 1366
        enew = (edit_script_list_p_t )tmp;
#line 1368
        enew->next_script = *Aligns;
#line 1369
        *Aligns = enew;
#line 1370
        enew->script = head;
#line 1371
        enew->offset1 = cur->from1;
#line 1372
        enew->offset2 = cur->from2;
#line 1373
        enew->len1 = (end1 - enew->offset1) + 1U;
#line 1374
        enew->len2 = (end2 - enew->offset2) + 1U;
#line 1375
        enew->score = ali_dist;
#line 1376
        ali_dist = 0;
#line 1377
        head = (edit_script_p_t )((void *)0);
        }
      }
#line 1379
      end1 = prev->to1;
#line 1380
      end2 = prev->to2;
    } else {
#line 1381
      diff = (int )(cur->from1 - prev->to1) - 1;
#line 1381
      if (diff != 0) {
#line 1381
        if (cur->to1) {
          {
#line 1383
          tmp___0 = xmalloc(sizeof(edit_script_t ));
#line 1383
          new = (edit_script_p_t )tmp___0;
          }
#line 1384
          if (diff < 0) {
#line 1385
            new->op_type = (char)4;
          } else {
#line 1387
            new->op_type = (char)1;
          }
#line 1388
          new->num = diff;
#line 1389
          new->next = head;
#line 1390
          head = new;
        } else {
#line 1381
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1391
      if (diff) {
#line 1392
        end1 = prev->to1;
      }
    }
#line 1394
    if (1000 < (int )(.2 * (double )((prev->to2 - prev->from2) + 1U))) {
#line 1394
      tmp___1 = (int )(.2 * (double )((prev->to2 - prev->from2) + 1U));
    } else {
#line 1394
      tmp___1 = 1000;
    }
    {
#line 1394
    diff = align_get_dist(seq1, seq2, (int )prev->from1 - 1, (int )prev->from2 - 1,
                          (int )prev->to1, (int )prev->to2, tmp___1);
    }
#line 1399
    if (diff < 0) {
#line 1400
      return (-1);
    }
    {
#line 1402
    align_path(seq1, seq2, (int )prev->from1 - 1, (int )prev->from2 - 1, (int )prev->to1,
               (int )prev->to2, diff, & left, & right, (int )M, (int )N);
    }
#line 1405
    if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 1406
      return (-1);
    }
    {
#line 1407
    Condense_both_Ends(& left, & right, & prevE);
    }
#line 1409
    if (! cur->to1) {
#line 1409
      if ((int )right->op_type == 1) {
#line 1411
        diff -= right->num;
#line 1412
        if (right->num > (int )prev->to1) {
          {
#line 1413
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trouble in DELETE alignment op.\n");
#line 1414
          prev->to1 = 0U;
#line 1415
          end1 = 0U;
          }
        } else {
#line 1417
          prev->to1 -= (unsigned int )right->num;
#line 1418
          end1 -= (unsigned int )right->num;
        }
#line 1420
        if (head) {
#line 1420
          if ((int )head->op_type == 1) {
#line 1421
            head->num += right->num;
          }
        }
        {
#line 1422
        free((void *)right);
#line 1423
        prevE->next = (struct _edit_script *)((void *)0);
#line 1424
        right = prevE;
        }
      }
    }
#line 1426
    if (ii == 0) {
#line 1426
      if (left) {
#line 1426
        if ((int )left->op_type == 1) {
#line 1427
          diff -= left->num;
#line 1428
          prev->from1 += (unsigned int )left->num;
#line 1429
          tmp_script = left->next;
#line 1430
          if ((unsigned long )right == (unsigned long )left) {
#line 1431
            right = tmp_script;
          }
          {
#line 1432
          free((void *)left);
#line 1433
          left = tmp_script;
          }
        }
      }
    }
#line 1436
    ali_dist += diff;
#line 1438
    a = (seq1 + prev->from1) - 1;
#line 1439
    b = (seq2 + prev->from2) - 1;
#line 1440
    di_count = 0;
#line 1440
    tmpi = di_count;
#line 1441
    tmp_script = left;
    {
#line 1442
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1442
      if (! tmp_script) {
#line 1442
        goto while_break___0;
      }
      {
#line 1444
      if ((int )tmp_script->op_type == 1) {
#line 1444
        goto case_1;
      }
#line 1449
      if ((int )tmp_script->op_type == 2) {
#line 1449
        goto case_2;
      }
#line 1454
      if ((int )tmp_script->op_type == 3) {
#line 1454
        goto case_3;
      }
#line 1443
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1445
      di_count += tmp_script->num;
#line 1446
      tmpi += tmp_script->num;
#line 1447
      a += tmp_script->num;
#line 1448
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1450
      di_count += tmp_script->num;
#line 1451
      tmpi += tmp_script->num;
#line 1452
      b += tmp_script->num;
#line 1453
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1457
      j = 0;
      {
#line 1457
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1457
        if (! (j < tmp_script->num)) {
#line 1457
          goto while_break___1;
        }
#line 1458
        if ((int )*a != (int )*b) {
#line 1459
          tmpi ++;
        } else {
#line 1461
          nmatches ++;
        }
#line 1457
        j ++;
#line 1457
        a ++;
#line 1457
        b ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1462
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1465
      tmp_script = tmp_script->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1467
    alen = (int )((double )((int )(((((prev->to1 - prev->from1) + 1U) + prev->to2) - prev->from2) + 1U) + di_count) / (double )2);
#line 1471
    prev->score = (unsigned int )(((alen - tmpi) * 100) / alen);
#line 1472
    right->next = head;
#line 1473
    head = left;
#line 1474
    cur = prev;
#line 1359
    ii --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1478
  diff = (int )cur->from2 - 1;
#line 1478
  if (diff != 0) {
#line 1478
    if (diff != (int )N) {
      {
#line 1479
      tmp___2 = xmalloc(sizeof(edit_script_list_t ));
#line 1479
      enew___0 = (edit_script_list_p_t )tmp___2;
#line 1481
      enew___0->next_script = *Aligns;
#line 1482
      *Aligns = enew___0;
#line 1483
      enew___0->offset1 = cur->from1;
#line 1484
      enew___0->offset2 = cur->from2;
#line 1485
      enew___0->len1 = (end1 - enew___0->offset1) + 1U;
#line 1486
      enew___0->len2 = (end2 - enew___0->offset2) + 1U;
#line 1487
      enew___0->script = head;
#line 1488
      enew___0->score = ali_dist;
      }
    } else {
#line 1478
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1489
  if (diff != (int )N) {
    {
#line 1491
    tmp___3 = xmalloc(sizeof(edit_script_list_t ));
#line 1491
    enew___1 = (edit_script_list_p_t )tmp___3;
#line 1493
    enew___1->next_script = *Aligns;
#line 1494
    *Aligns = enew___1;
#line 1495
    enew___1->offset1 = cur->from1;
#line 1496
    enew___1->offset2 = 1U;
#line 1497
    enew___1->len1 = (end1 - enew___1->offset1) + 1U;
#line 1498
    enew___1->len2 = (end2 - enew___1->offset2) + 1U;
#line 1499
    enew___1->script = head;
#line 1500
    enew___1->score = ali_dist;
    }
  }
#line 1502
  *num_matches = nmatches;
#line 1503
  return (0);
}
}
#line 1506 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static exon_p_t new_exon(unsigned int f1 , unsigned int f2 , unsigned int t1 , unsigned int t2 ) 
{ 
  exon_p_t e ;
  void *tmp ;

  {
  {
#line 1509
  tmp = xmalloc(sizeof(exon_t ));
#line 1509
  e = (exon_p_t )tmp;
#line 1510
  e->from1 = f1;
#line 1511
  e->from2 = f2;
#line 1512
  e->to1 = t1;
#line 1513
  e->to2 = t2;
  }
#line 1514
  return (e);
}
}
#line 1518 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static unsigned int greedy(uchar *s1 , uchar *s2 , unsigned int m , unsigned int n ,
                           unsigned int offset1 , unsigned int offset2 , unsigned int W ,
                           collec_p_t eCol ) 
{ 
  int col ;
  int k ;
  int blower ;
  int flower ;
  int bupper ;
  int fupper ;
  int row ;
  int DELTA ;
  int B_ORIGIN ;
  int F_ORIGIN ;
  unsigned int d ;
  unsigned int max_d ;
  unsigned int Cost ;
  unsigned int MAX_D ;
  unsigned int i ;
  int back ;
  int forth ;
  int *blast_d ;
  int *flast_d ;
  int *btemp_d ;
  int *ftemp_d ;
  int *min_row ;
  int *min_diag ;
  int *max_row ;
  int *max_diag ;
  exon_p_t tmp ;
  unsigned int tmp___0 ;
  double tmp___1 ;
  exon_p_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  exon_p_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  unsigned int p1 ;
  unsigned int p2 ;
  unsigned int q1 ;
  unsigned int q2 ;
  exon_p_t tmp___12 ;
  exon_p_t tmp___13 ;

  {
#line 1542
  if (n >= 1000000U) {
#line 1543
    return (0U);
  }
#line 1544
  DELTA = (int )n - (int )m;
#line 1546
  if (W < (unsigned int )(.2 * (double )m + (double )1)) {
#line 1546
    MAX_D = (unsigned int )(.2 * (double )m + (double )1);
  } else {
#line 1546
    MAX_D = W;
  }
#line 1546
  max_d = MAX_D;
#line 1548
  if (DELTA < 0) {
#line 1549
    if ((double )W > ((double )1 + .2) * (double )n) {
#line 1549
      tmp___1 = ((double )1 + .2) * (double )n;
    } else {
#line 1549
      tmp___1 = (double )W;
    }
#line 1549
    if ((double )m <= tmp___1) {
      {
#line 1550
      tmp = new_exon(offset2 + 1U, offset1 + 1U, offset2 + n, offset1 + m);
#line 1550
      add_col_elt(eCol, (void *)tmp);
      }
#line 1553
      return ((m - n) + (unsigned int )(.2 * (double )n + (double )1));
    } else {
#line 1555
      if (W < (unsigned int )(.2 * (double )m + (double )1)) {
#line 1555
        tmp___0 = (unsigned int )(.2 * (double )m + (double )1);
      } else {
#line 1555
        tmp___0 = W;
      }
#line 1555
      return (tmp___0 + 1U);
    }
  }
#line 1559
  F_ORIGIN = (int )MAX_D;
#line 1560
  B_ORIGIN = (int )MAX_D - DELTA;
#line 1561
  row = (int )m;
#line 1561
  col = (int )n;
  {
#line 1561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1561
    if (row > 0) {
#line 1561
      if (col > 0) {
#line 1561
        if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 1561
          goto while_break;
        }
      } else {
#line 1561
        goto while_break;
      }
    } else {
#line 1561
      goto while_break;
    }
#line 1561
    row --;
#line 1561
    col --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1566
  if (row == 0) {
    {
#line 1568
    tmp___2 = new_exon(((offset2 - m) + n) + 1U, offset1 + 1U, offset2 + n, offset1 + m);
#line 1568
    add_col_elt(eCol, (void *)tmp___2);
    }
#line 1571
    return (0U);
  }
  {
#line 1574
  tmp___3 = xmalloc((unsigned long )((MAX_D + n) + 1U) * sizeof(int ));
#line 1574
  blast_d = (int *)tmp___3;
#line 1575
  tmp___4 = xmalloc((unsigned long )((MAX_D + n) + 1U) * sizeof(int ));
#line 1575
  btemp_d = (int *)tmp___4;
#line 1577
  i = 0U;
  }
  {
#line 1577
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1577
    if (! (i <= MAX_D + n)) {
#line 1577
      goto while_break___0;
    }
#line 1578
    *(blast_d + i) = (int )m + 1;
#line 1579
    *(btemp_d + i) = (int )m + 1;
#line 1577
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1581
  *(blast_d + (B_ORIGIN + DELTA)) = row;
#line 1583
  blower = (B_ORIGIN + DELTA) - 1;
#line 1584
  bupper = (B_ORIGIN + DELTA) + 1;
#line 1586
  row = 0;
  {
#line 1586
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1586
    if ((unsigned int )row < n) {
#line 1586
      if ((unsigned int )row < m) {
#line 1586
        if (! ((int )*(s1 + row) == (int )*(s2 + row))) {
#line 1586
          goto while_break___1;
        }
      } else {
#line 1586
        goto while_break___1;
      }
    } else {
#line 1586
      goto while_break___1;
    }
#line 1586
    row ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1593
  if ((unsigned int )row == m) {
    {
#line 1595
    tmp___5 = new_exon(offset2 + 1U, offset1 + 1U, offset2 + m, offset1 + m);
#line 1595
    add_col_elt(eCol, (void *)tmp___5);
#line 1598
    free((void *)blast_d);
#line 1599
    free((void *)btemp_d);
    }
#line 1600
    return (0U);
  }
  {
#line 1603
  tmp___6 = xmalloc((unsigned long )((MAX_D + n) + 1U) * sizeof(int ));
#line 1603
  flast_d = (int *)tmp___6;
#line 1604
  tmp___7 = xmalloc((unsigned long )((MAX_D + n) + 1U) * sizeof(int ));
#line 1604
  ftemp_d = (int *)tmp___7;
#line 1606
  i = 0U;
  }
  {
#line 1606
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1606
    if (! (i <= MAX_D + n)) {
#line 1606
      goto while_break___2;
    }
#line 1607
    *(flast_d + i) = -1;
#line 1608
    *(ftemp_d + i) = -1;
#line 1606
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1610
  *(flast_d + F_ORIGIN) = row;
#line 1612
  flower = F_ORIGIN - 1;
#line 1613
  fupper = F_ORIGIN + 1;
#line 1615
  tmp___8 = xmalloc((unsigned long )(MAX_D + 1U) * sizeof(int ));
#line 1615
  max_row = (int *)tmp___8;
#line 1616
  tmp___9 = xmalloc((unsigned long )(MAX_D + 1U) * sizeof(int ));
#line 1616
  min_row = (int *)tmp___9;
#line 1617
  tmp___10 = xmalloc((unsigned long )(MAX_D + 1U) * sizeof(int ));
#line 1617
  max_diag = (int *)tmp___10;
#line 1618
  tmp___11 = xmalloc((unsigned long )(MAX_D + 1U) * sizeof(int ));
#line 1618
  min_diag = (int *)tmp___11;
#line 1620
  d = 1U;
  }
  {
#line 1620
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1620
    if (! (d <= MAX_D)) {
#line 1620
      goto while_break___3;
    }
#line 1621
    *(min_row + d) = (int )m + 1;
#line 1622
    *(max_row + d) = -1;
#line 1620
    d ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1624
  *(min_row + 0) = *(blast_d + (B_ORIGIN + DELTA));
#line 1625
  *(min_diag + 0) = B_ORIGIN + DELTA;
#line 1626
  *(max_row + 0) = *(flast_d + F_ORIGIN);
#line 1627
  *(max_diag + 0) = F_ORIGIN;
#line 1629
  forth = -1;
#line 1629
  back = forth;
#line 1631
  d = 1U;
  {
#line 1632
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1632
    if (! (d <= max_d)) {
#line 1632
      goto while_break___4;
    }
#line 1635
    k = blower;
    {
#line 1635
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1635
      if (! (k <= bupper)) {
#line 1635
        goto while_break___5;
      }
#line 1639
      if (k == (- ((int )d) + DELTA) + B_ORIGIN) {
#line 1642
        row = *(blast_d + (k + 1));
      } else
#line 1643
      if (k == ((int )d + DELTA) + B_ORIGIN) {
#line 1646
        row = *(blast_d + (k - 1)) - 1;
      } else
#line 1647
      if (*(blast_d + k) <= *(blast_d + (k + 1))) {
#line 1647
        if (*(blast_d + k) - 1 <= *(blast_d + (k - 1))) {
#line 1651
          row = *(blast_d + k) - 1;
        } else {
#line 1647
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1653
      if (*(blast_d + (k - 1)) <= *(blast_d + (k + 1)) - 1) {
#line 1653
        if (*(blast_d + (k - 1)) <= *(blast_d + k) - 1) {
#line 1656
          row = *(blast_d + (k - 1)) - 1;
        } else {
#line 1659
          row = *(blast_d + (k + 1));
        }
      } else {
#line 1659
        row = *(blast_d + (k + 1));
      }
#line 1662
      col = (row + k) - B_ORIGIN;
      {
#line 1665
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1665
        if (row > 0) {
#line 1665
          if (col > 0) {
#line 1665
            if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 1665
              goto while_break___6;
            }
          } else {
#line 1665
            goto while_break___6;
          }
        } else {
#line 1665
          goto while_break___6;
        }
#line 1666
        row --;
#line 1667
        col --;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1669
      *(btemp_d + k) = row;
#line 1635
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1675
    *(min_row + d) = *(btemp_d + (DELTA + B_ORIGIN));
#line 1676
    *(min_diag + d) = DELTA + B_ORIGIN;
#line 1677
    k = blower;
    {
#line 1677
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1677
      if (! (k <= bupper)) {
#line 1677
        goto while_break___7;
      }
#line 1678
      *(blast_d + k) = *(btemp_d + k);
#line 1679
      *(btemp_d + k) = (int )m + 1;
#line 1680
      if (*(blast_d + k) < *(min_row + d)) {
#line 1681
        *(min_row + d) = *(blast_d + k);
#line 1682
        *(min_diag + d) = k;
      }
#line 1677
      k ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1688
    Cost = 0U;
    {
#line 1688
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1688
      if (! (Cost < d)) {
#line 1688
        goto while_break___8;
      }
#line 1689
      if (*(min_row + d) <= *(max_row + Cost)) {
#line 1689
        if (max_d > d + Cost) {
#line 1691
          max_d = d + Cost;
#line 1692
          back = (int )d;
#line 1693
          forth = (int )Cost;
#line 1694
          goto while_break___8;
        } else
#line 1689
        if (max_d == d + Cost) {
#line 1689
          if (forth < 0) {
#line 1691
            max_d = d + Cost;
#line 1692
            back = (int )d;
#line 1693
            forth = (int )Cost;
#line 1694
            goto while_break___8;
          }
        }
      }
#line 1688
      Cost ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1698
    blower --;
#line 1698
    bupper ++;
#line 1701
    k = flower;
    {
#line 1701
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1701
      if (! (k <= fupper)) {
#line 1701
        goto while_break___9;
      }
#line 1705
      if (k == - ((int )d) + F_ORIGIN) {
#line 1707
        row = *(flast_d + (k + 1)) + 1;
      } else
#line 1709
      if (k == (int )d + F_ORIGIN) {
#line 1711
        row = *(flast_d + (k - 1));
      } else
#line 1713
      if (*(flast_d + k) >= *(flast_d + (k + 1))) {
#line 1713
        if (*(flast_d + k) + 1 >= *(flast_d + (k - 1))) {
#line 1717
          row = *(flast_d + k) + 1;
        } else {
#line 1713
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1719
      if (*(flast_d + (k + 1)) + 1 >= *(flast_d + (k - 1))) {
#line 1719
        if (*(flast_d + (k + 1)) >= *(flast_d + k)) {
#line 1723
          row = *(flast_d + (k + 1)) + 1;
        } else {
#line 1726
          row = *(flast_d + (k - 1));
        }
      } else {
#line 1726
        row = *(flast_d + (k - 1));
      }
#line 1729
      col = (row + k) - F_ORIGIN;
#line 1732
      if (row >= 0) {
        {
#line 1733
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1733
          if ((unsigned int )row < m) {
#line 1733
            if ((unsigned int )col < n) {
#line 1733
              if (! ((int )*(s1 + row) == (int )*(s2 + col))) {
#line 1733
                goto while_break___10;
              }
            } else {
#line 1733
              goto while_break___10;
            }
          } else {
#line 1733
            goto while_break___10;
          }
#line 1736
          row ++;
#line 1737
          col ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 1739
      *(ftemp_d + k) = row;
#line 1701
      k ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1744
    *(max_row + d) = *(ftemp_d + F_ORIGIN);
#line 1745
    *(max_diag + d) = F_ORIGIN;
#line 1746
    k = flower;
    {
#line 1746
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1746
      if (! (k <= fupper)) {
#line 1746
        goto while_break___11;
      }
#line 1747
      *(flast_d + k) = *(ftemp_d + k);
#line 1748
      *(ftemp_d + k) = -1;
#line 1749
      if (*(flast_d + k) > *(max_row + d)) {
#line 1750
        *(max_row + d) = *(flast_d + k);
#line 1751
        *(max_diag + d) = k;
      }
#line 1746
      k ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1759
    Cost = 0U;
    {
#line 1759
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1759
      if (! (Cost <= d)) {
#line 1759
        goto while_break___12;
      }
#line 1760
      if (*(min_row + Cost) <= *(max_row + d)) {
#line 1760
        if (max_d > d + Cost) {
#line 1762
          max_d = d + Cost;
#line 1763
          back = (int )Cost;
#line 1764
          forth = (int )d;
#line 1765
          goto while_break___12;
        } else
#line 1760
        if (max_d == d + Cost) {
#line 1760
          if (forth < 0) {
#line 1762
            max_d = d + Cost;
#line 1763
            back = (int )Cost;
#line 1764
            forth = (int )d;
#line 1765
            goto while_break___12;
          }
        }
      }
#line 1759
      Cost ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1768
    flower --;
#line 1768
    fupper ++;
#line 1770
    d ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1773
  if (d > MAX_D) {
    {
#line 1774
    free((void *)blast_d);
#line 1774
    free((void *)btemp_d);
#line 1775
    free((void *)flast_d);
#line 1775
    free((void *)ftemp_d);
#line 1776
    free((void *)min_row);
#line 1776
    free((void *)min_diag);
#line 1777
    free((void *)max_row);
#line 1777
    free((void *)max_diag);
    }
#line 1779
    return (d);
  }
#line 1784
  if ((int )m - *(min_row + back) >= *(max_row + forth)) {
#line 1785
    p1 = (unsigned int )*(min_row + back);
#line 1786
    p2 = (unsigned int )((*(min_row + back) + *(max_diag + forth)) - F_ORIGIN);
#line 1787
    q1 = (unsigned int )*(min_row + back);
#line 1788
    q2 = (unsigned int )((*(min_row + back) + *(min_diag + back)) - B_ORIGIN);
  } else {
#line 1790
    p1 = (unsigned int )*(max_row + forth);
#line 1791
    p2 = (unsigned int )((*(max_row + forth) + *(max_diag + forth)) - F_ORIGIN);
#line 1792
    q1 = (unsigned int )*(max_row + forth);
#line 1793
    q2 = (unsigned int )((*(max_row + forth) + *(min_diag + back)) - B_ORIGIN);
  }
#line 1795
  if (! (q1 > 0U)) {
#line 1795
    if (! (p1 < m)) {
      {
#line 1795
      __assert_fail("q1 > 0 || p1 < m", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c",
                    1795U, "greedy");
      }
    }
  }
#line 1796
  if (q1 > 0U) {
    {
#line 1797
    tmp___12 = new_exon(offset2 + 1U, offset1 + 1U, offset2 + p2, offset1 + p1);
#line 1797
    add_col_elt(eCol, (void *)tmp___12);
    }
  }
#line 1800
  if (p1 < m) {
    {
#line 1801
    tmp___13 = new_exon((offset2 + q2) + 1U, (offset1 + q1) + 1U, offset2 + n, offset1 + m);
#line 1801
    add_col_elt(eCol, (void *)tmp___13);
    }
  }
  {
#line 1806
  free((void *)blast_d);
#line 1806
  free((void *)btemp_d);
#line 1807
  free((void *)flast_d);
#line 1807
  free((void *)ftemp_d);
#line 1808
  free((void *)min_row);
#line 1808
  free((void *)min_diag);
#line 1809
  free((void *)max_row);
#line 1809
  free((void *)max_diag);
  }
#line 1811
  if (! (back + forth >= 0)) {
    {
#line 1811
    __assert_fail("back + forth >= 0", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c",
                  1811U, "greedy");
    }
  }
#line 1812
  return ((unsigned int )(back + forth));
}
}
#line 1815 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int about_same_gap_p(unsigned int to1 , unsigned int nFrom1 , unsigned int to2 ,
                            unsigned int nFrom2 ) 
{ 
  unsigned int g1 ;
  unsigned int g2 ;
  unsigned int d ;
  unsigned int tem ;

  {
#line 1820
  if (nFrom1 <= to1) {
#line 1821
    return (0);
  } else
#line 1820
  if (nFrom2 <= to2) {
#line 1821
    return (0);
  }
#line 1822
  g1 = (nFrom1 - to1) - 1U;
#line 1823
  g2 = (nFrom2 - to2) - 1U;
#line 1824
  if (g2 > g1) {
#line 1825
    tem = g1;
#line 1826
    g1 = g2;
#line 1827
    g2 = tem;
  }
#line 1829
  d = g1 - g2;
#line 1830
  if (d < 30U) {
#line 1831
    return (1);
  } else
#line 1830
  if ((d * 100U) / g1 <= options.gapPct) {
#line 1831
    return (1);
  }
#line 1832
  return (0);
}
}
#line 1836 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void compact_exons(collec_p_t eCol , unsigned int W ) 
{ 
  unsigned int i ;
  exon_p_t cur ;
  exon_p_t next ;
  unsigned int diff ;
  exon_p_t cur___0 ;
  exon_p_t next___0 ;
  int tmp ;

  {
#line 1839
  i = 1U;
  {
#line 1841
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1841
    if (! (i < eCol->nb)) {
#line 1841
      goto while_break;
    }
#line 1842
    cur = *(eCol->e.exon + (i - 1U));
#line 1843
    next = *(eCol->e.exon + i);
#line 1844
    diff = next->from2 - cur->from2;
#line 1845
    if (diff <= options.intron_window) {
#line 1846
      (eCol->nb) --;
#line 1847
      if (cur->to2 > next->to2) {
        {
#line 1848
        free((void *)next);
#line 1849
        memmove((void *)(eCol->e.exon + i), (void const   *)((eCol->e.exon + i) + 1),
                (unsigned long )(eCol->nb - i) * sizeof(exon_p_t ));
        }
#line 1851
        if (i < eCol->nb) {
#line 1852
          next = *(eCol->e.exon + i);
#line 1853
          cur->to1 += diff;
#line 1854
          cur->to2 += diff;
#line 1855
          next->from1 -= diff;
#line 1856
          next->from2 -= diff;
        }
      } else {
        {
#line 1859
        free((void *)cur);
#line 1860
        memmove((void *)((eCol->e.exon + i) - 1), (void const   *)(eCol->e.exon + i),
                (unsigned long )((eCol->nb - i) + 1U) * sizeof(exon_p_t ));
        }
#line 1862
        if (i > 1U) {
#line 1863
          cur = *(eCol->e.exon + (i - 2U));
#line 1864
          cur->to1 += diff;
#line 1865
          cur->to2 += diff;
#line 1866
          next->from1 -= diff;
#line 1867
          next->from2 -= diff;
        }
      }
    } else {
#line 1871
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1873
  i = 1U;
  {
#line 1873
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1873
    if (! (i < eCol->nb)) {
#line 1873
      goto while_break___0;
    }
#line 1874
    cur___0 = *(eCol->e.exon + (i - 1U));
#line 1875
    next___0 = *(eCol->e.exon + i);
#line 1876
    if (next___0->from1 < (cur___0->to1 + 1U) + 30U) {
#line 1876
      if (next___0->from2 <= (cur___0->to2 + 1U) + W) {
#line 1876
        goto _L;
      } else {
#line 1876
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 1876
      tmp = about_same_gap_p(cur___0->to1, next___0->from1, cur___0->to2, next___0->from2);
      }
#line 1876
      if (tmp) {
        _L: /* CIL Label */ 
        {
#line 1881
        cur___0->to1 = next___0->to1;
#line 1882
        cur___0->to2 = next___0->to2;
#line 1883
        free((void *)next___0);
#line 1884
        (eCol->nb) --;
#line 1885
        memmove((void *)(eCol->e.elt + i), (void const   *)((eCol->e.elt + i) + 1),
                (unsigned long )(eCol->nb - i) * sizeof(void *));
#line 1887
        i --;
        }
      }
    }
#line 1873
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1890
  return;
}
}
#line 1892 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int good_ratio(int l , unsigned int W ) 
{ 
  unsigned int length ;

  {
#line 1895
  length = (unsigned int )l;
#line 1896
  if (! (l >= 0)) {
    {
#line 1896
    __assert_fail("l >= 0", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c",
                  1896U, "good_ratio");
    }
  }
#line 1897
  if (length <= W / 2U) {
#line 1897
    return (2);
  } else
#line 1898
  if (length < 2U * W) {
#line 1898
    return (options.cutoff);
  } else {
#line 1899
    return ((int )((.75 * .2) * (double )length + (double )1));
  }
}
}
#line 1902 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int extend_bw(uchar *s1 , uchar *s2 , int m , int n , int offset1 , int offset2 ,
                     int *line1 , int *line2 , unsigned int W ) 
{ 
  int col ;
  int row ;
  int max_d ;
  int d ;
  int k ;
  int DELTA ;
  int ORIGIN ;
  int lower ;
  int upper ;
  int *last_d ;
  int *temp_d ;
  int *min_row ;
  int *min_diag ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1919
  DELTA = n - m;
#line 1920
  max_d = m + 1;
#line 1922
  ORIGIN = m;
#line 1923
  row = m;
#line 1923
  col = n;
  {
#line 1923
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1923
    if (row > 0) {
#line 1923
      if (col > 0) {
#line 1923
        if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 1923
          goto while_break;
        }
      } else {
#line 1923
        goto while_break;
      }
    } else {
#line 1923
      goto while_break;
    }
#line 1923
    row --;
#line 1923
    col --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1926
  if (row == 0) {
#line 1927
    *line1 = row + offset1;
#line 1928
    *line2 = col + offset2;
#line 1930
    return (0);
  } else
#line 1926
  if (col == 0) {
#line 1927
    *line1 = row + offset1;
#line 1928
    *line2 = col + offset2;
#line 1930
    return (0);
  }
  {
#line 1933
  tmp = xmalloc((size_t )((m + n) + 1) * sizeof(int ));
#line 1933
  last_d = (int *)tmp;
#line 1934
  tmp___0 = xmalloc((size_t )((m + n) + 1) * sizeof(int ));
#line 1934
  temp_d = (int *)tmp___0;
#line 1936
  k = 0;
  }
  {
#line 1936
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1936
    if (! (k <= m + n)) {
#line 1936
      goto while_break___0;
    }
#line 1936
    *(last_d + k) = m + 1;
#line 1936
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1937
  *(last_d + (ORIGIN + DELTA)) = row;
#line 1939
  lower = (ORIGIN + DELTA) - 1;
#line 1940
  upper = (ORIGIN + DELTA) + 1;
#line 1942
  tmp___1 = xmalloc((size_t )(m + 1) * sizeof(int ));
#line 1942
  min_row = (int *)tmp___1;
#line 1943
  tmp___2 = xmalloc((size_t )(m + 1) * sizeof(int ));
#line 1943
  min_diag = (int *)tmp___2;
#line 1945
  d = 1;
  }
  {
#line 1945
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1945
    if (! (d <= m)) {
#line 1945
      goto while_break___1;
    }
#line 1946
    *(min_row + d) = m + 1;
#line 1945
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1948
  *(min_row + 0) = *(last_d + (ORIGIN + DELTA));
#line 1949
  *(min_diag + 0) = ORIGIN + DELTA;
#line 1951
  d = 0;
  {
#line 1952
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1952
    d ++;
#line 1952
    if (d <= max_d) {
      {
#line 1952
      tmp___3 = good_ratio(m - *(min_row + (d - 1)), W);
      }
#line 1952
      if (! (d - 1 <= tmp___3)) {
#line 1952
        if (d >= 2) {
          {
#line 1952
          tmp___4 = good_ratio(m - *(min_row + (d - 2)), W);
          }
#line 1952
          if (! (d - 2 <= tmp___4)) {
#line 1952
            goto while_break___2;
          }
        } else {
#line 1952
          goto while_break___2;
        }
      }
    } else {
#line 1952
      goto while_break___2;
    }
#line 1957
    k = lower;
    {
#line 1957
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1957
      if (! (k <= upper)) {
#line 1957
        goto while_break___3;
      }
#line 1960
      if (k == (- d + DELTA) + ORIGIN) {
#line 1962
        row = *(last_d + (k + 1));
      } else
#line 1965
      if (k == (d + DELTA) + ORIGIN) {
#line 1967
        row = *(last_d + (k - 1)) - 1;
      } else
#line 1970
      if (*(last_d + k) - 1 <= *(last_d + (k + 1))) {
#line 1970
        if (*(last_d + k) - 1 <= *(last_d + (k - 1)) - 1) {
#line 1973
          row = *(last_d + k) - 1;
        } else {
#line 1970
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1976
      if (*(last_d + (k - 1)) - 1 <= *(last_d + (k + 1))) {
#line 1976
        if (*(last_d + (k - 1)) - 1 <= *(last_d + k) - 1) {
#line 1979
          row = *(last_d + (k - 1)) - 1;
        } else {
#line 1984
          row = *(last_d + (k + 1));
        }
      } else {
#line 1984
        row = *(last_d + (k + 1));
      }
#line 1992
      col = (row + k) - ORIGIN;
      {
#line 1994
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1994
        if (row > 0) {
#line 1994
          if (col > 0) {
#line 1994
            if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 1994
              goto while_break___4;
            }
          } else {
#line 1994
            goto while_break___4;
          }
        } else {
#line 1994
          goto while_break___4;
        }
#line 1995
        row --;
#line 1995
        col --;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1998
      *(temp_d + k) = row;
#line 2000
      if (row == 0) {
#line 2000
        if (col == 0) {
          {
#line 2003
          free((void *)last_d);
#line 2003
          free((void *)temp_d);
#line 2004
          free((void *)min_row);
#line 2004
          free((void *)min_diag);
#line 2006
          *line1 = row + offset1;
#line 2007
          *line2 = col + offset2;
          }
#line 2009
          return (d);
        }
      }
#line 2011
      if (row == 0) {
        {
#line 2014
        free((void *)last_d);
#line 2014
        free((void *)temp_d);
#line 2015
        free((void *)min_row);
#line 2015
        free((void *)min_diag);
#line 2017
        *line1 = row + offset1;
#line 2018
        *line2 = col + offset2;
        }
#line 2020
        return (d);
      }
#line 2023
      if (col == 0) {
        {
#line 2025
        free((void *)last_d);
#line 2025
        free((void *)temp_d);
#line 2026
        free((void *)min_row);
#line 2026
        free((void *)min_diag);
#line 2028
        *line1 = row + offset1;
#line 2029
        *line2 = col + offset2;
        }
#line 2031
        return (d);
      }
#line 1957
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2035
    *(min_row + d) = *(last_d + (ORIGIN + DELTA));
#line 2036
    *(min_diag + d) = ORIGIN + DELTA;
#line 2037
    k = lower;
    {
#line 2037
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2037
      if (! (k <= upper)) {
#line 2037
        goto while_break___5;
      }
#line 2038
      if (*(temp_d + k) < *(min_row + d)) {
#line 2039
        *(min_row + d) = *(temp_d + k);
#line 2040
        *(min_diag + d) = k;
      }
#line 2037
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2043
    k = lower;
    {
#line 2043
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2043
      if (! (k <= upper)) {
#line 2043
        goto while_break___6;
      }
#line 2044
      *(last_d + k) = *(temp_d + k);
#line 2043
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2047
    lower --;
#line 2048
    upper ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2052
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2052
    if (d > 0) {
#line 2052
      if (! (*(min_row + (d - 1)) - *(min_row + d) < 3)) {
#line 2052
        goto while_break___7;
      }
    } else {
#line 2052
      goto while_break___7;
    }
#line 2053
    d --;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 2055
  *line1 = *(min_row + d) + offset1;
#line 2056
  *line2 = ((*(min_row + d) + *(min_diag + d)) - ORIGIN) + offset2;
#line 2058
  free((void *)min_row);
#line 2059
  free((void *)min_diag);
#line 2060
  free((void *)last_d);
#line 2061
  free((void *)temp_d);
  }
#line 2063
  return (d);
}
}
#line 2067 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int extend_fw(uchar *s1 , uchar *s2 , int m , int n , int offset1 , int offset2 ,
                     int *line1 , int *line2 , unsigned int W ) 
{ 
  int col ;
  int row ;
  int max_d ;
  int d ;
  int k ;
  int ORIGIN ;
  int lower ;
  int upper ;
  int *last_d ;
  int *temp_d ;
  int *max_row ;
  int *max_diag ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2083
  max_d = m + 1;
#line 2085
  ORIGIN = m;
#line 2086
  row = 0;
#line 2086
  col = 0;
  {
#line 2086
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2086
    if (col < n) {
#line 2086
      if (row < m) {
#line 2086
        if (! ((int )*(s1 + row) == (int )*(s2 + col))) {
#line 2086
          goto while_break;
        }
      } else {
#line 2086
        goto while_break;
      }
    } else {
#line 2086
      goto while_break;
    }
#line 2086
    row ++;
#line 2086
    col ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2089
  if (row == m) {
#line 2090
    *line1 = row + offset1;
#line 2091
    *line2 = col + offset2;
#line 2093
    return (0);
  }
#line 2095
  if (col == n) {
#line 2096
    *line1 = row + offset1;
#line 2097
    *line2 = col + offset2;
#line 2099
    return (0);
  }
  {
#line 2102
  tmp = xmalloc((size_t )((m + n) + 1) * sizeof(int ));
#line 2102
  last_d = (int *)tmp;
#line 2103
  tmp___0 = xmalloc((size_t )((m + n) + 1) * sizeof(int ));
#line 2103
  temp_d = (int *)tmp___0;
#line 2105
  k = 0;
  }
  {
#line 2105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2105
    if (! (k <= m + n)) {
#line 2105
      goto while_break___0;
    }
#line 2105
    *(last_d + k) = -1;
#line 2105
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2106
  *(last_d + ORIGIN) = row;
#line 2108
  lower = ORIGIN - 1;
#line 2109
  upper = ORIGIN + 1;
#line 2111
  tmp___1 = xmalloc((size_t )(m + 1) * sizeof(int ));
#line 2111
  max_row = (int *)tmp___1;
#line 2112
  tmp___2 = xmalloc((size_t )(m + 1) * sizeof(int ));
#line 2112
  max_diag = (int *)tmp___2;
#line 2114
  d = 1;
  }
  {
#line 2114
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2114
    if (! (d <= m)) {
#line 2114
      goto while_break___1;
    }
#line 2115
    *(max_row + d) = -1;
#line 2114
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2117
  *(max_row + 0) = *(last_d + ORIGIN);
#line 2118
  *(max_diag + 0) = ORIGIN;
#line 2120
  d = 0;
  {
#line 2121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2121
    d ++;
#line 2121
    if (d <= max_d) {
      {
#line 2121
      tmp___3 = good_ratio(*(max_row + (d - 1)), W);
      }
#line 2121
      if (! (d - 1 <= tmp___3)) {
#line 2121
        if (d >= 2) {
          {
#line 2121
          tmp___4 = good_ratio(*(max_row + (d - 2)), W);
          }
#line 2121
          if (! (d - 2 <= tmp___4)) {
#line 2121
            goto while_break___2;
          }
        } else {
#line 2121
          goto while_break___2;
        }
      }
    } else {
#line 2121
      goto while_break___2;
    }
#line 2126
    k = lower;
    {
#line 2126
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2126
      if (! (k <= upper)) {
#line 2126
        goto while_break___3;
      }
#line 2129
      if (k == - d + ORIGIN) {
#line 2132
        row = *(last_d + (k + 1)) + 1;
      } else
#line 2134
      if (k == d + ORIGIN) {
#line 2137
        row = *(last_d + (k - 1));
      } else
#line 2139
      if (*(last_d + k) >= *(last_d + (k + 1))) {
#line 2139
        if (*(last_d + k) + 1 >= *(last_d + (k - 1))) {
#line 2143
          row = *(last_d + k) + 1;
        } else {
#line 2139
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2145
      if (*(last_d + (k + 1)) + 1 >= *(last_d + (k - 1))) {
#line 2145
        if (*(last_d + (k + 1)) >= *(last_d + k)) {
#line 2149
          row = *(last_d + (k + 1)) + 1;
        } else {
#line 2154
          row = *(last_d + (k - 1));
        }
      } else {
#line 2154
        row = *(last_d + (k - 1));
      }
#line 2161
      col = (row + k) - ORIGIN;
#line 2163
      if (row >= 0) {
        {
#line 2164
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2164
          if (row < m) {
#line 2164
            if (col < n) {
#line 2164
              if (! ((int )*(s1 + row) == (int )*(s2 + col))) {
#line 2164
                goto while_break___4;
              }
            } else {
#line 2164
              goto while_break___4;
            }
          } else {
#line 2164
            goto while_break___4;
          }
#line 2165
          row ++;
#line 2165
          col ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 2168
      *(temp_d + k) = row;
#line 2170
      if (row == m) {
#line 2170
        if (col == n) {
          {
#line 2172
          free((void *)last_d);
#line 2172
          free((void *)temp_d);
#line 2173
          free((void *)max_row);
#line 2173
          free((void *)max_diag);
#line 2174
          *line1 = row + offset1;
#line 2175
          *line2 = col + offset2;
          }
#line 2176
          return (d);
        }
      }
#line 2178
      if (row == m) {
        {
#line 2180
        free((void *)temp_d);
#line 2180
        free((void *)last_d);
#line 2181
        free((void *)max_row);
#line 2181
        free((void *)max_diag);
#line 2182
        *line1 = row + offset1;
#line 2183
        *line2 = col + offset2;
        }
#line 2184
        return (d);
      }
#line 2187
      if (col == n) {
        {
#line 2189
        free((void *)temp_d);
#line 2189
        free((void *)last_d);
#line 2190
        free((void *)max_row);
#line 2190
        free((void *)max_diag);
#line 2191
        *line1 = row + offset1;
#line 2192
        *line2 = col + offset2;
        }
#line 2193
        return (d);
      }
#line 2126
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2196
    *(max_row + d) = *(last_d + ORIGIN);
#line 2197
    *(max_diag + d) = ORIGIN;
#line 2198
    k = lower;
    {
#line 2198
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2198
      if (! (k <= upper)) {
#line 2198
        goto while_break___5;
      }
#line 2199
      if (*(temp_d + k) > *(max_row + d)) {
#line 2200
        *(max_row + d) = *(temp_d + k);
#line 2201
        *(max_diag + d) = k;
      }
#line 2198
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2204
    k = lower;
    {
#line 2204
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2204
      if (! (k <= upper)) {
#line 2204
        goto while_break___6;
      }
#line 2205
      *(last_d + k) = *(temp_d + k);
#line 2204
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2208
    lower --;
#line 2209
    upper ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2214
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2214
    if (d > 0) {
#line 2214
      if (! (*(max_row + d) - *(max_row + (d - 1)) < 3)) {
#line 2214
        goto while_break___7;
      }
    } else {
#line 2214
      goto while_break___7;
    }
#line 2215
    d --;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 2217
  *line1 = *(max_row + d) + offset1;
#line 2218
  *line2 = ((*(max_row + d) + *(max_diag + d)) - ORIGIN) + offset2;
#line 2219
  free((void *)max_row);
#line 2220
  free((void *)max_diag);
#line 2221
  free((void *)last_d);
#line 2222
  free((void *)temp_d);
  }
#line 2223
  return (d);
}
}
#line 2248 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void swap_seqs(collec_p_t eCol ) 
{ 
  unsigned int i ;
  exon_p_t e ;
  unsigned int tem ;

  {
#line 2252
  i = 0U;
  {
#line 2252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2252
    if (! (i < eCol->nb)) {
#line 2252
      goto while_break;
    }
#line 2253
    e = *(eCol->e.exon + i);
#line 2254
    tem = e->from1;
#line 2255
    e->from1 = e->from2;
#line 2256
    e->from2 = tem;
#line 2257
    tem = e->to1;
#line 2258
    e->to1 = e->to2;
#line 2259
    e->to2 = tem;
#line 2252
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2261
  return;
}
}
#line 2263 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void merge(collec_p_t eCol , collec_p_t aCol , unsigned int pos , unsigned int W ) 
{ 
  unsigned int last ;
  unsigned int i ;
  void *tmp ;
  exon_p_t cur ;
  exon_p_t next ;

  {
#line 2266
  last = pos + aCol->nb;
#line 2268
  if (aCol->nb == 0U) {
#line 2269
    return;
  }
#line 2271
  if (eCol->nb + aCol->nb > eCol->size) {
    {
#line 2272
    eCol->size = eCol->nb + aCol->nb;
#line 2273
    tmp = xrealloc((void *)eCol->e.elt, (unsigned long )eCol->size * sizeof(void *));
#line 2273
    eCol->e.elt = (void **)tmp;
    }
  }
  {
#line 2276
  memmove((void *)(eCol->e.elt + last), (void const   *)(eCol->e.elt + pos), (unsigned long )(eCol->nb - pos) * sizeof(void *));
#line 2278
  memcpy((void */* __restrict  */)(eCol->e.elt + pos), (void const   */* __restrict  */)aCol->e.elt,
         (unsigned long )aCol->nb * sizeof(void *));
#line 2279
  eCol->nb += aCol->nb;
  }
#line 2280
  if (last < eCol->nb) {
#line 2281
    last ++;
  }
#line 2282
  if (pos == 0U) {
#line 2283
    pos ++;
  }
#line 2284
  i = pos;
  {
#line 2284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2284
    if (! (i < last)) {
#line 2284
      goto while_break;
    }
#line 2285
    cur = *(eCol->e.exon + (i - 1U));
#line 2286
    next = *(eCol->e.exon + i);
#line 2288
    if (next->from2 <= cur->from2) {
      {
#line 2289
      free((void *)cur);
#line 2290
      memmove((void *)((eCol->e.elt + i) - 1), (void const   *)(eCol->e.elt + i),
              (unsigned long )(eCol->nb - i) * sizeof(void *));
#line 2292
      (eCol->nb) --;
#line 2293
      last --;
#line 2294
      i --;
      }
#line 2295
      goto __Cont;
    }
#line 2297
    if (cur->to2 >= next->to2) {
      {
#line 2298
      free((void *)next);
#line 2299
      (eCol->nb) --;
#line 2300
      memmove((void *)(eCol->e.elt + i), (void const   *)((eCol->e.elt + i) + 1),
              (unsigned long )(eCol->nb - i) * sizeof(void *));
#line 2302
      last --;
#line 2303
      i --;
      }
#line 2304
      goto __Cont;
    }
#line 2306
    if (next->from1 < (cur->to1 + 1U) + 30U) {
#line 2306
      if (next->from2 <= (cur->to2 + 1U) + W) {
#line 2309
        if (cur->from1 > next->from1) {
#line 2309
          cur->from1 = next->from1;
        } else {
#line 2309
          cur->from1 = cur->from1;
        }
#line 2310
        if (cur->from2 > next->from2) {
#line 2310
          cur->from2 = next->from2;
        } else {
#line 2310
          cur->from2 = cur->from2;
        }
#line 2311
        if (next->to1 < cur->to1) {
#line 2311
          cur->to1 = cur->to1;
        } else {
#line 2311
          cur->to1 = next->to1;
        }
#line 2312
        if (next->to2 < cur->to2) {
#line 2312
          cur->to2 = cur->to2;
        } else {
#line 2312
          cur->to2 = next->to2;
        }
        {
#line 2313
        free((void *)next);
#line 2314
        (eCol->nb) --;
#line 2315
        memmove((void *)(eCol->e.elt + i), (void const   *)((eCol->e.elt + i) + 1),
                (unsigned long )(eCol->nb - i) * sizeof(void *));
#line 2317
        last --;
#line 2318
        i --;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2284
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2321
  return;
}
}
#line 2323 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
void free_align(edit_script_list_p_t aligns ) 
{ 
  edit_script_list_p_t head ;

  {
#line 2328
  head = aligns;
  {
#line 2330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2330
    head = aligns;
#line 2330
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 2330
      goto while_break;
    }
    {
#line 2331
    aligns = aligns->next_script;
#line 2332
    Free_script(head->script);
#line 2333
    free((void *)head);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2335
  return;
}
}
#line 2378 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int perfect_spl_p(uchar *seq1 , uchar *seq2 , splice_score_p_t splS ) 
{ 
  unsigned int score ;
  unsigned int j ;
  uchar splice[4] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2383
  score = SWscore((seq1 + splS->to1) - options.scoreSplice_window, (seq2 + splS->to2) - options.scoreSplice_window,
                  options.scoreSplice_window);
  }
#line 2386
  if (score < options.scoreSplice_window) {
#line 2387
    return (0);
  }
  {
#line 2388
  score = SWscore((seq1 + splS->nFrom1) - 1, seq2 + splS->to2, options.scoreSplice_window);
  }
#line 2390
  if (score < options.scoreSplice_window) {
#line 2391
    return (0);
  }
  {
#line 2392
  memcpy((void */* __restrict  */)(splice), (void const   */* __restrict  */)(seq1 + splS->to1),
         2UL);
#line 2393
  memcpy((void */* __restrict  */)(splice + 2), (void const   */* __restrict  */)((seq1 + splS->nFrom1) - 3),
         2UL);
#line 2394
  j = 0U;
  }
  {
#line 2394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2394
    if (! (j < options.nbSplice)) {
#line 2394
      goto while_break;
    }
    {
#line 2395
    tmp = memcmp((void const   *)(splice), (void const   *)((options.splice + j)->fwd),
                 4UL);
    }
#line 2395
    if (tmp == 0) {
#line 2396
      splS->type = (int )j;
#line 2397
      splS->direction = 1;
#line 2398
      return (1);
    }
    {
#line 2400
    tmp___0 = memcmp((void const   *)(splice), (void const   *)((options.splice + j)->rev),
                     4UL);
    }
#line 2400
    if (tmp___0 == 0) {
#line 2401
      splS->type = (int )j;
#line 2402
      splS->direction = -1;
#line 2403
      return (1);
    }
#line 2394
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2406
  return (0);
}
}
#line 2409 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static int splice_score_compare(void const   *a , void const   *b ) 
{ 
  splice_score_p_t sa ;
  splice_score_p_t sb ;
  unsigned int adj_score_a ;
  unsigned int adj_score_b ;
  int tmp ;
  int tmp___0 ;

  {
#line 2412
  sa = (splice_score_p_t )a;
#line 2413
  sb = (splice_score_p_t )b;
#line 2414
  adj_score_a = sa->score + sa->splScore;
#line 2415
  adj_score_b = sb->score + sb->splScore;
#line 2416
  if (sa->type < sb->type) {
#line 2416
    tmp = 1;
  } else {
#line 2416
    tmp = 0;
  }
#line 2416
  adj_score_a += (unsigned int )tmp;
#line 2417
  if (sb->type < sa->type) {
#line 2417
    tmp___0 = 1;
  } else {
#line 2417
    tmp___0 = 0;
  }
#line 2417
  adj_score_b += (unsigned int )tmp___0;
#line 2418
  if (adj_score_a < adj_score_b) {
#line 2419
    return (-1);
  }
#line 2420
  if (adj_score_a > adj_score_b) {
#line 2421
    return (1);
  }
#line 2422
  if (sa->splScore < sb->splScore) {
#line 2423
    return (-1);
  }
#line 2424
  if (sa->splScore > sb->splScore) {
#line 2425
    return (1);
  }
#line 2426
  if (sa->type > sb->type) {
#line 2427
    return (-1);
  }
#line 2428
  if (sa->type < sb->type) {
#line 2429
    return (1);
  }
#line 2430
  return (0);
}
}
#line 2433 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void compute_max_score_1(uchar *seq1 , uchar *seq2 , splice_score_p_t splS ,
                                int type , unsigned int to1 , unsigned int to2 , unsigned int nFrom1 ,
                                uchar *s , uchar *jct , int dir ) 
{ 
  int j ;
  splice_score_t curL ;
  splice_score_t curR ;
  int i ;
  splice_score_t cur ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2440
  memcpy((void */* __restrict  */)(s + options.scoreSplice_window), (void const   */* __restrict  */)jct,
         4UL);
#line 2441
  j = - ((int )options.intron_window);
  }
  {
#line 2441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2441
    if (! (j <= (int )options.intron_window)) {
#line 2441
      goto while_break;
    }
    {
#line 2444
    curR.type = type;
#line 2444
    curL.type = curR.type;
#line 2445
    curR.splScore = 0U;
#line 2445
    curL.splScore = curR.splScore;
#line 2446
    curR.score = 0U;
#line 2446
    curL.score = curR.score;
#line 2447
    memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)(((seq2 + to2) - options.scoreSplice_window) + j),
           (size_t )options.scoreSplice_window);
#line 2449
    memcpy((void */* __restrict  */)((s + options.scoreSplice_window) + 4), (void const   */* __restrict  */)((seq2 + to2) + j),
           (size_t )options.scoreSplice_window);
#line 2451
    i = - ((int )options.spliceInDel);
    }
    {
#line 2451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2451
      if (! (i <= (int )options.spliceInDel)) {
#line 2451
        goto while_break___0;
      }
#line 2453
      cur.type = type;
#line 2454
      cur.splScore = 0U;
#line 2455
      if ((int )*(seq1 + (((int )to1 + j) + i)) == (int )*(jct + 0)) {
#line 2456
        (cur.splScore) ++;
      }
#line 2457
      if ((int )*(seq1 + ((((int )to1 + j) + i) + 1)) == (int )*(jct + 1)) {
#line 2458
        (cur.splScore) ++;
      }
      {
#line 2459
      cur.score = SWscore((((seq1 + to1) - options.scoreSplice_window) + j) + i, s,
                          options.scoreSplice_window + 2U);
#line 2471
      tmp = splice_score_compare((void const   *)(& cur), (void const   *)(& curL));
      }
#line 2471
      if (tmp > 0) {
#line 2472
        curL.score = cur.score;
#line 2473
        curL.splScore = cur.splScore;
#line 2474
        curL.to1 = (unsigned int )(((int )to1 + j) + i);
      }
#line 2476
      cur.splScore = 0U;
#line 2477
      if ((int )*(seq1 + ((((int )nFrom1 - 3) + j) + i)) == (int )*(jct + 2)) {
#line 2478
        (cur.splScore) ++;
      }
#line 2479
      if ((int )*(seq1 + ((((int )nFrom1 - 2) + j) + i)) == (int )*(jct + 3)) {
#line 2480
        (cur.splScore) ++;
      }
      {
#line 2481
      cur.score = SWscore((((seq1 + nFrom1) - 3) + j) + i, (s + options.scoreSplice_window) + 2,
                          options.scoreSplice_window + 2U);
#line 2492
      tmp___0 = splice_score_compare((void const   *)(& cur), (void const   *)(& curR));
      }
#line 2492
      if (tmp___0 > 0) {
#line 2493
        curR.score = cur.score;
#line 2494
        curR.splScore = cur.splScore;
#line 2495
        curR.nFrom1 = (unsigned int )(((int )nFrom1 + j) + i);
      }
#line 2451
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2502
    curL.score += curR.score;
#line 2503
    curL.splScore += curR.splScore;
#line 2504
    tmp___1 = splice_score_compare((void const   *)(& curL), (void const   *)splS);
    }
#line 2504
    if (tmp___1 > 0) {
#line 2505
      splS->score = curL.score;
#line 2506
      splS->splScore = curL.splScore;
#line 2507
      splS->to1 = curL.to1;
#line 2508
      splS->to2 = (unsigned int )((int )to2 + j);
#line 2509
      splS->nFrom1 = curR.nFrom1;
#line 2510
      splS->type = type;
#line 2511
      splS->direction = dir;
    }
#line 2441
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2517
  return;
}
}
#line 2521 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void compute_max_score(uchar *seq1 , uchar *seq2 , splice_score_p_t splS ,
                              int direction ) 
{ 
  int k ;
  unsigned int to1 ;
  unsigned int to2 ;
  unsigned int nFrom1 ;
  uchar *s ;
  void *tmp ;

  {
  {
#line 2526
  to1 = splS->to1;
#line 2527
  to2 = splS->to2;
#line 2528
  nFrom1 = splS->nFrom1;
#line 2529
  tmp = xmalloc((unsigned long )(options.scoreSplice_window * 2U + 4U) * sizeof(uchar ));
#line 2529
  s = (uchar *)tmp;
#line 2531
  splS->score = 0U;
#line 2532
  splS->splScore = 0U;
#line 2533
  splS->type = -1;
#line 2534
  k = 0;
  }
  {
#line 2534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2534
    if (! (k < (int )options.nbSplice)) {
#line 2534
      goto while_break;
    }
#line 2538
    if (direction >= 0) {
      {
#line 2539
      compute_max_score_1(seq1, seq2, splS, k, to1, to2, nFrom1, s, (options.splice + k)->fwd,
                          1);
      }
    }
#line 2541
    if (direction <= 0) {
      {
#line 2542
      compute_max_score_1(seq1, seq2, splS, k, to1, to2, nFrom1, s, (options.splice + k)->rev,
                          -1);
      }
    }
#line 2534
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2545
  free((void *)s);
  }
#line 2546
  return;
}
}
#line 2548 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static void slide_intron(result_p_t r , uchar *seq1 , uchar *seq2 ) 
{ 
  unsigned int i ;
  exon_p_t cur ;
  exon_p_t next ;
  splice_score_t splS ;
  int tmp ;
  exon_p_t cur___0 ;
  exon_p_t next___0 ;
  splice_score_p_t splS___0 ;
  unsigned int nb ;
  unsigned int j ;
  unsigned int nbP ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned int fwd ;
  unsigned int rev ;
  exon_p_t cur___1 ;
  exon_p_t next___1 ;
  splice_score_t max ;
  splice_score_t cs ;
  unsigned int nb___0 ;
  unsigned int j___0 ;
  int tmp___2 ;
  exon_p_t cur___2 ;
  exon_p_t next___2 ;
  splice_score_t max___0 ;
  splice_score_t cs___0 ;
  unsigned int nb___1 ;
  unsigned int j___1 ;
  int tmp___3 ;

  {
#line 2554
  i = 1U;
  {
#line 2554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2554
    if (! (i < r->eCol.nb)) {
#line 2554
      goto while_break;
    }
#line 2555
    cur = *(r->eCol.e.exon + (i - 1U));
#line 2556
    next = *(r->eCol.e.exon + i);
#line 2558
    cur->type = -1;
#line 2559
    cur->direction = 0;
#line 2560
    cur->splScore = 0U;
#line 2561
    if (next->from2 - cur->to2 != 1U) {
#line 2562
      goto __Cont;
    }
    {
#line 2563
    splS.to1 = cur->to1;
#line 2564
    splS.to2 = cur->to2;
#line 2565
    splS.nFrom1 = next->from1;
#line 2566
    tmp = perfect_spl_p(seq1, seq2, & splS);
    }
#line 2566
    if (tmp) {
#line 2567
      r->direction += splS.direction;
#line 2568
      cur->direction = splS.direction;
#line 2569
      cur->type = (int )((char )splS.type);
#line 2570
      cur->splScore = 4U + options.scoreSplice_window * 2U;
    }
    __Cont: /* CIL Label */ 
#line 2554
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2574
  i = 1U;
  {
#line 2574
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2574
    if (! (i < r->eCol.nb)) {
#line 2574
      goto while_break___0;
    }
#line 2575
    cur___0 = *(r->eCol.e.exon + (i - 1U));
#line 2576
    next___0 = *(r->eCol.e.exon + i);
#line 2578
    nbP = 0U;
#line 2579
    if (next___0->from2 > cur___0->to2) {
#line 2580
      goto __Cont___0;
    }
    {
#line 2581
    nb = (cur___0->to2 - next___0->from2) + 2U;
#line 2582
    tmp___0 = xmalloc((unsigned long )nb * sizeof(splice_score_t ));
#line 2582
    splS___0 = (splice_score_p_t )tmp___0;
#line 2583
    j = 0U;
    }
    {
#line 2583
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2583
      if (! (j < nb)) {
#line 2583
        goto while_break___1;
      }
      {
#line 2584
      (splS___0 + j)->to1 = ((cur___0->to1 - nb) + j) + 1U;
#line 2585
      (splS___0 + j)->to2 = ((cur___0->to2 - nb) + j) + 1U;
#line 2586
      (splS___0 + j)->nFrom1 = next___0->from1 + j;
#line 2587
      tmp___1 = perfect_spl_p(seq1, seq2, splS___0 + j);
      }
#line 2587
      if (tmp___1) {
#line 2588
        nbP ++;
      } else {
#line 2590
        (splS___0 + j)->direction = 0;
      }
#line 2583
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2592
    if (nbP == 1U) {
#line 2593
      j = 0U;
      {
#line 2593
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2593
        if (! (j < nb)) {
#line 2593
          goto while_break___2;
        }
#line 2594
        if ((splS___0 + j)->direction != 0) {
#line 2595
          r->direction += (splS___0 + j)->direction;
#line 2596
          cur___0->direction = (splS___0 + j)->direction;
#line 2597
          cur___0->type = (int )((char )(splS___0 + j)->type);
#line 2598
          cur___0->splScore = 4U + options.scoreSplice_window * 2U;
#line 2599
          cur___0->to1 = (splS___0 + j)->to1;
#line 2600
          cur___0->to2 = (splS___0 + j)->to2;
#line 2601
          next___0->from2 = cur___0->to2 + 1U;
#line 2602
          next___0->from1 = (splS___0 + j)->nFrom1;
        }
#line 2593
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 2604
    free((void *)splS___0);
    }
    __Cont___0: /* CIL Label */ 
#line 2574
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2607
  if (r->direction == 0) {
#line 2608
    fwd = 0U;
#line 2608
    rev = 0U;
#line 2609
    i = 1U;
    {
#line 2609
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2609
      if (! (i < r->eCol.nb)) {
#line 2609
        goto while_break___3;
      }
#line 2610
      cur___1 = *(r->eCol.e.exon + (i - 1U));
#line 2611
      next___1 = *(r->eCol.e.exon + i);
#line 2614
      if (cur___1->to2 + 1U < next___1->from2) {
#line 2615
        goto __Cont___1;
      }
#line 2616
      if (cur___1->direction > 0) {
#line 2617
        fwd += cur___1->splScore;
#line 2618
        goto __Cont___1;
      }
#line 2620
      if (cur___1->direction < 0) {
#line 2621
        rev += cur___1->splScore;
#line 2622
        goto __Cont___1;
      }
#line 2624
      nb___0 = (cur___1->to2 - next___1->from2) + 2U;
#line 2625
      max.type = -1;
#line 2626
      max.score = 0U;
#line 2627
      max.splScore = 0U;
#line 2628
      j___0 = 0U;
      {
#line 2628
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2628
        if (! (j___0 < nb___0)) {
#line 2628
          goto while_break___4;
        }
        {
#line 2629
        cs.to1 = ((cur___1->to1 - nb___0) + j___0) + 1U;
#line 2630
        cs.to2 = ((cur___1->to2 - nb___0) + j___0) + 1U;
#line 2631
        cs.nFrom1 = next___1->from1 + j___0;
#line 2632
        compute_max_score(seq1, seq2, & cs, 0);
#line 2633
        tmp___2 = splice_score_compare((void const   *)(& cs), (void const   *)(& max));
        }
#line 2633
        if (tmp___2 > 0) {
#line 2634
          max = cs;
        }
#line 2628
        j___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2636
      if (max.direction > 0) {
#line 2637
        fwd += max.score;
      }
#line 2638
      if (max.direction < 0) {
#line 2639
        rev += max.score;
      }
      __Cont___1: /* CIL Label */ 
#line 2609
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2641
    if (fwd >= rev) {
#line 2642
      r->direction = 1;
    } else {
#line 2644
      r->direction = -1;
    }
  }
#line 2646
  i = 1U;
  {
#line 2646
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2646
    if (! (i < r->eCol.nb)) {
#line 2646
      goto while_break___5;
    }
#line 2647
    cur___2 = *(r->eCol.e.exon + (i - 1U));
#line 2648
    next___2 = *(r->eCol.e.exon + i);
#line 2651
    if (cur___2->type >= 0) {
#line 2651
      if (cur___2->direction * r->direction > 0) {
#line 2653
        goto __Cont___2;
      } else {
#line 2651
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2651
    if (cur___2->to2 + 1U < next___2->from2) {
#line 2653
      goto __Cont___2;
    }
#line 2654
    nb___1 = (cur___2->to2 - next___2->from2) + 2U;
#line 2655
    max___0.type = -1;
#line 2656
    max___0.score = 0U;
#line 2657
    max___0.splScore = 0U;
#line 2658
    j___1 = 0U;
    {
#line 2658
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2658
      if (! (j___1 < nb___1)) {
#line 2658
        goto while_break___6;
      }
      {
#line 2659
      cs___0.to1 = ((cur___2->to1 - nb___1) + j___1) + 1U;
#line 2660
      cs___0.to2 = ((cur___2->to2 - nb___1) + j___1) + 1U;
#line 2661
      cs___0.nFrom1 = next___2->from1 + j___1;
#line 2662
      compute_max_score(seq1, seq2, & cs___0, r->direction);
#line 2663
      tmp___3 = splice_score_compare((void const   *)(& cs___0), (void const   *)(& max___0));
      }
#line 2663
      if (tmp___3 > 0) {
#line 2664
        max___0 = cs___0;
      }
#line 2658
      j___1 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2666
    cur___2->direction = max___0.direction;
#line 2667
    cur___2->type = (int )((char )max___0.type);
#line 2668
    cur___2->splScore = max___0.score;
#line 2669
    cur___2->to1 = max___0.to1;
#line 2670
    cur___2->to2 = max___0.to2;
#line 2671
    next___2->from2 = cur___2->to2 + 1U;
#line 2672
    next___2->from1 = max___0.nFrom1;
#line 2687
    if (cur___2->to2 == cur___2->from2) {
#line 2687
      goto _L___0;
    } else
#line 2687
    if (cur___2->to1 <= cur___2->from1) {
      _L___0: /* CIL Label */ 
      {
#line 2689
      free((void *)cur___2);
#line 2690
      (r->eCol.nb) --;
#line 2691
      i --;
#line 2692
      memmove((void *)(r->eCol.e.exon + i), (void const   *)((r->eCol.e.exon + i) + 1),
              (unsigned long )(r->eCol.nb - i) * sizeof(exon_p_t ));
      }
#line 2694
      if (i > 0U) {
#line 2695
        i --;
#line 2696
        cur___2 = *(r->eCol.e.exon + i);
#line 2697
        (next___2->from2) --;
#line 2698
        (next___2->from1) --;
#line 2699
        cur___2->direction = 0;
#line 2700
        cur___2->type = 0;
#line 2701
        cur___2->splScore = 0U;
      }
    }
#line 2707
    if (next___2->to2 <= next___2->from2) {
#line 2707
      goto _L___1;
    } else
#line 2707
    if (next___2->to1 <= next___2->from1) {
      _L___1: /* CIL Label */ 
      {
#line 2709
      free((void *)next___2);
#line 2710
      (r->eCol.nb) --;
#line 2711
      memmove((void *)(r->eCol.e.exon + i), (void const   *)((r->eCol.e.exon + i) + 1),
              (unsigned long )(r->eCol.nb - i) * sizeof(exon_p_t ));
#line 2713
      i --;
#line 2714
      cur___2->direction = 0;
#line 2715
      cur___2->type = 0;
#line 2716
      cur___2->splScore = 0U;
      }
    }
    __Cont___2: /* CIL Label */ 
#line 2646
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2722
  return;
}
}
#line 2739 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c"
static unsigned int SWscore(uchar *s1 , uchar *s2 , unsigned int len ) 
{ 
  unsigned int i ;
  int score[3] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 2744
  score[2] = 0;
#line 2744
  score[0] = score[2];
#line 2745
  if ((int )*s1 == (int )*s2) {
#line 2745
    score[1] = 1;
  } else {
#line 2745
    score[1] = 0;
  }
#line 2746
  i = 1U;
  {
#line 2746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2746
    if (! (i < len)) {
#line 2746
      goto while_break;
    }
#line 2747
    if ((int )*(s1 + (i - 1U)) == (int )*(s2 + i)) {
#line 2747
      tmp___1 = 1;
    } else {
#line 2747
      tmp___1 = 0;
    }
#line 2747
    if (score[0] + tmp___1 < score[1]) {
#line 2747
      score[0] = score[1];
    } else {
#line 2747
      if ((int )*(s1 + (i - 1U)) == (int )*(s2 + i)) {
#line 2747
        tmp___0 = 1;
      } else {
#line 2747
        tmp___0 = 0;
      }
#line 2747
      score[0] += tmp___0;
    }
#line 2748
    if ((int )*(s1 + i) == (int )*(s2 + (i - 1U))) {
#line 2748
      tmp___4 = 1;
    } else {
#line 2748
      tmp___4 = 0;
    }
#line 2748
    if (score[2] + tmp___4 < score[1]) {
#line 2748
      score[2] = score[1];
    } else {
#line 2748
      if ((int )*(s1 + i) == (int )*(s2 + (i - 1U))) {
#line 2748
        tmp___3 = 1;
      } else {
#line 2748
        tmp___3 = 0;
      }
#line 2748
      score[2] += tmp___3;
    }
#line 2749
    if (score[0] - 1 < score[2] - 1) {
#line 2749
      tmp___9 = score[2] - 1;
    } else {
#line 2749
      tmp___9 = score[0] - 1;
    }
#line 2749
    if ((int )*(s1 + i) == (int )*(s2 + i)) {
#line 2749
      tmp___10 = 1;
    } else {
#line 2749
      tmp___10 = 0;
    }
#line 2749
    if (tmp___9 < score[1] + tmp___10) {
#line 2749
      if ((int )*(s1 + i) == (int )*(s2 + i)) {
#line 2749
        tmp___7 = 1;
      } else {
#line 2749
        tmp___7 = 0;
      }
#line 2749
      score[1] += tmp___7;
    } else {
#line 2749
      if (score[0] - 1 < score[2] - 1) {
#line 2749
        tmp___8 = score[2] - 1;
      } else {
#line 2749
        tmp___8 = score[0] - 1;
      }
#line 2749
      score[1] = tmp___8;
    }
#line 2746
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2752
  if (! (score[1] >= 0)) {
    {
#line 2752
    __assert_fail("score[1] >= 0", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4b1.c",
                  2752U, "SWscore");
    }
  }
#line 2753
  return ((unsigned int )score[1]);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 171 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
options_t options  ;
#line 172 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.h"
char *argv0  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.h"
void S2A(edit_script_p_t head , int *S ) ;
#line 16
void IDISPLAY(uchar *A , uchar *B , unsigned int M , unsigned int N , int *S , unsigned int AP ,
              unsigned int BP , collec_p_t eCol , int direction ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void init_seq(char const   *fName , seq_p_t sp ) ;
#line 56
static int get_next_seq(seq_p_t sp , unsigned int offset , int warnMultiSeq ) ;
#line 57
static void seq_revcomp_inplace(seq_p_t seq ) ;
#line 58
static void print_align_lat(uchar *seq1 , uchar *seq2 , result_p_t r ) ;
#line 59
static void print_polyA_info(seq_p_t s1 , seq_p_t s2 , collec_p_t eCol , sim4_stats_p_t st ) ;
#line 60
static void print_res(result_p_t res , int rev , seq_p_t seq1 , seq_p_t seq2 ) ;
#line 61
static void init_splice_junctions(void) ;
#line 62
static void bug_handler(int signum ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static char const   Usage[1954]  = 
#line 67
  {      (char const   )'%',      (char const   )'s',      (char const   )' ',      (char const   )'[', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )']', 
        (char const   )' ',      (char const   )'d',      (char const   )'n',      (char const   )'a', 
        (char const   )' ',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )'_',      (char const   )'d',      (char const   )'b',      (char const   )'\n', 
        (char const   )'\n',      (char const   )'T',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'S',      (char const   )'I',      (char const   )'B', 
        (char const   )'s',      (char const   )'i',      (char const   )'m',      (char const   )'4', 
        (char const   )' ',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'0',      (char const   )'.',      (char const   )'2', 
        (char const   )'0',      (char const   )'.',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'A',      (char const   )'v',      (char const   )'a',      (char const   )'i', 
        (char const   )'l',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'(',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )' ',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'u',      (char const   )'e', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'b',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'[',      (char const   )']', 
        (char const   )')',      (char const   )':',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'A',      (char const   )' ', 
        (char const   )'<',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )'o', 
        (char const   )'u',      (char const   )'t',      (char const   )'p',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'0',      (char const   )':', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'p',      (char const   )'o',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )'l',      (char const   )'y', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'1',      (char const   )':', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'i', 
        (char const   )'g',      (char const   )'n',      (char const   )'m',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'t', 
        (char const   )'e',      (char const   )'x',      (char const   )'t',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'3',      (char const   )':',      (char const   )' ', 
        (char const   )'b',      (char const   )'o',      (char const   )'t',      (char const   )'h', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'p',      (char const   )'o',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )' ', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'g', 
        (char const   )'n',      (char const   )'m',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'t',      (char const   )'e', 
        (char const   )'x',      (char const   )'t',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'4',      (char const   )':',      (char const   )' ',      (char const   )'b', 
        (char const   )'o',      (char const   )'t',      (char const   )'h',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )'p',      (char const   )'o',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'s',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'m',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'t',      (char const   )'e',      (char const   )'x', 
        (char const   )'t',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )' ',      (char const   )'p', 
        (char const   )'o',      (char const   )'l',      (char const   )'y',      (char const   )'A', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'f', 
        (char const   )'o',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'5', 
        (char const   )':',      (char const   )' ',      (char const   )'s',      (char const   )'a', 
        (char const   )'m',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'4',      (char const   )' ', 
        (char const   )'p',      (char const   )'l',      (char const   )'u',      (char const   )'s', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'s', 
        (char const   )'p',      (char const   )'l',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'i', 
        (char const   )'m',      (char const   )'e',      (char const   )'r',      (char const   )'i', 
        (char const   )'c',      (char const   )' ',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'g',      (char const   )'n',      (char const   )'m', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'t',      (char const   )'e',      (char const   )'x',      (char const   )'t', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'(',      (char const   )'w',      (char const   )'h', 
        (char const   )'i',      (char const   )'c',      (char const   )'h',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'c', 
        (char const   )'u',      (char const   )'r',      (char const   )'r',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'l',      (char const   )'y', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'c', 
        (char const   )')',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'N',      (char const   )'o', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'a',      (char const   )'t',      (char const   )' ', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'u',      (char const   )'n',      (char const   )'i', 
        (char const   )'m',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )'m',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'[', 
        (char const   )'%',      (char const   )'d',      (char const   )']',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'C', 
        (char const   )' ',      (char const   )'<',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'>',      (char const   )' ',      (char const   )' ', 
        (char const   )'M',      (char const   )'S',      (char const   )'P',      (char const   )' ', 
        (char const   )'s',      (char const   )'c',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'h', 
        (char const   )'o',      (char const   )'l',      (char const   )'d',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'[',      (char const   )'%',      (char const   )'d',      (char const   )']', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'c',      (char const   )' ',      (char const   )'<',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )'m',      (char const   )'i',      (char const   )'n', 
        (char const   )'i',      (char const   )'m',      (char const   )'u',      (char const   )'m', 
        (char const   )' ',      (char const   )'s',      (char const   )'c',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'u',      (char const   )'t',      (char const   )'o',      (char const   )'f', 
        (char const   )'f',      (char const   )' ',      (char const   )'[',      (char const   )'%', 
        (char const   )'d',      (char const   )']',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'E',      (char const   )' ', 
        (char const   )'<',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )'c', 
        (char const   )'u',      (char const   )'t',      (char const   )'o',      (char const   )'f', 
        (char const   )'f',      (char const   )' ',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'u',      (char const   )'e',      (char const   )' ', 
        (char const   )'[',      (char const   )'%',      (char const   )'d',      (char const   )']', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'f',      (char const   )' ',      (char const   )'<',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )'s',      (char const   )'c',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'p',      (char const   )'e',      (char const   )'r', 
        (char const   )'c',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'(',      (char const   )'0',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )')',      (char const   )' ',      (char const   )'[',      (char const   )'%', 
        (char const   )'d',      (char const   )']',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'g',      (char const   )' ', 
        (char const   )'<',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )'j', 
        (char const   )'o',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'w',      (char const   )'h', 
        (char const   )'e',      (char const   )'n',      (char const   )' ',      (char const   )'g', 
        (char const   )'a',      (char const   )'p',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'g',      (char const   )'e', 
        (char const   )'n',      (char const   )'o',      (char const   )'m',      (char const   )'i', 
        (char const   )'c',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'R',      (char const   )'N', 
        (char const   )'A',      (char const   )' ',      (char const   )'h',      (char const   )'a', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )'l', 
        (char const   )'e',      (char const   )'n',      (char const   )'g',      (char const   )'t', 
        (char const   )'h',      (char const   )'s',      (char const   )' ',      (char const   )'w', 
        (char const   )'h',      (char const   )'i',      (char const   )'c',      (char const   )'h', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'f', 
        (char const   )'f',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'a',      (char const   )'t',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'p',      (char const   )'e',      (char const   )'r',      (char const   )'c', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'[', 
        (char const   )'%',      (char const   )'d',      (char const   )']',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'H', 
        (char const   )' ',      (char const   )'<',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'>',      (char const   )' ',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )' ',      (char const   )'c', 
        (char const   )'h',      (char const   )'i',      (char const   )'m',      (char const   )'e', 
        (char const   )'r',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'t',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'s',      (char const   )'c',      (char const   )'r',      (char const   )'i', 
        (char const   )'p',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )'w',      (char const   )'h',      (char const   )'e',      (char const   )'n', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'b',      (char const   )'e',      (char const   )'s', 
        (char const   )'t',      (char const   )' ',      (char const   )'s',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'w',      (char const   )'e',      (char const   )'r', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'p', 
        (char const   )'e',      (char const   )'r',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'o',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'a',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'R',      (char const   )'N',      (char const   )'A', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'i',      (char const   )'m',      (char const   )'e',      (char const   )'r', 
        (char const   )'a',      (char const   )' ',      (char const   )'s',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'g', 
        (char const   )'r',      (char const   )'e',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'p',      (char const   )'e',      (char const   )'r', 
        (char const   )'c',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'R', 
        (char const   )'N',      (char const   )'A',      (char const   )' ',      (char const   )'l', 
        (char const   )'e',      (char const   )'n',      (char const   )'g',      (char const   )'t', 
        (char const   )'h',      (char const   )' ',      (char const   )'(',      (char const   )'0', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'s', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'p',      (char const   )'o',      (char const   )'r', 
        (char const   )'t',      (char const   )')',      (char const   )' ',      (char const   )'[', 
        (char const   )'%',      (char const   )'u',      (char const   )']',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'I', 
        (char const   )' ',      (char const   )'<',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'>',      (char const   )' ',      (char const   )' ', 
        (char const   )'w',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'o',      (char const   )'w',      (char const   )' ',      (char const   )'w', 
        (char const   )'i',      (char const   )'d',      (char const   )'t',      (char const   )'h', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'w',      (char const   )'h',      (char const   )'i',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'a', 
        (char const   )'r',      (char const   )'c',      (char const   )'h',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'r', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'s', 
        (char const   )'p',      (char const   )'l',      (char const   )'i',      (char const   )'c', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'[',      (char const   )'%',      (char const   )'d',      (char const   )']', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'K',      (char const   )' ',      (char const   )'<',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )'M',      (char const   )'S',      (char const   )'P', 
        (char const   )' ',      (char const   )'s',      (char const   )'c',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'h',      (char const   )'o',      (char const   )'l',      (char const   )'d', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )' ',      (char const   )'p', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'[',      (char const   )'%',      (char const   )'d',      (char const   )']', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'L',      (char const   )' ',      (char const   )'<',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )'a',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'p', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'l', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'d',      (char const   )' ',      (char const   )'s', 
        (char const   )'p',      (char const   )'l',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'-',      (char const   )'t',      (char const   )'y', 
        (char const   )'p',      (char const   )'e',      (char const   )'s',      (char const   )' ', 
        (char const   )'[',      (char const   )'%',      (char const   )'s',      (char const   )']', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'M',      (char const   )' ',      (char const   )'<',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )'s',      (char const   )'c',      (char const   )'o', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'s',      (char const   )'p',      (char const   )'l', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )' ', 
        (char const   )'s',      (char const   )'i',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )',',      (char const   )' ',      (char const   )'e', 
        (char const   )'v',      (char const   )'a',      (char const   )'l',      (char const   )'u', 
        (char const   )'a',      (char const   )'t',      (char const   )'e',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'M',      (char const   )' ',      (char const   )'n', 
        (char const   )'u',      (char const   )'c',      (char const   )'l',      (char const   )'e', 
        (char const   )'o',      (char const   )'t',      (char const   )'i',      (char const   )'d', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'[', 
        (char const   )'%',      (char const   )'d',      (char const   )']',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'o', 
        (char const   )' ',      (char const   )'<',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'>',      (char const   )' ',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )'f',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'p',      (char const   )'o', 
        (char const   )'s',      (char const   )'i',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'d', 
        (char const   )'n',      (char const   )'a',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'q',      (char const   )'u',      (char const   )'e', 
        (char const   )'n',      (char const   )'c',      (char const   )'e',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'a',      (char const   )'m',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'[', 
        (char const   )'%',      (char const   )'u',      (char const   )']',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'q', 
        (char const   )' ',      (char const   )'<',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'>',      (char const   )' ',      (char const   )' ', 
        (char const   )'p',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'l',      (char const   )'t',      (char const   )'y',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'a',      (char const   )' ',      (char const   )'n',      (char const   )'u', 
        (char const   )'c',      (char const   )'l',      (char const   )'e',      (char const   )'o', 
        (char const   )'t',      (char const   )'i',      (char const   )'d',      (char const   )'e', 
        (char const   )' ',      (char const   )'m',      (char const   )'i',      (char const   )'s', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'[',      (char const   )'%', 
        (char const   )'d',      (char const   )']',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'R',      (char const   )' ', 
        (char const   )'<',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'a',      (char const   )'r', 
        (char const   )'c',      (char const   )'h',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'0',      (char const   )':',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'a',      (char const   )'r',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'\'',      (char const   )'+', 
        (char const   )'\'',      (char const   )' ',      (char const   )'(',      (char const   )'d', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )')',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'n', 
        (char const   )'l',      (char const   )'y',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'1',      (char const   )':',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'a',      (char const   )'r',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'\'',      (char const   )'-', 
        (char const   )'\'',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'l', 
        (char const   )'y',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'2', 
        (char const   )':',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'a',      (char const   )'r',      (char const   )'c',      (char const   )'h', 
        (char const   )' ',      (char const   )'b',      (char const   )'o',      (char const   )'t', 
        (char const   )'h',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'b',      (char const   )'e',      (char const   )'s', 
        (char const   )'t',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'[',      (char const   )'%',      (char const   )'d',      (char const   )']', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'r',      (char const   )' ',      (char const   )'<',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'w', 
        (char const   )'a',      (char const   )'r',      (char const   )'d',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'a',      (char const   )' ',      (char const   )'n',      (char const   )'u', 
        (char const   )'c',      (char const   )'l',      (char const   )'e',      (char const   )'o', 
        (char const   )'t',      (char const   )'i',      (char const   )'d',      (char const   )'e', 
        (char const   )' ',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )' ',      (char const   )'[', 
        (char const   )'%',      (char const   )'d',      (char const   )']',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'S', 
        (char const   )' ',      (char const   )'<',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'>',      (char const   )' ',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'x',      (char const   )' ', 
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )'b', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'s',      (char const   )'e',      (char const   )'r',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'/',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'d',      (char const   )'e',      (char const   )'l',      (char const   )'e', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'e',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'u',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'D', 
        (char const   )'N',      (char const   )'A',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'w',      (char const   )'h', 
        (char const   )'e',      (char const   )'n',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'b', 
        (char const   )'e',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'s',      (char const   )'p',      (char const   )'l',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )' ',      (char const   )'s', 
        (char const   )'i',      (char const   )'t',      (char const   )'e',      (char const   )' ', 
        (char const   )'p',      (char const   )'o',      (char const   )'s',      (char const   )'i', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'[',      (char const   )'%', 
        (char const   )'d',      (char const   )']',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'s',      (char const   )' ', 
        (char const   )'<',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )'s', 
        (char const   )'p',      (char const   )'l',      (char const   )'i',      (char const   )'t', 
        (char const   )' ',      (char const   )'s',      (char const   )'c',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )' ',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )'c',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'[',      (char const   )'%', 
        (char const   )'d',      (char const   )']',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'W',      (char const   )' ', 
        (char const   )'<',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )'w', 
        (char const   )'o',      (char const   )'r',      (char const   )'d',      (char const   )' ', 
        (char const   )'s',      (char const   )'i',      (char const   )'z',      (char const   )'e', 
        (char const   )' ',      (char const   )'[',      (char const   )'%',      (char const   )'d', 
        (char const   )']',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'X',      (char const   )' ',      (char const   )'<', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'>', 
        (char const   )' ',      (char const   )' ',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'u',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'i',      (char const   )'n',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'w',      (char const   )'o',      (char const   )'r',      (char const   )'d', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )' ', 
        (char const   )'[',      (char const   )'%',      (char const   )'d',      (char const   )']', 
        (char const   )'\n',      (char const   )'\000'};
#line 112 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
char dna_seq_head[256]  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
char rna_seq_head[256]  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
int main(int argc , char **argv ) 
{ 
  int count ;
  seq_t seq1 ;
  seq_t seq2 ;
  hash_env_t he ;
  collec_t res ;
  collec_t rev_res ;
  char *tmp ;
  int c ;
  int tmp___0 ;
  int val ;
  int tmp___1 ;
  int val___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int val___1 ;
  int tmp___6 ;
  int val___2 ;
  int tmp___7 ;
  size_t i ;
  size_t len ;
  size_t tmp___8 ;
  int val___3 ;
  int tmp___9 ;
  int val___4 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int curRes ;
  unsigned int max_nmatches ;
  unsigned int max_cmatches ;
  result_p_t r ;
  result_p_t r___0 ;
  result_p_t r___1 ;
  result_p_t r___2 ;
  result_p_t r___3 ;
  result_p_t r___4 ;
  unsigned int max_nmatches___0 ;
  result_p_t r___5 ;
  result_p_t r___6 ;
  result_p_t r___7 ;
  result_p_t r___8 ;
  int tmp___18 ;

  {
  {
#line 126
  argv0 = *(argv + 0);
#line 127
  tmp = setlocale(6, "POSIX");
  }
#line 127
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Warning: could not set locale to POSIX\n",
            *(argv + 0));
    }
  }
  {
#line 129
  signal(11, & bug_handler);
#line 130
  signal(7, & bug_handler);
#line 132
  options.C = 15U;
#line 133
  options.cutoff = 3;
#line 134
  options.gapPct = 10U;
#line 135
  options.intron_window = 6U;
#line 136
  options.K = 15U;
#line 137
  options.splice_type_list = (unsigned char *)"GTAG,GCAG,GTAC,ATAC";
#line 138
  options.nbSplice = 4U;
#line 139
  options.scoreSplice_window = 10U;
#line 140
  options.mismatchScore = -5;
#line 141
  options.reverse = 2U;
#line 142
  options.matchScore = 1;
#line 143
  options.W = 12U;
#line 144
  options.X = 12U;
#line 145
  options.filterPct = 75U;
#line 146
  options.minScore_cutoff = 50U;
#line 147
  options.splitScorePct = 75U;
#line 148
  options.huntChimera = 75U;
#line 149
  options.spliceInDel = 2U;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    tmp___0 = getopt(argc, (char * const  *)argv, "A:C:c:E:f:g:H:I:K:L:M:o:q:R:r:S:s:W:X:");
#line 151
    c = tmp___0;
    }
#line 152
    if (c == -1) {
#line 153
      goto while_break;
    }
    {
#line 155
    if (c == 65) {
#line 155
      goto case_65;
    }
#line 160
    if (c == 67) {
#line 160
      goto case_67;
    }
#line 167
    if (c == 99) {
#line 167
      goto case_99;
    }
#line 174
    if (c == 69) {
#line 174
      goto case_69;
    }
#line 179
    if (c == 102) {
#line 179
      goto case_102;
    }
#line 184
    if (c == 103) {
#line 184
      goto case_103;
    }
#line 189
    if (c == 72) {
#line 189
      goto case_72;
    }
#line 194
    if (c == 73) {
#line 194
      goto case_73;
    }
#line 201
    if (c == 75) {
#line 201
      goto case_75;
    }
#line 208
    if (c == 76) {
#line 208
      goto case_76;
    }
#line 233
    if (c == 77) {
#line 233
      goto case_77;
    }
#line 240
    if (c == 111) {
#line 240
      goto case_111;
    }
#line 247
    if (c == 113) {
#line 247
      goto case_113;
    }
#line 250
    if (c == 82) {
#line 250
      goto case_82;
    }
#line 255
    if (c == 114) {
#line 255
      goto case_114;
    }
#line 258
    if (c == 83) {
#line 258
      goto case_83;
    }
#line 261
    if (c == 115) {
#line 261
      goto case_115;
    }
#line 266
    if (c == 87) {
#line 266
      goto case_87;
    }
#line 271
    if (c == 88) {
#line 271
      goto case_88;
    }
#line 276
    if (c == 63) {
#line 276
      goto case_63;
    }
#line 278
    goto switch_default;
    case_65: /* CIL Label */ 
    {
#line 156
    options.ali_flag = atoi((char const   *)optarg);
    }
#line 157
    if (options.ali_flag < 0) {
      {
#line 158
      fatal("A must be one of 0, 1, 2, 3, 4, or 5.\n");
      }
    } else
#line 157
    if (options.ali_flag > 5) {
      {
#line 158
      fatal("A must be one of 0, 1, 2, 3, 4, or 5.\n");
      }
    }
#line 159
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 161
    tmp___1 = atoi((char const   *)optarg);
#line 161
    val = tmp___1;
    }
#line 162
    if (val < 0) {
      {
#line 163
      fatal("Value for option C must be non-negative.\n");
      }
    }
#line 164
    options.C = (unsigned int )val;
#line 165
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 168
    tmp___2 = atoi((char const   *)optarg);
#line 168
    val___0 = tmp___2;
    }
#line 169
    if (val___0 < 0) {
      {
#line 170
      fatal("Value for option c must be non-negative.\n");
      }
    }
#line 171
    options.minScore_cutoff = (unsigned int )val___0;
#line 172
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 175
    options.cutoff = atoi((char const   *)optarg);
    }
#line 176
    if (options.cutoff < 3) {
      {
#line 177
      fatal("Cutoff (E) must be within [3,10].\n");
      }
    } else
#line 176
    if (options.cutoff > 10) {
      {
#line 177
      fatal("Cutoff (E) must be within [3,10].\n");
      }
    }
#line 178
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 180
    tmp___3 = atoi((char const   *)optarg);
#line 180
    options.filterPct = (unsigned int )tmp___3;
    }
#line 181
    if (options.filterPct > 100U) {
      {
#line 182
      fatal("Filter in percent (f) must be within [0,100].\n");
      }
    }
#line 183
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 185
    tmp___4 = atoi((char const   *)optarg);
#line 185
    options.gapPct = (unsigned int )tmp___4;
    }
#line 186
    if (options.gapPct > 100U) {
      {
#line 187
      fatal("Length difference in percent (g) must be within [0,100].\n");
      }
    }
#line 188
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 190
    tmp___5 = atoi((char const   *)optarg);
#line 190
    options.huntChimera = (unsigned int )tmp___5;
    }
#line 191
    if (options.huntChimera > 100U) {
      {
#line 192
      fatal("Chimera filter in percent (H) must be within [0,100].\n");
      }
    }
#line 193
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 195
    tmp___6 = atoi((char const   *)optarg);
#line 195
    val___1 = tmp___6;
    }
#line 196
    if (val___1 < 0) {
      {
#line 197
      fatal("Value for option I must be non-negative.\n");
      }
    }
#line 198
    options.intron_window = (unsigned int )val___1;
#line 199
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 202
    tmp___7 = atoi((char const   *)optarg);
#line 202
    val___2 = tmp___7;
    }
#line 203
    if (val___2 < 0) {
      {
#line 204
      fatal("Value for option K must be non-negative.\n");
      }
    }
#line 205
    options.K = (unsigned int )val___2;
#line 206
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 210
    tmp___8 = strlen((char const   *)optarg);
#line 210
    len = tmp___8;
#line 211
    options.splice_type_list = (unsigned char *)optarg;
#line 212
    options.nbSplice = 1U;
    }
#line 213
    if (len % 5UL != 4UL) {
      {
#line 214
      fatal("Splice types list has illegal length (%zu)\n", len);
      }
    }
#line 215
    i = (size_t )0;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (! (i < len)) {
#line 215
        goto while_break___0;
      }
#line 216
      if (i % 5UL == 4UL) {
#line 217
        if ((int )*(options.splice_type_list + i) != 44) {
          {
#line 218
          fatal("Comma expected instead of %c at position %zuin splice types list.\n",
                (int )*(options.splice_type_list + i), i);
          }
        }
#line 221
        (options.nbSplice) ++;
      } else
#line 223
      if ((int )*(options.splice_type_list + i) != 65) {
#line 223
        if ((int )*(options.splice_type_list + i) != 67) {
#line 223
          if ((int )*(options.splice_type_list + i) != 71) {
#line 223
            if ((int )*(options.splice_type_list + i) != 84) {
              {
#line 227
              fatal("Expected \'A\', \'C\', \'G\' or \'T\' instead of \'%c\' atposition %zu in splice types list.\n",
                    (int )*(options.splice_type_list + i), i);
              }
            }
          }
        }
      }
#line 215
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 231
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 234
    tmp___9 = atoi((char const   *)optarg);
#line 234
    val___3 = tmp___9;
    }
#line 235
    if (val___3 < 0) {
      {
#line 236
      fatal("Value for option M must be non-negative.\n");
      }
    }
#line 237
    options.scoreSplice_window = (unsigned int )val___3;
#line 238
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 241
    tmp___10 = atoi((char const   *)optarg);
#line 241
    val___4 = tmp___10;
    }
#line 242
    if (val___4 < 0) {
      {
#line 243
      fatal("Value for option o must be non-negative.\n");
      }
    }
#line 244
    options.dnaOffset = (unsigned int )val___4;
#line 245
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 248
    options.mismatchScore = atoi((char const   *)optarg);
    }
#line 249
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 251
    tmp___11 = atoi((char const   *)optarg);
#line 251
    options.reverse = (unsigned int )tmp___11;
    }
#line 252
    if (options.reverse > 2U) {
      {
#line 253
      fatal("R must be one of 0, 1, or 2.\n");
      }
    }
#line 254
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 256
    options.matchScore = atoi((char const   *)optarg);
    }
#line 257
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 259
    tmp___12 = atoi((char const   *)optarg);
#line 259
    options.spliceInDel = (unsigned int )tmp___12;
    }
#line 260
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 262
    tmp___13 = atoi((char const   *)optarg);
#line 262
    options.splitScorePct = (unsigned int )tmp___13;
    }
#line 263
    if (options.splitScorePct > 100U) {
      {
#line 264
      fatal("Split score in percent (s) must be within [0,100].\n");
      }
    }
#line 265
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 267
    tmp___14 = atoi((char const   *)optarg);
#line 267
    options.W = (unsigned int )tmp___14;
    }
#line 268
    if (options.W < 1U) {
      {
#line 269
      fatal("W must be within [1,15].\n");
      }
    } else
#line 268
    if (options.W > 15U) {
      {
#line 269
      fatal("W must be within [1,15].\n");
      }
    }
#line 270
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 272
    tmp___15 = atoi((char const   *)optarg);
#line 272
    options.X = (unsigned int )tmp___15;
    }
#line 273
    if (options.X < 1U) {
      {
#line 274
      fatal("X must be positive.\n");
      }
    }
#line 275
    goto switch_break;
    case_63: /* CIL Label */ 
#line 277
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"?? getopt returned character code 0%o ??\n",
            c);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  if (optind + 2 != argc) {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(Usage),
            *(argv + 0), options.ali_flag, options.C, options.minScore_cutoff, options.cutoff,
            options.filterPct, options.gapPct, options.huntChimera, options.intron_window,
            options.K, options.splice_type_list, options.scoreSplice_window, options.dnaOffset,
            options.mismatchScore, options.reverse, options.matchScore, options.spliceInDel,
            options.splitScorePct, options.W, options.X);
    }
#line 303
    return (1);
  }
  {
#line 307
  init_seq((char const   *)*(argv + optind), & seq1);
#line 308
  tmp___16 = get_next_seq(& seq1, options.dnaOffset, 1);
  }
#line 308
  if (tmp___16 != 0) {
    {
#line 309
    fatal("Cannot read sequence from %s.\n", *(argv + optind));
    }
  }
  {
#line 310
  strncpy((char */* __restrict  */)(dna_seq_head), (char const   */* __restrict  */)seq1.header,
          256UL);
#line 313
  init_seq((char const   *)*(argv + (optind + 1)), & seq2);
#line 314
  tmp___17 = get_next_seq(& seq2, 0U, 0);
  }
#line 314
  if (tmp___17 != 0) {
    {
#line 315
    fatal("Cannot read sequence from %s.\n", *(argv + (optind + 1)));
    }
  }
  {
#line 317
  init_encoding();
#line 318
  init_hash_env(& he, options.W, seq1.seq, seq1.len);
#line 319
  init_col(& res, 1U);
#line 320
  init_col(& rev_res, 1U);
#line 321
  bld_table(& he);
#line 322
  init_splice_junctions();
#line 324
  count = 0;
  }
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 325
    if (! (! count)) {
      {
#line 325
      tmp___18 = get_next_seq(& seq2, 0U, 0);
      }
#line 325
      if (! (tmp___18 == 0)) {
#line 325
        goto while_break___1;
      }
    }
    {
#line 327
    strncpy((char */* __restrict  */)(rna_seq_head), (char const   */* __restrict  */)seq2.header,
            256UL);
#line 328
    count ++;
    }
    {
#line 331
    if (options.reverse == 0U) {
#line 331
      goto case_0;
    }
#line 334
    if (options.reverse == 2U) {
#line 334
      goto case_2;
    }
#line 336
    if (options.reverse == 1U) {
#line 336
      goto case_1;
    }
#line 340
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 332
    SIM4(& he, & seq2, & res);
    }
#line 333
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 335
    SIM4(& he, & seq2, & res);
    }
    case_1: /* CIL Label */ 
    {
#line 337
    seq_revcomp_inplace(& seq2);
#line 338
    SIM4(& he, & seq2, & rev_res);
    }
#line 339
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 341
    fatal("Unrecognized request for EST orientation.\n");
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 344
    if (options.huntChimera > 0U) {
#line 345
      max_nmatches = 0U;
#line 346
      max_cmatches = 0U;
#line 347
      curRes = 0U;
      {
#line 347
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 347
        if (! (curRes < rev_res.nb)) {
#line 347
          goto while_break___2;
        }
#line 348
        r = *(rev_res.e.result + curRes);
#line 349
        if (r->chimera) {
#line 350
          if (r->st.nmatches > max_cmatches) {
#line 351
            max_cmatches = r->st.nmatches;
          }
        } else
#line 353
        if (r->st.nmatches > max_nmatches) {
#line 354
          max_nmatches = r->st.nmatches;
        }
#line 347
        curRes ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 357
      curRes = 0U;
      {
#line 357
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 357
        if (! (curRes < res.nb)) {
#line 357
          goto while_break___3;
        }
#line 358
        r___0 = *(res.e.result + curRes);
#line 359
        if (r___0->chimera) {
#line 360
          if (r___0->st.nmatches > max_cmatches) {
#line 361
            max_cmatches = r___0->st.nmatches;
          }
        } else
#line 363
        if (r___0->st.nmatches > max_nmatches) {
#line 364
          max_nmatches = r___0->st.nmatches;
        }
#line 357
        curRes ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 367
      if ((max_cmatches * options.huntChimera) / 100U > max_nmatches) {
#line 367
        if (max_cmatches > (seq2.len * options.huntChimera) / 100U) {
#line 370
          curRes = 0U;
          {
#line 370
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 370
            if (! (curRes < rev_res.nb)) {
#line 370
              goto while_break___4;
            }
#line 371
            r___1 = *(rev_res.e.result + curRes);
#line 372
            if (r___1->chimera == 0) {
#line 373
              r___1->st.nmatches = 0U;
            }
#line 370
            curRes ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 375
          curRes = 0U;
          {
#line 375
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 375
            if (! (curRes < res.nb)) {
#line 375
              goto while_break___5;
            }
#line 376
            r___2 = *(res.e.result + curRes);
#line 377
            if (r___2->chimera == 0) {
#line 378
              r___2->st.nmatches = 0U;
            }
#line 375
            curRes ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
#line 367
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 382
        curRes = 0U;
        {
#line 382
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 382
          if (! (curRes < rev_res.nb)) {
#line 382
            goto while_break___6;
          }
#line 383
          r___3 = *(rev_res.e.result + curRes);
#line 384
          if (r___3->chimera) {
#line 385
            r___3->st.nmatches = 0U;
          }
#line 382
          curRes ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 387
        curRes = 0U;
        {
#line 387
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 387
          if (! (curRes < res.nb)) {
#line 387
            goto while_break___7;
          }
#line 388
          r___4 = *(res.e.result + curRes);
#line 389
          if (r___4->chimera) {
#line 390
            r___4->st.nmatches = 0U;
          }
#line 387
          curRes ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
#line 395
    if (options.filterPct > 0U) {
#line 396
      max_nmatches___0 = 0U;
#line 397
      curRes = 0U;
      {
#line 397
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 397
        if (! (curRes < rev_res.nb)) {
#line 397
          goto while_break___8;
        }
#line 398
        r___5 = *(rev_res.e.result + curRes);
#line 399
        if (r___5->st.nmatches > max_nmatches___0) {
#line 400
          max_nmatches___0 = r___5->st.nmatches;
        }
#line 397
        curRes ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 402
      curRes = 0U;
      {
#line 402
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 402
        if (! (curRes < res.nb)) {
#line 402
          goto while_break___9;
        }
#line 403
        r___6 = *(res.e.result + curRes);
#line 404
        if (r___6->st.nmatches > max_nmatches___0) {
#line 405
          max_nmatches___0 = r___6->st.nmatches;
        }
#line 402
        curRes ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 407
      max_nmatches___0 = (max_nmatches___0 * options.filterPct) / 100U;
#line 408
      curRes = 0U;
      {
#line 408
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 408
        if (! (curRes < rev_res.nb)) {
#line 408
          goto while_break___10;
        }
#line 409
        r___7 = *(rev_res.e.result + curRes);
#line 410
        if (r___7->st.nmatches < max_nmatches___0) {
#line 411
          r___7->st.nmatches = 0U;
        }
#line 408
        curRes ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 413
      curRes = 0U;
      {
#line 413
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 413
        if (! (curRes < res.nb)) {
#line 413
          goto while_break___11;
        }
#line 414
        r___8 = *(res.e.result + curRes);
#line 415
        if (r___8->st.nmatches < max_nmatches___0) {
#line 416
          r___8->st.nmatches = 0U;
        }
#line 413
        curRes ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 420
    curRes = 0U;
    {
#line 420
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 420
      if (! (curRes < rev_res.nb)) {
#line 420
        goto while_break___12;
      }
      {
#line 421
      print_res(*(rev_res.e.result + curRes), 1, & seq1, & seq2);
#line 420
      curRes ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 422
    rev_res.nb = 0U;
#line 423
    if (options.reverse) {
#line 423
      if (options.ali_flag) {
        {
#line 425
        seq_revcomp_inplace(& seq2);
        }
      }
    }
#line 426
    curRes = 0U;
    {
#line 426
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 426
      if (! (curRes < res.nb)) {
#line 426
        goto while_break___13;
      }
      {
#line 427
      print_res(*(res.e.result + curRes), 0, & seq1, & seq2);
#line 426
      curRes ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 428
    res.nb = 0U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 441
  return (0);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static unsigned char const   dna_complement[256]  = 
#line 444
  {      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )'T',      (unsigned char const   )'V',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'M', 
        (unsigned char const   )' ',      (unsigned char const   )'K',      (unsigned char const   )'N',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'Y',      (unsigned char const   )'S', 
        (unsigned char const   )'A',      (unsigned char const   )' ',      (unsigned char const   )'B',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'R',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )'t',      (unsigned char const   )'v',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'m', 
        (unsigned char const   )' ',      (unsigned char const   )'k',      (unsigned char const   )'n',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'y',      (unsigned char const   )'s', 
        (unsigned char const   )'a',      (unsigned char const   )' ',      (unsigned char const   )'b',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'r',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' '};
#line 454 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void init_splice_junctions(void) 
{ 
  unsigned int i ;
  void *tmp ;
  unsigned int j ;
  uchar c ;

  {
  {
#line 458
  tmp = xmalloc((unsigned long )options.nbSplice * sizeof(junction_t ));
#line 458
  options.splice = (junction_p_t )tmp;
#line 460
  i = 0U;
  }
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (i < options.nbSplice)) {
#line 460
      goto while_break;
    }
#line 462
    j = 0U;
    {
#line 462
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 462
      if (! (j < 4U)) {
#line 462
        goto while_break___0;
      }
#line 463
      c = *(options.splice_type_list + (i * 5U + j));
#line 464
      (options.splice + i)->fwd[j] = c;
#line 465
      (options.splice + i)->rev[3U - j] = (uchar )dna_complement[c];
#line 462
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 460
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  return;
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void print_res(result_p_t res , int rev , seq_p_t seq1 , seq_p_t seq2 ) 
{ 
  unsigned int i ;

  {
#line 479
  if (res->st.nmatches >= options.minScore_cutoff) {
    {
#line 480
    printf((char const   */* __restrict  */)"\n%s%s\n", seq1->header, seq2->header);
    }
#line 481
    if (res->chimera) {
      {
#line 482
      printf((char const   */* __restrict  */)"Chimera\n\n");
      }
    }
#line 483
    if (rev) {
      {
#line 484
      printf((char const   */* __restrict  */)"(complement)\n\n");
      }
    }
    {
#line 486
    if (options.ali_flag == 0) {
#line 486
      goto case_0;
    }
#line 489
    if (options.ali_flag == 1) {
#line 489
      goto case_1;
    }
#line 492
    if (options.ali_flag == 3) {
#line 492
      goto case_3;
    }
#line 497
    if (options.ali_flag == 5) {
#line 497
      goto case_5;
    }
#line 497
    if (options.ali_flag == 4) {
#line 497
      goto case_5;
    }
#line 502
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 487
    print_exons(& res->eCol, res->direction);
    }
#line 488
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 490
    print_align_lat(seq1->seq, seq2->seq, res);
    }
#line 491
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 493
    print_exons(& res->eCol, res->direction);
#line 494
    print_align_lat(seq1->seq, seq2->seq, res);
    }
#line 495
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 498
    print_exons(& res->eCol, res->direction);
#line 499
    print_polyA_info(seq1, seq2, & res->eCol, & res->st);
#line 500
    print_align_lat(seq1->seq, seq2->seq, res);
    }
#line 501
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 503
    fatal("Unrecognized option for alignment output.\n");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 505
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 507
  i = 0U;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! (i < res->eCol.nb)) {
#line 507
      goto while_break;
    }
    {
#line 508
    free(*(res->eCol.e.elt + i));
#line 507
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  free((void *)res->eCol.e.elt);
  }
#line 510
  if (res->sList) {
    {
#line 511
    free_align(res->sList);
    }
  }
  {
#line 512
  free((void *)res);
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void print_polyA_info(seq_p_t s1 , seq_p_t s2 , collec_p_t eCol , sim4_stats_p_t st ) 
{ 
  unsigned int cnt ;
  unsigned int cntDna ;
  unsigned int pos ;
  unsigned int i ;
  unsigned int scanLen ;
  char *pSig ;
  char buf[51] ;
  exon_p_t e ;
  unsigned int cnt___0 ;
  unsigned int cntDna___0 ;
  unsigned int pos___0 ;
  unsigned int i___0 ;
  char *pSig___0 ;
  char buf___0[51] ;
  exon_p_t e___0 ;

  {
#line 519
  if (st->polyA_cut) {
#line 520
    cnt = 0U;
#line 520
    cntDna = 0U;
#line 520
    scanLen = 50U;
#line 522
    e = *(eCol->e.exon + (eCol->nb - 1U));
#line 523
    pos = 0U;
    {
#line 523
    while (1) {
      while_continue: /* CIL Label */ ;
#line 523
      if (pos < 10U) {
#line 523
        if (! (e->to2 + pos < s2->len)) {
#line 523
          goto while_break;
        }
      } else {
#line 523
        goto while_break;
      }
#line 524
      if ((int )*(s2->seq + (e->to2 + pos)) == 65) {
#line 525
        cnt ++;
      }
#line 523
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 526
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 526
      if (e->to2 + pos < s2->len) {
#line 526
        if (! ((int )*(s2->seq + (e->to2 + pos)) == 65)) {
#line 526
          goto while_break___0;
        }
      } else {
#line 526
        goto while_break___0;
      }
#line 527
      pos ++;
#line 528
      cnt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 530
    i = 0U;
    {
#line 530
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 530
      if (i < s1->len) {
#line 530
        if (! (i < pos)) {
#line 530
          goto while_break___1;
        }
      } else {
#line 530
        goto while_break___1;
      }
#line 531
      if ((int )*(s1->seq + (e->to1 + i)) == 65) {
#line 532
        cntDna ++;
      }
#line 530
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 533
    printf((char const   */* __restrict  */)"\nPolyA site %u nt, %u/%u A\'s %u\n R %.*s %u\n D %*.*s %u\n",
           pos, cnt, cntDna, (e->to1 + 1U) + options.dnaOffset, pos, s2->seq + e->to2,
           e->to2 + 1U, pos, i, s1->seq + e->to1, (e->to1 + 1U) + options.dnaOffset);
    }
#line 537
    if (e->to1 < scanLen) {
#line 538
      scanLen = e->to1;
    }
    {
#line 539
    strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)(((char *)s1->seq + e->to1) - scanLen),
            (size_t )scanLen);
#line 540
    buf[scanLen] = (char)0;
#line 541
    pSig = strstr((char const   *)(buf), "AATAAA");
    }
#line 542
    if ((unsigned long )pSig == (unsigned long )((void *)0)) {
      {
#line 543
      pSig = strstr((char const   *)(buf), "ATTAAA");
      }
    }
#line 544
    if ((unsigned long )pSig != (unsigned long )((void *)0)) {
      {
#line 545
      printf((char const   */* __restrict  */)"PolyA signal %u\n", (unsigned int )(((((pSig - buf) + (long )e->to1) - (long )scanLen) + 1L) + (long )options.dnaOffset));
      }
    }
  }
#line 549
  if (st->polyT_cut) {
#line 550
    cnt___0 = 0U;
#line 550
    cntDna___0 = 0U;
#line 552
    e___0 = *(eCol->e.exon + 0);
#line 553
    pos___0 = 0U;
    {
#line 553
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 553
      if (pos___0 < 10U) {
#line 553
        if (! (pos___0 < e___0->from2 - 1U)) {
#line 553
          goto while_break___2;
        }
      } else {
#line 553
        goto while_break___2;
      }
#line 554
      if ((int )*(s2->seq + ((e___0->from2 - 2U) - pos___0)) == 84) {
#line 555
        cnt___0 ++;
      }
#line 553
      pos___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 556
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 556
      if (pos___0 < e___0->from2 - 1U) {
#line 556
        if (! ((int )*(s2->seq + ((e___0->from2 - 2U) - pos___0)) == 84)) {
#line 556
          goto while_break___3;
        }
      } else {
#line 556
        goto while_break___3;
      }
#line 557
      pos___0 ++;
#line 558
      cnt___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 560
    i___0 = 0U;
    {
#line 560
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 560
      if (i___0 < e___0->from1 - 1U) {
#line 560
        if (! (i___0 < pos___0)) {
#line 560
          goto while_break___4;
        }
      } else {
#line 560
        goto while_break___4;
      }
#line 561
      if ((int )*(s1->seq + ((e___0->from1 - 2U) - i___0)) == 84) {
#line 562
        cntDna___0 ++;
      }
#line 560
      i___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 563
    printf((char const   */* __restrict  */)"\nPolyA site %u nt, %u/%u A\'s %u minus strand\n R %.*s %u\n D %*.*s %u\n",
           pos___0, cnt___0, cntDna___0, (e___0->from1 - 1U) + options.dnaOffset,
           pos___0, s2->seq + ((e___0->from2 - 1U) - pos___0), e___0->from2 - 1U,
           pos___0, i___0, s1->seq + ((e___0->from1 - 1U) - i___0), (e___0->from1 - 1U) + options.dnaOffset);
#line 568
    strncpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)(((char *)s1->seq + e___0->from1) - 1),
            50UL);
#line 569
    buf___0[50] = (char)0;
#line 570
    pSig___0 = strstr((char const   *)(buf___0), "TTTATT");
    }
#line 571
    if ((unsigned long )pSig___0 == (unsigned long )((void *)0)) {
      {
#line 572
      pSig___0 = strstr((char const   *)(buf___0), "TTTAAT");
      }
    }
#line 573
    if ((unsigned long )pSig___0 != (unsigned long )((void *)0)) {
      {
#line 574
      printf((char const   */* __restrict  */)"PolyA signal %u minus strand\n", (unsigned int )((((pSig___0 - buf___0) + (long )e___0->from1) + 5L) + (long )options.dnaOffset));
      }
    }
  }
#line 577
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void print_align_lat(uchar *seq1 , uchar *seq2 , result_p_t r ) 
{ 
  int *S ;
  edit_script_list_p_t head ;
  edit_script_list_p_t aligns ;
  void *tmp ;

  {
#line 585
  if ((unsigned long )r->sList == (unsigned long )((void *)0)) {
#line 586
    return;
  }
#line 587
  if (r->chimera) {
#line 587
    if (options.ali_flag < 5) {
#line 588
      return;
    }
  }
#line 589
  aligns = r->sList;
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (! ((unsigned long )aligns != (unsigned long )((void *)0))) {
#line 590
      goto while_break;
    }
    {
#line 591
    head = aligns;
#line 592
    aligns = aligns->next_script;
#line 593
    tmp = xmalloc((unsigned long )((2U * head->len2 + 1U) + 1U) * sizeof(int ));
#line 593
    S = (int *)tmp;
#line 594
    S ++;
#line 595
    S2A(head->script, S);
#line 596
    Free_script(head->script);
#line 597
    IDISPLAY(((seq1 + head->offset1) - 1) - 1, ((seq2 + head->offset2) - 1) - 1, head->len1,
             head->len2, S, head->offset1, head->offset2, & r->eCol, r->direction);
#line 600
    free((void *)(S - 1));
#line 601
    free((void *)head);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  r->sList = (edit_script_list_p_t )((void *)0);
#line 604
  return;
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void grow_read_buf(read_buf_p_t b ) 
{ 
  void *tmp ;

  {
  {
#line 627
  b->lmax += 4096U;
#line 628
  tmp = xrealloc((void *)b->line, (unsigned long )b->lmax * sizeof(char ));
#line 628
  b->line = (char *)tmp;
  }
#line 629
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static char *shuffle_line(read_buf_p_t b , size_t *cur ) 
{ 
  unsigned int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;

  {
#line 634
  if (b->ic == 0U) {
#line 635
    return ((char *)((void *)0));
  } else
#line 634
  if (*cur >= (size_t )b->ic) {
#line 635
    return ((char *)((void *)0));
  }
#line 637
  if ((size_t )b->lmax <= (size_t )b->lc + ((size_t )b->ic - *cur)) {
    {
#line 638
    grow_read_buf(b);
    }
  }
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (*cur < (size_t )b->ic) {
#line 639
      if (! ((int )b->in[*cur] != 10)) {
#line 639
        goto while_break;
      }
    } else {
#line 639
      goto while_break;
    }
#line 640
    tmp = b->lc;
#line 640
    (b->lc) ++;
#line 640
    tmp___0 = *cur;
#line 640
    (*cur) ++;
#line 640
    *(b->line + tmp) = b->in[tmp___0];
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  if (*cur < (size_t )b->ic) {
#line 644
    tmp___1 = b->lc;
#line 644
    (b->lc) ++;
#line 644
    tmp___2 = *cur;
#line 644
    (*cur) ++;
#line 644
    *(b->line + tmp___1) = b->in[tmp___2];
#line 646
    *(b->line + b->lc) = (char)0;
#line 648
    if (*cur < (size_t )b->ic) {
      {
#line 649
      memmove((void *)(b->in), (void const   *)(b->in + *cur), ((size_t )b->ic - *cur) * sizeof(char ));
#line 650
      b->ic -= (unsigned int )*cur;
      }
    } else {
#line 652
      b->ic = 0U;
    }
#line 653
    *cur = (size_t )0;
#line 654
    return (b->line);
  }
#line 657
  b->ic = 0U;
#line 657
  *cur = (size_t )0;
#line 658
  return ((char *)((void *)0));
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static char *read_line_buf(read_buf_p_t b , int fd ) 
{ 
  char *s ;
  ssize_t rc ;
  size_t cur ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 664
  s = (char *)((void *)0);
#line 666
  cur = (size_t )0;
#line 667
  b->lc = 0U;
#line 668
  s = shuffle_line(b, & cur);
  }
#line 668
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 669
    return (s);
  }
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 671
    rc = read(fd, (void *)(b->in + b->ic), (size_t )((4096U - b->ic) - 1U));
    }
#line 671
    if (rc == -1L) {
      {
#line 673
      tmp___2 = __errno_location();
      }
#line 673
      if (*tmp___2 != 4) {
        {
#line 674
        tmp = __errno_location();
#line 674
        tmp___0 = __errno_location();
#line 674
        tmp___1 = strerror(*tmp___0);
#line 674
        fatal("Could not read from %d: %s(%d)\n", fd, tmp___1, *tmp);
        }
      }
    } else {
#line 677
      b->ic += (unsigned int )rc;
    }
    {
#line 678
    s = shuffle_line(b, & cur);
    }
#line 679
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 679
      if (rc == 0L) {
#line 681
        *(b->line + b->lc) = (char)0;
#line 682
        s = b->line;
      }
    }
#line 670
    if (! ((unsigned long )s == (unsigned long )((void *)0))) {
#line 670
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  return (s);
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void init_buf(read_buf_p_t b ) 
{ 
  void *tmp ;

  {
  {
#line 691
  tmp = xmalloc(4096UL * sizeof(char ));
#line 691
  b->line = (char *)tmp;
#line 692
  b->lmax = 4096U;
#line 693
  b->lc = 0U;
#line 694
  b->ic = 0U;
  }
#line 695
  return;
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void init_seq(char const   *fName , seq_p_t sp ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 700
  sp->fName = fName;
#line 701
  sp->header = (char *)((void *)0);
#line 702
  sp->seq = (unsigned char *)((void *)0);
#line 703
  init_buf(& sp->rb);
  }
#line 704
  if ((unsigned long )fName != (unsigned long )((void *)0)) {
    {
#line 705
    sp->fd = open(fName, 0);
    }
#line 706
    if (sp->fd == -1) {
      {
#line 707
      tmp = __errno_location();
#line 707
      tmp___0 = __errno_location();
#line 707
      tmp___1 = strerror(*tmp___0);
#line 707
      fatal("Could not open file %s: %s(%d)\n", fName, tmp___1, *tmp);
      }
    }
  } else {
#line 710
    sp->fd = 0;
  }
  {
#line 711
  sp->len = 0U;
#line 712
  sp->maxHead = 0U;
#line 713
  sp->max = 0U;
#line 714
  read_line_buf(& sp->rb, sp->fd);
  }
#line 715
  return;
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static int get_next_seq(seq_p_t sp , unsigned int offset , int warnMultiSeq ) 
{ 
  unsigned int lenStr ;
  unsigned int headerLen ;
  char *buf ;
  int res ;
  void *tmp ;
  unsigned char c ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *s ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;

  {
#line 720
  lenStr = 24U;
#line 722
  buf = sp->rb.line;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (sp->rb.lc > 0U) {
#line 724
      if (! ((int )*(buf + 0) != 62)) {
#line 724
        goto while_break;
      }
    } else {
#line 724
      goto while_break;
    }
    {
#line 725
    buf = read_line_buf(& sp->rb, sp->fd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  if (sp->rb.lc == 0U) {
#line 727
    return (-1);
  }
#line 729
  if ((sp->rb.lc + lenStr) + 1U > sp->maxHead) {
    {
#line 730
    sp->maxHead = (sp->rb.lc + lenStr) + 1U;
#line 731
    tmp = xrealloc((void *)sp->header, (unsigned long )sp->maxHead * sizeof(char ));
#line 731
    sp->header = (char *)tmp;
    }
  }
  {
#line 733
  headerLen = sp->rb.lc;
#line 734
  memcpy((void */* __restrict  */)sp->header, (void const   */* __restrict  */)buf,
         (unsigned long )(sp->rb.lc + 1U) * sizeof(char ));
#line 735
  sp->len = 0U;
#line 736
  buf = read_line_buf(& sp->rb, sp->fd);
  }
  {
#line 737
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 737
    if (sp->rb.lc > 0U) {
#line 737
      if (! ((int )*(buf + 0) != 62)) {
#line 737
        goto while_break___0;
      }
    } else {
#line 737
      goto while_break___0;
    }
#line 740
    if ((sp->len + sp->rb.lc) + 1U > sp->max) {
#line 741
      if ((sp->len + sp->rb.lc) + 1U < sp->max + 262144U) {
#line 741
        sp->max += 262144U;
      } else {
#line 741
        sp->max = (sp->len + sp->rb.lc) + 1U;
      }
      {
#line 743
      tmp___0 = xrealloc((void *)sp->seq, (unsigned long )sp->max * sizeof(unsigned char ));
#line 743
      sp->seq = (unsigned char *)tmp___0;
      }
    }
    {
#line 746
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 746
      tmp___6 = buf;
#line 746
      buf ++;
#line 746
      c = (unsigned char )*tmp___6;
#line 746
      if (! ((int )c != 0)) {
#line 746
        goto while_break___1;
      }
      {
#line 747
      tmp___5 = __ctype_b_loc();
      }
#line 747
      if ((int const   )*(*tmp___5 + (int )c) & 256) {
#line 748
        tmp___1 = sp->len;
#line 748
        (sp->len) ++;
#line 748
        *(sp->seq + tmp___1) = c;
      } else {
        {
#line 749
        tmp___4 = __ctype_b_loc();
        }
#line 749
        if ((int const   )*(*tmp___4 + (int )c) & 512) {
          {
#line 750
          tmp___2 = sp->len;
#line 750
          (sp->len) ++;
#line 750
          tmp___3 = toupper((int )c);
#line 750
          *(sp->seq + tmp___2) = (unsigned char )tmp___3;
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 753
    buf = read_line_buf(& sp->rb, sp->fd);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 755
  if (warnMultiSeq) {
#line 755
    if (sp->rb.lc > 0U) {
      {
#line 756
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n***  WARNING                                           ***\n***  there appears to be several sequences in the DNA  ***\n***  sequence file.  Only the first one will be used,  ***\n***  which might not be what was intended.             ***\n\n");
      }
    }
  }
  {
#line 762
  *(sp->seq + sp->len) = (unsigned char)0;
#line 763
  buf = strstr((char const   *)sp->header, "; LEN=");
  }
#line 764
  if (buf) {
#line 765
    s = buf + 6;
#line 766
    headerLen -= 6U;
    {
#line 767
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 767
      tmp___7 = __ctype_b_loc();
      }
#line 767
      if (! ((int const   )*(*tmp___7 + (int )*s) & 2048)) {
#line 767
        goto while_break___2;
      }
#line 768
      s ++;
#line 769
      headerLen --;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 771
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 771
      if (! *s) {
#line 771
        goto while_break___3;
      }
#line 772
      tmp___8 = buf;
#line 772
      buf ++;
#line 772
      tmp___9 = s;
#line 772
      s ++;
#line 772
      *tmp___8 = *tmp___9;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 774
  buf = (sp->header + headerLen) - 1;
  {
#line 775
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 775
    tmp___10 = __ctype_b_loc();
    }
#line 775
    if (! ((int const   )*(*tmp___10 + (int )*buf) & 2)) {
      {
#line 775
      tmp___11 = __ctype_b_loc();
      }
#line 775
      if (! ((int const   )*(*tmp___11 + (int )*buf) & 8192)) {
#line 775
        goto while_break___4;
      }
    }
#line 776
    buf --;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 777
  res = snprintf((char */* __restrict  */)(buf + 1), (size_t )lenStr, (char const   */* __restrict  */)"; LEN=%u\n",
                 sp->len + offset);
  }
#line 778
  if (res < 0) {
    {
#line 779
    fatal("Sequence too long: %u\n", sp->len);
    }
  } else
#line 778
  if (res >= (int )lenStr) {
    {
#line 779
    fatal("Sequence too long: %u\n", sp->len);
    }
  }
#line 780
  return (0);
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void seq_revcomp_inplace(seq_p_t seq ) 
{ 
  unsigned char *s ;
  unsigned char *t ;
  unsigned char c ;
  unsigned char *tmp ;

  {
#line 786
  s = seq->seq;
#line 787
  t = seq->seq + seq->len;
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! ((unsigned long )s < (unsigned long )t)) {
#line 789
      goto while_break;
    }
#line 790
    t --;
#line 790
    c = (unsigned char )dna_complement[*t];
#line 791
    *t = (unsigned char )dna_complement[*s];
#line 792
    tmp = s;
#line 792
    s ++;
#line 792
    *tmp = c;
  }
  while_break: /* CIL Label */ ;
  }
#line 794
  return;
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/sim4.init.c"
static void bug_handler(int signum ) 
{ 


  {
  {
#line 799
  fflush(stdout);
#line 800
  fflush(stderr);
#line 801
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nCaught signal %d while processing:\n%.256s\n%.256s\n",
          signum, dna_seq_head, rna_seq_head);
#line 803
  abort();
  }
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
static int snake(uchar *seq1 , uchar *seq2 , int k , int x , int endx , int endy ) ;
#line 18
static int rsnake(uchar *seq1 , uchar *seq2 , int k , int x , int startx , int starty ,
                  int M , int N ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
void align_path(uchar *seq1 , uchar *seq2 , int i1 , int j1 , int i2 , int j2 , int dist ,
                edit_script_p_t *head , edit_script_p_t *tail , int M , int N ) 
{ 
  int *last_d ;
  int *temp_d ;
  int *rlast_d ;
  int *rtemp_d ;
  edit_script_p_t head1 ;
  edit_script_p_t tail1 ;
  edit_script_p_t head2 ;
  edit_script_p_t tail2 ;
  int midc ;
  int rmidc ;
  int start ;
  int lower ;
  int upper ;
  int rstart ;
  int rlower ;
  int rupper ;
  int c ;
  int k ;
  int row ;
  int mi ;
  int mj ;
  int tmp ;
  int ll ;
  int uu ;
  char flag ;
  edit_script_p_t tmp___0 ;
  void *tmp___1 ;
  edit_script_p_t tmp___2 ;
  void *tmp___3 ;
  edit_script_p_t tmp___4 ;
  void *tmp___5 ;
  edit_script_p_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;

  {
#line 37
  tmp___0 = (edit_script_p_t )((void *)0);
#line 37
  *tail = tmp___0;
#line 37
  *head = tmp___0;
#line 40
  if (i1 == i2) {
#line 41
    if (j1 == j2) {
#line 41
      *head = (edit_script_p_t )((void *)0);
    } else {
      {
#line 43
      tmp___1 = xmalloc(sizeof(edit_script_t ));
#line 43
      head1 = (edit_script_p_t )tmp___1;
#line 44
      head1->op_type = (char)2;
#line 45
      head1->num = j2 - j1;
#line 46
      head1->next = (struct _edit_script *)((void *)0);
#line 47
      tmp___2 = head1;
#line 47
      *tail = tmp___2;
#line 47
      *head = tmp___2;
      }
    }
#line 49
    return;
  }
#line 52
  if (j1 == j2) {
    {
#line 53
    tmp___3 = xmalloc(sizeof(edit_script_t ));
#line 53
    head1 = (edit_script_p_t )tmp___3;
#line 54
    head1->op_type = (char)1;
#line 55
    head1->num = i2 - i1;
#line 56
    head1->next = (struct _edit_script *)((void *)0);
#line 57
    tmp___4 = head1;
#line 57
    *tail = tmp___4;
#line 57
    *head = tmp___4;
    }
#line 58
    return;
  }
#line 61
  if (dist <= 1) {
#line 62
    start = j1 - i1;
#line 63
    if (j2 - i2 == j1 - i1) {
      {
#line 64
      tmp___5 = xmalloc(sizeof(edit_script_t ));
#line 64
      head1 = (edit_script_p_t )tmp___5;
#line 65
      head1->op_type = (char)3;
#line 66
      head1->num = i2 - i1;
#line 67
      head1->next = (struct _edit_script *)((void *)0);
#line 68
      tmp___6 = head1;
#line 68
      *tail = tmp___6;
#line 68
      *head = tmp___6;
      }
    } else
#line 69
    if (j2 - j1 == (i2 - i1) + 1) {
      {
#line 71
      tmp = snake(seq1, seq2, start, i1, i2, j2);
      }
#line 72
      if (tmp > i1) {
        {
#line 73
        tmp___7 = xmalloc(sizeof(edit_script_t ));
#line 73
        head1 = (edit_script_p_t )tmp___7;
#line 74
        head1->op_type = (char)3;
#line 75
        head1->num = tmp - i1;
#line 76
        *head = head1;
        }
      }
      {
#line 78
      tmp___8 = xmalloc(sizeof(edit_script_t ));
#line 78
      head2 = (edit_script_p_t )tmp___8;
#line 79
      head2->op_type = (char)2;
#line 80
      head2->num = 1;
      }
#line 82
      if (*head) {
#line 82
        head1->next = head2;
      } else {
#line 83
        *head = head2;
      }
#line 84
      *tail = head2;
#line 85
      head2->next = (struct _edit_script *)((void *)0);
#line 87
      if (i2 - tmp) {
        {
#line 88
        head1 = head2;
#line 89
        tmp___9 = xmalloc(sizeof(edit_script_t ));
#line 89
        head2 = (edit_script_p_t )tmp___9;
#line 89
        *tail = head2;
#line 90
        head2->op_type = (char)3;
#line 91
        head2->num = i2 - tmp;
#line 92
        head2->next = (struct _edit_script *)((void *)0);
#line 93
        head1->next = head2;
        }
      }
    } else
#line 95
    if ((j2 - j1) + 1 == i2 - i1) {
      {
#line 97
      tmp = snake(seq1, seq2, start, i1, i2, j2);
      }
#line 98
      if (tmp > i1) {
        {
#line 99
        tmp___10 = xmalloc(sizeof(edit_script_t ));
#line 99
        head1 = (edit_script_p_t )tmp___10;
#line 100
        head1->op_type = (char)3;
#line 101
        head1->num = tmp - i1;
#line 102
        *head = head1;
        }
      }
      {
#line 104
      tmp___11 = xmalloc(sizeof(edit_script_t ));
#line 104
      head2 = (edit_script_p_t )tmp___11;
#line 105
      head2->op_type = (char)1;
#line 106
      head2->num = 1;
      }
#line 108
      if (*head) {
#line 108
        head1->next = head2;
      } else {
#line 109
        *head = head2;
      }
#line 110
      *tail = head2;
#line 111
      head2->next = (struct _edit_script *)((void *)0);
#line 113
      if (i2 > tmp + 1) {
        {
#line 114
        head1 = head2;
#line 115
        tmp___12 = xmalloc(sizeof(edit_script_t ));
#line 115
        head2 = (edit_script_p_t )tmp___12;
#line 115
        *tail = head2;
#line 116
        head2->op_type = (char)3;
#line 117
        head2->num = (i2 - tmp) - 1;
#line 118
        head2->next = (struct _edit_script *)((void *)0);
#line 119
        head1->next = head2;
        }
      }
    } else {
      {
#line 122
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"align.c: warning: something wrong when aligning.");
      }
    }
#line 125
    return;
  }
#line 129
  midc = dist / 2;
#line 130
  rmidc = dist - midc;
#line 133
  start = j1 - i1;
#line 134
  if (j1 - i2 < start - midc) {
#line 134
    lower = start - midc;
  } else {
#line 134
    lower = j1 - i2;
  }
#line 135
  if (j2 - i1 > start + midc) {
#line 135
    upper = start + midc;
  } else {
#line 135
    upper = j2 - i1;
  }
#line 136
  rstart = j2 - i2;
#line 137
  if (j1 - i2 < rstart - rmidc) {
#line 137
    rlower = rstart - rmidc;
  } else {
#line 137
    rlower = j1 - i2;
  }
#line 138
  if (j2 - i1 > rstart + rmidc) {
#line 138
    rupper = rstart + rmidc;
  } else {
#line 138
    rupper = j2 - i1;
  }
  {
#line 141
  tmp___13 = xmalloc((size_t )((upper - lower) + 1) * sizeof(int ));
#line 141
  last_d = (int *)tmp___13 - lower;
#line 142
  tmp___14 = xmalloc((size_t )((upper - lower) + 1) * sizeof(int ));
#line 142
  temp_d = (int *)tmp___14 - lower;
#line 144
  k = lower;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (k <= upper)) {
#line 144
      goto while_break;
    }
#line 144
    *(last_d + k) = -1;
#line 144
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  *(last_d + start) = snake(seq1, seq2, start, i1, i2, j2);
#line 148
  c = 1;
  }
  {
#line 148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 148
    if (! (c <= midc)) {
#line 148
      goto while_break___0;
    }
#line 149
    if (lower < start - c) {
#line 149
      ll = start - c;
    } else {
#line 149
      ll = lower;
    }
#line 150
    if (upper > start + c) {
#line 150
      uu = start + c;
    } else {
#line 150
      uu = upper;
    }
#line 151
    k = ll;
    {
#line 151
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 151
      if (! (k <= uu)) {
#line 151
        goto while_break___1;
      }
#line 152
      if (k == ll) {
#line 154
        row = *(last_d + (k + 1)) + 1;
      } else
#line 155
      if (k == uu) {
#line 157
        row = *(last_d + (k - 1));
      } else
#line 158
      if (*(last_d + k) >= *(last_d + (k + 1))) {
#line 158
        if (*(last_d + k) + 1 >= *(last_d + (k - 1))) {
#line 161
          row = *(last_d + k) + 1;
        } else {
#line 158
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 162
      if (*(last_d + (k + 1)) + 1 >= *(last_d + (k - 1))) {
#line 162
        if (*(last_d + (k + 1)) >= *(last_d + k)) {
#line 165
          row = *(last_d + (k + 1)) + 1;
        } else {
#line 168
          row = *(last_d + (k - 1));
        }
      } else {
#line 168
        row = *(last_d + (k - 1));
      }
      {
#line 171
      *(temp_d + k) = snake(seq1, seq2, k, row, i2, j2);
#line 151
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 173
    k = ll;
    {
#line 173
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 173
      if (! (k <= uu)) {
#line 173
        goto while_break___2;
      }
#line 174
      *(last_d + k) = *(temp_d + k);
#line 173
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 148
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 178
  tmp___15 = xmalloc((size_t )((rupper - rlower) + 1) * sizeof(int ));
#line 178
  rlast_d = (int *)tmp___15 - rlower;
#line 179
  tmp___16 = xmalloc((size_t )((rupper - rlower) + 1) * sizeof(int ));
#line 179
  rtemp_d = (int *)tmp___16 - rlower;
#line 181
  k = rlower;
  }
  {
#line 181
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 181
    if (! (k <= rupper)) {
#line 181
      goto while_break___3;
    }
#line 181
    *(rlast_d + k) = i2 + 1;
#line 181
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 182
  *(rlast_d + rstart) = rsnake(seq1, seq2, rstart, i2, i1, j1, M, N);
#line 185
  c = 1;
  }
  {
#line 185
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 185
    if (! (c <= rmidc)) {
#line 185
      goto while_break___4;
    }
#line 186
    if (rlower < rstart - c) {
#line 186
      ll = rstart - c;
    } else {
#line 186
      ll = rlower;
    }
#line 187
    if (rupper > rstart + c) {
#line 187
      uu = rstart + c;
    } else {
#line 187
      uu = rupper;
    }
#line 188
    k = ll;
    {
#line 188
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 188
      if (! (k <= uu)) {
#line 188
        goto while_break___5;
      }
#line 189
      if (k == ll) {
#line 191
        row = *(rlast_d + (k + 1));
      } else
#line 192
      if (k == uu) {
#line 194
        row = *(rlast_d + (k - 1)) - 1;
      } else
#line 195
      if (*(rlast_d + k) - 1 <= *(rlast_d + (k + 1))) {
#line 195
        if (*(rlast_d + k) - 1 <= *(rlast_d + (k - 1)) - 1) {
#line 198
          row = *(rlast_d + k) - 1;
        } else {
#line 195
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 199
      if (*(rlast_d + (k - 1)) - 1 <= *(rlast_d + (k + 1))) {
#line 199
        if (*(rlast_d + (k - 1)) - 1 <= *(rlast_d + k) - 1) {
#line 202
          row = *(rlast_d + (k - 1)) - 1;
        } else {
#line 205
          row = *(rlast_d + (k + 1));
        }
      } else {
#line 205
        row = *(rlast_d + (k + 1));
      }
      {
#line 208
      *(rtemp_d + k) = rsnake(seq1, seq2, k, row, i1, j1, M, N);
#line 188
      k ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 210
    k = ll;
    {
#line 210
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 210
      if (! (k <= uu)) {
#line 210
        goto while_break___6;
      }
#line 211
      *(rlast_d + k) = *(rtemp_d + k);
#line 210
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 185
    c ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 218
  flag = (char)0;
#line 219
  mi = i1;
#line 219
  mj = j1;
#line 220
  if (lower < rlower) {
#line 220
    ll = rlower;
  } else {
#line 220
    ll = lower;
  }
#line 220
  if (upper > rupper) {
#line 220
    uu = rupper;
  } else {
#line 220
    uu = upper;
  }
#line 221
  k = ll;
  {
#line 221
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 221
    if (! (k <= uu)) {
#line 221
      goto while_break___7;
    }
#line 222
    if (*(last_d + k) >= *(rlast_d + k)) {
#line 223
      if (*(last_d + k) - i1 >= i2 - *(rlast_d + k)) {
#line 224
        mi = *(last_d + k);
#line 224
        mj = k + mi;
      } else {
#line 226
        mi = *(rlast_d + k);
#line 226
        mj = k + mi;
      }
#line 228
      flag = (char)1;
#line 230
      goto while_break___7;
    }
#line 221
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 233
  free((void *)(last_d + lower));
#line 233
  free((void *)(rlast_d + rlower));
#line 234
  free((void *)(temp_d + lower));
#line 234
  free((void *)(rtemp_d + rlower));
  }
#line 236
  if (flag) {
    {
#line 238
    align_path(seq1, seq2, i1, j1, mi, mj, midc, & head1, & tail1, M, N);
#line 241
    align_path(seq1, seq2, mi, mj, i2, j2, rmidc, & head2, & tail2, M, N);
    }
#line 244
    if (head1) {
#line 244
      tail1->next = head2;
    } else {
#line 245
      head1 = head2;
    }
  } else {
    {
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"align.c: warning: something wrong when dividing\n");
#line 249
    head1 = (edit_script_p_t )((void *)0);
    }
  }
#line 251
  *head = head1;
#line 252
  if (head2) {
#line 252
    *tail = tail2;
  } else {
#line 253
    *tail = tail1;
  }
#line 254
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
int align_get_dist(uchar *seq1 , uchar *seq2 , int i1 , int j1 , int i2 , int j2 ,
                   int limit ) 
{ 
  int *last_d ;
  int *temp_d ;
  int goal_diag ;
  int ll ;
  int uu ;
  int c ;
  int k ;
  int row ;
  int start ;
  int lower ;
  int upper ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 267
  start = j1 - i1;
#line 268
  if (j1 - i2 < start - limit) {
#line 268
    lower = start - limit;
  } else {
#line 268
    lower = j1 - i2;
  }
#line 269
  if (j2 - i1 > start + limit) {
#line 269
    upper = start + limit;
  } else {
#line 269
    upper = j2 - i1;
  }
#line 270
  goal_diag = j2 - i2;
#line 272
  if (goal_diag > upper) {
#line 273
    return (-1);
  } else
#line 272
  if (goal_diag < lower) {
#line 273
    return (-1);
  }
  {
#line 276
  tmp = xmalloc((size_t )((upper - lower) + 1) * sizeof(int ));
#line 276
  last_d = (int *)tmp - lower;
#line 277
  tmp___0 = xmalloc((size_t )((upper - lower) + 1) * sizeof(int ));
#line 277
  temp_d = (int *)tmp___0 - lower;
#line 280
  k = lower;
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (k <= upper)) {
#line 280
      goto while_break;
    }
#line 280
    *(last_d + k) = (-0x7FFFFFFF-1);
#line 280
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  *(last_d + start) = snake(seq1, seq2, start, i1, i2, j2);
  }
#line 283
  if (*(last_d + goal_diag) >= i2) {
    {
#line 285
    free((void *)(last_d + lower));
#line 286
    free((void *)(temp_d + lower));
    }
#line 287
    return (0);
  }
#line 290
  c = 1;
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (! (c <= limit)) {
#line 290
      goto while_break___0;
    }
#line 291
    if (lower < start - c) {
#line 291
      ll = start - c;
    } else {
#line 291
      ll = lower;
    }
#line 291
    if (upper > start + c) {
#line 291
      uu = start + c;
    } else {
#line 291
      uu = upper;
    }
#line 292
    k = ll;
    {
#line 292
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 292
      if (! (k <= uu)) {
#line 292
        goto while_break___1;
      }
#line 293
      if (k == ll) {
#line 294
        row = *(last_d + (k + 1)) + 1;
      } else
#line 295
      if (k == uu) {
#line 296
        row = *(last_d + (k - 1));
      } else
#line 297
      if (*(last_d + k) >= *(last_d + (k + 1))) {
#line 297
        if (*(last_d + k) + 1 >= *(last_d + (k - 1))) {
#line 299
          row = *(last_d + k) + 1;
        } else {
#line 297
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 300
      if (*(last_d + (k + 1)) + 1 >= *(last_d + (k - 1))) {
#line 300
        if (*(last_d + (k + 1)) >= *(last_d + k)) {
#line 302
          row = *(last_d + (k + 1)) + 1;
        } else {
#line 304
          row = *(last_d + (k - 1));
        }
      } else {
#line 304
        row = *(last_d + (k - 1));
      }
      {
#line 306
      *(temp_d + k) = snake(seq1, seq2, k, row, i2, j2);
#line 292
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 309
    k = ll;
    {
#line 309
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 309
      if (! (k <= uu)) {
#line 309
        goto while_break___2;
      }
#line 309
      *(last_d + k) = *(temp_d + k);
#line 309
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 311
    if (*(last_d + goal_diag) >= i2) {
      {
#line 313
      free((void *)(last_d + lower));
#line 314
      free((void *)(temp_d + lower));
      }
#line 315
      return (c);
    }
#line 290
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 320
  return (-1);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
void Condense_both_Ends(edit_script_p_t *head , edit_script_p_t *tail , edit_script_p_t *prev ) 
{ 
  edit_script_p_t tp ;
  edit_script_p_t tp1 ;

  {
#line 330
  tp = *head;
#line 330
  *prev = (edit_script_p_t )((void *)0);
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
#line 331
      goto while_break;
    }
    {
#line 332
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 332
      tp1 = tp->next;
#line 332
      if ((unsigned long )tp1 != (unsigned long )((void *)0)) {
#line 332
        if (! ((int )tp->op_type == (int )tp1->op_type)) {
#line 332
          goto while_break___0;
        }
      } else {
#line 332
        goto while_break___0;
      }
      {
#line 333
      tp->num += tp1->num;
#line 334
      tp->next = tp1->next;
#line 335
      free((void *)tp1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 337
    if (tp->next) {
#line 337
      *prev = tp;
    } else {
#line 338
      *tail = tp;
    }
#line 339
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return;
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
void S2A(edit_script_p_t head , int *S ) 
{ 
  edit_script_p_t tp ;
  int *lastS ;
  int i ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 348
  tp = head;
#line 349
  lastS = S;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
#line 350
      goto while_break;
    }
#line 354
    if ((int )tp->op_type == 3) {
#line 355
      i = 0;
      {
#line 355
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 355
        if (! (i < tp->num)) {
#line 355
          goto while_break___0;
        }
#line 356
        tmp = lastS;
#line 356
        lastS ++;
#line 356
        *tmp = 0;
#line 355
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 357
    if ((int )tp->op_type == 2) {
#line 358
      tmp___0 = lastS;
#line 358
      lastS ++;
#line 358
      *tmp___0 = tp->num;
    } else
#line 359
    if ((int )tp->op_type == 4) {
#line 360
      tmp___1 = lastS;
#line 360
      lastS ++;
#line 360
      *tmp___1 = 2147483647;
#line 361
      tmp___2 = lastS;
#line 361
      lastS ++;
#line 361
      *tmp___2 = tp->num;
    } else {
#line 363
      tmp___3 = lastS;
#line 363
      lastS ++;
#line 363
      *tmp___3 = 0 - tp->num;
    }
#line 365
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  *(S - 1) = (int )(lastS - S);
#line 368
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
static uchar ALINE[51]  ;
#line 372 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
static uchar BLINE[51]  ;
#line 372 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
static uchar CLINE[51]  ;
#line 374 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
static unsigned int get_pos_width(collec_p_t eCol ) 
{ 
  unsigned int last ;
  unsigned int w ;

  {
#line 377
  last = (*(eCol->e.exon + (eCol->nb - 1U)))->to1 + options.dnaOffset;
#line 378
  w = 1U;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    last /= 10U;
#line 379
    if (! (last > 0U)) {
#line 379
      goto while_break;
    }
#line 380
    w ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  if (w < 7U) {
#line 382
    w = 7U;
  }
#line 383
  return (w);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
void IDISPLAY(uchar *A , uchar *B , unsigned int M , unsigned int N , int *S , unsigned int AP ,
              unsigned int BP , collec_p_t eCol , int direction ) 
{ 
  uchar *a ;
  uchar *b ;
  uchar *c ;
  uchar sign ;
  int op ;
  int index ;
  int starti ;
  int shiftA ;
  unsigned int i ;
  unsigned int j ;
  unsigned int lines ;
  unsigned int ap ;
  unsigned int bp ;
  unsigned int pWidth ;
  unsigned int ii ;
  exon_p_t ep ;
  int *tmp ;
  uchar *tmp___0 ;
  int tmp___3 ;
  uchar *tmp___4 ;
  uchar *tmp___5 ;
  int *tmp___6 ;
  uchar *tmp___7 ;
  uchar *tmp___8 ;
  uchar *tmp___9 ;
  int *tmp___10 ;
  uchar *tmp___11 ;
  uchar *tmp___12 ;
  uchar *tmp___13 ;
  uchar *tmp___14 ;
  uchar *tmp___15 ;
  uchar *tmp___16 ;
  uchar *tmp___17 ;
  uchar *tmp___18 ;
  uchar *tmp___19 ;
  uchar *tmp___20 ;
  uchar *tmp___21 ;
  uchar *tmp___22 ;
  uchar *tmp___23 ;
  uchar *tmp___24 ;
  uchar *tmp___25 ;
  uchar *tmp___26 ;
  uchar *tmp___27 ;
  uchar *tmp___28 ;
  uchar *tmp___29 ;
  uchar *tmp___30 ;
  uchar *tmp___31 ;
  uchar tmp___32 ;
  uchar tmp___33 ;
  unsigned int tmp___34 ;

  {
#line 392
  shiftA = 0;
#line 394
  ii = 0U;
#line 397
  if (! (eCol->nb > 0U)) {
    {
#line 397
    __assert_fail("eCol->nb > 0", "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c",
                  397U, "IDISPLAY");
    }
  }
  {
#line 399
  pWidth = get_pos_width(eCol);
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (ii < eCol->nb) {
#line 401
      ep = *(eCol->e.exon + ii);
#line 401
      if (! (ep->from1 != AP)) {
#line 401
        if (! (ep->from2 != BP)) {
#line 401
          goto while_break;
        }
      }
    } else {
#line 401
      goto while_break;
    }
#line 403
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  if (ii >= eCol->nb) {
    {
#line 405
    fatal("align.c: Alignment fragment not found.\n");
    }
  }
#line 406
  lines = 0U;
#line 406
  j = lines;
#line 406
  i = j;
#line 407
  index = 0;
#line 407
  op = index;
#line 408
  sign = (uchar )'*';
#line 409
  ap = AP;
#line 410
  bp = BP;
#line 411
  a = ALINE;
#line 412
  b = BLINE;
#line 413
  c = CLINE;
#line 414
  if (ii < eCol->nb - 1U) {
#line 414
    starti = (int )ep->to1 + 1;
  } else {
#line 414
    starti = -1;
  }
  {
#line 416
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 416
    if (! (i < M)) {
#line 416
      if (! (j < N)) {
#line 416
        goto while_break___0;
      }
    }
#line 417
    if (op == 0) {
#line 417
      if (*S == 0) {
#line 418
        tmp = S;
#line 418
        S ++;
#line 418
        op = *tmp;
#line 419
        i ++;
#line 419
        *a = *(A + i);
#line 420
        j ++;
#line 420
        *b = *(B + j);
#line 421
        tmp___0 = c;
#line 421
        c ++;
#line 421
        tmp___4 = a;
#line 421
        a ++;
#line 421
        tmp___5 = b;
#line 421
        b ++;
#line 421
        if ((int )*tmp___4 == (int )*tmp___5) {
#line 421
          tmp___3 = '|';
        } else {
#line 421
          tmp___3 = ' ';
        }
#line 421
        *tmp___0 = (unsigned char )tmp___3;
      } else {
#line 417
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 423
      if (op == 0) {
#line 424
        tmp___6 = S;
#line 424
        S ++;
#line 424
        op = *tmp___6;
      }
#line 425
      if (op > 0) {
#line 425
        if (op != 2147483647) {
#line 426
          tmp___7 = a;
#line 426
          a ++;
#line 426
          *tmp___7 = (uchar )' ';
#line 427
          tmp___8 = b;
#line 427
          b ++;
#line 427
          j ++;
#line 427
          *tmp___8 = *(B + j);
#line 428
          tmp___9 = c;
#line 428
          c ++;
#line 428
          *tmp___9 = (uchar )'-';
#line 429
          op --;
        } else {
#line 425
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 431
        if (op == 2147483647) {
#line 432
          tmp___10 = S;
#line 432
          S ++;
#line 432
          shiftA = *tmp___10;
#line 433
          op = -10;
        }
#line 435
        if ((int )(i + AP) == starti) {
#line 437
          if (ep->type < 0) {
#line 438
            sign = (uchar )'=';
          } else
#line 437
          if (direction == 0) {
#line 438
            sign = (uchar )'=';
          } else
#line 439
          if (direction > 0) {
#line 440
            sign = (uchar )'>';
          } else {
#line 442
            sign = (uchar )'<';
          }
#line 443
          ii ++;
#line 444
          if (ii < eCol->nb) {
#line 444
            ep = *(eCol->e.exon + ii);
          } else {
#line 444
            ep = (exon_p_t )((void *)0);
          }
#line 445
          if (ii < eCol->nb - 1U) {
#line 445
            starti = (int )ep->to1 + 1;
          } else {
#line 445
            starti = -1;
          }
#line 446
          if (shiftA != 0) {
#line 447
            AP = ep->from1 - 3U;
          }
#line 448
          index = 1;
#line 449
          tmp___11 = c;
#line 449
          c ++;
#line 449
          *tmp___11 = sign;
#line 450
          tmp___12 = a;
#line 450
          a ++;
#line 450
          i ++;
#line 450
          *tmp___12 = *(A + i);
#line 451
          tmp___13 = b;
#line 451
          b ++;
#line 451
          *tmp___13 = (uchar )' ';
#line 452
          op ++;
        } else
#line 453
        if (! index) {
#line 454
          tmp___14 = c;
#line 454
          c ++;
#line 454
          *tmp___14 = (uchar )'-';
#line 455
          tmp___15 = a;
#line 455
          a ++;
#line 455
          i ++;
#line 455
          *tmp___15 = *(A + i);
#line 456
          tmp___16 = b;
#line 456
          b ++;
#line 456
          *tmp___16 = (uchar )' ';
#line 457
          op ++;
        } else {
          {
#line 463
          if (index == 2) {
#line 463
            goto case_2;
          }
#line 463
          if (index == 1) {
#line 463
            goto case_2;
          }
#line 463
          if (index == 0) {
#line 463
            goto case_2;
          }
#line 471
          if (index == 4) {
#line 471
            goto case_4;
          }
#line 471
          if (index == 3) {
#line 471
            goto case_4;
          }
#line 479
          if (index == 5) {
#line 479
            goto case_5;
          }
#line 496
          if (index == 7) {
#line 496
            goto case_7;
          }
#line 496
          if (index == 6) {
#line 496
            goto case_7;
          }
#line 503
          if (index == 8) {
#line 503
            goto case_8;
          }
#line 460
          goto switch_break;
          case_2: /* CIL Label */ 
          case_1: /* CIL Label */ 
          case_0: /* CIL Label */ 
#line 464
          tmp___17 = a;
#line 464
          a ++;
#line 464
          i ++;
#line 464
          *tmp___17 = *(A + i);
#line 465
          tmp___18 = b;
#line 465
          b ++;
#line 465
          *tmp___18 = (uchar )' ';
#line 466
          tmp___19 = c;
#line 466
          c ++;
#line 466
          *tmp___19 = sign;
#line 467
          op ++;
#line 468
          index ++;
#line 469
          goto switch_break;
          case_4: /* CIL Label */ 
          case_3: /* CIL Label */ 
#line 472
          tmp___20 = a;
#line 472
          a ++;
#line 472
          *tmp___20 = (uchar )'.';
#line 473
          tmp___21 = b;
#line 473
          b ++;
#line 473
          *tmp___21 = (uchar )' ';
#line 474
          tmp___22 = c;
#line 474
          c ++;
#line 474
          *tmp___22 = (uchar )'.';
#line 475
          i ++;
#line 476
          op ++;
#line 477
          index ++;
#line 478
          goto switch_break;
          case_5: /* CIL Label */ 
#line 480
          tmp___23 = a;
#line 480
          a ++;
#line 480
          *tmp___23 = (uchar )'.';
#line 481
          tmp___24 = b;
#line 481
          b ++;
#line 481
          *tmp___24 = (uchar )' ';
#line 482
          tmp___25 = c;
#line 482
          c ++;
#line 482
          *tmp___25 = (uchar )'.';
#line 483
          if (shiftA != 0) {
#line 484
            A += shiftA;
#line 485
            A += i;
#line 486
            A -= 8;
#line 487
            shiftA = 0;
#line 488
            i = 0U;
#line 489
            M = 0U;
          } else {
#line 491
            i += (unsigned int )(- op) - 3U;
          }
#line 492
          op = -3;
#line 493
          index ++;
#line 494
          goto switch_break;
          case_7: /* CIL Label */ 
          case_6: /* CIL Label */ 
#line 497
          tmp___26 = a;
#line 497
          a ++;
#line 497
          i ++;
#line 497
          *tmp___26 = *(A + i);
#line 498
          tmp___27 = b;
#line 498
          b ++;
#line 498
          *tmp___27 = (uchar )' ';
#line 499
          tmp___28 = c;
#line 499
          c ++;
#line 499
          *tmp___28 = sign;
#line 500
          op ++;
#line 501
          index ++;
#line 502
          goto switch_break;
          case_8: /* CIL Label */ 
#line 504
          tmp___29 = a;
#line 504
          a ++;
#line 504
          i ++;
#line 504
          *tmp___29 = *(A + i);
#line 505
          tmp___30 = b;
#line 505
          b ++;
#line 505
          *tmp___30 = (uchar )' ';
#line 506
          tmp___31 = c;
#line 506
          c ++;
#line 506
          *tmp___31 = sign;
#line 507
          op ++;
#line 508
          index = 0;
#line 509
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
#line 514
    if ((unsigned long )a >= (unsigned long )(ALINE + 50)) {
#line 514
      goto _L___1;
    } else
#line 514
    if (i >= M) {
#line 514
      if (j >= N) {
        _L___1: /* CIL Label */ 
        {
#line 515
        tmp___33 = (uchar )'\000';
#line 515
        *c = tmp___33;
#line 515
        tmp___32 = tmp___33;
#line 515
        *b = tmp___32;
#line 515
        *a = tmp___32;
#line 516
        tmp___34 = lines;
#line 516
        lines ++;
#line 516
        printf((char const   */* __restrict  */)"\n%*u ", pWidth, 50U * tmp___34);
#line 517
        b = ALINE + 10;
        }
        {
#line 517
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 517
          if (! ((unsigned long )b <= (unsigned long )a)) {
#line 517
            goto while_break___1;
          }
          {
#line 518
          printf((char const   */* __restrict  */)"    .    :");
#line 517
          b += 10;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 519
        if ((unsigned long )b <= (unsigned long )(a + 5)) {
          {
#line 520
          printf((char const   */* __restrict  */)"    .");
          }
        }
        {
#line 521
        printf((char const   */* __restrict  */)"\n%*u %s\n%*s %s\n%*u %s\n", pWidth,
               ap + options.dnaOffset, ALINE, pWidth, " ", CLINE, pWidth, bp, BLINE);
#line 525
        ap = AP + i;
#line 526
        bp = BP + j;
#line 527
        a = ALINE;
#line 528
        b = BLINE;
#line 529
        c = CLINE;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 532
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
void Free_script(edit_script_p_t head ) 
{ 
  edit_script_p_t tp ;
  edit_script_p_t tp1 ;

  {
#line 539
  tp = head;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
#line 540
      goto while_break;
    }
    {
#line 541
    tp1 = tp->next;
#line 542
    free((void *)tp);
#line 543
    tp = tp1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
static int snake(uchar *seq1 , uchar *seq2 , int k , int x , int endx , int endy ) 
{ 
  int y ;

  {
#line 552
  if (x < 0) {
#line 552
    return (x);
  }
#line 553
  y = x + k;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (x < endx) {
#line 554
      if (y < endy) {
#line 554
        if (! ((int )*(seq1 + x) == (int )*(seq2 + y))) {
#line 554
          goto while_break;
        }
      } else {
#line 554
        goto while_break;
      }
    } else {
#line 554
      goto while_break;
    }
#line 555
    x ++;
#line 555
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return (x);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/sibsim4-0.20/align.c"
static int rsnake(uchar *seq1 , uchar *seq2 , int k , int x , int startx , int starty ,
                  int M , int N ) 
{ 
  int y ;

  {
#line 567
  if (x > M) {
#line 568
    return (x);
  }
#line 569
  if (startx < 0) {
    {
#line 570
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TROUBLE!!! startx:  %5d,  starty:  %5d\n",
            startx, starty);
    }
  } else
#line 569
  if (starty < 0) {
    {
#line 570
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TROUBLE!!! startx:  %5d,  starty:  %5d\n",
            startx, starty);
    }
  }
#line 571
  if (x + k > N) {
    {
#line 572
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TROUBLE!!! x:  %5d,  y:  %5d\n",
            x, x + k);
    }
  }
#line 574
  y = x + k;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if (x > startx) {
#line 575
      if (y > starty) {
#line 575
        if (! ((int )*(seq1 + (x - 1)) == (int )*(seq2 + (y - 1)))) {
#line 575
          goto while_break;
        }
      } else {
#line 575
        goto while_break;
      }
    } else {
#line 575
      goto while_break;
    }
#line 576
    x --;
#line 577
    y --;
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  return (x);
}
}
