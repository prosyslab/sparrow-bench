/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_12 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_12 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgi.h"
struct _cgi_field {
   char *name ;
   char *value ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgi.h"
typedef struct _cgi_field cgi_field;
#line 26 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgi.h"
struct _cgi_form {
   char *source ;
   char *storage ;
   cgi_field *fields ;
   size_t maxstorage ;
   size_t maxfields ;
   size_t nfields ;
   int errcond ;
   char errmsg[1024] ;
   char errinfo[1024] ;
   FILE *tmpf ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgi.h"
typedef struct _cgi_form cgi_form;
#line 943 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 943 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
union __anonunion_53___0 {
   int __in ;
   int __i ;
};
#line 943 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
union __anonunion_53___1 {
   int __in ;
   int __i ;
};
#line 943 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
union __anonunion_53___2 {
   int __in ;
   int __i ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 195
extern FILE *tmpfile(void) ;
#line 209
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) tmpnam)(char *__s ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgi-ptypes.h"
int cgi_alloc_form(cgi_form *formp ) ;
#line 10
void cgi_free_form(cgi_form *formp ) ;
#line 11
int cgi_parallel_fname(char *basename , char *buf , int buflen ) ;
#line 12
void cgi_fix_crlf(char *string ) ;
#line 13
int cgi_nonblank(char *string ) ;
#line 14
int cgi_parse_form(cgi_form *formp ) ;
#line 15
void cgi_print_form(cgi_form *formp , FILE *outstream ) ;
#line 16
char *cgi_value(cgi_form *formp , char *name ) ;
#line 17
char *cgi_char2entity(int c ) ;
#line 18
void cgi_string2url(char *instring , FILE *outstream ) ;
#line 19
void cgi_string2html(char *instring , FILE *outstream ) ;
#line 20
void cgi_stream2html(FILE *instream , FILE *outstream ) ;
#line 21
int cgi_output_value(cgi_form *formp , char *name , char *formatstr , FILE *outstream ) ;
#line 22
void cgi_concat_errno(char *string ) ;
#line 23
int cgi_template_fill(cgi_form *formp , char *templatefile ) ;
#line 24
void cgi_pclose_fix(void) ;
#line 25
int cgi_mail_template(cgi_form *formp , char *templatefile ) ;
#line 26
void cgi_output_failure(cgi_form *formp , char *msg ) ;
#line 27
void cgi_redirect(char *url ) ;
#line 28
void cgi_output_success(cgi_form *formp , char *msg ) ;
#line 29
int cgi_standard_email(void) ;
#line 30
int cgi_standard_echo(void) ;
#line 31
int cgi_standard_file(void) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
char *cgi_query  =    (char *)0;
#line 29 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
time_t received_time  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
char datebuf[80]  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int noheader  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int flag  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void strip_nonprint(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! *s) {
#line 37
      goto while_break;
    }
    {
#line 38
    tmp = __ctype_b_loc();
    }
#line 38
    if (! ((int const   )*(*tmp + (int )*s) & 16384)) {
#line 38
      *s = (char )' ';
    }
#line 39
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_alloc_form(cgi_form *formp ) 
{ 
  char *env_var ;
  int content_length ;
  int total ;
  int bytes_read ;
  void *tmp ;
  ssize_t tmp___0 ;
  char *progname ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 49
  memset((void *)formp, 0, sizeof(cgi_form ));
  }
#line 52
  if (! cgi_query) {
    {
#line 54
    env_var = getenv("REQUEST_METHOD");
    }
#line 55
    if (! env_var) {
      {
#line 57
      formp->errcond = 1;
#line 58
      strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"400 REQUEST_METHOD not set.");
      }
#line 59
      return (1);
    }
    {
#line 61
    tmp___1 = strcmp((char const   *)env_var, "GET");
    }
#line 61
    if (tmp___1) {
      {
#line 74
      total = 0;
#line 76
      env_var = getenv("CONTENT_LENGTH");
      }
#line 77
      if (! env_var) {
        {
#line 79
        formp->errcond = 1;
#line 80
        sprintf((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"400 CONTENT_LENGTH not set.");
        }
#line 82
        return (1);
      }
      {
#line 84
      content_length = atoi((char const   *)env_var);
#line 85
      tmp = malloc((size_t )(content_length + 1));
#line 85
      cgi_query = (char *)tmp;
      }
#line 86
      if (! cgi_query) {
        {
#line 88
        formp->errcond = 1;
#line 89
        sprintf((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"503 Couldn\'t allocate %d bytes of memory.",
                content_length + 1);
        }
#line 92
        return (1);
      }
      {
#line 94
      while (1) {
        while_continue: /* CIL Label */ ;
#line 94
        if (! (total < content_length)) {
#line 94
          goto while_break;
        }
        {
#line 96
        tmp___0 = read(0, (void *)(cgi_query + total), (size_t )content_length);
#line 96
        bytes_read = (int )tmp___0;
        }
#line 99
        if (bytes_read <= 0) {
          {
#line 103
          progname = getenv("SCRIPT_NAME");
          }
#line 104
          if (! progname) {
#line 104
            progname = (char *)"cgiemail";
          }
#line 105
          if (bytes_read < 0) {
            {
#line 105
            perror((char const   *)progname);
            }
          } else {
            {
#line 106
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: read() returned 0.\n",
                    progname);
            }
          }
#line 107
          return (1);
        }
#line 109
        total += bytes_read;
      }
      while_break: /* CIL Label */ ;
      }
#line 112
      *(cgi_query + content_length) = (char )'\000';
    } else {
      {
#line 63
      cgi_query = getenv("QUERY_STRING");
      }
#line 64
      if (! cgi_query) {
        {
#line 66
        formp->errcond = 1;
#line 67
        strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"400 REQUEST_METHOD is GET, but QUERY_STRING is not set.");
        }
#line 69
        return (1);
      }
    }
  }
#line 116
  formp->source = cgi_query;
#line 117
  if (! formp->source) {
    {
#line 119
    formp->errcond = 1;
#line 120
    strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"400 Could not read form input.");
    }
#line 121
    return (1);
  }
  {
#line 125
  tmp___2 = strlen((char const   *)formp->source);
#line 125
  formp->maxstorage = tmp___2 + 1UL;
#line 126
  formp->maxfields = formp->maxstorage / 4UL + 1UL;
#line 129
  tmp___3 = malloc(formp->maxstorage);
#line 129
  formp->storage = (char *)tmp___3;
  }
#line 130
  if (! formp->storage) {
    {
#line 132
    formp->errcond = 1;
#line 133
    sprintf((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"503 Couldn\'t allocate %d bytes of memory.",
            formp->maxstorage);
    }
#line 135
    return (1);
  }
  {
#line 137
  tmp___4 = malloc(formp->maxfields * sizeof(cgi_field ));
#line 137
  formp->fields = (cgi_field *)tmp___4;
  }
#line 138
  if (! formp->fields) {
    {
#line 140
    free((void *)formp->storage);
#line 141
    formp->errcond = 1;
#line 142
    sprintf((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"503 Couldn\'t allocate %d bytes of memory.",
            formp->maxfields * sizeof(cgi_field ));
    }
#line 144
    return (1);
  }
#line 147
  return (0);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_free_form(cgi_form *formp ) 
{ 


  {
#line 154
  if (formp) {
#line 156
    if (formp->storage) {
      {
#line 156
      free((void *)formp->storage);
      }
    }
#line 157
    if (formp->fields) {
      {
#line 157
      free((void *)formp->fields);
      }
    }
  }
#line 159
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_parallel_fname(char *basename , char *buf , int buflen ) 
{ 
  int dlen ;
  char *env_var ;
  char *dir_end ;
  size_t tmp ;

  {
  {
#line 174
  env_var = getenv("PATH_TRANSLATED");
  }
#line 175
  if (! env_var) {
#line 176
    return (1);
  }
  {
#line 177
  dir_end = strrchr((char const   *)env_var, '/');
  }
#line 178
  if (! dir_end) {
#line 179
    return (1);
  }
  {
#line 180
  dlen = (int )((dir_end - env_var) + 1L);
#line 182
  tmp = strlen((char const   *)basename);
  }
#line 182
  if ((size_t )(1 + dlen) + tmp > (size_t )buflen) {
#line 183
    return (1);
  }
  {
#line 185
  strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)env_var,
          (size_t )dlen);
#line 186
  strcpy((char */* __restrict  */)(buf + dlen), (char const   */* __restrict  */)basename);
  }
#line 187
  return (0);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_fix_crlf(char *string ) 
{ 
  char *ptr ;

  {
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 197
    ptr = strchr((char const   *)string, '\r');
    }
#line 197
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 197
      goto while_break;
    }
#line 199
    if ((int )*(ptr + 1) == 10) {
      {
#line 199
      strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)(ptr + 1));
      }
    } else {
#line 200
      *ptr = (char )'\n';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_nonblank(char *string ) 
{ 
  char *ptr ;
  unsigned short const   **tmp ;

  {
#line 212
  ptr = string;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! *ptr) {
#line 212
      goto while_break;
    }
    {
#line 213
    tmp = __ctype_b_loc();
    }
#line 213
    if ((int const   )*(*tmp + (int )*ptr) & 32768) {
#line 213
      return (1);
    }
#line 212
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (0);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_parse_form(cgi_form *formp ) 
{ 
  char *from_ptr ;
  char *to_ptr ;
  cgi_field *field_ptr ;
  char hex_string[3] ;
  int parse_state ;
  int hex_int ;
  int i ;
  struct tm *timeptr ;
  char *tmp ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 233
  parse_state = 0;
#line 239
  time(& received_time);
#line 240
  timeptr = localtime((time_t const   *)(& received_time));
#line 241
  strftime((char */* __restrict  */)(datebuf), (size_t )79, (char const   */* __restrict  */)"%a, %d %b %Y %H:%M:%S %Z",
           (struct tm  const  */* __restrict  */)timeptr);
#line 244
  field_ptr = formp->fields;
#line 245
  formp->nfields = (size_t )0;
#line 246
  hex_string[2] = (char )'\000';
#line 249
  from_ptr = formp->source;
#line 249
  to_ptr = formp->storage;
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if ((int )*from_ptr != 0) {
#line 249
      if (! ((size_t )(to_ptr - formp->storage) < formp->maxstorage)) {
#line 249
        goto while_break;
      }
    } else {
#line 249
      goto while_break;
    }
#line 253
    if (parse_state == 0) {
#line 256
      field_ptr->name = to_ptr;
#line 257
      (formp->nfields) ++;
#line 258
      parse_state ++;
    }
#line 260
    if (parse_state == 2) {
#line 263
      field_ptr->value = to_ptr;
#line 264
      parse_state ++;
    }
#line 266
    if ((int )*(from_ptr + 0) == 37) {
      {
#line 266
      tmp___5 = __ctype_b_loc();
      }
#line 266
      if ((int const   )*(*tmp___5 + (int )*(from_ptr + 1)) & 2048) {
#line 266
        tmp___4 = 1;
      } else
#line 266
      if (65 <= (int )*(from_ptr + 1)) {
#line 266
        if ((int )*(from_ptr + 1) <= 70) {
#line 266
          tmp___4 = 1;
        } else {
#line 266
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 266
      if (97 <= (int )*(from_ptr + 1)) {
#line 266
        if ((int )*(from_ptr + 1) <= 102) {
#line 266
          tmp___4 = 1;
        } else {
#line 266
          tmp___4 = 0;
        }
      } else {
#line 266
        tmp___4 = 0;
      }
#line 266
      if (tmp___4) {
#line 269
        if ((int )*(from_ptr + 1) == 48) {
#line 269
          if ((int )*(from_ptr + 2) == 97) {
#line 271
            hex_string[0] = (char )'2';
#line 272
            hex_string[1] = (char )'0';
          } else
#line 269
          if ((int )*(from_ptr + 2) == 100) {
#line 271
            hex_string[0] = (char )'2';
#line 272
            hex_string[1] = (char )'0';
          } else {
#line 276
            hex_string[0] = *(from_ptr + 1);
#line 277
            hex_string[1] = *(from_ptr + 2);
          }
        } else {
#line 276
          hex_string[0] = *(from_ptr + 1);
#line 277
          hex_string[1] = *(from_ptr + 2);
        }
        {
#line 279
        sscanf((char const   */* __restrict  */)(hex_string), (char const   */* __restrict  */)"%x",
               & hex_int);
#line 280
        tmp = to_ptr;
#line 280
        to_ptr ++;
#line 280
        *tmp = (char )hex_int;
#line 281
        tmp___2 = __ctype_b_loc();
        }
#line 281
        if ((int const   )*(*tmp___2 + (int )*(from_ptr + 2)) & 2048) {
#line 281
          tmp___1 = 1;
        } else
#line 281
        if (65 <= (int )*(from_ptr + 2)) {
#line 281
          if ((int )*(from_ptr + 2) <= 70) {
#line 281
            tmp___1 = 1;
          } else {
#line 281
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 281
        if (97 <= (int )*(from_ptr + 2)) {
#line 281
          if ((int )*(from_ptr + 2) <= 102) {
#line 281
            tmp___1 = 1;
          } else {
#line 281
            tmp___1 = 0;
          }
        } else {
#line 281
          tmp___1 = 0;
        }
#line 281
        from_ptr += 1 + tmp___1;
#line 282
        goto __Cont;
      }
    }
#line 284
    if ((int )*(from_ptr + 0) == 43) {
#line 286
      tmp___6 = to_ptr;
#line 286
      to_ptr ++;
#line 286
      *tmp___6 = (char )' ';
#line 287
      goto __Cont;
    }
#line 289
    if (parse_state == 1) {
#line 289
      if ((int )*(from_ptr + 0) == 61) {
#line 292
        tmp___7 = to_ptr;
#line 292
        to_ptr ++;
#line 292
        *tmp___7 = (char )'\000';
#line 293
        parse_state ++;
#line 294
        goto __Cont;
      }
    }
#line 296
    if ((int )*(from_ptr + 0) == 38) {
#line 298
      tmp___8 = to_ptr;
#line 298
      to_ptr ++;
#line 298
      *tmp___8 = (char )'\000';
#line 299
      field_ptr ++;
#line 300
      if ((unsigned long )field_ptr > (unsigned long )(formp->fields + formp->maxfields)) {
        {
#line 302
        formp->errcond = 1;
#line 303
        sprintf((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"400 Exceeded %d fields.",
                formp->maxfields);
        }
#line 305
        return (1);
      }
#line 307
      parse_state = 0;
#line 308
      goto __Cont;
    }
#line 311
    tmp___9 = to_ptr;
#line 311
    to_ptr ++;
#line 311
    *tmp___9 = *from_ptr;
    __Cont: /* CIL Label */ 
#line 249
    from_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  *to_ptr = (char )'\000';
#line 316
  if (parse_state == 2) {
#line 316
    field_ptr->value = to_ptr;
  }
#line 319
  i = 0;
  {
#line 319
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 319
    if (! ((size_t )i < formp->nfields)) {
#line 319
      goto while_break___0;
    }
    {
#line 320
    cgi_fix_crlf((formp->fields + i)->value);
#line 319
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  if (formp->maxfields - formp->nfields > 4UL) {
#line 325
    (formp->fields + formp->nfields)->name = (char *)"cgierrmsg";
#line 326
    tmp___10 = formp->nfields;
#line 326
    (formp->nfields) ++;
#line 326
    (formp->fields + tmp___10)->value = formp->errmsg;
#line 327
    (formp->fields + formp->nfields)->name = (char *)"cgierrinfo";
#line 328
    tmp___11 = formp->nfields;
#line 328
    (formp->nfields) ++;
#line 328
    (formp->fields + tmp___11)->value = formp->errinfo;
#line 329
    (formp->fields + formp->nfields)->name = (char *)"cgirelease";
#line 330
    tmp___12 = formp->nfields;
#line 330
    (formp->nfields) ++;
#line 330
    (formp->fields + tmp___12)->value = (char *)"1.6";
#line 331
    (formp->fields + formp->nfields)->name = (char *)"cgidate";
#line 332
    tmp___13 = formp->nfields;
#line 332
    (formp->nfields) ++;
#line 332
    (formp->fields + tmp___13)->value = datebuf;
  }
#line 335
  return (0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_print_form(cgi_form *formp , FILE *outstream ) 
{ 
  int i ;

  {
  {
#line 346
  fprintf((FILE */* __restrict  */)outstream, (char const   */* __restrict  */)"source=\t%s\nmaxstorage=\t%d\nmaxfields=\t%d\nnfields=\t%d\n",
          formp->source, formp->maxstorage, formp->maxfields, formp->nfields);
#line 349
  i = 0;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! ((size_t )i < formp->nfields)) {
#line 349
      goto while_break;
    }
    {
#line 350
    printf((char const   */* __restrict  */)"Field %s=\t%s\n", (formp->fields + i)->name,
           (formp->fields + i)->value);
#line 349
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return;
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
char *cgi_value(cgi_form *formp , char *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 361
  i = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! ((size_t )i < formp->nfields)) {
#line 361
      goto while_break;
    }
    {
#line 363
    tmp = strcmp((char const   *)(formp->fields + i)->name, (char const   *)name);
    }
#line 363
    if (! tmp) {
#line 364
      return ((formp->fields + i)->value);
    }
#line 361
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  return ((char *)"");
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
static char retval[2]  ;
#line 370 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
char *cgi_char2entity(int c ) 
{ 


  {
  {
#line 378
  if (c == 38) {
#line 378
    goto case_38;
  }
#line 380
  if (c == 60) {
#line 380
    goto case_60;
  }
#line 382
  if (c == 62) {
#line 382
    goto case_62;
  }
#line 384
  if (c == 34) {
#line 384
    goto case_34;
  }
#line 386
  goto switch_default;
  case_38: /* CIL Label */ 
#line 379
  return ((char *)"&amp;");
  case_60: /* CIL Label */ 
#line 381
  return ((char *)"&lt;");
  case_62: /* CIL Label */ 
#line 383
  return ((char *)"&gt;");
  case_34: /* CIL Label */ 
#line 385
  return ((char *)"&quot;");
  switch_default: /* CIL Label */ 
  {
#line 387
  sprintf((char */* __restrict  */)(retval), (char const   */* __restrict  */)"%c",
          c);
  }
#line 388
  return (retval);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
static char url_safe[8]  = 
#line 396
  {      (char )'/',      (char )':',      (char )'$',      (char )'-', 
        (char )'_',      (char )'@',      (char )'.',      (char )'\000'};
#line 398 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_string2url(char *instring , FILE *outstream ) 
{ 
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! *instring) {
#line 403
      goto while_break;
    }
#line 405
    if ((int )*instring == 32) {
      {
#line 406
      fputc('+', outstream);
      }
    } else {
      {
#line 409
      tmp = __ctype_b_loc();
      }
#line 409
      if ((int const   )*(*tmp + (int )*instring) & 8) {
        {
#line 410
        fputc((int )*instring, outstream);
        }
      } else {
        {
#line 409
        tmp___0 = strchr((char const   *)(url_safe), (int )*instring);
        }
#line 409
        if (tmp___0) {
          {
#line 410
          fputc((int )*instring, outstream);
          }
        } else {
          {
#line 412
          fprintf((FILE */* __restrict  */)outstream, (char const   */* __restrict  */)"%%%02x",
                  (int )*instring);
          }
        }
      }
    }
#line 414
    instring ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_string2html(char *instring , FILE *outstream ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    if (! *instring) {
#line 424
      goto while_break;
    }
    {
#line 425
    tmp = instring;
#line 425
    instring ++;
#line 425
    tmp___0 = cgi_char2entity((int )*tmp);
#line 425
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)outstream);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_stream2html(FILE *instream , FILE *outstream ) 
{ 
  int c ;
  char *tmp ;

  {
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    c = fgetc(instream);
    }
#line 435
    if (! (c != -1)) {
#line 435
      goto while_break;
    }
    {
#line 436
    tmp = cgi_char2entity(c);
#line 436
    fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)outstream);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  return;
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_output_value(cgi_form *formp , char *name , char *formatstr , FILE *outstream ) 
{ 
  int i ;
  int nfound ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 448
  nfound = 0;
#line 450
  i = 0;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! ((size_t )i < formp->nfields)) {
#line 450
      goto while_break;
    }
    {
#line 452
    tmp___2 = strcmp((char const   *)(formp->fields + i)->name, (char const   *)name);
    }
#line 452
    if (! tmp___2) {
#line 454
      if (! noheader) {
        {
#line 456
        strip_nonprint((formp->fields + i)->value);
        }
      }
#line 458
      if (nfound) {
        {
#line 458
        fputc(' ', outstream);
        }
      }
#line 459
      if (formatstr) {
        {
#line 461
        tmp___0 = strcmp((char const   *)formatstr, "%H");
        }
#line 461
        if (tmp___0) {
          {
#line 465
          tmp = strcmp((char const   *)formatstr, "%U");
          }
#line 465
          if (tmp) {
            {
#line 468
            fprintf((FILE */* __restrict  */)outstream, (char const   */* __restrict  */)formatstr,
                    (formp->fields + i)->value);
            }
          } else {
            {
#line 466
            cgi_string2url((formp->fields + i)->value, outstream);
            }
          }
        } else {
          {
#line 462
          cgi_string2html((formp->fields + i)->value, outstream);
          }
        }
      } else {
        {
#line 472
        fputs((char const   */* __restrict  */)(formp->fields + i)->value, (FILE */* __restrict  */)outstream);
        }
      }
      {
#line 473
      tmp___1 = cgi_nonblank((formp->fields + i)->value);
      }
#line 473
      if (tmp___1) {
#line 473
        nfound ++;
      }
    }
#line 450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  return (nfound);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_concat_errno(char *string ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 484
  tmp = __errno_location();
#line 484
  tmp___0 = strerror(*tmp);
#line 484
  tmp___1 = strcat((char */* __restrict  */)string, (char const   */* __restrict  */)" - ");
#line 484
  strcat((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)tmp___0);
  }
#line 491
  return;
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_read_configuration(cgi_form *formp , char *templatedir , int templatedirlen ) 
{ 
  FILE *cfp ;
  char *linebuf ;
  int linebuflen ;
  char *directive ;
  int directivelen ;
  size_t tmp ;
  void *tmp___0 ;
  char *inquotes ;
  char *endquotes ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 503
  directive = (char *)"templatedir=\"";
#line 504
  tmp = strlen((char const   *)directive);
#line 504
  directivelen = (int )tmp;
#line 506
  cfp = fopen((char const   */* __restrict  */)"/usr/local/etc/cgiemail.conf", (char const   */* __restrict  */)"r");
  }
#line 507
  if (! cfp) {
#line 509
    return (0);
  }
  {
#line 512
  linebuflen = (templatedirlen + directivelen) + 2;
#line 513
  tmp___0 = malloc((size_t )(linebuflen + 1));
#line 513
  linebuf = (char *)tmp___0;
  }
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 514
    tmp___3 = fgets((char */* __restrict  */)linebuf, linebuflen - 1, (FILE */* __restrict  */)cfp);
    }
#line 514
    if (! tmp___3) {
#line 514
      goto while_break;
    }
    {
#line 516
    tmp___2 = strncmp((char const   *)linebuf, (char const   *)directive, (size_t )directivelen);
    }
#line 516
    if (! tmp___2) {
      {
#line 518
      inquotes = linebuf + directivelen;
#line 519
      tmp___1 = strchr((char const   *)inquotes, '\"');
#line 519
      endquotes = tmp___1;
      }
#line 520
      if (endquotes) {
        {
#line 522
        strncpy((char */* __restrict  */)templatedir, (char const   */* __restrict  */)inquotes,
                (size_t )(endquotes - inquotes));
#line 523
        *(templatedir + (endquotes - inquotes)) = (char)0;
        }
#line 524
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 529
  formp->errcond = 1;
#line 530
  strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"500 Could not find templatedir in configuration file");
#line 535
  strcpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)"No templatedir=\"...\" line in configuration file.");
  }
#line 537
  return (1);
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_template_fill(cgi_form *formp , char *templatefile ) 
{ 
  FILE *tfp ;
  char varname[255] ;
  char formatstr[255] ;
  char templatedir[255] ;
  int varnamelen ;
  int formatlen ;
  int nfound ;
  int substitutions ;
  int inchar ;
  int parse_state ;
  int cgienv ;
  char *envval ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 549
  varnamelen = 0;
#line 549
  formatlen = 0;
#line 549
  nfound = 0;
#line 549
  substitutions = 0;
#line 550
  parse_state = 0;
#line 552
  varname[0] = (char )'\000';
#line 553
  formatstr[0] = (char )'\000';
#line 554
  templatedir[0] = (char )'\000';
#line 557
  cgienv = 0;
#line 561
  tmp = cgi_read_configuration(formp, templatedir, 254);
  }
#line 561
  if (tmp) {
#line 562
    return (1);
  }
#line 564
  if (! (templatedir)) {
    {
#line 568
    formp->errcond = 1;
#line 569
    strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"403 Template not in valid directory");
#line 573
    strcpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)"Template file could not be accessed.");
    }
#line 575
    return (1);
  } else {
    {
#line 564
    tmp___0 = strlen((char const   *)(templatedir));
#line 564
    tmp___1 = strncmp((char const   *)templatefile, (char const   *)(templatedir),
                      tmp___0);
    }
#line 564
    if (tmp___1) {
      {
#line 568
      formp->errcond = 1;
#line 569
      strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"403 Template not in valid directory");
#line 573
      strcpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)"Template file could not be accessed.");
      }
#line 575
      return (1);
    } else {
      {
#line 564
      tmp___2 = strstr((char const   *)templatefile, "/../");
      }
#line 564
      if (tmp___2) {
        {
#line 568
        formp->errcond = 1;
#line 569
        strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"403 Template not in valid directory");
#line 573
        strcpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)"Template file could not be accessed.");
        }
#line 575
        return (1);
      }
    }
  }
  {
#line 579
  tfp = fopen((char const   */* __restrict  */)templatefile, (char const   */* __restrict  */)"r");
  }
#line 580
  if (! tfp) {
    {
#line 582
    formp->errcond = 1;
#line 583
    strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"500 Could not open template");
#line 584
    cgi_concat_errno(formp->errmsg);
#line 588
    strcpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)"Template file could not be accessed.");
    }
#line 590
    return (1);
  }
#line 594
  if (formp->tmpf) {
    {
#line 594
    rewind(formp->tmpf);
    }
  } else {
    {
#line 595
    formp->tmpf = tmpfile();
    }
  }
#line 596
  if (! formp->tmpf) {
    {
#line 598
    formp->errcond = 1;
#line 599
    strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"500 Could not open temporary file.");
#line 602
    tmp___3 = access("/tmp", 2);
    }
#line 602
    if (tmp___3) {
      {
#line 604
      strcpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)"/tmp");
#line 605
      cgi_concat_errno(formp->errinfo);
      }
    }
#line 608
    return (1);
  }
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 611
    inchar = fgetc(tfp);
    }
#line 611
    if (inchar != -1) {
      {
#line 611
      tmp___4 = __ctype_b_loc();
      }
#line 611
      if (! ((int const   )*(*tmp___4 + inchar) & 8192)) {
#line 611
        goto while_break;
      }
    } else {
#line 611
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  if (inchar == -1) {
    {
#line 617
    formp->errcond = 1;
#line 618
    strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"500 Empty template file");
#line 619
    strncpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)templatefile,
            (size_t )1023);
    }
#line 620
    return (1);
  }
  {
#line 631
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 633
    if (parse_state == 1) {
      {
#line 635
      fputc(inchar, formp->tmpf);
#line 636
      parse_state = 0;
      }
#line 637
      goto __Cont;
    }
#line 639
    if (parse_state == 0) {
#line 642
      if (flag >= 2) {
#line 644
        noheader = 1;
      }
#line 647
      if (inchar == 13) {
        {
#line 649
        fputc('\n', formp->tmpf);
#line 650
        inchar = fgetc(tfp);
#line 651
        flag ++;
        }
#line 652
        if (inchar == 10) {
#line 652
          goto __Cont;
        }
      }
#line 654
      if (inchar != 32) {
#line 654
        if (inchar != 10) {
#line 656
          flag = 0;
        } else {
#line 654
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 660
      if (inchar == 10) {
#line 660
        flag ++;
      }
#line 662
      if (inchar == 92) {
#line 664
        parse_state = 1;
#line 665
        goto __Cont;
      }
#line 667
      if (inchar == 91) {
#line 670
        cgienv = 0;
#line 672
        parse_state = 2;
#line 673
        varnamelen = 0;
#line 674
        formatlen = 0;
#line 675
        goto __Cont;
      }
      {
#line 677
      fputc(inchar, formp->tmpf);
      }
#line 678
      goto __Cont;
    }
#line 680
    if (parse_state == 2) {
#line 682
      if (inchar == 37) {
        {
#line 684
        formatlen = 1;
#line 685
        strcpy((char */* __restrict  */)(formatstr), (char const   */* __restrict  */)"%");
#line 686
        parse_state = 3;
        }
#line 687
        goto __Cont;
      }
#line 691
      if (inchar == 36) {
#line 691
        if (varnamelen == 0) {
#line 693
          cgienv = 1;
#line 694
          goto __Cont;
        }
      }
#line 698
      if (inchar == 93) {
#line 700
        varname[varnamelen] = (char )'\000';
#line 702
        if (cgienv) {
          {
#line 704
          cgienv = 0;
#line 705
          envval = getenv((char const   *)(varname));
          }
#line 706
          if (! envval) {
#line 706
            envval = (char *)"";
          } else {
#line 707
            substitutions ++;
          }
#line 708
          if (formatlen > 0) {
            {
#line 709
            fprintf((FILE */* __restrict  */)formp->tmpf, (char const   */* __restrict  */)(formatstr),
                    envval);
            }
          } else {
            {
#line 710
            fputs((char const   */* __restrict  */)envval, (FILE */* __restrict  */)formp->tmpf);
            }
          }
        } else {
#line 715
          if (formatlen > 0) {
            {
#line 716
            nfound = cgi_output_value(formp, varname, formatstr, formp->tmpf);
            }
          } else {
            {
#line 720
            nfound = cgi_output_value(formp, varname, (char *)((void *)0), formp->tmpf);
            }
          }
#line 724
          if (! nfound) {
            {
#line 724
            tmp___5 = strncmp((char const   *)(varname), "required", (size_t )8);
            }
#line 724
            if (! tmp___5) {
              {
#line 726
              formp->errcond = 1;
#line 727
              strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"400 Required field left blank");
#line 729
              strcpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)(varname));
              }
#line 730
              return (1);
            }
          }
#line 732
          substitutions += nfound;
        }
#line 734
        parse_state = 0;
#line 735
        goto __Cont;
      }
#line 737
      tmp___6 = varnamelen;
#line 737
      varnamelen ++;
#line 737
      varname[tmp___6] = (char )inchar;
#line 738
      if (varnamelen > 255) {
        {
#line 740
        fclose(tfp);
#line 741
        formp->errcond = 1;
#line 742
        strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"403 Variable Name too long");
#line 743
        strncpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)(varname),
                (size_t )varnamelen);
#line 744
        strcpy((char */* __restrict  */)(formp->errinfo + varnamelen), (char const   */* __restrict  */)"...");
        }
#line 745
        return (1);
      }
#line 747
      goto __Cont;
    }
#line 749
    if (parse_state == 3) {
#line 751
      if (inchar == 44) {
#line 753
        formatstr[formatlen] = (char )'\000';
#line 754
        parse_state = 2;
#line 755
        goto __Cont;
      }
#line 757
      tmp___7 = formatlen;
#line 757
      formatlen ++;
#line 757
      formatstr[tmp___7] = (char )inchar;
#line 758
      if (formatlen > 255) {
        {
#line 760
        fclose(tfp);
#line 761
        formp->errcond = 1;
#line 762
        strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"403 Format String too long");
#line 763
        strncpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)(formatstr),
                (size_t )formatlen);
#line 764
        strcpy((char */* __restrict  */)(formp->errinfo + formatlen), (char const   */* __restrict  */)"...");
        }
#line 765
        return (1);
      }
#line 767
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
    {
#line 631
    inchar = fgetc(tfp);
    }
#line 631
    if (! (inchar != -1)) {
#line 631
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 771
  fclose(tfp);
  }
#line 775
  if (! substitutions) {
    {
#line 777
    formp->errcond = 1;
#line 778
    strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"403 No variable substitutions in template");
#line 782
    strcpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)"Template file doesn\'t look like a template.");
    }
#line 784
    return (1);
  }
#line 787
  return (0);
}
}
#line 798 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_pclose_fix(void) 
{ 
  sigset_t mysigmask ;

  {
  {
#line 805
  sigemptyset(& mysigmask);
#line 806
  sigaddset(& mysigmask, 17);
#line 807
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& mysigmask), (sigset_t */* __restrict  */)0);
#line 810
  sigemptyset(& mysigmask);
#line 811
  sigaddset(& mysigmask, 13);
#line 812
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& mysigmask), (sigset_t */* __restrict  */)0);
  }
#line 817
  return;
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_mail_template(cgi_form *formp , char *templatefile ) 
{ 
  FILE *mypipe ;
  FILE *errorfp ;
  int retval___3 ;
  char buf[8192] ;
  char command[8192] ;
  int nbytes ;
  char *envvar ;
  char errorfile[20] ;
  int old_stdout ;
  int old_stderr ;
  int errorfd ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  union __anonunion_53 __constr_expr_0 ;
  int tmp___6 ;

  {
  {
#line 845
  retval___3 = cgi_template_fill(formp, templatefile);
  }
#line 846
  if (retval___3) {
#line 846
    return (retval___3);
  }
  {
#line 849
  tmpnam(errorfile);
#line 850
  errorfd = open((char const   *)(errorfile), 193, 420);
  }
#line 851
  if (errorfd != -1) {
    {
#line 853
    old_stdout = dup(1);
#line 854
    dup2(errorfd, 1);
#line 855
    old_stderr = dup(2);
#line 856
    dup2(errorfd, 2);
    }
  }
  {
#line 860
  cgi_pclose_fix();
#line 861
  tmp = strcpy((char */* __restrict  */)(command), (char const   */* __restrict  */)"/usr/sbin/sendmail");
#line 861
  strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)" -oi -t");
#line 862
  tmp___0 = cgi_value(formp, (char *)"cgiemail-mailopt");
#line 862
  tmp___1 = strstr((char const   *)tmp___0, "sync");
  }
#line 862
  if (tmp___1) {
    {
#line 863
    strcat((char */* __restrict  */)(command), (char const   */* __restrict  */)" -odi");
    }
  }
  {
#line 868
  mypipe = popen((char const   *)(command), "w");
  }
#line 871
  if (errorfd != -1) {
    {
#line 873
    dup2(old_stdout, 1);
#line 874
    close(old_stdout);
#line 875
    dup2(old_stderr, 2);
#line 876
    close(old_stderr);
#line 877
    close(errorfd);
    }
  }
#line 881
  if (! mypipe) {
    {
#line 883
    formp->errcond = 1;
#line 884
    strcpy((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"500 Could not open sendmail pipe");
#line 885
    cgi_concat_errno(formp->errmsg);
#line 886
    strncpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)(command),
            (size_t )1023);
    }
#line 887
    return (1);
  }
  {
#line 893
  envvar = getenv("REMOTE_HOST");
  }
#line 894
  if (! envvar) {
    {
#line 894
    envvar = getenv("REMOTE_ADDR");
    }
  } else
#line 894
  if (! *envvar) {
    {
#line 894
    envvar = getenv("REMOTE_ADDR");
    }
  }
#line 895
  if (envvar) {
#line 895
    if (*envvar) {
      {
#line 897
      fputs((char const   */* __restrict  */)"Received: from ", (FILE */* __restrict  */)mypipe);
#line 898
      fputs((char const   */* __restrict  */)envvar, (FILE */* __restrict  */)mypipe);
#line 899
      envvar = getenv("SERVER_NAME");
      }
#line 900
      if (envvar) {
#line 900
        if (*envvar) {
          {
#line 902
          fputs((char const   */* __restrict  */)" by ", (FILE */* __restrict  */)mypipe);
#line 903
          fputs((char const   */* __restrict  */)envvar, (FILE */* __restrict  */)mypipe);
          }
        }
      }
      {
#line 905
      fputs((char const   */* __restrict  */)" with HTTP;\n\t", (FILE */* __restrict  */)mypipe);
#line 906
      fputs((char const   */* __restrict  */)(datebuf), (FILE */* __restrict  */)mypipe);
#line 907
      fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)mypipe);
      }
    }
  }
  {
#line 912
  fputs((char const   */* __restrict  */)"X-Mailer: cgiemail ", (FILE */* __restrict  */)mypipe);
#line 913
  fputs((char const   */* __restrict  */)"1.6", (FILE */* __restrict  */)mypipe);
#line 914
  envvar = getenv("HTTP_REFERER");
  }
#line 914
  if ((unsigned long )((void *)0) != (unsigned long )envvar) {
    {
#line 916
    fputs((char const   */* __restrict  */)"\n\t(form=\"", (FILE */* __restrict  */)mypipe);
#line 917
    tmp___2 = getenv("HTTP_REFERER");
#line 917
    fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)mypipe);
#line 918
    fputs((char const   */* __restrict  */)"\")", (FILE */* __restrict  */)mypipe);
    }
  }
  {
#line 921
  fputs((char const   */* __restrict  */)"\n\t(action=\"", (FILE */* __restrict  */)mypipe);
#line 922
  tmp___3 = getenv("SCRIPT_NAME");
#line 922
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)mypipe);
#line 923
  envvar = getenv("PATH_INFO");
  }
#line 923
  if ((unsigned long )((void *)0) != (unsigned long )envvar) {
    {
#line 924
    tmp___4 = getenv("PATH_INFO");
#line 924
    fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)mypipe);
    }
  }
  {
#line 925
  fputs((char const   */* __restrict  */)"\")\n", (FILE */* __restrict  */)mypipe);
#line 929
  rewind(formp->tmpf);
  }
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 931
    tmp___5 = fread((void */* __restrict  */)(buf), sizeof(char ), (size_t )8192,
                    (FILE */* __restrict  */)formp->tmpf);
#line 931
    nbytes = (int )tmp___5;
    }
#line 931
    if (nbytes > 0) {
      {
#line 932
      fwrite((void const   */* __restrict  */)(buf), sizeof(char ), (size_t )nbytes,
             (FILE */* __restrict  */)mypipe);
      }
    }
#line 930
    if (! (nbytes == 8192)) {
#line 930
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 936
  retval___3 = pclose(mypipe);
#line 943
  __constr_expr_0.__in = retval___3;
#line 943
  retval___3 = (__constr_expr_0.__i & 65280) >> 8;
  }
#line 945
  if (retval___3) {
    {
#line 953
    errorfp = fopen((char const   */* __restrict  */)(errorfile), (char const   */* __restrict  */)"r");
    }
#line 954
    if (! errorfp) {
      {
#line 956
      formp->errcond = 1;
#line 957
      sprintf((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"500 sendmail exit %d - check httpd error logs",
              retval___3);
#line 959
      strcpy((char */* __restrict  */)(formp->errinfo), (char const   */* __restrict  */)(command));
      }
    } else {
      {
#line 964
      fread((void */* __restrict  */)(formp->errinfo), sizeof(char ), (size_t )1023,
            (FILE */* __restrict  */)errorfp);
#line 965
      tmp___6 = cgi_nonblank(formp->errinfo);
      }
#line 965
      if (tmp___6) {
        {
#line 967
        formp->errcond = 1;
#line 968
        sprintf((char */* __restrict  */)(formp->errmsg), (char const   */* __restrict  */)"500 sendmail exit %d with error message",
                retval___3);
        }
      }
    }
  }
  {
#line 974
  unlink((char const   *)(errorfile));
  }
#line 975
  return (formp->errcond);
}
}
#line 978 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_output_failure(cgi_form *formp , char *msg ) 
{ 
  char *failure ;
  char buf[8192] ;
  int nbytes ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 986
  failure = cgi_value(formp, (char *)"failure");
  }
#line 987
  if (failure) {
#line 987
    if (*failure) {
      {
#line 989
      tmp___3 = strpbrk((char const   *)failure, ":/");
      }
#line 989
      if (tmp___3) {
        {
#line 991
        cgi_redirect(failure);
        }
#line 992
        return;
      } else {
        {
#line 999
        tmp___1 = cgi_parallel_fname(failure, buf, 8192);
        }
#line 999
        if (0 == tmp___1) {
          {
#line 999
          tmp___2 = cgi_template_fill(formp, buf);
          }
#line 999
          if (0 == tmp___2) {
            {
#line 1002
            rewind(formp->tmpf);
#line 1003
            puts("Content-Type: text/html\r\n\r");
            }
            {
#line 1004
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 1006
              tmp = fread((void */* __restrict  */)(buf), sizeof(char ), (size_t )8192,
                          (FILE */* __restrict  */)formp->tmpf);
#line 1006
              nbytes = (int )tmp;
              }
#line 1007
              if (nbytes) {
                {
#line 1009
                tmp___0 = fwrite((void const   */* __restrict  */)(buf), sizeof(char ),
                                 (size_t )nbytes, (FILE */* __restrict  */)stdout);
                }
#line 1009
                if (! tmp___0) {
#line 1010
                  goto while_break;
                }
              }
#line 1004
              if (! (nbytes == 8192)) {
#line 1004
                goto while_break;
              }
            }
            while_break: /* CIL Label */ ;
            }
#line 1014
            return;
          }
        }
      }
    }
  }
  {
#line 1020
  puts("Content-Type: text/html\r");
#line 1021
  printf((char const   */* __restrict  */)"Status: %s\r\n\r\n", formp->errmsg);
#line 1022
  puts("<HEAD><TITLE>Error</TITLE></HEAD>");
#line 1023
  printf((char const   */* __restrict  */)"<BODY><H1>Error</H1>%s<P>", msg);
#line 1024
  puts("<BLOCKQUOTE><STRONG><SAMP>");
#line 1025
  puts((char const   *)(formp->errmsg));
#line 1026
  puts("</SAMP></STRONG><P>");
  }
#line 1027
  if (formp->errinfo[0]) {
    {
#line 1029
    puts("<PRE>");
#line 1030
    puts((char const   *)(formp->errinfo));
#line 1031
    puts("</PRE>");
    }
  }
  {
#line 1033
  puts("</BLOCKQUOTE>");
#line 1034
  cgi_output_value(formp, (char *)"addendum", (char *)((void *)0), stdout);
#line 1035
  puts("<P><EM>cgiemail ");
#line 1036
  puts("1.6");
#line 1037
  puts("</EM></BODY>");
  }
#line 1038
  return;
}
}
#line 1048 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_redirect(char *url ) 
{ 


  {
  {
#line 1052
  printf((char const   */* __restrict  */)"Location: %s\r\n\r\n", url);
  }
#line 1053
  return;
}
}
#line 1056 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
void cgi_output_success(cgi_form *formp , char *msg ) 
{ 
  char *success ;
  char buf[8192] ;
  int nbytes ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1064
  success = cgi_value(formp, (char *)"success");
  }
#line 1065
  if (success) {
#line 1065
    if (*success) {
      {
#line 1067
      tmp___3 = strpbrk((char const   *)success, ":/");
      }
#line 1067
      if (tmp___3) {
        {
#line 1069
        cgi_redirect(success);
        }
#line 1070
        return;
      } else {
        {
#line 1077
        tmp___1 = cgi_parallel_fname(success, buf, 8192);
        }
#line 1077
        if (0 == tmp___1) {
          {
#line 1077
          tmp___2 = cgi_template_fill(formp, buf);
          }
#line 1077
          if (0 == tmp___2) {
            {
#line 1080
            rewind(formp->tmpf);
#line 1081
            puts("Content-Type: text/html\r\n\r");
            }
            {
#line 1082
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 1084
              tmp = fread((void */* __restrict  */)(buf), sizeof(char ), (size_t )8192,
                          (FILE */* __restrict  */)formp->tmpf);
#line 1084
              nbytes = (int )tmp;
              }
#line 1085
              if (nbytes) {
                {
#line 1087
                tmp___0 = fwrite((void const   */* __restrict  */)(buf), sizeof(char ),
                                 (size_t )nbytes, (FILE */* __restrict  */)stdout);
                }
#line 1087
                if (! tmp___0) {
#line 1088
                  goto while_break;
                }
              }
#line 1082
              if (! (nbytes == 8192)) {
#line 1082
                goto while_break;
              }
            }
            while_break: /* CIL Label */ ;
            }
#line 1092
            return;
          } else {
            {
#line 1096
            cgi_output_failure(formp, msg);
            }
#line 1096
            return;
          }
        } else {
          {
#line 1096
          cgi_output_failure(formp, msg);
          }
#line 1096
          return;
        }
      }
    }
  }
  {
#line 1102
  puts("Content-Type: text/html\r\n\r");
#line 1103
  puts("<HEAD><TITLE>Success</TITLE></HEAD>");
#line 1104
  printf((char const   */* __restrict  */)"<BODY>%s<P><HR>", msg);
#line 1105
  puts("<PRE>");
#line 1106
  rewind(formp->tmpf);
#line 1107
  cgi_stream2html(formp->tmpf, stdout);
#line 1108
  tmp___4 = cgi_value(formp, (char *)"debug-source");
  }
#line 1108
  if (*tmp___4) {
    {
#line 1110
    puts("<HR>");
#line 1111
    puts((char const   *)formp->source);
#line 1112
    puts("<HR>");
    }
  }
  {
#line 1114
  puts("</PRE><P>");
#line 1115
  cgi_output_value(formp, (char *)"addendum", (char *)((void *)0), stdout);
#line 1116
  puts("<P><EM>cgiemail ");
#line 1117
  puts("1.6");
#line 1118
  puts("</EM></BODY>");
  }
#line 1120
  return;
}
}
#line 1123 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_standard_email(void) 
{ 
  cgi_form form ;
  char *template_filename ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1129
  template_filename = getenv("PATH_TRANSLATED");
  }
#line 1130
  if (! template_filename) {
    {
#line 1132
    cgi_redirect((char *)"http://web.mit.edu/wwwdev/cgiemail/nopath.html");
    }
#line 1133
    return (1);
  } else
#line 1130
  if (! *template_filename) {
    {
#line 1132
    cgi_redirect((char *)"http://web.mit.edu/wwwdev/cgiemail/nopath.html");
    }
#line 1133
    return (1);
  }
  {
#line 1136
  tmp = cgi_alloc_form(& form);
  }
#line 1136
  if (tmp) {
    {
#line 1140
    cgi_output_failure(& form, (char *)"No email was sent due to an error.");
#line 1141
    cgi_free_form(& form);
    }
#line 1142
    return (1);
  } else {
    {
#line 1136
    tmp___0 = cgi_parse_form(& form);
    }
#line 1136
    if (tmp___0) {
      {
#line 1140
      cgi_output_failure(& form, (char *)"No email was sent due to an error.");
#line 1141
      cgi_free_form(& form);
      }
#line 1142
      return (1);
    } else {
      {
#line 1136
      tmp___1 = cgi_mail_template(& form, template_filename);
      }
#line 1136
      if (tmp___1) {
        {
#line 1140
        cgi_output_failure(& form, (char *)"No email was sent due to an error.");
#line 1141
        cgi_free_form(& form);
        }
#line 1142
        return (1);
      }
    }
  }
  {
#line 1145
  cgi_output_success(& form, (char *)"The following email message was sent.");
#line 1146
  cgi_free_form(& form);
  }
#line 1147
  return (0);
}
}
#line 1150 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_standard_echo(void) 
{ 
  cgi_form form ;
  char *template_filename ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1156
  template_filename = getenv("PATH_TRANSLATED");
  }
#line 1157
  if (! template_filename) {
    {
#line 1159
    cgi_redirect((char *)"http://web.mit.edu/wwwdev/cgiemail/nopath.html");
    }
#line 1160
    return (1);
  } else
#line 1157
  if (! *template_filename) {
    {
#line 1159
    cgi_redirect((char *)"http://web.mit.edu/wwwdev/cgiemail/nopath.html");
    }
#line 1160
    return (1);
  }
  {
#line 1163
  tmp = cgi_alloc_form(& form);
  }
#line 1163
  if (tmp) {
    {
#line 1167
    cgi_output_failure(& form, (char *)"Form was not processed due to an error.");
#line 1168
    cgi_free_form(& form);
    }
#line 1169
    return (1);
  } else {
    {
#line 1163
    tmp___0 = cgi_parse_form(& form);
    }
#line 1163
    if (tmp___0) {
      {
#line 1167
      cgi_output_failure(& form, (char *)"Form was not processed due to an error.");
#line 1168
      cgi_free_form(& form);
      }
#line 1169
      return (1);
    } else {
      {
#line 1163
      tmp___1 = cgi_template_fill(& form, template_filename);
      }
#line 1163
      if (tmp___1) {
        {
#line 1167
        cgi_output_failure(& form, (char *)"Form was not processed due to an error.");
#line 1168
        cgi_free_form(& form);
        }
#line 1169
        return (1);
      }
    }
  }
  {
#line 1172
  cgi_output_success(& form, (char *)"Processed form looks like this:");
#line 1173
  cgi_free_form(& form);
  }
#line 1174
  return (0);
}
}
#line 1177 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
int cgi_standard_file(void) 
{ 
  cgi_form form ;
  char *template_filename ;
  char incoming_filename[8192] ;
  int retval___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  FILE *fp ;
  char buf[8192] ;
  int nbytes ;
  struct stat st ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1184
  template_filename = getenv("PATH_TRANSLATED");
  }
#line 1185
  if (! template_filename) {
    {
#line 1187
    cgi_redirect((char *)"http://web.mit.edu/wwwdev/cgiemail/nopath.html");
    }
#line 1188
    return (1);
  } else
#line 1185
  if (! *template_filename) {
    {
#line 1187
    cgi_redirect((char *)"http://web.mit.edu/wwwdev/cgiemail/nopath.html");
    }
#line 1188
    return (1);
  }
  {
#line 1191
  tmp = cgi_alloc_form(& form);
  }
#line 1191
  if (tmp) {
    {
#line 1195
    cgi_output_failure(& form, (char *)"Form was not processed due to an error.");
#line 1196
    cgi_free_form(& form);
    }
#line 1197
    return (1);
  } else {
    {
#line 1191
    tmp___0 = cgi_parse_form(& form);
    }
#line 1191
    if (tmp___0) {
      {
#line 1195
      cgi_output_failure(& form, (char *)"Form was not processed due to an error.");
#line 1196
      cgi_free_form(& form);
      }
#line 1197
      return (1);
    } else {
      {
#line 1191
      tmp___1 = cgi_template_fill(& form, template_filename);
      }
#line 1191
      if (tmp___1) {
        {
#line 1195
        cgi_output_failure(& form, (char *)"Form was not processed due to an error.");
#line 1196
        cgi_free_form(& form);
        }
#line 1197
        return (1);
      }
    }
  }
  {
#line 1200
  tmp___6 = cgi_parallel_fname((char *)"incoming.txt", incoming_filename, 8192);
  }
#line 1200
  if (0 == tmp___6) {
    {
#line 1202
    tmp___5 = access((char const   *)(incoming_filename), 2);
    }
#line 1202
    if (tmp___5) {
      {
#line 1265
      form.errcond = 1;
#line 1266
      strcpy((char */* __restrict  */)(form.errmsg), (char const   */* __restrict  */)"500 No write access to file");
#line 1267
      cgi_concat_errno(form.errmsg);
#line 1268
      strncpy((char */* __restrict  */)(form.errinfo), (char const   */* __restrict  */)(incoming_filename),
              (size_t )1023);
      }
    } else {
      {
#line 1210
      tmp___2 = lstat((char const   */* __restrict  */)(incoming_filename), (struct stat */* __restrict  */)(& st));
      }
#line 1210
      if (tmp___2) {
        {
#line 1212
        form.errcond = 1;
#line 1213
        strcpy((char */* __restrict  */)(form.errmsg), (char const   */* __restrict  */)"500 Could not stat file");
#line 1214
        cgi_concat_errno(form.errmsg);
#line 1215
        strncpy((char */* __restrict  */)(form.errinfo), (char const   */* __restrict  */)(incoming_filename),
                (size_t )1023);
        }
#line 1216
        goto failure;
      } else
#line 1220
      if ((st.st_mode & 61440U) == 40960U) {
        {
#line 1222
        form.errcond = 1;
#line 1223
        strcpy((char */* __restrict  */)(form.errmsg), (char const   */* __restrict  */)"500 File is symbolic link");
#line 1224
        strncpy((char */* __restrict  */)(form.errinfo), (char const   */* __restrict  */)(incoming_filename),
                (size_t )1023);
        }
#line 1225
        goto failure;
      } else
#line 1228
      if (st.st_nlink > 1UL) {
        {
#line 1230
        form.errcond = 1;
#line 1231
        strcpy((char */* __restrict  */)(form.errmsg), (char const   */* __restrict  */)"500 File is hard link");
#line 1232
        strncpy((char */* __restrict  */)(form.errinfo), (char const   */* __restrict  */)(incoming_filename),
                (size_t )1023);
        }
#line 1233
        goto failure;
      }
      {
#line 1237
      rewind(form.tmpf);
#line 1238
      fp = fopen((char const   */* __restrict  */)(incoming_filename), (char const   */* __restrict  */)"a");
      }
#line 1239
      if (fp) {
        {
#line 1241
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1243
          tmp___3 = fread((void */* __restrict  */)(buf), sizeof(char ), (size_t )8192,
                          (FILE */* __restrict  */)form.tmpf);
#line 1243
          nbytes = (int )tmp___3;
          }
#line 1243
          if (nbytes > 0) {
            {
#line 1245
            fwrite((void const   */* __restrict  */)(buf), sizeof(char ), (size_t )nbytes,
                   (FILE */* __restrict  */)fp);
            }
          }
#line 1241
          if (! (nbytes == 8192)) {
#line 1241
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1247
        tmp___4 = fclose(fp);
        }
#line 1247
        if (tmp___4) {
          {
#line 1249
          form.errcond = 1;
#line 1250
          strcpy((char */* __restrict  */)(form.errmsg), (char const   */* __restrict  */)"500 Write to file failed");
#line 1251
          cgi_concat_errno(form.errmsg);
#line 1252
          strncpy((char */* __restrict  */)(form.errinfo), (char const   */* __restrict  */)(incoming_filename),
                  (size_t )1023);
          }
        }
      } else {
        {
#line 1257
        form.errcond = 1;
#line 1258
        strcpy((char */* __restrict  */)(form.errmsg), (char const   */* __restrict  */)"500 Could not append file");
#line 1259
        cgi_concat_errno(form.errmsg);
#line 1260
        strncpy((char */* __restrict  */)(form.errinfo), (char const   */* __restrict  */)(incoming_filename),
                (size_t )1023);
        }
      }
    }
  }
  failure: 
#line 1275
  if (form.errcond) {
    {
#line 1276
    cgi_output_failure(& form, (char *)"Form was not processed due to an error.");
    }
  } else {
    {
#line 1278
    cgi_output_success(& form, (char *)"The following information was written:");
    }
  }
  {
#line 1279
  retval___3 = form.errcond;
#line 1280
  cgi_free_form(& form);
  }
#line 1281
  return (retval___3);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgiecho.c"
int main(void) 
{ 
  int tmp ;

  {
  {
#line 13
  tmp = cgi_standard_echo();
#line 13
  exit(tmp);
  }
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
static char retval___0[2]  ;
#line 396 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
static char url_safe___0[8]  = 
#line 396
  {      (char )'/',      (char )':',      (char )'$',      (char )'-', 
        (char )'_',      (char )'@',      (char )'.',      (char )'\000'};
#line 374 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
static char retval___1[2]  ;
#line 396 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
static char url_safe___1[8]  = 
#line 396
  {      (char )'/',      (char )':',      (char )'$',      (char )'-', 
        (char )'_',      (char )'@',      (char )'.',      (char )'\000'};
#line 374 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
static char retval___2[2]  ;
#line 396 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilib.c"
static char url_safe___2[8]  = 
#line 396
  {      (char )'/',      (char )':',      (char )'$',      (char )'-', 
        (char )'_',      (char )'@',      (char )'.',      (char )'\000'};
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/csoget.c"
int csoget(char *query , char *host , char *origbuf , int origbufsize ) 
{ 
  struct hostent *hp ;
  struct sockaddr_in sname ;
  u_short portnum ;
  int sock ;
  int red ;
  int total ;
  int bufsize ;
  char *remote_addr ;
  char *buf ;
  int tmp ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 32
  red = 1;
#line 32
  total = 0;
#line 37
  hp = gethostbyname((char const   *)host);
  }
#line 38
  if (! hp) {
#line 38
    return (-1);
  }
  {
#line 41
  memset((void *)(& sname), 0, sizeof(sname));
#line 42
  sname.sin_family = (sa_family_t )2;
#line 43
  memcpy((void */* __restrict  */)(& sname.sin_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
         (size_t )hp->h_length);
#line 46
  portnum = (u_short )108;
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! ((int )portnum >= 105)) {
#line 46
      goto while_break;
    }
    {
#line 48
    sname.sin_port = htons(portnum);
#line 51
    sock = socket(2, 1, 0);
#line 54
    tmp = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sname)),
                  (socklen_t )sizeof(sname));
    }
#line 54
    if (tmp < 0) {
#line 55
      goto __Cont;
    }
    {
#line 58
    remote_addr = getenv("REMOTE_ADDR");
    }
#line 59
    if (remote_addr) {
      {
#line 61
      tmp___0 = write(sock, (void const   *)"id NET ", (size_t )7);
      }
#line 61
      if (tmp___0 < 0L) {
#line 61
        goto __Cont;
      }
      {
#line 62
      tmp___1 = strlen((char const   *)remote_addr);
#line 62
      tmp___2 = write(sock, (void const   *)remote_addr, tmp___1);
      }
#line 62
      if (tmp___2 < 0L) {
#line 62
        goto __Cont;
      }
      {
#line 63
      tmp___3 = write(sock, (void const   *)"\n", (size_t )1);
      }
#line 63
      if (tmp___3 < 0L) {
#line 63
        goto __Cont;
      }
    }
    {
#line 67
    tmp___4 = write(sock, (void const   *)"help web motd\n", (size_t )14);
    }
#line 67
    if (tmp___4 < 0L) {
#line 67
      goto __Cont;
    }
    {
#line 70
    tmp___5 = write(sock, (void const   *)"query ", (size_t )6);
    }
#line 70
    if (tmp___5 < 0L) {
#line 70
      goto __Cont;
    }
    {
#line 71
    tmp___6 = strlen((char const   *)query);
#line 71
    tmp___7 = write(sock, (void const   *)query, tmp___6);
    }
#line 71
    if (tmp___7 < 0L) {
#line 71
      goto __Cont;
    }
    {
#line 72
    tmp___8 = write(sock, (void const   *)"\nquit\n", (size_t )6);
    }
#line 72
    if (tmp___8 < 0L) {
#line 72
      goto __Cont;
    }
#line 75
    buf = origbuf;
#line 76
    bufsize = origbufsize;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 80
      tmp___9 = read(sock, (void *)buf, (size_t )bufsize);
#line 80
      red = (int )tmp___9;
      }
#line 81
      if (red > 0) {
#line 83
        buf += red;
#line 84
        bufsize -= red;
#line 85
        total += red;
      }
#line 77
      if (bufsize > 1) {
#line 77
        if (! (red > 0)) {
#line 77
          goto while_break___0;
        }
      } else {
#line 77
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 90
    *(buf + 0) = (char )'\000';
#line 91
    close(sock);
    }
#line 96
    if (red == 0) {
      {
#line 96
      tmp___10 = strstr((char const   *)origbuf, "Query refused");
      }
#line 96
      if (! tmp___10) {
#line 96
        return (total);
      }
    }
    __Cont: /* CIL Label */ 
#line 46
    portnum = (u_short )((int )portnum - 3);
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (-1);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/csoget.c"
int finger(char *query , char *host , char *buf , int bufsize ) 
{ 
  char *textline1 ;
  char *textline2 ;
  char *colon1 ;
  char *colon2 ;
  int old_seq ;
  int new_seq ;
  int repeat_line ;
  int tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 109
  old_seq = 0;
#line 109
  new_seq = 0;
#line 109
  repeat_line = 0;
#line 112
  tmp = csoget(query, host, buf, bufsize);
  }
#line 112
  if (tmp == -1) {
#line 112
    return (-1);
  }
  {
#line 115
  tmp___1 = __ctype_b_loc();
  }
#line 115
  if (! ((int const   )*(*tmp___1 + (int )*(buf + 0)) & 2048)) {
#line 115
    if ((int )*(buf + 0) != 45) {
      {
#line 115
      tmp___0 = strlen((char const   *)buf);
      }
#line 115
      return ((int )tmp___0);
    }
  }
#line 118
  textline1 = buf;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((unsigned long )textline1 > (unsigned long )((char *)1))) {
#line 118
      goto while_break;
    }
    {
#line 122
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 124
      repeat_line = 0;
#line 126
      colon1 = strpbrk((char const   *)textline1, ":\n");
      }
#line 127
      if (! colon1) {
#line 127
        goto __Cont;
      } else
#line 127
      if ((int )*colon1 == 10) {
#line 127
        goto __Cont;
      }
      {
#line 128
      tmp___5 = strncmp((char const   *)(colon1 - 3), "200", (size_t )3);
      }
#line 128
      if (tmp___5) {
        {
#line 164
        strcpy((char */* __restrict  */)textline1, (char const   */* __restrict  */)(colon1 + 1));
        }
      } else {
        {
#line 130
        colon2 = strpbrk((char const   *)(colon1 + 1), ":\n");
        }
#line 131
        if (! colon2) {
#line 131
          goto _L;
        } else
#line 131
        if ((int )*colon2 == 10) {
#line 131
          goto _L;
        } else {
          {
#line 131
          tmp___4 = strncmp((char const   *)colon2, ":motd:", (size_t )6);
          }
#line 131
          if (tmp___4) {
            {
#line 150
            new_seq = atoi((char const   *)(colon1 + 1));
            }
#line 151
            if (old_seq != new_seq) {
#line 153
              old_seq = new_seq;
#line 154
              tmp___3 = textline1;
#line 154
              textline1 ++;
#line 154
              *tmp___3 = (char )'\n';
            }
            {
#line 157
            strcpy((char */* __restrict  */)textline1, (char const   */* __restrict  */)(colon2 + 1));
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 134
            textline2 = strchr((char const   *)(colon1 + 1), '\n');
            }
#line 135
            if (textline2) {
              {
#line 138
              strcpy((char */* __restrict  */)textline1, (char const   */* __restrict  */)(textline2 + 1));
#line 139
              repeat_line = 1;
              }
            } else {
#line 143
              *textline1 = (char )'\000';
#line 144
              goto while_break___0;
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 122
      if (repeat_line) {
#line 122
        if (! *textline1) {
#line 122
          goto while_break___0;
        }
      } else {
#line 122
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 118
    tmp___2 = strchr((char const   *)textline1, '\n');
#line 118
    textline1 = tmp___2 + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  tmp___6 = strlen((char const   *)buf);
  }
#line 168
  return ((int )tmp___6);
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgi-ptypes.h"
char *cgi_next_line_in_string(char *string , char *linebuf , int linebuflen ) ;
#line 35
int cgi_cso_field(char *linebuf , char *fieldname , char *valuebuf , int buflen ) ;
#line 36
void cgi_cso_header(cgi_form *formp , char *query ) ;
#line 37
void cgi_cso_footer(void) ;
#line 38
void cgi_url_print(char *linebuf ) ;
#line 39
int cgi_standard_cso(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilibcso.c"
char *cgi_next_line_in_string(char *string , char *linebuf , int linebuflen ) 
{ 
  char *ptr ;
  int linelen ;

  {
  {
#line 26
  ptr = strchr((char const   *)string, '\n');
  }
#line 28
  if (ptr) {
#line 32
    linelen = (int )(ptr - string);
#line 33
    if (linelen >= linebuflen) {
#line 33
      linelen = linebuflen - 1;
    }
    {
#line 34
    strncpy((char */* __restrict  */)linebuf, (char const   */* __restrict  */)string,
            (size_t )linelen);
#line 35
    *(linebuf + linelen) = (char )'\000';
    }
#line 36
    return (ptr + 1);
  }
  {
#line 38
  strncpy((char */* __restrict  */)linebuf, (char const   */* __restrict  */)string,
          (size_t )linebuflen);
  }
#line 39
  return ((char *)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilibcso.c"
int cgi_cso_field(char *linebuf , char *fieldname , char *valuebuf , int buflen ) 
{ 
  char *ptr ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 51
  ptr = strchr((char const   *)linebuf, ':');
  }
#line 52
  if (! ptr) {
#line 52
    return (0);
  }
  {
#line 55
  tmp = strlen((char const   *)fieldname);
#line 55
  tmp___0 = strlen((char const   *)fieldname);
#line 55
  tmp___1 = strncmp((char const   *)fieldname, (char const   *)(ptr - tmp___0), tmp);
  }
#line 55
  if (tmp___1) {
#line 56
    return (0);
  }
  {
#line 59
  strncpy((char */* __restrict  */)valuebuf, (char const   */* __restrict  */)(ptr + 2),
          (size_t )buflen);
  }
#line 60
  return (1);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilibcso.c"
void cgi_cso_header(cgi_form *formp , char *query ) 
{ 
  char buf[8192] ;
  int nbytes ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 74
  puts("Content-Type: text/html\n");
#line 78
  tmp___0 = cgi_template_fill(formp, (char *)"/afs/net.mit.edu/admin/www/root/csoheader");
  }
#line 78
  if (! tmp___0) {
    {
#line 80
    rewind(formp->tmpf);
    }
    {
#line 81
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 82
      tmp = fread((void */* __restrict  */)(buf), sizeof(char ), (size_t )8192, (FILE */* __restrict  */)formp->tmpf);
#line 82
      nbytes = (int )tmp;
      }
#line 82
      if (nbytes > 0) {
        {
#line 83
        fwrite((void const   */* __restrict  */)(buf), sizeof(char ), (size_t )nbytes,
               (FILE */* __restrict  */)stdout);
        }
      }
#line 81
      if (! (nbytes == 8192)) {
#line 81
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 85
    return;
  }
  {
#line 88
  fputs((char const   */* __restrict  */)"<HEAD><TITLE>Results of directory query: \"",
        (FILE */* __restrict  */)stdout);
#line 89
  fputs((char const   */* __restrict  */)query, (FILE */* __restrict  */)stdout);
#line 90
  puts("\"</TITLE></HEAD>");
#line 91
  fputs((char const   */* __restrict  */)"<BODY><H1>Results of directory query: \"",
        (FILE */* __restrict  */)stdout);
#line 92
  fputs((char const   */* __restrict  */)query, (FILE */* __restrict  */)stdout);
#line 93
  puts("\"</H1>");
  }
#line 94
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilibcso.c"
void cgi_cso_footer(void) 
{ 
  FILE *fp ;
  char buf[8192] ;
  int nbytes ;
  size_t tmp ;

  {
  {
#line 107
  fp = fopen((char const   */* __restrict  */)"/afs/net.mit.edu/admin/www/root/csofooter",
             (char const   */* __restrict  */)"r");
  }
#line 107
  if ((unsigned long )((FILE *)0) != (unsigned long )fp) {
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 110
      tmp = fread((void */* __restrict  */)(buf), sizeof(char ), (size_t )8192, (FILE */* __restrict  */)fp);
#line 110
      nbytes = (int )tmp;
      }
#line 110
      if (nbytes > 0) {
        {
#line 111
        fwrite((void const   */* __restrict  */)(buf), sizeof(char ), (size_t )nbytes,
               (FILE */* __restrict  */)stdout);
        }
      }
#line 109
      if (! (nbytes == 8192)) {
#line 109
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 113
    fclose(fp);
    }
#line 114
    return;
  }
  {
#line 117
  puts("</BODY>");
  }
#line 118
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilibcso.c"
void cgi_url_print(char *linebuf ) 
{ 
  char *ptr1 ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 126
  tmp___0 = strncmp((char const   *)linebuf, "       url:", (size_t )11);
  }
#line 126
  if (tmp___0) {
    {
#line 126
    tmp___1 = strstr((char const   *)linebuf, "://");
    }
#line 126
    if (tmp___1) {
      _L: /* CIL Label */ 
      {
#line 130
      fwrite((void const   */* __restrict  */)linebuf, (size_t )1, (size_t )12, (FILE */* __restrict  */)stdout);
#line 133
      fputs((char const   */* __restrict  */)"<a href=\"", (FILE */* __restrict  */)stdout);
#line 134
      ptr1 = linebuf + 12;
      }
      {
#line 134
      while (1) {
        while_continue: /* CIL Label */ ;
#line 134
        if (*ptr1) {
          {
#line 134
          tmp = __ctype_b_loc();
          }
#line 134
          if ((int const   )*(*tmp + (int )*ptr1) & 8192) {
#line 134
            goto while_break;
          }
        } else {
#line 134
          goto while_break;
        }
        {
#line 135
        putchar((int )*ptr1);
#line 134
        ptr1 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 136
      fputs((char const   */* __restrict  */)"\">", (FILE */* __restrict  */)stdout);
#line 137
      fwrite((void const   */* __restrict  */)(linebuf + 12), (size_t )1, (size_t )(ptr1 - (linebuf + 12)),
             (FILE */* __restrict  */)stdout);
#line 138
      fputs((char const   */* __restrict  */)"</a>", (FILE */* __restrict  */)stdout);
#line 141
      puts((char const   *)ptr1);
      }
    } else {
      {
#line 143
      puts((char const   *)linebuf);
      }
    }
  } else {
#line 126
    goto _L;
  }
#line 144
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/cgiemail-1.6/cgilibcso.c"
int cgi_standard_cso(void) 
{ 
  cgi_form form ;
  char *query ;
  char fingerbuf[32768] ;
  char *ptr ;
  char linebuf[256] ;
  char namebuf[256] ;
  char deptbuf[256] ;
  char aliasbuf[256] ;
  char titlebuf[256] ;
  char yearbuf[256] ;
  char emailbuf[256] ;
  int i ;
  int fieldlen ;
  int motdlen ;
  char *fingerhost ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  {
#line 154
  motdlen = 0;
#line 157
  tmp = cgi_alloc_form(& form);
  }
#line 157
  if (tmp) {
    {
#line 160
    cgi_output_failure(& form, (char *)"Request was not processed due to an error.");
#line 161
    cgi_free_form(& form);
    }
#line 162
    return (1);
  } else {
    {
#line 157
    tmp___0 = cgi_parse_form(& form);
    }
#line 157
    if (tmp___0) {
      {
#line 160
      cgi_output_failure(& form, (char *)"Request was not processed due to an error.");
#line 161
      cgi_free_form(& form);
      }
#line 162
      return (1);
    }
  }
  {
#line 164
  query = cgi_value(& form, (char *)"query");
#line 167
  fingerhost = (char *)"mitdir.mit.edu";
#line 182
  tmp___1 = finger(query, fingerhost, fingerbuf, 32768);
  }
#line 182
  if (tmp___1 < 0) {
    {
#line 184
    form.errcond = 1;
#line 185
    snprintf((char */* __restrict  */)(form.errmsg), (size_t )1023, (char const   */* __restrict  */)"500 Could not finger %s@%s",
             query, fingerhost);
#line 186
    cgi_concat_errno(form.errmsg);
#line 187
    cgi_output_failure(& form, (char *)"Request was not processed due to an error.");
#line 188
    cgi_free_form(& form);
    }
#line 189
    return (1);
  }
  {
#line 192
  cgi_fix_crlf(fingerbuf);
#line 195
  ptr = fingerbuf;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    ptr = cgi_next_line_in_string(ptr, linebuf, 256);
    }
#line 196
    if (! ((unsigned long )ptr != (unsigned long )((char *)0))) {
#line 196
      goto while_break;
    }
    {
#line 198
    tmp___2 = strncmp((char const   *)(linebuf), "There were ", (size_t )11);
    }
#line 198
    if (! tmp___2) {
#line 198
      goto while_break;
    }
#line 199
    motdlen = (int )(ptr - fingerbuf);
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  if (! ptr) {
    {
#line 205
    cgi_cso_header(& form, query);
#line 206
    linebuf[0] = (char )'\000';
#line 207
    ptr = strstr((char const   *)(fingerbuf), "There was 1 match to your request");
    }
#line 208
    if (! ptr) {
#line 208
      ptr = fingerbuf;
    }
#line 209
    motdlen = (int )(ptr - fingerbuf);
#line 210
    if (motdlen) {
      {
#line 210
      ptr = cgi_next_line_in_string(ptr, linebuf, 256);
      }
    }
    {
#line 211
    printf((char const   */* __restrict  */)"<p>%s</p>\n<PRE>", linebuf);
    }
    {
#line 213
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 213
      ptr = cgi_next_line_in_string(ptr, linebuf, 256);
      }
#line 213
      if (! ((unsigned long )ptr != (unsigned long )((char *)0))) {
#line 213
        goto while_break___0;
      }
      {
#line 216
      tmp___3 = cgi_cso_field(linebuf, (char *)"alias", aliasbuf, 256);
      }
#line 216
      if (tmp___3) {
#line 217
        goto while_continue___0;
      }
      {
#line 220
      tmp___4 = cgi_cso_field(linebuf, (char *)"email", emailbuf, 256);
      }
#line 220
      if (tmp___4) {
        {
#line 220
        tmp___5 = strcmp((char const   *)(emailbuf), "Unknown");
        }
#line 220
        if (tmp___5) {
          {
#line 223
          printf((char const   */* __restrict  */)"%10s: <A HREF=\"mailto:%s\">%s</A>\n",
                 "email", emailbuf, emailbuf);
          }
#line 225
          goto while_continue___0;
        }
      }
      {
#line 229
      cgi_url_print(linebuf);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 235
    deptbuf[0] = (char )'\000';
#line 236
    cgi_cso_header(& form, query);
#line 237
    printf((char const   */* __restrict  */)"<p>%s</p>\n<PRE>", linebuf);
    }
    {
#line 238
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 238
      ptr = cgi_next_line_in_string(ptr, linebuf, 256);
      }
#line 238
      if (! ((unsigned long )ptr != (unsigned long )((char *)0))) {
#line 238
        goto while_break___1;
      }
      {
#line 240
      tmp___6 = cgi_cso_field(linebuf, (char *)"department", deptbuf, 256);
      }
#line 240
      if (tmp___6) {
#line 240
        goto while_continue___1;
      }
      {
#line 241
      tmp___7 = cgi_cso_field(linebuf, (char *)"name", namebuf, 256);
      }
#line 241
      if (tmp___7) {
#line 241
        goto while_continue___1;
      }
      {
#line 242
      tmp___8 = cgi_cso_field(linebuf, (char *)"title", titlebuf, 256);
      }
#line 242
      if (tmp___8) {
#line 242
        goto while_continue___1;
      }
      {
#line 243
      tmp___9 = cgi_cso_field(linebuf, (char *)"year", yearbuf, 256);
      }
#line 243
      if (tmp___9) {
#line 243
        goto while_continue___1;
      }
      {
#line 244
      tmp___12 = cgi_cso_field(linebuf, (char *)"alias", aliasbuf, 256);
      }
#line 244
      if (tmp___12) {
        {
#line 247
        fputs((char const   */* __restrict  */)"<A HREF=\"", (FILE */* __restrict  */)stdout);
#line 248
        tmp___10 = getenv("SCRIPT_NAME");
#line 248
        fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)stdout);
#line 249
        fputs((char const   */* __restrict  */)"?query=alias%3D", (FILE */* __restrict  */)stdout);
#line 250
        fputs((char const   */* __restrict  */)(aliasbuf), (FILE */* __restrict  */)stdout);
#line 251
        fputs((char const   */* __restrict  */)"\">", (FILE */* __restrict  */)stdout);
#line 252
        fputs((char const   */* __restrict  */)(namebuf), (FILE */* __restrict  */)stdout);
#line 255
        fputs((char const   */* __restrict  */)"</A>...", (FILE */* __restrict  */)stdout);
#line 256
        tmp___11 = strlen((char const   *)(namebuf));
#line 256
        fieldlen = (int )(24UL - tmp___11);
#line 257
        i = 0;
        }
        {
#line 257
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 257
          if (! (i < fieldlen)) {
#line 257
            goto while_break___2;
          }
          {
#line 257
          putchar('.');
#line 257
          i ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 261
        if (deptbuf[0]) {
#line 263
          if (yearbuf[0]) {
            {
#line 265
            fputs((char const   */* __restrict  */)(deptbuf), (FILE */* __restrict  */)stdout);
#line 266
            fputs((char const   */* __restrict  */)", year ", (FILE */* __restrict  */)stdout);
#line 267
            puts((char const   *)(yearbuf));
            }
          } else {
            {
#line 269
            puts((char const   *)(deptbuf));
            }
          }
        } else
#line 272
        if (yearbuf[0]) {
          {
#line 274
          fputs((char const   */* __restrict  */)"Year ", (FILE */* __restrict  */)stdout);
#line 275
          puts((char const   *)(yearbuf));
          }
        } else
#line 278
        if (titlebuf[0]) {
          {
#line 278
          puts((char const   *)(titlebuf));
          }
        } else {
          {
#line 279
          puts("");
          }
        }
#line 280
        yearbuf[0] = (char )'\000';
#line 280
        titlebuf[0] = yearbuf[0];
#line 280
        deptbuf[0] = titlebuf[0];
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 285
  puts("</PRE>");
#line 286
  fwrite((void const   */* __restrict  */)(fingerbuf), sizeof(char ), (size_t )motdlen,
         (FILE */* __restrict  */)stdout);
#line 287
  cgi_cso_footer();
  }
#line 288
  return (0);
}
}
