/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 68 "/usr/include/errno.h"
typedef int error_t;
#line 153 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
struct lt_dlhandle_struct;
#line 153 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef struct lt_dlhandle_struct *lt_dlhandle;
#line 188 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef void lt_dlmutex_lock(void);
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef void lt_dlmutex_unlock(void);
#line 190 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef void lt_dlmutex_seterror(char const   *errmsg );
#line 191 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef char const   *lt_dlmutex_geterror(void);
#line 221 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
struct __anonstruct_lt_dlsymlist_30 {
   char const   *name ;
   void *address ;
};
#line 221 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef struct __anonstruct_lt_dlsymlist_30 lt_dlsymlist;
#line 242 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
struct __anonstruct_lt_dlinfo_31 {
   char *filename ;
   char *name ;
   int ref_count ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef struct __anonstruct_lt_dlinfo_31 lt_dlinfo;
#line 256 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef unsigned int lt_dlcaller_id;
#line 270
struct lt_dlloader;
#line 270 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef struct lt_dlloader lt_dlloader;
#line 271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef void *lt_user_data;
#line 272 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef void *lt_module;
#line 275 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef lt_module lt_module_open(lt_user_data loader_data , char const   *filename );
#line 277 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef int lt_module_close(lt_user_data loader_data , lt_module handle );
#line 279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef void *lt_find_sym(lt_user_data loader_data , lt_module handle , char const   *symbol );
#line 282 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
typedef int lt_dlloader_exit(lt_user_data loader_data );
#line 284 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
struct lt_user_dlloader {
   char const   *sym_prefix ;
   lt_module_open *module_open ;
   lt_module_close *module_close ;
   lt_find_sym *find_sym ;
   lt_dlloader_exit *dlloader_exit ;
   lt_user_data dlloader_data ;
};
#line 806 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
struct __anonstruct_lt_caller_data_33 {
   lt_dlcaller_id key ;
   void *data ;
};
#line 806 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
typedef struct __anonstruct_lt_caller_data_33 lt_caller_data;
#line 830 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
struct lt_dlloader {
   struct lt_dlloader *next ;
   char const   *loader_name ;
   char const   *sym_prefix ;
   lt_module_open *module_open ;
   lt_module_close *module_close ;
   lt_find_sym *find_sym ;
   lt_dlloader_exit *dlloader_exit ;
   lt_user_data dlloader_data ;
};
#line 841 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
struct lt_dlhandle_struct {
   struct lt_dlhandle_struct *next ;
   lt_dlloader *loader ;
   lt_dlinfo info ;
   int depcount ;
   lt_dlhandle *deplibs ;
   lt_module module ;
   void *system ;
   lt_caller_data *caller_data ;
   int flags ;
};
#line 1952 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
struct lt_dlsymlists_t {
   struct lt_dlsymlists_t *next ;
   lt_dlsymlist const   *syms ;
};
#line 1952 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
typedef struct lt_dlsymlists_t lt_dlsymlists_t;
#line 2144 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
typedef int foreach_callback_func(char *filename , void *data1 , void *data2 );
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 425 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
struct fr_randctx {
   uint32_t randcnt ;
   uint32_t randrsl[256] ;
   uint32_t randmem[256] ;
   uint32_t randa ;
   uint32_t randb ;
   uint32_t randc ;
};
#line 425 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct fr_randctx fr_randctx;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_23 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_23 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 202 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
union __anonunion_ipaddr_43 {
   struct in_addr ip4addr ;
   struct in6_addr ip6addr ;
};
#line 202 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
struct fr_ipaddr_t {
   int af ;
   union __anonunion_ipaddr_43 ipaddr ;
   uint32_t scope ;
};
#line 202 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct fr_ipaddr_t fr_ipaddr_t;
#line 480
struct fr_fifo_t;
#line 480 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct fr_fifo_t fr_fifo_t;
#line 30 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
struct fr_fifo_entry_t {
   struct fr_fifo_entry_t *next ;
   void *data ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
typedef struct fr_fifo_entry_t fr_fifo_entry_t;
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
struct fr_fifo_t {
   fr_fifo_entry_t *head ;
   fr_fifo_entry_t **tail ;
   fr_fifo_entry_t *freelist ;
   int num_elements ;
   int max_entries ;
   void (*freeNode)(void * ) ;
};
#line 36 "/usr/include/stdint.h"
typedef signed char int8_t;
#line 38 "/usr/include/stdint.h"
typedef int int32_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
enum fr_token_t {
    T_OP_INVALID = 0,
    T_EOL = 1,
    T_LCBRACE = 2,
    T_RCBRACE = 3,
    T_LBRACE = 4,
    T_RBRACE = 5,
    T_COMMA = 6,
    T_SEMICOLON = 7,
    T_OP_ADD = 8,
    T_OP_SUB = 9,
    T_OP_SET = 10,
    T_OP_EQ = 11,
    T_OP_NE = 12,
    T_OP_GE = 13,
    T_OP_GT = 14,
    T_OP_LE = 15,
    T_OP_LT = 16,
    T_OP_REG_EQ = 17,
    T_OP_REG_NE = 18,
    T_OP_CMP_TRUE = 19,
    T_OP_CMP_FALSE = 20,
    T_OP_CMP_EQ = 21,
    T_HASH = 22,
    T_BARE_WORD = 23,
    T_DOUBLE_QUOTED_STRING = 24,
    T_SINGLE_QUOTED_STRING = 25,
    T_BACK_QUOTED_STRING = 26,
    T_TOKEN_LAST = 27
} ;
#line 33 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
typedef enum fr_token_t FR_TOKEN;
#line 95 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
struct attr_flags {
   unsigned int addport : 1 ;
   unsigned int has_tag : 1 ;
   unsigned int do_xlat : 1 ;
   unsigned int unknown_attr : 1 ;
   unsigned int array : 1 ;
   unsigned int has_value : 1 ;
   unsigned int has_value_alias : 1 ;
   unsigned int has_tlv : 1 ;
   unsigned int is_tlv : 1 ;
   unsigned int encoded : 1 ;
   int8_t tag ;
   uint8_t encrypt ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct attr_flags ATTR_FLAGS;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
struct dict_attr {
   unsigned int attr ;
   int type ;
   int vendor ;
   ATTR_FLAGS flags ;
   char name[1] ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct dict_attr DICT_ATTR;
#line 127 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
struct dict_value {
   unsigned int attr ;
   int value ;
   char name[1] ;
};
#line 127 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct dict_value DICT_VALUE;
#line 133 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
struct dict_vendor {
   int vendorpec ;
   int type ;
   int length ;
   int flags ;
   char name[1] ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct dict_vendor DICT_VENDOR;
#line 141 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
union value_pair_data {
   char strvalue[254] ;
   uint8_t octets[254] ;
   struct in_addr ipaddr ;
   struct in6_addr ipv6addr ;
   uint32_t date ;
   uint32_t integer ;
   int32_t sinteger ;
   uint8_t filter[32] ;
   uint8_t ifid[8] ;
   uint8_t ipv6prefix[18] ;
   uint8_t ether[6] ;
   uint8_t *tlv ;
};
#line 141 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef union value_pair_data VALUE_PAIR_DATA;
#line 156 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
struct value_pair {
   char const   *name ;
   int attribute ;
   int vendor ;
   int type ;
   size_t length ;
   FR_TOKEN operator ;
   ATTR_FLAGS flags ;
   struct value_pair *next ;
   uint32_t lvalue ;
   VALUE_PAIR_DATA data ;
};
#line 156 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct value_pair VALUE_PAIR;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_47 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_47 regmatch_t;
#line 60 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
struct FR_MD5Context {
   uint32_t state[4] ;
   uint32_t count[2] ;
   uint8_t buffer[64] ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
typedef struct FR_MD5Context FR_MD5_CTX;
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/sha1.h"
struct __anonstruct_fr_SHA1_CTX_42 {
   uint32_t state[5] ;
   uint32_t count[2] ;
   uint8_t buffer[64] ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/sha1.h"
typedef struct __anonstruct_fr_SHA1_CTX_42 fr_SHA1_CTX;
#line 163 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
union __anonunion_CHAR64LONG16_45 {
   uint8_t c[64] ;
   uint32_t l[16] ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
typedef union __anonunion_CHAR64LONG16_45 CHAR64LONG16;
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
struct fr_hash_table_t;
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
typedef struct fr_hash_table_t fr_hash_table_t;
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
struct fr_hash_entry_t {
   struct fr_hash_entry_t *next ;
   uint32_t reversed ;
   uint32_t key ;
   void *data ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
typedef struct fr_hash_entry_t fr_hash_entry_t;
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
struct fr_hash_table_t {
   int num_elements ;
   int num_buckets ;
   int next_grow ;
   int mask ;
   void (*free)(void * ) ;
   uint32_t (*hash)(void const   * ) ;
   int (*cmp)(void const   * , void const   * ) ;
   fr_hash_entry_t null ;
   fr_hash_entry_t **buckets ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 220 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
struct radius_packet {
   int sockfd ;
   fr_ipaddr_t src_ipaddr ;
   fr_ipaddr_t dst_ipaddr ;
   uint16_t src_port ;
   uint16_t dst_port ;
   int id ;
   unsigned int code ;
   uint32_t hash ;
   uint8_t vector[16] ;
   time_t timestamp ;
   uint8_t *data ;
   int data_len ;
   VALUE_PAIR *vps ;
   ssize_t offset ;
};
#line 220 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct radius_packet RADIUS_PACKET;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
struct FR_NAME_NUMBER {
   char const   *name ;
   int number ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
typedef struct FR_NAME_NUMBER FR_NAME_NUMBER;
#line 71 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
struct FR_MD4Context {
   uint32_t state[4] ;
   uint32_t count[2] ;
   uint8_t buffer[64] ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
typedef struct FR_MD4Context FR_MD4_CTX;
#line 444 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
struct rbtree_t;
#line 444 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct rbtree_t rbtree_t;
#line 445
struct rbnode_t;
#line 445 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef struct rbnode_t rbnode_t;
#line 462
enum __anonenum_RBTREE_ORDER_44 {
    PreOrder = 0,
    InOrder = 1,
    PostOrder = 2
} ;
#line 462 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
typedef enum __anonenum_RBTREE_ORDER_44 RBTREE_ORDER;
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
enum __anonenum_NodeColor_45 {
    Black = 0,
    Red = 1
} ;
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
typedef enum __anonenum_NodeColor_45 NodeColor;
#line 31 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
struct rbnode_t {
   rbnode_t *Left ;
   rbnode_t *Right ;
   rbnode_t *Parent ;
   NodeColor Color ;
   void *Data ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
struct rbtree_t {
   rbnode_t *Root ;
   int num_elements ;
   int (*Compare)(void const   * , void const   * ) ;
   int replace_flag ;
   void (*freeNode)(void * ) ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
struct fr_heap_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
typedef struct fr_heap_t fr_heap_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
struct fr_event_list_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
typedef struct fr_event_list_t fr_event_list_t;
#line 35
struct fr_event_t;
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
typedef struct fr_event_t fr_event_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
struct fr_event_fd_t {
   int fd ;
   void (*handler)(fr_event_list_t *el , int sock , void *ctx ) ;
   void *ctx ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
typedef struct fr_event_fd_t fr_event_fd_t;
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
struct fr_event_list_t {
   fr_heap_t *times ;
   int changed ;
   int exit ;
   void (*status)(struct timeval * ) ;
   struct timeval now ;
   int dispatch ;
   int max_readers ;
   fr_event_fd_t readers[256] ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
struct fr_event_t {
   void (*callback)(void * ) ;
   void *ctx ;
   struct timeval when ;
   fr_event_t **ev_p ;
   int heap ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
struct dict_stat_t {
   struct dict_stat_t *next ;
   char *name ;
   time_t mtime ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
typedef struct dict_stat_t dict_stat_t;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
struct value_fixup_t {
   char attrstr[128] ;
   DICT_VALUE *dval ;
   struct value_fixup_t *next ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
typedef struct value_fixup_t value_fixup_t;
#line 308 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
struct fr_pool_t {
   void *page_end ;
   void *free_ptr ;
   struct fr_pool_t *page_free ;
   struct fr_pool_t *page_next ;
};
#line 308 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
typedef struct fr_pool_t fr_pool_t;
#line 94 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
struct ascend_ip_filter_t {
   uint32_t srcip ;
   uint32_t dstip ;
   uint8_t srcmask ;
   uint8_t dstmask ;
   uint8_t proto ;
   uint8_t established ;
   uint16_t srcport ;
   uint16_t dstport ;
   uint8_t srcPortComp ;
   uint8_t dstPortComp ;
   unsigned char fill[4] ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
typedef struct ascend_ip_filter_t ascend_ip_filter_t;
#line 118 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
struct ascend_ipx_net_t {
   uint32_t net ;
   uint8_t node[6] ;
   uint16_t socket ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
typedef struct ascend_ipx_net_t ascend_ipx_net_t;
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
struct ascend_ipx_filter_t {
   ascend_ipx_net_t src ;
   ascend_ipx_net_t dst ;
   uint8_t srcSocComp ;
   uint8_t dstSocComp ;
};
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
typedef struct ascend_ipx_filter_t ascend_ipx_filter_t;
#line 170 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
struct ascend_generic_filter_t {
   uint16_t offset ;
   uint16_t len ;
   uint16_t more ;
   uint8_t mask[6] ;
   uint8_t value[6] ;
   uint8_t compNeq ;
   uint8_t fill[3] ;
};
#line 170 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
typedef struct ascend_generic_filter_t ascend_generic_filter_t;
#line 203 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
union __anonunion_u_46 {
   ascend_ip_filter_t ip ;
   ascend_ipx_filter_t ipx ;
   ascend_generic_filter_t generic ;
   uint8_t data[28] ;
};
#line 203 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
struct ascend_filter_t {
   uint8_t type ;
   uint8_t forward ;
   uint8_t direction ;
   uint8_t fill ;
   union __anonunion_u_46 u ;
};
#line 203 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
typedef struct ascend_filter_t ascend_filter_t;
#line 59 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
struct radius_packet_t {
   uint8_t code ;
   uint8_t id ;
   uint8_t length[2] ;
   uint8_t vector[16] ;
   uint8_t data[1] ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
typedef struct radius_packet_t radius_packet_t;
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
struct fr_packet_list_t;
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
typedef struct fr_packet_list_t fr_packet_list_t;
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
struct fr_packet_socket_t {
   int sockfd ;
   int num_outgoing ;
   int offset ;
   int inaddr_any ;
   fr_ipaddr_t ipaddr ;
   int port ;
};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
typedef struct fr_packet_socket_t fr_packet_socket_t;
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
struct fr_packet_list_t {
   rbtree_t *tree ;
   fr_hash_table_t *dst2id_ht ;
   int alloc_id ;
   int num_outgoing ;
   uint32_t mask ;
   int last_recv ;
   fr_packet_socket_t sockets[32] ;
};
#line 460 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
struct fr_packet_dst2id_t {
   fr_ipaddr_t dst_ipaddr ;
   int dst_port ;
   uint32_t id[1] ;
};
#line 460 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
typedef struct fr_packet_dst2id_t fr_packet_dst2id_t;
#line 17 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
struct fr_heap_t {
   int size ;
   int num_elements ;
   size_t offset ;
   int (*cmp)(void const   * , void const   * ) ;
   void **p ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
struct conf_part;
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
typedef struct conf_part CONF_SECTION;
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
struct CONF_PARSER {
   char const   *name ;
   int type ;
   size_t offset ;
   void *data ;
   char const   *dflt ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
typedef struct CONF_PARSER CONF_PARSER;
#line 36 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
struct auth_req;
#line 36 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
typedef struct auth_req REQUEST;
#line 36 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
typedef uint32_t fr_uint_t;
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
struct fr_stats_t {
   fr_uint_t total_requests ;
   fr_uint_t total_invalid_requests ;
   fr_uint_t total_dup_requests ;
   fr_uint_t total_responses ;
   fr_uint_t total_access_accepts ;
   fr_uint_t total_access_rejects ;
   fr_uint_t total_access_challenges ;
   fr_uint_t total_malformed_requests ;
   fr_uint_t total_bad_authenticators ;
   fr_uint_t total_packets_dropped ;
   fr_uint_t total_no_records ;
   fr_uint_t total_unknown_types ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
typedef struct fr_stats_t fr_stats_t;
#line 55 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
struct fr_stats_ema_t {
   int window ;
   int f1 ;
   int f10 ;
   int ema1 ;
   int ema10 ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
typedef struct fr_stats_ema_t fr_stats_ema_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
struct home_server {
   char const   *name ;
   char const   *hostname ;
   char const   *server ;
   fr_ipaddr_t ipaddr ;
   int port ;
   int type ;
   char const   *secret ;
   fr_event_t *ev ;
   struct timeval when ;
   int response_window ;
   int no_response_fail ;
   int max_outstanding ;
   int currently_outstanding ;
   int message_authenticator ;
   time_t last_packet ;
   struct timeval revive_time ;
   struct timeval zombie_period_start ;
   int zombie_period ;
   int state ;
   int ping_check ;
   char const   *ping_user_name ;
   char const   *ping_user_password ;
   int ping_interval ;
   int num_pings_to_alive ;
   int num_received_pings ;
   int ping_timeout ;
   int revive_interval ;
   CONF_SECTION *cs ;
   int coa_irt ;
   int coa_mrc ;
   int coa_mrt ;
   int coa_mrd ;
   int number ;
   fr_ipaddr_t src_ipaddr ;
   fr_stats_t stats ;
   fr_stats_ema_t ema ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
typedef struct home_server home_server;
#line 96
enum home_pool_type_t {
    HOME_POOL_INVALID = 0,
    HOME_POOL_LOAD_BALANCE = 1,
    HOME_POOL_FAIL_OVER = 2,
    HOME_POOL_CLIENT_BALANCE = 3,
    HOME_POOL_CLIENT_PORT_BALANCE = 4,
    HOME_POOL_KEYED_BALANCE = 5
} ;
#line 96 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
typedef enum home_pool_type_t home_pool_type_t;
#line 106 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
struct home_pool_t {
   char const   *name ;
   home_pool_type_t type ;
   int server_type ;
   CONF_SECTION *cs ;
   char const   *virtual_server ;
   home_server *fallback ;
   int num_home_servers ;
   home_server *servers[1] ;
};
#line 106 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
typedef struct home_pool_t home_pool_t;
#line 114 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
struct request_data_t;
#line 114 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
typedef struct request_data_t request_data_t;
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
struct radclient {
   fr_ipaddr_t ipaddr ;
   int prefix ;
   char *longname ;
   char *secret ;
   char *shortname ;
   int message_authenticator ;
   char *nastype ;
   char *login ;
   char *password ;
   char *server ;
   int number ;
   CONF_SECTION const   *cs ;
   fr_stats_t *auth ;
   fr_stats_t *acct ;
   int lifetime ;
   int dynamic ;
   time_t created ;
   time_t last_new_client ;
   char *client_server ;
   int rate_limit ;
   char *coa_name ;
   home_server *coa_server ;
   home_pool_t *coa_pool ;
};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
typedef struct radclient RADCLIENT;
#line 157
enum RAD_LISTEN_TYPE {
    RAD_LISTEN_NONE = 0,
    RAD_LISTEN_PROXY = 1,
    RAD_LISTEN_AUTH = 2,
    RAD_LISTEN_ACCT = 3,
    RAD_LISTEN_DETAIL = 4,
    RAD_LISTEN_VQP = 5,
    RAD_LISTEN_COMMAND = 6,
    RAD_LISTEN_COA = 7,
    RAD_LISTEN_MAX = 8
} ;
#line 157 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
typedef enum RAD_LISTEN_TYPE RAD_LISTEN_TYPE;
#line 188
struct rad_listen_t;
#line 188 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
typedef struct rad_listen_t rad_listen_t;
#line 194
struct main_config_t;
#line 194 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
struct auth_req {
   RADIUS_PACKET *packet ;
   RADIUS_PACKET *proxy ;
   RADIUS_PACKET *reply ;
   RADIUS_PACKET *proxy_reply ;
   VALUE_PAIR *config_items ;
   VALUE_PAIR *username ;
   VALUE_PAIR *password ;
   struct main_config_t *root ;
   request_data_t *data ;
   RADCLIENT *client ;
   pthread_t child_pid ;
   time_t timestamp ;
   unsigned int number ;
   rad_listen_t *listener ;
   rad_listen_t *proxy_listener ;
   int simul_max ;
   int simul_count ;
   int simul_mpp ;
   int options ;
   char const   *module ;
   char const   *component ;
   struct timeval received ;
   struct timeval when ;
   int delay ;
   int master_state ;
   int child_state ;
   RAD_LISTEN_TYPE priority ;
   fr_event_t *ev ;
   struct timeval next_when ;
   void (*next_callback)(void * ) ;
   int in_request_hash ;
   int in_proxy_hash ;
   home_server *home_server ;
   home_pool_t *home_pool ;
   struct timeval proxy_when ;
   int num_proxied_requests ;
   int num_proxied_responses ;
   char const   *server ;
   REQUEST *parent ;
   void (*radlog)(int  , int  , REQUEST * , char const   *  , ...) ;
   REQUEST *coa ;
   int num_coa_requests ;
};
#line 290 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
typedef int (*RAD_REQUEST_FUNP)(REQUEST * );
#line 311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
struct rad_listen_t {
   struct rad_listen_t *next ;
   RAD_LISTEN_TYPE type ;
   int fd ;
   char const   *server ;
   int status ;
   int (*recv)(rad_listen_t * , RAD_REQUEST_FUNP * , REQUEST ** ) ;
   int (*send)(rad_listen_t * , REQUEST * ) ;
   int (*encode)(rad_listen_t * , REQUEST * ) ;
   int (*decode)(rad_listen_t * , REQUEST * ) ;
   int (*print)(rad_listen_t const   * , char * , size_t  ) ;
   CONF_SECTION const   *cs ;
   void *data ;
   fr_stats_t stats ;
};
#line 341
enum radlog_dest_t {
    RADLOG_STDOUT = 0,
    RADLOG_FILES = 1,
    RADLOG_SYSLOG = 2,
    RADLOG_STDERR = 3,
    RADLOG_NULL = 4,
    RADLOG_NUM_DEST = 5
} ;
#line 341 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
typedef enum radlog_dest_t radlog_dest_t;
#line 350
struct main_config;
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
struct main_config_t {
   struct main_config *next ;
   int refcount ;
   fr_ipaddr_t myip ;
   int port ;
   int log_auth ;
   int log_auth_badpass ;
   int log_auth_goodpass ;
   int allow_core_dumps ;
   int debug_level ;
   int proxy_requests ;
   int reject_delay ;
   int status_server ;
   int max_request_time ;
   int cleanup_delay ;
   int max_requests ;
   char *log_file ;
   char *checkrad ;
   char const   *pid_file ;
   rad_listen_t *listen ;
   int syslog_facility ;
   int radlog_fd ;
   radlog_dest_t radlog_dest ;
   CONF_SECTION *config ;
   char const   *name ;
   char const   *auth_badpass_msg ;
   char const   *auth_goodpass_msg ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
typedef int (*packetmethod)(void *instance , REQUEST *request );
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
struct module_t {
   uint32_t magic ;
   char const   *name ;
   int type ;
   int (*instantiate)(CONF_SECTION *mod_cs , void **instance ) ;
   int (*detach)(void *instance ) ;
   packetmethod methods[10] ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
typedef struct module_t module_t;
#line 31 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acctlog/rlm_acctlog.c"
struct rlm_acctlog_t {
   char *acctstart ;
   char *acctstop ;
   char *acctupdate ;
   char *accton ;
   char *acctoff ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acctlog/rlm_acctlog.c"
typedef struct rlm_acctlog_t rlm_acctlog_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
struct conf_item;
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
typedef struct conf_item CONF_ITEM;
#line 25
struct conf_pair;
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
typedef struct conf_pair CONF_PAIR;
#line 17 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/detail.h"
enum detail_state_t {
    STATE_UNOPENED = 0,
    STATE_UNLOCKED = 1,
    STATE_HEADER = 2,
    STATE_READING = 3,
    STATE_QUEUED = 4,
    STATE_RUNNING = 5,
    STATE_NO_REPLY = 6,
    STATE_REPLIED = 7
} ;
#line 17 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/detail.h"
typedef enum detail_state_t detail_state_t;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/detail.h"
struct listen_detail_t {
   fr_event_t *ev ;
   int delay_time ;
   char *filename ;
   char *filename_work ;
   VALUE_PAIR *vps ;
   FILE *fp ;
   off_t offset ;
   detail_state_t state ;
   time_t timestamp ;
   time_t running ;
   fr_ipaddr_t client_ip ;
   int load_factor ;
   int signal ;
   int poll_interval ;
   int retry_interval ;
   int packets ;
   int tries ;
   int one_shot ;
   int has_rtt ;
   int srtt ;
   int rttvar ;
   struct timeval last_packet ;
   RADCLIENT detail_client ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/detail.h"
typedef struct listen_detail_t listen_detail_t;
#line 41 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
struct detail_instance {
   char *detailfile ;
   int detailperm ;
   int dirperm ;
   char *header ;
   int locking ;
   int log_srcdst ;
   fr_hash_table_t *ht ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
struct rlm_attr_rewrite_t {
   char *attribute ;
   int attr_num ;
   char *search ;
   int search_len ;
   char *searchin_str ;
   char searchin ;
   char *replace ;
   int replace_len ;
   int append ;
   int nocase ;
   int new_attr ;
   int num_matches ;
   char const   *name ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
typedef struct rlm_attr_rewrite_t rlm_attr_rewrite_t;
#line 47 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
struct rlm_checkval_t {
   char *item_name ;
   char *check_name ;
   char *data_type ;
   int dat_type ;
   int item_attr ;
   int chk_attr ;
   int notfound_reject ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
typedef struct rlm_checkval_t rlm_checkval_t;
#line 31 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
struct rlm_always_t {
   char *rcode_str ;
   int rcode ;
   int simulcount ;
   int mpp ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
typedef struct rlm_always_t rlm_always_t;
#line 294 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
struct pair_list {
   char const   *name ;
   VALUE_PAIR *check ;
   VALUE_PAIR *reply ;
   int lineno ;
   int order ;
   struct pair_list *next ;
   struct pair_list *lastdefault ;
};
#line 294 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
typedef struct pair_list PAIR_LIST;
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
struct attr_filter_instance {
   char *attrsfile ;
   char *key ;
   int relaxed ;
   PAIR_LIST *attrs ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
struct rlm_acct_unique_list_t {
   DICT_ATTR *dattr ;
   struct rlm_acct_unique_list_t *next ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
typedef struct rlm_acct_unique_list_t rlm_acct_unique_list_t;
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
struct rlm_acct_unique_t {
   char *key ;
   rlm_acct_unique_list_t *head ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
typedef struct rlm_acct_unique_t rlm_acct_unique_t;
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_copy_packet/rlm_copy_packet.c"
struct rlm_packet_t {
   char *string ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_copy_packet/rlm_copy_packet.c"
typedef struct rlm_packet_t rlm_packet_t;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 50 "/usr/include/argz.h"
extern  __attribute__((__nothrow__)) error_t ( __attribute__((__leaf__)) argz_create_sep)(char const   * __restrict  __string ,
                                                                                          int __sep ,
                                                                                          char ** __restrict  __argz ,
                                                                                          size_t * __restrict  __len ) ;
#line 70
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) argz_stringify)(char *__argz ,
                                                                                      size_t __len ,
                                                                                      int __sep ) ;
#line 77
extern  __attribute__((__nothrow__)) error_t ( __attribute__((__leaf__)) argz_append)(char ** __restrict  __argz ,
                                                                                      size_t * __restrict  __argz_len ,
                                                                                      char const   * __restrict  __buf ,
                                                                                      size_t __buf_len ) ;
#line 119
extern  __attribute__((__nothrow__)) error_t ( __attribute__((__leaf__)) argz_insert)(char ** __restrict  __argz ,
                                                                                      size_t * __restrict  __argz_len ,
                                                                                      char * __restrict  __before ,
                                                                                      char const   * __restrict  __entry ) ;
#line 154
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) argz_next)(char const   * __restrict  __argz ,
                                                                                  size_t __argz_len ,
                                                                                  char const   * __restrict  __entry ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 156 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.h"
int lt_dlinit(void) ;
#line 157
int lt_dlexit(void) ;
#line 160
int lt_dladdsearchdir(char const   *search_dir ) ;
#line 161
int lt_dlinsertsearchdir(char const   *before , char const   *search_dir ) ;
#line 163
int lt_dlsetsearchpath(char const   *search_path ) ;
#line 164
char const   *lt_dlgetsearchpath(void) ;
#line 165
int lt_dlforeachfile(char const   *search_path , int (*func)(char const   *filename ,
                                                             void *data ) , void *data ) ;
#line 171
lt_dlhandle lt_dlopen(char const   *filename ) ;
#line 172
lt_dlhandle lt_dlopenext(char const   *filename ) ;
#line 173
void *lt_dlsym(lt_dlhandle handle , char const   *symbol ) ;
#line 175
char const   *lt_dlerror(void) ;
#line 176
int lt_dlclose(lt_dlhandle handle ) ;
#line 179
int lt_dlmakeresident(lt_dlhandle handle ) ;
#line 180
int lt_dlisresident(lt_dlhandle handle ) ;
#line 193
int lt_dlmutex_register(lt_dlmutex_lock *lock , lt_dlmutex_unlock *unlock , lt_dlmutex_seterror *seterror ,
                        lt_dlmutex_geterror *geterror ) ;
#line 209
void *(*lt_dlmalloc)(size_t size ) ;
#line 210
void *(*lt_dlrealloc)(void *ptr , size_t size ) ;
#line 211
void (*lt_dlfree)(void *ptr ) ;
#line 226
int lt_dlpreload(lt_dlsymlist const   *preloaded ) ;
#line 227
int lt_dlpreload_default(lt_dlsymlist const   *preloaded ) ;
#line 249
lt_dlinfo const   *lt_dlgetinfo(lt_dlhandle handle ) ;
#line 250
lt_dlhandle lt_dlhandle_next(lt_dlhandle place ) ;
#line 251
int lt_dlforeach(int (*func)(lt_dlhandle handle , void *data ) , void *data ) ;
#line 258
lt_dlcaller_id lt_dlcaller_register(void) ;
#line 259
void *lt_dlcaller_set_data(lt_dlcaller_id key , lt_dlhandle handle , void *data ) ;
#line 262
void *lt_dlcaller_get_data(lt_dlcaller_id key , lt_dlhandle handle ) ;
#line 293
lt_dlloader *lt_dlloader_next(lt_dlloader *place ) ;
#line 294
lt_dlloader *lt_dlloader_find(char const   *loader_name ) ;
#line 296
char const   *lt_dlloader_name(lt_dlloader *place ) ;
#line 297
lt_user_data *lt_dlloader_data(lt_dlloader *place ) ;
#line 298
int lt_dlloader_add(lt_dlloader *place , struct lt_user_dlloader  const  *dlloader ,
                    char const   *loader_name ) ;
#line 301
int lt_dlloader_remove(char const   *loader_name ) ;
#line 345
int lt_dladderror(char const   *diagnostic ) ;
#line 346
int lt_dlseterror(int errindex ) ;
#line 212 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char *lt_estrdup(char const   *str ) ;
#line 213
static void *lt_emalloc(size_t size ) ;
#line 214
static void *lt_erealloc(void *addr , size_t size ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
void *(*lt_dlmalloc)(size_t size )  =    (void *(*)(size_t  ))(& malloc);
#line 222 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
void *(*lt_dlrealloc)(void *ptr , size_t size )  =    (void *(*)(void * , size_t  ))(& realloc);
#line 224 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
void (*lt_dlfree)(void *ptr )  =    (void (*)(void * ))(& free);
#line 262
static char *rpl_strdup(char const   *str ) ;
#line 264 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char *rpl_strdup(char const   *str ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 268
  tmp = (char *)0;
#line 270
  if (str) {
    {
#line 272
    tmp___0 = strlen(str);
#line 272
    tmp___1 = (*lt_dlmalloc)((1UL + tmp___0) * sizeof(char ));
#line 272
    tmp = (char *)tmp___1;
    }
#line 273
    if (tmp) {
      {
#line 275
      strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)str);
      }
    }
  }
#line 279
  return (tmp);
}
}
#line 820 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char const   *lt_dlerror_strings[21]  = 
#line 820
  {      "unknown error",      "dlopen support not available",      "invalid loader",      "loader initialization failed", 
        "loader removal failed",      "file not found",      "dependency library not found",      "no symbols defined", 
        "can\'t open the module",      "can\'t close the module",      "symbol not found",      "not enough memory", 
        "invalid module handle",      "internal buffer overflow",      "invalid errorcode",      "library already shutdown", 
        "can\'t close resident module",      "invalid mutex handler registration",      "invalid search path insert position",      "dep lib loading bug, please report to freeradius-devel@lists.freeradius.org", 
        (char const   *)0};
#line 866 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char const   objdir[7]  = {      (char const   )'.',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'s',      (char const   )'/',      (char const   )'\000'};
#line 867 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char const   archive_ext[4]  = {      (char const   )'.',      (char const   )'l',      (char const   )'a',      (char const   )'\000'};
#line 869 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char const   shlib_ext[4]  = {      (char const   )'.',      (char const   )'s',      (char const   )'o',      (char const   )'\000'};
#line 872 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char const   sys_search_path[181]  = 
#line 872
  {      (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )':',      (char const   )'/',      (char const   )'u',      (char const   )'s', 
        (char const   )'r',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'b',      (char const   )'/',      (char const   )'x', 
        (char const   )'8',      (char const   )'6',      (char const   )'_',      (char const   )'6', 
        (char const   )'4',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'u',      (char const   )'x',      (char const   )'-', 
        (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )'/', 
        (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'f', 
        (char const   )'a',      (char const   )'k',      (char const   )'e',      (char const   )'r', 
        (char const   )'o',      (char const   )'o',      (char const   )'t',      (char const   )':', 
        (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'b',      (char const   )':',      (char const   )'/', 
        (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'/', 
        (char const   )'x',      (char const   )'8',      (char const   )'6',      (char const   )'_', 
        (char const   )'6',      (char const   )'4',      (char const   )'-',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'u',      (char const   )'x', 
        (char const   )'-',      (char const   )'g',      (char const   )'n',      (char const   )'u', 
        (char const   )':',      (char const   )'/',      (char const   )'u',      (char const   )'s', 
        (char const   )'r',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )'/',      (char const   )'x',      (char const   )'8', 
        (char const   )'6',      (char const   )'_',      (char const   )'6',      (char const   )'4', 
        (char const   )'-',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'u',      (char const   )'x',      (char const   )'-',      (char const   )'g', 
        (char const   )'n',      (char const   )'u',      (char const   )':',      (char const   )'/', 
        (char const   )'u',      (char const   )'s',      (char const   )'r',      (char const   )'/', 
        (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'/', 
        (char const   )'x',      (char const   )'8',      (char const   )'6',      (char const   )'_', 
        (char const   )'6',      (char const   )'4',      (char const   )'-',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'u',      (char const   )'x', 
        (char const   )'-',      (char const   )'g',      (char const   )'n',      (char const   )'u', 
        (char const   )'/',      (char const   )'m',      (char const   )'e',      (char const   )'s', 
        (char const   )'a',      (char const   )'-',      (char const   )'e',      (char const   )'g', 
        (char const   )'l',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'b',      (char const   )'/',      (char const   )'x', 
        (char const   )'8',      (char const   )'6',      (char const   )'_',      (char const   )'6', 
        (char const   )'4',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'u',      (char const   )'x',      (char const   )'-', 
        (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )'/', 
        (char const   )'m',      (char const   )'e',      (char const   )'s',      (char const   )'a', 
        (char const   )'\000'};
#line 903 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlmutex_lock *lt_dlmutex_lock_func  =    (lt_dlmutex_lock *)0;
#line 904 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlmutex_unlock *lt_dlmutex_unlock_func  =    (lt_dlmutex_unlock *)0;
#line 905 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlmutex_seterror *lt_dlmutex_seterror_func  =    (lt_dlmutex_seterror *)0;
#line 906 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlmutex_geterror *lt_dlmutex_geterror_func  =    (lt_dlmutex_geterror *)0;
#line 907 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char const   *lt_dllast_error  =    (char const   *)0;
#line 914 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlmutex_register(lt_dlmutex_lock *lock , lt_dlmutex_unlock *unlock , lt_dlmutex_seterror *seterror ,
                        lt_dlmutex_geterror *geterror ) 
{ 
  lt_dlmutex_unlock *old_unlock ;
  int errors ;

  {
#line 921
  old_unlock = unlock;
#line 922
  errors = 0;
#line 925
  if (lt_dlmutex_lock_func) {
    {
#line 925
    (*lt_dlmutex_lock_func)();
    }
  }
#line 927
  if (lock) {
#line 927
    if (unlock) {
#line 927
      if (seterror) {
#line 927
        if (geterror) {
#line 930
          lt_dlmutex_lock_func = lock;
#line 931
          lt_dlmutex_unlock_func = unlock;
#line 932
          lt_dlmutex_geterror_func = geterror;
        } else {
#line 927
          goto _L___2;
        }
      } else {
#line 927
        goto _L___2;
      }
    } else {
#line 927
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 927
  if (lock) {
#line 927
    goto _L;
  } else
#line 927
  if (unlock) {
#line 927
    goto _L;
  } else
#line 927
  if (seterror) {
#line 927
    goto _L;
  } else
#line 927
  if (geterror) {
    _L: /* CIL Label */ 
#line 936
    if (lt_dlmutex_seterror_func) {
      {
#line 936
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[17]);
      }
    } else {
#line 936
      lt_dllast_error = lt_dlerror_strings[17];
    }
#line 937
    errors ++;
  } else {
#line 930
    lt_dlmutex_lock_func = lock;
#line 931
    lt_dlmutex_unlock_func = unlock;
#line 932
    lt_dlmutex_geterror_func = geterror;
  }
#line 942
  if (old_unlock) {
    {
#line 943
    (*old_unlock)();
    }
  }
#line 947
  return (errors);
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char const   **user_error_strings  =    (char const   **)0;
#line 957 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int errorcount  =    20;
#line 959 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dladderror(char const   *diagnostic ) 
{ 
  int errindex ;
  int result ;
  char const   **temp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 963
  errindex = 0;
#line 964
  result = -1;
#line 965
  temp = (char const   **)0;
#line 967
  if (! diagnostic) {
    {
#line 967
    __assert_fail("diagnostic", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  967U, "lt_dladderror");
    }
  }
#line 969
  if (lt_dlmutex_lock_func) {
    {
#line 969
    (*lt_dlmutex_lock_func)();
    }
  }
  {
#line 971
  errindex = errorcount - 20;
#line 972
  tmp = lt_erealloc((void *)user_error_strings, (unsigned long )(1 + errindex) * sizeof(char const   *));
#line 972
  temp = (char const   **)tmp;
  }
#line 973
  if (temp) {
#line 975
    user_error_strings = temp;
#line 976
    *(user_error_strings + errindex) = diagnostic;
#line 977
    tmp___0 = errorcount;
#line 977
    errorcount ++;
#line 977
    result = tmp___0;
  }
#line 980
  if (lt_dlmutex_unlock_func) {
    {
#line 980
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 982
  return (result);
}
}
#line 985 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlseterror(int errindex ) 
{ 
  int errors ;

  {
#line 989
  errors = 0;
#line 991
  if (lt_dlmutex_lock_func) {
    {
#line 991
    (*lt_dlmutex_lock_func)();
    }
  }
#line 993
  if (errindex >= errorcount) {
#line 993
    goto _L;
  } else
#line 993
  if (errindex < 0) {
    _L: /* CIL Label */ 
#line 996
    if (lt_dlmutex_seterror_func) {
      {
#line 996
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[14]);
      }
    } else {
#line 996
      lt_dllast_error = lt_dlerror_strings[14];
    }
#line 997
    errors ++;
  } else
#line 999
  if (errindex < 20) {
#line 1002
    if (lt_dlmutex_seterror_func) {
      {
#line 1002
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[errindex]);
      }
    } else {
#line 1002
      lt_dllast_error = lt_dlerror_strings[errindex];
    }
  } else
#line 1007
  if (lt_dlmutex_seterror_func) {
    {
#line 1007
    (*lt_dlmutex_seterror_func)(*(user_error_strings + (errindex - 20)));
    }
  } else {
#line 1007
    lt_dllast_error = *(user_error_strings + (errindex - 20));
  }
#line 1010
  if (lt_dlmutex_unlock_func) {
    {
#line 1010
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 1012
  return (errors);
}
}
#line 1015 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static void *lt_emalloc(size_t size ) 
{ 
  void *mem ;
  void *tmp ;

  {
  {
#line 1019
  tmp = (*lt_dlmalloc)(size);
#line 1019
  mem = tmp;
  }
#line 1020
  if (size) {
#line 1020
    if (! mem) {
#line 1021
      if (lt_dlmutex_seterror_func) {
        {
#line 1021
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[11]);
        }
      } else {
#line 1021
        lt_dllast_error = lt_dlerror_strings[11];
      }
    }
  }
#line 1022
  return (mem);
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static void *lt_erealloc(void *addr , size_t size ) 
{ 
  void *mem ;
  void *tmp ;

  {
  {
#line 1030
  tmp = (*lt_dlrealloc)(addr, size);
#line 1030
  mem = tmp;
  }
#line 1031
  if (size) {
#line 1031
    if (! mem) {
#line 1032
      if (lt_dlmutex_seterror_func) {
        {
#line 1032
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[11]);
        }
      } else {
#line 1032
        lt_dllast_error = lt_dlerror_strings[11];
      }
    }
  }
#line 1033
  return (mem);
}
}
#line 1036 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char *lt_estrdup(char const   *str ) 
{ 
  char *copy ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1040
  tmp = rpl_strdup(str);
#line 1040
  copy = tmp;
  }
#line 1041
  if (str) {
#line 1041
    if (*(str + 0)) {
      {
#line 1041
      tmp___0 = strlen(str);
#line 1041
      tmp___1 = tmp___0;
      }
    } else {
#line 1041
      tmp___1 = (size_t )0;
    }
  } else {
#line 1041
    tmp___1 = (size_t )0;
  }
#line 1041
  if (tmp___1) {
#line 1041
    if (! copy) {
#line 1042
      if (lt_dlmutex_seterror_func) {
        {
#line 1042
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[11]);
        }
      } else {
#line 1042
        lt_dllast_error = lt_dlerror_strings[11];
      }
    }
  }
#line 1043
  return (copy);
}
}
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 1105 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_module sys_dl_open(lt_user_data loader_data , char const   *filename ) 
{ 
  lt_module module ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1110
  tmp = dlopen(filename, 257);
#line 1110
  module = tmp;
  }
#line 1112
  if (! module) {
#line 1114
    if (lt_dlmutex_seterror_func) {
      {
#line 1114
      tmp___0 = dlerror();
#line 1114
      (*lt_dlmutex_seterror_func)((char const   *)tmp___0);
      }
    } else {
      {
#line 1114
      tmp___1 = dlerror();
#line 1114
      lt_dllast_error = (char const   *)tmp___1;
      }
    }
  }
#line 1117
  return (module);
}
}
#line 1120 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int sys_dl_close(lt_user_data loader_data , lt_module module ) 
{ 
  int errors ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1125
  errors = 0;
#line 1127
  tmp___1 = dlclose(module);
  }
#line 1127
  if (tmp___1 != 0) {
#line 1129
    if (lt_dlmutex_seterror_func) {
      {
#line 1129
      tmp = dlerror();
#line 1129
      (*lt_dlmutex_seterror_func)((char const   *)tmp);
      }
    } else {
      {
#line 1129
      tmp___0 = dlerror();
#line 1129
      lt_dllast_error = (char const   *)tmp___0;
      }
    }
#line 1130
    errors ++;
  }
#line 1133
  return (errors);
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static void *sys_dl_sym(lt_user_data loader_data , lt_module module , char const   *symbol ) 
{ 
  void *address ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1142
  tmp = dlsym((void */* __restrict  */)module, (char const   */* __restrict  */)symbol);
#line 1142
  address = tmp;
  }
#line 1144
  if (! address) {
#line 1146
    if (lt_dlmutex_seterror_func) {
      {
#line 1146
      tmp___0 = dlerror();
#line 1146
      (*lt_dlmutex_seterror_func)((char const   *)tmp___0);
      }
    } else {
      {
#line 1146
      tmp___1 = dlerror();
#line 1146
      lt_dllast_error = (char const   *)tmp___1;
      }
    }
  }
#line 1149
  return (address);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static struct lt_user_dlloader sys_dl  =    {(char const   *)0, & sys_dl_open, & sys_dl_close, & sys_dl_sym, (lt_dlloader_exit *)0,
    (lt_user_data )0};
#line 1958 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlsymlist const   *default_preloaded_symbols  =    (lt_dlsymlist const   *)0;
#line 1959 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlsymlists_t *preloaded_symbols  =    (lt_dlsymlists_t *)0;
#line 1961 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int presym_init(lt_user_data loader_data ) 
{ 
  int errors ;

  {
#line 1965
  errors = 0;
#line 1967
  if (lt_dlmutex_lock_func) {
    {
#line 1967
    (*lt_dlmutex_lock_func)();
    }
  }
#line 1969
  preloaded_symbols = (lt_dlsymlists_t *)0;
#line 1970
  if (default_preloaded_symbols) {
    {
#line 1972
    errors = lt_dlpreload(default_preloaded_symbols);
    }
  }
#line 1975
  if (lt_dlmutex_unlock_func) {
    {
#line 1975
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 1977
  return (errors);
}
}
#line 1980 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int presym_free_symlists(void) 
{ 
  lt_dlsymlists_t *lists ;
  lt_dlsymlists_t *tmp ;

  {
#line 1985
  if (lt_dlmutex_lock_func) {
    {
#line 1985
    (*lt_dlmutex_lock_func)();
    }
  }
#line 1987
  lists = preloaded_symbols;
  {
#line 1988
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1988
    if (! lists) {
#line 1988
      goto while_break;
    }
#line 1990
    tmp = lists;
#line 1992
    lists = lists->next;
#line 1993
    if (tmp) {
      {
#line 1993
      (*lt_dlfree)((void *)tmp);
#line 1993
      tmp = (lt_dlsymlists_t *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1995
  preloaded_symbols = (lt_dlsymlists_t *)0;
#line 1997
  if (lt_dlmutex_unlock_func) {
    {
#line 1997
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 1999
  return (0);
}
}
#line 2002 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int presym_exit(lt_user_data loader_data ) 
{ 


  {
  {
#line 2006
  presym_free_symlists();
  }
#line 2007
  return (0);
}
}
#line 2010 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int presym_add_symlist(lt_dlsymlist const   *preloaded ) 
{ 
  lt_dlsymlists_t *tmp ;
  lt_dlsymlists_t *lists ;
  int errors ;
  void *tmp___0 ;

  {
#line 2016
  errors = 0;
#line 2018
  if (lt_dlmutex_lock_func) {
    {
#line 2018
    (*lt_dlmutex_lock_func)();
    }
  }
#line 2020
  lists = preloaded_symbols;
  {
#line 2021
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2021
    if (! lists) {
#line 2021
      goto while_break;
    }
#line 2023
    if ((unsigned long )lists->syms == (unsigned long )preloaded) {
#line 2025
      goto done;
    }
#line 2027
    lists = lists->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2030
  tmp___0 = lt_emalloc(sizeof(lt_dlsymlists_t ));
#line 2030
  tmp = (lt_dlsymlists_t *)tmp___0;
  }
#line 2031
  if (tmp) {
    {
#line 2033
    memset((void *)tmp, 0, sizeof(lt_dlsymlists_t ));
#line 2034
    tmp->syms = preloaded;
#line 2035
    tmp->next = preloaded_symbols;
#line 2036
    preloaded_symbols = tmp;
    }
  } else {
#line 2040
    errors ++;
  }
  done: 
#line 2044
  if (lt_dlmutex_unlock_func) {
    {
#line 2044
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 2045
  return (errors);
}
}
#line 2048 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_module presym_open(lt_user_data loader_data , char const   *filename ) 
{ 
  lt_dlsymlists_t *lists ;
  lt_module module ;
  lt_dlsymlist const   *syms ;
  int tmp ;

  {
#line 2054
  module = (lt_module )0;
#line 2056
  if (lt_dlmutex_lock_func) {
    {
#line 2056
    (*lt_dlmutex_lock_func)();
    }
  }
#line 2057
  lists = preloaded_symbols;
#line 2059
  if (! lists) {
#line 2061
    if (lt_dlmutex_seterror_func) {
      {
#line 2061
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[7]);
      }
    } else {
#line 2061
      lt_dllast_error = lt_dlerror_strings[7];
    }
#line 2062
    goto done;
  }
#line 2069
  if (! filename) {
#line 2071
    filename = "@PROGRAM@";
  }
  {
#line 2074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2074
    if (! lists) {
#line 2074
      goto while_break;
    }
#line 2076
    syms = lists->syms;
    {
#line 2078
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2078
      if (! syms->name) {
#line 2078
        goto while_break___0;
      }
#line 2080
      if (! syms->address) {
        {
#line 2080
        tmp = strcmp((char const   *)syms->name, filename);
        }
#line 2080
        if (tmp == 0) {
#line 2082
          module = (lt_module )syms;
#line 2083
          goto done;
        }
      }
#line 2085
      syms ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2088
    lists = lists->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2091
  if (lt_dlmutex_seterror_func) {
    {
#line 2091
    (*lt_dlmutex_seterror_func)(lt_dlerror_strings[5]);
    }
  } else {
#line 2091
    lt_dllast_error = lt_dlerror_strings[5];
  }
  done: 
#line 2094
  if (lt_dlmutex_unlock_func) {
    {
#line 2094
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 2095
  return (module);
}
}
#line 2098 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int presym_close(lt_user_data loader_data , lt_module module ) 
{ 


  {
#line 2104
  module = (lt_module )0;
#line 2105
  return (0);
}
}
#line 2108 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static void *presym_sym(lt_user_data loader_data , lt_module module , char const   *symbol ) 
{ 
  lt_dlsymlist *syms ;
  int tmp ;

  {
#line 2114
  syms = (lt_dlsymlist *)module;
#line 2116
  syms ++;
  {
#line 2117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2117
    if (! syms->address) {
#line 2117
      goto while_break;
    }
    {
#line 2119
    tmp = strcmp(syms->name, symbol);
    }
#line 2119
    if (tmp == 0) {
#line 2121
      return (syms->address);
    }
#line 2124
    syms ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2127
  if (lt_dlmutex_seterror_func) {
    {
#line 2127
    (*lt_dlmutex_seterror_func)(lt_dlerror_strings[10]);
    }
  } else {
#line 2127
    lt_dllast_error = lt_dlerror_strings[10];
  }
#line 2129
  return ((void *)0);
}
}
#line 2132 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static struct lt_user_dlloader presym  =    {(char const   *)0, & presym_open, & presym_close, & presym_sym, & presym_exit,
    (lt_user_data )0};
#line 2147
static int foreach_dirinpath(char const   *search_path , char const   *base_name ,
                             foreach_callback_func *func , void *data1 , void *data2 ) ;
#line 2152
static int find_file_callback(char *filename , void *data1 , void *data2 ) ;
#line 2154
static int find_handle_callback(char *filename , void *data , void *ignored ) ;
#line 2156
static int foreachfile_callback(char *dirname , void *data1 , void *data2 ) ;
#line 2160
static int canonicalize_path(char const   *path , char **pcanonical ) ;
#line 2162
static int argzize_path(char const   *path , char **pargz , size_t *pargz_len ) ;
#line 2165
static FILE *find_file(char const   *search_path , char const   *base_name , char **pdir ) ;
#line 2168
static lt_dlhandle *find_handle(char const   *search_path , char const   *base_name ,
                                lt_dlhandle *handle ) ;
#line 2171
static int find_module(lt_dlhandle *handle , char const   *dir , char const   *libdir ,
                       char const   *dlname , char const   *old_name , int installed ) ;
#line 2177
static int free_vars(char *dlname , char *oldname , char *libdir , char *deplibs ) ;
#line 2179
static int load_deplibs(lt_dlhandle handle , char *deplibs ) ;
#line 2181
static int trim(char **dest , char const   *str ) ;
#line 2183
static int try_dlopen(lt_dlhandle *phandle , char const   *filename ) ;
#line 2185
static int tryall_dlopen(lt_dlhandle *handle , char const   *filename , char const   *useloader ) ;
#line 2188
static int unload_deplibs(lt_dlhandle handle ) ;
#line 2189
static int lt_argz_insert(char **pargz , size_t *pargz_len , char *before , char const   *entry ) ;
#line 2193
static int lt_argz_insertinorder(char **pargz , size_t *pargz_len , char const   *entry ) ;
#line 2196
static int lt_argz_insertdir(char **pargz , size_t *pargz_len , char const   *dirnam ,
                             struct dirent *dp ) ;
#line 2200
static int lt_dlpath_insertdir(char **ppath , char *before , char const   *dir ) ;
#line 2203
static int list_files_by_dir(char const   *dirnam , char **pargz , size_t *pargz_len ) ;
#line 2206
static int file_not_found(void) ;
#line 2208 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static char *user_search_path  =    (char *)0;
#line 2209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlloader *loaders  =    (lt_dlloader *)0;
#line 2210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlhandle handles  =    (lt_dlhandle )0;
#line 2211 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int initialized  =    0;
#line 2214 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlinit(void) 
{ 
  int errors ;
  lt_dlloader *tmp ;
  int tmp___0 ;
  lt_dlloader *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2217
  errors = 0;
#line 2219
  if (lt_dlmutex_lock_func) {
    {
#line 2219
    (*lt_dlmutex_lock_func)();
    }
  }
#line 2222
  initialized ++;
#line 2222
  if (initialized == 1) {
    {
#line 2224
    handles = (lt_dlhandle )0;
#line 2225
    user_search_path = (char *)0;
#line 2228
    tmp = lt_dlloader_next((lt_dlloader *)0);
#line 2228
    tmp___0 = lt_dlloader_add(tmp, (struct lt_user_dlloader  const  *)(& sys_dl),
                              "dlopen");
#line 2228
    errors += tmp___0;
#line 2246
    tmp___1 = lt_dlloader_next((lt_dlloader *)0);
#line 2246
    tmp___2 = lt_dlloader_add(tmp___1, (struct lt_user_dlloader  const  *)(& presym),
                              "dlpreload");
#line 2246
    errors += tmp___2;
#line 2248
    tmp___3 = presym_init(presym.dlloader_data);
    }
#line 2248
    if (tmp___3) {
#line 2250
      if (lt_dlmutex_seterror_func) {
        {
#line 2250
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[3]);
        }
      } else {
#line 2250
        lt_dllast_error = lt_dlerror_strings[3];
      }
#line 2251
      errors ++;
    } else
#line 2253
    if (errors != 0) {
#line 2255
      if (lt_dlmutex_seterror_func) {
        {
#line 2255
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[1]);
        }
      } else {
#line 2255
        lt_dllast_error = lt_dlerror_strings[1];
      }
#line 2256
      errors ++;
    }
  }
#line 2260
  if (lt_dlmutex_unlock_func) {
    {
#line 2260
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 2262
  return (errors);
}
}
#line 2265 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlpreload(lt_dlsymlist const   *preloaded ) 
{ 
  int errors ;

  {
#line 2269
  errors = 0;
#line 2271
  if (preloaded) {
    {
#line 2273
    errors = presym_add_symlist(preloaded);
    }
  } else {
    {
#line 2277
    presym_free_symlists();
    }
#line 2279
    if (lt_dlmutex_lock_func) {
      {
#line 2279
      (*lt_dlmutex_lock_func)();
      }
    }
#line 2280
    if (default_preloaded_symbols) {
      {
#line 2282
      errors = lt_dlpreload(default_preloaded_symbols);
      }
    }
#line 2284
    if (lt_dlmutex_unlock_func) {
      {
#line 2284
      (*lt_dlmutex_unlock_func)();
      }
    }
  }
#line 2287
  return (errors);
}
}
#line 2290 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlpreload_default(lt_dlsymlist const   *preloaded ) 
{ 


  {
#line 2294
  if (lt_dlmutex_lock_func) {
    {
#line 2294
    (*lt_dlmutex_lock_func)();
    }
  }
#line 2295
  default_preloaded_symbols = preloaded;
#line 2296
  if (lt_dlmutex_unlock_func) {
    {
#line 2296
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 2297
  return (0);
}
}
#line 2300 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlexit(void) 
{ 
  lt_dlloader *loader ;
  int errors ;
  int level ;
  lt_dlhandle cur ;
  int saw_nonresident ;
  lt_dlhandle tmp ;
  int tmp___0 ;
  lt_dlloader *next ;
  lt_user_data data ;
  int tmp___1 ;

  {
#line 2305
  errors = 0;
#line 2307
  if (lt_dlmutex_lock_func) {
    {
#line 2307
    (*lt_dlmutex_lock_func)();
    }
  }
#line 2308
  loader = loaders;
#line 2310
  if (! initialized) {
#line 2312
    if (lt_dlmutex_seterror_func) {
      {
#line 2312
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[15]);
      }
    } else {
#line 2312
      lt_dllast_error = lt_dlerror_strings[15];
    }
#line 2313
    errors ++;
#line 2314
    goto done;
  }
#line 2318
  initialized --;
#line 2318
  if (initialized == 0) {
    {
#line 2322
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2322
      if (handles) {
#line 2322
        if (! ((handles->flags & 1) == 1)) {
#line 2322
          goto while_break;
        }
      } else {
#line 2322
        goto while_break;
      }
#line 2324
      handles = handles->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 2328
    level = 1;
    {
#line 2328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2328
      if (! handles) {
#line 2328
        goto while_break___0;
      }
#line 2330
      cur = handles;
#line 2331
      saw_nonresident = 0;
      {
#line 2333
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2333
        if (! cur) {
#line 2333
          goto while_break___1;
        }
#line 2335
        tmp = cur;
#line 2336
        cur = cur->next;
#line 2337
        if (! ((tmp->flags & 1) == 1)) {
#line 2338
          saw_nonresident = 1;
        }
#line 2339
        if (! ((tmp->flags & 1) == 1)) {
#line 2339
          if (tmp->info.ref_count <= level) {
            {
#line 2341
            tmp___0 = lt_dlclose(tmp);
            }
#line 2341
            if (tmp___0) {
#line 2343
              errors ++;
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2348
      if (! saw_nonresident) {
#line 2349
        goto while_break___0;
      }
#line 2328
      level ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2353
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2353
      if (! loader) {
#line 2353
        goto while_break___2;
      }
#line 2355
      next = loader->next;
#line 2356
      data = loader->dlloader_data;
#line 2357
      if (loader->dlloader_exit) {
        {
#line 2357
        tmp___1 = (*(loader->dlloader_exit))(data);
        }
#line 2357
        if (tmp___1) {
#line 2359
          errors ++;
        }
      }
#line 2362
      if ((unsigned long )loader != (unsigned long )next) {
#line 2362
        if (loader) {
          {
#line 2362
          (*lt_dlfree)((void *)loader);
          }
        }
#line 2362
        loader = next;
#line 2362
        next = (lt_dlloader *)0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2364
    loaders = (lt_dlloader *)0;
#line 2366
    if (user_search_path) {
      {
#line 2366
      (*lt_dlfree)((void *)user_search_path);
#line 2366
      user_search_path = (char *)((void *)0);
      }
    }
  }
  done: 
#line 2370
  if (lt_dlmutex_unlock_func) {
    {
#line 2370
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 2371
  return (errors);
}
}
#line 2374 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int tryall_dlopen(lt_dlhandle *handle , char const   *filename , char const   *useloader ) 
{ 
  lt_dlhandle cur ;
  lt_dlloader *loader ;
  char const   *saved_error ;
  int errors ;
  int tmp ;
  int tmp___0 ;
  lt_user_data data ;

  {
#line 2383
  errors = 0;
#line 2385
  if (lt_dlmutex_seterror_func) {
    {
#line 2385
    saved_error = (*lt_dlmutex_geterror_func)();
    }
  } else {
#line 2385
    saved_error = lt_dllast_error;
  }
#line 2386
  if (lt_dlmutex_lock_func) {
    {
#line 2386
    (*lt_dlmutex_lock_func)();
    }
  }
#line 2388
  cur = handles;
#line 2389
  loader = loaders;
  {
#line 2392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2392
    if (! cur) {
#line 2392
      goto while_break;
    }
#line 2395
    if (! cur->info.filename) {
#line 2395
      if (! filename) {
#line 2397
        goto while_break;
      }
    }
#line 2400
    if (cur->info.filename) {
#line 2400
      if (filename) {
        {
#line 2400
        tmp = strcmp((char const   *)cur->info.filename, filename);
        }
#line 2400
        if (tmp == 0) {
#line 2403
          goto while_break;
        }
      }
    }
#line 2406
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2409
  if (cur) {
#line 2411
    (cur->info.ref_count) ++;
#line 2412
    *handle = cur;
#line 2413
    goto done;
  }
#line 2416
  cur = *handle;
#line 2417
  if (filename) {
    {
#line 2431
    cur->info.filename = lt_estrdup(filename);
    }
#line 2432
    if (! cur->info.filename) {
#line 2434
      errors ++;
#line 2435
      goto done;
    }
  } else {
#line 2440
    cur->info.filename = (char *)0;
  }
  {
#line 2443
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2443
    if (! loader) {
#line 2443
      goto while_break___0;
    }
#line 2445
    if (useloader) {
      {
#line 2445
      tmp___0 = strcmp(loader->loader_name, useloader);
      }
#line 2445
      if (tmp___0) {
#line 2447
        loader = loader->next;
#line 2448
        goto while_continue___0;
      }
    }
    {
#line 2450
    data = loader->dlloader_data;
#line 2452
    cur->module = (*(loader->module_open))(data, filename);
    }
#line 2454
    if ((unsigned long )cur->module != (unsigned long )((lt_module )0)) {
#line 2456
      goto while_break___0;
    }
#line 2458
    loader = loader->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2461
  if (! loader) {
#line 2463
    if (cur->info.filename) {
      {
#line 2463
      (*lt_dlfree)((void *)cur->info.filename);
#line 2463
      cur->info.filename = (char *)((void *)0);
      }
    }
#line 2464
    errors ++;
#line 2465
    goto done;
  }
#line 2468
  cur->loader = loader;
#line 2469
  if (lt_dlmutex_seterror_func) {
    {
#line 2469
    (*lt_dlmutex_seterror_func)(saved_error);
    }
  } else {
#line 2469
    lt_dllast_error = saved_error;
  }
  done: 
#line 2472
  if (lt_dlmutex_unlock_func) {
    {
#line 2472
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 2474
  return (errors);
}
}
#line 2477 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int tryall_dlopen_module(lt_dlhandle *handle , char const   *prefix , char const   *dirname ,
                                char const   *dlname ) 
{ 
  int error ;
  char *filename ;
  size_t filename_len ;
  size_t dirname_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2484
  error = 0;
#line 2485
  filename = (char *)0;
#line 2486
  filename_len = (size_t )0;
#line 2487
  if (dirname) {
#line 2487
    if (*(dirname + 0)) {
      {
#line 2487
      tmp = strlen(dirname);
#line 2487
      tmp___0 = tmp;
      }
    } else {
#line 2487
      tmp___0 = (size_t )0;
    }
  } else {
#line 2487
    tmp___0 = (size_t )0;
  }
#line 2487
  dirname_len = tmp___0;
#line 2489
  if (! handle) {
    {
#line 2489
    __assert_fail("handle", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2489U, "tryall_dlopen_module");
    }
  }
#line 2490
  if (! dirname) {
    {
#line 2490
    __assert_fail("dirname", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2490U, "tryall_dlopen_module");
    }
  }
#line 2491
  if (! dlname) {
    {
#line 2491
    __assert_fail("dlname", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2491U, "tryall_dlopen_module");
    }
  }
#line 2498
  if (dirname_len > 0UL) {
#line 2499
    if ((int const   )*(dirname + (dirname_len - 1UL)) == 47) {
#line 2500
      dirname_len --;
    }
  }
#line 2501
  if (dlname) {
#line 2501
    if (*(dlname + 0)) {
      {
#line 2501
      tmp___1 = strlen(dlname);
#line 2501
      tmp___2 = tmp___1;
      }
    } else {
#line 2501
      tmp___2 = (size_t )0;
    }
  } else {
#line 2501
    tmp___2 = (size_t )0;
  }
  {
#line 2501
  filename_len = (dirname_len + 1UL) + tmp___2;
#line 2505
  tmp___3 = lt_emalloc((((dirname_len + 1UL) + filename_len) + 1UL) * sizeof(char ));
#line 2505
  filename = (char *)tmp___3;
  }
#line 2506
  if (! filename) {
#line 2507
    return (1);
  }
  {
#line 2509
  sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%.*s/%s",
          (int )dirname_len, dirname, dlname);
  }
#line 2514
  if (prefix) {
    {
#line 2516
    tmp___4 = tryall_dlopen_module(handle, (char const   *)0, prefix, (char const   *)filename);
#line 2516
    error += tmp___4;
    }
  } else {
    {
#line 2519
    tmp___5 = tryall_dlopen(handle, (char const   *)filename, (char const   *)((void *)0));
    }
#line 2519
    if (tmp___5 != 0) {
#line 2521
      error ++;
    }
  }
#line 2524
  if (filename) {
    {
#line 2524
    (*lt_dlfree)((void *)filename);
#line 2524
    filename = (char *)((void *)0);
    }
  }
#line 2525
  return (error);
}
}
#line 2528 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int find_module(lt_dlhandle *handle , char const   *dir , char const   *libdir ,
                       char const   *dlname , char const   *old_name , int installed ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2540
  if (old_name) {
    {
#line 2540
    tmp = tryall_dlopen(handle, old_name, "dlpreload");
    }
#line 2540
    if (tmp == 0) {
#line 2542
      return (0);
    }
  }
#line 2546
  if (dlname) {
#line 2549
    if (installed) {
#line 2549
      if (libdir) {
        {
#line 2551
        tmp___0 = tryall_dlopen_module(handle, (char const   *)0, libdir, dlname);
        }
#line 2551
        if (tmp___0 == 0) {
#line 2553
          return (0);
        }
      }
    }
#line 2557
    if (! installed) {
      {
#line 2559
      tmp___1 = tryall_dlopen_module(handle, dir, objdir, dlname);
      }
#line 2559
      if (tmp___1 == 0) {
#line 2560
        return (0);
      }
    }
#line 2565
    if (dir) {
      {
#line 2565
      tmp___2 = tryall_dlopen_module(handle, (char const   *)0, dir, dlname);
      }
#line 2565
      if (tmp___2 == 0) {
#line 2567
        return (0);
      }
    }
  }
#line 2571
  return (1);
}
}
#line 2575 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int canonicalize_path(char const   *path , char **pcanonical ) 
{ 
  char *canonical ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t dest ;
  size_t src ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 2580
  canonical = (char *)0;
#line 2582
  if (path) {
#line 2582
    if (! *path) {
      {
#line 2582
      __assert_fail("path && *path", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    2582U, "canonicalize_path");
      }
    }
  } else {
    {
#line 2582
    __assert_fail("path && *path", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2582U, "canonicalize_path");
    }
  }
#line 2583
  if (! pcanonical) {
    {
#line 2583
    __assert_fail("pcanonical", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2583U, "canonicalize_path");
    }
  }
#line 2585
  if (path) {
#line 2585
    if (*(path + 0)) {
      {
#line 2585
      tmp = strlen(path);
#line 2585
      tmp___0 = tmp;
      }
    } else {
#line 2585
      tmp___0 = (size_t )0;
    }
  } else {
#line 2585
    tmp___0 = (size_t )0;
  }
  {
#line 2585
  tmp___1 = lt_emalloc((1UL + tmp___0) * sizeof(char ));
#line 2585
  canonical = (char *)tmp___1;
  }
#line 2586
  if (! canonical) {
#line 2587
    return (1);
  }
#line 2590
  dest = (size_t )0;
#line 2592
  src = (size_t )0;
  {
#line 2592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2592
    if (! ((int const   )*(path + src) != 0)) {
#line 2592
      goto while_break;
    }
#line 2597
    if ((int const   )*(path + src) == 58) {
#line 2599
      if (dest == 0UL) {
#line 2602
        goto __Cont;
      } else
#line 2599
      if ((int const   )*(path + (1UL + src)) == 58) {
#line 2602
        goto __Cont;
      } else
#line 2599
      if ((int const   )*(path + (1UL + src)) == 0) {
#line 2602
        goto __Cont;
      }
    }
#line 2606
    if ((int const   )*(path + src) != 47) {
#line 2612
      tmp___2 = dest;
#line 2612
      dest ++;
#line 2612
      *(canonical + tmp___2) = (char )*(path + src);
    } else
#line 2617
    if ((int const   )*(path + (1UL + src)) != 58) {
#line 2617
      if ((int const   )*(path + (1UL + src)) != 0) {
#line 2617
        if ((int const   )*(path + (1UL + src)) != 47) {
#line 2624
          tmp___3 = dest;
#line 2624
          dest ++;
#line 2624
          *(canonical + tmp___3) = (char )'/';
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2592
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2629
  *(canonical + dest) = (char )'\000';
#line 2633
  *pcanonical = canonical;
#line 2635
  return (0);
}
}
#line 2638 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int argzize_path(char const   *path , char **pargz , size_t *pargz_len ) 
{ 
  error_t error ;

  {
#line 2646
  if (! path) {
    {
#line 2646
    __assert_fail("path", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2646U, "argzize_path");
    }
  }
#line 2647
  if (! pargz) {
    {
#line 2647
    __assert_fail("pargz", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2647U, "argzize_path");
    }
  }
#line 2648
  if (! pargz_len) {
    {
#line 2648
    __assert_fail("pargz_len", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2648U, "argzize_path");
    }
  }
  {
#line 2650
  error = argz_create_sep((char const   */* __restrict  */)path, ':', (char **/* __restrict  */)pargz,
                          (size_t */* __restrict  */)pargz_len);
  }
#line 2650
  if (error) {
    {
#line 2654
    if (error == 12) {
#line 2654
      goto case_12;
    }
#line 2657
    goto switch_default;
    case_12: /* CIL Label */ 
#line 2655
    if (lt_dlmutex_seterror_func) {
      {
#line 2655
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[11]);
      }
    } else {
#line 2655
      lt_dllast_error = lt_dlerror_strings[11];
    }
#line 2656
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2658
    if (lt_dlmutex_seterror_func) {
      {
#line 2658
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[0]);
      }
    } else {
#line 2658
      lt_dllast_error = lt_dlerror_strings[0];
    }
#line 2659
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2662
    return (1);
  }
#line 2665
  return (0);
}
}
#line 2672 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int foreach_dirinpath(char const   *search_path , char const   *base_name ,
                             foreach_callback_func *func , void *data1 , void *data2 ) 
{ 
  int result ;
  int filenamesize ;
  size_t lenbase ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t argz_len ;
  char *argz ;
  char *filename ;
  char *canonical ;
  int tmp___1 ;
  int tmp___2 ;
  char *dir_name ;
  size_t lendir ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;

  {
#line 2680
  result = 0;
#line 2681
  filenamesize = 0;
#line 2682
  if (base_name) {
#line 2682
    if (*(base_name + 0)) {
      {
#line 2682
      tmp = strlen(base_name);
#line 2682
      tmp___0 = tmp;
      }
    } else {
#line 2682
      tmp___0 = (size_t )0;
    }
  } else {
#line 2682
    tmp___0 = (size_t )0;
  }
#line 2682
  lenbase = tmp___0;
#line 2683
  argz_len = (size_t )0;
#line 2684
  argz = (char *)0;
#line 2685
  filename = (char *)0;
#line 2686
  canonical = (char *)0;
#line 2688
  if (lt_dlmutex_lock_func) {
    {
#line 2688
    (*lt_dlmutex_lock_func)();
    }
  }
#line 2690
  if (! search_path) {
#line 2690
    goto _L;
  } else
#line 2690
  if (! *search_path) {
    _L: /* CIL Label */ 
#line 2692
    if (lt_dlmutex_seterror_func) {
      {
#line 2692
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[5]);
      }
    } else {
#line 2692
      lt_dllast_error = lt_dlerror_strings[5];
    }
#line 2693
    goto cleanup;
  }
  {
#line 2696
  tmp___1 = canonicalize_path(search_path, & canonical);
  }
#line 2696
  if (tmp___1 != 0) {
#line 2697
    goto cleanup;
  }
  {
#line 2699
  tmp___2 = argzize_path((char const   *)canonical, & argz, & argz_len);
  }
#line 2699
  if (tmp___2 != 0) {
#line 2700
    goto cleanup;
  }
#line 2703
  dir_name = (char *)0;
  {
#line 2704
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2704
    dir_name = argz_next((char const   */* __restrict  */)argz, argz_len, (char const   */* __restrict  */)dir_name);
    }
#line 2704
    if (! dir_name) {
#line 2704
      goto while_break;
    }
#line 2706
    if (dir_name) {
#line 2706
      if (*(dir_name + 0)) {
        {
#line 2706
        tmp___3 = strlen((char const   *)dir_name);
#line 2706
        tmp___4 = tmp___3;
        }
      } else {
#line 2706
        tmp___4 = (size_t )0;
      }
    } else {
#line 2706
      tmp___4 = (size_t )0;
    }
#line 2706
    lendir = tmp___4;
#line 2708
    if ((lendir + 1UL) + lenbase >= (size_t )filenamesize) {
#line 2710
      if (filename) {
        {
#line 2710
        (*lt_dlfree)((void *)filename);
#line 2710
        filename = (char *)((void *)0);
        }
      }
      {
#line 2711
      filenamesize = (int )(((lendir + 1UL) + lenbase) + 1UL);
#line 2712
      tmp___5 = lt_emalloc((unsigned long )filenamesize * sizeof(char ));
#line 2712
      filename = (char *)tmp___5;
      }
#line 2713
      if (! filename) {
#line 2714
        goto cleanup;
      }
    }
#line 2717
    if (! ((size_t )filenamesize > lendir)) {
      {
#line 2717
      __assert_fail("filenamesize > lendir", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    2717U, "foreach_dirinpath");
      }
    }
    {
#line 2718
    strcpy((char */* __restrict  */)filename, (char const   */* __restrict  */)dir_name);
    }
#line 2720
    if (base_name) {
#line 2720
      if (*base_name) {
#line 2722
        if ((int )*(filename + (lendir - 1UL)) != 47) {
#line 2723
          tmp___6 = lendir;
#line 2723
          lendir ++;
#line 2723
          *(filename + tmp___6) = (char )'/';
        }
        {
#line 2724
        strcpy((char */* __restrict  */)(filename + lendir), (char const   */* __restrict  */)base_name);
        }
      }
    }
    {
#line 2727
    result = (*func)(filename, data1, data2);
    }
#line 2727
    if (result) {
#line 2729
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 2735
  if (argz) {
    {
#line 2735
    (*lt_dlfree)((void *)argz);
#line 2735
    argz = (char *)((void *)0);
    }
  }
#line 2736
  if (canonical) {
    {
#line 2736
    (*lt_dlfree)((void *)canonical);
#line 2736
    canonical = (char *)((void *)0);
    }
  }
#line 2737
  if (filename) {
    {
#line 2737
    (*lt_dlfree)((void *)filename);
#line 2737
    filename = (char *)((void *)0);
    }
  }
#line 2739
  if (lt_dlmutex_unlock_func) {
    {
#line 2739
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 2741
  return (result);
}
}
#line 2747 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int find_file_callback(char *filename , void *data1 , void *data2 ) 
{ 
  char **pdir ;
  FILE **pfile ;
  int is_done ;
  char *dirend ;
  char *tmp ;
  FILE *tmp___0 ;

  {
#line 2753
  pdir = (char **)data1;
#line 2754
  pfile = (FILE **)data2;
#line 2755
  is_done = 0;
#line 2757
  if (filename) {
#line 2757
    if (! *filename) {
      {
#line 2757
      __assert_fail("filename && *filename", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    2757U, "find_file_callback");
      }
    }
  } else {
    {
#line 2757
    __assert_fail("filename && *filename", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2757U, "find_file_callback");
    }
  }
#line 2758
  if (! pdir) {
    {
#line 2758
    __assert_fail("pdir", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2758U, "find_file_callback");
    }
  }
#line 2759
  if (! pfile) {
    {
#line 2759
    __assert_fail("pfile", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  2759U, "find_file_callback");
    }
  }
  {
#line 2761
  tmp___0 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 2761
  *pfile = tmp___0;
  }
#line 2761
  if (tmp___0) {
    {
#line 2763
    tmp = strrchr((char const   *)filename, '/');
#line 2763
    dirend = tmp;
    }
#line 2765
    if ((unsigned long )dirend > (unsigned long )filename) {
#line 2766
      *dirend = (char )'\000';
    }
#line 2768
    if (*pdir) {
      {
#line 2768
      (*lt_dlfree)((void *)*pdir);
#line 2768
      *pdir = (char *)((void *)0);
      }
    }
    {
#line 2769
    *pdir = lt_estrdup((char const   *)filename);
    }
#line 2770
    if ((unsigned long )*pdir == (unsigned long )((char *)0)) {
#line 2770
      is_done = -1;
    } else {
#line 2770
      is_done = 1;
    }
  }
#line 2773
  return (is_done);
}
}
#line 2776 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static FILE *find_file(char const   *search_path , char const   *base_name , char **pdir ) 
{ 
  FILE *file ;

  {
  {
#line 2782
  file = (FILE *)0;
#line 2784
  foreach_dirinpath(search_path, base_name, & find_file_callback, (void *)pdir, (void *)(& file));
  }
#line 2786
  return (file);
}
}
#line 2789 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int find_handle_callback(char *filename , void *data , void *ignored ) 
{ 
  lt_dlhandle *handle ;
  int notfound ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2795
  handle = (lt_dlhandle *)data;
#line 2796
  tmp = access((char const   *)filename, 4);
#line 2796
  notfound = tmp;
  }
#line 2799
  if (notfound) {
#line 2800
    return (0);
  }
  {
#line 2804
  tmp___0 = tryall_dlopen(handle, (char const   *)filename, (char const   *)((void *)0));
  }
#line 2804
  if (tmp___0 != 0) {
#line 2805
    *handle = (lt_dlhandle )0;
  }
#line 2807
  return (1);
}
}
#line 2812 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlhandle *find_handle(char const   *search_path , char const   *base_name ,
                                lt_dlhandle *handle ) 
{ 
  int tmp ;

  {
#line 2818
  if (! search_path) {
#line 2819
    return ((lt_dlhandle *)0);
  }
  {
#line 2821
  tmp = foreach_dirinpath(search_path, base_name, & find_handle_callback, (void *)handle,
                          (void *)0);
  }
#line 2821
  if (! tmp) {
#line 2823
    return ((lt_dlhandle *)0);
  }
#line 2825
  return (handle);
}
}
#line 2828 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int load_deplibs(lt_dlhandle handle , char *deplibs ) 
{ 
  int errors ;

  {
#line 2839
  errors = 0;
#line 2841
  handle->depcount = 0;
#line 2988
  return (errors);
}
}
#line 2991 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int unload_deplibs(lt_dlhandle handle ) 
{ 
  int i ;
  int errors ;
  int tmp ;

  {
#line 2996
  errors = 0;
#line 2998
  if (handle->depcount) {
#line 3000
    i = 0;
    {
#line 3000
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3000
      if (! (i < handle->depcount)) {
#line 3000
        goto while_break;
      }
#line 3002
      if (! (((*(handle->deplibs + i))->flags & 1) == 1)) {
        {
#line 3004
        tmp = lt_dlclose(*(handle->deplibs + i));
#line 3004
        errors += tmp;
        }
      }
#line 3000
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3009
  return (errors);
}
}
#line 3012 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int trim(char **dest , char const   *str ) 
{ 
  char const   *end ;
  char *tmp ;
  size_t len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3019
  tmp = strrchr(str, '\'');
#line 3019
  end = (char const   *)tmp;
  }
#line 3020
  if (str) {
#line 3020
    if (*(str + 0)) {
      {
#line 3020
      tmp___0 = strlen(str);
#line 3020
      tmp___1 = tmp___0;
      }
    } else {
#line 3020
      tmp___1 = (size_t )0;
    }
  } else {
#line 3020
    tmp___1 = (size_t )0;
  }
#line 3020
  len = tmp___1;
#line 3023
  if (*dest) {
    {
#line 3023
    (*lt_dlfree)((void *)*dest);
#line 3023
    *dest = (char *)((void *)0);
    }
  }
#line 3025
  if (! end) {
#line 3026
    return (1);
  }
#line 3028
  if (len > 3UL) {
#line 3028
    if ((int const   )*(str + 0) == 39) {
      {
#line 3030
      tmp___3 = lt_emalloc((unsigned long )(end - str) * sizeof(char ));
#line 3030
      tmp___2 = (char *)tmp___3;
      }
#line 3031
      if (! tmp___2) {
#line 3032
        return (1);
      }
      {
#line 3034
      strncpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)(str + 1),
              (size_t )((end - str) - 1L));
#line 3035
      *(tmp___2 + (len - 3UL)) = (char )'\000';
#line 3036
      *dest = tmp___2;
      }
    } else {
#line 3040
      *dest = (char *)0;
    }
  } else {
#line 3040
    *dest = (char *)0;
  }
#line 3043
  return (0);
}
}
#line 3046 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int free_vars(char *dlname , char *oldname , char *libdir , char *deplibs ) 
{ 


  {
#line 3053
  if (dlname) {
    {
#line 3053
    (*lt_dlfree)((void *)dlname);
#line 3053
    dlname = (char *)((void *)0);
    }
  }
#line 3054
  if (oldname) {
    {
#line 3054
    (*lt_dlfree)((void *)oldname);
#line 3054
    oldname = (char *)((void *)0);
    }
  }
#line 3055
  if (libdir) {
    {
#line 3055
    (*lt_dlfree)((void *)libdir);
#line 3055
    libdir = (char *)((void *)0);
    }
  }
#line 3056
  if (deplibs) {
    {
#line 3056
    (*lt_dlfree)((void *)deplibs);
#line 3056
    deplibs = (char *)((void *)0);
    }
  }
#line 3058
  return (0);
}
}
#line 3061 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int try_dlopen(lt_dlhandle *phandle , char const   *filename ) 
{ 
  char const   *ext ;
  char const   *saved_error ;
  char *canonical ;
  char *base_name ;
  char *dir ;
  char *name ;
  int errors ;
  lt_dlhandle newhandle ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t dirlen ;
  void *tmp___2 ;
  char *tmp___3 ;
  FILE *file ;
  char *dlname ;
  char *old_name ;
  char *libdir ;
  char *deplibs ;
  char *line ;
  size_t line_len ;
  int installed ;
  void *tmp___4 ;
  size_t i ;
  unsigned short const   **tmp___5 ;
  char const   *search_path ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *last_libname ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  void *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  void *tmp___31 ;
  int tmp___32 ;
  lt_dlhandle *tmp___33 ;
  char *tmp___34 ;
  lt_dlhandle *tmp___35 ;
  char *tmp___36 ;
  lt_dlhandle *tmp___37 ;
  lt_dlhandle *tmp___38 ;
  int tmp___39 ;

  {
#line 3066
  ext = (char const   *)0;
#line 3067
  saved_error = (char const   *)0;
#line 3068
  canonical = (char *)0;
#line 3069
  base_name = (char *)0;
#line 3070
  dir = (char *)0;
#line 3071
  name = (char *)0;
#line 3072
  errors = 0;
#line 3075
  if (! phandle) {
    {
#line 3075
    __assert_fail("phandle", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3075U, "try_dlopen");
    }
  }
#line 3076
  if (! ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0))) {
    {
#line 3076
    __assert_fail("*phandle == 0", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3076U, "try_dlopen");
    }
  }
#line 3078
  if (lt_dlmutex_seterror_func) {
    {
#line 3078
    saved_error = (*lt_dlmutex_geterror_func)();
    }
  } else {
#line 3078
    saved_error = lt_dllast_error;
  }
#line 3081
  if (! filename) {
    {
#line 3083
    tmp = lt_emalloc(sizeof(struct lt_dlhandle_struct ));
#line 3083
    *phandle = (struct lt_dlhandle_struct *)tmp;
    }
#line 3084
    if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 3085
      return (1);
    }
    {
#line 3087
    memset((void *)*phandle, 0, sizeof(struct lt_dlhandle_struct ));
#line 3088
    newhandle = *phandle;
#line 3091
    (*phandle)->flags |= 1;
#line 3093
    tmp___0 = tryall_dlopen(& newhandle, (char const   *)0, (char const   *)((void *)0));
    }
#line 3093
    if (tmp___0 != 0) {
#line 3095
      if (*phandle) {
        {
#line 3095
        (*lt_dlfree)((void *)*phandle);
#line 3095
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 3096
      return (1);
    }
#line 3099
    goto register_handle;
  }
#line 3102
  if (filename) {
#line 3102
    if (! *filename) {
      {
#line 3102
      __assert_fail("filename && *filename", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    3102U, "try_dlopen");
      }
    }
  } else {
    {
#line 3102
    __assert_fail("filename && *filename", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3102U, "try_dlopen");
    }
  }
  {
#line 3106
  tmp___1 = canonicalize_path(filename, & canonical);
  }
#line 3106
  if (tmp___1 != 0) {
#line 3108
    errors ++;
#line 3109
    goto cleanup;
  }
  {
#line 3114
  base_name = strrchr((char const   *)canonical, '/');
  }
#line 3115
  if (base_name) {
    {
#line 3117
    dirlen = (size_t )((base_name + 1) - canonical);
#line 3119
    tmp___2 = lt_emalloc((1UL + dirlen) * sizeof(char ));
#line 3119
    dir = (char *)tmp___2;
    }
#line 3120
    if (! dir) {
#line 3122
      errors ++;
#line 3123
      goto cleanup;
    }
    {
#line 3126
    strncpy((char */* __restrict  */)dir, (char const   */* __restrict  */)canonical,
            dirlen);
#line 3127
    *(dir + dirlen) = (char )'\000';
#line 3129
    base_name ++;
    }
  } else {
#line 3132
    base_name = canonical;
  }
#line 3134
  if (base_name) {
#line 3134
    if (! *base_name) {
      {
#line 3134
      __assert_fail("base_name && *base_name", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    3134U, "try_dlopen");
      }
    }
  } else {
    {
#line 3134
    __assert_fail("base_name && *base_name", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3134U, "try_dlopen");
    }
  }
  {
#line 3137
  tmp___3 = strrchr((char const   *)base_name, '.');
#line 3137
  ext = (char const   *)tmp___3;
  }
#line 3138
  if (ext) {
    {
#line 3138
    tmp___39 = strcmp(ext, archive_ext);
    }
#line 3138
    if (tmp___39 == 0) {
      {
#line 3141
      file = (FILE *)0;
#line 3142
      dlname = (char *)0;
#line 3143
      old_name = (char *)0;
#line 3144
      libdir = (char *)0;
#line 3145
      deplibs = (char *)0;
#line 3146
      line = (char *)0;
#line 3152
      installed = 1;
#line 3155
      tmp___4 = lt_emalloc((unsigned long )((ext - (char const   *)base_name) + 1L) * sizeof(char ));
#line 3155
      name = (char *)tmp___4;
      }
#line 3156
      if (! name) {
#line 3158
        errors ++;
#line 3159
        goto cleanup;
      }
#line 3165
      i = (size_t )0;
      {
#line 3165
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3165
        if (! (i < (size_t )(ext - (char const   *)base_name))) {
#line 3165
          goto while_break;
        }
        {
#line 3167
        tmp___5 = __ctype_b_loc();
        }
#line 3167
        if ((int const   )*(*tmp___5 + (int )*(base_name + i)) & 8) {
#line 3169
          *(name + i) = *(base_name + i);
        } else {
#line 3173
          *(name + i) = (char )'_';
        }
#line 3165
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 3176
      *(name + (ext - (char const   *)base_name)) = (char )'\000';
#line 3183
      if (! dir) {
#line 3187
        if (lt_dlmutex_lock_func) {
          {
#line 3187
          (*lt_dlmutex_lock_func)();
          }
        }
#line 3188
        search_path = (char const   *)user_search_path;
#line 3189
        if (search_path) {
          {
#line 3190
          file = find_file((char const   *)user_search_path, (char const   *)base_name,
                           & dir);
          }
        }
#line 3191
        if (lt_dlmutex_unlock_func) {
          {
#line 3191
          (*lt_dlmutex_unlock_func)();
          }
        }
#line 3193
        if (! file) {
          {
#line 3195
          tmp___6 = getenv("LTDL_LIBRARY_PATH");
#line 3195
          search_path = (char const   *)tmp___6;
          }
#line 3196
          if (search_path) {
            {
#line 3197
            file = find_file(search_path, (char const   *)base_name, & dir);
            }
          }
        }
#line 3201
        if (! file) {
          {
#line 3203
          tmp___7 = getenv("LD_LIBRARY_PATH");
#line 3203
          search_path = (char const   *)tmp___7;
          }
#line 3204
          if (search_path) {
            {
#line 3205
            file = find_file(search_path, (char const   *)base_name, & dir);
            }
          }
        }
#line 3209
        if (! file) {
#line 3209
          if (sys_search_path) {
            {
#line 3211
            file = find_file(sys_search_path, (char const   *)base_name, & dir);
            }
          }
        }
      } else {
        {
#line 3217
        file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
        }
      }
#line 3222
      if (! file) {
#line 3224
        if (lt_dlmutex_seterror_func) {
          {
#line 3224
          (*lt_dlmutex_seterror_func)(lt_dlerror_strings[5]);
          }
        } else {
#line 3224
          lt_dllast_error = lt_dlerror_strings[5];
        }
#line 3225
        errors ++;
#line 3226
        goto cleanup;
      }
      {
#line 3229
      line_len = (size_t )1024;
#line 3230
      tmp___8 = lt_emalloc(line_len * sizeof(char ));
#line 3230
      line = (char *)tmp___8;
      }
#line 3231
      if (! line) {
        {
#line 3233
        fclose(file);
#line 3234
        errors ++;
        }
#line 3235
        goto cleanup;
      }
      {
#line 3239
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 3239
        tmp___27 = feof(file);
        }
#line 3239
        if (tmp___27) {
#line 3239
          goto while_break___0;
        }
        {
#line 3241
        tmp___9 = fgets((char */* __restrict  */)line, (int )line_len, (FILE */* __restrict  */)file);
        }
#line 3241
        if (! tmp___9) {
#line 3243
          goto while_break___0;
        }
        {
#line 3248
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3248
          if (line) {
#line 3248
            if (*(line + 0)) {
              {
#line 3248
              tmp___12 = strlen((char const   *)line);
#line 3248
              tmp___13 = tmp___12;
              }
            } else {
#line 3248
              tmp___13 = (size_t )0;
            }
          } else {
#line 3248
            tmp___13 = (size_t )0;
          }
#line 3248
          if ((int )*(line + (tmp___13 - 1UL)) != 10) {
            {
#line 3248
            tmp___14 = feof(file);
            }
#line 3248
            if (tmp___14) {
#line 3248
              goto while_break___1;
            }
          } else {
#line 3248
            goto while_break___1;
          }
          {
#line 3250
          tmp___10 = (*lt_dlrealloc)((void *)line, (line_len * 2UL) * sizeof(char ));
#line 3250
          line = (char *)tmp___10;
#line 3251
          tmp___11 = fgets((char */* __restrict  */)(line + (line_len - 1UL)), (int )line_len + 1,
                           (FILE */* __restrict  */)file);
          }
#line 3251
          if (! tmp___11) {
#line 3253
            goto while_break___1;
          }
#line 3255
          line_len *= 2UL;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3258
        if ((int )*(line + 0) == 10) {
#line 3260
          goto while_continue___0;
        } else
#line 3258
        if ((int )*(line + 0) == 35) {
#line 3260
          goto while_continue___0;
        }
        {
#line 3265
        tmp___26 = strncmp((char const   *)line, "dlname=", sizeof("dlname=") - 1UL);
        }
#line 3265
        if (tmp___26 == 0) {
          {
#line 3267
          tmp___15 = trim(& dlname, (char const   *)(line + (sizeof("dlname=") - 1UL)));
#line 3267
          errors += tmp___15;
          }
        } else {
          {
#line 3272
          tmp___25 = strncmp((char const   *)line, "old_library=", sizeof("old_library=") - 1UL);
          }
#line 3272
          if (tmp___25 == 0) {
            {
#line 3275
            tmp___16 = trim(& old_name, (char const   *)(line + (sizeof("old_library=") - 1UL)));
#line 3275
            errors += tmp___16;
            }
          } else {
            {
#line 3279
            tmp___24 = strncmp((char const   *)line, "libdir=", sizeof("libdir=") - 1UL);
            }
#line 3279
            if (tmp___24 == 0) {
              {
#line 3281
              tmp___17 = trim(& libdir, (char const   *)(line + (sizeof("libdir=") - 1UL)));
#line 3281
              errors += tmp___17;
              }
            } else {
              {
#line 3286
              tmp___23 = strncmp((char const   *)line, "dependency_libs=", sizeof("dependency_libs=") - 1UL);
              }
#line 3286
              if (tmp___23 == 0) {
                {
#line 3289
                tmp___18 = trim(& deplibs, (char const   *)(line + (sizeof("dependency_libs=") - 1UL)));
#line 3289
                errors += tmp___18;
                }
              } else {
                {
#line 3291
                tmp___22 = strcmp((char const   *)line, "installed=yes\n");
                }
#line 3291
                if (tmp___22 == 0) {
#line 3293
                  installed = 1;
                } else {
                  {
#line 3295
                  tmp___21 = strcmp((char const   *)line, "installed=no\n");
                  }
#line 3295
                  if (tmp___21 == 0) {
#line 3297
                    installed = 0;
                  } else
#line 3302
                  if (! dlname) {
                    {
#line 3302
                    tmp___20 = strncmp((char const   *)line, "library_names=", sizeof("library_names=") - 1UL);
                    }
#line 3302
                    if (tmp___20 == 0) {
                      {
#line 3306
                      tmp___19 = trim(& dlname, (char const   *)(line + (sizeof("library_names=") - 1UL)));
#line 3306
                      errors += tmp___19;
                      }
#line 3307
                      if (! errors) {
#line 3307
                        if (dlname) {
                          {
#line 3307
                          last_libname = strrchr((char const   *)dlname, ' ');
                          }
#line 3307
                          if ((unsigned long )last_libname != (unsigned long )((char *)0)) {
                            {
#line 3311
                            last_libname = lt_estrdup((char const   *)(last_libname + 1));
                            }
#line 3312
                            if (! last_libname) {
#line 3314
                              errors ++;
#line 3315
                              goto cleanup;
                            }
#line 3317
                            if ((unsigned long )dlname != (unsigned long )last_libname) {
#line 3317
                              if (dlname) {
                                {
#line 3317
                                (*lt_dlfree)((void *)dlname);
                                }
                              }
#line 3317
                              dlname = last_libname;
#line 3317
                              last_libname = (char *)0;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 3321
        if (errors) {
#line 3322
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3325
      fclose(file);
      }
#line 3326
      if (line) {
        {
#line 3326
        (*lt_dlfree)((void *)line);
#line 3326
        line = (char *)((void *)0);
        }
      }
      {
#line 3329
      tmp___28 = lt_emalloc(sizeof(struct lt_dlhandle_struct ));
#line 3329
      *phandle = (struct lt_dlhandle_struct *)tmp___28;
      }
#line 3330
      if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 3331
        errors ++;
      }
#line 3333
      if (errors) {
        {
#line 3335
        free_vars(dlname, old_name, libdir, deplibs);
        }
#line 3336
        if (*phandle) {
          {
#line 3336
          (*lt_dlfree)((void *)*phandle);
#line 3336
          *phandle = (lt_dlhandle )((void *)0);
          }
        }
#line 3337
        goto cleanup;
      }
#line 3340
      if (! *phandle) {
        {
#line 3340
        __assert_fail("*phandle", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                      3340U, "try_dlopen");
        }
      }
      {
#line 3342
      memset((void *)*phandle, 0, sizeof(struct lt_dlhandle_struct ));
#line 3343
      tmp___30 = load_deplibs(*phandle, deplibs);
      }
#line 3343
      if (tmp___30 == 0) {
        {
#line 3345
        newhandle = *phandle;
#line 3347
        tmp___29 = find_module(& newhandle, (char const   *)dir, (char const   *)libdir,
                               (char const   *)dlname, (char const   *)old_name, installed);
        }
#line 3347
        if (tmp___29) {
          {
#line 3349
          unload_deplibs(*phandle);
#line 3350
          errors ++;
          }
        }
      } else {
#line 3355
        errors ++;
      }
      {
#line 3358
      free_vars(dlname, old_name, libdir, deplibs);
      }
#line 3359
      if (errors) {
#line 3361
        if (*phandle) {
          {
#line 3361
          (*lt_dlfree)((void *)*phandle);
#line 3361
          *phandle = (lt_dlhandle )((void *)0);
          }
        }
#line 3362
        goto cleanup;
      }
#line 3365
      if ((unsigned long )*phandle != (unsigned long )newhandle) {
        {
#line 3367
        unload_deplibs(*phandle);
        }
      }
    } else {
#line 3138
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 3373
    tmp___31 = lt_emalloc(sizeof(struct lt_dlhandle_struct ));
#line 3373
    *phandle = (struct lt_dlhandle_struct *)tmp___31;
    }
#line 3374
    if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 3376
      errors ++;
#line 3377
      goto cleanup;
    }
    {
#line 3380
    memset((void *)*phandle, 0, sizeof(struct lt_dlhandle_struct ));
#line 3381
    newhandle = *phandle;
    }
#line 3387
    if (dir) {
#line 3387
      goto _L;
    } else {
      {
#line 3387
      tmp___33 = find_handle((char const   *)user_search_path, (char const   *)base_name,
                             & newhandle);
      }
#line 3387
      if (! tmp___33) {
        {
#line 3387
        tmp___34 = getenv("LTDL_LIBRARY_PATH");
#line 3387
        tmp___35 = find_handle((char const   *)tmp___34, (char const   *)base_name,
                               & newhandle);
        }
#line 3387
        if (! tmp___35) {
          {
#line 3387
          tmp___36 = getenv("LD_LIBRARY_PATH");
#line 3387
          tmp___37 = find_handle((char const   *)tmp___36, (char const   *)base_name,
                                 & newhandle);
          }
#line 3387
          if (! tmp___37) {
            {
#line 3387
            tmp___38 = find_handle(sys_search_path, (char const   *)base_name, & newhandle);
            }
#line 3387
            if (! tmp___38) {
              _L: /* CIL Label */ 
              {
#line 3399
              tmp___32 = tryall_dlopen(& newhandle, filename, (char const   *)((void *)0));
              }
#line 3399
              if (tmp___32 != 0) {
#line 3401
                newhandle = (lt_dlhandle )((void *)0);
              }
            }
          }
        }
      }
    }
#line 3405
    if (! newhandle) {
#line 3407
      if (*phandle) {
        {
#line 3407
        (*lt_dlfree)((void *)*phandle);
#line 3407
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 3408
      errors ++;
#line 3409
      goto cleanup;
    }
  }
  register_handle: 
#line 3414
  if ((unsigned long )*phandle != (unsigned long )newhandle) {
#line 3414
    if (*phandle) {
      {
#line 3414
      (*lt_dlfree)((void *)*phandle);
      }
    }
#line 3414
    *phandle = newhandle;
#line 3414
    newhandle = (lt_dlhandle )0;
  }
#line 3416
  if ((*phandle)->info.ref_count == 0) {
#line 3418
    (*phandle)->info.ref_count = 1;
#line 3419
    if ((unsigned long )(*phandle)->info.name != (unsigned long )name) {
#line 3419
      if ((*phandle)->info.name) {
        {
#line 3419
        (*lt_dlfree)((void *)(*phandle)->info.name);
        }
      }
#line 3419
      (*phandle)->info.name = name;
#line 3419
      name = (char *)0;
    }
#line 3421
    if (lt_dlmutex_lock_func) {
      {
#line 3421
      (*lt_dlmutex_lock_func)();
      }
    }
#line 3422
    (*phandle)->next = handles;
#line 3423
    handles = *phandle;
#line 3424
    if (lt_dlmutex_unlock_func) {
      {
#line 3424
      (*lt_dlmutex_unlock_func)();
      }
    }
  }
#line 3427
  if (lt_dlmutex_seterror_func) {
    {
#line 3427
    (*lt_dlmutex_seterror_func)(saved_error);
    }
  } else {
#line 3427
    lt_dllast_error = saved_error;
  }
  cleanup: 
#line 3430
  if (dir) {
    {
#line 3430
    (*lt_dlfree)((void *)dir);
#line 3430
    dir = (char *)((void *)0);
    }
  }
#line 3431
  if (name) {
    {
#line 3431
    (*lt_dlfree)((void *)name);
#line 3431
    name = (char *)((void *)0);
    }
  }
#line 3432
  if (canonical) {
    {
#line 3432
    (*lt_dlfree)((void *)canonical);
#line 3432
    canonical = (char *)((void *)0);
    }
  }
#line 3434
  return (errors);
}
}
#line 3437 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
lt_dlhandle lt_dlopen(char const   *filename ) 
{ 
  lt_dlhandle handle ;
  int tmp ;

  {
  {
#line 3441
  handle = (lt_dlhandle )0;
#line 3445
  tmp = try_dlopen(& handle, filename);
  }
#line 3445
  if (tmp != 0) {
#line 3446
    return ((lt_dlhandle )0);
  }
#line 3448
  return (handle);
}
}
#line 3453 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int file_not_found(void) 
{ 
  char const   *error ;

  {
#line 3456
  error = (char const   *)0;
#line 3458
  if (lt_dlmutex_seterror_func) {
    {
#line 3458
    error = (*lt_dlmutex_geterror_func)();
    }
  } else {
#line 3458
    error = lt_dllast_error;
  }
#line 3459
  if ((unsigned long )error == (unsigned long )lt_dlerror_strings[5]) {
#line 3460
    return (1);
  }
#line 3462
  return (0);
}
}
#line 3469 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
lt_dlhandle lt_dlopenext(char const   *filename ) 
{ 
  lt_dlhandle handle ;
  char *tmp ;
  char *ext ;
  size_t len ;
  int errors ;
  lt_dlhandle tmp___0 ;
  size_t tmp___1 ;
  lt_dlhandle tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;

  {
#line 3473
  handle = (lt_dlhandle )0;
#line 3474
  tmp = (char *)0;
#line 3475
  ext = (char *)0;
#line 3477
  errors = 0;
#line 3479
  if (! filename) {
    {
#line 3481
    tmp___0 = lt_dlopen(filename);
    }
#line 3481
    return (tmp___0);
  }
#line 3484
  if (! filename) {
    {
#line 3484
    __assert_fail("filename", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3484U, "lt_dlopenext");
    }
  }
#line 3486
  if (filename) {
#line 3486
    if (*(filename + 0)) {
      {
#line 3486
      tmp___1 = strlen(filename);
#line 3486
      len = tmp___1;
      }
    } else {
#line 3486
      len = (size_t )0;
    }
  } else {
#line 3486
    len = (size_t )0;
  }
  {
#line 3487
  ext = strrchr(filename, '.');
  }
#line 3491
  if (ext) {
    {
#line 3491
    tmp___3 = strcmp((char const   *)ext, archive_ext);
    }
#line 3491
    if (tmp___3 == 0) {
      {
#line 3497
      tmp___2 = lt_dlopen(filename);
      }
#line 3497
      return (tmp___2);
    } else {
      {
#line 3491
      tmp___4 = strcmp((char const   *)ext, shlib_ext);
      }
#line 3491
      if (tmp___4 == 0) {
        {
#line 3497
        tmp___2 = lt_dlopen(filename);
        }
#line 3497
        return (tmp___2);
      }
    }
  }
#line 3501
  if (archive_ext) {
#line 3501
    if (archive_ext[0]) {
      {
#line 3501
      tmp___5 = strlen(archive_ext);
#line 3501
      tmp___6 = tmp___5;
      }
    } else {
#line 3501
      tmp___6 = (size_t )0;
    }
  } else {
#line 3501
    tmp___6 = (size_t )0;
  }
  {
#line 3501
  tmp___7 = lt_emalloc(((len + tmp___6) + 1UL) * sizeof(char ));
#line 3501
  tmp = (char *)tmp___7;
  }
#line 3502
  if (! tmp) {
#line 3503
    return ((lt_dlhandle )0);
  }
  {
#line 3505
  strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)filename);
#line 3506
  strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)(archive_ext));
#line 3507
  errors = try_dlopen(& handle, (char const   *)tmp);
  }
#line 3508
  if (handle) {
#line 3508
    if (errors) {
#line 3509
      if (lt_dlmutex_seterror_func) {
        {
#line 3509
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[19]);
        }
      } else {
#line 3509
        lt_dllast_error = lt_dlerror_strings[19];
      }
#line 3510
      return ((lt_dlhandle )0);
    }
  }
#line 3512
  if (handle) {
#line 3512
    if (errors) {
#line 3513
      if (lt_dlmutex_seterror_func) {
        {
#line 3513
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[19]);
        }
      } else {
#line 3513
        lt_dllast_error = lt_dlerror_strings[19];
      }
#line 3514
      return ((lt_dlhandle )0);
    }
  }
#line 3522
  if (handle) {
#line 3522
    goto _L;
  } else
#line 3522
  if (errors > 0) {
    {
#line 3522
    tmp___8 = file_not_found();
    }
#line 3522
    if (! tmp___8) {
      _L: /* CIL Label */ 
#line 3524
      if (tmp) {
        {
#line 3524
        (*lt_dlfree)((void *)tmp);
#line 3524
        tmp = (char *)((void *)0);
        }
      }
#line 3525
      return (handle);
    }
  }
#line 3530
  if (shlib_ext) {
#line 3530
    if (shlib_ext[0]) {
      {
#line 3530
      tmp___12 = strlen(shlib_ext);
#line 3530
      tmp___13 = tmp___12;
      }
    } else {
#line 3530
      tmp___13 = (size_t )0;
    }
  } else {
#line 3530
    tmp___13 = (size_t )0;
  }
#line 3530
  if (archive_ext) {
#line 3530
    if (archive_ext[0]) {
      {
#line 3530
      tmp___14 = strlen(archive_ext);
#line 3530
      tmp___15 = tmp___14;
      }
    } else {
#line 3530
      tmp___15 = (size_t )0;
    }
  } else {
#line 3530
    tmp___15 = (size_t )0;
  }
#line 3530
  if (tmp___13 > tmp___15) {
#line 3532
    if (tmp) {
      {
#line 3532
      (*lt_dlfree)((void *)tmp);
#line 3532
      tmp = (char *)((void *)0);
      }
    }
#line 3533
    if (shlib_ext) {
#line 3533
      if (shlib_ext[0]) {
        {
#line 3533
        tmp___9 = strlen(shlib_ext);
#line 3533
        tmp___10 = tmp___9;
        }
      } else {
#line 3533
        tmp___10 = (size_t )0;
      }
    } else {
#line 3533
      tmp___10 = (size_t )0;
    }
    {
#line 3533
    tmp___11 = lt_emalloc(((len + tmp___10) + 1UL) * sizeof(char ));
#line 3533
    tmp = (char *)tmp___11;
    }
#line 3534
    if (! tmp) {
#line 3535
      return ((lt_dlhandle )0);
    }
    {
#line 3537
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)filename);
    }
  } else {
#line 3541
    *(tmp + len) = (char )'\000';
#line 3542
    if (handle) {
#line 3542
      if (errors) {
#line 3543
        if (lt_dlmutex_seterror_func) {
          {
#line 3543
          (*lt_dlmutex_seterror_func)(lt_dlerror_strings[19]);
          }
        } else {
#line 3543
          lt_dllast_error = lt_dlerror_strings[19];
        }
#line 3544
        return ((lt_dlhandle )0);
      }
    }
  }
  {
#line 3548
  strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)(shlib_ext));
#line 3549
  errors = try_dlopen(& handle, (char const   *)tmp);
  }
#line 3550
  if (handle) {
#line 3550
    if (errors) {
#line 3551
      if (lt_dlmutex_seterror_func) {
        {
#line 3551
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[19]);
        }
      } else {
#line 3551
        lt_dllast_error = lt_dlerror_strings[19];
      }
#line 3552
      return ((lt_dlhandle )0);
    }
  }
#line 3557
  if (handle) {
#line 3557
    goto _L___0;
  } else
#line 3557
  if (errors > 0) {
    {
#line 3557
    tmp___16 = file_not_found();
    }
#line 3557
    if (! tmp___16) {
      _L___0: /* CIL Label */ 
#line 3559
      if (tmp) {
        {
#line 3559
        (*lt_dlfree)((void *)tmp);
#line 3559
        tmp = (char *)((void *)0);
        }
      }
#line 3560
      return (handle);
    }
  }
#line 3566
  if (lt_dlmutex_seterror_func) {
    {
#line 3566
    (*lt_dlmutex_seterror_func)(lt_dlerror_strings[5]);
    }
  } else {
#line 3566
    lt_dllast_error = lt_dlerror_strings[5];
  }
#line 3567
  if (tmp) {
    {
#line 3567
    (*lt_dlfree)((void *)tmp);
#line 3567
    tmp = (char *)((void *)0);
    }
  }
#line 3568
  return ((lt_dlhandle )0);
}
}
#line 3572 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int lt_argz_insert(char **pargz , size_t *pargz_len , char *before , char const   *entry ) 
{ 
  error_t error ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 3583
  if (before) {
    {
#line 3584
    error = argz_insert((char **/* __restrict  */)pargz, (size_t */* __restrict  */)pargz_len,
                        (char */* __restrict  */)before, (char const   */* __restrict  */)entry);
    }
  } else {
#line 3586
    if (entry) {
#line 3586
      if (*(entry + 0)) {
        {
#line 3586
        tmp = strlen(entry);
#line 3586
        tmp___0 = tmp;
        }
      } else {
#line 3586
        tmp___0 = (size_t )0;
      }
    } else {
#line 3586
      tmp___0 = (size_t )0;
    }
    {
#line 3586
    error = argz_append((char **/* __restrict  */)pargz, (size_t */* __restrict  */)pargz_len,
                        (char const   */* __restrict  */)entry, 1UL + tmp___0);
    }
  }
#line 3588
  if (error) {
    {
#line 3592
    if (error == 12) {
#line 3592
      goto case_12;
    }
#line 3595
    goto switch_default;
    case_12: /* CIL Label */ 
#line 3593
    if (lt_dlmutex_seterror_func) {
      {
#line 3593
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[11]);
      }
    } else {
#line 3593
      lt_dllast_error = lt_dlerror_strings[11];
    }
#line 3594
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3596
    if (lt_dlmutex_seterror_func) {
      {
#line 3596
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[0]);
      }
    } else {
#line 3596
      lt_dllast_error = lt_dlerror_strings[0];
    }
#line 3597
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3599
    return (1);
  }
#line 3602
  return (0);
}
}
#line 3605 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int lt_argz_insertinorder(char **pargz , size_t *pargz_len , char const   *entry ) 
{ 
  char *before ;
  int cmp ;
  int tmp ;
  int tmp___0 ;

  {
#line 3611
  before = (char *)0;
#line 3613
  if (! pargz) {
    {
#line 3613
    __assert_fail("pargz", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3613U, "lt_argz_insertinorder");
    }
  }
#line 3614
  if (! pargz_len) {
    {
#line 3614
    __assert_fail("pargz_len", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3614U, "lt_argz_insertinorder");
    }
  }
#line 3615
  if (entry) {
#line 3615
    if (! *entry) {
      {
#line 3615
      __assert_fail("entry && *entry", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    3615U, "lt_argz_insertinorder");
      }
    }
  } else {
    {
#line 3615
    __assert_fail("entry && *entry", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3615U, "lt_argz_insertinorder");
    }
  }
#line 3617
  if (*pargz) {
    {
#line 3618
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3618
      before = argz_next((char const   */* __restrict  */)*pargz, *pargz_len, (char const   */* __restrict  */)before);
      }
#line 3618
      if (! before) {
#line 3618
        goto while_break;
      }
      {
#line 3620
      tmp = strcmp(entry, (char const   *)before);
#line 3620
      cmp = tmp;
      }
#line 3622
      if (cmp < 0) {
#line 3622
        goto while_break;
      }
#line 3623
      if (cmp == 0) {
#line 3623
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 3626
  tmp___0 = lt_argz_insert(pargz, pargz_len, before, entry);
  }
#line 3626
  return (tmp___0);
}
}
#line 3629 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int lt_argz_insertdir(char **pargz , size_t *pargz_len , char const   *dirnam ,
                             struct dirent *dp ) 
{ 
  char *buf ;
  size_t buf_len ;
  char *end ;
  size_t end_offset ;
  size_t dir_len ;
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  char *p ;
  char *tmp___1 ;
  char *p___0 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 3636
  buf = (char *)0;
#line 3637
  buf_len = (size_t )0;
#line 3638
  end = (char *)0;
#line 3639
  end_offset = (size_t )0;
#line 3640
  dir_len = (size_t )0;
#line 3641
  errors = 0;
#line 3643
  if (! pargz) {
    {
#line 3643
    __assert_fail("pargz", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3643U, "lt_argz_insertdir");
    }
  }
#line 3644
  if (! pargz_len) {
    {
#line 3644
    __assert_fail("pargz_len", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3644U, "lt_argz_insertdir");
    }
  }
#line 3645
  if (! dp) {
    {
#line 3645
    __assert_fail("dp", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3645U, "lt_argz_insertdir");
    }
  }
#line 3647
  if (dirnam) {
#line 3647
    if (*(dirnam + 0)) {
      {
#line 3647
      tmp = strlen(dirnam);
#line 3647
      dir_len = tmp;
      }
    } else {
#line 3647
      dir_len = (size_t )0;
    }
  } else {
#line 3647
    dir_len = (size_t )0;
  }
  {
#line 3648
  tmp___0 = strlen((char const   *)(dp->d_name));
#line 3648
  end = dp->d_name + tmp___0;
#line 3653
  p = end;
  }
  {
#line 3653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3653
    if (! ((unsigned long )(p - 1) > (unsigned long )(dp->d_name))) {
#line 3653
      goto while_break;
    }
    {
#line 3654
    tmp___1 = strchr(".0123456789", (int )*(p + -1));
    }
#line 3654
    if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
#line 3655
      goto while_break;
    }
#line 3653
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3657
  if ((int )*p == 46) {
#line 3658
    end = p;
  }
#line 3664
  p___0 = end - 1;
  {
#line 3664
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3664
    if (! ((unsigned long )p___0 > (unsigned long )(dp->d_name))) {
#line 3664
      goto while_break___0;
    }
#line 3665
    if ((int )*p___0 == 46) {
#line 3667
      end = p___0;
#line 3668
      goto while_break___0;
    }
#line 3664
    p___0 --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3673
  end_offset = (size_t )(end - dp->d_name);
#line 3674
  buf_len = (dir_len + 1UL) + end_offset;
#line 3675
  tmp___2 = lt_emalloc((1UL + buf_len) * sizeof(char ));
#line 3675
  buf = (char *)tmp___2;
  }
#line 3676
  if (! buf) {
#line 3677
    errors ++;
#line 3677
    return (errors);
  }
#line 3679
  if (! buf) {
    {
#line 3679
    __assert_fail("buf", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3679U, "lt_argz_insertdir");
    }
  }
  {
#line 3681
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)dirnam);
#line 3682
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"/");
#line 3683
  strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)(dp->d_name),
          end_offset);
#line 3684
  *(buf + buf_len) = (char )'\000';
#line 3687
  tmp___3 = lt_argz_insertinorder(pargz, pargz_len, (char const   *)buf);
  }
#line 3687
  if (tmp___3 != 0) {
#line 3688
    errors ++;
  }
#line 3690
  if (buf) {
    {
#line 3690
    (*lt_dlfree)((void *)buf);
#line 3690
    buf = (char *)((void *)0);
    }
  }
#line 3692
  return (errors);
}
}
#line 3695 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int list_files_by_dir(char const   *dirnam , char **pargz , size_t *pargz_len ) 
{ 
  DIR *dirp ;
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  struct dirent *dp ;
  int tmp___1 ;

  {
#line 3701
  dirp = (DIR *)0;
#line 3702
  errors = 0;
#line 3704
  if (dirnam) {
#line 3704
    if (! *dirnam) {
      {
#line 3704
      __assert_fail("dirnam && *dirnam", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    3704U, "list_files_by_dir");
      }
    }
  } else {
    {
#line 3704
    __assert_fail("dirnam && *dirnam", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3704U, "list_files_by_dir");
    }
  }
#line 3705
  if (! pargz) {
    {
#line 3705
    __assert_fail("pargz", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3705U, "list_files_by_dir");
    }
  }
#line 3706
  if (! pargz_len) {
    {
#line 3706
    __assert_fail("pargz_len", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3706U, "list_files_by_dir");
    }
  }
#line 3707
  if (dirnam) {
#line 3707
    if (*(dirnam + 0)) {
      {
#line 3707
      tmp = strlen(dirnam);
#line 3707
      tmp___0 = tmp;
      }
    } else {
#line 3707
      tmp___0 = (size_t )0;
    }
  } else {
#line 3707
    tmp___0 = (size_t )0;
  }
#line 3707
  if (! ((int const   )*(dirnam + (tmp___0 - 1UL)) != 47)) {
    {
#line 3707
    __assert_fail("dirnam[(((dirnam) && (dirnam)[0]) ? strlen (dirnam) : 0) -1] != \'/\'",
                  "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  3707U, "list_files_by_dir");
    }
  }
  {
#line 3709
  dirp = opendir(dirnam);
  }
#line 3710
  if (dirp) {
#line 3712
    dp = (struct dirent *)0;
    {
#line 3714
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3714
      dp = readdir(dirp);
      }
#line 3714
      if (! dp) {
#line 3714
        goto while_break;
      }
#line 3715
      if ((int )dp->d_name[0] != 46) {
        {
#line 3716
        tmp___1 = lt_argz_insertdir(pargz, pargz_len, dirnam, dp);
        }
#line 3716
        if (tmp___1) {
#line 3718
          errors ++;
#line 3719
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3722
    closedir(dirp);
    }
  } else {
#line 3725
    errors ++;
  }
#line 3727
  return (errors);
}
}
#line 3733 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int foreachfile_callback(char *dirname , void *data1 , void *data2 ) 
{ 
  int (*func)(char const   *filename , void *data ) ;
  int is_done ;
  char *argz ;
  size_t argz_len ;
  int tmp ;
  char *filename ;

  {
  {
#line 3739
  func = (int (*)(char const   *filename , void *data ))data1;
#line 3742
  is_done = 0;
#line 3743
  argz = (char *)0;
#line 3744
  argz_len = (size_t )0;
#line 3746
  tmp = list_files_by_dir((char const   *)dirname, & argz, & argz_len);
  }
#line 3746
  if (tmp != 0) {
#line 3747
    goto cleanup;
  }
#line 3748
  if (! argz) {
#line 3749
    goto cleanup;
  }
#line 3752
  filename = (char *)0;
  {
#line 3753
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3753
    filename = argz_next((char const   */* __restrict  */)argz, argz_len, (char const   */* __restrict  */)filename);
    }
#line 3753
    if (! filename) {
#line 3753
      goto while_break;
    }
    {
#line 3754
    is_done = (*func)((char const   *)filename, data2);
    }
#line 3754
    if (is_done) {
#line 3755
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 3759
  if (argz) {
    {
#line 3759
    (*lt_dlfree)((void *)argz);
#line 3759
    argz = (char *)((void *)0);
    }
  }
#line 3761
  return (is_done);
}
}
#line 3771 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlforeachfile(char const   *search_path , int (*func)(char const   *filename ,
                                                             void *data ) , void *data ) 
{ 
  int is_done ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 3777
  is_done = 0;
#line 3779
  if (search_path) {
    {
#line 3783
    is_done = foreach_dirinpath(search_path, (char const   *)0, & foreachfile_callback,
                                (void *)func, data);
    }
  } else {
    {
#line 3789
    is_done = foreach_dirinpath((char const   *)user_search_path, (char const   *)0,
                                & foreachfile_callback, (void *)func, data);
    }
#line 3791
    if (! is_done) {
      {
#line 3793
      tmp = getenv("LTDL_LIBRARY_PATH");
#line 3793
      is_done = foreach_dirinpath((char const   *)tmp, (char const   *)0, & foreachfile_callback,
                                  (void *)func, data);
      }
    }
#line 3798
    if (! is_done) {
      {
#line 3800
      tmp___0 = getenv("LD_LIBRARY_PATH");
#line 3800
      is_done = foreach_dirinpath((char const   *)tmp___0, (char const   *)0, & foreachfile_callback,
                                  (void *)func, data);
      }
    }
#line 3805
    if (! is_done) {
      {
#line 3807
      tmp___1 = getenv("/lib:/usr/lib:/usr/lib/x86_64-linux-gnu/libfakeroot:/usr/local/lib:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu/mesa-egl:/usr/lib/x86_64-linux-gnu/mesa");
#line 3807
      is_done = foreach_dirinpath((char const   *)tmp___1, (char const   *)0, & foreachfile_callback,
                                  (void *)func, data);
      }
    }
  }
#line 3813
  return (is_done);
}
}
#line 3816 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlclose(lt_dlhandle handle ) 
{ 
  lt_dlhandle cur ;
  lt_dlhandle last ;
  int errors ;
  lt_user_data data ;
  int tmp ;
  int tmp___0 ;

  {
#line 3821
  errors = 0;
#line 3823
  if (lt_dlmutex_lock_func) {
    {
#line 3823
    (*lt_dlmutex_lock_func)();
    }
  }
#line 3826
  cur = handles;
#line 3826
  last = cur;
  {
#line 3827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3827
    if (cur) {
#line 3827
      if (! ((unsigned long )handle != (unsigned long )cur)) {
#line 3827
        goto while_break;
      }
    } else {
#line 3827
      goto while_break;
    }
#line 3829
    last = cur;
#line 3830
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 3833
  if (! cur) {
#line 3835
    if (lt_dlmutex_seterror_func) {
      {
#line 3835
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[12]);
      }
    } else {
#line 3835
      lt_dllast_error = lt_dlerror_strings[12];
    }
#line 3836
    errors ++;
#line 3837
    goto done;
  }
#line 3840
  (handle->info.ref_count) --;
#line 3846
  if (handle->info.ref_count <= 0) {
#line 3846
    if (! ((handle->flags & 1) == 1)) {
#line 3848
      data = (handle->loader)->dlloader_data;
#line 3850
      if ((unsigned long )handle != (unsigned long )handles) {
#line 3852
        last->next = handle->next;
      } else {
#line 3856
        handles = handle->next;
      }
      {
#line 3859
      tmp = (*((handle->loader)->module_close))(data, handle->module);
#line 3859
      errors += tmp;
#line 3860
      tmp___0 = unload_deplibs(handle);
#line 3860
      errors += tmp___0;
      }
#line 3863
      if (handle->caller_data) {
        {
#line 3863
        (*lt_dlfree)((void *)handle->caller_data);
#line 3863
        handle->caller_data = (lt_caller_data *)((void *)0);
        }
      }
#line 3865
      if (handle->info.filename) {
        {
#line 3865
        (*lt_dlfree)((void *)handle->info.filename);
#line 3865
        handle->info.filename = (char *)((void *)0);
        }
      }
#line 3866
      if (handle->info.name) {
        {
#line 3866
        (*lt_dlfree)((void *)handle->info.name);
#line 3866
        handle->info.name = (char *)((void *)0);
        }
      }
#line 3867
      if (handle) {
        {
#line 3867
        (*lt_dlfree)((void *)handle);
#line 3867
        handle = (lt_dlhandle )((void *)0);
        }
      }
#line 3869
      goto done;
    }
  }
#line 3872
  if ((handle->flags & 1) == 1) {
#line 3874
    if (lt_dlmutex_seterror_func) {
      {
#line 3874
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[16]);
      }
    } else {
#line 3874
      lt_dllast_error = lt_dlerror_strings[16];
    }
#line 3875
    errors ++;
  }
  done: 
#line 3879
  if (lt_dlmutex_unlock_func) {
    {
#line 3879
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 3881
  return (errors);
}
}
#line 3884 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
void *lt_dlsym(lt_dlhandle handle , char const   *symbol ) 
{ 
  size_t lensym ;
  char lsym[128] ;
  char *sym ;
  void *address ;
  lt_user_data data ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *saved_error ;

  {
#line 3895
  if (! handle) {
#line 3897
    if (lt_dlmutex_seterror_func) {
      {
#line 3897
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[12]);
      }
    } else {
#line 3897
      lt_dllast_error = lt_dlerror_strings[12];
    }
#line 3898
    return ((void *)0);
  }
#line 3901
  if (! symbol) {
#line 3903
    if (lt_dlmutex_seterror_func) {
      {
#line 3903
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[10]);
      }
    } else {
#line 3903
      lt_dllast_error = lt_dlerror_strings[10];
    }
#line 3904
    return ((void *)0);
  }
#line 3907
  if (symbol) {
#line 3907
    if (*(symbol + 0)) {
      {
#line 3907
      tmp = strlen(symbol);
#line 3907
      tmp___0 = tmp;
      }
    } else {
#line 3907
      tmp___0 = (size_t )0;
    }
  } else {
#line 3907
    tmp___0 = (size_t )0;
  }
#line 3907
  if ((handle->loader)->sym_prefix) {
#line 3907
    if (*((handle->loader)->sym_prefix + 0)) {
      {
#line 3907
      tmp___1 = strlen((handle->loader)->sym_prefix);
#line 3907
      tmp___2 = tmp___1;
      }
    } else {
#line 3907
      tmp___2 = (size_t )0;
    }
  } else {
#line 3907
    tmp___2 = (size_t )0;
  }
#line 3907
  if (handle->info.name) {
#line 3907
    if (*(handle->info.name + 0)) {
      {
#line 3907
      tmp___3 = strlen((char const   *)handle->info.name);
#line 3907
      tmp___4 = tmp___3;
      }
    } else {
#line 3907
      tmp___4 = (size_t )0;
    }
  } else {
#line 3907
    tmp___4 = (size_t )0;
  }
#line 3907
  lensym = (tmp___0 + tmp___2) + tmp___4;
#line 3910
  if (lensym + 5UL < 128UL) {
#line 3912
    sym = lsym;
  } else {
    {
#line 3916
    tmp___5 = lt_emalloc(((lensym + 5UL) + 1UL) * sizeof(char ));
#line 3916
    sym = (char *)tmp___5;
    }
#line 3917
    if (! sym) {
#line 3919
      if (lt_dlmutex_seterror_func) {
        {
#line 3919
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[13]);
        }
      } else {
#line 3919
        lt_dllast_error = lt_dlerror_strings[13];
      }
#line 3920
      return ((void *)0);
    }
  }
#line 3924
  data = (handle->loader)->dlloader_data;
#line 3925
  if (handle->info.name) {
#line 3929
    if (lt_dlmutex_seterror_func) {
      {
#line 3929
      saved_error = (*lt_dlmutex_geterror_func)();
      }
    } else {
#line 3929
      saved_error = lt_dllast_error;
    }
#line 3932
    if ((handle->loader)->sym_prefix) {
      {
#line 3934
      strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)(handle->loader)->sym_prefix);
#line 3935
      strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)handle->info.name);
      }
    } else {
      {
#line 3939
      strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)handle->info.name);
      }
    }
    {
#line 3942
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)"_LTX_");
#line 3943
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
#line 3946
    address = (*((handle->loader)->find_sym))(data, handle->module, (char const   *)sym);
    }
#line 3947
    if (address) {
#line 3949
      if ((unsigned long )sym != (unsigned long )(lsym)) {
#line 3951
        if (sym) {
          {
#line 3951
          (*lt_dlfree)((void *)sym);
#line 3951
          sym = (char *)((void *)0);
          }
        }
      }
#line 3953
      return (address);
    }
#line 3955
    if (lt_dlmutex_seterror_func) {
      {
#line 3955
      (*lt_dlmutex_seterror_func)(saved_error);
      }
    } else {
#line 3955
      lt_dllast_error = saved_error;
    }
  }
#line 3959
  if ((handle->loader)->sym_prefix) {
    {
#line 3961
    strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)(handle->loader)->sym_prefix);
#line 3962
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
    }
  } else {
    {
#line 3966
    strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
    }
  }
  {
#line 3969
  address = (*((handle->loader)->find_sym))(data, handle->module, (char const   *)sym);
  }
#line 3970
  if ((unsigned long )sym != (unsigned long )(lsym)) {
#line 3972
    if (sym) {
      {
#line 3972
      (*lt_dlfree)((void *)sym);
#line 3972
      sym = (char *)((void *)0);
      }
    }
  }
#line 3975
  return (address);
}
}
#line 3978 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
char const   *lt_dlerror(void) 
{ 
  char const   *error ;
  char const   *tmp ;

  {
#line 3983
  if (lt_dlmutex_seterror_func) {
    {
#line 3983
    error = (*lt_dlmutex_geterror_func)();
    }
  } else {
#line 3983
    error = lt_dllast_error;
  }
#line 3984
  if (lt_dlmutex_seterror_func) {
    {
#line 3984
    (*lt_dlmutex_seterror_func)((char const   *)0);
    }
  } else {
#line 3984
    lt_dllast_error = (char const   *)0;
  }
#line 3986
  if (error) {
#line 3986
    tmp = error;
  } else {
#line 3986
    tmp = (char const   *)((void *)0);
  }
#line 3986
  return (tmp);
}
}
#line 3989 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static int lt_dlpath_insertdir(char **ppath , char *before , char const   *dir ) 
{ 
  int errors ;
  char *canonical ;
  char *argz ;
  size_t argz_len ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 3995
  errors = 0;
#line 3996
  canonical = (char *)0;
#line 3997
  argz = (char *)0;
#line 3998
  argz_len = (size_t )0;
#line 4000
  if (! ppath) {
    {
#line 4000
    __assert_fail("ppath", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  4000U, "lt_dlpath_insertdir");
    }
  }
#line 4001
  if (dir) {
#line 4001
    if (! *dir) {
      {
#line 4001
      __assert_fail("dir && *dir", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    4001U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 4001
    __assert_fail("dir && *dir", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  4001U, "lt_dlpath_insertdir");
    }
  }
  {
#line 4003
  tmp = canonicalize_path(dir, & canonical);
  }
#line 4003
  if (tmp != 0) {
#line 4005
    errors ++;
#line 4006
    goto cleanup;
  }
#line 4009
  if (canonical) {
#line 4009
    if (! *canonical) {
      {
#line 4009
      __assert_fail("canonical && *canonical", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    4009U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 4009
    __assert_fail("canonical && *canonical", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  4009U, "lt_dlpath_insertdir");
    }
  }
#line 4012
  if ((unsigned long )*ppath == (unsigned long )((char *)0)) {
#line 4014
    if (! (! before)) {
      {
#line 4014
      __assert_fail("!before", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    4014U, "lt_dlpath_insertdir");
      }
    }
#line 4015
    if (! dir) {
      {
#line 4015
      __assert_fail("dir", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    4015U, "lt_dlpath_insertdir");
      }
    }
    {
#line 4017
    *ppath = lt_estrdup(dir);
    }
#line 4018
    if ((unsigned long )*ppath == (unsigned long )((char *)0)) {
#line 4019
      errors ++;
    }
#line 4021
    return (errors);
  }
#line 4024
  if (ppath) {
#line 4024
    if (! *ppath) {
      {
#line 4024
      __assert_fail("ppath && *ppath", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    4024U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 4024
    __assert_fail("ppath && *ppath", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                  4024U, "lt_dlpath_insertdir");
    }
  }
  {
#line 4026
  tmp___0 = argzize_path((char const   *)*ppath, & argz, & argz_len);
  }
#line 4026
  if (tmp___0 != 0) {
#line 4028
    errors ++;
#line 4029
    goto cleanup;
  }
#line 4037
  if (before) {
#line 4039
    if (! ((unsigned long )*ppath <= (unsigned long )before)) {
      {
#line 4039
      __assert_fail("*ppath <= before", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    4039U, "lt_dlpath_insertdir");
      }
    }
    {
#line 4040
    tmp___1 = strlen((char const   *)*ppath);
    }
#line 4040
    if (! ((size_t )(before - *ppath) <= tmp___1)) {
      {
#line 4040
      __assert_fail("before - *ppath <= strlen (*ppath)", "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c",
                    4040U, "lt_dlpath_insertdir");
      }
    }
#line 4042
    before = argz + (before - *ppath);
  }
  {
#line 4045
  tmp___2 = lt_argz_insert(& argz, & argz_len, before, dir);
  }
#line 4045
  if (tmp___2 != 0) {
#line 4047
    errors ++;
#line 4048
    goto cleanup;
  }
  {
#line 4051
  argz_stringify(argz, argz_len, ':');
  }
#line 4052
  if ((unsigned long )*ppath != (unsigned long )argz) {
#line 4052
    if (*ppath) {
      {
#line 4052
      (*lt_dlfree)((void *)*ppath);
      }
    }
#line 4052
    *ppath = argz;
#line 4052
    argz = (char *)0;
  }
  cleanup: 
#line 4055
  if (canonical) {
    {
#line 4055
    (*lt_dlfree)((void *)canonical);
#line 4055
    canonical = (char *)((void *)0);
    }
  }
#line 4056
  if (argz) {
    {
#line 4056
    (*lt_dlfree)((void *)argz);
#line 4056
    argz = (char *)((void *)0);
    }
  }
#line 4058
  return (errors);
}
}
#line 4061 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dladdsearchdir(char const   *search_dir ) 
{ 
  int errors ;
  int tmp ;

  {
#line 4065
  errors = 0;
#line 4067
  if (search_dir) {
#line 4067
    if (*search_dir) {
#line 4069
      if (lt_dlmutex_lock_func) {
        {
#line 4069
        (*lt_dlmutex_lock_func)();
        }
      }
      {
#line 4070
      tmp = lt_dlpath_insertdir(& user_search_path, (char *)0, search_dir);
      }
#line 4070
      if (tmp != 0) {
#line 4071
        errors ++;
      }
#line 4072
      if (lt_dlmutex_unlock_func) {
        {
#line 4072
        (*lt_dlmutex_unlock_func)();
        }
      }
    }
  }
#line 4075
  return (errors);
}
}
#line 4078 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlinsertsearchdir(char const   *before , char const   *search_dir ) 
{ 
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 4083
  errors = 0;
#line 4085
  if (before) {
#line 4087
    if (lt_dlmutex_lock_func) {
      {
#line 4087
      (*lt_dlmutex_lock_func)();
      }
    }
#line 4088
    if ((unsigned long )before < (unsigned long )user_search_path) {
#line 4088
      goto _L;
    } else {
#line 4088
      if (user_search_path) {
#line 4088
        if (*(user_search_path + 0)) {
          {
#line 4088
          tmp = strlen((char const   *)user_search_path);
#line 4088
          tmp___0 = tmp;
          }
        } else {
#line 4088
          tmp___0 = (size_t )0;
        }
      } else {
#line 4088
        tmp___0 = (size_t )0;
      }
#line 4088
      if ((unsigned long )before >= (unsigned long )(user_search_path + tmp___0)) {
        _L: /* CIL Label */ 
#line 4091
        if (lt_dlmutex_unlock_func) {
          {
#line 4091
          (*lt_dlmutex_unlock_func)();
          }
        }
#line 4092
        if (lt_dlmutex_seterror_func) {
          {
#line 4092
          (*lt_dlmutex_seterror_func)(lt_dlerror_strings[18]);
          }
        } else {
#line 4092
          lt_dllast_error = lt_dlerror_strings[18];
        }
#line 4093
        return (1);
      }
    }
#line 4095
    if (lt_dlmutex_unlock_func) {
      {
#line 4095
      (*lt_dlmutex_unlock_func)();
      }
    }
  }
#line 4098
  if (search_dir) {
#line 4098
    if (*search_dir) {
#line 4100
      if (lt_dlmutex_lock_func) {
        {
#line 4100
        (*lt_dlmutex_lock_func)();
        }
      }
      {
#line 4101
      tmp___1 = lt_dlpath_insertdir(& user_search_path, (char *)before, search_dir);
      }
#line 4101
      if (tmp___1 != 0) {
#line 4104
        errors ++;
      }
#line 4106
      if (lt_dlmutex_unlock_func) {
        {
#line 4106
        (*lt_dlmutex_unlock_func)();
        }
      }
    }
  }
#line 4109
  return (errors);
}
}
#line 4112 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlsetsearchpath(char const   *search_path ) 
{ 
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 4116
  errors = 0;
#line 4118
  if (lt_dlmutex_lock_func) {
    {
#line 4118
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4119
  if (user_search_path) {
    {
#line 4119
    (*lt_dlfree)((void *)user_search_path);
#line 4119
    user_search_path = (char *)((void *)0);
    }
  }
#line 4120
  if (lt_dlmutex_unlock_func) {
    {
#line 4120
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4122
  if (! search_path) {
#line 4124
    return (errors);
  } else {
#line 4122
    if (search_path) {
#line 4122
      if (*(search_path + 0)) {
        {
#line 4122
        tmp = strlen(search_path);
#line 4122
        tmp___0 = tmp;
        }
      } else {
#line 4122
        tmp___0 = (size_t )0;
      }
    } else {
#line 4122
      tmp___0 = (size_t )0;
    }
#line 4122
    if (! tmp___0) {
#line 4124
      return (errors);
    }
  }
#line 4127
  if (lt_dlmutex_lock_func) {
    {
#line 4127
    (*lt_dlmutex_lock_func)();
    }
  }
  {
#line 4128
  tmp___1 = canonicalize_path(search_path, & user_search_path);
  }
#line 4128
  if (tmp___1 != 0) {
#line 4129
    errors ++;
  }
#line 4130
  if (lt_dlmutex_unlock_func) {
    {
#line 4130
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4132
  return (errors);
}
}
#line 4135 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
char const   *lt_dlgetsearchpath(void) 
{ 
  char const   *saved_path ;

  {
#line 4140
  if (lt_dlmutex_lock_func) {
    {
#line 4140
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4141
  saved_path = (char const   *)user_search_path;
#line 4142
  if (lt_dlmutex_unlock_func) {
    {
#line 4142
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4144
  return (saved_path);
}
}
#line 4147 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlmakeresident(lt_dlhandle handle ) 
{ 
  int errors ;

  {
#line 4151
  errors = 0;
#line 4153
  if (! handle) {
#line 4155
    if (lt_dlmutex_seterror_func) {
      {
#line 4155
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[12]);
      }
    } else {
#line 4155
      lt_dllast_error = lt_dlerror_strings[12];
    }
#line 4156
    errors ++;
  } else {
#line 4160
    handle->flags |= 1;
  }
#line 4163
  return (errors);
}
}
#line 4166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlisresident(lt_dlhandle handle ) 
{ 


  {
#line 4170
  if (! handle) {
#line 4172
    if (lt_dlmutex_seterror_func) {
      {
#line 4172
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[12]);
      }
    } else {
#line 4172
      lt_dllast_error = lt_dlerror_strings[12];
    }
#line 4173
    return (-1);
  }
#line 4176
  return ((handle->flags & 1) == 1);
}
}
#line 4184 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
lt_dlinfo const   *lt_dlgetinfo(lt_dlhandle handle ) 
{ 


  {
#line 4188
  if (! handle) {
#line 4190
    if (lt_dlmutex_seterror_func) {
      {
#line 4190
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[12]);
      }
    } else {
#line 4190
      lt_dllast_error = lt_dlerror_strings[12];
    }
#line 4191
    return ((lt_dlinfo const   *)0);
  }
#line 4194
  return ((lt_dlinfo const   *)(& handle->info));
}
}
#line 4197 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
lt_dlhandle lt_dlhandle_next(lt_dlhandle place ) 
{ 
  struct lt_dlhandle_struct *tmp ;

  {
#line 4201
  if (place) {
#line 4201
    tmp = place->next;
  } else {
#line 4201
    tmp = handles;
  }
#line 4201
  return (tmp);
}
}
#line 4204 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlforeach(int (*func)(lt_dlhandle handle , void *data ) , void *data ) 
{ 
  int errors ;
  lt_dlhandle cur ;
  lt_dlhandle tmp ;
  int tmp___0 ;

  {
#line 4209
  errors = 0;
#line 4212
  if (lt_dlmutex_lock_func) {
    {
#line 4212
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4214
  cur = handles;
  {
#line 4215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4215
    if (! cur) {
#line 4215
      goto while_break;
    }
    {
#line 4217
    tmp = cur;
#line 4219
    cur = cur->next;
#line 4220
    tmp___0 = (*func)(tmp, data);
    }
#line 4220
    if (tmp___0) {
#line 4222
      errors ++;
#line 4223
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4227
  if (lt_dlmutex_unlock_func) {
    {
#line 4227
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4229
  return (errors);
}
}
#line 4235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
static lt_dlcaller_id last_caller_id  =    (lt_dlcaller_id )0;
#line 4232 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
lt_dlcaller_id lt_dlcaller_register(void) 
{ 
  int result ;

  {
#line 4238
  if (lt_dlmutex_lock_func) {
    {
#line 4238
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4239
  last_caller_id ++;
#line 4239
  result = (int )last_caller_id;
#line 4240
  if (lt_dlmutex_unlock_func) {
    {
#line 4240
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4242
  return ((lt_dlcaller_id )result);
}
}
#line 4245 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
void *lt_dlcaller_set_data(lt_dlcaller_id key , lt_dlhandle handle , void *data ) 
{ 
  int n_elements ;
  void *stale ;
  int i ;
  lt_caller_data *temp ;
  void *tmp ;

  {
#line 4251
  n_elements = 0;
#line 4252
  stale = (void *)0;
#line 4257
  if (lt_dlmutex_lock_func) {
    {
#line 4257
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4259
  if (handle->caller_data) {
    {
#line 4260
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4260
      if (! (handle->caller_data + n_elements)->key) {
#line 4260
        goto while_break;
      }
#line 4261
      n_elements ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 4263
  i = 0;
  {
#line 4263
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4263
    if (! (i < n_elements)) {
#line 4263
      goto while_break___0;
    }
#line 4265
    if ((handle->caller_data + i)->key == key) {
#line 4267
      stale = (handle->caller_data + i)->data;
#line 4268
      goto while_break___0;
    }
#line 4263
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4274
  if (i == n_elements) {
    {
#line 4276
    tmp = (*lt_dlrealloc)((void *)handle->caller_data, (unsigned long )(2 + n_elements) * sizeof(lt_caller_data ));
#line 4276
    temp = (lt_caller_data *)tmp;
    }
#line 4279
    if (! temp) {
#line 4281
      stale = (void *)0;
#line 4282
      goto done;
    }
#line 4285
    handle->caller_data = temp;
#line 4288
    (handle->caller_data + i)->key = key;
#line 4289
    (handle->caller_data + (1 + i))->key = (lt_dlcaller_id )0;
  }
#line 4292
  (handle->caller_data + i)->data = data;
  done: 
#line 4295
  if (lt_dlmutex_unlock_func) {
    {
#line 4295
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4297
  return (stale);
}
}
#line 4300 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
void *lt_dlcaller_get_data(lt_dlcaller_id key , lt_dlhandle handle ) 
{ 
  void *result ;
  int i ;

  {
#line 4305
  result = (void *)0;
#line 4309
  if (lt_dlmutex_lock_func) {
    {
#line 4309
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4314
  i = 0;
  {
#line 4314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4314
    if (! (handle->caller_data + i)->key) {
#line 4314
      goto while_break;
    }
#line 4316
    if ((handle->caller_data + i)->key == key) {
#line 4318
      result = (handle->caller_data + i)->data;
#line 4319
      goto while_break;
    }
#line 4314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4324
  if (lt_dlmutex_unlock_func) {
    {
#line 4324
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4326
  return (result);
}
}
#line 4334 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlloader_add(lt_dlloader *place , struct lt_user_dlloader  const  *dlloader ,
                    char const   *loader_name ) 
{ 
  int errors ;
  lt_dlloader *node ;
  lt_dlloader *ptr ;
  void *tmp ;

  {
#line 4340
  errors = 0;
#line 4341
  node = (lt_dlloader *)0;
#line 4341
  ptr = (lt_dlloader *)0;
#line 4343
  if ((unsigned long )dlloader == (unsigned long )((struct lt_user_dlloader  const  *)0)) {
#line 4343
    goto _L;
  } else
#line 4343
  if ((unsigned long )dlloader->module_open == (unsigned long )((lt_module_open */* const  */)0)) {
#line 4343
    goto _L;
  } else
#line 4343
  if ((unsigned long )dlloader->module_close == (unsigned long )((lt_module_close */* const  */)0)) {
#line 4343
    goto _L;
  } else
#line 4343
  if ((unsigned long )dlloader->find_sym == (unsigned long )((lt_find_sym */* const  */)0)) {
    _L: /* CIL Label */ 
#line 4348
    if (lt_dlmutex_seterror_func) {
      {
#line 4348
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[2]);
      }
    } else {
#line 4348
      lt_dllast_error = lt_dlerror_strings[2];
    }
#line 4349
    return (1);
  }
  {
#line 4353
  tmp = lt_emalloc(sizeof(lt_dlloader ));
#line 4353
  node = (lt_dlloader *)tmp;
  }
#line 4354
  if (! node) {
#line 4355
    return (1);
  }
#line 4357
  node->next = (struct lt_dlloader *)0;
#line 4358
  node->loader_name = loader_name;
#line 4359
  node->sym_prefix = (char const   *)dlloader->sym_prefix;
#line 4360
  node->dlloader_exit = (lt_dlloader_exit *)dlloader->dlloader_exit;
#line 4361
  node->module_open = (lt_module_open *)dlloader->module_open;
#line 4362
  node->module_close = (lt_module_close *)dlloader->module_close;
#line 4363
  node->find_sym = (lt_find_sym *)dlloader->find_sym;
#line 4364
  node->dlloader_data = (lt_user_data )dlloader->dlloader_data;
#line 4366
  if (lt_dlmutex_lock_func) {
    {
#line 4366
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4367
  if (! loaders) {
#line 4370
    loaders = node;
  } else
#line 4372
  if (! place) {
#line 4376
    ptr = loaders;
    {
#line 4376
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4376
      if (! ptr->next) {
#line 4376
        goto while_break;
      }
#line 4376
      ptr = ptr->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 4381
    ptr->next = node;
  } else
#line 4383
  if ((unsigned long )loaders == (unsigned long )place) {
#line 4386
    node->next = place;
#line 4387
    loaders = node;
  } else {
#line 4392
    ptr = loaders;
    {
#line 4392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4392
      if (! ((unsigned long )ptr->next != (unsigned long )place)) {
#line 4392
        goto while_break___0;
      }
#line 4392
      ptr = ptr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4397
    if ((unsigned long )ptr->next != (unsigned long )place) {
#line 4399
      if (lt_dlmutex_seterror_func) {
        {
#line 4399
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[2]);
        }
      } else {
#line 4399
        lt_dllast_error = lt_dlerror_strings[2];
      }
#line 4400
      errors ++;
    } else {
#line 4405
      node->next = place;
#line 4406
      ptr->next = node;
    }
  }
#line 4410
  if (lt_dlmutex_unlock_func) {
    {
#line 4410
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4412
  return (errors);
}
}
#line 4415 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
int lt_dlloader_remove(char const   *loader_name ) 
{ 
  lt_dlloader *place ;
  lt_dlloader *tmp ;
  lt_dlhandle handle ;
  int errors ;
  lt_dlloader *prev ;
  int tmp___0 ;

  {
  {
#line 4419
  tmp = lt_dlloader_find(loader_name);
#line 4419
  place = tmp;
#line 4421
  errors = 0;
  }
#line 4423
  if (! place) {
#line 4425
    if (lt_dlmutex_seterror_func) {
      {
#line 4425
      (*lt_dlmutex_seterror_func)(lt_dlerror_strings[2]);
      }
    } else {
#line 4425
      lt_dllast_error = lt_dlerror_strings[2];
    }
#line 4426
    return (1);
  }
#line 4429
  if (lt_dlmutex_lock_func) {
    {
#line 4429
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4432
  handle = handles;
  {
#line 4432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4432
    if (! handle) {
#line 4432
      goto while_break;
    }
#line 4434
    if ((unsigned long )handle->loader == (unsigned long )place) {
#line 4436
      if (lt_dlmutex_seterror_func) {
        {
#line 4436
        (*lt_dlmutex_seterror_func)(lt_dlerror_strings[4]);
        }
      } else {
#line 4436
        lt_dllast_error = lt_dlerror_strings[4];
      }
#line 4437
      errors ++;
#line 4438
      goto done;
    }
#line 4432
    handle = handle->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4442
  if ((unsigned long )place == (unsigned long )loaders) {
#line 4445
    loaders = loaders->next;
  } else {
#line 4451
    prev = loaders;
    {
#line 4451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4451
      if (! prev->next) {
#line 4451
        goto while_break___0;
      }
      {
#line 4453
      tmp___0 = strcmp((prev->next)->loader_name, loader_name);
      }
#line 4453
      if (! tmp___0) {
#line 4455
        goto while_break___0;
      }
#line 4451
      prev = prev->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4459
    place = prev->next;
#line 4460
    prev->next = (prev->next)->next;
  }
#line 4463
  if (place->dlloader_exit) {
    {
#line 4465
    errors = (*(place->dlloader_exit))(place->dlloader_data);
    }
  }
#line 4468
  if (place) {
    {
#line 4468
    (*lt_dlfree)((void *)place);
#line 4468
    place = (lt_dlloader *)((void *)0);
    }
  }
  done: 
#line 4471
  if (lt_dlmutex_unlock_func) {
    {
#line 4471
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4473
  return (errors);
}
}
#line 4476 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
lt_dlloader *lt_dlloader_next(lt_dlloader *place ) 
{ 
  lt_dlloader *next ;

  {
#line 4482
  if (lt_dlmutex_lock_func) {
    {
#line 4482
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4483
  if (place) {
#line 4483
    next = place->next;
  } else {
#line 4483
    next = loaders;
  }
#line 4484
  if (lt_dlmutex_unlock_func) {
    {
#line 4484
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4486
  return (next);
}
}
#line 4489 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
char const   *lt_dlloader_name(lt_dlloader *place ) 
{ 
  char const   *name ;

  {
#line 4493
  name = (char const   *)0;
#line 4495
  if (place) {
#line 4497
    if (lt_dlmutex_lock_func) {
      {
#line 4497
      (*lt_dlmutex_lock_func)();
      }
    }
#line 4498
    if (place) {
#line 4498
      name = place->loader_name;
    } else {
#line 4498
      name = (char const   *)0;
    }
#line 4499
    if (lt_dlmutex_unlock_func) {
      {
#line 4499
      (*lt_dlmutex_unlock_func)();
      }
    }
  } else
#line 4503
  if (lt_dlmutex_seterror_func) {
    {
#line 4503
    (*lt_dlmutex_seterror_func)(lt_dlerror_strings[2]);
    }
  } else {
#line 4503
    lt_dllast_error = lt_dlerror_strings[2];
  }
#line 4506
  return (name);
}
}
#line 4509 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
lt_user_data *lt_dlloader_data(lt_dlloader *place ) 
{ 
  lt_user_data *data ;

  {
#line 4513
  data = (lt_user_data *)0;
#line 4515
  if (place) {
#line 4517
    if (lt_dlmutex_lock_func) {
      {
#line 4517
      (*lt_dlmutex_lock_func)();
      }
    }
#line 4518
    if (place) {
#line 4518
      data = & place->dlloader_data;
    } else {
#line 4518
      data = (lt_user_data *)0;
    }
#line 4519
    if (lt_dlmutex_unlock_func) {
      {
#line 4519
      (*lt_dlmutex_unlock_func)();
      }
    }
  } else
#line 4523
  if (lt_dlmutex_seterror_func) {
    {
#line 4523
    (*lt_dlmutex_seterror_func)(lt_dlerror_strings[2]);
    }
  } else {
#line 4523
    lt_dllast_error = lt_dlerror_strings[2];
  }
#line 4526
  return (data);
}
}
#line 4529 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/libltdl/ltdl.c"
lt_dlloader *lt_dlloader_find(char const   *loader_name ) 
{ 
  lt_dlloader *place ;
  int tmp ;

  {
#line 4533
  place = (lt_dlloader *)0;
#line 4535
  if (lt_dlmutex_lock_func) {
    {
#line 4535
    (*lt_dlmutex_lock_func)();
    }
  }
#line 4536
  place = loaders;
  {
#line 4536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4536
    if (! place) {
#line 4536
      goto while_break;
    }
    {
#line 4538
    tmp = strcmp(place->loader_name, loader_name);
    }
#line 4538
    if (tmp == 0) {
#line 4540
      goto while_break;
    }
#line 4536
    place = place->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4543
  if (lt_dlmutex_unlock_func) {
    {
#line 4543
    (*lt_dlmutex_unlock_func)();
    }
  }
#line 4545
  return (place);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 434 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
void fr_isaac(fr_randctx *ctx ) ;
#line 435
void fr_randinit(fr_randctx *ctx , int flag ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
void fr_isaac(fr_randctx *ctx ) 
{ 
  register uint32_t a ;
  register uint32_t b ;
  register uint32_t x ;
  register uint32_t y ;
  register uint32_t *m ;
  register uint32_t *mm ;
  register uint32_t *m2 ;
  register uint32_t *r ;
  register uint32_t *mend ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t *tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t *tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t *tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t *tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t *tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t *tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t *tmp___22 ;

  {
#line 33
  mm = ctx->randmem;
#line 33
  r = ctx->randrsl;
#line 34
  a = ctx->randa;
#line 34
  (ctx->randc) ++;
#line 34
  b = (ctx->randb + ctx->randc) & 4294967295U;
#line 35
  m = mm;
#line 35
  m2 = m + (1 << 8) / 2;
#line 35
  mend = m2;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((unsigned long )m < (unsigned long )mend)) {
#line 35
      goto while_break;
    }
#line 37
    x = *m;
#line 37
    tmp = m2;
#line 37
    m2 ++;
#line 37
    a = ((a ^ (a << 13)) + *tmp) & 4294967295U;
#line 37
    tmp___0 = m;
#line 37
    m ++;
#line 37
    y = ((*(mm + ((x >> 2) & (unsigned int )((1 << 8) - 1))) + a) + b) & 4294967295U;
#line 37
    *tmp___0 = y;
#line 37
    tmp___1 = r;
#line 37
    r ++;
#line 37
    b = (*(mm + (((y >> 8) >> 2) & (unsigned int )((1 << 8) - 1))) + x) & 4294967295U;
#line 37
    *tmp___1 = b;
#line 38
    x = *m;
#line 38
    tmp___2 = m2;
#line 38
    m2 ++;
#line 38
    a = ((a ^ (a >> 6)) + *tmp___2) & 4294967295U;
#line 38
    tmp___3 = m;
#line 38
    m ++;
#line 38
    y = ((*(mm + ((x >> 2) & (unsigned int )((1 << 8) - 1))) + a) + b) & 4294967295U;
#line 38
    *tmp___3 = y;
#line 38
    tmp___4 = r;
#line 38
    r ++;
#line 38
    b = (*(mm + (((y >> 8) >> 2) & (unsigned int )((1 << 8) - 1))) + x) & 4294967295U;
#line 38
    *tmp___4 = b;
#line 39
    x = *m;
#line 39
    tmp___5 = m2;
#line 39
    m2 ++;
#line 39
    a = ((a ^ (a << 2)) + *tmp___5) & 4294967295U;
#line 39
    tmp___6 = m;
#line 39
    m ++;
#line 39
    y = ((*(mm + ((x >> 2) & (unsigned int )((1 << 8) - 1))) + a) + b) & 4294967295U;
#line 39
    *tmp___6 = y;
#line 39
    tmp___7 = r;
#line 39
    r ++;
#line 39
    b = (*(mm + (((y >> 8) >> 2) & (unsigned int )((1 << 8) - 1))) + x) & 4294967295U;
#line 39
    *tmp___7 = b;
#line 40
    x = *m;
#line 40
    tmp___8 = m2;
#line 40
    m2 ++;
#line 40
    a = ((a ^ (a >> 16)) + *tmp___8) & 4294967295U;
#line 40
    tmp___9 = m;
#line 40
    m ++;
#line 40
    y = ((*(mm + ((x >> 2) & (unsigned int )((1 << 8) - 1))) + a) + b) & 4294967295U;
#line 40
    *tmp___9 = y;
#line 40
    tmp___10 = r;
#line 40
    r ++;
#line 40
    b = (*(mm + (((y >> 8) >> 2) & (unsigned int )((1 << 8) - 1))) + x) & 4294967295U;
#line 40
    *tmp___10 = b;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  m2 = mm;
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 42
    if (! ((unsigned long )m2 < (unsigned long )mend)) {
#line 42
      goto while_break___0;
    }
#line 44
    x = *m;
#line 44
    tmp___11 = m2;
#line 44
    m2 ++;
#line 44
    a = ((a ^ (a << 13)) + *tmp___11) & 4294967295U;
#line 44
    tmp___12 = m;
#line 44
    m ++;
#line 44
    y = ((*(mm + ((x >> 2) & (unsigned int )((1 << 8) - 1))) + a) + b) & 4294967295U;
#line 44
    *tmp___12 = y;
#line 44
    tmp___13 = r;
#line 44
    r ++;
#line 44
    b = (*(mm + (((y >> 8) >> 2) & (unsigned int )((1 << 8) - 1))) + x) & 4294967295U;
#line 44
    *tmp___13 = b;
#line 45
    x = *m;
#line 45
    tmp___14 = m2;
#line 45
    m2 ++;
#line 45
    a = ((a ^ (a >> 6)) + *tmp___14) & 4294967295U;
#line 45
    tmp___15 = m;
#line 45
    m ++;
#line 45
    y = ((*(mm + ((x >> 2) & (unsigned int )((1 << 8) - 1))) + a) + b) & 4294967295U;
#line 45
    *tmp___15 = y;
#line 45
    tmp___16 = r;
#line 45
    r ++;
#line 45
    b = (*(mm + (((y >> 8) >> 2) & (unsigned int )((1 << 8) - 1))) + x) & 4294967295U;
#line 45
    *tmp___16 = b;
#line 46
    x = *m;
#line 46
    tmp___17 = m2;
#line 46
    m2 ++;
#line 46
    a = ((a ^ (a << 2)) + *tmp___17) & 4294967295U;
#line 46
    tmp___18 = m;
#line 46
    m ++;
#line 46
    y = ((*(mm + ((x >> 2) & (unsigned int )((1 << 8) - 1))) + a) + b) & 4294967295U;
#line 46
    *tmp___18 = y;
#line 46
    tmp___19 = r;
#line 46
    r ++;
#line 46
    b = (*(mm + (((y >> 8) >> 2) & (unsigned int )((1 << 8) - 1))) + x) & 4294967295U;
#line 46
    *tmp___19 = b;
#line 47
    x = *m;
#line 47
    tmp___20 = m2;
#line 47
    m2 ++;
#line 47
    a = ((a ^ (a >> 16)) + *tmp___20) & 4294967295U;
#line 47
    tmp___21 = m;
#line 47
    m ++;
#line 47
    y = ((*(mm + ((x >> 2) & (unsigned int )((1 << 8) - 1))) + a) + b) & 4294967295U;
#line 47
    *tmp___21 = y;
#line 47
    tmp___22 = r;
#line 47
    r ++;
#line 47
    b = (*(mm + (((y >> 8) >> 2) & (unsigned int )((1 << 8) - 1))) + x) & 4294967295U;
#line 47
    *tmp___22 = b;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 49
  ctx->randb = b;
#line 49
  ctx->randa = a;
#line 50
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
void fr_randinit(fr_randctx *ctx , int flag ) 
{ 
  int i ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;
  uint32_t *m ;
  uint32_t *r ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 71
  tmp___0 = (uint32_t )0;
#line 71
  ctx->randc = tmp___0;
#line 71
  tmp = tmp___0;
#line 71
  ctx->randb = tmp;
#line 71
  ctx->randa = tmp;
#line 72
  m = ctx->randmem;
#line 73
  r = ctx->randrsl;
#line 74
  h = 2654435769U;
#line 74
  g = h;
#line 74
  f = g;
#line 74
  e = f;
#line 74
  d = e;
#line 74
  c = d;
#line 74
  b = c;
#line 74
  a = b;
#line 76
  i = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < 4)) {
#line 76
      goto while_break;
    }
#line 77
    a ^= b << 11;
#line 77
    d += a;
#line 77
    b += c;
#line 77
    b ^= c >> 2;
#line 77
    e += b;
#line 77
    c += d;
#line 77
    c ^= d << 8;
#line 77
    f += c;
#line 77
    d += e;
#line 77
    d ^= e >> 16;
#line 77
    g += d;
#line 77
    e += f;
#line 77
    e ^= f << 10;
#line 77
    h += e;
#line 77
    f += g;
#line 77
    f ^= g >> 4;
#line 77
    a += f;
#line 77
    g += h;
#line 77
    g ^= h << 8;
#line 77
    b += g;
#line 77
    h += a;
#line 77
    h ^= a >> 9;
#line 77
    c += h;
#line 77
    a += b;
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  if (flag) {
#line 82
    i = 0;
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      if (! (i < 1 << 8)) {
#line 82
        goto while_break___0;
      }
#line 83
      a += *(r + i);
#line 83
      b += *(r + (i + 1));
#line 83
      c += *(r + (i + 2));
#line 83
      d += *(r + (i + 3));
#line 84
      e += *(r + (i + 4));
#line 84
      f += *(r + (i + 5));
#line 84
      g += *(r + (i + 6));
#line 84
      h += *(r + (i + 7));
#line 85
      a ^= b << 11;
#line 85
      d += a;
#line 85
      b += c;
#line 85
      b ^= c >> 2;
#line 85
      e += b;
#line 85
      c += d;
#line 85
      c ^= d << 8;
#line 85
      f += c;
#line 85
      d += e;
#line 85
      d ^= e >> 16;
#line 85
      g += d;
#line 85
      e += f;
#line 85
      e ^= f << 10;
#line 85
      h += e;
#line 85
      f += g;
#line 85
      f ^= g >> 4;
#line 85
      a += f;
#line 85
      g += h;
#line 85
      g ^= h << 8;
#line 85
      b += g;
#line 85
      h += a;
#line 85
      h ^= a >> 9;
#line 85
      c += h;
#line 85
      a += b;
#line 86
      *(m + i) = a;
#line 86
      *(m + (i + 1)) = b;
#line 86
      *(m + (i + 2)) = c;
#line 86
      *(m + (i + 3)) = d;
#line 87
      *(m + (i + 4)) = e;
#line 87
      *(m + (i + 5)) = f;
#line 87
      *(m + (i + 6)) = g;
#line 87
      *(m + (i + 7)) = h;
#line 82
      i += 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    i = 0;
    {
#line 90
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 90
      if (! (i < 1 << 8)) {
#line 90
        goto while_break___1;
      }
#line 91
      a += *(m + i);
#line 91
      b += *(m + (i + 1));
#line 91
      c += *(m + (i + 2));
#line 91
      d += *(m + (i + 3));
#line 92
      e += *(m + (i + 4));
#line 92
      f += *(m + (i + 5));
#line 92
      g += *(m + (i + 6));
#line 92
      h += *(m + (i + 7));
#line 93
      a ^= b << 11;
#line 93
      d += a;
#line 93
      b += c;
#line 93
      b ^= c >> 2;
#line 93
      e += b;
#line 93
      c += d;
#line 93
      c ^= d << 8;
#line 93
      f += c;
#line 93
      d += e;
#line 93
      d ^= e >> 16;
#line 93
      g += d;
#line 93
      e += f;
#line 93
      e ^= f << 10;
#line 93
      h += e;
#line 93
      f += g;
#line 93
      f ^= g >> 4;
#line 93
      a += f;
#line 93
      g += h;
#line 93
      g ^= h << 8;
#line 93
      b += g;
#line 93
      h += a;
#line 93
      h ^= a >> 9;
#line 93
      c += h;
#line 93
      a += b;
#line 94
      *(m + i) = a;
#line 94
      *(m + (i + 1)) = b;
#line 94
      *(m + (i + 2)) = c;
#line 94
      *(m + (i + 3)) = d;
#line 95
      *(m + (i + 4)) = e;
#line 95
      *(m + (i + 5)) = f;
#line 95
      *(m + (i + 6)) = g;
#line 95
      *(m + (i + 7)) = h;
#line 90
      i += 8;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 98
    i = 0;
    {
#line 98
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 98
      if (! (i < 1 << 8)) {
#line 98
        goto while_break___2;
      }
#line 100
      a ^= b << 11;
#line 100
      d += a;
#line 100
      b += c;
#line 100
      b ^= c >> 2;
#line 100
      e += b;
#line 100
      c += d;
#line 100
      c ^= d << 8;
#line 100
      f += c;
#line 100
      d += e;
#line 100
      d ^= e >> 16;
#line 100
      g += d;
#line 100
      e += f;
#line 100
      e ^= f << 10;
#line 100
      h += e;
#line 100
      f += g;
#line 100
      f ^= g >> 4;
#line 100
      a += f;
#line 100
      g += h;
#line 100
      g ^= h << 8;
#line 100
      b += g;
#line 100
      h += a;
#line 100
      h ^= a >> 9;
#line 100
      c += h;
#line 100
      a += b;
#line 101
      *(m + i) = a;
#line 101
      *(m + (i + 1)) = b;
#line 101
      *(m + (i + 2)) = c;
#line 101
      *(m + (i + 3)) = d;
#line 102
      *(m + (i + 4)) = e;
#line 102
      *(m + (i + 5)) = f;
#line 102
      *(m + (i + 6)) = g;
#line 102
      *(m + (i + 7)) = h;
#line 98
      i += 8;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 106
  fr_isaac(ctx);
#line 107
  ctx->randcnt = (uint32_t )(1 << 8);
  }
#line 108
  return;
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
void ( /* format attribute */  fr_strerror_printf)(char const   *fmt  , ...) ;
#line 374
int fr_dns_lookups ;
#line 375
int fr_debug_flag ;
#line 390
char const   *ip_ntoa(char *buffer , uint32_t ipaddr ) ;
#line 391
char *ifid_ntoa(char *buffer , size_t size , uint8_t *ifid ) ;
#line 392
uint8_t *ifid_aton(char const   *ifid_str , uint8_t *ifid ) ;
#line 393
int rad_lockfd(int fd , int lock_len ) ;
#line 394
int rad_lockfd_nonblock(int fd , int lock_len ) ;
#line 395
int rad_unlockfd(int fd , int lock_len ) ;
#line 396
void fr_bin2hex(uint8_t const   *bin , char *hex , size_t len ) ;
#line 397
size_t fr_hex2bin(char const   *hex , uint8_t *bin , size_t len ) ;
#line 405
int closefrom(int fd ) ;
#line 407
int fr_ipaddr_cmp(fr_ipaddr_t const   *a , fr_ipaddr_t const   *b ) ;
#line 409
int ip_hton(char const   *src , int af , fr_ipaddr_t *dst ) ;
#line 410
char const   *ip_ntoh(fr_ipaddr_t const   *src , char *dst , size_t cnt ) ;
#line 411
int fr_ipaddr2sockaddr(fr_ipaddr_t const   *ipaddr , int port , struct sockaddr_storage *sa ,
                       socklen_t *salen ) ;
#line 413
int fr_sockaddr2ipaddr(struct sockaddr_storage  const  *sa , socklen_t salen , fr_ipaddr_t *ipaddr ,
                       int *port ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int fr_dns_lookups  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int fr_debug_flag  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
char const   *ip_ntoa(char *buffer , uint32_t ipaddr ) 
{ 


  {
  {
#line 42
  ipaddr = ntohl(ipaddr);
#line 44
  sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%d.%d.%d.%d",
          (ipaddr >> 24) & 255U, (ipaddr >> 16) & 255U, (ipaddr >> 8) & 255U, ipaddr & 255U);
  }
#line 49
  return ((char const   *)buffer);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int rad_lockfd(int fd , int lock_len ) 
{ 
  int tmp ;

  {
  {
#line 64
  lock_len = lock_len;
#line 65
  tmp = flock(fd, 2);
  }
#line 65
  return (tmp);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int rad_lockfd_nonblock(int fd , int lock_len ) 
{ 
  int tmp ;

  {
  {
#line 90
  lock_len = lock_len;
#line 91
  tmp = flock(fd, 6);
  }
#line 91
  return (tmp);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int rad_unlockfd(int fd , int lock_len ) 
{ 
  int tmp ;

  {
  {
#line 116
  lock_len = lock_len;
#line 117
  tmp = flock(fd, 8);
  }
#line 117
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
char *ifid_ntoa(char *buffer , size_t size , uint8_t *ifid ) 
{ 


  {
  {
#line 136
  snprintf((char */* __restrict  */)buffer, size, (char const   */* __restrict  */)"%x:%x:%x:%x",
           ((int )*(ifid + 0) << 8) + (int )*(ifid + 1), ((int )*(ifid + 2) << 8) + (int )*(ifid + 3),
           ((int )*(ifid + 4) << 8) + (int )*(ifid + 5), ((int )*(ifid + 6) << 8) + (int )*(ifid + 7));
  }
#line 139
  return (buffer);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits[17]  = 
#line 149
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 147 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
uint8_t *ifid_aton(char const   *ifid_str , uint8_t *ifid ) 
{ 
  char const   *p ;
  char const   *pch ;
  int num_id ;
  int val ;
  int idx ;
  int tmp ;
  char *tmp___0 ;

  {
#line 151
  num_id = 0;
#line 151
  val = 0;
#line 151
  idx = 0;
#line 153
  p = ifid_str;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if ((int const   )*p == 58) {
#line 154
      goto _L;
    } else
#line 154
    if ((int const   )*p == 0) {
      _L: /* CIL Label */ 
#line 155
      if (num_id <= 0) {
#line 156
        return ((uint8_t *)((void *)0));
      }
#line 161
      *(ifid + idx) = (uint8_t )((val >> 8) & 255);
#line 162
      *(ifid + (idx + 1)) = (uint8_t )(val & 255);
#line 163
      if ((int const   )*p == 0) {
#line 168
        if (idx != 6) {
#line 169
          return ((uint8_t *)((void *)0));
        }
#line 170
        goto while_break;
      }
#line 172
      val = 0;
#line 173
      num_id = 0;
#line 174
      idx += 2;
#line 174
      if (idx > 6) {
#line 175
        return ((uint8_t *)((void *)0));
      }
    } else {
      {
#line 176
      tmp = tolower((int )*p);
#line 176
      tmp___0 = strchr(xdigits, tmp);
#line 176
      pch = (char const   *)tmp___0;
      }
#line 176
      if ((unsigned long )pch != (unsigned long )((void *)0)) {
#line 177
        num_id ++;
#line 177
        if (num_id > 4) {
#line 178
          return ((uint8_t *)((void *)0));
        }
#line 182
        val <<= 4;
#line 183
        val = (int )((long )val | (pch - xdigits));
      } else {
#line 185
        return ((uint8_t *)((void *)0));
      }
    }
#line 153
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return (ifid);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int ip_hton(char const   *src , int af , fr_ipaddr_t *dst ) 
{ 
  int rcode ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *res ;
  char const   *tmp ;

  {
  {
#line 414
  ai = (struct addrinfo *)((void *)0);
#line 414
  res = (struct addrinfo *)((void *)0);
#line 416
  memset((void *)(& hints), 0, sizeof(hints));
#line 417
  hints.ai_family = af;
#line 419
  rcode = getaddrinfo((char const   */* __restrict  */)src, (char const   */* __restrict  */)((void *)0),
                      (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 419
  if (rcode != 0) {
    {
#line 420
    tmp = gai_strerror(rcode);
#line 420
    fr_strerror_printf("ip_hton: %s", tmp);
    }
#line 421
    return (-1);
  }
#line 424
  ai = res;
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    if (! ai) {
#line 424
      goto while_break;
    }
#line 425
    if (af == ai->ai_family) {
#line 426
      goto while_break;
    } else
#line 425
    if (af == 0) {
#line 426
      goto while_break;
    }
#line 424
    ai = ai->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  if (! ai) {
    {
#line 430
    fr_strerror_printf("ip_hton failed to find requested information for host %.100s",
                       src);
#line 431
    freeaddrinfo(ai);
    }
#line 432
    return (-1);
  }
  {
#line 435
  rcode = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)((struct sockaddr_storage *)ai->ai_addr),
                             ai->ai_addrlen, dst, (int *)((void *)0));
#line 437
  freeaddrinfo(ai);
  }
#line 438
  if (! rcode) {
#line 438
    return (-1);
  }
#line 440
  return (0);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
char const   *ip_ntoh(fr_ipaddr_t const   *src , char *dst , size_t cnt ) 
{ 
  struct sockaddr_storage ss ;
  int error ;
  socklen_t salen ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 455
  if (! fr_dns_lookups) {
    {
#line 456
    tmp = inet_ntop((int )src->af, (void const   */* __restrict  */)(& src->ipaddr),
                    (char */* __restrict  */)dst, (socklen_t )cnt);
    }
#line 456
    return (tmp);
  }
  {
#line 459
  tmp___0 = fr_ipaddr2sockaddr(src, 0, & ss, & salen);
  }
#line 459
  if (! tmp___0) {
#line 460
    return ((char const   *)((void *)0));
  }
  {
#line 463
  error = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& ss)),
                      salen, (char */* __restrict  */)dst, (socklen_t )cnt, (char */* __restrict  */)((void *)0),
                      (socklen_t )0, 3);
  }
#line 463
  if (error != 0) {
    {
#line 465
    tmp___1 = gai_strerror(error);
#line 465
    fr_strerror_printf("ip_ntoh: %s", tmp___1);
    }
#line 466
    return ((char const   *)((void *)0));
  }
#line 468
  return ((char const   *)dst);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab  =    "0123456789abcdef";
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
size_t fr_hex2bin(char const   *hex , uint8_t *bin , size_t len ) 
{ 
  size_t i ;
  char *c1 ;
  char *c2 ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 484
  i = (size_t )0;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! (i < len)) {
#line 484
      goto while_break;
    }
    {
#line 485
    tmp = tolower((int )*(hex + (i << 1)));
#line 485
    tmp___0 = memchr((void const   *)hextab, tmp, (size_t )16);
#line 485
    c1 = (char *)tmp___0;
    }
#line 485
    if (c1) {
      {
#line 485
      tmp___1 = tolower((int )*(hex + ((i << 1) + 1UL)));
#line 485
      tmp___2 = memchr((void const   *)hextab, tmp___1, (size_t )16);
#line 485
      c2 = (char *)tmp___2;
      }
#line 485
      if (! c2) {
#line 487
        goto while_break;
      }
    } else {
#line 487
      goto while_break;
    }
#line 488
    *(bin + i) = (uint8_t )(((c1 - (char *)hextab) << 4) + (c2 - (char *)hextab));
#line 484
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 491
  return (i);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
void fr_bin2hex(uint8_t const   *bin , char *hex , size_t len ) 
{ 
  size_t i ;

  {
#line 504
  i = (size_t )0;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (i < len)) {
#line 504
      goto while_break;
    }
#line 505
    *(hex + 0) = (char )*(hextab + (((int const   )*bin >> 4) & 15));
#line 506
    *(hex + 1) = (char )*(hextab + ((int const   )*bin & 15));
#line 507
    hex += 2;
#line 508
    bin ++;
#line 504
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  *hex = (char )'\000';
#line 511
  return;
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int closefrom(int fd ) 
{ 
  int i ;
  int maxfd ;
  long tmp ;

  {
  {
#line 522
  maxfd = 256;
#line 525
  tmp = sysconf(4);
#line 525
  maxfd = (int )tmp;
  }
#line 526
  if (maxfd < 0) {
#line 527
    maxfd = 256;
  }
#line 531
  if (fd > maxfd) {
#line 531
    return (0);
  }
#line 538
  i = fd;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! (i < maxfd)) {
#line 538
      goto while_break;
    }
    {
#line 539
    close(i);
#line 538
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (0);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int fr_ipaddr_cmp(fr_ipaddr_t const   *a , fr_ipaddr_t const   *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 548
  if (a->af < b->af) {
#line 548
    return (-1);
  }
#line 549
  if (a->af > b->af) {
#line 549
    return (1);
  }
  {
#line 552
  if (a->af == 2) {
#line 552
    goto case_2;
  }
#line 559
  if (a->af == 10) {
#line 559
    goto case_10;
  }
#line 569
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 553
  tmp = memcmp((void const   *)(& a->ipaddr.ip4addr), (void const   *)(& b->ipaddr.ip4addr),
               sizeof(a->ipaddr.ip4addr));
  }
#line 553
  return (tmp);
#line 556
  goto switch_break;
  case_10: /* CIL Label */ 
#line 560
  if (a->scope < b->scope) {
#line 560
    return (-1);
  }
#line 561
  if (a->scope > b->scope) {
#line 561
    return (1);
  }
  {
#line 563
  tmp___0 = memcmp((void const   *)(& a->ipaddr.ip6addr), (void const   *)(& b->ipaddr.ip6addr),
                   sizeof(a->ipaddr.ip6addr));
  }
#line 563
  return (tmp___0);
#line 566
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 570
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 573
  return (-1);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int fr_ipaddr2sockaddr(fr_ipaddr_t const   *ipaddr , int port , struct sockaddr_storage *sa ,
                       socklen_t *salen ) 
{ 
  struct sockaddr_in s4 ;
  struct sockaddr_in6 s6 ;

  {
#line 579
  if (ipaddr->af == 2) {
    {
#line 582
    *salen = (socklen_t )sizeof(s4);
#line 584
    memset((void *)(& s4), 0, sizeof(s4));
#line 585
    s4.sin_family = (sa_family_t )2;
#line 586
    s4.sin_addr = (struct in_addr )ipaddr->ipaddr.ip4addr;
#line 587
    s4.sin_port = htons((uint16_t )port);
#line 588
    memset((void *)sa, 0, sizeof(*sa));
#line 589
    memcpy((void */* __restrict  */)sa, (void const   */* __restrict  */)(& s4), sizeof(s4));
    }
  } else
#line 592
  if (ipaddr->af == 10) {
    {
#line 595
    *salen = (socklen_t )sizeof(s6);
#line 597
    memset((void *)(& s6), 0, sizeof(s6));
#line 598
    s6.sin6_family = (sa_family_t )10;
#line 599
    s6.sin6_addr = (struct in6_addr )ipaddr->ipaddr.ip6addr;
#line 600
    s6.sin6_port = htons((uint16_t )port);
#line 601
    s6.sin6_scope_id = (uint32_t )ipaddr->scope;
#line 602
    memset((void *)sa, 0, sizeof(*sa));
#line 603
    memcpy((void */* __restrict  */)sa, (void const   */* __restrict  */)(& s6), sizeof(s6));
    }
  } else {
#line 606
    return (0);
  }
#line 609
  return (1);
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
int fr_sockaddr2ipaddr(struct sockaddr_storage  const  *sa , socklen_t salen , fr_ipaddr_t *ipaddr ,
                       int *port ) 
{ 
  struct sockaddr_in s4 ;
  uint16_t tmp ;
  struct sockaddr_in6 s6 ;
  uint16_t tmp___0 ;

  {
#line 616
  if ((int const   )sa->ss_family == 2) {
#line 619
    if ((unsigned long )salen < sizeof(s4)) {
      {
#line 620
      fr_strerror_printf("IPv4 address is too small");
      }
#line 621
      return (0);
    }
    {
#line 624
    memcpy((void */* __restrict  */)(& s4), (void const   */* __restrict  */)sa, sizeof(s4));
#line 625
    ipaddr->af = 2;
#line 626
    ipaddr->ipaddr.ip4addr = s4.sin_addr;
    }
#line 627
    if (port) {
      {
#line 627
      tmp = ntohs(s4.sin_port);
#line 627
      *port = (int )tmp;
      }
    }
  } else
#line 630
  if ((int const   )sa->ss_family == 10) {
#line 633
    if ((unsigned long )salen < sizeof(s6)) {
      {
#line 634
      fr_strerror_printf("IPv6 address is too small");
      }
#line 635
      return (0);
    }
    {
#line 638
    memcpy((void */* __restrict  */)(& s6), (void const   */* __restrict  */)sa, sizeof(s6));
#line 639
    ipaddr->af = 10;
#line 640
    ipaddr->ipaddr.ip6addr = s6.sin6_addr;
    }
#line 641
    if (port) {
      {
#line 641
      tmp___0 = ntohs(s6.sin6_port);
#line 641
      *port = (int )tmp___0;
      }
    }
#line 642
    ipaddr->scope = s6.sin6_scope_id;
  } else {
    {
#line 646
    fr_strerror_printf("Unsupported address famility %d", (int const   )sa->ss_family);
    }
#line 648
    return (0);
  }
#line 651
  return (1);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 482 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
fr_fifo_t *fr_fifo_create(int max_entries , void (*freeNode)(void * ) ) ;
#line 483
void fr_fifo_free(fr_fifo_t *fi ) ;
#line 484
int fr_fifo_push(fr_fifo_t *fi , void *data ) ;
#line 485
void *fr_fifo_pop(fr_fifo_t *fi ) ;
#line 486
void *fr_fifo_peek(fr_fifo_t *fi ) ;
#line 487
int fr_fifo_num_elements(fr_fifo_t *fi ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
fr_fifo_t *fr_fifo_create(int max_entries , void (*freeNode)(void * ) ) 
{ 
  fr_fifo_t *fi ;
  void *tmp ;

  {
#line 49
  if (max_entries < 2) {
#line 49
    return ((fr_fifo_t *)((void *)0));
  } else
#line 49
  if (max_entries > 1048576) {
#line 49
    return ((fr_fifo_t *)((void *)0));
  }
  {
#line 51
  tmp = malloc(sizeof(*fi));
#line 51
  fi = (fr_fifo_t *)tmp;
  }
#line 52
  if (! fi) {
#line 52
    return ((fr_fifo_t *)((void *)0));
  }
  {
#line 54
  memset((void *)fi, 0, sizeof(*fi));
#line 56
  fi->max_entries = max_entries;
#line 57
  fi->freeNode = freeNode;
  }
#line 59
  return (fi);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
void fr_fifo_free(fr_fifo_t *fi ) 
{ 


  {
#line 78
  if (! fi) {
#line 78
    return;
  }
  {
#line 80
  fr_fifo_free_entries(fi, fi->head);
#line 81
  fr_fifo_free_entries(fi, fi->freelist);
#line 83
  free((void *)fi);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
int fr_fifo_push(fr_fifo_t *fi , void *data ) 
{ 
  fr_fifo_entry_t *entry ;

  {
#line 106
  if (! fi) {
#line 106
    return (0);
  } else
#line 106
  if (! data) {
#line 106
    return (0);
  }
#line 108
  if (fi->num_elements >= fi->max_entries) {
#line 108
    return (0);
  }
  {
#line 110
  entry = fr_fifo_alloc_entry(fi);
  }
#line 111
  if (! entry) {
#line 111
    return (0);
  }
#line 112
  entry->data = data;
#line 114
  if (! fi->head) {
#line 115
    fi->head = entry;
  } else {
#line 117
    *(fi->tail) = entry;
  }
#line 119
  fi->tail = & entry->next;
#line 121
  (fi->num_elements) ++;
#line 123
  return (1);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
void *fr_fifo_pop(fr_fifo_t *fi ) 
{ 
  void *data ;
  fr_fifo_entry_t *entry ;

  {
#line 139
  if (! fi) {
#line 139
    return ((void *)0);
  } else
#line 139
  if (! fi->head) {
#line 139
    return ((void *)0);
  }
  {
#line 141
  entry = fi->head;
#line 142
  fi->head = entry->next;
#line 144
  data = entry->data;
#line 145
  fr_fifo_free_entry(fi, entry);
#line 147
  (fi->num_elements) --;
  }
#line 149
  if (! fi->head) {
#line 150
    fi->tail = (fr_fifo_entry_t **)((void *)0);
#line 151
    fi->num_elements = 0;
  }
#line 154
  return (data);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
void *fr_fifo_peek(fr_fifo_t *fi ) 
{ 


  {
#line 159
  if (! fi) {
#line 159
    return ((void *)0);
  } else
#line 159
  if (! fi->head) {
#line 159
    return ((void *)0);
  }
#line 161
  return ((fi->head)->data);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
int fr_fifo_num_elements(fr_fifo_t *fi ) 
{ 


  {
#line 166
  if (! fi) {
#line 166
    return (0);
  }
#line 168
  return (fi->num_elements);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 120 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 369 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 80
FR_TOKEN gettoken(char const   **ptr , char *buf , int buflen ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 243 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
int vp_prints_value(char *out , size_t outlen , VALUE_PAIR *vp , int delimitst ) ;
#line 245
char const   *vp_print_name(char *buffer , size_t bufsize , int attr ) ;
#line 259
DICT_ATTR *dict_attrbyvalue(unsigned int attr ) ;
#line 260
DICT_ATTR *dict_attrbyname(char const   *name ) ;
#line 262
DICT_VALUE *dict_valbyname(unsigned int attr , char const   *name ) ;
#line 263
int dict_vendorbyname(char const   *name ) ;
#line 264
DICT_VENDOR *dict_vendorbyvalue(int vendorpec ) ;
#line 337
VALUE_PAIR *pairalloc(DICT_ATTR *da ) ;
#line 338
VALUE_PAIR *paircreate_raw(int attr , int type , VALUE_PAIR *vp ) ;
#line 339
VALUE_PAIR *paircreate(int attr , int type ) ;
#line 340
void pairfree(VALUE_PAIR **pair_ptr ) ;
#line 341
void pairbasicfree(VALUE_PAIR *pair ) ;
#line 342
VALUE_PAIR *pairfind(VALUE_PAIR *first , int attr ) ;
#line 343
void pairdelete(VALUE_PAIR **first , int attr ) ;
#line 344
void pairadd(VALUE_PAIR **first , VALUE_PAIR *add ) ;
#line 345
void pairreplace(VALUE_PAIR **first , VALUE_PAIR *replace ) ;
#line 346
int paircmp(VALUE_PAIR *one , VALUE_PAIR *two ) ;
#line 347
VALUE_PAIR *paircopyvp(VALUE_PAIR const   *vp ) ;
#line 348
VALUE_PAIR *paircopy(VALUE_PAIR *vp ) ;
#line 349
VALUE_PAIR *paircopy2(VALUE_PAIR *vp , int attr ) ;
#line 350
void pairmove(VALUE_PAIR **to , VALUE_PAIR **from ) ;
#line 351
void pairmove2(VALUE_PAIR **to , VALUE_PAIR **from , int attr ) ;
#line 352
VALUE_PAIR *pairparsevalue(VALUE_PAIR *vp , char const   *value ) ;
#line 353
VALUE_PAIR *pairmake(char const   *attribute , char const   *value , int operator ) ;
#line 354
VALUE_PAIR *pairread(char const   **ptr , FR_TOKEN *eol ) ;
#line 355
FR_TOKEN userparse(char const   *buffer , VALUE_PAIR **first_pair ) ;
#line 356
VALUE_PAIR *readvp2(FILE *fp , int *pfiledone , char const   *errprefix ) ;
#line 368
void ( /* format attribute */  fr_perror)(char const   *fmt  , ...) ;
#line 373
char const   *fr_strerror(void) ;
#line 379
FILE *fr_log_fp ;
#line 381
void ( /* format attribute */  fr_printf_log)(char const   *fmt  , ...) ;
#line 419
int ascend_parse_filter(VALUE_PAIR *pair ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 61 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *pairalloc(DICT_ATTR *da ) 
{ 
  size_t name_len ;
  VALUE_PAIR *vp ;
  void *tmp ;

  {
#line 63
  name_len = (size_t )0;
#line 70
  if (! da) {
#line 70
    name_len = (size_t )32;
  }
  {
#line 72
  tmp = malloc(sizeof(*vp) + name_len);
#line 72
  vp = (VALUE_PAIR *)tmp;
  }
#line 73
  if (! vp) {
#line 73
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 74
  memset((void *)vp, 0, sizeof(*vp));
  }
#line 76
  if (da) {
#line 77
    vp->attribute = (int )da->attr;
#line 78
    vp->vendor = da->vendor;
#line 79
    vp->type = da->type;
#line 80
    vp->name = (char const   *)(da->name);
#line 81
    vp->flags = da->flags;
  } else {
    {
#line 83
    vp->attribute = 0;
#line 84
    vp->vendor = 0;
#line 85
    vp->type = 5;
#line 86
    vp->name = (char const   *)((void *)0);
#line 87
    memset((void *)(& vp->flags), 0, sizeof(vp->flags));
#line 88
    vp->flags.unknown_attr = 1U;
    }
  }
  {
#line 92
  if (vp->type == 9) {
#line 92
    goto case_9;
  }
#line 96
  if (vp->type == 10) {
#line 96
    goto case_10;
  }
#line 103
  if (vp->type == 12) {
#line 103
    goto case_12;
  }
#line 103
  if (vp->type == 3) {
#line 103
    goto case_12;
  }
#line 103
  if (vp->type == 2) {
#line 103
    goto case_12;
  }
#line 103
  if (vp->type == 1) {
#line 103
    goto case_12;
  }
#line 107
  if (vp->type == 6) {
#line 107
    goto case_6;
  }
#line 111
  if (vp->type == 7) {
#line 111
    goto case_7;
  }
#line 115
  if (vp->type == 8) {
#line 115
    goto case_8;
  }
#line 119
  if (vp->type == 11) {
#line 119
    goto case_11;
  }
#line 123
  if (vp->type == 14) {
#line 123
    goto case_14;
  }
#line 129
  goto switch_default;
  case_9: /* CIL Label */ 
#line 93
  vp->length = (size_t )1;
#line 94
  goto switch_break;
  case_10: /* CIL Label */ 
#line 97
  vp->length = (size_t )2;
#line 98
  goto switch_break;
  case_12: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 104
  vp->length = (size_t )4;
#line 105
  goto switch_break;
  case_6: /* CIL Label */ 
#line 108
  vp->length = sizeof(vp->data.ifid);
#line 109
  goto switch_break;
  case_7: /* CIL Label */ 
#line 112
  vp->length = sizeof(vp->data.ipv6addr);
#line 113
  goto switch_break;
  case_8: /* CIL Label */ 
#line 116
  vp->length = sizeof(vp->data.ipv6prefix);
#line 117
  goto switch_break;
  case_11: /* CIL Label */ 
#line 120
  vp->length = sizeof(vp->data.ether);
#line 121
  goto switch_break;
  case_14: /* CIL Label */ 
#line 124
  vp->data.tlv = (uint8_t *)((void *)0);
#line 125
  vp->length = (size_t )0;
#line 126
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  vp->length = (size_t )0;
#line 131
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 134
  return (vp);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *paircreate_raw(int attr , int type , VALUE_PAIR *vp ) 
{ 
  char *p ;
  char const   *tmp ;

  {
#line 140
  p = (char *)(vp + 1);
#line 142
  if (! vp->flags.unknown_attr) {
    {
#line 143
    pairfree(& vp);
    }
#line 144
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 147
  vp->vendor = (attr >> 16) & 65535;
#line 148
  vp->attribute = attr;
#line 149
  vp->operator = (FR_TOKEN )11;
#line 150
  vp->name = (char const   *)p;
#line 151
  vp->type = type;
#line 152
  vp->length = (size_t )0;
#line 153
  memset((void *)(& vp->flags), 0, sizeof(vp->flags));
#line 154
  vp->flags.unknown_attr = 1U;
#line 156
  tmp = vp_print_name(p, (size_t )24, vp->attribute);
  }
#line 156
  if (! tmp) {
    {
#line 157
    free((void *)vp);
    }
#line 158
    return ((VALUE_PAIR *)((void *)0));
  }
#line 161
  return (vp);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *paircreate(int attr , int type ) 
{ 
  VALUE_PAIR *vp ;
  DICT_ATTR *da ;
  VALUE_PAIR *tmp ;

  {
  {
#line 173
  da = dict_attrbyvalue((unsigned int )attr);
#line 174
  vp = pairalloc(da);
  }
#line 174
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 175
    fr_strerror_printf("out of memory");
    }
#line 176
    return ((VALUE_PAIR *)((void *)0));
  }
#line 178
  vp->operator = (FR_TOKEN )11;
#line 183
  if (! da) {
    {
#line 183
    tmp = paircreate_raw(attr, type, vp);
    }
#line 183
    return (tmp);
  }
#line 185
  return (vp);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
void pairbasicfree(VALUE_PAIR *pair ) 
{ 


  {
#line 194
  if (pair->type == 14) {
    {
#line 194
    free((void *)pair->data.tlv);
    }
  }
  {
#line 196
  memset((void *)pair, 0, sizeof(*pair));
#line 197
  free((void *)pair);
  }
#line 198
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
void pairfree(VALUE_PAIR **pair_ptr ) 
{ 
  VALUE_PAIR *next ;
  VALUE_PAIR *pair ;

  {
#line 208
  if (! pair_ptr) {
#line 208
    return;
  }
#line 209
  pair = *pair_ptr;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! ((unsigned long )pair != (unsigned long )((void *)0))) {
#line 211
      goto while_break;
    }
    {
#line 212
    next = pair->next;
#line 213
    pairbasicfree(pair);
#line 214
    pair = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  *pair_ptr = (VALUE_PAIR *)((void *)0);
#line 218
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *pairfind(VALUE_PAIR *first , int attr ) 
{ 


  {
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (first) {
#line 226
      if (! (first->attribute != attr)) {
#line 226
        goto while_break;
      }
    } else {
#line 226
      goto while_break;
    }
#line 227
    first = first->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (first);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
void pairdelete(VALUE_PAIR **first , int attr ) 
{ 
  VALUE_PAIR *i ;
  VALUE_PAIR *next ;
  VALUE_PAIR **last ;

  {
#line 238
  last = first;
#line 240
  i = *first;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! i) {
#line 240
      goto while_break;
    }
#line 241
    next = i->next;
#line 242
    if (i->attribute == attr) {
      {
#line 243
      *last = next;
#line 244
      pairbasicfree(i);
      }
    } else {
#line 246
      last = & i->next;
    }
#line 240
    i = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
void pairadd(VALUE_PAIR **first , VALUE_PAIR *add ) 
{ 
  VALUE_PAIR *i ;

  {
#line 258
  if (! add) {
#line 258
    return;
  }
#line 260
  if ((unsigned long )*first == (unsigned long )((void *)0)) {
#line 261
    *first = add;
#line 262
    return;
  }
#line 264
  i = *first;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! i->next) {
#line 264
      goto while_break;
    }
#line 264
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  i->next = add;
#line 267
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
void pairreplace(VALUE_PAIR **first , VALUE_PAIR *replace ) 
{ 
  VALUE_PAIR *i ;
  VALUE_PAIR *next ;
  VALUE_PAIR **prev ;

  {
#line 275
  prev = first;
#line 277
  if ((unsigned long )*first == (unsigned long )((void *)0)) {
#line 278
    *first = replace;
#line 279
    return;
  }
#line 287
  i = *first;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! i) {
#line 287
      goto while_break;
    }
#line 288
    next = i->next;
#line 294
    if (i->attribute == replace->attribute) {
      {
#line 295
      *prev = replace;
#line 300
      replace->next = next;
#line 301
      pairbasicfree(i);
      }
#line 302
      return;
    }
#line 308
    prev = & i->next;
#line 287
    i = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  *prev = replace;
#line 316
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *paircopyvp(VALUE_PAIR const   *vp ) 
{ 
  size_t name_len ;
  VALUE_PAIR *n ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 327
  if (! vp->flags.unknown_attr) {
#line 328
    name_len = (size_t )0;
  } else {
#line 330
    name_len = (size_t )32;
  }
  {
#line 333
  tmp = malloc(sizeof(*n) + name_len);
#line 333
  n = (VALUE_PAIR *)tmp;
  }
#line 333
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    {
#line 334
    fr_strerror_printf("out of memory");
    }
#line 335
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 337
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)vp, sizeof(*n) + name_len);
  }
#line 343
  if (vp->flags.unknown_attr) {
#line 343
    n->name = (char const   *)((char *)(n + 1));
  }
#line 344
  n->next = (struct value_pair *)((void *)0);
#line 346
  if (n->type == 14) {
#line 346
    if ((unsigned long )n->data.tlv != (unsigned long )((void *)0)) {
      {
#line 348
      tmp___0 = malloc(n->length);
#line 348
      n->data.tlv = (uint8_t *)tmp___0;
#line 349
      memcpy((void */* __restrict  */)n->data.tlv, (void const   */* __restrict  */)vp->data.tlv,
             n->length);
      }
    }
  }
#line 352
  return (n);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *paircopy2(VALUE_PAIR *vp , int attr ) 
{ 
  VALUE_PAIR *first ;
  VALUE_PAIR *n ;
  VALUE_PAIR **last ;

  {
#line 363
  first = (VALUE_PAIR *)((void *)0);
#line 364
  last = & first;
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! vp) {
#line 366
      goto while_break;
    }
#line 367
    if (attr >= 0) {
#line 367
      if (vp->attribute != attr) {
#line 368
        vp = vp->next;
#line 369
        goto while_continue;
      }
    }
    {
#line 372
    n = paircopyvp((VALUE_PAIR const   *)vp);
    }
#line 373
    if (! n) {
#line 373
      return (first);
    }
#line 374
    *last = n;
#line 375
    last = & n->next;
#line 376
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return (first);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *paircopy(VALUE_PAIR *vp ) 
{ 
  VALUE_PAIR *tmp ;

  {
  {
#line 387
  tmp = paircopy2(vp, -1);
  }
#line 387
  return (tmp);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
void pairmove(VALUE_PAIR **to , VALUE_PAIR **from ) 
{ 
  VALUE_PAIR **tailto ;
  VALUE_PAIR *i ;
  VALUE_PAIR *j ;
  VALUE_PAIR *next ;
  VALUE_PAIR *tailfrom ;
  VALUE_PAIR *found ;
  int has_password ;
  int tmp ;
  VALUE_PAIR *mynext ;

  {
#line 398
  tailfrom = (VALUE_PAIR *)((void *)0);
#line 400
  has_password = 0;
#line 406
  tailto = to;
#line 407
  i = *to;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! i) {
#line 407
      goto while_break;
    }
#line 408
    if (i->attribute == 2) {
#line 410
      has_password = 1;
    } else
#line 408
    if (i->attribute == 1006) {
#line 410
      has_password = 1;
    }
#line 411
    tailto = & i->next;
#line 407
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  i = *from;
  {
#line 417
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 417
    if (! i) {
#line 417
      goto while_break___0;
    }
#line 418
    next = i->next;
#line 425
    if (has_password) {
#line 425
      if (i->attribute == 2) {
#line 428
        tailfrom = i;
#line 429
        goto __Cont;
      } else
#line 425
      if (i->attribute == 1006) {
#line 428
        tailfrom = i;
#line 429
        goto __Cont;
      }
    }
    {
#line 445
    if ((unsigned int )i->operator == 21U) {
#line 445
      goto case_21;
    }
#line 445
    if ((unsigned int )i->operator == 20U) {
#line 445
      goto case_21;
    }
#line 445
    if ((unsigned int )i->operator == 19U) {
#line 445
      goto case_21;
    }
#line 445
    if ((unsigned int )i->operator == 16U) {
#line 445
      goto case_21;
    }
#line 445
    if ((unsigned int )i->operator == 15U) {
#line 445
      goto case_21;
    }
#line 445
    if ((unsigned int )i->operator == 14U) {
#line 445
      goto case_21;
    }
#line 445
    if ((unsigned int )i->operator == 13U) {
#line 445
      goto case_21;
    }
#line 445
    if ((unsigned int )i->operator == 12U) {
#line 445
      goto case_21;
    }
#line 449
    goto switch_default;
    case_21: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 446
    tailfrom = i;
#line 447
    goto __Cont;
    switch_default: /* CIL Label */ 
#line 450
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 459
    if (i->attribute == 500) {
#line 459
      goto _L___0;
    } else
#line 459
    if (i->attribute != 1040) {
#line 459
      if (i->attribute != 22) {
        _L___0: /* CIL Label */ 
        {
#line 462
        found = pairfind(*to, i->attribute);
        }
        {
#line 469
        if ((unsigned int )i->operator == 9U) {
#line 469
          goto case_9;
        }
#line 534
        if ((unsigned int )i->operator == 11U) {
#line 534
          goto case_11;
        }
#line 551
        if ((unsigned int )i->operator == 10U) {
#line 551
          goto case_10;
        }
#line 586
        goto switch_default___0;
        case_9: /* CIL Label */ 
#line 470
        if (found) {
#line 471
          if (! i->data.strvalue[0]) {
#line 471
            goto _L;
          } else {
            {
#line 471
            tmp = strcmp((char const   *)(found->data.strvalue), (char const   *)(i->data.strvalue));
            }
#line 471
            if (tmp == 0) {
              _L: /* CIL Label */ 
              {
#line 474
              pairdelete(to, found->attribute);
#line 480
              tailto = to;
#line 481
              j = *to;
              }
              {
#line 481
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 481
                if (! j) {
#line 481
                  goto while_break___1;
                }
#line 482
                tailto = & j->next;
#line 481
                j = j->next;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
          }
        }
#line 486
        tailfrom = i;
#line 487
        goto __Cont;
#line 488
        goto switch_break___0;
        case_11: /* CIL Label */ 
#line 540
        if (found) {
#line 541
          tailfrom = i;
#line 542
          goto __Cont;
        }
#line 544
        goto switch_break___0;
        case_10: /* CIL Label */ 
#line 552
        if (found) {
          {
#line 553
          mynext = found->next;
#line 566
          memcpy((void */* __restrict  */)found, (void const   */* __restrict  */)i,
                 sizeof(*found));
#line 567
          found->next = mynext;
#line 569
          pairdelete(& found->next, found->attribute);
#line 575
          j = found;
          }
          {
#line 575
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 575
            if (! j) {
#line 575
              goto while_break___2;
            }
#line 576
            tailto = & j->next;
#line 575
            j = j->next;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 578
          goto __Cont;
        }
#line 580
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 588
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 591
    if (tailfrom) {
#line 592
      tailfrom->next = next;
    } else {
#line 594
      *from = next;
    }
#line 601
    if (! *to) {
#line 602
      tailto = to;
    }
#line 604
    *tailto = i;
#line 605
    if (i) {
#line 606
      i->next = (struct value_pair *)((void *)0);
#line 607
      tailto = & i->next;
    }
    __Cont: /* CIL Label */ 
#line 417
    i = next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 610
  return;
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
void pairmove2(VALUE_PAIR **to , VALUE_PAIR **from , int attr ) 
{ 
  VALUE_PAIR *to_tail ;
  VALUE_PAIR *i ;
  VALUE_PAIR *next ;
  VALUE_PAIR *iprev ;

  {
#line 618
  iprev = (VALUE_PAIR *)((void *)0);
#line 623
  if ((unsigned long )*to != (unsigned long )((void *)0)) {
#line 624
    to_tail = *to;
#line 625
    i = *to;
    {
#line 625
    while (1) {
      while_continue: /* CIL Label */ ;
#line 625
      if (! i) {
#line 625
        goto while_break;
      }
#line 626
      to_tail = i;
#line 625
      i = i->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 628
    to_tail = (VALUE_PAIR *)((void *)0);
  }
#line 630
  i = *from;
  {
#line 630
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 630
    if (! i) {
#line 630
      goto while_break___0;
    }
#line 631
    next = i->next;
#line 638
    if (attr != 26) {
#line 638
      if (i->attribute != attr) {
#line 640
        iprev = i;
#line 641
        goto __Cont;
      }
    }
#line 648
    if (attr == 26) {
#line 648
      if (((i->attribute >> 16) & 65535) == 0) {
#line 650
        iprev = i;
#line 651
        goto __Cont;
      }
    }
#line 657
    if (iprev) {
#line 658
      iprev->next = next;
    } else {
#line 660
      *from = next;
    }
#line 665
    if (to_tail) {
#line 666
      to_tail->next = i;
    } else {
#line 668
      *to = i;
    }
#line 669
    to_tail = i;
#line 670
    i->next = (struct value_pair *)((void *)0);
    __Cont: /* CIL Label */ 
#line 630
    i = next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 672
  return;
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok(& p, " \t");
#line 726
  f[1] = mystrtok(& p, " \t");
#line 727
  f[2] = mystrtok(& p, " \t");
#line 728
  f[3] = mystrtok(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___0  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *pairparsevalue(VALUE_PAIR *vp , char const   *value ) 
{ 
  char *p ;
  char *s ;
  char const   *cp ;
  char const   *cs ;
  int x ;
  size_t length ;
  DICT_VALUE *dval ;
  char c ;
  char const   *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  fr_ipaddr_t ipaddr ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  time_t date ;
  int tmp___6 ;
  int tmp___7 ;
  char buffer[256] ;
  char const   *tmp___8 ;
  int tmp___9 ;
  uint8_t *us ;
  size_t tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  uint8_t *tmp___13 ;
  int tmp___14 ;
  uint8_t *tmp___15 ;
  fr_ipaddr_t ipaddr___0 ;
  char buffer___0[1024] ;
  char const   *tmp___16 ;
  int tmp___17 ;
  unsigned int prefix ;
  char buffer___1[256] ;
  char *eptr ;
  int tmp___18 ;
  unsigned long tmp___19 ;
  char const   *c1 ;
  char const   *c2 ;
  int tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;
  void *tmp___25 ;
  fr_ipaddr_t ipaddr___1 ;
  int tmp___26 ;
  int tmp___27 ;
  long tmp___28 ;
  int tmp___29 ;
  size_t tmp___30 ;
  void *tmp___31 ;
  size_t tmp___32 ;

  {
#line 866
  s = (char *)0;
#line 872
  if (! value) {
#line 872
    return ((VALUE_PAIR *)((void *)0));
  }
#line 878
  if (vp->type != 14) {
    {
#line 879
    strlcpy(vp->data.strvalue, value, sizeof(vp->data.strvalue));
#line 880
    vp->length = strlen((char const   *)(vp->data.strvalue));
    }
  }
  {
#line 884
  if (vp->type == 0) {
#line 884
    goto case_0;
  }
#line 948
  if (vp->type == 2) {
#line 948
    goto case_2;
  }
#line 988
  if (vp->type == 9) {
#line 988
    goto case_9;
  }
#line 1005
  if (vp->type == 10) {
#line 1005
    goto case_10;
  }
#line 1021
  if (vp->type == 1) {
#line 1021
    goto case_1;
  }
#line 1043
  if (vp->type == 3) {
#line 1043
    goto case_3;
  }
#line 1064
  if (vp->type == 4) {
#line 1064
    goto case_4;
  }
#line 1088
  if (vp->type == 5) {
#line 1088
    goto do_octets;
  }
#line 1122
  if (vp->type == 6) {
#line 1122
    goto case_6;
  }
#line 1131
  if (vp->type == 7) {
#line 1131
    goto case_7;
  }
#line 1149
  if (vp->type == 8) {
#line 1149
    goto case_8;
  }
#line 1180
  if (vp->type == 11) {
#line 1180
    goto case_11;
  }
#line 1212
  if (vp->type == 13) {
#line 1212
    goto case_13;
  }
#line 1232
  if (vp->type == 12) {
#line 1232
    goto case_12;
  }
#line 1237
  if (vp->type == 14) {
#line 1237
    goto case_14;
  }
#line 1263
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 888
  p = vp->data.strvalue;
#line 889
  cp = value;
#line 890
  length = (size_t )0;
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
#line 892
    if (*cp) {
#line 892
      if (! (length < sizeof(vp->data.strvalue) - 1UL)) {
#line 892
        goto while_break;
      }
    } else {
#line 892
      goto while_break;
    }
#line 893
    tmp = cp;
#line 893
    cp ++;
#line 893
    c = (char )*tmp;
#line 895
    if ((int )c == 92) {
      {
#line 897
      if ((int const   )*cp == 114) {
#line 897
        goto case_114;
      }
#line 901
      if ((int const   )*cp == 110) {
#line 901
        goto case_110;
      }
#line 905
      if ((int const   )*cp == 116) {
#line 905
        goto case_116;
      }
#line 909
      if ((int const   )*cp == 34) {
#line 909
        goto case_34;
      }
#line 913
      if ((int const   )*cp == 39) {
#line 913
        goto case_39;
      }
#line 917
      if ((int const   )*cp == 92) {
#line 917
        goto case_92;
      }
#line 921
      if ((int const   )*cp == 96) {
#line 921
        goto case_96;
      }
#line 925
      if ((int const   )*cp == 0) {
#line 925
        goto case_0___0;
      }
#line 928
      goto switch_default;
      case_114: /* CIL Label */ 
#line 898
      c = (char )'\r';
#line 899
      cp ++;
#line 900
      goto switch_break___0;
      case_110: /* CIL Label */ 
#line 902
      c = (char )'\n';
#line 903
      cp ++;
#line 904
      goto switch_break___0;
      case_116: /* CIL Label */ 
#line 906
      c = (char )'\t';
#line 907
      cp ++;
#line 908
      goto switch_break___0;
      case_34: /* CIL Label */ 
#line 910
      c = (char )'\"';
#line 911
      cp ++;
#line 912
      goto switch_break___0;
      case_39: /* CIL Label */ 
#line 914
      c = (char )'\'';
#line 915
      cp ++;
#line 916
      goto switch_break___0;
      case_92: /* CIL Label */ 
#line 918
      c = (char )'\\';
#line 919
      cp ++;
#line 920
      goto switch_break___0;
      case_96: /* CIL Label */ 
#line 922
      c = (char )'`';
#line 923
      cp ++;
#line 924
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 926
      c = (char )'\\';
#line 927
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 929
      if ((int const   )*(cp + 0) >= 48) {
#line 929
        if ((int const   )*(cp + 0) <= 57) {
#line 929
          if ((int const   )*(cp + 1) >= 48) {
#line 929
            if ((int const   )*(cp + 1) <= 57) {
#line 929
              if ((int const   )*(cp + 2) >= 48) {
#line 929
                if ((int const   )*(cp + 2) <= 57) {
                  {
#line 929
                  tmp___0 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%3o",
                                   & x);
                  }
#line 929
                  if (tmp___0 == 1) {
#line 936
                    c = (char )x;
#line 937
                    cp += 3;
                  }
                }
              }
            }
          }
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 941
    tmp___1 = p;
#line 941
    p ++;
#line 941
    *tmp___1 = c;
#line 942
    length ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  vp->data.strvalue[length] = (char )'\000';
#line 945
  vp->length = length;
#line 946
  goto switch_break;
  case_2: /* CIL Label */ 
#line 952
  if ((unsigned int )vp->operator == 17U) {
#line 954
    goto switch_break;
  } else
#line 952
  if ((unsigned int )vp->operator == 18U) {
#line 954
    goto switch_break;
  }
  {
#line 961
  s = (char *)((void *)0);
#line 962
  p = strrchr(value, '+');
  }
#line 962
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 962
    if (! *(p + 1)) {
      {
#line 963
      s = strdup(value);
#line 963
      cs = (char const   *)s;
      }
#line 964
      if (! s) {
#line 964
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 965
      p = strrchr((char const   *)s, '+');
#line 966
      *p = (char)0;
#line 967
      vp->flags.addport = 1U;
      }
    } else {
#line 969
      p = (char *)((void *)0);
#line 970
      cs = value;
    }
  } else {
#line 969
    p = (char *)((void *)0);
#line 970
    cs = value;
  }
  {
#line 976
  tmp___2 = ip_hton(cs, 2, & ipaddr);
  }
#line 976
  if (tmp___2 < 0) {
    {
#line 977
    free((void *)s);
#line 978
    fr_strerror_printf("Failed to find IP address for %s", cs);
    }
#line 979
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 982
  vp->lvalue = ipaddr.ipaddr.ip4addr.s_addr;
#line 984
  free((void *)s);
#line 985
  vp->length = (size_t )4;
  }
#line 986
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 989
  vp->length = (size_t )1;
#line 994
  vp->lvalue = getint(value, & p);
  }
#line 995
  if (! *p) {
#line 996
    if (vp->lvalue > 255U) {
      {
#line 997
      fr_strerror_printf("Byte value \"%s\" is larger than 255", value);
      }
#line 998
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1000
    goto switch_break;
  }
  {
#line 1002
  tmp___3 = check_for_whitespace((char const   *)p);
  }
#line 1002
  if (tmp___3) {
#line 1002
    goto switch_break;
  }
#line 1003
  goto check_for_value;
  case_10: /* CIL Label */ 
  {
#line 1009
  vp->lvalue = getint(value, & p);
#line 1010
  vp->length = (size_t )2;
  }
#line 1011
  if (! *p) {
#line 1012
    if (vp->lvalue > 65535U) {
      {
#line 1013
      fr_strerror_printf("Byte value \"%s\" is larger than 65535", value);
      }
#line 1014
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1016
    goto switch_break;
  }
  {
#line 1018
  tmp___4 = check_for_whitespace((char const   *)p);
  }
#line 1018
  if (tmp___4) {
#line 1018
    goto switch_break;
  }
#line 1019
  goto check_for_value;
  case_1: /* CIL Label */ 
  {
#line 1025
  vp->lvalue = getint(value, & p);
#line 1026
  vp->length = (size_t )4;
  }
#line 1027
  if (! *p) {
#line 1027
    goto switch_break;
  }
  {
#line 1028
  tmp___5 = check_for_whitespace((char const   *)p);
  }
#line 1028
  if (tmp___5) {
#line 1028
    goto switch_break;
  }
  check_for_value: 
  {
#line 1035
  dval = dict_valbyname((unsigned int )vp->attribute, value);
  }
#line 1035
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1036
    fr_strerror_printf("Unknown value %s for attribute %s", value, vp->name);
    }
#line 1038
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1040
  vp->lvalue = (uint32_t )dval->value;
#line 1041
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1053
  tmp___6 = gettime(value, & date);
  }
#line 1053
  if (tmp___6 < 0) {
    {
#line 1054
    fr_strerror_printf("failed to parse time string \"%s\"", value);
    }
#line 1056
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1059
  vp->lvalue = (uint32_t )date;
#line 1061
  vp->length = (size_t )4;
#line 1062
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1066
  tmp___7 = strncasecmp(value, "0x", (size_t )2);
  }
#line 1066
  if (tmp___7 == 0) {
#line 1067
    vp->type = 5;
#line 1068
    goto do_octets;
  }
  {
#line 1071
  tmp___9 = ascend_parse_filter(vp);
  }
#line 1071
  if (tmp___9 < 0) {
    {
#line 1074
    tmp___8 = fr_strerror();
#line 1074
    snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"failed to parse Ascend binary attribute: %s",
             tmp___8);
#line 1075
    fr_strerror_printf("%s", buffer);
    }
#line 1076
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1078
  goto switch_break;
  do_octets: 
  case_5: /* CIL Label */ 
  {
#line 1089
  tmp___14 = strncasecmp(value, "0x", (size_t )2);
  }
#line 1089
  if (tmp___14 == 0) {
    {
#line 1091
    cp = value + 2;
#line 1092
    us = vp->data.octets;
#line 1093
    vp->length = (size_t )0;
#line 1100
    tmp___10 = strlen(cp);
    }
#line 1100
    if ((tmp___10 & 1UL) != 0UL) {
      {
#line 1101
      fr_strerror_printf("Hex string is not an even length string.");
      }
#line 1102
      return ((VALUE_PAIR *)((void *)0));
    }
    {
#line 1106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1106
      if (*cp) {
#line 1106
        if (! (vp->length < 254UL)) {
#line 1106
          goto while_break___0;
        }
      } else {
#line 1106
        goto while_break___0;
      }
      {
#line 1110
      tmp___12 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%02x",
                        & tmp___11);
      }
#line 1110
      if (tmp___12 != 1) {
        {
#line 1111
        fr_strerror_printf("Non-hex characters at %c%c", (int const   )*(cp + 0),
                           (int const   )*(cp + 1));
        }
#line 1112
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1115
      cp += 2;
#line 1116
      tmp___13 = us;
#line 1116
      us ++;
#line 1116
      *tmp___13 = (uint8_t )tmp___11;
#line 1117
      (vp->length) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1120
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1123
  tmp___15 = ifid_aton(value, (uint8_t *)((void *)(& vp->data.ifid)));
  }
#line 1123
  if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
    {
#line 1124
    fr_strerror_printf("failed to parse interface-id string \"%s\"", value);
    }
#line 1126
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1128
  vp->length = (size_t )8;
#line 1129
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1135
  tmp___17 = ip_hton(value, 10, & ipaddr___0);
  }
#line 1135
  if (tmp___17 < 0) {
    {
#line 1138
    tmp___16 = fr_strerror();
#line 1138
    strlcpy(buffer___0, tmp___16, sizeof(buffer___0));
#line 1140
    fr_strerror_printf("failed to parse IPv6 address string \"%s\": %s", value, buffer___0);
    }
#line 1142
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1144
  vp->data.ipv6addr = ipaddr___0.ipaddr.ip6addr;
#line 1145
  vp->length = (size_t )16;
#line 1147
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1150
  p = strchr(value, '/');
  }
#line 1151
  if (! p) {
    {
#line 1152
    fr_strerror_printf("invalid IPv6 prefix string \"%s\"", value);
    }
#line 1154
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1151
  if (p - (char *)value >= 256L) {
    {
#line 1152
    fr_strerror_printf("invalid IPv6 prefix string \"%s\"", value);
    }
#line 1154
    return ((VALUE_PAIR *)((void *)0));
  } else {
    {
#line 1159
    memcpy((void */* __restrict  */)(buffer___1), (void const   */* __restrict  */)value,
           (size_t )(p - (char *)value));
#line 1160
    buffer___1[p - (char *)value] = (char )'\000';
#line 1162
    tmp___18 = inet_pton(10, (char const   */* __restrict  */)(buffer___1), (void */* __restrict  */)(vp->data.octets + 2));
    }
#line 1162
    if (tmp___18 <= 0) {
      {
#line 1163
      fr_strerror_printf("failed to parse IPv6 address string \"%s\"", value);
      }
#line 1165
      return ((VALUE_PAIR *)((void *)0));
    }
    {
#line 1168
    tmp___19 = strtoul((char const   */* __restrict  */)(p + 1), (char **/* __restrict  */)(& eptr),
                       10);
#line 1168
    prefix = (unsigned int )tmp___19;
    }
#line 1169
    if (prefix > 128U) {
      {
#line 1170
      fr_strerror_printf("failed to parse IPv6 address string \"%s\"", value);
      }
#line 1172
      return ((VALUE_PAIR *)((void *)0));
    } else
#line 1169
    if (*eptr) {
      {
#line 1170
      fr_strerror_printf("failed to parse IPv6 address string \"%s\"", value);
      }
#line 1172
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1174
    vp->data.octets[1] = (uint8_t )prefix;
  }
#line 1176
  vp->data.octets[0] = (uint8_t )'\000';
#line 1177
  vp->length = (size_t )18;
#line 1178
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1184
  length = (size_t )0;
#line 1185
  cp = value;
  {
#line 1186
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1186
    if (! *cp) {
#line 1186
      goto while_break___1;
    }
#line 1187
    if ((int const   )*(cp + 1) == 58) {
      {
#line 1188
      c1 = hextab___0;
#line 1189
      tmp___20 = tolower((int )*(cp + 0));
#line 1189
      tmp___21 = memchr((void const   *)hextab___0, tmp___20, (size_t )16);
#line 1189
      c2 = (char const   *)tmp___21;
#line 1190
      cp += 2;
      }
    } else
#line 1191
    if ((int const   )*(cp + 1) != 0) {
#line 1191
      if ((int const   )*(cp + 2) == 58) {
#line 1191
        goto _L;
      } else
#line 1191
      if ((int const   )*(cp + 2) == 0) {
        _L: /* CIL Label */ 
        {
#line 1194
        tmp___22 = tolower((int )*(cp + 0));
#line 1194
        tmp___23 = memchr((void const   *)hextab___0, tmp___22, (size_t )16);
#line 1194
        c1 = (char const   *)tmp___23;
#line 1195
        tmp___24 = tolower((int )*(cp + 1));
#line 1195
        tmp___25 = memchr((void const   *)hextab___0, tmp___24, (size_t )16);
#line 1195
        c2 = (char const   *)tmp___25;
#line 1196
        cp += 2;
        }
#line 1197
        if ((int const   )*cp == 58) {
#line 1197
          cp ++;
        }
      } else {
#line 1199
        c2 = (char const   *)((void *)0);
#line 1199
        c1 = c2;
      }
    } else {
#line 1199
      c2 = (char const   *)((void *)0);
#line 1199
      c1 = c2;
    }
#line 1201
    if (! c1) {
      {
#line 1202
      fr_strerror_printf("failed to parse Ethernet address \"%s\"", value);
      }
#line 1203
      return ((VALUE_PAIR *)((void *)0));
    } else
#line 1201
    if (! c2) {
      {
#line 1202
      fr_strerror_printf("failed to parse Ethernet address \"%s\"", value);
      }
#line 1203
      return ((VALUE_PAIR *)((void *)0));
    } else
#line 1201
    if (length >= sizeof(vp->data.ether)) {
      {
#line 1202
      fr_strerror_printf("failed to parse Ethernet address \"%s\"", value);
      }
#line 1203
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1205
    vp->data.ether[length] = (uint8_t )(((c1 - hextab___0) << 4) + (c2 - hextab___0));
#line 1206
    length ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1209
  vp->length = (size_t )6;
#line 1210
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1213
  tmp___27 = inet_pton(10, (char const   */* __restrict  */)value, (void */* __restrict  */)(vp->data.strvalue));
  }
#line 1213
  if (tmp___27 > 0) {
#line 1214
    vp->type = 7;
#line 1215
    vp->length = (size_t )16;
#line 1216
    vp->data.strvalue[vp->length] = (char )'\000';
  } else {
    {
#line 1221
    tmp___26 = ip_hton(value, 2, & ipaddr___1);
    }
#line 1221
    if (tmp___26 < 0) {
      {
#line 1222
      fr_strerror_printf("Failed to find IPv4 address for %s", value);
      }
#line 1223
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1226
    vp->type = 2;
#line 1227
    vp->lvalue = ipaddr___1.ipaddr.ip4addr.s_addr;
#line 1228
    vp->length = (size_t )4;
  }
#line 1230
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1233
  tmp___28 = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)(& p),
                    10);
#line 1233
  vp->data.sinteger = (int32_t )tmp___28;
#line 1234
  vp->length = (size_t )4;
  }
#line 1235
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 1238
  tmp___29 = strncasecmp(value, "0x", (size_t )2);
  }
#line 1238
  if (tmp___29 != 0) {
    {
#line 1239
    fr_strerror_printf("Invalid TLV specification");
    }
#line 1240
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1242
  tmp___30 = strlen(value + 2);
#line 1242
  length = tmp___30 / 2UL;
  }
#line 1243
  if (vp->length < length) {
    {
#line 1244
    free((void *)vp->data.tlv);
#line 1245
    vp->data.tlv = (uint8_t *)((void *)0);
    }
  }
  {
#line 1247
  tmp___31 = malloc(length);
#line 1247
  vp->data.tlv = (uint8_t *)tmp___31;
  }
#line 1248
  if (! vp->data.tlv) {
    {
#line 1249
    fr_strerror_printf("No memory");
    }
#line 1250
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1252
  tmp___32 = fr_hex2bin(value + 2, vp->data.tlv, length);
  }
#line 1252
  if (tmp___32 != length) {
    {
#line 1254
    fr_strerror_printf("Invalid hex data in TLV");
    }
#line 1255
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1257
  vp->length = length;
#line 1258
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 1264
  fr_strerror_printf("unknown attribute type %d", vp->type);
  }
#line 1265
  return ((VALUE_PAIR *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 1268
  return (vp);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any(char const   *attribute , char const   *value , int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1469 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *pairmake(char const   *attribute , char const   *value , int operator ) 
{ 
  DICT_ATTR *da ;
  VALUE_PAIR *vp ;
  char *tc ;
  char *ts ;
  signed char tag ;
  int found_tag ;
  char buffer[64] ;
  char const   *attrname ;
  long tmp ;
  VALUE_PAIR *tmp___0 ;
  long tmp___1 ;
  VALUE_PAIR *tmp___2 ;

  {
  {
#line 1477
  attrname = attribute;
#line 1482
  found_tag = 0;
#line 1483
  tag = (signed char)0;
#line 1485
  ts = strrchr(attribute, ':');
  }
#line 1486
  if (ts) {
#line 1486
    if (! *(ts + 1)) {
      {
#line 1487
      fr_strerror_printf("Invalid tag for attribute %s", attribute);
      }
#line 1488
      return ((VALUE_PAIR *)((void *)0));
    }
  }
#line 1491
  if (ts) {
#line 1491
    if (*(ts + 1)) {
      {
#line 1492
      strlcpy(buffer, attribute, sizeof(buffer));
#line 1493
      attrname = (char const   *)(buffer);
#line 1494
      ts = strrchr(attrname, ':');
      }
#line 1497
      if ((int )*(ts + 1) == 42) {
#line 1497
        if ((int )*(ts + 2) == 0) {
#line 1499
          tag = (signed char)-128;
#line 1500
          *ts = (char)0;
        } else {
#line 1497
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1501
      if ((int )*(ts + 1) >= 48) {
#line 1501
        if ((int )*(ts + 1) <= 57) {
          {
#line 1503
          tmp = strtol((char const   */* __restrict  */)(ts + 1), (char **/* __restrict  */)(& tc),
                       0);
#line 1503
          tag = (signed char )tmp;
          }
#line 1504
          if (tc) {
#line 1504
            if (! *tc) {
#line 1504
              if ((int )tag < 32) {
#line 1505
                *ts = (char)0;
              } else {
#line 1506
                tag = (signed char)0;
              }
            } else {
#line 1506
              tag = (signed char)0;
            }
          } else {
#line 1506
            tag = (signed char)0;
          }
        } else {
          {
#line 1508
          fr_strerror_printf("Invalid tag for attribute %s", attribute);
          }
#line 1509
          return ((VALUE_PAIR *)((void *)0));
        }
      } else {
        {
#line 1508
        fr_strerror_printf("Invalid tag for attribute %s", attribute);
        }
#line 1509
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1511
      found_tag = 1;
    }
  }
  {
#line 1518
  da = dict_attrbyname(attrname);
  }
#line 1518
  if ((unsigned long )da == (unsigned long )((void *)0)) {
    {
#line 1519
    tmp___0 = pairmake_any(attrname, value, operator);
    }
#line 1519
    return (tmp___0);
  }
  {
#line 1522
  vp = pairalloc(da);
  }
#line 1522
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1523
    fr_strerror_printf("out of memory");
    }
#line 1524
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1526
  if (operator == 0) {
#line 1526
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1526
    vp->operator = (FR_TOKEN )operator;
  }
#line 1533
  if (value) {
#line 1533
    if ((int const   )*value == 58) {
#line 1533
      if (da->flags.has_tag) {
#line 1535
        if (found_tag) {
          {
#line 1536
          fr_strerror_printf("Duplicate tag %s for attribute %s", value, vp->name);
          }
#line 1538
          if (fr_debug_flag) {
#line 1538
            if (fr_log_fp) {
              {
#line 1538
              fr_printf_log("Duplicate tag %s for attribute %s\n", value, vp->name);
              }
            }
          }
          {
#line 1540
          pairbasicfree(vp);
          }
#line 1541
          return ((VALUE_PAIR *)((void *)0));
        }
#line 1544
        if ((int const   )*(value + 1) == 42) {
#line 1544
          if ((int const   )*(value + 2) == 58) {
#line 1546
            tag = (signed char)-128;
#line 1547
            value += 3;
          } else {
#line 1544
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 1550
          tmp___1 = strtol((char const   */* __restrict  */)(value + 1), (char **/* __restrict  */)(& tc),
                           0);
#line 1550
          tag = (signed char )tmp___1;
          }
#line 1551
          if (tc) {
#line 1551
            if ((int )*tc == 58) {
#line 1551
              if ((int )tag < 32) {
#line 1552
                value = (char const   *)(tc + 1);
              } else {
#line 1553
                tag = (signed char)0;
              }
            } else {
#line 1553
              tag = (signed char)0;
            }
          } else {
#line 1553
            tag = (signed char)0;
          }
        }
#line 1555
        found_tag = 1;
      }
    }
  }
#line 1558
  if (found_tag) {
#line 1559
    vp->flags.tag = tag;
  }
  {
#line 1571
  if ((unsigned int )vp->operator == 20U) {
#line 1571
    goto case_20;
  }
#line 1571
  if ((unsigned int )vp->operator == 19U) {
#line 1571
    goto case_20;
  }
#line 1583
  if ((unsigned int )vp->operator == 18U) {
#line 1583
    goto case_18;
  }
#line 1583
  if ((unsigned int )vp->operator == 17U) {
#line 1583
    goto case_18;
  }
#line 1563
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1564
  goto switch_break;
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
#line 1572
  vp->data.strvalue[0] = (char )'\000';
#line 1573
  vp->length = (size_t )0;
#line 1574
  return (vp);
#line 1575
  goto switch_break;
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
#line 1584
  if (! value) {
    {
#line 1585
    fr_strerror_printf("No regular expression found in %s", vp->name);
#line 1587
    pairbasicfree(vp);
    }
#line 1588
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1591
  strlcpy(vp->data.strvalue, value, sizeof(vp->data.strvalue));
#line 1592
  vp->length = strlen((char const   *)(vp->data.strvalue));
  }
#line 1597
  return (vp);
  switch_break: /* CIL Label */ ;
  }
#line 1609
  if (value) {
    {
#line 1609
    tmp___2 = pairparsevalue(vp, value);
    }
#line 1609
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 1610
      pairbasicfree(vp);
      }
#line 1611
      return ((VALUE_PAIR *)((void *)0));
    }
  }
#line 1614
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 1644 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *pairread(char const   **ptr , FR_TOKEN *eol ) 
{ 
  char buf[64] ;
  char attr[64] ;
  char value[1024] ;
  char *q ;
  char const   *p ;
  FR_TOKEN token ;
  FR_TOKEN t ;
  FR_TOKEN xlat ;
  VALUE_PAIR *vp ;
  size_t len ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  VALUE_PAIR *tmp___3 ;
  size_t tmp___4 ;

  {
#line 1654
  *eol = (FR_TOKEN )0;
#line 1656
  p = *ptr;
  {
#line 1657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1657
    if (! ((int const   )*p == 32)) {
#line 1657
      if (! ((int const   )*p == 9)) {
#line 1657
        goto while_break;
      }
    }
#line 1657
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1659
  if (! *p) {
    {
#line 1660
    *eol = (FR_TOKEN )0;
#line 1661
    fr_strerror_printf("No token read where we expected an attribute name");
    }
#line 1662
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1665
  if ((int const   )*p == 35) {
    {
#line 1666
    *eol = (FR_TOKEN )22;
#line 1667
    fr_strerror_printf("Read a comment instead of a token");
    }
#line 1668
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1671
  q = attr;
#line 1672
  len = (size_t )0;
  {
#line 1672
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1672
    if (! (len < sizeof(attr))) {
#line 1672
      goto while_break___0;
    }
#line 1673
    if (valid_attr_name[(int )*p]) {
#line 1674
      tmp = q;
#line 1674
      q ++;
#line 1674
      tmp___0 = p;
#line 1674
      p ++;
#line 1674
      *tmp = (char )*tmp___0;
#line 1675
      goto __Cont;
    }
#line 1677
    goto while_break___0;
    __Cont: /* CIL Label */ 
#line 1672
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1680
  if (len == sizeof(attr)) {
    {
#line 1681
    *eol = (FR_TOKEN )0;
#line 1682
    fr_strerror_printf("Attribute name is too long");
    }
#line 1683
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1689
  if (len > 0UL) {
#line 1689
    if ((int )attr[len - 1UL] == 58) {
#line 1690
      p --;
#line 1691
      len --;
    }
  }
  {
#line 1694
  attr[len] = (char )'\000';
#line 1695
  *ptr = p;
#line 1698
  token = gettoken(ptr, buf, (int )sizeof(buf));
  }
#line 1699
  if ((unsigned int )token < 8U) {
    {
#line 1700
    fr_strerror_printf("expecting operator");
    }
#line 1701
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1699
  if ((unsigned int )token > 22U) {
    {
#line 1700
    fr_strerror_printf("expecting operator");
    }
#line 1701
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1705
  xlat = gettoken(ptr, value, (int )sizeof(value));
  }
#line 1706
  if ((unsigned int )xlat == 1U) {
    {
#line 1707
    fr_strerror_printf("failed to get value");
    }
#line 1708
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1714
  p = *ptr;
#line 1715
  t = gettoken(& p, buf, (int )sizeof(buf));
  }
#line 1716
  if ((unsigned int )t != 1U) {
#line 1716
    if ((unsigned int )t != 6U) {
#line 1716
      if ((unsigned int )t != 22U) {
        {
#line 1717
        fr_strerror_printf("Expected end of line or comma");
        }
#line 1718
        return ((VALUE_PAIR *)((void *)0));
      }
    }
  }
#line 1721
  *eol = t;
#line 1722
  if ((unsigned int )t == 6U) {
#line 1723
    *ptr = p;
  }
#line 1726
  vp = (VALUE_PAIR *)((void *)0);
  {
#line 1738
  if ((unsigned int )xlat == 24U) {
#line 1738
    goto case_24;
  }
#line 1767
  if ((unsigned int )xlat == 25U) {
#line 1767
    goto case_25;
  }
#line 1797
  if ((unsigned int )xlat == 26U) {
#line 1797
    goto case_26;
  }
#line 1731
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1732
  vp = pairmake((char const   *)(attr), (char const   *)(value), (int )token);
  }
#line 1733
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 1739
  tmp___1 = strchr((char const   *)(value), '%');
#line 1739
  p = (char const   *)tmp___1;
  }
#line 1740
  if (p) {
#line 1740
    if ((int const   )*(p + 1) == 123) {
      {
#line 1741
      tmp___2 = strlen((char const   *)(value));
      }
#line 1741
      if (tmp___2 >= sizeof(vp->data.strvalue)) {
        {
#line 1742
        fr_strerror_printf("Value too long");
        }
#line 1743
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1745
      vp = pairmake((char const   *)(attr), (char const   *)((void *)0), (int )token);
      }
#line 1746
      if (! vp) {
#line 1747
        *eol = (FR_TOKEN )0;
#line 1748
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1751
      strlcpy(vp->data.strvalue, (char const   *)(value), sizeof(vp->data.strvalue));
#line 1752
      vp->flags.do_xlat = 1U;
#line 1753
      vp->length = (size_t )0;
      }
    } else {
#line 1740
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1759
    vp = pairmake((char const   *)(attr), (char const   *)(value), (int )token);
    }
#line 1760
    if (! vp) {
#line 1761
      *eol = (FR_TOKEN )0;
#line 1762
      return ((VALUE_PAIR *)((void *)0));
    }
  }
#line 1765
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 1768
  vp = pairmake((char const   *)(attr), (char const   *)((void *)0), (int )token);
  }
#line 1769
  if (! vp) {
#line 1770
    *eol = (FR_TOKEN )0;
#line 1771
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1777
  if (vp->type == 0) {
    {
#line 1779
    strlcpy(vp->data.strvalue, (char const   *)(value), sizeof(vp->data.strvalue));
#line 1781
    vp->length = strlen((char const   *)(vp->data.strvalue));
    }
  } else
#line 1777
  if (vp->type == 5) {
    {
#line 1779
    strlcpy(vp->data.strvalue, (char const   *)(value), sizeof(vp->data.strvalue));
#line 1781
    vp->length = strlen((char const   *)(vp->data.strvalue));
    }
  } else {
    {
#line 1787
    tmp___3 = pairparsevalue(vp, (char const   *)(value));
    }
#line 1787
    if (! tmp___3) {
      {
#line 1788
      pairfree(& vp);
#line 1789
      *eol = (FR_TOKEN )0;
      }
#line 1790
      return ((VALUE_PAIR *)((void *)0));
    }
  }
#line 1792
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 1798
  tmp___4 = strlen((char const   *)(value));
  }
#line 1798
  if (tmp___4 >= sizeof(vp->data.strvalue)) {
    {
#line 1799
    fr_strerror_printf("Value too long");
    }
#line 1800
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1803
  vp = pairmake((char const   *)(attr), (char const   *)((void *)0), (int )token);
  }
#line 1804
  if (! vp) {
#line 1805
    *eol = (FR_TOKEN )0;
#line 1806
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1809
  vp->flags.do_xlat = 1U;
#line 1810
  strlcpy(vp->data.strvalue, (char const   *)(value), sizeof(vp->data.strvalue));
#line 1811
  vp->length = (size_t )0;
  }
#line 1812
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1818
  if (! vp) {
#line 1819
    *eol = (FR_TOKEN )0;
#line 1820
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1823
  return (vp);
}
}
#line 1830 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
FR_TOKEN userparse(char const   *buffer , VALUE_PAIR **first_pair ) 
{ 
  VALUE_PAIR *vp ;
  char const   *p ;
  FR_TOKEN last_token ;
  FR_TOKEN previous_token ;

  {
#line 1834
  last_token = (FR_TOKEN )0;
#line 1840
  if ((int const   )*(buffer + 0) == 0) {
#line 1841
    return ((FR_TOKEN )1);
  }
#line 1843
  p = buffer;
  {
#line 1844
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1845
    previous_token = last_token;
#line 1846
    vp = pairread(& p, & last_token);
    }
#line 1846
    if ((unsigned long )vp == (unsigned long )((void *)0)) {
#line 1847
      return (last_token);
    }
    {
#line 1849
    pairadd(first_pair, vp);
    }
#line 1844
    if (*p) {
#line 1844
      if (! ((unsigned int )last_token == 6U)) {
#line 1844
        goto while_break;
      }
    } else {
#line 1844
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1855
  if ((unsigned int )last_token == 22U) {
#line 1856
    return (previous_token);
  }
#line 1862
  return (last_token);
}
}
#line 1870 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
VALUE_PAIR *readvp2(FILE *fp , int *pfiledone , char const   *errprefix ) 
{ 
  char buf[8192] ;
  FR_TOKEN last_token ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *list ;
  int error ;
  char *tmp ;
  VALUE_PAIR *tmp___0 ;

  {
#line 1873
  last_token = (FR_TOKEN )1;
#line 1876
  error = 0;
#line 1878
  list = (VALUE_PAIR *)((void *)0);
  {
#line 1880
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1880
    if (! error) {
      {
#line 1880
      tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
#line 1880
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1880
        goto while_break;
      }
    } else {
#line 1880
      goto while_break;
    }
#line 1885
    if ((int )buf[0] == 10) {
#line 1885
      if (list) {
#line 1886
        return (list);
      }
    }
#line 1888
    if ((int )buf[0] == 10) {
#line 1888
      if (! list) {
#line 1889
        goto while_continue;
      }
    }
#line 1895
    if ((int )buf[0] == 35) {
#line 1895
      goto while_continue;
    }
    {
#line 1900
    vp = (VALUE_PAIR *)((void *)0);
#line 1901
    last_token = userparse((char const   *)(buf), & vp);
    }
#line 1902
    if (! vp) {
#line 1903
      if ((unsigned int )last_token != 1U) {
        {
#line 1904
        fr_perror("%s", errprefix);
#line 1905
        error = 1;
        }
#line 1906
        goto while_break;
      }
#line 1908
      goto while_break;
    }
    {
#line 1911
    pairadd(& list, vp);
#line 1912
    buf[0] = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1915
  if (error) {
    {
#line 1915
    pairfree(& list);
    }
  }
#line 1917
  *pfiledone = 1;
#line 1919
  if (error) {
#line 1919
    tmp___0 = (VALUE_PAIR *)((void *)0);
  } else {
#line 1919
    tmp___0 = list;
  }
#line 1919
  return (tmp___0);
}
}
#line 1937 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
int paircmp(VALUE_PAIR *one , VALUE_PAIR *two ) 
{ 
  int compare ;
  regex_t reg ;
  char buffer[1017] ;
  size_t length ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 1942
  if ((unsigned int )one->operator == 19U) {
#line 1942
    goto case_19;
  }
#line 1945
  if ((unsigned int )one->operator == 20U) {
#line 1945
    goto case_20;
  }
#line 1953
  if ((unsigned int )one->operator == 18U) {
#line 1953
    goto case_18;
  }
#line 1953
  if ((unsigned int )one->operator == 17U) {
#line 1953
    goto case_18;
  }
#line 1984
  goto switch_default;
  case_19: /* CIL Label */ 
#line 1943
  return ((unsigned long )two != (unsigned long )((void *)0));
  case_20: /* CIL Label */ 
#line 1946
  return ((unsigned long )two == (unsigned long )((void *)0));
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  {
#line 1961
  compare = regcomp((regex_t */* __restrict  */)(& reg), (char const   */* __restrict  */)(one->data.strvalue),
                    1);
  }
#line 1963
  if (compare != 0) {
    {
#line 1964
    regerror(compare, (regex_t const   */* __restrict  */)(& reg), (char */* __restrict  */)(buffer),
             sizeof(buffer));
#line 1965
    fr_strerror_printf("Illegal regular expression in attribute: %s: %s", one->name,
                       buffer);
    }
#line 1967
    return (-1);
  }
  {
#line 1970
  vp_prints_value(buffer, sizeof(buffer), two, 0);
#line 1976
  compare = regexec((regex_t const   */* __restrict  */)(& reg), (char const   */* __restrict  */)(buffer),
                    (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 1978
  regfree(& reg);
  }
#line 1979
  if ((unsigned int )one->operator == 17U) {
#line 1979
    return (compare == 0);
  }
#line 1980
  return (compare != 0);
  switch_default: /* CIL Label */ 
#line 1985
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1994
  if (one->type == 5) {
#line 1994
    goto case_5;
  }
#line 1994
  if (one->type == 4) {
#line 1994
    goto case_5;
  }
#line 2020
  if (one->type == 0) {
#line 2020
    goto case_0;
  }
#line 2027
  if (one->type == 3) {
#line 2027
    goto case_3;
  }
#line 2027
  if (one->type == 1) {
#line 2027
    goto case_3;
  }
#line 2027
  if (one->type == 10) {
#line 2027
    goto case_3;
  }
#line 2027
  if (one->type == 9) {
#line 2027
    goto case_3;
  }
#line 2031
  if (one->type == 2) {
#line 2031
    goto case_2;
  }
#line 2035
  if (one->type == 7) {
#line 2035
    goto case_7;
  }
#line 2040
  if (one->type == 8) {
#line 2040
    goto case_8;
  }
#line 2045
  if (one->type == 6) {
#line 2045
    goto case_6;
  }
#line 2050
  goto switch_default___0;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1998
  if (one->length < two->length) {
#line 1999
    length = one->length;
  } else {
#line 2001
    length = two->length;
  }
#line 2004
  if (length) {
    {
#line 2005
    compare = memcmp((void const   *)(two->data.octets), (void const   *)(one->data.octets),
                     length);
    }
#line 2007
    if (compare != 0) {
#line 2007
      goto switch_break___0;
    }
  }
#line 2016
  compare = (int )(two->length - one->length);
#line 2018
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 2021
  compare = strcmp((char const   *)(two->data.strvalue), (char const   *)(one->data.strvalue));
  }
#line 2022
  goto switch_break___0;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 2028
  compare = (int )(two->lvalue - one->lvalue);
#line 2029
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 2032
  tmp = ntohl(two->lvalue);
#line 2032
  tmp___0 = ntohl(one->lvalue);
#line 2032
  compare = (int )(tmp - tmp___0);
  }
#line 2033
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 2036
  compare = memcmp((void const   *)(& two->data.ipv6addr), (void const   *)(& one->data.ipv6addr),
                   sizeof(two->data.ipv6addr));
  }
#line 2038
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 2041
  compare = memcmp((void const   *)(& two->data.ipv6prefix), (void const   *)(& one->data.ipv6prefix),
                   sizeof(two->data.ipv6prefix));
  }
#line 2043
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 2046
  compare = memcmp((void const   *)(& two->data.ifid), (void const   *)(& one->data.ifid),
                   sizeof(two->data.ifid));
  }
#line 2048
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2051
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 2058
  if ((unsigned int )one->operator == 21U) {
#line 2058
    goto case_21;
  }
#line 2061
  if ((unsigned int )one->operator == 12U) {
#line 2061
    goto case_12;
  }
#line 2064
  if ((unsigned int )one->operator == 16U) {
#line 2064
    goto case_16;
  }
#line 2067
  if ((unsigned int )one->operator == 14U) {
#line 2067
    goto case_14;
  }
#line 2070
  if ((unsigned int )one->operator == 15U) {
#line 2070
    goto case_15;
  }
#line 2073
  if ((unsigned int )one->operator == 13U) {
#line 2073
    goto case_13;
  }
#line 2076
  goto switch_default___1;
  case_21: /* CIL Label */ 
#line 2059
  return (compare == 0);
  case_12: /* CIL Label */ 
#line 2062
  return (compare != 0);
  case_16: /* CIL Label */ 
#line 2065
  return (compare < 0);
  case_14: /* CIL Label */ 
#line 2068
  return (compare > 0);
  case_15: /* CIL Label */ 
#line 2071
  return (compare <= 0);
  case_13: /* CIL Label */ 
#line 2074
  return (compare >= 0);
  switch_default___1: /* CIL Label */ 
#line 2077
  return (0);
  switch_break___1: /* CIL Label */ ;
  }
#line 2080
  return (0);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 373
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ 
  char *d ;
  char const   *s ;
  size_t n ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 45
  d = dst;
#line 46
  s = src;
#line 47
  n = siz;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    tmp = n;
#line 51
    n --;
#line 51
    if (tmp != 0UL) {
#line 51
      if (! ((int )*d != 0)) {
#line 51
        goto while_break;
      }
    } else {
#line 51
      goto while_break;
    }
#line 52
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  dlen = (size_t )(d - dst);
#line 54
  n = siz - dlen;
#line 56
  if (n == 0UL) {
    {
#line 57
    tmp___0 = strlen(s);
    }
#line 57
    return (dlen + tmp___0);
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! ((int const   )*s != 0)) {
#line 58
      goto while_break___0;
    }
#line 59
    if (n != 1UL) {
#line 60
      tmp___1 = d;
#line 60
      d ++;
#line 60
      *tmp___1 = (char )*s;
#line 61
      n --;
    }
#line 63
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 65
  *d = (char )'\000';
#line 67
  return (dlen + (size_t )(s - src));
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
void fr_md5_calc(uint8_t *output , uint8_t const   *input , unsigned int inlen ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69
void fr_MD5Init(FR_MD5_CTX *ctx ) ;
#line 70
void fr_MD5Update(FR_MD5_CTX *ctx , unsigned char const   *input , size_t len ) ;
#line 72
void fr_MD5Final(uint8_t *digest , FR_MD5_CTX *ctx ) ;
#line 74
void fr_MD5Transform(uint32_t *state , uint8_t const   *block ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
void fr_md5_calc(uint8_t *output , uint8_t const   *input , unsigned int inlen ) 
{ 
  FR_MD5_CTX context ;

  {
  {
#line 26
  fr_MD5Init(& context);
#line 27
  fr_MD5Update(& context, input, (size_t )inlen);
#line 28
  fr_MD5Final((uint8_t *)output, & context);
  }
#line 29
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING[64]  = 
#line 78
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 88 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
void fr_MD5Init(FR_MD5_CTX *ctx ) 
{ 


  {
#line 91
  ctx->count[0] = (uint32_t )0;
#line 92
  ctx->count[1] = (uint32_t )0;
#line 93
  ctx->state[0] = (uint32_t )1732584193;
#line 94
  ctx->state[1] = 4023233417U;
#line 95
  ctx->state[2] = 2562383102U;
#line 96
  ctx->state[3] = (uint32_t )271733878;
#line 97
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
void fr_MD5Update(FR_MD5_CTX *ctx , unsigned char const   *input , size_t len ) 
{ 
  size_t have ;
  size_t need ;
  uint32_t tmp ;

  {
#line 109
  have = (size_t )((ctx->count[0] >> 3) & 63U);
#line 110
  need = 64UL - have;
#line 114
  tmp = ctx->count[0] + ((uint32_t )len << 3);
#line 114
  ctx->count[0] = tmp;
#line 114
  if (tmp < (uint32_t )len) {
#line 116
    (ctx->count[1]) ++;
  }
#line 118
  ctx->count[1] += (uint32_t )len >> 29;
#line 120
  if (len >= need) {
#line 121
    if (have != 0UL) {
      {
#line 122
      memcpy((void */* __restrict  */)(ctx->buffer + have), (void const   */* __restrict  */)input,
             need);
#line 123
      fr_MD5Transform((uint32_t *)(ctx->state), (uint8_t const   *)(ctx->buffer));
#line 124
      input += need;
#line 125
      len -= need;
#line 126
      have = (size_t )0;
      }
    }
    {
#line 130
    while (1) {
      while_continue: /* CIL Label */ ;
#line 130
      if (! (len >= 64UL)) {
#line 130
        goto while_break;
      }
      {
#line 131
      fr_MD5Transform((uint32_t *)(ctx->state), (uint8_t const   *)input);
#line 132
      input += 64;
#line 133
      len -= 64UL;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 138
  if (len != 0UL) {
    {
#line 139
    memcpy((void */* __restrict  */)(ctx->buffer + have), (void const   */* __restrict  */)input,
           len);
    }
  }
#line 140
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
void fr_MD5Final(uint8_t *digest , FR_MD5_CTX *ctx ) 
{ 
  uint8_t count[8] ;
  size_t padlen ;
  int i ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    count[7] = (uint8_t )(ctx->count[1] >> 24);
#line 154
    count[6] = (uint8_t )(ctx->count[1] >> 16);
#line 154
    count[5] = (uint8_t )(ctx->count[1] >> 8);
#line 154
    count[4] = (uint8_t )ctx->count[1];
#line 154
    count[3] = (uint8_t )(ctx->count[0] >> 24);
#line 154
    count[2] = (uint8_t )(ctx->count[0] >> 16);
#line 154
    count[1] = (uint8_t )(ctx->count[0] >> 8);
#line 154
    count[0] = (uint8_t )ctx->count[0];
#line 154
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  padlen = (size_t )(64U - ((ctx->count[0] >> 3) & 63U));
#line 159
  if (padlen < 9UL) {
#line 160
    padlen += 64UL;
  }
  {
#line 161
  fr_MD5Update(ctx, PADDING, padlen - 8UL);
#line 162
  fr_MD5Update(ctx, (unsigned char const   *)(count), (size_t )8);
  }
#line 164
  if ((unsigned long )digest != (unsigned long )((void *)0)) {
#line 165
    i = 0;
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 165
      if (! (i < 4)) {
#line 165
        goto while_break___0;
      }
      {
#line 166
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 166
        *((digest + i * 4) + 3) = (uint8_t )(ctx->state[i] >> 24);
#line 166
        *((digest + i * 4) + 2) = (uint8_t )(ctx->state[i] >> 16);
#line 166
        *((digest + i * 4) + 1) = (uint8_t )(ctx->state[i] >> 8);
#line 166
        *((digest + i * 4) + 0) = (uint8_t )ctx->state[i];
#line 166
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 165
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 168
  memset((void *)ctx, 0, sizeof(*ctx));
  }
#line 169
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
void fr_MD5Transform(uint32_t *state , uint8_t const   *block ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t in[16] ;

  {
#line 194
  a = (uint32_t )0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (a < 16U)) {
#line 194
      goto while_break;
    }
#line 195
    in[a] = (((uint32_t )*(block + a * 4U) | ((uint32_t )*(block + (a * 4U + 1U)) << 8)) | ((uint32_t )*(block + (a * 4U + 2U)) << 16)) | ((uint32_t )*(block + (a * 4U + 3U)) << 24);
#line 194
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  a = *(state + 0);
#line 203
  b = *(state + 1);
#line 204
  c = *(state + 2);
#line 205
  d = *(state + 3);
#line 207
  a += ((d ^ (b & (c ^ d))) + in[0]) + 3614090360U;
#line 207
  a = (a << 7) | (a >> 25);
#line 207
  a += b;
#line 208
  d += ((c ^ (a & (b ^ c))) + in[1]) + 3905402710U;
#line 208
  d = (d << 12) | (d >> 20);
#line 208
  d += a;
#line 209
  c += ((b ^ (d & (a ^ b))) + in[2]) + 606105819U;
#line 209
  c = (c << 17) | (c >> 15);
#line 209
  c += d;
#line 210
  b += ((a ^ (c & (d ^ a))) + in[3]) + 3250441966U;
#line 210
  b = (b << 22) | (b >> 10);
#line 210
  b += c;
#line 211
  a += ((d ^ (b & (c ^ d))) + in[4]) + 4118548399U;
#line 211
  a = (a << 7) | (a >> 25);
#line 211
  a += b;
#line 212
  d += ((c ^ (a & (b ^ c))) + in[5]) + 1200080426U;
#line 212
  d = (d << 12) | (d >> 20);
#line 212
  d += a;
#line 213
  c += ((b ^ (d & (a ^ b))) + in[6]) + 2821735955U;
#line 213
  c = (c << 17) | (c >> 15);
#line 213
  c += d;
#line 214
  b += ((a ^ (c & (d ^ a))) + in[7]) + 4249261313U;
#line 214
  b = (b << 22) | (b >> 10);
#line 214
  b += c;
#line 215
  a += ((d ^ (b & (c ^ d))) + in[8]) + 1770035416U;
#line 215
  a = (a << 7) | (a >> 25);
#line 215
  a += b;
#line 216
  d += ((c ^ (a & (b ^ c))) + in[9]) + 2336552879U;
#line 216
  d = (d << 12) | (d >> 20);
#line 216
  d += a;
#line 217
  c += ((b ^ (d & (a ^ b))) + in[10]) + 4294925233U;
#line 217
  c = (c << 17) | (c >> 15);
#line 217
  c += d;
#line 218
  b += ((a ^ (c & (d ^ a))) + in[11]) + 2304563134U;
#line 218
  b = (b << 22) | (b >> 10);
#line 218
  b += c;
#line 219
  a += ((d ^ (b & (c ^ d))) + in[12]) + 1804603682U;
#line 219
  a = (a << 7) | (a >> 25);
#line 219
  a += b;
#line 220
  d += ((c ^ (a & (b ^ c))) + in[13]) + 4254626195U;
#line 220
  d = (d << 12) | (d >> 20);
#line 220
  d += a;
#line 221
  c += ((b ^ (d & (a ^ b))) + in[14]) + 2792965006U;
#line 221
  c = (c << 17) | (c >> 15);
#line 221
  c += d;
#line 222
  b += ((a ^ (c & (d ^ a))) + in[15]) + 1236535329U;
#line 222
  b = (b << 22) | (b >> 10);
#line 222
  b += c;
#line 224
  a += ((c ^ (d & (b ^ c))) + in[1]) + 4129170786U;
#line 224
  a = (a << 5) | (a >> 27);
#line 224
  a += b;
#line 225
  d += ((b ^ (c & (a ^ b))) + in[6]) + 3225465664U;
#line 225
  d = (d << 9) | (d >> 23);
#line 225
  d += a;
#line 226
  c += ((a ^ (b & (d ^ a))) + in[11]) + 643717713U;
#line 226
  c = (c << 14) | (c >> 18);
#line 226
  c += d;
#line 227
  b += ((d ^ (a & (c ^ d))) + in[0]) + 3921069994U;
#line 227
  b = (b << 20) | (b >> 12);
#line 227
  b += c;
#line 228
  a += ((c ^ (d & (b ^ c))) + in[5]) + 3593408605U;
#line 228
  a = (a << 5) | (a >> 27);
#line 228
  a += b;
#line 229
  d += ((b ^ (c & (a ^ b))) + in[10]) + 38016083U;
#line 229
  d = (d << 9) | (d >> 23);
#line 229
  d += a;
#line 230
  c += ((a ^ (b & (d ^ a))) + in[15]) + 3634488961U;
#line 230
  c = (c << 14) | (c >> 18);
#line 230
  c += d;
#line 231
  b += ((d ^ (a & (c ^ d))) + in[4]) + 3889429448U;
#line 231
  b = (b << 20) | (b >> 12);
#line 231
  b += c;
#line 232
  a += ((c ^ (d & (b ^ c))) + in[9]) + 568446438U;
#line 232
  a = (a << 5) | (a >> 27);
#line 232
  a += b;
#line 233
  d += ((b ^ (c & (a ^ b))) + in[14]) + 3275163606U;
#line 233
  d = (d << 9) | (d >> 23);
#line 233
  d += a;
#line 234
  c += ((a ^ (b & (d ^ a))) + in[3]) + 4107603335U;
#line 234
  c = (c << 14) | (c >> 18);
#line 234
  c += d;
#line 235
  b += ((d ^ (a & (c ^ d))) + in[8]) + 1163531501U;
#line 235
  b = (b << 20) | (b >> 12);
#line 235
  b += c;
#line 236
  a += ((c ^ (d & (b ^ c))) + in[13]) + 2850285829U;
#line 236
  a = (a << 5) | (a >> 27);
#line 236
  a += b;
#line 237
  d += ((b ^ (c & (a ^ b))) + in[2]) + 4243563512U;
#line 237
  d = (d << 9) | (d >> 23);
#line 237
  d += a;
#line 238
  c += ((a ^ (b & (d ^ a))) + in[7]) + 1735328473U;
#line 238
  c = (c << 14) | (c >> 18);
#line 238
  c += d;
#line 239
  b += ((d ^ (a & (c ^ d))) + in[12]) + 2368359562U;
#line 239
  b = (b << 20) | (b >> 12);
#line 239
  b += c;
#line 241
  a += (((b ^ c) ^ d) + in[5]) + 4294588738U;
#line 241
  a = (a << 4) | (a >> 28);
#line 241
  a += b;
#line 242
  d += (((a ^ b) ^ c) + in[8]) + 2272392833U;
#line 242
  d = (d << 11) | (d >> 21);
#line 242
  d += a;
#line 243
  c += (((d ^ a) ^ b) + in[11]) + 1839030562U;
#line 243
  c = (c << 16) | (c >> 16);
#line 243
  c += d;
#line 244
  b += (((c ^ d) ^ a) + in[14]) + 4259657740U;
#line 244
  b = (b << 23) | (b >> 9);
#line 244
  b += c;
#line 245
  a += (((b ^ c) ^ d) + in[1]) + 2763975236U;
#line 245
  a = (a << 4) | (a >> 28);
#line 245
  a += b;
#line 246
  d += (((a ^ b) ^ c) + in[4]) + 1272893353U;
#line 246
  d = (d << 11) | (d >> 21);
#line 246
  d += a;
#line 247
  c += (((d ^ a) ^ b) + in[7]) + 4139469664U;
#line 247
  c = (c << 16) | (c >> 16);
#line 247
  c += d;
#line 248
  b += (((c ^ d) ^ a) + in[10]) + 3200236656U;
#line 248
  b = (b << 23) | (b >> 9);
#line 248
  b += c;
#line 249
  a += (((b ^ c) ^ d) + in[13]) + 681279174U;
#line 249
  a = (a << 4) | (a >> 28);
#line 249
  a += b;
#line 250
  d += (((a ^ b) ^ c) + in[0]) + 3936430074U;
#line 250
  d = (d << 11) | (d >> 21);
#line 250
  d += a;
#line 251
  c += (((d ^ a) ^ b) + in[3]) + 3572445317U;
#line 251
  c = (c << 16) | (c >> 16);
#line 251
  c += d;
#line 252
  b += (((c ^ d) ^ a) + in[6]) + 76029189U;
#line 252
  b = (b << 23) | (b >> 9);
#line 252
  b += c;
#line 253
  a += (((b ^ c) ^ d) + in[9]) + 3654602809U;
#line 253
  a = (a << 4) | (a >> 28);
#line 253
  a += b;
#line 254
  d += (((a ^ b) ^ c) + in[12]) + 3873151461U;
#line 254
  d = (d << 11) | (d >> 21);
#line 254
  d += a;
#line 255
  c += (((d ^ a) ^ b) + in[15]) + 530742520U;
#line 255
  c = (c << 16) | (c >> 16);
#line 255
  c += d;
#line 256
  b += (((c ^ d) ^ a) + in[2]) + 3299628645U;
#line 256
  b = (b << 23) | (b >> 9);
#line 256
  b += c;
#line 258
  a += ((c ^ (b | ~ d)) + in[0]) + 4096336452U;
#line 258
  a = (a << 6) | (a >> 26);
#line 258
  a += b;
#line 259
  d += ((b ^ (a | ~ c)) + in[7]) + 1126891415U;
#line 259
  d = (d << 10) | (d >> 22);
#line 259
  d += a;
#line 260
  c += ((a ^ (d | ~ b)) + in[14]) + 2878612391U;
#line 260
  c = (c << 15) | (c >> 17);
#line 260
  c += d;
#line 261
  b += ((d ^ (c | ~ a)) + in[5]) + 4237533241U;
#line 261
  b = (b << 21) | (b >> 11);
#line 261
  b += c;
#line 262
  a += ((c ^ (b | ~ d)) + in[12]) + 1700485571U;
#line 262
  a = (a << 6) | (a >> 26);
#line 262
  a += b;
#line 263
  d += ((b ^ (a | ~ c)) + in[3]) + 2399980690U;
#line 263
  d = (d << 10) | (d >> 22);
#line 263
  d += a;
#line 264
  c += ((a ^ (d | ~ b)) + in[10]) + 4293915773U;
#line 264
  c = (c << 15) | (c >> 17);
#line 264
  c += d;
#line 265
  b += ((d ^ (c | ~ a)) + in[1]) + 2240044497U;
#line 265
  b = (b << 21) | (b >> 11);
#line 265
  b += c;
#line 266
  a += ((c ^ (b | ~ d)) + in[8]) + 1873313359U;
#line 266
  a = (a << 6) | (a >> 26);
#line 266
  a += b;
#line 267
  d += ((b ^ (a | ~ c)) + in[15]) + 4264355552U;
#line 267
  d = (d << 10) | (d >> 22);
#line 267
  d += a;
#line 268
  c += ((a ^ (d | ~ b)) + in[6]) + 2734768916U;
#line 268
  c = (c << 15) | (c >> 17);
#line 268
  c += d;
#line 269
  b += ((d ^ (c | ~ a)) + in[13]) + 1309151649U;
#line 269
  b = (b << 21) | (b >> 11);
#line 269
  b += c;
#line 270
  a += ((c ^ (b | ~ d)) + in[4]) + 4149444226U;
#line 270
  a = (a << 6) | (a >> 26);
#line 270
  a += b;
#line 271
  d += ((b ^ (a | ~ c)) + in[11]) + 3174756917U;
#line 271
  d = (d << 10) | (d >> 22);
#line 271
  d += a;
#line 272
  c += ((a ^ (d | ~ b)) + in[2]) + 718787259U;
#line 272
  c = (c << 15) | (c >> 17);
#line 272
  c += d;
#line 273
  b += ((d ^ (c | ~ a)) + in[9]) + 3951481745U;
#line 273
  b = (b << 21) | (b >> 11);
#line 273
  b += c;
#line 275
  *(state + 0) += a;
#line 276
  *(state + 1) += b;
#line 277
  *(state + 2) += c;
#line 278
  *(state + 3) += d;
#line 279
  return;
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 20 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/sha1.h"
void fr_SHA1Init(fr_SHA1_CTX *context ) ;
#line 21
void fr_SHA1Update(fr_SHA1_CTX *context , uint8_t const   *data , unsigned int len ) ;
#line 22
void fr_SHA1Final(uint8_t *digest , fr_SHA1_CTX *context ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 296 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
void fr_hmac_sha1(uint8_t const   *text , int text_len , uint8_t const   *key , int key_len ,
                  uint8_t *digest ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
void fr_hmac_sha1(uint8_t const   *text , int text_len , uint8_t const   *key , int key_len ,
                  uint8_t *digest ) 
{ 
  fr_SHA1_CTX context ;
  uint8_t k_ipad[65] ;
  uint8_t k_opad[65] ;
  uint8_t tk[20] ;
  int i ;
  fr_SHA1_CTX tctx ;

  {
#line 45
  if (key_len > 64) {
    {
#line 49
    fr_SHA1Init(& tctx);
#line 50
    fr_SHA1Update(& tctx, key, (unsigned int )key_len);
#line 51
    fr_SHA1Final((uint8_t *)(tk), & tctx);
#line 53
    key = (uint8_t const   *)(tk);
#line 54
    key_len = 20;
    }
  }
  {
#line 109
  memset((void *)(k_ipad), 0, sizeof(k_ipad));
#line 110
  memset((void *)(k_opad), 0, sizeof(k_opad));
#line 111
  memcpy((void */* __restrict  */)(k_ipad), (void const   */* __restrict  */)key,
         (size_t )key_len);
#line 112
  memcpy((void */* __restrict  */)(k_opad), (void const   */* __restrict  */)key,
         (size_t )key_len);
#line 115
  i = 0;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i < 64)) {
#line 115
      goto while_break;
    }
#line 116
    k_ipad[i] = (uint8_t )((int )k_ipad[i] ^ 54);
#line 117
    k_opad[i] = (uint8_t )((int )k_opad[i] ^ 92);
#line 115
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  fr_SHA1Init(& context);
#line 124
  fr_SHA1Update(& context, (uint8_t const   *)(k_ipad), 64U);
#line 125
  fr_SHA1Update(& context, text, (unsigned int )text_len);
#line 126
  fr_SHA1Final((uint8_t *)digest, & context);
#line 130
  fr_SHA1Init(& context);
#line 132
  fr_SHA1Update(& context, (uint8_t const   *)(k_opad), 64U);
#line 133
  fr_SHA1Update(& context, (uint8_t const   *)digest, 20U);
#line 135
  fr_SHA1Final((uint8_t *)digest, & context);
  }
#line 156
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 505 "/usr/include/pthread.h"
extern int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *__once_control ,
                                                             void (*__init_routine)(void) ) ;
#line 1122
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_key_create)(pthread_key_t *__key ,
                                                                                                         void (*__destr_function)(void * ) ) ;
#line 1130
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key ) ;
#line 1133
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_setspecific)(pthread_key_t __key ,
                                                                                          void const   *__pointer ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
void ( /* format attribute */  fr_strerror_printf)(char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *buffer ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 89
  pthread_once(& fr_strerror_once, & fr_strerror_make_key);
#line 91
  tmp = pthread_getspecific(fr_strerror_key);
#line 91
  buffer = (char *)tmp;
  }
#line 92
  if (! buffer) {
    {
#line 93
    tmp___0 = malloc((size_t )1024);
#line 93
    buffer = (char *)tmp___0;
    }
#line 94
    if (! buffer) {
#line 94
      return;
    }
    {
#line 96
    pthread_setspecific(fr_strerror_key, (void const   *)buffer);
    }
  }
  {
#line 99
  __builtin_va_start(ap, fmt);
#line 100
  vsnprintf((char */* __restrict  */)buffer, (size_t )1024, (char const   */* __restrict  */)fmt,
            ap);
#line 107
  __builtin_va_end(ap);
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
char const   *fr_strerror(void) 
{ 
  char const   *msg ;
  void *tmp ;

  {
  {
#line 118
  pthread_once(& fr_strerror_once, & fr_strerror_make_key);
#line 120
  tmp = pthread_getspecific(fr_strerror_key);
#line 120
  msg = (char const   *)tmp;
  }
#line 121
  if (msg) {
#line 121
    return (msg);
  }
#line 123
  return ("(unknown error)");
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
void ( /* format attribute */  fr_perror)(char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 131
  __builtin_va_start(ap, fmt);
#line 132
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 133
  tmp = strchr(fmt, ':');
  }
#line 133
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 134
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": ");
    }
  }
  {
#line 135
  tmp___0 = fr_strerror();
#line 135
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp___0);
#line 136
  __builtin_va_end(ap);
  }
#line 137
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 19 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/sha1.h"
void fr_SHA1Transform(uint32_t *state , uint8_t const   *buffer ) ;
#line 30
void fr_SHA1FinalNoLen(uint8_t *digest , fr_SHA1_CTX *context ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
void fr_SHA1Transform(uint32_t *state , uint8_t const   *buffer ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  CHAR64LONG16 *block ;
  uint8_t workspace[64] ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  uint32_t tmp___33 ;
  uint32_t tmp___34 ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;
  uint32_t tmp___39 ;
  uint32_t tmp___40 ;
  uint32_t tmp___41 ;
  uint32_t tmp___42 ;
  uint32_t tmp___43 ;
  uint32_t tmp___44 ;
  uint32_t tmp___45 ;
  uint32_t tmp___46 ;
  uint32_t tmp___47 ;
  uint32_t tmp___48 ;
  uint32_t tmp___49 ;
  uint32_t tmp___50 ;
  uint32_t tmp___51 ;
  uint32_t tmp___52 ;
  uint32_t tmp___53 ;
  uint32_t tmp___54 ;
  uint32_t tmp___55 ;
  uint32_t tmp___56 ;
  uint32_t tmp___57 ;
  uint32_t tmp___58 ;
  uint32_t tmp___59 ;
  uint32_t tmp___60 ;
  uint32_t tmp___61 ;
  uint32_t tmp___62 ;
  uint32_t tmp___63 ;
  uint32_t tmp___64 ;
  uint32_t tmp___65 ;
  uint32_t tmp___66 ;
  uint32_t tmp___67 ;
  uint32_t tmp___68 ;
  uint32_t tmp___69 ;
  uint32_t tmp___70 ;
  uint32_t tmp___71 ;
  uint32_t tmp___72 ;
  uint32_t tmp___73 ;
  uint32_t tmp___74 ;
  uint32_t tmp___75 ;
  uint32_t tmp___76 ;
  uint32_t tmp___77 ;
  uint32_t tmp___78 ;

  {
  {
#line 50
  block = (CHAR64LONG16 *)(workspace);
#line 51
  memcpy((void */* __restrict  */)block, (void const   */* __restrict  */)buffer,
         (size_t )64);
#line 53
  a = *(state + 0);
#line 54
  b = *(state + 1);
#line 55
  c = *(state + 2);
#line 56
  d = *(state + 3);
#line 57
  e = *(state + 4);
#line 59
  tmp = htonl(block->l[0]);
#line 59
  block->l[0] = tmp;
#line 59
  e += ((((b & (c ^ d)) ^ d) + tmp) + 1518500249U) + ((a << 5) | (a >> 27));
#line 59
  b = (b << 30) | (b >> 2);
#line 59
  tmp___0 = htonl(block->l[1]);
#line 59
  block->l[1] = tmp___0;
#line 59
  d += ((((a & (b ^ c)) ^ c) + tmp___0) + 1518500249U) + ((e << 5) | (e >> 27));
#line 59
  a = (a << 30) | (a >> 2);
#line 59
  tmp___1 = htonl(block->l[2]);
#line 59
  block->l[2] = tmp___1;
#line 59
  c += ((((e & (a ^ b)) ^ b) + tmp___1) + 1518500249U) + ((d << 5) | (d >> 27));
#line 59
  e = (e << 30) | (e >> 2);
#line 59
  tmp___2 = htonl(block->l[3]);
#line 59
  block->l[3] = tmp___2;
#line 59
  b += ((((d & (e ^ a)) ^ a) + tmp___2) + 1518500249U) + ((c << 5) | (c >> 27));
#line 59
  d = (d << 30) | (d >> 2);
#line 60
  tmp___3 = htonl(block->l[4]);
#line 60
  block->l[4] = tmp___3;
#line 60
  a += ((((c & (d ^ e)) ^ e) + tmp___3) + 1518500249U) + ((b << 5) | (b >> 27));
#line 60
  c = (c << 30) | (c >> 2);
#line 60
  tmp___4 = htonl(block->l[5]);
#line 60
  block->l[5] = tmp___4;
#line 60
  e += ((((b & (c ^ d)) ^ d) + tmp___4) + 1518500249U) + ((a << 5) | (a >> 27));
#line 60
  b = (b << 30) | (b >> 2);
#line 60
  tmp___5 = htonl(block->l[6]);
#line 60
  block->l[6] = tmp___5;
#line 60
  d += ((((a & (b ^ c)) ^ c) + tmp___5) + 1518500249U) + ((e << 5) | (e >> 27));
#line 60
  a = (a << 30) | (a >> 2);
#line 60
  tmp___6 = htonl(block->l[7]);
#line 60
  block->l[7] = tmp___6;
#line 60
  c += ((((e & (a ^ b)) ^ b) + tmp___6) + 1518500249U) + ((d << 5) | (d >> 27));
#line 60
  e = (e << 30) | (e >> 2);
#line 61
  tmp___7 = htonl(block->l[8]);
#line 61
  block->l[8] = tmp___7;
#line 61
  b += ((((d & (e ^ a)) ^ a) + tmp___7) + 1518500249U) + ((c << 5) | (c >> 27));
#line 61
  d = (d << 30) | (d >> 2);
#line 61
  tmp___8 = htonl(block->l[9]);
#line 61
  block->l[9] = tmp___8;
#line 61
  a += ((((c & (d ^ e)) ^ e) + tmp___8) + 1518500249U) + ((b << 5) | (b >> 27));
#line 61
  c = (c << 30) | (c >> 2);
#line 61
  tmp___9 = htonl(block->l[10]);
#line 61
  block->l[10] = tmp___9;
#line 61
  e += ((((b & (c ^ d)) ^ d) + tmp___9) + 1518500249U) + ((a << 5) | (a >> 27));
#line 61
  b = (b << 30) | (b >> 2);
#line 61
  tmp___10 = htonl(block->l[11]);
#line 61
  block->l[11] = tmp___10;
#line 61
  d += ((((a & (b ^ c)) ^ c) + tmp___10) + 1518500249U) + ((e << 5) | (e >> 27));
#line 61
  a = (a << 30) | (a >> 2);
#line 62
  tmp___11 = htonl(block->l[12]);
#line 62
  block->l[12] = tmp___11;
#line 62
  c += ((((e & (a ^ b)) ^ b) + tmp___11) + 1518500249U) + ((d << 5) | (d >> 27));
#line 62
  e = (e << 30) | (e >> 2);
#line 62
  tmp___12 = htonl(block->l[13]);
#line 62
  block->l[13] = tmp___12;
#line 62
  b += ((((d & (e ^ a)) ^ a) + tmp___12) + 1518500249U) + ((c << 5) | (c >> 27));
#line 62
  d = (d << 30) | (d >> 2);
#line 62
  tmp___13 = htonl(block->l[14]);
#line 62
  block->l[14] = tmp___13;
#line 62
  a += ((((c & (d ^ e)) ^ e) + tmp___13) + 1518500249U) + ((b << 5) | (b >> 27));
#line 62
  c = (c << 30) | (c >> 2);
#line 62
  tmp___14 = htonl(block->l[15]);
#line 62
  block->l[15] = tmp___14;
#line 62
  e += ((((b & (c ^ d)) ^ d) + tmp___14) + 1518500249U) + ((a << 5) | (a >> 27));
#line 62
  b = (b << 30) | (b >> 2);
#line 63
  tmp___15 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 63
  block->l[0] = tmp___15;
#line 63
  d += ((((a & (b ^ c)) ^ c) + tmp___15) + 1518500249U) + ((e << 5) | (e >> 27));
#line 63
  a = (a << 30) | (a >> 2);
#line 63
  tmp___16 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 63
  block->l[1] = tmp___16;
#line 63
  c += ((((e & (a ^ b)) ^ b) + tmp___16) + 1518500249U) + ((d << 5) | (d >> 27));
#line 63
  e = (e << 30) | (e >> 2);
#line 63
  tmp___17 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 63
  block->l[2] = tmp___17;
#line 63
  b += ((((d & (e ^ a)) ^ a) + tmp___17) + 1518500249U) + ((c << 5) | (c >> 27));
#line 63
  d = (d << 30) | (d >> 2);
#line 63
  tmp___18 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 63
  block->l[3] = tmp___18;
#line 63
  a += ((((c & (d ^ e)) ^ e) + tmp___18) + 1518500249U) + ((b << 5) | (b >> 27));
#line 63
  c = (c << 30) | (c >> 2);
#line 64
  tmp___19 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 64
  block->l[4] = tmp___19;
#line 64
  e += ((((b ^ c) ^ d) + tmp___19) + 1859775393U) + ((a << 5) | (a >> 27));
#line 64
  b = (b << 30) | (b >> 2);
#line 64
  tmp___20 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 64
  block->l[5] = tmp___20;
#line 64
  d += ((((a ^ b) ^ c) + tmp___20) + 1859775393U) + ((e << 5) | (e >> 27));
#line 64
  a = (a << 30) | (a >> 2);
#line 64
  tmp___21 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 64
  block->l[6] = tmp___21;
#line 64
  c += ((((e ^ a) ^ b) + tmp___21) + 1859775393U) + ((d << 5) | (d >> 27));
#line 64
  e = (e << 30) | (e >> 2);
#line 64
  tmp___22 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 64
  block->l[7] = tmp___22;
#line 64
  b += ((((d ^ e) ^ a) + tmp___22) + 1859775393U) + ((c << 5) | (c >> 27));
#line 64
  d = (d << 30) | (d >> 2);
#line 65
  tmp___23 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 65
  block->l[8] = tmp___23;
#line 65
  a += ((((c ^ d) ^ e) + tmp___23) + 1859775393U) + ((b << 5) | (b >> 27));
#line 65
  c = (c << 30) | (c >> 2);
#line 65
  tmp___24 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 65
  block->l[9] = tmp___24;
#line 65
  e += ((((b ^ c) ^ d) + tmp___24) + 1859775393U) + ((a << 5) | (a >> 27));
#line 65
  b = (b << 30) | (b >> 2);
#line 65
  tmp___25 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 65
  block->l[10] = tmp___25;
#line 65
  d += ((((a ^ b) ^ c) + tmp___25) + 1859775393U) + ((e << 5) | (e >> 27));
#line 65
  a = (a << 30) | (a >> 2);
#line 65
  tmp___26 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 65
  block->l[11] = tmp___26;
#line 65
  c += ((((e ^ a) ^ b) + tmp___26) + 1859775393U) + ((d << 5) | (d >> 27));
#line 65
  e = (e << 30) | (e >> 2);
#line 66
  tmp___27 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 66
  block->l[12] = tmp___27;
#line 66
  b += ((((d ^ e) ^ a) + tmp___27) + 1859775393U) + ((c << 5) | (c >> 27));
#line 66
  d = (d << 30) | (d >> 2);
#line 66
  tmp___28 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 66
  block->l[13] = tmp___28;
#line 66
  a += ((((c ^ d) ^ e) + tmp___28) + 1859775393U) + ((b << 5) | (b >> 27));
#line 66
  c = (c << 30) | (c >> 2);
#line 66
  tmp___29 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 66
  block->l[14] = tmp___29;
#line 66
  e += ((((b ^ c) ^ d) + tmp___29) + 1859775393U) + ((a << 5) | (a >> 27));
#line 66
  b = (b << 30) | (b >> 2);
#line 66
  tmp___30 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 66
  block->l[15] = tmp___30;
#line 66
  d += ((((a ^ b) ^ c) + tmp___30) + 1859775393U) + ((e << 5) | (e >> 27));
#line 66
  a = (a << 30) | (a >> 2);
#line 67
  tmp___31 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 67
  block->l[0] = tmp___31;
#line 67
  c += ((((e ^ a) ^ b) + tmp___31) + 1859775393U) + ((d << 5) | (d >> 27));
#line 67
  e = (e << 30) | (e >> 2);
#line 67
  tmp___32 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 67
  block->l[1] = tmp___32;
#line 67
  b += ((((d ^ e) ^ a) + tmp___32) + 1859775393U) + ((c << 5) | (c >> 27));
#line 67
  d = (d << 30) | (d >> 2);
#line 67
  tmp___33 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 67
  block->l[2] = tmp___33;
#line 67
  a += ((((c ^ d) ^ e) + tmp___33) + 1859775393U) + ((b << 5) | (b >> 27));
#line 67
  c = (c << 30) | (c >> 2);
#line 67
  tmp___34 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 67
  block->l[3] = tmp___34;
#line 67
  e += ((((b ^ c) ^ d) + tmp___34) + 1859775393U) + ((a << 5) | (a >> 27));
#line 67
  b = (b << 30) | (b >> 2);
#line 68
  tmp___35 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 68
  block->l[4] = tmp___35;
#line 68
  d += ((((a ^ b) ^ c) + tmp___35) + 1859775393U) + ((e << 5) | (e >> 27));
#line 68
  a = (a << 30) | (a >> 2);
#line 68
  tmp___36 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 68
  block->l[5] = tmp___36;
#line 68
  c += ((((e ^ a) ^ b) + tmp___36) + 1859775393U) + ((d << 5) | (d >> 27));
#line 68
  e = (e << 30) | (e >> 2);
#line 68
  tmp___37 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 68
  block->l[6] = tmp___37;
#line 68
  b += ((((d ^ e) ^ a) + tmp___37) + 1859775393U) + ((c << 5) | (c >> 27));
#line 68
  d = (d << 30) | (d >> 2);
#line 68
  tmp___38 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 68
  block->l[7] = tmp___38;
#line 68
  a += ((((c ^ d) ^ e) + tmp___38) + 1859775393U) + ((b << 5) | (b >> 27));
#line 68
  c = (c << 30) | (c >> 2);
#line 69
  tmp___39 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 69
  block->l[8] = tmp___39;
#line 69
  e += (((((b | c) & d) | (b & c)) + tmp___39) + 2400959708U) + ((a << 5) | (a >> 27));
#line 69
  b = (b << 30) | (b >> 2);
#line 69
  tmp___40 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 69
  block->l[9] = tmp___40;
#line 69
  d += (((((a | b) & c) | (a & b)) + tmp___40) + 2400959708U) + ((e << 5) | (e >> 27));
#line 69
  a = (a << 30) | (a >> 2);
#line 69
  tmp___41 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 69
  block->l[10] = tmp___41;
#line 69
  c += (((((e | a) & b) | (e & a)) + tmp___41) + 2400959708U) + ((d << 5) | (d >> 27));
#line 69
  e = (e << 30) | (e >> 2);
#line 69
  tmp___42 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 69
  block->l[11] = tmp___42;
#line 69
  b += (((((d | e) & a) | (d & e)) + tmp___42) + 2400959708U) + ((c << 5) | (c >> 27));
#line 69
  d = (d << 30) | (d >> 2);
#line 70
  tmp___43 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 70
  block->l[12] = tmp___43;
#line 70
  a += (((((c | d) & e) | (c & d)) + tmp___43) + 2400959708U) + ((b << 5) | (b >> 27));
#line 70
  c = (c << 30) | (c >> 2);
#line 70
  tmp___44 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 70
  block->l[13] = tmp___44;
#line 70
  e += (((((b | c) & d) | (b & c)) + tmp___44) + 2400959708U) + ((a << 5) | (a >> 27));
#line 70
  b = (b << 30) | (b >> 2);
#line 70
  tmp___45 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 70
  block->l[14] = tmp___45;
#line 70
  d += (((((a | b) & c) | (a & b)) + tmp___45) + 2400959708U) + ((e << 5) | (e >> 27));
#line 70
  a = (a << 30) | (a >> 2);
#line 70
  tmp___46 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 70
  block->l[15] = tmp___46;
#line 70
  c += (((((e | a) & b) | (e & a)) + tmp___46) + 2400959708U) + ((d << 5) | (d >> 27));
#line 70
  e = (e << 30) | (e >> 2);
#line 71
  tmp___47 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 71
  block->l[0] = tmp___47;
#line 71
  b += (((((d | e) & a) | (d & e)) + tmp___47) + 2400959708U) + ((c << 5) | (c >> 27));
#line 71
  d = (d << 30) | (d >> 2);
#line 71
  tmp___48 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 71
  block->l[1] = tmp___48;
#line 71
  a += (((((c | d) & e) | (c & d)) + tmp___48) + 2400959708U) + ((b << 5) | (b >> 27));
#line 71
  c = (c << 30) | (c >> 2);
#line 71
  tmp___49 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 71
  block->l[2] = tmp___49;
#line 71
  e += (((((b | c) & d) | (b & c)) + tmp___49) + 2400959708U) + ((a << 5) | (a >> 27));
#line 71
  b = (b << 30) | (b >> 2);
#line 71
  tmp___50 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 71
  block->l[3] = tmp___50;
#line 71
  d += (((((a | b) & c) | (a & b)) + tmp___50) + 2400959708U) + ((e << 5) | (e >> 27));
#line 71
  a = (a << 30) | (a >> 2);
#line 72
  tmp___51 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 72
  block->l[4] = tmp___51;
#line 72
  c += (((((e | a) & b) | (e & a)) + tmp___51) + 2400959708U) + ((d << 5) | (d >> 27));
#line 72
  e = (e << 30) | (e >> 2);
#line 72
  tmp___52 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 72
  block->l[5] = tmp___52;
#line 72
  b += (((((d | e) & a) | (d & e)) + tmp___52) + 2400959708U) + ((c << 5) | (c >> 27));
#line 72
  d = (d << 30) | (d >> 2);
#line 72
  tmp___53 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 72
  block->l[6] = tmp___53;
#line 72
  a += (((((c | d) & e) | (c & d)) + tmp___53) + 2400959708U) + ((b << 5) | (b >> 27));
#line 72
  c = (c << 30) | (c >> 2);
#line 72
  tmp___54 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 72
  block->l[7] = tmp___54;
#line 72
  e += (((((b | c) & d) | (b & c)) + tmp___54) + 2400959708U) + ((a << 5) | (a >> 27));
#line 72
  b = (b << 30) | (b >> 2);
#line 73
  tmp___55 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 73
  block->l[8] = tmp___55;
#line 73
  d += (((((a | b) & c) | (a & b)) + tmp___55) + 2400959708U) + ((e << 5) | (e >> 27));
#line 73
  a = (a << 30) | (a >> 2);
#line 73
  tmp___56 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 73
  block->l[9] = tmp___56;
#line 73
  c += (((((e | a) & b) | (e & a)) + tmp___56) + 2400959708U) + ((d << 5) | (d >> 27));
#line 73
  e = (e << 30) | (e >> 2);
#line 73
  tmp___57 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 73
  block->l[10] = tmp___57;
#line 73
  b += (((((d | e) & a) | (d & e)) + tmp___57) + 2400959708U) + ((c << 5) | (c >> 27));
#line 73
  d = (d << 30) | (d >> 2);
#line 73
  tmp___58 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 73
  block->l[11] = tmp___58;
#line 73
  a += (((((c | d) & e) | (c & d)) + tmp___58) + 2400959708U) + ((b << 5) | (b >> 27));
#line 73
  c = (c << 30) | (c >> 2);
#line 74
  tmp___59 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 74
  block->l[12] = tmp___59;
#line 74
  e += ((((b ^ c) ^ d) + tmp___59) + 3395469782U) + ((a << 5) | (a >> 27));
#line 74
  b = (b << 30) | (b >> 2);
#line 74
  tmp___60 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 74
  block->l[13] = tmp___60;
#line 74
  d += ((((a ^ b) ^ c) + tmp___60) + 3395469782U) + ((e << 5) | (e >> 27));
#line 74
  a = (a << 30) | (a >> 2);
#line 74
  tmp___61 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 74
  block->l[14] = tmp___61;
#line 74
  c += ((((e ^ a) ^ b) + tmp___61) + 3395469782U) + ((d << 5) | (d >> 27));
#line 74
  e = (e << 30) | (e >> 2);
#line 74
  tmp___62 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 74
  block->l[15] = tmp___62;
#line 74
  b += ((((d ^ e) ^ a) + tmp___62) + 3395469782U) + ((c << 5) | (c >> 27));
#line 74
  d = (d << 30) | (d >> 2);
#line 75
  tmp___63 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 75
  block->l[0] = tmp___63;
#line 75
  a += ((((c ^ d) ^ e) + tmp___63) + 3395469782U) + ((b << 5) | (b >> 27));
#line 75
  c = (c << 30) | (c >> 2);
#line 75
  tmp___64 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 75
  block->l[1] = tmp___64;
#line 75
  e += ((((b ^ c) ^ d) + tmp___64) + 3395469782U) + ((a << 5) | (a >> 27));
#line 75
  b = (b << 30) | (b >> 2);
#line 75
  tmp___65 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 75
  block->l[2] = tmp___65;
#line 75
  d += ((((a ^ b) ^ c) + tmp___65) + 3395469782U) + ((e << 5) | (e >> 27));
#line 75
  a = (a << 30) | (a >> 2);
#line 75
  tmp___66 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 75
  block->l[3] = tmp___66;
#line 75
  c += ((((e ^ a) ^ b) + tmp___66) + 3395469782U) + ((d << 5) | (d >> 27));
#line 75
  e = (e << 30) | (e >> 2);
#line 76
  tmp___67 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 76
  block->l[4] = tmp___67;
#line 76
  b += ((((d ^ e) ^ a) + tmp___67) + 3395469782U) + ((c << 5) | (c >> 27));
#line 76
  d = (d << 30) | (d >> 2);
#line 76
  tmp___68 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 76
  block->l[5] = tmp___68;
#line 76
  a += ((((c ^ d) ^ e) + tmp___68) + 3395469782U) + ((b << 5) | (b >> 27));
#line 76
  c = (c << 30) | (c >> 2);
#line 76
  tmp___69 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 76
  block->l[6] = tmp___69;
#line 76
  e += ((((b ^ c) ^ d) + tmp___69) + 3395469782U) + ((a << 5) | (a >> 27));
#line 76
  b = (b << 30) | (b >> 2);
#line 76
  tmp___70 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 76
  block->l[7] = tmp___70;
#line 76
  d += ((((a ^ b) ^ c) + tmp___70) + 3395469782U) + ((e << 5) | (e >> 27));
#line 76
  a = (a << 30) | (a >> 2);
#line 77
  tmp___71 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 77
  block->l[8] = tmp___71;
#line 77
  c += ((((e ^ a) ^ b) + tmp___71) + 3395469782U) + ((d << 5) | (d >> 27));
#line 77
  e = (e << 30) | (e >> 2);
#line 77
  tmp___72 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 77
  block->l[9] = tmp___72;
#line 77
  b += ((((d ^ e) ^ a) + tmp___72) + 3395469782U) + ((c << 5) | (c >> 27));
#line 77
  d = (d << 30) | (d >> 2);
#line 77
  tmp___73 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 77
  block->l[10] = tmp___73;
#line 77
  a += ((((c ^ d) ^ e) + tmp___73) + 3395469782U) + ((b << 5) | (b >> 27));
#line 77
  c = (c << 30) | (c >> 2);
#line 77
  tmp___74 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 77
  block->l[11] = tmp___74;
#line 77
  e += ((((b ^ c) ^ d) + tmp___74) + 3395469782U) + ((a << 5) | (a >> 27));
#line 77
  b = (b << 30) | (b >> 2);
#line 78
  tmp___75 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 78
  block->l[12] = tmp___75;
#line 78
  d += ((((a ^ b) ^ c) + tmp___75) + 3395469782U) + ((e << 5) | (e >> 27));
#line 78
  a = (a << 30) | (a >> 2);
#line 78
  tmp___76 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 78
  block->l[13] = tmp___76;
#line 78
  c += ((((e ^ a) ^ b) + tmp___76) + 3395469782U) + ((d << 5) | (d >> 27));
#line 78
  e = (e << 30) | (e >> 2);
#line 78
  tmp___77 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 78
  block->l[14] = tmp___77;
#line 78
  b += ((((d ^ e) ^ a) + tmp___77) + 3395469782U) + ((c << 5) | (c >> 27));
#line 78
  d = (d << 30) | (d >> 2);
#line 78
  tmp___78 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 78
  block->l[15] = tmp___78;
#line 78
  a += ((((c ^ d) ^ e) + tmp___78) + 3395469782U) + ((b << 5) | (b >> 27));
#line 78
  c = (c << 30) | (c >> 2);
#line 80
  *(state + 0) += a;
#line 81
  *(state + 1) += b;
#line 82
  *(state + 2) += c;
#line 83
  *(state + 3) += d;
#line 84
  *(state + 4) += e;
#line 86
  e = (uint32_t )0;
#line 86
  d = e;
#line 86
  c = d;
#line 86
  b = c;
#line 86
  a = b;
  }
#line 87
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
void fr_SHA1Init(fr_SHA1_CTX *context ) 
{ 
  uint32_t tmp ;

  {
#line 95
  context->state[0] = (uint32_t )1732584193;
#line 96
  context->state[1] = 4023233417U;
#line 97
  context->state[2] = 2562383102U;
#line 98
  context->state[3] = (uint32_t )271733878;
#line 99
  context->state[4] = 3285377520U;
#line 100
  tmp = (uint32_t )0;
#line 100
  context->count[1] = tmp;
#line 100
  context->count[0] = tmp;
#line 101
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
void fr_SHA1Update(fr_SHA1_CTX *context , uint8_t const   *data , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;
  uint32_t tmp ;

  {
#line 110
  j = (context->count[0] >> 3) & 63U;
#line 111
  tmp = context->count[0] + (len << 3);
#line 111
  context->count[0] = tmp;
#line 111
  if (tmp < len << 3) {
#line 111
    (context->count[1]) ++;
  }
#line 112
  context->count[1] += len >> 29;
#line 113
  if (j + len > 63U) {
    {
#line 114
    i = 64U - j;
#line 114
    memcpy((void */* __restrict  */)(& context->buffer[j]), (void const   */* __restrict  */)data,
           (size_t )i);
#line 115
    fr_SHA1Transform((uint32_t *)(context->state), (uint8_t const   *)(context->buffer));
    }
    {
#line 116
    while (1) {
      while_continue: /* CIL Label */ ;
#line 116
      if (! (i + 63U < len)) {
#line 116
        goto while_break;
      }
      {
#line 117
      fr_SHA1Transform((uint32_t *)(context->state), (uint8_t const   *)(data + i));
#line 116
      i += 64U;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 119
    j = 0U;
  } else {
#line 121
    i = 0U;
  }
  {
#line 122
  memcpy((void */* __restrict  */)(& context->buffer[j]), (void const   */* __restrict  */)(data + i),
         (size_t )(len - i));
  }
#line 123
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
void fr_SHA1Final(uint8_t *digest , fr_SHA1_CTX *context ) 
{ 
  uint32_t i ;
  uint32_t j ;
  uint8_t finalcount[8] ;
  int tmp ;

  {
#line 133
  i = (uint32_t )0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i < 8U)) {
#line 133
      goto while_break;
    }
#line 134
    if (i >= 4U) {
#line 134
      tmp = 0;
    } else {
#line 134
      tmp = 1;
    }
#line 134
    finalcount[i] = (uint8_t )((context->count[tmp] >> (3U - (i & 3U)) * 8U) & 255U);
#line 133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  fr_SHA1Update(context, (unsigned char const   *)"\200", 1U);
  }
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    if (! ((context->count[0] & 504U) != 448U)) {
#line 138
      goto while_break___0;
    }
    {
#line 139
    fr_SHA1Update(context, (unsigned char const   *)"\000", 1U);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 141
  fr_SHA1Update(context, (uint8_t const   *)(finalcount), 8U);
#line 142
  i = (uint32_t )0;
  }
  {
#line 142
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 142
    if (! (i < 20U)) {
#line 142
      goto while_break___1;
    }
#line 143
    *(digest + i) = (uint8_t )((context->state[i >> 2] >> (3U - (i & 3U)) * 8U) & 255U);
#line 142
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 147
  j = (uint32_t )0;
#line 147
  i = j;
#line 148
  memset((void *)(context->buffer), 0, (size_t )64);
#line 149
  memset((void *)(context->state), 0, (size_t )20);
#line 150
  memset((void *)(context->count), 0, (size_t )8);
#line 151
  memset((void *)(& finalcount), 0, (size_t )8);
  }
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
void fr_SHA1FinalNoLen(uint8_t *digest , fr_SHA1_CTX *context ) 
{ 
  uint32_t i ;
  uint32_t j ;

  {
#line 161
  i = (uint32_t )0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < 20U)) {
#line 161
      goto while_break;
    }
#line 162
    *(digest + i) = (uint8_t )((context->state[i >> 2] >> (3U - (i & 3U)) * 8U) & 255U);
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  j = (uint32_t )0;
#line 167
  i = j;
#line 168
  memset((void *)(context->buffer), 0, (size_t )64);
#line 169
  memset((void *)(context->state), 0, (size_t )20);
#line 170
  memset((void *)(context->count), 0, (size_t )8);
  }
#line 175
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 240 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
int fr_utf8_char(uint8_t const   *str ) ;
#line 241
size_t fr_print_string(char const   *in , size_t inlen , char *out , size_t outlen ) ;
#line 246
int vp_prints(char *out , size_t outlen , VALUE_PAIR *vp ) ;
#line 247
void vp_print(FILE *fp , VALUE_PAIR *vp ) ;
#line 248
void vp_printlist(FILE *fp , VALUE_PAIR *vp ) ;
#line 261
DICT_VALUE *dict_valbyattr(unsigned int attr , int value ) ;
#line 420
void print_abinary(VALUE_PAIR *vp , char *buffer , size_t len ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
int fr_utf8_char(uint8_t const   *str ) 
{ 


  {
#line 40
  if ((int const   )*str < 32) {
#line 40
    return (0);
  }
#line 42
  if ((int const   )*str <= 126) {
#line 42
    return (1);
  }
#line 44
  if ((int const   )*str <= 193) {
#line 44
    return (0);
  }
#line 46
  if ((int const   )*(str + 0) >= 194) {
#line 46
    if ((int const   )*(str + 0) <= 223) {
#line 46
      if ((int const   )*(str + 1) >= 128) {
#line 46
        if ((int const   )*(str + 1) <= 191) {
#line 50
          return (2);
        }
      }
    }
  }
#line 53
  if ((int const   )*(str + 0) == 224) {
#line 53
    if ((int const   )*(str + 1) >= 160) {
#line 53
      if ((int const   )*(str + 1) <= 191) {
#line 53
        if ((int const   )*(str + 2) >= 128) {
#line 53
          if ((int const   )*(str + 2) <= 191) {
#line 58
            return (3);
          }
        }
      }
    }
  }
#line 61
  if ((int const   )*(str + 0) >= 225) {
#line 61
    if ((int const   )*(str + 0) <= 236) {
#line 61
      if ((int const   )*(str + 1) >= 128) {
#line 61
        if ((int const   )*(str + 1) <= 191) {
#line 61
          if ((int const   )*(str + 2) >= 128) {
#line 61
            if ((int const   )*(str + 2) <= 191) {
#line 67
              return (3);
            }
          }
        }
      }
    }
  }
#line 70
  if ((int const   )*(str + 0) >= 238) {
#line 70
    if ((int const   )*(str + 0) <= 239) {
#line 70
      if ((int const   )*(str + 1) >= 128) {
#line 70
        if ((int const   )*(str + 1) <= 191) {
#line 70
          if ((int const   )*(str + 2) >= 128) {
#line 70
            if ((int const   )*(str + 2) <= 191) {
#line 76
              return (3);
            }
          }
        }
      }
    }
  }
#line 79
  if ((int const   )*(str + 0) == 237) {
#line 79
    if ((int const   )*(str + 1) >= 128) {
#line 79
      if ((int const   )*(str + 1) <= 159) {
#line 79
        if ((int const   )*(str + 2) >= 128) {
#line 79
          if ((int const   )*(str + 2) <= 191) {
#line 84
            return (3);
          }
        }
      }
    }
  }
#line 87
  if ((int const   )*(str + 0) == 240) {
#line 87
    if ((int const   )*(str + 1) >= 144) {
#line 87
      if ((int const   )*(str + 1) <= 191) {
#line 87
        if ((int const   )*(str + 2) >= 128) {
#line 87
          if ((int const   )*(str + 2) <= 191) {
#line 87
            if ((int const   )*(str + 3) >= 128) {
#line 87
              if ((int const   )*(str + 3) <= 191) {
#line 94
                return (4);
              }
            }
          }
        }
      }
    }
  }
#line 97
  if ((int const   )*(str + 0) >= 241) {
#line 97
    if ((int const   )*(str + 1) <= 243) {
#line 97
      if ((int const   )*(str + 1) >= 128) {
#line 97
        if ((int const   )*(str + 1) <= 191) {
#line 97
          if ((int const   )*(str + 2) >= 128) {
#line 97
            if ((int const   )*(str + 2) <= 191) {
#line 97
              if ((int const   )*(str + 3) >= 128) {
#line 97
                if ((int const   )*(str + 3) <= 191) {
#line 105
                  return (4);
                }
              }
            }
          }
        }
      }
    }
  }
#line 109
  if ((int const   )*(str + 0) == 244) {
#line 109
    if ((int const   )*(str + 1) >= 128) {
#line 109
      if ((int const   )*(str + 1) <= 143) {
#line 109
        if ((int const   )*(str + 2) >= 128) {
#line 109
          if ((int const   )*(str + 2) <= 191) {
#line 109
            if ((int const   )*(str + 3) >= 128) {
#line 109
              if ((int const   )*(str + 3) <= 191) {
#line 116
                return (4);
              }
            }
          }
        }
      }
    }
  }
#line 122
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
size_t fr_print_string(char const   *in , size_t inlen , char *out , size_t outlen ) 
{ 
  char const   *start ;
  uint8_t const   *str ;
  int sp ;
  int utf8 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  uint8_t const   *tmp___2 ;

  {
#line 132
  start = (char const   *)out;
#line 133
  str = (uint8_t const   *)in;
#line 134
  sp = 0;
#line 135
  utf8 = 0;
#line 137
  if (inlen == 0UL) {
    {
#line 137
    inlen = strlen(in);
    }
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (inlen > 0UL) {
#line 142
      if (! (outlen > 4UL)) {
#line 142
        goto while_break;
      }
    } else {
#line 142
      goto while_break;
    }
#line 148
    if (inlen == 1UL) {
#line 148
      if ((int const   )*str == 0) {
#line 148
        goto while_break;
      }
    }
    {
#line 151
    if ((int const   )*str == 92) {
#line 151
      goto case_92;
    }
#line 154
    if ((int const   )*str == 13) {
#line 154
      goto case_13;
    }
#line 157
    if ((int const   )*str == 10) {
#line 157
      goto case_10;
    }
#line 160
    if ((int const   )*str == 9) {
#line 160
      goto case_9;
    }
#line 163
    if ((int const   )*str == 34) {
#line 163
      goto case_34;
    }
#line 166
    goto switch_default;
    case_92: /* CIL Label */ 
#line 152
    sp = '\\';
#line 153
    goto switch_break;
    case_13: /* CIL Label */ 
#line 155
    sp = 'r';
#line 156
    goto switch_break;
    case_10: /* CIL Label */ 
#line 158
    sp = 'n';
#line 159
    goto switch_break;
    case_9: /* CIL Label */ 
#line 161
    sp = 't';
#line 162
    goto switch_break;
    case_34: /* CIL Label */ 
#line 164
    sp = '\"';
#line 165
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 167
    sp = 0;
#line 168
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 171
    if (sp) {
#line 172
      tmp = out;
#line 172
      out ++;
#line 172
      *tmp = (char )'\\';
#line 173
      tmp___0 = out;
#line 173
      out ++;
#line 173
      *tmp___0 = (char )sp;
#line 174
      outlen -= 2UL;
#line 175
      str ++;
#line 176
      inlen --;
#line 177
      goto while_continue;
    }
    {
#line 180
    utf8 = fr_utf8_char(str);
    }
#line 181
    if (! utf8) {
      {
#line 182
      snprintf((char */* __restrict  */)out, outlen, (char const   */* __restrict  */)"\\%03o",
               (int const   )*str);
#line 183
      out += 4;
#line 184
      outlen -= 4UL;
#line 185
      str ++;
#line 186
      inlen --;
      }
#line 187
      goto while_continue;
    }
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 191
      tmp___1 = out;
#line 191
      out ++;
#line 191
      tmp___2 = str;
#line 191
      str ++;
#line 191
      *tmp___1 = (char )*tmp___2;
#line 192
      outlen --;
#line 193
      inlen --;
#line 190
      utf8 --;
#line 190
      if (! (utf8 > 0)) {
#line 190
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  *out = (char)0;
#line 198
  return ((size_t )(out - (char *)start));
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
int vp_prints_value(char *out , size_t outlen , VALUE_PAIR *vp , int delimitst ) 
{ 
  DICT_VALUE *v ;
  char buf[1024] ;
  char const   *a ;
  size_t len ;
  time_t t ;
  struct tm s_tm ;
  size_t tmp ;
  struct tm *tmp___0 ;
  struct tm *tmp___1 ;
  char *tmp___2 ;
  struct in6_addr addr ;
  char *p ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 210
  a = (char const   *)((void *)0);
#line 215
  *(out + 0) = (char )'\000';
#line 216
  if (! vp) {
#line 216
    return (0);
  }
  {
#line 219
  if (vp->type == 0) {
#line 219
    goto case_0;
  }
#line 244
  if (vp->type == 1) {
#line 244
    goto case_1;
  }
#line 256
  if (vp->type == 10) {
#line 256
    goto case_10;
  }
#line 256
  if (vp->type == 9) {
#line 256
    goto case_10;
  }
#line 267
  if (vp->type == 3) {
#line 267
    goto case_3;
  }
#line 278
  if (vp->type == 12) {
#line 278
    goto case_12;
  }
#line 282
  if (vp->type == 2) {
#line 282
    goto case_2;
  }
#line 286
  if (vp->type == 4) {
#line 286
    goto case_4;
  }
#line 294
  if (vp->type == 5) {
#line 294
    goto case_5;
  }
#line 303
  if (vp->type == 6) {
#line 303
    goto case_6;
  }
#line 307
  if (vp->type == 7) {
#line 307
    goto case_7;
  }
#line 313
  if (vp->type == 8) {
#line 313
    goto case_8;
  }
#line 331
  if (vp->type == 11) {
#line 331
    goto case_11;
  }
#line 339
  if (vp->type == 14) {
#line 339
    goto case_14;
  }
#line 348
  goto switch_default;
  case_0: /* CIL Label */ 
#line 220
  if (delimitst == 1) {
#line 220
    if (vp->flags.has_tag) {
      {
#line 222
      buf[0] = (char )'\"';
#line 223
      fr_print_string((char const   *)(vp->data.strvalue), vp->length, buf + 1, sizeof(buf) - 2UL);
#line 225
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\"");
      }
    } else {
#line 220
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 226
  if (delimitst == 1) {
    {
#line 228
    buf[0] = (char )'\"';
#line 229
    fr_print_string((char const   *)(vp->data.strvalue), vp->length, buf + 1, sizeof(buf) - 2UL);
#line 231
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\"");
    }
  } else
#line 233
  if (delimitst < 0) {
    {
#line 234
    strlcpy(out, (char const   *)(vp->data.strvalue), outlen);
#line 235
    tmp = strlen((char const   *)out);
    }
#line 235
    return ((int )tmp);
  } else {
    {
#line 239
    fr_print_string((char const   *)(vp->data.strvalue), vp->length, buf, sizeof(buf));
    }
  }
#line 242
  a = (char const   *)(buf);
#line 243
  goto switch_break;
  case_1: /* CIL Label */ 
#line 245
  if (vp->flags.has_tag) {
    {
#line 247
    v = dict_valbyattr((unsigned int )vp->attribute, (int )(vp->lvalue & 16777215U));
    }
#line 247
    if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 249
      a = (char const   *)(v->name);
    } else {
      {
#line 251
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%u",
               vp->lvalue & 16777215U);
#line 252
      a = (char const   *)(buf);
      }
    }
  } else {
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 258
    v = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
    }
#line 258
    if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 260
      a = (char const   *)(v->name);
    } else {
      {
#line 262
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%u",
               vp->lvalue);
#line 263
      a = (char const   *)(buf);
      }
    }
  }
#line 266
  goto switch_break;
  case_3: /* CIL Label */ 
#line 268
  t = (time_t )vp->lvalue;
#line 269
  if (delimitst == 1) {
    {
#line 270
    tmp___0 = localtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)(& s_tm));
#line 270
    len = strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"\"%b %e %Y %H:%M:%S %Z\"",
                   (struct tm  const  */* __restrict  */)tmp___0);
    }
  } else {
    {
#line 273
    tmp___1 = localtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)(& s_tm));
#line 273
    len = strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%b %e %Y %H:%M:%S %Z",
                   (struct tm  const  */* __restrict  */)tmp___1);
    }
  }
#line 276
  if (len > 0UL) {
#line 276
    a = (char const   *)(buf);
  }
#line 277
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 279
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d",
           vp->data.sinteger);
#line 280
  a = (char const   *)(buf);
  }
#line 281
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 283
  a = inet_ntop(2, (void const   */* __restrict  */)(& vp->lvalue), (char */* __restrict  */)(buf),
                (socklen_t )sizeof(buf));
  }
#line 285
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 288
  a = (char const   *)(buf);
#line 289
  print_abinary(vp, buf, sizeof(buf));
  }
#line 290
  goto switch_break;
  case_5: /* CIL Label */ 
#line 295
  if (outlen <= 2UL * (vp->length + 1UL)) {
#line 295
    return (0);
  }
  {
#line 297
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"0x");
#line 299
  fr_bin2hex((uint8_t const   *)(vp->data.octets), buf + 2, vp->length);
#line 300
  a = (char const   *)(buf);
  }
#line 301
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 304
  tmp___2 = ifid_ntoa(buf, sizeof(buf), vp->data.octets);
#line 304
  a = (char const   *)tmp___2;
  }
#line 305
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 308
  a = inet_ntop(10, (void const   */* __restrict  */)((struct in6_addr  const  *)(vp->data.strvalue)),
                (char */* __restrict  */)(buf), (socklen_t )sizeof(buf));
  }
#line 311
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 320
  memcpy((void */* __restrict  */)(& addr), (void const   */* __restrict  */)(vp->data.strvalue + 2),
         sizeof(addr));
#line 322
  a = inet_ntop(10, (void const   */* __restrict  */)(& addr), (char */* __restrict  */)(buf),
                (socklen_t )sizeof(buf));
  }
#line 323
  if (a) {
    {
#line 324
    tmp___3 = strlen((char const   *)(buf));
#line 324
    p = buf + tmp___3;
#line 325
    snprintf((char */* __restrict  */)p, (size_t )(((buf + sizeof(buf)) - p) - 1L),
             (char const   */* __restrict  */)"/%u", (unsigned int )vp->data.octets[1]);
    }
  }
#line 329
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 332
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%02x:%02x:%02x:%02x:%02x:%02x",
           (int )vp->data.ether[0], (int )vp->data.ether[1], (int )vp->data.ether[2],
           (int )vp->data.ether[3], (int )vp->data.ether[4], (int )vp->data.ether[5]);
#line 336
  a = (char const   *)(buf);
  }
#line 337
  goto switch_break;
  case_14: /* CIL Label */ 
#line 340
  if (outlen <= 2UL * (vp->length + 1UL)) {
#line 340
    return (0);
  }
  {
#line 342
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"0x");
#line 344
  fr_bin2hex((uint8_t const   *)vp->data.tlv, buf + 2, vp->length);
#line 345
  a = (char const   *)(buf);
  }
#line 346
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 349
  a = "UNKNOWN-TYPE";
#line 350
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 353
  if ((unsigned long )a != (unsigned long )((void *)0)) {
    {
#line 353
    strlcpy(out, a, outlen);
    }
  }
  {
#line 355
  tmp___4 = strlen((char const   *)out);
  }
#line 355
  return ((int )tmp___4);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens[27]  = 
#line 361
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 391 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
char const   *vp_print_name(char *buffer , size_t bufsize , int attr ) 
{ 
  int vendor ;
  size_t len ;
  DICT_VENDOR *v ;
  size_t tmp ;

  {
#line 394
  len = (size_t )0;
#line 396
  if (! buffer) {
#line 396
    return ((char const   *)((void *)0));
  }
#line 398
  vendor = (attr >> 16) & 65535;
#line 399
  if (vendor) {
    {
#line 402
    v = dict_vendorbyvalue(vendor);
    }
#line 403
    if (v) {
      {
#line 404
      snprintf((char */* __restrict  */)buffer, bufsize, (char const   */* __restrict  */)"%s-",
               v->name);
      }
    } else {
      {
#line 406
      snprintf((char */* __restrict  */)buffer, bufsize, (char const   */* __restrict  */)"Vendor-%u-",
               vendor);
      }
    }
    {
#line 409
    len = strlen((char const   *)buffer);
    }
#line 410
    if (len == bufsize) {
#line 411
      return ((char const   *)((void *)0));
    }
  }
  {
#line 415
  snprintf((char */* __restrict  */)(buffer + len), bufsize - len, (char const   */* __restrict  */)"Attr-%u",
           attr & 65535);
#line 416
  tmp = strlen((char const   *)(buffer + len));
#line 416
  len += tmp;
  }
#line 417
  if (len == bufsize) {
#line 418
    return ((char const   *)((void *)0));
  }
#line 421
  return ((char const   *)buffer);
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
int vp_prints(char *out , size_t outlen , VALUE_PAIR *vp ) 
{ 
  size_t len ;
  char const   *token ;
  char const   *name ;
  char namebuf[128] ;
  char const   *tmp ;
  size_t tmp___0 ;

  {
#line 431
  token = (char const   *)((void *)0);
#line 435
  *(out + 0) = (char)0;
#line 436
  if (! vp) {
#line 436
    return (0);
  }
#line 438
  name = vp->name;
#line 439
  len = (size_t )0;
#line 441
  if (! name) {
#line 441
    goto _L;
  } else
#line 441
  if (! *name) {
    _L: /* CIL Label */ 
    {
#line 442
    tmp = vp_print_name(namebuf, sizeof(namebuf), vp->attribute);
    }
#line 442
    if (! tmp) {
#line 443
      return (0);
    }
#line 445
    name = (char const   *)(namebuf);
  }
#line 448
  if ((unsigned int )vp->operator > 0U) {
#line 448
    if ((unsigned int )vp->operator < 27U) {
#line 450
      token = vp_tokens[vp->operator];
    } else {
#line 452
      token = "<INVALID-TOKEN>";
    }
  } else {
#line 452
    token = "<INVALID-TOKEN>";
  }
#line 455
  if (vp->flags.has_tag) {
    {
#line 456
    snprintf((char */* __restrict  */)out, outlen, (char const   */* __restrict  */)"%s:%d %s ",
             name, (int )vp->flags.tag, token);
#line 459
    len = strlen((char const   *)out);
#line 460
    vp_prints_value(out + len, outlen - len, vp, 1);
    }
  } else {
    {
#line 463
    snprintf((char */* __restrict  */)out, outlen, (char const   */* __restrict  */)"%s %s ",
             name, token);
#line 464
    len = strlen((char const   *)out);
#line 465
    vp_prints_value(out + len, outlen - len, vp, 1);
    }
  }
  {
#line 469
  tmp___0 = strlen((char const   *)(out + len));
  }
#line 469
  return ((int )(len + tmp___0));
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
void vp_print(FILE *fp , VALUE_PAIR *vp ) 
{ 
  char buf[1024] ;

  {
  {
#line 480
  vp_prints(buf, sizeof(buf), vp);
#line 481
  fputc('\t', fp);
#line 482
  fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)fp);
#line 483
  fputc('\n', fp);
  }
#line 484
  return;
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
void vp_printlist(FILE *fp , VALUE_PAIR *vp ) 
{ 


  {
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! vp) {
#line 493
      goto while_break;
    }
    {
#line 494
    vp_print(fp, vp);
#line 493
    vp = vp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38
uint32_t fr_hash(void const   *data , size_t size ) ;
#line 39
uint32_t fr_hash_update(void const   *data , size_t size , uint32_t hash ) ;
#line 40
uint32_t fr_hash_string(char const   *p ) ;
#line 47
uint32_t fr_hash_fold(uint32_t hash , int bits ) ;
#line 55
fr_hash_table_t *fr_hash_table_create(uint32_t (*hashNode)(void const   * ) , int (*cmpNode)(void const   * ,
                                                                                             void const   * ) ,
                                      void (*freeNode)(void * ) ) ;
#line 58
void fr_hash_table_free(fr_hash_table_t *ht ) ;
#line 59
int fr_hash_table_insert(fr_hash_table_t *ht , void *data ) ;
#line 60
int fr_hash_table_delete(fr_hash_table_t *ht , void const   *data ) ;
#line 61
void *fr_hash_table_yank(fr_hash_table_t *ht , void const   *data ) ;
#line 62
int fr_hash_table_replace(fr_hash_table_t *ht , void *data ) ;
#line 63
void *fr_hash_table_finddata(fr_hash_table_t *ht , void const   *data ) ;
#line 64
int fr_hash_table_num_elements(fr_hash_table_t *ht ) ;
#line 65
int fr_hash_table_walk(fr_hash_table_t *ht , int (*callback)(void * , void * ) , void *context ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte[key & 255U] << 24) | ((int const   )reversed_byte[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find(fr_hash_table_t *ht , fr_hash_entry_t *head , uint32_t reversed ,
                                  void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
fr_hash_table_t *fr_hash_table_create(uint32_t (*hashNode)(void const   * ) , int (*cmpNode)(void const   * ,
                                                                                             void const   * ) ,
                                      void (*freeNode)(void * ) ) 
{ 
  fr_hash_table_t *ht ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 266
  if (! hashNode) {
#line 266
    return ((fr_hash_table_t *)((void *)0));
  }
  {
#line 268
  tmp = malloc(sizeof(*ht));
#line 268
  ht = (fr_hash_table_t *)tmp;
  }
#line 269
  if (! ht) {
#line 269
    return ((fr_hash_table_t *)((void *)0));
  }
  {
#line 271
  memset((void *)ht, 0, sizeof(*ht));
#line 272
  ht->free = freeNode;
#line 273
  ht->hash = hashNode;
#line 274
  ht->cmp = cmpNode;
#line 275
  ht->num_buckets = 64;
#line 276
  ht->mask = ht->num_buckets - 1;
#line 283
  ht->next_grow = (ht->num_buckets << 1) + (ht->num_buckets >> 1);
#line 285
  tmp___0 = malloc(sizeof(*(ht->buckets)) * (unsigned long )ht->num_buckets);
#line 285
  ht->buckets = (fr_hash_entry_t **)tmp___0;
  }
#line 286
  if (! ht->buckets) {
    {
#line 287
    free((void *)ht);
    }
#line 288
    return ((fr_hash_table_t *)((void *)0));
  }
  {
#line 290
  memset((void *)ht->buckets, 0, sizeof(*(ht->buckets)) * (unsigned long )ht->num_buckets);
#line 292
  ht->null.reversed = (uint32_t )(~ 0);
#line 293
  ht->null.key = (uint32_t )(~ 0);
#line 294
  ht->null.next = & ht->null;
#line 296
  *(ht->buckets + 0) = & ht->null;
  }
#line 298
  return (ht);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
int fr_hash_table_insert(fr_hash_table_t *ht , void *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *node ;
  void *tmp ;
  int tmp___0 ;

  {
#line 396
  if (! ht) {
#line 396
    return (0);
  } else
#line 396
  if (! data) {
#line 396
    return (0);
  }
  {
#line 398
  key = (*(ht->hash))((void const   *)data);
#line 399
  entry = key & (unsigned int )ht->mask;
#line 400
  reversed = reverse(key);
  }
#line 402
  if (! *(ht->buckets + entry)) {
    {
#line 402
    fr_hash_table_fixup(ht, entry);
    }
  }
  {
#line 408
  tmp = malloc(sizeof(*node));
#line 408
  node = (fr_hash_entry_t *)tmp;
  }
#line 409
  if (! node) {
#line 409
    return (0);
  }
  {
#line 410
  memset((void *)node, 0, sizeof(*node));
#line 412
  node->next = & ht->null;
#line 413
  node->reversed = reversed;
#line 414
  node->key = key;
#line 415
  node->data = data;
#line 418
  tmp___0 = list_insert(ht, ht->buckets + entry, node);
  }
#line 418
  if (! tmp___0) {
    {
#line 419
    free((void *)node);
    }
#line 420
    return (0);
  }
#line 427
  (ht->num_elements) ++;
#line 428
  if (ht->num_elements >= ht->next_grow) {
    {
#line 429
    fr_hash_table_grow(ht);
    }
  }
#line 432
  return (1);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
int fr_hash_table_replace(fr_hash_table_t *ht , void *data ) 
{ 
  fr_hash_entry_t *node ;
  int tmp ;

  {
#line 465
  if (! ht) {
#line 465
    return (0);
  } else
#line 465
  if (! data) {
#line 465
    return (0);
  }
  {
#line 467
  node = fr_hash_table_find(ht, (void const   *)data);
  }
#line 468
  if (! node) {
    {
#line 468
    tmp = fr_hash_table_insert(ht, data);
    }
#line 468
    return (tmp);
  }
#line 470
  if (ht->free) {
    {
#line 470
    (*(ht->free))(node->data);
    }
  }
#line 471
  node->data = data;
#line 473
  return (1);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
void *fr_hash_table_finddata(fr_hash_table_t *ht , void const   *data ) 
{ 
  fr_hash_entry_t *node ;

  {
  {
#line 484
  node = fr_hash_table_find(ht, data);
  }
#line 485
  if (! node) {
#line 485
    return ((void *)0);
  }
#line 487
  return (node->data);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
void *fr_hash_table_yank(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  void *old ;
  fr_hash_entry_t *node ;

  {
#line 503
  if (! ht) {
#line 503
    return ((void *)0);
  }
  {
#line 505
  key = (*(ht->hash))(data);
#line 506
  entry = key & (unsigned int )ht->mask;
#line 507
  reversed = reverse(key);
  }
#line 509
  if (! *(ht->buckets + entry)) {
    {
#line 509
    fr_hash_table_fixup(ht, entry);
    }
  }
  {
#line 511
  node = list_find(ht, *(ht->buckets + entry), reversed, data);
  }
#line 512
  if (! node) {
#line 512
    return ((void *)0);
  }
  {
#line 514
  list_delete(ht, ht->buckets + entry, node);
#line 515
  (ht->num_elements) --;
#line 517
  old = node->data;
#line 518
  free((void *)node);
  }
#line 520
  return (old);
}
}
#line 527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
int fr_hash_table_delete(fr_hash_table_t *ht , void const   *data ) 
{ 
  void *old ;

  {
  {
#line 531
  old = fr_hash_table_yank(ht, data);
  }
#line 532
  if (! old) {
#line 532
    return (0);
  }
#line 534
  if (ht->free) {
    {
#line 534
    (*(ht->free))(old);
    }
  }
#line 536
  return (1);
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
void fr_hash_table_free(fr_hash_table_t *ht ) 
{ 
  int i ;
  fr_hash_entry_t *node ;
  fr_hash_entry_t *next ;

  {
#line 548
  if (! ht) {
#line 548
    return;
  }
#line 553
  i = 0;
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if (! (i < ht->num_buckets)) {
#line 553
      goto while_break;
    }
#line 554
    if (*(ht->buckets + i)) {
#line 554
      node = *(ht->buckets + i);
      {
#line 554
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 554
        if (! ((unsigned long )node != (unsigned long )(& ht->null))) {
#line 554
          goto while_break___0;
        }
#line 557
        next = node->next;
#line 559
        if (! node->data) {
#line 559
          goto __Cont;
        }
#line 561
        if (ht->free) {
          {
#line 561
          (*(ht->free))(node->data);
          }
        }
        {
#line 562
        free((void *)node);
        }
        __Cont: /* CIL Label */ 
#line 554
        node = next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 553
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 566
  free((void *)ht->buckets);
#line 567
  free((void *)ht);
  }
#line 568
  return;
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
int fr_hash_table_num_elements(fr_hash_table_t *ht ) 
{ 


  {
#line 576
  if (! ht) {
#line 576
    return (0);
  }
#line 578
  return (ht->num_elements);
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
int fr_hash_table_walk(fr_hash_table_t *ht , int (*callback)(void * , void * ) , void *context ) 
{ 
  int i ;
  int rcode ;
  fr_hash_entry_t *node ;
  fr_hash_entry_t *next ;

  {
#line 591
  if (! ht) {
#line 591
    return (0);
  } else
#line 591
  if (! callback) {
#line 591
    return (0);
  }
#line 593
  i = ht->num_buckets - 1;
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! (i >= 0)) {
#line 593
      goto while_break;
    }
#line 599
    if (! *(ht->buckets + i)) {
      {
#line 599
      fr_hash_table_fixup(ht, (uint32_t )i);
      }
    }
#line 601
    node = *(ht->buckets + i);
    {
#line 601
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 601
      if (! ((unsigned long )node != (unsigned long )(& ht->null))) {
#line 601
        goto while_break___0;
      }
      {
#line 602
      next = node->next;
#line 604
      rcode = (*callback)(context, node->data);
      }
#line 605
      if (rcode != 0) {
#line 605
        return (rcode);
      }
#line 601
      node = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 593
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 609
  return (0);
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
uint32_t fr_hash(void const   *data , size_t size ) 
{ 
  uint8_t const   *p ;
  uint8_t const   *q ;
  uint32_t hash ;
  uint8_t const   *tmp ;

  {
#line 701
  p = (uint8_t const   *)data;
#line 702
  q = p + size;
#line 703
  hash = 2166136261U;
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! ((unsigned long )p != (unsigned long )q)) {
#line 708
      goto while_break;
    }
#line 712
    hash *= 16777619U;
#line 723
    tmp = p;
#line 723
    p ++;
#line 723
    hash ^= (uint32_t )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  return (hash);
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
uint32_t fr_hash_update(void const   *data , size_t size , uint32_t hash ) 
{ 
  uint8_t const   *p ;
  uint8_t const   *q ;
  uint8_t const   *tmp ;

  {
#line 734
  p = (uint8_t const   *)data;
#line 735
  q = p + size;
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    if (! ((unsigned long )p != (unsigned long )q)) {
#line 737
      goto while_break;
    }
#line 738
    hash *= 16777619U;
#line 739
    tmp = p;
#line 739
    p ++;
#line 739
    hash ^= (uint32_t )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  return (hash);
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
uint32_t fr_hash_fold(uint32_t hash , int bits ) 
{ 
  int count ;
  uint32_t result ;

  {
#line 757
  if (bits <= 0) {
#line 757
    return (hash);
  } else
#line 757
  if (bits >= 32) {
#line 757
    return (hash);
  }
#line 759
  result = hash;
#line 764
  count = 0;
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    if (! (count < 32)) {
#line 764
      goto while_break;
    }
#line 765
    hash >>= bits;
#line 766
    result ^= hash;
#line 764
    count += bits;
  }
  while_break: /* CIL Label */ ;
  }
#line 769
  return (result & ((uint32_t )(1 << bits) - 1U));
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
uint32_t fr_hash_string(char const   *p ) 
{ 
  uint32_t hash ;
  char const   *tmp ;

  {
#line 778
  hash = 2166136261U;
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 780
    if (! *p) {
#line 780
      goto while_break;
    }
#line 781
    hash *= 16777619U;
#line 782
    tmp = p;
#line 782
    p ++;
#line 782
    hash ^= (uint32_t )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  return (hash);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
void rad_free(RADIUS_PACKET **radius_packet_ptr ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 34
RADIUS_PACKET *vqp_recv(int sockfd ) ;
#line 35
int vqp_send(RADIUS_PACKET *packet ) ;
#line 36
int vqp_decode(RADIUS_PACKET *packet ) ;
#line 37
int vqp_encode(RADIUS_PACKET *packet , RADIUS_PACKET *original ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto(int sockfd , void *data , size_t data_len , int flags , fr_ipaddr_t *src_ipaddr ,
                      fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                            uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
RADIUS_PACKET *vqp_recv(int sockfd ) 
{ 
  uint8_t *ptr ;
  ssize_t length ;
  uint32_t id ;
  RADIUS_PACKET *packet ;
  void *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int attrlen ;
  uint32_t tmp___3 ;

  {
  {
#line 283
  tmp = malloc(sizeof(*packet));
#line 283
  packet = (RADIUS_PACKET *)tmp;
  }
#line 283
  if ((unsigned long )packet == (unsigned long )((void *)0)) {
    {
#line 284
    fr_strerror_printf("out of memory");
    }
#line 285
    return ((RADIUS_PACKET *)((void *)0));
  }
  {
#line 287
  memset((void *)packet, 0, sizeof(*packet));
#line 289
  tmp___0 = vqp_recvfrom(sockfd, & packet->data, 0, & packet->src_ipaddr, & packet->src_port,
                         & packet->dst_ipaddr, & packet->dst_port);
#line 289
  packet->data_len = (int )tmp___0;
  }
#line 296
  if (packet->data_len < 0) {
    {
#line 297
    tmp___1 = __errno_location();
#line 297
    tmp___2 = strerror(*tmp___1);
#line 297
    fr_strerror_printf("Error receiving packet: %s", tmp___2);
#line 299
    free((void *)packet);
    }
#line 300
    return ((RADIUS_PACKET *)((void *)0));
  }
#line 309
  if (packet->data_len < 8) {
    {
#line 310
    fr_strerror_printf("VQP packet is too short");
#line 311
    rad_free(& packet);
    }
#line 312
    return ((RADIUS_PACKET *)((void *)0));
  }
#line 315
  ptr = packet->data;
#line 327
  if ((int )*(ptr + 3) > 12) {
    {
#line 328
    fr_strerror_printf("Too many VQP attributes");
#line 329
    rad_free(& packet);
    }
#line 330
    return ((RADIUS_PACKET *)((void *)0));
  }
#line 333
  if (packet->data_len > 8) {
#line 339
    ptr += 8;
#line 340
    length = (ssize_t )(packet->data_len - 8);
    {
#line 342
    while (1) {
      while_continue: /* CIL Label */ ;
#line 342
      if (! (length > 0L)) {
#line 342
        goto while_break;
      }
#line 343
      if (length < 7L) {
        {
#line 344
        fr_strerror_printf("Packet contains malformed attribute");
#line 345
        rad_free(& packet);
        }
#line 346
        return ((RADIUS_PACKET *)((void *)0));
      }
#line 353
      if ((int )*(ptr + 0) != 0) {
        {
#line 355
        fr_strerror_printf("Packet contains invalid attribute");
#line 356
        rad_free(& packet);
        }
#line 357
        return ((RADIUS_PACKET *)((void *)0));
      } else
#line 353
      if ((int )*(ptr + 1) != 0) {
        {
#line 355
        fr_strerror_printf("Packet contains invalid attribute");
#line 356
        rad_free(& packet);
        }
#line 357
        return ((RADIUS_PACKET *)((void *)0));
      } else
#line 353
      if ((int )*(ptr + 2) != 12) {
        {
#line 355
        fr_strerror_printf("Packet contains invalid attribute");
#line 356
        rad_free(& packet);
        }
#line 357
        return ((RADIUS_PACKET *)((void *)0));
      } else
#line 353
      if ((int )*(ptr + 3) < 1) {
        {
#line 355
        fr_strerror_printf("Packet contains invalid attribute");
#line 356
        rad_free(& packet);
        }
#line 357
        return ((RADIUS_PACKET *)((void *)0));
      } else
#line 353
      if ((int )*(ptr + 3) > 8) {
        {
#line 355
        fr_strerror_printf("Packet contains invalid attribute");
#line 356
        rad_free(& packet);
        }
#line 357
        return ((RADIUS_PACKET *)((void *)0));
      }
#line 371
      if ((int )*(ptr + 3) != 5) {
#line 371
        if ((int )*(ptr + 4) != 0) {
          {
#line 373
          fr_strerror_printf("Packet contains attribute with invalid length %02x %02x",
                             (int )*(ptr + 4), (int )*(ptr + 5));
#line 374
          rad_free(& packet);
          }
#line 375
          return ((RADIUS_PACKET *)((void *)0));
        } else
#line 371
        if ((int )*(ptr + 5) > 253) {
          {
#line 373
          fr_strerror_printf("Packet contains attribute with invalid length %02x %02x",
                             (int )*(ptr + 4), (int )*(ptr + 5));
#line 374
          rad_free(& packet);
          }
#line 375
          return ((RADIUS_PACKET *)((void *)0));
        }
      }
#line 377
      attrlen = ((int )*(ptr + 4) << 8) | (int )*(ptr + 5);
#line 378
      ptr += 6 + attrlen;
#line 379
      length -= (ssize_t )(6 + attrlen);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 383
  packet->sockfd = sockfd;
#line 384
  packet->vps = (VALUE_PAIR *)((void *)0);
#line 389
  packet->code = 1U;
#line 391
  memcpy((void */* __restrict  */)(& id), (void const   */* __restrict  */)(packet->data + 4),
         (size_t )4);
#line 392
  tmp___3 = ntohl(id);
#line 392
  packet->id = (int )tmp___3;
  }
#line 400
  return (packet);
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
int vqp_send(RADIUS_PACKET *packet ) 
{ 
  int tmp ;

  {
#line 410
  if (! packet) {
#line 410
    return (-1);
  } else
#line 410
  if (! packet->data) {
#line 410
    return (-1);
  } else
#line 410
  if (packet->data_len < 8) {
#line 410
    return (-1);
  }
  {
#line 420
  tmp = vqp_sendto(packet->sockfd, (void *)packet->data, (size_t )packet->data_len,
                   0, & packet->src_ipaddr, & packet->dst_ipaddr, (int )packet->dst_port);
  }
#line 420
  return (tmp);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
int vqp_decode(RADIUS_PACKET *packet ) 
{ 
  uint8_t *ptr ;
  uint8_t *end ;
  int attribute ;
  int length ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
#line 432
  if (! packet) {
#line 432
    return (-1);
  } else
#line 432
  if (! packet->data) {
#line 432
    return (-1);
  }
#line 434
  if (packet->data_len < 8) {
#line 434
    return (-1);
  }
  {
#line 436
  tail = & packet->vps;
#line 438
  vp = paircreate(11008, 5);
  }
#line 439
  if (! vp) {
    {
#line 440
    fr_strerror_printf("No memory");
    }
#line 441
    return (-1);
  }
#line 443
  vp->lvalue = (uint32_t )*(packet->data + 1);
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if (fr_debug_flag) {
#line 444
      if (fr_log_fp) {
        {
#line 444
        vp_print(fr_log_fp, vp);
        }
      }
    }
#line 444
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 446
  *tail = vp;
#line 447
  tail = & vp->next;
#line 449
  vp = paircreate(11009, 5);
  }
#line 450
  if (! vp) {
    {
#line 451
    fr_strerror_printf("No memory");
    }
#line 452
    return (-1);
  }
#line 454
  vp->lvalue = (uint32_t )*(packet->data + 2);
  {
#line 455
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 455
    if (fr_debug_flag) {
#line 455
      if (fr_log_fp) {
        {
#line 455
        vp_print(fr_log_fp, vp);
        }
      }
    }
#line 455
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 457
  *tail = vp;
#line 458
  tail = & vp->next;
#line 460
  vp = paircreate(11010, 5);
  }
#line 461
  if (! vp) {
    {
#line 462
    fr_strerror_printf("No memory");
    }
#line 463
    return (-1);
  }
#line 465
  vp->lvalue = (uint32_t )packet->id;
  {
#line 466
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 466
    if (fr_debug_flag) {
#line 466
      if (fr_log_fp) {
        {
#line 466
        vp_print(fr_log_fp, vp);
        }
      }
    }
#line 466
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 468
  *tail = vp;
#line 469
  tail = & vp->next;
#line 471
  ptr = packet->data + 8;
#line 472
  end = packet->data + packet->data_len;
  {
#line 479
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 479
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 479
      goto while_break___2;
    }
    {
#line 480
    attribute = ((int )*(ptr + 2) << 8) | (int )*(ptr + 3);
#line 481
    length = ((int )*(ptr + 4) << 8) | (int )*(ptr + 5);
#line 482
    ptr += 6;
#line 487
    attribute |= 8192;
#line 488
    vp = paircreate(attribute, 5);
    }
#line 489
    if (! vp) {
      {
#line 490
      pairfree(& packet->vps);
#line 492
      fr_strerror_printf("No memory");
      }
#line 493
      return (-1);
    }
    {
#line 497
    if (vp->type == 2) {
#line 497
      goto case_2;
    }
#line 506
    goto switch_default;
    case_2: /* CIL Label */ 
#line 498
    if (length == 4) {
      {
#line 499
      memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)ptr,
             (size_t )4);
#line 500
      vp->length = (size_t )4;
      }
#line 501
      goto switch_break;
    }
#line 503
    vp->type = 5;
    switch_default: /* CIL Label */ 
#line 509
    if (length > 253) {
#line 509
      vp->length = (size_t )253;
    } else {
#line 509
      vp->length = (size_t )length;
    }
    {
#line 510
    memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)ptr,
           vp->length);
#line 511
    vp->data.octets[vp->length] = (uint8_t )'\000';
    }
#line 512
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 514
    ptr += length;
    {
#line 515
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 515
      if (fr_debug_flag) {
#line 515
        if (fr_log_fp) {
          {
#line 515
          vp_print(fr_log_fp, vp);
          }
        }
      }
#line 515
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 517
    *tail = vp;
#line 518
    tail = & vp->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 525
  return (0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 545 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
int vqp_encode(RADIUS_PACKET *packet , RADIUS_PACKET *original ) 
{ 
  int i ;
  int code ;
  int length ;
  VALUE_PAIR *vp ;
  uint8_t *ptr ;
  VALUE_PAIR *vps[12] ;
  void *tmp ;
  uint32_t sequence ;

  {
#line 552
  if (! packet) {
    {
#line 553
    fr_strerror_printf("Failed encoding VQP");
    }
#line 554
    return (-1);
  }
#line 557
  if (packet->data) {
#line 557
    return (0);
  }
  {
#line 559
  vp = pairfind(packet->vps, 11008);
  }
#line 560
  if (! vp) {
    {
#line 561
    fr_strerror_printf("Failed to find VQP-Packet-Type in response packet");
    }
#line 562
    return (-1);
  }
#line 565
  code = (int )vp->lvalue;
#line 566
  if (code < 1) {
    {
#line 567
    fr_strerror_printf("Invalid value %d for VQP-Packet-Type", code);
    }
#line 568
    return (-1);
  } else
#line 566
  if (code > 4) {
    {
#line 567
    fr_strerror_printf("Invalid value %d for VQP-Packet-Type", code);
    }
#line 568
    return (-1);
  }
  {
#line 571
  length = 8;
#line 572
  memset((void *)(vps), 0, sizeof(vps));
#line 574
  vp = pairfind(packet->vps, 11009);
  }
#line 586
  if (! vp) {
#line 586
    i = 0;
    {
#line 586
    while (1) {
      while_continue: /* CIL Label */ ;
#line 586
      if (! (i < 12)) {
#line 586
        goto while_break;
      }
#line 587
      if (! contents[code][i]) {
#line 587
        goto while_break;
      }
      {
#line 589
      vps[i] = pairfind(packet->vps, contents[code][i] | 8192);
      }
#line 594
      if (! vps[i]) {
        {
#line 595
        fr_strerror_printf("Failed to find VQP attribute %02x", contents[code][i]);
        }
#line 597
        return (-1);
      }
#line 600
      length += 6;
#line 601
      length = (int )((size_t )length + (vps[i])->length);
#line 586
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 604
  tmp = malloc((size_t )length);
#line 604
  packet->data = (uint8_t *)tmp;
  }
#line 605
  if (! packet->data) {
    {
#line 606
    fr_strerror_printf("No memory");
    }
#line 607
    return (-1);
  }
#line 609
  packet->data_len = length;
#line 611
  ptr = packet->data;
#line 613
  *(ptr + 0) = (uint8_t )1;
#line 614
  *(ptr + 1) = (uint8_t )code;
#line 616
  if (! vp) {
#line 617
    *(ptr + 2) = (uint8_t )0;
  } else {
#line 619
    *(ptr + 2) = (uint8_t )(vp->lvalue & 255U);
#line 620
    return (0);
  }
#line 626
  if (code == 1) {
    {
#line 629
    *(ptr + 3) = (uint8_t )12;
#line 631
    sequence = htonl((uint32_t )packet->id);
#line 632
    memcpy((void */* __restrict  */)(ptr + 4), (void const   */* __restrict  */)(& sequence),
           (size_t )4);
    }
  } else
#line 626
  if (code == 3) {
    {
#line 629
    *(ptr + 3) = (uint8_t )12;
#line 631
    sequence = htonl((uint32_t )packet->id);
#line 632
    memcpy((void */* __restrict  */)(ptr + 4), (void const   */* __restrict  */)(& sequence),
           (size_t )4);
    }
  } else {
#line 634
    if (! original) {
      {
#line 635
      fr_strerror_printf("Cannot send VQP response without request");
      }
#line 636
      return (-1);
    }
    {
#line 642
    memcpy((void */* __restrict  */)(ptr + 4), (void const   */* __restrict  */)(original->data + 4),
           (size_t )4);
#line 644
    *(ptr + 3) = (uint8_t )2;
    }
  }
#line 647
  ptr += 8;
#line 652
  i = 0;
  {
#line 652
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 652
    if (! (i < 12)) {
#line 652
      goto while_break___0;
    }
#line 653
    if (! vps[i]) {
#line 653
      goto while_break___0;
    }
#line 654
    vp = vps[i];
    {
#line 656
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 656
      if (fr_debug_flag) {
#line 656
        if (fr_log_fp) {
          {
#line 656
          vp_print(fr_log_fp, vp);
          }
        }
      }
#line 656
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 663
    *(ptr + 0) = (uint8_t )0;
#line 664
    *(ptr + 1) = (uint8_t )0;
#line 665
    *(ptr + 2) = (uint8_t )12;
#line 666
    *(ptr + 3) = (uint8_t )(vp->attribute & 255);
#line 669
    *(ptr + 4) = (uint8_t )0;
#line 670
    *(ptr + 5) = (uint8_t )(vp->length & 255UL);
#line 672
    ptr += 6;
    {
#line 676
    if (vp->type == 2) {
#line 676
      goto case_2;
    }
#line 680
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 677
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(& vp->lvalue),
           (size_t )4);
    }
#line 678
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 683
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(vp->data.octets),
           vp->length);
    }
#line 684
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 686
    ptr += vp->length;
#line 652
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 689
  return (0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 73
int fr_str2int(FR_NAME_NUMBER const   *table , char const   *name , int def ) ;
#line 74
char const   *fr_int2str(FR_NAME_NUMBER const   *table , int number , char const   *def ) ;
#line 78
int getword(char const   **ptr , char *buf , int buflen ) ;
#line 79
int getbareword(char const   **ptr , char *buf , int buflen ) ;
#line 81
FR_TOKEN getstring(char const   **ptr , char *buf , int buflen ) ;
#line 82
char const   *fr_token_name(int token ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing(char const   **ptr , char *buf , int buflen , int tok , FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
int getword(char const   **ptr , char *buf , int buflen ) 
{ 
  int tmp___0 ;
  FR_TOKEN tmp___1 ;

  {
  {
#line 209
  tmp___1 = getthing(ptr, buf, buflen, 0, tokens);
  }
#line 209
  if ((unsigned int )tmp___1 == 1U) {
#line 209
    tmp___0 = 0;
  } else {
#line 209
    tmp___0 = 1;
  }
#line 209
  return (tmp___0);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
int getbareword(char const   **ptr , char *buf , int buflen ) 
{ 
  FR_TOKEN token ;

  {
  {
#line 220
  token = getthing(ptr, buf, buflen, 0, (FR_NAME_NUMBER const   *)((void *)0));
  }
#line 221
  if ((unsigned int )token != 23U) {
#line 222
    return (0);
  }
#line 225
  return (1);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
FR_TOKEN gettoken(char const   **ptr , char *buf , int buflen ) 
{ 
  FR_TOKEN tmp ;

  {
  {
#line 233
  tmp = getthing(ptr, buf, buflen, 1, tokens);
  }
#line 233
  return (tmp);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
FR_TOKEN getstring(char const   **ptr , char *buf , int buflen ) 
{ 
  char const   *p ;
  unsigned short const   **tmp ;
  FR_TOKEN tmp___0 ;
  FR_TOKEN tmp___1 ;

  {
#line 241
  p = *ptr;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (*p) {
      {
#line 243
      tmp = __ctype_b_loc();
      }
#line 243
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 243
        goto while_break;
      }
    } else {
#line 243
      goto while_break;
    }
#line 243
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  *ptr = p;
#line 247
  if ((int const   )*p == 34) {
    {
#line 248
    tmp___0 = gettoken(ptr, buf, buflen);
    }
#line 248
    return (tmp___0);
  } else
#line 247
  if ((int const   )*p == 39) {
    {
#line 248
    tmp___0 = gettoken(ptr, buf, buflen);
    }
#line 248
    return (tmp___0);
  } else
#line 247
  if ((int const   )*p == 96) {
    {
#line 248
    tmp___0 = gettoken(ptr, buf, buflen);
    }
#line 248
    return (tmp___0);
  }
  {
#line 251
  tmp___1 = getthing(ptr, buf, buflen, 0, tokens);
  }
#line 251
  return (tmp___1);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
int fr_str2int(FR_NAME_NUMBER const   *table , char const   *name , int def ) 
{ 
  FR_NAME_NUMBER const   *this ;
  int tmp ;

  {
#line 261
  this = table;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! ((unsigned long )this->name != (unsigned long )((void *)0))) {
#line 261
      goto while_break;
    }
    {
#line 262
    tmp = strcasecmp((char const   *)this->name, name);
    }
#line 262
    if (tmp == 0) {
#line 263
      return ((int )this->number);
    }
#line 261
    this ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return (def);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
char const   *fr_int2str(FR_NAME_NUMBER const   *table , int number , char const   *def ) 
{ 
  FR_NAME_NUMBER const   *this ;

  {
#line 278
  this = table;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! ((unsigned long )this->name != (unsigned long )((void *)0))) {
#line 278
      goto while_break;
    }
#line 279
    if (this->number == (int const   )number) {
#line 280
      return ((char const   *)this->name);
    }
#line 278
    this ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return (def);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
char const   *fr_token_name(int token ) 
{ 
  char const   *tmp ;

  {
  {
#line 289
  tmp = fr_int2str(tokens, token, "???");
  }
#line 289
  return (tmp);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 37
void fr_md4_calc(unsigned char *output , unsigned char const   *input , unsigned int inlen ) ;
#line 78
void fr_MD4Init(FR_MD4_CTX *ctx ) ;
#line 79
void fr_MD4Update(FR_MD4_CTX *ctx , unsigned char const   *buf , size_t len ) ;
#line 81
void fr_MD4Final(unsigned char *digest , FR_MD4_CTX *ctx ) ;
#line 83
void fr_MD4Transform(uint32_t *buf , unsigned char const   *inc ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
void fr_md4_calc(unsigned char *output , unsigned char const   *input , unsigned int inlen ) 
{ 
  FR_MD4_CTX context ;

  {
  {
#line 28
  fr_MD4Init(& context);
#line 29
  fr_MD4Update(& context, input, (size_t )inlen);
#line 30
  fr_MD4Final((uint8_t *)output, & context);
  }
#line 31
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
void fr_MD4Init(FR_MD4_CTX *ctx ) 
{ 


  {
#line 135
  ctx->count[0] = (uint32_t )0;
#line 136
  ctx->count[1] = (uint32_t )0;
#line 137
  ctx->state[0] = (uint32_t )1732584193;
#line 138
  ctx->state[1] = 4023233417U;
#line 139
  ctx->state[2] = 2562383102U;
#line 140
  ctx->state[3] = (uint32_t )271733878;
#line 141
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
void fr_MD4Update(FR_MD4_CTX *ctx , unsigned char const   *buf , size_t len ) 
{ 
  uint32_t count ;
  uint32_t tmp ;
  unsigned char *p ;

  {
#line 153
  count = (ctx->count[0] >> 3) & 63U;
#line 157
  tmp = ctx->count[0] + ((uint32_t )len << 3);
#line 157
  ctx->count[0] = tmp;
#line 157
  if (tmp < (uint32_t )len) {
#line 159
    (ctx->count[1]) ++;
  }
#line 161
  ctx->count[1] += (uint32_t )len >> 29;
#line 164
  if (count) {
#line 165
    p = ctx->buffer + count;
#line 167
    count = 64U - count;
#line 168
    if (len < (size_t )count) {
      {
#line 169
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf, len);
      }
#line 170
      return;
    }
    {
#line 172
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf, (size_t )count);
#line 174
    fr_MD4Transform((uint32_t *)(ctx->state), (uint8_t const   *)(ctx->buffer));
#line 175
    buf += count;
#line 176
    len -= (size_t )count;
    }
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (len >= 64UL)) {
#line 180
      goto while_break;
    }
    {
#line 181
    memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buf,
           (size_t )64);
#line 183
    fr_MD4Transform((uint32_t *)(ctx->state), (uint8_t const   *)(ctx->buffer));
#line 184
    buf += 64;
#line 185
    len -= 64UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buf,
         len);
  }
#line 190
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
void fr_MD4Final(unsigned char *digest , FR_MD4_CTX *ctx ) 
{ 
  uint32_t count ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
#line 203
  count = (ctx->count[0] >> 3) & 63U;
#line 209
  p = ctx->buffer + count;
#line 210
  tmp = p;
#line 210
  p ++;
#line 210
  *tmp = (unsigned char)128;
#line 213
  count = 63U - count;
#line 216
  if (count < 8U) {
    {
#line 218
    memset((void *)p, 0, (size_t )count);
#line 220
    fr_MD4Transform((uint32_t *)(ctx->state), (uint8_t const   *)(ctx->buffer));
#line 223
    memset((void *)(ctx->buffer), 0, (size_t )56);
    }
  } else {
    {
#line 226
    memset((void *)p, 0, (size_t )(count - 8U));
    }
  }
  {
#line 231
  *((uint32_t *)(ctx->buffer) + 14) = ctx->count[0];
#line 232
  *((uint32_t *)(ctx->buffer) + 15) = ctx->count[1];
#line 234
  fr_MD4Transform((uint32_t *)(ctx->state), (uint8_t const   *)(ctx->buffer));
#line 236
  memcpy((void */* __restrict  */)digest, (void const   */* __restrict  */)(ctx->state),
         (size_t )16);
#line 237
  memset((void *)ctx, 0, sizeof(*ctx));
  }
#line 238
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
void fr_MD4Transform(uint32_t *buf , unsigned char const   *inc ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t const   *in ;

  {
#line 261
  in = (uint32_t const   *)inc;
#line 263
  a = *(buf + 0);
#line 264
  b = *(buf + 1);
#line 265
  c = *(buf + 2);
#line 266
  d = *(buf + 3);
#line 268
  a += (d ^ (b & (c ^ d))) + (unsigned int )*(in + 0);
#line 268
  a = (a << 3) | (a >> 29);
#line 269
  d += (c ^ (a & (b ^ c))) + (unsigned int )*(in + 1);
#line 269
  d = (d << 7) | (d >> 25);
#line 270
  c += (b ^ (d & (a ^ b))) + (unsigned int )*(in + 2);
#line 270
  c = (c << 11) | (c >> 21);
#line 271
  b += (a ^ (c & (d ^ a))) + (unsigned int )*(in + 3);
#line 271
  b = (b << 19) | (b >> 13);
#line 272
  a += (d ^ (b & (c ^ d))) + (unsigned int )*(in + 4);
#line 272
  a = (a << 3) | (a >> 29);
#line 273
  d += (c ^ (a & (b ^ c))) + (unsigned int )*(in + 5);
#line 273
  d = (d << 7) | (d >> 25);
#line 274
  c += (b ^ (d & (a ^ b))) + (unsigned int )*(in + 6);
#line 274
  c = (c << 11) | (c >> 21);
#line 275
  b += (a ^ (c & (d ^ a))) + (unsigned int )*(in + 7);
#line 275
  b = (b << 19) | (b >> 13);
#line 276
  a += (d ^ (b & (c ^ d))) + (unsigned int )*(in + 8);
#line 276
  a = (a << 3) | (a >> 29);
#line 277
  d += (c ^ (a & (b ^ c))) + (unsigned int )*(in + 9);
#line 277
  d = (d << 7) | (d >> 25);
#line 278
  c += (b ^ (d & (a ^ b))) + (unsigned int )*(in + 10);
#line 278
  c = (c << 11) | (c >> 21);
#line 279
  b += (a ^ (c & (d ^ a))) + (unsigned int )*(in + 11);
#line 279
  b = (b << 19) | (b >> 13);
#line 280
  a += (d ^ (b & (c ^ d))) + (unsigned int )*(in + 12);
#line 280
  a = (a << 3) | (a >> 29);
#line 281
  d += (c ^ (a & (b ^ c))) + (unsigned int )*(in + 13);
#line 281
  d = (d << 7) | (d >> 25);
#line 282
  c += (b ^ (d & (a ^ b))) + (unsigned int )*(in + 14);
#line 282
  c = (c << 11) | (c >> 21);
#line 283
  b += (a ^ (c & (d ^ a))) + (unsigned int )*(in + 15);
#line 283
  b = (b << 19) | (b >> 13);
#line 285
  a += ((((b & c) | (b & d)) | (c & d)) + (unsigned int )*(in + 0)) + 1518500249U;
#line 285
  a = (a << 3) | (a >> 29);
#line 286
  d += ((((a & b) | (a & c)) | (b & c)) + (unsigned int )*(in + 4)) + 1518500249U;
#line 286
  d = (d << 5) | (d >> 27);
#line 287
  c += ((((d & a) | (d & b)) | (a & b)) + (unsigned int )*(in + 8)) + 1518500249U;
#line 287
  c = (c << 9) | (c >> 23);
#line 288
  b += ((((c & d) | (c & a)) | (d & a)) + (unsigned int )*(in + 12)) + 1518500249U;
#line 288
  b = (b << 13) | (b >> 19);
#line 289
  a += ((((b & c) | (b & d)) | (c & d)) + (unsigned int )*(in + 1)) + 1518500249U;
#line 289
  a = (a << 3) | (a >> 29);
#line 290
  d += ((((a & b) | (a & c)) | (b & c)) + (unsigned int )*(in + 5)) + 1518500249U;
#line 290
  d = (d << 5) | (d >> 27);
#line 291
  c += ((((d & a) | (d & b)) | (a & b)) + (unsigned int )*(in + 9)) + 1518500249U;
#line 291
  c = (c << 9) | (c >> 23);
#line 292
  b += ((((c & d) | (c & a)) | (d & a)) + (unsigned int )*(in + 13)) + 1518500249U;
#line 292
  b = (b << 13) | (b >> 19);
#line 293
  a += ((((b & c) | (b & d)) | (c & d)) + (unsigned int )*(in + 2)) + 1518500249U;
#line 293
  a = (a << 3) | (a >> 29);
#line 294
  d += ((((a & b) | (a & c)) | (b & c)) + (unsigned int )*(in + 6)) + 1518500249U;
#line 294
  d = (d << 5) | (d >> 27);
#line 295
  c += ((((d & a) | (d & b)) | (a & b)) + (unsigned int )*(in + 10)) + 1518500249U;
#line 295
  c = (c << 9) | (c >> 23);
#line 296
  b += ((((c & d) | (c & a)) | (d & a)) + (unsigned int )*(in + 14)) + 1518500249U;
#line 296
  b = (b << 13) | (b >> 19);
#line 297
  a += ((((b & c) | (b & d)) | (c & d)) + (unsigned int )*(in + 3)) + 1518500249U;
#line 297
  a = (a << 3) | (a >> 29);
#line 298
  d += ((((a & b) | (a & c)) | (b & c)) + (unsigned int )*(in + 7)) + 1518500249U;
#line 298
  d = (d << 5) | (d >> 27);
#line 299
  c += ((((d & a) | (d & b)) | (a & b)) + (unsigned int )*(in + 11)) + 1518500249U;
#line 299
  c = (c << 9) | (c >> 23);
#line 300
  b += ((((c & d) | (c & a)) | (d & a)) + (unsigned int )*(in + 15)) + 1518500249U;
#line 300
  b = (b << 13) | (b >> 19);
#line 302
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 0)) + 1859775393U;
#line 302
  a = (a << 3) | (a >> 29);
#line 303
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 8)) + 1859775393U;
#line 303
  d = (d << 9) | (d >> 23);
#line 304
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 4)) + 1859775393U;
#line 304
  c = (c << 11) | (c >> 21);
#line 305
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 12)) + 1859775393U;
#line 305
  b = (b << 15) | (b >> 17);
#line 306
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 2)) + 1859775393U;
#line 306
  a = (a << 3) | (a >> 29);
#line 307
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 10)) + 1859775393U;
#line 307
  d = (d << 9) | (d >> 23);
#line 308
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 6)) + 1859775393U;
#line 308
  c = (c << 11) | (c >> 21);
#line 309
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 14)) + 1859775393U;
#line 309
  b = (b << 15) | (b >> 17);
#line 310
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 1)) + 1859775393U;
#line 310
  a = (a << 3) | (a >> 29);
#line 311
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 9)) + 1859775393U;
#line 311
  d = (d << 9) | (d >> 23);
#line 312
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 5)) + 1859775393U;
#line 312
  c = (c << 11) | (c >> 21);
#line 313
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 13)) + 1859775393U;
#line 313
  b = (b << 15) | (b >> 17);
#line 314
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 3)) + 1859775393U;
#line 314
  a = (a << 3) | (a >> 29);
#line 315
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 11)) + 1859775393U;
#line 315
  d = (d << 9) | (d >> 23);
#line 316
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 7)) + 1859775393U;
#line 316
  c = (c << 11) | (c >> 21);
#line 317
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 15)) + 1859775393U;
#line 317
  b = (b << 15) | (b >> 17);
#line 319
  *(buf + 0) += a;
#line 320
  *(buf + 1) += b;
#line 321
  *(buf + 2) += c;
#line 322
  *(buf + 3) += d;
#line 323
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 447 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
rbtree_t *rbtree_create(int (*Compare)(void const   * , void const   * ) , void (*freeNode)(void * ) ,
                        int replace_flag ) ;
#line 450
void rbtree_free(rbtree_t *tree ) ;
#line 451
int rbtree_insert(rbtree_t *tree , void *Data ) ;
#line 452
rbnode_t *rbtree_insertnode(rbtree_t *tree , void *Data ) ;
#line 453
void rbtree_delete(rbtree_t *tree , rbnode_t *Z ) ;
#line 454
int rbtree_deletebydata(rbtree_t *tree , void const   *data ) ;
#line 455
rbnode_t *rbtree_find(rbtree_t *tree , void const   *Data ) ;
#line 456
void *rbtree_finddata(rbtree_t *tree , void const   *Data ) ;
#line 457
int rbtree_num_elements(rbtree_t *tree ) ;
#line 458
void *rbtree_min(rbtree_t *tree ) ;
#line 459
void *rbtree_node2data(rbtree_t *tree , rbnode_t *node ) ;
#line 475
int rbtree_walk(rbtree_t *tree , RBTREE_ORDER order , int (*callback)(void * , void * ) ,
                void *context ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel  =    {& Sentinel, & Sentinel, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel)) {
    {
#line 60
    FreeWalker(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel)) {
    {
#line 61
    FreeWalker(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
void rbtree_free(rbtree_t *tree ) 
{ 


  {
#line 69
  if (! tree) {
#line 69
    return;
  }
#line 74
  if ((unsigned long )tree->Root != (unsigned long )(& Sentinel)) {
    {
#line 74
    FreeWalker(tree, tree->Root);
    }
  }
  {
#line 79
  tree->Root = (rbnode_t *)((void *)0);
#line 80
  free((void *)tree);
  }
#line 81
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
rbtree_t *rbtree_create(int (*Compare)(void const   * , void const   * ) , void (*freeNode)(void * ) ,
                        int replace_flag ) 
{ 
  rbtree_t *tree ;
  void *tmp ;

  {
#line 92
  if (! Compare) {
#line 92
    return ((rbtree_t *)((void *)0));
  }
  {
#line 94
  tmp = malloc(sizeof(*tree));
#line 94
  tree = (rbtree_t *)tmp;
  }
#line 95
  if (! tree) {
#line 95
    return ((rbtree_t *)((void *)0));
  }
  {
#line 97
  memset((void *)tree, 0, sizeof(*tree));
#line 101
  tree->Root = & Sentinel;
#line 102
  tree->Compare = Compare;
#line 103
  tree->replace_flag = replace_flag;
#line 104
  tree->freeNode = freeNode;
  }
#line 106
  return (tree);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
rbnode_t *rbtree_insertnode(rbtree_t *tree , void *Data ) 
{ 
  rbnode_t *Current ;
  rbnode_t *Parent ;
  rbnode_t *X ;
  int result ;
  void *tmp ;
  int tmp___0 ;

  {
#line 240
  Current = tree->Root;
#line 241
  Parent = (rbnode_t *)((void *)0);
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! ((unsigned long )Current != (unsigned long )(& Sentinel))) {
#line 242
      goto while_break;
    }
    {
#line 248
    result = (*(tree->Compare))((void const   *)Data, (void const   *)Current->Data);
    }
#line 249
    if (result == 0) {
#line 253
      if (tree->replace_flag == 0) {
#line 254
        return ((rbnode_t *)((void *)0));
      }
#line 260
      if (tree->freeNode) {
        {
#line 260
        (*(tree->freeNode))(Current->Data);
        }
      }
#line 261
      Current->Data = Data;
#line 262
      return (Current);
    }
#line 265
    Parent = Current;
#line 266
    if (result < 0) {
#line 266
      Current = Current->Left;
    } else {
#line 266
      Current = Current->Right;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 270
  tmp = malloc(sizeof(*X));
#line 270
  X = (rbnode_t *)tmp;
  }
#line 270
  if ((unsigned long )X == (unsigned long )((void *)0)) {
    {
#line 271
    exit(1);
    }
  }
#line 274
  X->Data = Data;
#line 275
  X->Parent = Parent;
#line 276
  X->Left = & Sentinel;
#line 277
  X->Right = & Sentinel;
#line 278
  X->Color = (NodeColor )1;
#line 281
  if (Parent) {
    {
#line 282
    tmp___0 = (*(tree->Compare))((void const   *)Data, (void const   *)Parent->Data);
    }
#line 282
    if (tmp___0 <= 0) {
#line 283
      Parent->Left = X;
    } else {
#line 285
      Parent->Right = X;
    }
  } else {
#line 287
    tree->Root = X;
  }
  {
#line 290
  InsertFixup(tree, X);
#line 292
  (tree->num_elements) ++;
  }
#line 294
  return (X);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
int rbtree_insert(rbtree_t *tree , void *Data ) 
{ 
  rbnode_t *tmp ;

  {
  {
#line 299
  tmp = rbtree_insertnode(tree, Data);
  }
#line 299
  if (tmp) {
#line 299
    return (1);
  }
#line 300
  return (0);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
void rbtree_delete(rbtree_t *tree , rbnode_t *Z ) 
{ 
  rbnode_t *X ;
  rbnode_t *Y ;
  rbnode_t *Parent ;

  {
#line 382
  if (! Z) {
#line 382
    return;
  } else
#line 382
  if ((unsigned long )Z == (unsigned long )(& Sentinel)) {
#line 382
    return;
  }
#line 384
  if ((unsigned long )Z->Left == (unsigned long )(& Sentinel)) {
#line 386
    Y = Z;
  } else
#line 384
  if ((unsigned long )Z->Right == (unsigned long )(& Sentinel)) {
#line 386
    Y = Z;
  } else {
#line 389
    Y = Z->Right;
    {
#line 390
    while (1) {
      while_continue: /* CIL Label */ ;
#line 390
      if (! ((unsigned long )Y->Left != (unsigned long )(& Sentinel))) {
#line 390
        goto while_break;
      }
#line 390
      Y = Y->Left;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 394
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel)) {
#line 395
    X = Y->Left;
  } else {
#line 397
    X = Y->Right;
  }
#line 400
  Parent = Y->Parent;
#line 401
  if ((unsigned long )X != (unsigned long )(& Sentinel)) {
#line 401
    X->Parent = Parent;
  }
#line 403
  if (Parent) {
#line 404
    if ((unsigned long )Y == (unsigned long )Parent->Left) {
#line 405
      Parent->Left = X;
    } else {
#line 407
      Parent->Right = X;
    }
  } else {
#line 409
    tree->Root = X;
  }
#line 411
  if ((unsigned long )Y != (unsigned long )Z) {
#line 412
    if (tree->freeNode) {
      {
#line 412
      (*(tree->freeNode))(Z->Data);
      }
    }
#line 413
    Z->Data = Y->Data;
#line 414
    Y->Data = (void *)0;
#line 416
    if ((unsigned int )Y->Color == 0U) {
#line 416
      if ((unsigned long )X != (unsigned long )(& Sentinel)) {
        {
#line 417
        DeleteFixup(tree, X, Parent);
        }
      }
    }
    {
#line 426
    memcpy((void */* __restrict  */)Y, (void const   */* __restrict  */)Z, sizeof(*Y));
    }
#line 428
    if (! Y->Parent) {
#line 429
      tree->Root = Y;
    } else {
#line 431
      if ((unsigned long )(Y->Parent)->Left == (unsigned long )Z) {
#line 431
        (Y->Parent)->Left = Y;
      }
#line 432
      if ((unsigned long )(Y->Parent)->Right == (unsigned long )Z) {
#line 432
        (Y->Parent)->Right = Y;
      }
    }
#line 434
    if ((unsigned long )(Y->Left)->Parent == (unsigned long )Z) {
#line 434
      (Y->Left)->Parent = Y;
    }
#line 435
    if ((unsigned long )(Y->Right)->Parent == (unsigned long )Z) {
#line 435
      (Y->Right)->Parent = Y;
    }
    {
#line 437
    free((void *)Z);
    }
  } else {
#line 440
    if (tree->freeNode) {
      {
#line 440
      (*(tree->freeNode))(Y->Data);
      }
    }
#line 442
    if ((unsigned int )Y->Color == 0U) {
#line 442
      if ((unsigned long )X != (unsigned long )(& Sentinel)) {
        {
#line 443
        DeleteFixup(tree, X, Parent);
        }
      }
    }
    {
#line 445
    free((void *)Y);
    }
  }
#line 448
  (tree->num_elements) --;
#line 449
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
int rbtree_deletebydata(rbtree_t *tree , void const   *data ) 
{ 
  rbnode_t *node ;
  rbnode_t *tmp ;

  {
  {
#line 457
  tmp = rbtree_find(tree, data);
#line 457
  node = tmp;
  }
#line 459
  if (! node) {
#line 459
    return (0);
  }
  {
#line 461
  rbtree_delete(tree, node);
  }
#line 463
  return (1);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
rbnode_t *rbtree_find(rbtree_t *tree , void const   *Data ) 
{ 
  rbnode_t *Current ;
  int result ;
  int tmp ;

  {
#line 476
  Current = tree->Root;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! ((unsigned long )Current != (unsigned long )(& Sentinel))) {
#line 478
      goto while_break;
    }
    {
#line 479
    tmp = (*(tree->Compare))(Data, (void const   *)Current->Data);
#line 479
    result = tmp;
    }
#line 481
    if (result == 0) {
#line 482
      return (Current);
    } else
#line 484
    if (result < 0) {
#line 484
      Current = Current->Left;
    } else {
#line 484
      Current = Current->Right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  return ((rbnode_t *)((void *)0));
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
void *rbtree_finddata(rbtree_t *tree , void const   *Data ) 
{ 
  rbnode_t *X ;

  {
  {
#line 498
  X = rbtree_find(tree, Data);
  }
#line 499
  if (! X) {
#line 499
    return ((void *)0);
  }
#line 501
  return (X->Data);
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel)) {
    {
#line 523
    rcode = WalkNodePreOrder(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel)) {
    {
#line 528
    rcode = WalkNodePreOrder(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel)) {
    {
#line 545
    rcode = WalkNodeInOrder(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel)) {
    {
#line 555
    rcode = WalkNodeInOrder(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel)) {
    {
#line 572
    rcode = WalkNodeInOrder(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel)) {
    {
#line 577
    rcode = WalkNodeInOrder(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
int rbtree_walk(rbtree_t *tree , RBTREE_ORDER order , int (*callback)(void * , void * ) ,
                void *context ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 597
  if ((unsigned long )tree->Root == (unsigned long )(& Sentinel)) {
#line 597
    return (0);
  }
  {
#line 600
  if ((unsigned int )order == 0U) {
#line 600
    goto case_0;
  }
#line 602
  if ((unsigned int )order == 1U) {
#line 602
    goto case_1;
  }
#line 604
  if ((unsigned int )order == 2U) {
#line 604
    goto case_2;
  }
#line 607
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 601
  tmp = WalkNodePreOrder(tree->Root, callback, context);
  }
#line 601
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 603
  tmp___0 = WalkNodeInOrder(tree->Root, callback, context);
  }
#line 603
  return (tmp___0);
  case_2: /* CIL Label */ 
  {
#line 605
  tmp___1 = WalkNodePostOrder(tree->Root, callback, context);
  }
#line 605
  return (tmp___1);
  switch_default: /* CIL Label */ 
#line 608
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 611
  return (-1);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
int rbtree_num_elements(rbtree_t *tree ) 
{ 


  {
#line 616
  if (! tree) {
#line 616
    return (0);
  }
#line 618
  return (tree->num_elements);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
void *rbtree_node2data(rbtree_t *tree , rbnode_t *node ) 
{ 


  {
#line 627
  tree = tree;
#line 629
  if (! node) {
#line 629
    return ((void *)0);
  }
#line 631
  return (node->Data);
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
void *rbtree_min(rbtree_t *tree ) 
{ 
  rbnode_t *Current ;

  {
#line 641
  if (! tree) {
#line 641
    return ((void *)0);
  } else
#line 641
  if (! tree->Root) {
#line 641
    return ((void *)0);
  }
#line 643
  Current = tree->Root;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! ((unsigned long )Current->Left != (unsigned long )(& Sentinel))) {
#line 644
      goto while_break;
    }
#line 644
    Current = Current->Left;
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  return (Current->Data);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 412
void timeval2ntp(struct timeval  const  *tv , uint8_t *ntp ) ;
#line 413
void ntp2timeval(struct timeval *tv , char const   *ntp ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 243 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
void timeval2ntp(struct timeval  const  *tv , uint8_t *ntp ) 
{ 
  uint32_t sec ;
  uint32_t usec ;

  {
  {
#line 248
  sec = (uint32_t )((unsigned long long )tv->tv_sec + 2208988800ULL);
#line 249
  usec = (uint32_t )(tv->tv_usec * 4295L);
#line 250
  usec = (uint32_t )((__suseconds_t const   )usec - (tv->tv_usec * 2143L >> 16));
#line 252
  sec = htonl(sec);
#line 253
  usec = htonl(usec);
#line 255
  memcpy((void */* __restrict  */)ntp, (void const   */* __restrict  */)(& sec), sizeof(sec));
#line 256
  memcpy((void */* __restrict  */)(ntp + sizeof(sec)), (void const   */* __restrict  */)(& usec),
         sizeof(usec));
  }
#line 257
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
void ntp2timeval(struct timeval *tv , char const   *ntp ) 
{ 
  uint32_t sec ;
  uint32_t usec ;

  {
  {
#line 267
  memcpy((void */* __restrict  */)(& sec), (void const   */* __restrict  */)ntp, sizeof(sec));
#line 268
  memcpy((void */* __restrict  */)(& usec), (void const   */* __restrict  */)(ntp + sizeof(sec)),
         sizeof(usec));
#line 270
  sec = ntohl(sec);
#line 271
  usec = ntohl(usec);
#line 273
  tv->tv_sec = (__time_t )((unsigned long long )sec - 2208988800ULL);
#line 274
  tv->tv_usec = (__suseconds_t )(usec / 4295U);
  }
#line 275
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35
fr_heap_t *fr_heap_create(int (*cmp)(void const   * , void const   * ) , size_t offset ) ;
#line 36
void fr_heap_delete(fr_heap_t *hp ) ;
#line 38
int fr_heap_insert(fr_heap_t *hp , void *data ) ;
#line 39
int fr_heap_extract(fr_heap_t *hp , void *data ) ;
#line 40
void *fr_heap_peek(fr_heap_t *hp ) ;
#line 41
int fr_heap_num_elements(fr_heap_t *hp ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 41
fr_event_list_t *fr_event_list_create(void (*status)(struct timeval * ) ) ;
#line 42
void fr_event_list_free(fr_event_list_t *el ) ;
#line 44
int fr_event_list_num_elements(fr_event_list_t *el ) ;
#line 46
int fr_event_insert(fr_event_list_t *el , void (*callback)(void * ) , void *ctx ,
                    struct timeval *when , fr_event_t **ev_p ) ;
#line 49
int fr_event_delete(fr_event_list_t *el , fr_event_t **ev_p ) ;
#line 51
int fr_event_run(fr_event_list_t *el , struct timeval *when ) ;
#line 53
int fr_event_now(fr_event_list_t *el , struct timeval *when ) ;
#line 55
int fr_event_fd_insert(fr_event_list_t *el , int type , int fd , void (*handler)(fr_event_list_t *el ,
                                                                                 int sock ,
                                                                                 void *ctx ) ,
                       void *ctx ) ;
#line 57
int fr_event_fd_delete(fr_event_list_t *el , int type , int fd ) ;
#line 58
int fr_event_loop(fr_event_list_t *el ) ;
#line 59
void fr_event_loop_exit(fr_event_list_t *el , int code ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
void fr_event_list_free(fr_event_list_t *el ) 
{ 
  fr_event_t *ev ;
  void *tmp ;

  {
#line 89
  if (! el) {
#line 89
    return;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    tmp = fr_heap_peek(el->times);
#line 91
    ev = (fr_event_t *)tmp;
    }
#line 91
    if (! ((unsigned long )ev != (unsigned long )((void *)0))) {
#line 91
      goto while_break;
    }
    {
#line 92
    fr_event_delete(el, & ev);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  fr_heap_delete(el->times);
#line 96
  free((void *)el);
  }
#line 97
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
fr_event_list_t *fr_event_list_create(void (*status)(struct timeval * ) ) 
{ 
  int i ;
  fr_event_list_t *el ;
  void *tmp ;

  {
  {
#line 105
  tmp = malloc(sizeof(*el));
#line 105
  el = (fr_event_list_t *)tmp;
  }
#line 106
  if (! el) {
#line 106
    return ((fr_event_list_t *)((void *)0));
  }
  {
#line 107
  memset((void *)el, 0, sizeof(*el));
#line 109
  el->times = fr_heap_create(& fr_event_list_time_cmp, (unsigned long )(& ((fr_event_t *)0)->heap));
  }
#line 111
  if (! el->times) {
    {
#line 112
    fr_event_list_free(el);
    }
#line 113
    return ((fr_event_list_t *)((void *)0));
  }
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < 256)) {
#line 116
      goto while_break;
    }
#line 117
    el->readers[i].fd = -1;
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  el->status = status;
#line 121
  el->changed = 1;
#line 123
  return (el);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
int fr_event_list_num_elements(fr_event_list_t *el ) 
{ 
  int tmp ;

  {
#line 128
  if (! el) {
#line 128
    return (0);
  }
  {
#line 130
  tmp = fr_heap_num_elements(el->times);
  }
#line 130
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
int fr_event_delete(fr_event_list_t *el , fr_event_t **ev_p ) 
{ 
  fr_event_t *ev ;

  {
#line 138
  if (! el) {
#line 138
    return (0);
  } else
#line 138
  if (! ev_p) {
#line 138
    return (0);
  } else
#line 138
  if (! *ev_p) {
#line 138
    return (0);
  }
#line 140
  ev = *ev_p;
#line 141
  if (ev->ev_p) {
#line 141
    *(ev->ev_p) = (fr_event_t *)((void *)0);
  }
  {
#line 142
  *ev_p = (fr_event_t *)((void *)0);
#line 144
  fr_heap_extract(el->times, (void *)ev);
#line 145
  free((void *)ev);
  }
#line 147
  return (1);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
int fr_event_insert(fr_event_list_t *el , void (*callback)(void * ) , void *ctx ,
                    struct timeval *when , fr_event_t **ev_p ) 
{ 
  fr_event_t *ev ;
  void *tmp ;
  int tmp___0 ;

  {
#line 158
  if (! el) {
#line 158
    return (0);
  } else
#line 158
  if (! callback | ! when) {
#line 158
    return (0);
  } else
#line 158
  if (when->tv_usec >= 1000000L) {
#line 158
    return (0);
  }
#line 160
  if (ev_p) {
#line 160
    if (*ev_p) {
      {
#line 160
      fr_event_delete(el, ev_p);
      }
    }
  }
  {
#line 162
  tmp = malloc(sizeof(*ev));
#line 162
  ev = (fr_event_t *)tmp;
  }
#line 163
  if (! ev) {
#line 163
    return (0);
  }
  {
#line 164
  memset((void *)ev, 0, sizeof(*ev));
#line 166
  ev->callback = callback;
#line 167
  ev->ctx = ctx;
#line 168
  ev->when = *when;
#line 169
  ev->ev_p = ev_p;
#line 171
  tmp___0 = fr_heap_insert(el->times, (void *)ev);
  }
#line 171
  if (! tmp___0) {
    {
#line 172
    free((void *)ev);
    }
#line 173
    return (0);
  }
#line 176
  if (ev_p) {
#line 176
    *ev_p = ev;
  }
#line 177
  return (1);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
int fr_event_run(fr_event_list_t *el , struct timeval *when ) 
{ 
  void (*callback)(void * ) ;
  void *ctx ;
  fr_event_t *ev ;
  int tmp ;
  void *tmp___0 ;

  {
#line 187
  if (! el) {
#line 187
    return (0);
  }
  {
#line 189
  tmp = fr_heap_num_elements(el->times);
  }
#line 189
  if (tmp == 0) {
#line 190
    when->tv_sec = (__time_t )0;
#line 191
    when->tv_usec = (__suseconds_t )0;
#line 192
    return (0);
  }
  {
#line 195
  tmp___0 = fr_heap_peek(el->times);
#line 195
  ev = (fr_event_t *)tmp___0;
  }
#line 196
  if (! ev) {
#line 197
    when->tv_sec = (__time_t )0;
#line 198
    when->tv_usec = (__suseconds_t )0;
#line 199
    return (0);
  }
#line 205
  if (ev->when.tv_sec > when->tv_sec) {
#line 208
    *when = ev->when;
#line 209
    return (0);
  } else
#line 205
  if (ev->when.tv_sec == when->tv_sec) {
#line 205
    if (ev->when.tv_usec > when->tv_usec) {
#line 208
      *when = ev->when;
#line 209
      return (0);
    }
  }
  {
#line 212
  callback = ev->callback;
#line 213
  ctx = ev->ctx;
#line 218
  fr_event_delete(el, & ev);
#line 220
  (*callback)(ctx);
  }
#line 221
  return (1);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
int fr_event_now(fr_event_list_t *el , struct timeval *when ) 
{ 


  {
#line 227
  if (! when) {
#line 227
    return (0);
  }
#line 229
  if (el) {
#line 229
    if (el->dispatch) {
#line 230
      *when = el->now;
    } else {
      {
#line 232
      gettimeofday((struct timeval */* __restrict  */)when, (__timezone_ptr_t )((void *)0));
      }
    }
  } else {
    {
#line 232
    gettimeofday((struct timeval */* __restrict  */)when, (__timezone_ptr_t )((void *)0));
    }
  }
#line 235
  return (1);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
int fr_event_fd_insert(fr_event_list_t *el , int type , int fd , void (*handler)(fr_event_list_t *el ,
                                                                                 int sock ,
                                                                                 void *ctx ) ,
                       void *ctx ) 
{ 
  int i ;
  fr_event_fd_t *ef ;

  {
#line 245
  if (! el) {
#line 245
    return (0);
  } else
#line 245
  if (fd < 0) {
#line 245
    return (0);
  } else
#line 245
  if (! handler) {
#line 245
    return (0);
  } else
#line 245
  if (! ctx) {
#line 245
    return (0);
  }
#line 247
  if (type != 0) {
#line 247
    return (0);
  }
#line 249
  if (el->max_readers >= 256) {
#line 249
    return (0);
  }
#line 251
  ef = (fr_event_fd_t *)((void *)0);
#line 252
  i = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i <= el->max_readers)) {
#line 252
      goto while_break;
    }
#line 256
    if (el->readers[i].fd == fd) {
#line 257
      if ((unsigned long )el->readers[i].handler != (unsigned long )handler) {
#line 259
        return (0);
      } else
#line 257
      if ((unsigned long )el->readers[i].ctx != (unsigned long )ctx) {
#line 259
        return (0);
      }
#line 265
      return (1);
    }
#line 268
    if (el->readers[i].fd < 0) {
#line 269
      ef = & el->readers[i];
#line 271
      if (i == el->max_readers) {
#line 271
        el->max_readers = i + 1;
      }
#line 272
      goto while_break;
    }
#line 252
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if (! ef) {
#line 276
    return (0);
  }
#line 278
  ef->handler = handler;
#line 279
  ef->ctx = ctx;
#line 280
  ef->fd = fd;
#line 282
  el->changed = 1;
#line 284
  return (1);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
int fr_event_fd_delete(fr_event_list_t *el , int type , int fd ) 
{ 
  int i ;

  {
#line 291
  if (! el) {
#line 291
    return (0);
  } else
#line 291
  if (fd < 0) {
#line 291
    return (0);
  }
#line 293
  if (type != 0) {
#line 293
    return (0);
  }
#line 295
  i = 0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (i < el->max_readers)) {
#line 295
      goto while_break;
    }
#line 296
    if (el->readers[i].fd == fd) {
#line 297
      el->readers[i].fd = -1;
#line 298
      if (i + 1 == el->max_readers) {
#line 298
        el->max_readers = i;
      }
#line 299
      el->changed = 1;
#line 300
      return (1);
    }
#line 295
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return (0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
void fr_event_loop_exit(fr_event_list_t *el , int code ) 
{ 


  {
#line 310
  if (! el) {
#line 310
    return;
  }
#line 312
  el->exit = code;
#line 313
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
int fr_event_loop(fr_event_list_t *el ) 
{ 
  int i ;
  int rcode ;
  int maxfd ;
  struct timeval when ;
  struct timeval *wake ;
  fd_set read_fds ;
  fd_set master_fds ;
  int __d0 ;
  int __d1 ;
  fr_event_t *ev ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  fr_event_fd_t *ef ;

  {
#line 318
  maxfd = 0;
#line 322
  el->exit = 0;
#line 323
  el->dispatch = 1;
#line 324
  el->changed = 1;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! (! el->exit)) {
#line 326
      goto while_break;
    }
#line 330
    if (el->changed) {
      {
#line 331
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 331
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& master_fds.fds_bits[0]): "memory");
#line 331
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 333
      i = 0;
      {
#line 333
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 333
        if (! (i < el->max_readers)) {
#line 333
          goto while_break___1;
        }
#line 334
        if (el->readers[i].fd < 0) {
#line 334
          goto __Cont;
        }
#line 336
        if (el->readers[i].fd > maxfd) {
#line 337
          maxfd = el->readers[i].fd;
        }
#line 339
        master_fds.fds_bits[el->readers[i].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << el->readers[i].fd % (8 * (int )sizeof(__fd_mask ));
        __Cont: /* CIL Label */ 
#line 333
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 342
      el->changed = 0;
    }
    {
#line 349
    when.tv_sec = (__time_t )0;
#line 350
    when.tv_usec = (__suseconds_t )0;
#line 352
    tmp___1 = fr_heap_num_elements(el->times);
    }
#line 352
    if (tmp___1 > 0) {
      {
#line 355
      tmp = fr_heap_peek(el->times);
#line 355
      ev = (fr_event_t *)tmp;
      }
#line 356
      if (! ev) {
        {
#line 356
        _exit(42);
        }
      }
      {
#line 358
      gettimeofday((struct timeval */* __restrict  */)(& el->now), (__timezone_ptr_t )((void *)0));
      }
#line 360
      if (el->now.tv_sec == ev->when.tv_sec) {
#line 360
        tmp___0 = el->now.tv_usec < ev->when.tv_usec;
      } else {
#line 360
        tmp___0 = el->now.tv_sec < ev->when.tv_sec;
      }
#line 360
      if (tmp___0) {
#line 361
        when = ev->when;
#line 362
        when.tv_sec -= el->now.tv_sec;
#line 364
        if (when.tv_sec > 0L) {
#line 365
          (when.tv_sec) --;
#line 366
          when.tv_usec += 1000000L;
        } else {
#line 368
          when.tv_sec = (__time_t )0;
        }
#line 370
        when.tv_usec -= el->now.tv_usec;
#line 371
        if (when.tv_usec >= 1000000L) {
#line 372
          when.tv_usec -= 1000000L;
#line 373
          (when.tv_sec) ++;
        }
      } else {
#line 376
        when.tv_sec = (__time_t )0;
#line 377
        when.tv_usec = (__suseconds_t )0;
      }
#line 380
      wake = & when;
    } else {
#line 382
      wake = (struct timeval *)((void *)0);
    }
#line 388
    if (el->status) {
      {
#line 388
      (*(el->status))(wake);
      }
    }
    {
#line 390
    read_fds = master_fds;
#line 391
    rcode = select(maxfd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)wake);
    }
#line 392
    if (rcode < 0) {
      {
#line 392
      tmp___4 = __errno_location();
      }
#line 392
      if (*tmp___4 != 4) {
        {
#line 393
        tmp___2 = __errno_location();
#line 393
        tmp___3 = strerror(*tmp___2);
#line 393
        fr_strerror_printf("Failed in select: %s", tmp___3);
#line 395
        el->dispatch = 0;
        }
#line 396
        return (-1);
      }
    }
    {
#line 399
    tmp___6 = fr_heap_num_elements(el->times);
    }
#line 399
    if (tmp___6 > 0) {
      {
#line 400
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 401
        gettimeofday((struct timeval */* __restrict  */)(& el->now), (__timezone_ptr_t )((void *)0));
#line 402
        when = el->now;
#line 400
        tmp___5 = fr_event_run(el, & when);
        }
#line 400
        if (! (tmp___5 == 1)) {
#line 400
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 406
    if (rcode <= 0) {
#line 406
      goto while_continue;
    }
#line 408
    i = 0;
    {
#line 408
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 408
      if (! (i < el->max_readers)) {
#line 408
        goto while_break___3;
      }
#line 409
      ef = & el->readers[i];
#line 411
      if (ef->fd < 0) {
#line 411
        goto __Cont___0;
      }
#line 413
      if (! ((read_fds.fds_bits[ef->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ef->fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 413
        goto __Cont___0;
      }
      {
#line 415
      (*(ef->handler))(el, ef->fd, ef->ctx);
      }
#line 417
      if (el->changed) {
#line 417
        goto while_break___3;
      }
      __Cont___0: /* CIL Label */ 
#line 408
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  el->dispatch = 0;
#line 422
  return (el->exit);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ 
  char *d ;
  char const   *s ;
  size_t n ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 43
  d = dst;
#line 44
  s = src;
#line 45
  n = siz;
#line 48
  if (n != 0UL) {
#line 48
    n --;
#line 48
    if (n != 0UL) {
      {
#line 49
      while (1) {
        while_continue: /* CIL Label */ ;
#line 50
        tmp = d;
#line 50
        d ++;
#line 50
        tmp___1 = s;
#line 50
        s ++;
#line 50
        tmp___0 = (char )*tmp___1;
#line 50
        *tmp = tmp___0;
#line 50
        if ((int )tmp___0 == 0) {
#line 51
          goto while_break;
        }
#line 49
        n --;
#line 49
        if (! (n != 0UL)) {
#line 49
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 56
  if (n == 0UL) {
#line 57
    if (siz != 0UL) {
#line 58
      *d = (char )'\000';
    }
    {
#line 59
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 59
      tmp___2 = s;
#line 59
      s ++;
#line 59
      if (! *tmp___2) {
#line 59
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 63
  return ((size_t )((s - src) - 1L));
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 254 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
int dict_addvendor(char const   *name , int value ) ;
#line 255
int dict_addattr(char const   *name , int vendor , int type , int value , ATTR_FLAGS flags ) ;
#line 256
int dict_addvalue(char const   *namestr , char const   *attrstr , int value ) ;
#line 257
int dict_init(char const   *dir , char const   *fn ) ;
#line 258
void dict_free(void) ;
#line 437
void fr_rand_seed(void const   *data , size_t size ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir);
#line 240
  stat_root_dir = (char *)((void *)0);
#line 241
  free((void *)stat_root_file);
#line 242
  stat_root_file = (char *)((void *)0);
  }
#line 244
  if (! stat_head) {
#line 245
    stat_tail = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail = (dict_stat_t *)((void *)0);
#line 255
  stat_head = stat_tail;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head) {
#line 274
    stat_tail = this;
#line 274
    stat_head = stat_tail;
  } else {
#line 276
    stat_tail->next = this;
#line 277
    stat_tail = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head) {
#line 297
    return (0);
  }
#line 299
  this = stat_head;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool) {
    {
#line 359
    dict_pool = fr_pool_create();
    }
#line 360
    if (! dict_pool) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool->page_free)->page_end)) {
    {
#line 368
    (dict_pool->page_free)->page_next = fr_pool_create();
    }
#line 369
    if (! (dict_pool->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool->page_free = (dict_pool->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool->page_free)->free_ptr;
#line 374
  (dict_pool->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
void dict_free(void) 
{ 


  {
  {
#line 395
  fr_hash_table_free(vendors_byname);
#line 396
  fr_hash_table_free(vendors_byvalue);
#line 397
  vendors_byname = (fr_hash_table_t *)((void *)0);
#line 398
  vendors_byvalue = (fr_hash_table_t *)((void *)0);
#line 400
  fr_hash_table_free(attributes_byname);
#line 401
  fr_hash_table_free(attributes_byvalue);
#line 402
  attributes_byname = (fr_hash_table_t *)((void *)0);
#line 403
  attributes_byvalue = (fr_hash_table_t *)((void *)0);
#line 405
  fr_hash_table_free(values_byname);
#line 406
  fr_hash_table_free(values_byvalue);
#line 407
  values_byname = (fr_hash_table_t *)((void *)0);
#line 408
  values_byvalue = (fr_hash_table_t *)((void *)0);
#line 410
  memset((void *)(dict_base_attrs), 0, sizeof(dict_base_attrs));
#line 412
  fr_pool_delete(& dict_pool);
#line 414
  dict_stat_free();
  }
#line 415
  return;
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
int dict_addvendor(char const   *name , int value ) 
{ 
  size_t length ;
  DICT_VENDOR *dv ;
  void *tmp ;
  int tmp___0 ;
  DICT_VENDOR *old_dv ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 426
  if (value > 65535) {
    {
#line 427
    fr_strerror_printf("dict_addvendor: Cannot handle vendor ID larger than 65535");
    }
#line 428
    return (-1);
  }
  {
#line 431
  length = strlen(name);
  }
#line 431
  if (length >= 128UL) {
    {
#line 432
    fr_strerror_printf("dict_addvendor: vendor name too long");
    }
#line 433
    return (-1);
  }
  {
#line 436
  tmp = fr_pool_alloc(sizeof(*dv) + length);
#line 436
  dv = (DICT_VENDOR *)tmp;
  }
#line 436
  if ((unsigned long )dv == (unsigned long )((void *)0)) {
    {
#line 437
    fr_strerror_printf("dict_addvendor: out of memory");
    }
#line 438
    return (-1);
  }
  {
#line 441
  strcpy((char */* __restrict  */)(dv->name), (char const   */* __restrict  */)name);
#line 442
  dv->vendorpec = value;
#line 443
  tmp___0 = 1;
#line 443
  dv->length = tmp___0;
#line 443
  dv->type = tmp___0;
#line 445
  tmp___2 = fr_hash_table_insert(vendors_byname, (void *)dv);
  }
#line 445
  if (! tmp___2) {
    {
#line 448
    tmp___1 = fr_hash_table_finddata(vendors_byname, (void const   *)dv);
#line 448
    old_dv = (DICT_VENDOR *)tmp___1;
    }
#line 449
    if (! old_dv) {
      {
#line 450
      fr_strerror_printf("dict_addvendor: Failed inserting vendor name %s", name);
      }
#line 451
      return (-1);
    }
#line 453
    if (old_dv->vendorpec != dv->vendorpec) {
      {
#line 454
      fr_strerror_printf("dict_addvendor: Duplicate vendor name %s", name);
      }
#line 455
      return (-1);
    }
    {
#line 461
    fr_pool_free((void *)dv);
    }
#line 462
    return (0);
  }
  {
#line 474
  tmp___3 = fr_hash_table_replace(vendors_byvalue, (void *)dv);
  }
#line 474
  if (! tmp___3) {
    {
#line 475
    fr_strerror_printf("dict_addvendor: Failed inserting vendor %s", name);
    }
#line 477
    return (-1);
  }
#line 480
  return (0);
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor  =    (DICT_VENDOR *)((void *)0);
#line 486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
int dict_addattr(char const   *name , int vendor , int type , int value , ATTR_FLAGS flags ) 
{ 
  size_t namelen ;
  DICT_ATTR *attr ;
  DICT_ATTR *tmp ;
  DICT_VENDOR *dv ;
  void *tmp___0 ;
  DICT_ATTR *a ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 493
  namelen = strlen(name);
  }
#line 494
  if (namelen >= 128UL) {
    {
#line 495
    fr_strerror_printf("dict_addattr: attribute name too long");
    }
#line 496
    return (-1);
  }
#line 505
  if (value == -1) {
    {
#line 506
    tmp = dict_attrbyname(name);
    }
#line 506
    if (tmp) {
#line 507
      return (0);
    }
#line 510
    max_attr ++;
#line 510
    value = max_attr;
  } else
#line 512
  if (vendor == 0) {
#line 516
    if (value > max_attr) {
#line 517
      max_attr = value;
    }
  }
#line 521
  if (value < 0) {
    {
#line 522
    fr_strerror_printf("dict_addattr: ATTRIBUTE has invalid number (less than zero)");
    }
#line 523
    return (-1);
  }
#line 526
  if (value >= 65536) {
    {
#line 527
    fr_strerror_printf("dict_addattr: ATTRIBUTE has invalid number (larger than 65535).");
    }
#line 528
    return (-1);
  }
#line 531
  if (vendor) {
#line 535
    if (flags.is_tlv) {
#line 535
      if ((int )flags.encrypt != 0) {
        {
#line 536
        fr_strerror_printf("Sub-TLV\'s cannot be encrypted");
        }
#line 537
        return (-1);
      }
    }
#line 540
    if (flags.has_tlv) {
#line 540
      if ((int )flags.encrypt != 0) {
        {
#line 541
        fr_strerror_printf("TLV\'s cannot be encrypted");
        }
#line 542
        return (-1);
      }
    }
#line 545
    if (flags.is_tlv) {
#line 545
      if (flags.has_tag) {
        {
#line 546
        fr_strerror_printf("Sub-TLV\'s cannot have a tag");
        }
#line 547
        return (-1);
      }
    }
#line 550
    if (flags.has_tlv) {
#line 550
      if (flags.has_tag) {
        {
#line 551
        fr_strerror_printf("TLV\'s cannot have a tag");
        }
#line 552
        return (-1);
      }
    }
#line 561
    if (last_vendor) {
#line 561
      if (vendor == last_vendor->vendorpec) {
#line 562
        dv = last_vendor;
      } else {
        {
#line 564
        dv = dict_vendorbyvalue(vendor);
#line 565
        last_vendor = dv;
        }
      }
    } else {
      {
#line 564
      dv = dict_vendorbyvalue(vendor);
#line 565
      last_vendor = dv;
      }
    }
#line 571
    if (! dv) {
      {
#line 572
      fr_strerror_printf("dict_addattr: Unknown vendor");
      }
#line 573
      return (-1);
    }
#line 580
    if (dv->type == 1) {
#line 580
      if (value >= 256) {
#line 580
        if (! flags.is_tlv) {
          {
#line 581
          fr_strerror_printf("dict_addattr: ATTRIBUTE has invalid number (larger than 255).");
          }
#line 582
          return (-1);
        }
      }
    }
  }
  {
#line 589
  tmp___0 = fr_pool_alloc(sizeof(*attr) + namelen);
#line 589
  attr = (DICT_ATTR *)tmp___0;
  }
#line 589
  if ((unsigned long )attr == (unsigned long )((void *)0)) {
    {
#line 590
    fr_strerror_printf("dict_addattr: out of memory");
    }
#line 591
    return (-1);
  }
  {
#line 594
  memcpy((void */* __restrict  */)(attr->name), (void const   */* __restrict  */)name,
         namelen);
#line 595
  attr->name[namelen] = (char )'\000';
#line 596
  attr->attr = (unsigned int )value;
#line 597
  attr->attr |= (unsigned int )(vendor << 16);
#line 598
  attr->vendor = vendor;
#line 599
  attr->type = type;
#line 600
  attr->flags = flags;
#line 601
  attr->vendor = vendor;
#line 606
  tmp___4 = fr_hash_table_insert(attributes_byname, (void *)attr);
  }
#line 606
  if (! tmp___4) {
    {
#line 613
    tmp___1 = fr_hash_table_finddata(attributes_byname, (void const   *)attr);
#line 613
    a = (DICT_ATTR *)tmp___1;
    }
#line 614
    if (a) {
      {
#line 614
      tmp___2 = strcasecmp((char const   *)(a->name), (char const   *)(attr->name));
      }
#line 614
      if (tmp___2 == 0) {
#line 615
        if (a->attr != attr->attr) {
          {
#line 616
          fr_strerror_printf("dict_addattr: Duplicate attribute name %s", name);
#line 617
          fr_pool_free((void *)attr);
          }
#line 618
          return (-1);
        }
      }
    }
    {
#line 630
    fr_hash_table_delete(attributes_byvalue, (void const   *)a);
#line 632
    tmp___3 = fr_hash_table_replace(attributes_byname, (void *)attr);
    }
#line 632
    if (! tmp___3) {
      {
#line 633
      fr_strerror_printf("dict_addattr: Internal error storing attribute %s", name);
#line 634
      fr_pool_free((void *)attr);
      }
#line 635
      return (-1);
    }
  }
  {
#line 648
  tmp___5 = fr_hash_table_replace(attributes_byvalue, (void *)attr);
  }
#line 648
  if (! tmp___5) {
    {
#line 649
    fr_strerror_printf("dict_addattr: Failed inserting attribute name %s", name);
    }
#line 650
    return (-1);
  }
#line 653
  if (! vendor) {
#line 653
    if (value > 0) {
#line 653
      if (value < 256) {
#line 654
        dict_base_attrs[value] = attr;
      }
    }
  }
#line 657
  return (0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr  =    (DICT_ATTR *)((void *)0);
#line 664 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
int dict_addvalue(char const   *namestr , char const   *attrstr , int value ) 
{ 
  size_t length ;
  DICT_ATTR *dattr ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  value_fixup_t *fixup ;
  void *tmp___2 ;
  DICT_VALUE *old ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 672
  if (! *namestr) {
    {
#line 673
    fr_strerror_printf("dict_addvalue: empty names are not permitted");
    }
#line 674
    return (-1);
  }
  {
#line 677
  length = strlen(namestr);
  }
#line 677
  if (length >= 128UL) {
    {
#line 678
    fr_strerror_printf("dict_addvalue: value name too long");
    }
#line 679
    return (-1);
  }
  {
#line 682
  tmp = fr_pool_alloc(sizeof(*dval) + length);
#line 682
  dval = (DICT_VALUE *)tmp;
  }
#line 682
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 683
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 684
    return (-1);
  }
  {
#line 686
  memset((void *)dval, 0, sizeof(*dval));
#line 688
  strcpy((char */* __restrict  */)(dval->name), (char const   */* __restrict  */)namestr);
#line 689
  dval->value = value;
  }
#line 696
  if (last_attr) {
    {
#line 696
    tmp___0 = strcasecmp(attrstr, (char const   *)(last_attr->name));
    }
#line 696
    if (tmp___0 == 0) {
#line 697
      dattr = last_attr;
    } else {
      {
#line 699
      dattr = dict_attrbyname(attrstr);
#line 700
      last_attr = dattr;
      }
    }
  } else {
    {
#line 699
    dattr = dict_attrbyname(attrstr);
#line 700
    last_attr = dattr;
    }
  }
#line 707
  if (dattr) {
#line 708
    if (dattr->flags.has_value_alias) {
      {
#line 709
      fr_strerror_printf("dict_addvalue: Cannot add VALUE for ATTRIBUTE \"%s\": It already has a VALUE-ALIAS",
                         attrstr);
      }
#line 710
      return (-1);
    }
#line 713
    dval->attr = dattr->attr;
    {
#line 721
    if (dattr->type == 9) {
#line 721
      goto case_9;
    }
#line 728
    if (dattr->type == 10) {
#line 728
      goto case_10;
    }
#line 742
    if (dattr->type == 1) {
#line 742
      goto case_1;
    }
#line 742
    if (dattr->type == 5) {
#line 742
      goto case_1;
    }
#line 745
    goto switch_default;
    case_9: /* CIL Label */ 
#line 722
    if (value > 255) {
      {
#line 723
      fr_pool_free((void *)dval);
#line 724
      fr_strerror_printf("dict_addvalue: ATTRIBUTEs of type \'byte\' cannot have VALUEs larger than 255");
      }
#line 725
      return (-1);
    }
#line 727
    goto switch_break;
    case_10: /* CIL Label */ 
#line 729
    if (value > 65535) {
      {
#line 730
      fr_pool_free((void *)dval);
#line 731
      fr_strerror_printf("dict_addvalue: ATTRIBUTEs of type \'short\' cannot have VALUEs larger than 65535");
      }
#line 732
      return (-1);
    }
#line 734
    goto switch_break;
    case_1: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 743
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 746
    fr_pool_free((void *)dval);
#line 747
    tmp___1 = fr_int2str(type_table, dattr->type, "?Unknown?");
#line 747
    fr_strerror_printf("dict_addvalue: VALUEs cannot be defined for attributes of type \'%s\'",
                       tmp___1);
    }
#line 749
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 752
    dattr->flags.has_value = 1U;
  } else {
    {
#line 756
    tmp___2 = malloc(sizeof(*fixup));
#line 756
    fixup = (value_fixup_t *)tmp___2;
    }
#line 757
    if (! fixup) {
      {
#line 758
      fr_pool_free((void *)dval);
#line 759
      fr_strerror_printf("dict_addvalue: out of memory");
      }
#line 760
      return (-1);
    }
    {
#line 762
    memset((void *)fixup, 0, sizeof(*fixup));
#line 764
    strlcpy(fixup->attrstr, attrstr, sizeof(fixup->attrstr));
#line 765
    fixup->dval = dval;
#line 770
    fixup->next = value_fixup;
#line 771
    value_fixup = fixup;
    }
#line 773
    return (0);
  }
  {
#line 779
  tmp___3 = fr_hash_table_insert(values_byname, (void *)dval);
  }
#line 779
  if (! tmp___3) {
#line 780
    if (dattr) {
      {
#line 788
      old = dict_valbyname(dattr->attr, namestr);
      }
#line 789
      if (old) {
#line 789
        if (old->value == dval->value) {
          {
#line 790
          fr_pool_free((void *)dval);
          }
#line 791
          return (0);
        }
      }
    }
    {
#line 795
    fr_pool_free((void *)dval);
#line 796
    fr_strerror_printf("dict_addvalue: Duplicate value name %s for attribute %s",
                       namestr, attrstr);
    }
#line 797
    return (-1);
  }
  {
#line 804
  tmp___4 = fr_hash_table_replace(values_byvalue, (void *)dval);
  }
#line 804
  if (! tmp___4) {
    {
#line 805
    fr_strerror_printf("dict_addvalue: Failed inserting value %s", namestr);
    }
#line 807
    return (-1);
  }
#line 810
  return (0);
}
}
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute(char const   *fn , int const   line , int const   block_vendor ,
                             DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias(char const   *fn , int const   line , char **argv ,
                               int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init(char const   *dir , char const   *fn , char const   *src_file ,
                        int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute(fn, (int const   )line, (int const   )block_vendor,
                                  block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 1612 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
int dict_init(char const   *dir , char const   *fn ) 
{ 
  int tmp ;
  int tmp___0 ;
  DICT_ATTR *a ;
  value_fixup_t *this ;
  value_fixup_t *next ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1618
  tmp = dict_stat_check(dir, fn);
  }
#line 1618
  if (tmp) {
#line 1619
    return (0);
  }
  {
#line 1625
  dict_free();
#line 1626
  stat_root_dir = strdup(dir);
#line 1627
  stat_root_file = strdup(fn);
#line 1635
  vendors_byname = fr_hash_table_create(& dict_vendor_name_hash, & dict_vendor_name_cmp,
                                        & fr_pool_free);
  }
#line 1638
  if (! vendors_byname) {
#line 1639
    return (-1);
  }
  {
#line 1647
  vendors_byvalue = fr_hash_table_create(& dict_vendor_value_hash, & dict_vendor_value_cmp,
                                         & fr_pool_free);
  }
#line 1650
  if (! vendors_byvalue) {
#line 1651
    return (-1);
  }
  {
#line 1660
  attributes_byname = fr_hash_table_create(& dict_attr_name_hash, & dict_attr_name_cmp,
                                           & fr_pool_free);
  }
#line 1663
  if (! attributes_byname) {
#line 1664
    return (-1);
  }
  {
#line 1672
  attributes_byvalue = fr_hash_table_create(& dict_attr_value_hash, & dict_attr_value_cmp,
                                            & fr_pool_free);
  }
#line 1675
  if (! attributes_byvalue) {
#line 1676
    return (-1);
  }
  {
#line 1679
  values_byname = fr_hash_table_create(& dict_value_name_hash, & dict_value_name_cmp,
                                       & fr_pool_free);
  }
#line 1682
  if (! values_byname) {
#line 1683
    return (-1);
  }
  {
#line 1686
  values_byvalue = fr_hash_table_create(& dict_value_value_hash, & dict_value_value_cmp,
                                        & fr_pool_free);
  }
#line 1689
  if (! values_byvalue) {
#line 1690
    return (-1);
  }
  {
#line 1693
  value_fixup = (value_fixup_t *)((void *)0);
#line 1695
  tmp___0 = my_dict_init(dir, fn, (char const   *)((void *)0), 0);
  }
#line 1695
  if (tmp___0 < 0) {
#line 1696
    return (-1);
  }
#line 1698
  if (value_fixup) {
#line 1702
    this = value_fixup;
    {
#line 1702
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1702
      if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 1702
        goto while_break;
      }
      {
#line 1703
      next = this->next;
#line 1705
      a = dict_attrbyname((char const   *)(this->attrstr));
      }
#line 1706
      if (! a) {
        {
#line 1707
        fr_strerror_printf("dict_init: No ATTRIBUTE \"%s\" defined for VALUE \"%s\"",
                           this->attrstr, (this->dval)->name);
        }
#line 1710
        return (-1);
      }
      {
#line 1713
      (this->dval)->attr = a->attr;
#line 1718
      tmp___1 = fr_hash_table_replace(values_byname, (void *)this->dval);
      }
#line 1718
      if (! tmp___1) {
        {
#line 1720
        fr_strerror_printf("dict_addvalue: Duplicate value name %s for attribute %s",
                           (this->dval)->name, a->name);
        }
#line 1721
        return (-1);
      }
      {
#line 1729
      tmp___2 = fr_hash_table_finddata(values_byvalue, (void const   *)this->dval);
      }
#line 1729
      if (! tmp___2) {
        {
#line 1730
        fr_hash_table_replace(values_byvalue, (void *)this->dval);
        }
      }
      {
#line 1733
      free((void *)this);
#line 1738
      value_fixup = next;
#line 1702
      this = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1748
  fr_hash_table_walk(vendors_byname, & null_callback, (void *)0);
#line 1749
  fr_hash_table_walk(vendors_byvalue, & null_callback, (void *)0);
#line 1751
  fr_hash_table_walk(attributes_byname, & null_callback, (void *)0);
#line 1752
  fr_hash_table_walk(attributes_byvalue, & null_callback, (void *)0);
#line 1754
  fr_hash_table_walk(values_byvalue, & null_callback, (void *)0);
#line 1755
  fr_hash_table_walk(values_byname, & null_callback, (void *)0);
  }
#line 1757
  return (0);
}
}
#line 1763 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
DICT_ATTR *dict_attrbyvalue(unsigned int attr ) 
{ 
  DICT_ATTR dattr ;
  void *tmp ;

  {
#line 1767
  if (attr > 0U) {
#line 1767
    if (attr < 256U) {
#line 1767
      return (dict_base_attrs[attr]);
    }
  }
  {
#line 1769
  dattr.attr = attr;
#line 1770
  dattr.vendor = (int )((attr >> 16) & 65535U);
#line 1772
  tmp = fr_hash_table_finddata(attributes_byvalue, (void const   *)(& dattr));
  }
#line 1772
  return ((DICT_ATTR *)tmp);
}
}
#line 1778 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
DICT_ATTR *dict_attrbyname(char const   *name ) 
{ 
  DICT_ATTR *da ;
  uint32_t buffer[((sizeof(*da) + 128UL) + 3UL) / 4UL] ;
  void *tmp ;

  {
#line 1783
  if (! name) {
#line 1783
    return ((DICT_ATTR *)((void *)0));
  }
  {
#line 1785
  da = (DICT_ATTR *)(buffer);
#line 1786
  strlcpy(da->name, name, (size_t )129);
#line 1788
  tmp = fr_hash_table_finddata(attributes_byname, (void const   *)da);
  }
#line 1788
  return ((DICT_ATTR *)tmp);
}
}
#line 1794 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
DICT_VALUE *dict_valbyattr(unsigned int attr , int value ) 
{ 
  DICT_VALUE dval ;
  DICT_VALUE *dv ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1801
  dval.attr = attr;
#line 1802
  dval.name[0] = (char )'\000';
#line 1808
  tmp = fr_hash_table_finddata(values_byname, (void const   *)(& dval));
#line 1808
  dv = (DICT_VALUE *)tmp;
  }
#line 1809
  if (dv) {
#line 1809
    dval.attr = (unsigned int )dv->value;
  }
  {
#line 1811
  dval.value = value;
#line 1813
  tmp___0 = fr_hash_table_finddata(values_byvalue, (void const   *)(& dval));
  }
#line 1813
  return ((DICT_VALUE *)tmp___0);
}
}
#line 1819 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
DICT_VALUE *dict_valbyname(unsigned int attr , char const   *name ) 
{ 
  DICT_VALUE *my_dv ;
  DICT_VALUE *dv ;
  uint32_t buffer[((sizeof(*my_dv) + 128UL) + 3UL) / 4UL] ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1824
  if (! name) {
#line 1824
    return ((DICT_VALUE *)((void *)0));
  }
  {
#line 1826
  my_dv = (DICT_VALUE *)(buffer);
#line 1827
  my_dv->attr = attr;
#line 1828
  my_dv->name[0] = (char )'\000';
#line 1834
  tmp = fr_hash_table_finddata(values_byname, (void const   *)my_dv);
#line 1834
  dv = (DICT_VALUE *)tmp;
  }
#line 1835
  if (dv) {
#line 1835
    my_dv->attr = (unsigned int )dv->value;
  }
  {
#line 1837
  strlcpy(my_dv->name, name, (size_t )129);
#line 1839
  tmp___0 = fr_hash_table_finddata(values_byname, (void const   *)my_dv);
  }
#line 1839
  return ((DICT_VALUE *)tmp___0);
}
}
#line 1847 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
int dict_vendorbyname(char const   *name ) 
{ 
  DICT_VENDOR *dv ;
  uint32_t buffer[((sizeof(*dv) + 128UL) + 3UL) / 4UL] ;
  void *tmp ;

  {
#line 1852
  if (! name) {
#line 1852
    return (0);
  }
  {
#line 1854
  dv = (DICT_VENDOR *)(buffer);
#line 1855
  strlcpy(dv->name, name, (size_t )129);
#line 1857
  tmp = fr_hash_table_finddata(vendors_byname, (void const   *)dv);
#line 1857
  dv = (DICT_VENDOR *)tmp;
  }
#line 1858
  if (! dv) {
#line 1858
    return (0);
  }
#line 1860
  return (dv->vendorpec);
}
}
#line 1866 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
DICT_VENDOR *dict_vendorbyvalue(int vendorpec ) 
{ 
  DICT_VENDOR dv ;
  void *tmp ;

  {
  {
#line 1870
  dv.vendorpec = vendorpec;
#line 1872
  tmp = fr_hash_table_finddata(vendors_byvalue, (void const   *)(& dv));
  }
#line 1872
  return ((DICT_VENDOR *)tmp);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 289 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___0(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net(int argc , char **argv , ascend_ipx_net_t *net , uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
int ascend_parse_filter(VALUE_PAIR *pair ) 
{ 
  int token ;
  int type ;
  int rcode ;
  int argc ;
  char *argv[32] ;
  ascend_filter_t filter ;

  {
  {
#line 996
  rcode = -1;
#line 1003
  fr_strerror_printf("Text is not in proper format");
#line 1011
  argc = str2argv___0(pair->data.strvalue, argv, 32);
  }
#line 1012
  if (argc < 3) {
#line 1012
    return (-1);
  }
  {
#line 1017
  type = fr_str2int(filterType, (char const   *)argv[0], -1);
#line 1018
  memset((void *)(& filter), 0, sizeof(filter));
  }
  {
#line 1026
  if (type == 2) {
#line 1026
    goto case_2;
  }
#line 1026
  if (type == 1) {
#line 1026
    goto case_2;
  }
#line 1026
  if (type == 0) {
#line 1026
    goto case_2;
  }
#line 1030
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 1027
  filter.type = (uint8_t )type;
#line 1028
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1031
  fr_strerror_printf("Unknown Ascend filter type \"%s\"", argv[0]);
  }
#line 1032
  return (-1);
#line 1033
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1039
  token = fr_str2int(filterKeywords, (char const   *)argv[1], -1);
  }
  {
#line 1041
  if (token == 2) {
#line 1041
    goto case_2___0;
  }
#line 1045
  if (token == 3) {
#line 1045
    goto case_3;
  }
#line 1049
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
#line 1042
  filter.direction = (uint8_t )1;
#line 1043
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 1046
  filter.direction = (uint8_t )0;
#line 1047
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1050
  fr_strerror_printf("Unknown Ascend filter direction \"%s\"", argv[1]);
  }
#line 1051
  return (-1);
#line 1052
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1058
  token = fr_str2int(filterKeywords, (char const   *)argv[2], -1);
  }
  {
#line 1060
  if (token == 4) {
#line 1060
    goto case_4;
  }
#line 1064
  if (token == 5) {
#line 1064
    goto case_5;
  }
#line 1068
  goto switch_default___1;
  case_4: /* CIL Label */ 
#line 1061
  filter.forward = (uint8_t )1;
#line 1062
  goto switch_break___1;
  case_5: /* CIL Label */ 
#line 1065
  filter.forward = (uint8_t )0;
#line 1066
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
  {
#line 1069
  fr_strerror_printf("Unknown Ascend filter action \"%s\"", argv[2]);
  }
#line 1070
  return (-1);
#line 1071
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 1076
  if (type == 0) {
#line 1076
    goto case_0___0;
  }
#line 1081
  if (type == 1) {
#line 1081
    goto case_1___0;
  }
#line 1085
  if (type == 2) {
#line 1085
    goto case_2___1;
  }
#line 1089
  goto switch_default___2;
  case_0___0: /* CIL Label */ 
  {
#line 1077
  rcode = ascend_parse_generic(argc - 3, & argv[3], & filter.u.generic);
  }
#line 1079
  goto switch_break___2;
  case_1___0: /* CIL Label */ 
  {
#line 1082
  rcode = ascend_parse_ip(argc - 3, & argv[3], & filter.u.ip);
  }
#line 1083
  goto switch_break___2;
  case_2___1: /* CIL Label */ 
  {
#line 1086
  rcode = ascend_parse_ipx(argc - 3, & argv[3], & filter.u.ipx);
  }
#line 1087
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 1090
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 1096
  if (rcode == 0) {
    {
#line 1097
    pair->length = sizeof(filter);
#line 1098
    memcpy((void */* __restrict  */)(pair->data.filter), (void const   */* __restrict  */)(& filter),
           sizeof(filter));
    }
  }
#line 1101
  return (rcode);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction[2]  = {      "out",      "in"};
#line 1145 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
void print_abinary(VALUE_PAIR *vp , char *buffer , size_t len ) 
{ 
  size_t i ;
  char *p ;
  ascend_filter_t *filter ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  uint16_t tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  uint16_t tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  uint32_t tmp___13 ;
  int tmp___14 ;
  uint16_t tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  uint32_t tmp___18 ;
  int tmp___19 ;
  uint16_t tmp___20 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  int count ;
  uint16_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  uint16_t tmp___26 ;
  int tmp___27 ;
  uint16_t tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;

  {
#line 1154
  p = buffer;
#line 1159
  if (vp->length != sizeof(*filter)) {
    {
#line 1160
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"0x");
#line 1161
    p += 2;
#line 1162
    len -= 2UL;
#line 1163
    i = (size_t )0;
    }
    {
#line 1163
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1163
      if (! (i < vp->length)) {
#line 1163
        goto while_break;
      }
      {
#line 1164
      snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)"%02x",
               (int )vp->data.octets[i]);
#line 1165
      p += 2;
#line 1166
      len -= 2UL;
#line 1163
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1168
    return;
  }
  {
#line 1171
  tmp = p;
#line 1171
  p ++;
#line 1171
  *tmp = (char )'\"';
#line 1172
  len -= 3UL;
#line 1174
  filter = (ascend_filter_t *)(& vp->data.filter);
#line 1175
  tmp___0 = fr_int2str(filterType, (int )filter->type, "??");
#line 1175
  tmp___1 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)"%s %s %s",
                     tmp___0, direction[(int )filter->direction & 1], action[(int )filter->forward & 1]);
#line 1175
  i = (size_t )tmp___1;
#line 1180
  p += i;
#line 1181
  len -= i;
  }
#line 1186
  if ((int )filter->type == 1) {
#line 1188
    if (filter->u.ip.srcip) {
      {
#line 1189
      tmp___2 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" srcip %d.%d.%d.%d/%d",
                         (int )*((uint8_t *)(& filter->u.ip.srcip) + 0), (int )*((uint8_t *)(& filter->u.ip.srcip) + 1),
                         (int )*((uint8_t *)(& filter->u.ip.srcip) + 2), (int )*((uint8_t *)(& filter->u.ip.srcip) + 3),
                         (int )filter->u.ip.srcmask);
#line 1189
      i = (size_t )tmp___2;
#line 1195
      p += i;
#line 1196
      len -= i;
      }
    }
#line 1199
    if (filter->u.ip.dstip) {
      {
#line 1200
      tmp___3 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" dstip %d.%d.%d.%d/%d",
                         (int )*((uint8_t *)(& filter->u.ip.dstip) + 0), (int )*((uint8_t *)(& filter->u.ip.dstip) + 1),
                         (int )*((uint8_t *)(& filter->u.ip.dstip) + 2), (int )*((uint8_t *)(& filter->u.ip.dstip) + 3),
                         (int )filter->u.ip.dstmask);
#line 1200
      i = (size_t )tmp___3;
#line 1206
      p += i;
#line 1207
      len -= i;
      }
    }
    {
#line 1210
    tmp___4 = fr_int2str(filterProtoName, (int )filter->u.ip.proto, "??");
#line 1210
    tmp___5 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" %s",
                       tmp___4);
#line 1210
    i = (size_t )tmp___5;
#line 1212
    p += i;
#line 1213
    len -= i;
    }
#line 1215
    if ((int )filter->u.ip.srcPortComp > 0) {
      {
#line 1216
      tmp___6 = ntohs(filter->u.ip.srcport);
#line 1216
      tmp___7 = fr_int2str(filterCompare, (int )filter->u.ip.srcPortComp, "??");
#line 1216
      tmp___8 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" srcport %s %d",
                         tmp___7, (int )tmp___6);
#line 1216
      i = (size_t )tmp___8;
#line 1219
      p += i;
#line 1220
      len -= i;
      }
    }
#line 1223
    if ((int )filter->u.ip.dstPortComp > 0) {
      {
#line 1224
      tmp___9 = ntohs(filter->u.ip.dstport);
#line 1224
      tmp___10 = fr_int2str(filterCompare, (int )filter->u.ip.dstPortComp, "??");
#line 1224
      tmp___11 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" dstport %s %d",
                          tmp___10, (int )tmp___9);
#line 1224
      i = (size_t )tmp___11;
#line 1227
      p += i;
#line 1228
      len -= i;
      }
    }
#line 1231
    if (filter->u.ip.established) {
      {
#line 1232
      tmp___12 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" est");
#line 1232
      i = (size_t )tmp___12;
#line 1233
      p += i;
#line 1234
      len -= i;
      }
    }
  } else
#line 1240
  if ((int )filter->type == 2) {
#line 1242
    if (filter->u.ipx.src.net) {
      {
#line 1243
      tmp___13 = ntohl(filter->u.ipx.src.net);
#line 1243
      tmp___14 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" srcipxnet 0x%04x srcipxnode 0x%02x%02x%02x%02x%02x%02x",
                          tmp___13, (int )filter->u.ipx.src.node[0], (int )filter->u.ipx.src.node[1],
                          (int )filter->u.ipx.src.node[2], (int )filter->u.ipx.src.node[3],
                          (int )filter->u.ipx.src.node[4], (int )filter->u.ipx.src.node[5]);
#line 1243
      i = (size_t )tmp___14;
#line 1248
      p += i;
#line 1249
      len -= i;
      }
#line 1251
      if ((int )filter->u.ipx.srcSocComp > 0) {
        {
#line 1252
        tmp___15 = ntohs(filter->u.ipx.src.socket);
#line 1252
        tmp___16 = fr_int2str(filterCompare, (int )filter->u.ipx.srcSocComp, "??");
#line 1252
        tmp___17 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" srcipxsock %s 0x%04x",
                            tmp___16, (int )tmp___15);
#line 1252
        i = (size_t )tmp___17;
#line 1255
        p += i;
#line 1256
        len -= i;
        }
      }
    }
#line 1261
    if (filter->u.ipx.dst.net) {
      {
#line 1262
      tmp___18 = ntohl(filter->u.ipx.dst.net);
#line 1262
      tmp___19 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" dstipxnet 0x%04x dstipxnode 0x%02x%02x%02x%02x%02x%02x",
                          tmp___18, (int )filter->u.ipx.dst.node[0], (int )filter->u.ipx.dst.node[1],
                          (int )filter->u.ipx.dst.node[2], (int )filter->u.ipx.dst.node[3],
                          (int )filter->u.ipx.dst.node[4], (int )filter->u.ipx.dst.node[5]);
#line 1262
      i = (size_t )tmp___19;
#line 1267
      p += i;
#line 1268
      len -= i;
      }
#line 1270
      if ((int )filter->u.ipx.dstSocComp > 0) {
        {
#line 1271
        tmp___20 = ntohs(filter->u.ipx.dst.socket);
#line 1271
        tmp___21 = fr_int2str(filterCompare, (int )filter->u.ipx.dstSocComp, "??");
#line 1271
        tmp___22 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" dstipxsock %s 0x%04x",
                            tmp___21, (int )tmp___20);
#line 1271
        i = (size_t )tmp___22;
#line 1274
        p += i;
#line 1275
        len -= i;
        }
      }
    }
  } else
#line 1280
  if ((int )filter->type == 0) {
    {
#line 1283
    tmp___23 = ntohs(filter->u.generic.offset);
#line 1283
    tmp___24 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" %u ",
                        (unsigned int )tmp___23);
#line 1283
    i = (size_t )tmp___24;
#line 1284
    p += i;
#line 1285
    i -= len;
#line 1288
    count = 0;
    }
    {
#line 1288
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1288
      tmp___26 = ntohs(filter->u.generic.len);
      }
#line 1288
      if (! (count < (int )tmp___26)) {
#line 1288
        goto while_break___0;
      }
      {
#line 1289
      tmp___25 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)"%02x",
                          (int )filter->u.generic.mask[count]);
#line 1289
      i = (size_t )tmp___25;
#line 1290
      p += i;
#line 1291
      len -= i;
#line 1288
      count ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1294
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)" ");
#line 1295
    p ++;
#line 1296
    len --;
#line 1299
    count = 0;
    }
    {
#line 1299
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1299
      tmp___28 = ntohs(filter->u.generic.len);
      }
#line 1299
      if (! (count < (int )tmp___28)) {
#line 1299
        goto while_break___1;
      }
      {
#line 1300
      tmp___27 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)"%02x",
                          (int )filter->u.generic.value[count]);
#line 1300
      i = (size_t )tmp___27;
#line 1301
      p += i;
#line 1302
      len -= i;
#line 1299
      count ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1305
    if (filter->u.generic.compNeq) {
#line 1305
      tmp___29 = "!=";
    } else {
#line 1305
      tmp___29 = "==";
    }
    {
#line 1305
    tmp___30 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" %s",
                        tmp___29);
#line 1305
    i = (size_t )tmp___30;
#line 1306
    p += i;
#line 1307
    len -= i;
    }
#line 1309
    if ((int )filter->u.generic.more != 0) {
      {
#line 1310
      tmp___31 = snprintf((char */* __restrict  */)p, len, (char const   */* __restrict  */)" more");
#line 1310
      i = (size_t )tmp___31;
#line 1311
      p += i;
#line 1312
      len -= i;
      }
    }
  }
#line 1316
  tmp___32 = p;
#line 1316
  p ++;
#line 1316
  *tmp___32 = (char )'\"';
#line 1317
  *p = (char )'\000';
#line 1318
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___21[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 290 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
void fr_hmac_md5(uint8_t const   *text , int text_len , uint8_t const   *key , int key_len ,
                 unsigned char *digest ) ;
#line 301
int rad_send(RADIUS_PACKET *packet , RADIUS_PACKET const   *original , char const   *secret ) ;
#line 302
int rad_packet_ok(RADIUS_PACKET *packet , int flags ) ;
#line 303
RADIUS_PACKET *rad_recv(int fd , int flags ) ;
#line 304
ssize_t rad_recv_header(int sockfd , fr_ipaddr_t *src_ipaddr , int *src_port , int *code ) ;
#line 306
void rad_recv_discard(int sockfd ) ;
#line 307
int rad_verify(RADIUS_PACKET *packet , RADIUS_PACKET *original , char const   *secret ) ;
#line 309
int rad_decode(RADIUS_PACKET *packet , RADIUS_PACKET *original , char const   *secret ) ;
#line 310
int rad_encode(RADIUS_PACKET *packet , RADIUS_PACKET const   *original , char const   *secret ) ;
#line 312
int rad_sign(RADIUS_PACKET *packet , RADIUS_PACKET const   *original , char const   *secret ) ;
#line 315
int rad_digest_cmp(uint8_t const   *a , uint8_t const   *b , size_t length ) ;
#line 316
RADIUS_PACKET *rad_alloc(int newvector ) ;
#line 317
RADIUS_PACKET *rad_alloc_reply(RADIUS_PACKET *packet ) ;
#line 319
int rad_pwencode(char *passwd , size_t *pwlen , char const   *secret , uint8_t const   *vector ) ;
#line 321
int rad_pwdecode(char *passwd , size_t pwlen , char const   *secret , uint8_t const   *vector ) ;
#line 323
int rad_tunnel_pwencode(char *passwd , size_t *pwlen , char const   *secret , uint8_t const   *vector ) ;
#line 325
int rad_tunnel_pwdecode(uint8_t *passwd , size_t *pwlen , char const   *secret , uint8_t const   *vector ) ;
#line 327
int rad_chap_encode(RADIUS_PACKET *packet , uint8_t *output , int id , VALUE_PAIR *password ) ;
#line 329
VALUE_PAIR *rad_attr2vp(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                        char const   *secret , int attribute , int length , uint8_t const   *data ) ;
#line 332
int rad_vp2attr(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                char const   *secret , VALUE_PAIR const   *vp , uint8_t *start ) ;
#line 376
int fr_max_attributes ;
#line 378
char const   *fr_packet_codes[52] ;
#line 380
void rad_print_hex(RADIUS_PACKET *packet ) ;
#line 436
uint32_t fr_rand(void) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int fr_max_attributes  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
FILE *fr_log_fp  =    (FILE *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset  =    0U;
#line 71 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
char const   *fr_packet_codes[52]  = 
#line 71
  {      "",      "Access-Request",      "Access-Accept",      "Access-Reject", 
        "Accounting-Request",      "Accounting-Response",      "Accounting-Status",      "Password-Request", 
        "Password-Accept",      "Password-Reject",      "Accounting-Message",      "Access-Challenge", 
        "Status-Server",      "Status-Client",      "14",      "15", 
        "16",      "17",      "18",      "19", 
        "20",      "Resource-Free-Request",      "Resource-Free-Response",      "Resource-Query-Request", 
        "Resource-Query-Response",      "Alternate-Resource-Reclaim-Request",      "NAS-Reboot-Request",      "NAS-Reboot-Response", 
        "28",      "Next-Passcode",      "New-Pin",      "Terminate-Session", 
        "Password-Expired",      "Event-Request",      "Event-Response",      "35", 
        "36",      "37",      "38",      "39", 
        "Disconnect-Request",      "Disconnect-ACK",      "Disconnect-NAK",      "CoA-Request", 
        "CoA-ACK",      "CoA-NAK",      "46",      "47", 
        "48",      "49",      "IP-Address-Allocate",      "IP-Address-Release"};
#line 127 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
void ( /* format attribute */  fr_printf_log)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 131
  __builtin_va_start(ap, fmt);
  }
#line 132
  if (fr_debug_flag == 0) {
    {
#line 133
    __builtin_va_end(ap);
    }
#line 134
    return;
  } else
#line 132
  if (! fr_log_fp) {
    {
#line 133
    __builtin_va_end(ap);
    }
#line 134
    return;
  }
  {
#line 137
  vfprintf((FILE */* __restrict  */)fr_log_fp, (char const   */* __restrict  */)fmt,
           ap);
#line 138
  __builtin_va_end(ap);
  }
#line 140
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
void rad_print_hex(RADIUS_PACKET *packet ) 
{ 
  int i ;
  int total ;
  uint8_t const   *ptr ;
  int attrlen ;

  {
#line 147
  if (! packet->data) {
#line 147
    return;
  }
  {
#line 149
  printf((char const   */* __restrict  */)"  Code:\t\t%u\n", (int )*(packet->data + 0));
#line 150
  printf((char const   */* __restrict  */)"  Id:\t\t%u\n", (int )*(packet->data + 1));
#line 151
  printf((char const   */* __restrict  */)"  Length:\t%u\n", ((int )*(packet->data + 2) << 8) | (int )*(packet->data + 3));
#line 153
  printf((char const   */* __restrict  */)"  Vector:\t");
#line 154
  i = 4;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < 20)) {
#line 154
      goto while_break;
    }
    {
#line 155
    printf((char const   */* __restrict  */)"%02x", (int )*(packet->data + i));
#line 154
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  printf((char const   */* __restrict  */)"\n");
  }
#line 159
  if (packet->data_len > 20) {
    {
#line 162
    printf((char const   */* __restrict  */)"  Data:");
#line 164
    total = packet->data_len - 20;
#line 165
    ptr = (uint8_t const   *)(packet->data + 20);
    }
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 167
      if (! (total > 0)) {
#line 167
        goto while_break___0;
      }
      {
#line 170
      printf((char const   */* __restrict  */)"\t\t");
      }
#line 171
      if (total < 2) {
        {
#line 172
        printf((char const   */* __restrict  */)"%02x\n", (int const   )*ptr);
        }
#line 173
        goto while_break___0;
      }
#line 176
      if ((int const   )*(ptr + 1) > (int const   )total) {
#line 177
        i = 0;
        {
#line 177
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 177
          if (! (i < total)) {
#line 177
            goto while_break___1;
          }
          {
#line 178
          printf((char const   */* __restrict  */)"%02x ", (int const   )*(ptr + i));
#line 177
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 180
        goto while_break___0;
      }
      {
#line 183
      printf((char const   */* __restrict  */)"%02x  %02x  ", (int const   )*(ptr + 0),
             (int const   )*(ptr + 1));
#line 184
      attrlen = (int )((int const   )*(ptr + 1) - 2);
#line 185
      ptr += 2;
#line 186
      total -= 2;
#line 188
      i = 0;
      }
      {
#line 188
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 188
        if (! (i < attrlen)) {
#line 188
          goto while_break___2;
        }
#line 189
        if (i > 0) {
#line 189
          if ((i & 15) == 0) {
            {
#line 190
            printf((char const   */* __restrict  */)"\t\t\t");
            }
          }
        }
        {
#line 191
        printf((char const   */* __restrict  */)"%02x ", (int const   )*(ptr + i));
        }
#line 192
        if ((i & 15) == 15) {
          {
#line 192
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 188
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 195
      if ((attrlen & 15) != 0) {
        {
#line 195
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 197
      ptr += attrlen;
#line 198
      total -= attrlen;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 201
  fflush(stdout);
  }
#line 202
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto(int sockfd , void *data , size_t data_len , int flags , fr_ipaddr_t *src_ipaddr ,
                      int src_port , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
void rad_recv_discard(int sockfd ) 
{ 
  uint8_t header[4] ;
  struct sockaddr_storage src ;
  socklen_t sizeof_src ;

  {
  {
#line 265
  sizeof_src = (socklen_t )sizeof(src);
#line 267
  recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
           (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 269
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
ssize_t rad_recv_header(int sockfd , fr_ipaddr_t *src_ipaddr , int *src_port , int *code ) 
{ 
  ssize_t data_len ;
  ssize_t packet_len ;
  uint8_t header[4] ;
  struct sockaddr_storage src ;
  socklen_t sizeof_src ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 278
  sizeof_src = (socklen_t )sizeof(src);
#line 280
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 282
  if (data_len < 0L) {
    {
#line 283
    tmp = __errno_location();
    }
#line 283
    if (*tmp == 11) {
#line 283
      return ((ssize_t )0);
    } else {
      {
#line 283
      tmp___0 = __errno_location();
      }
#line 283
      if (*tmp___0 == 4) {
#line 283
        return ((ssize_t )0);
      }
    }
#line 284
    return ((ssize_t )-1);
  }
#line 290
  if (data_len < 4L) {
    {
#line 291
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 293
    return ((ssize_t )1);
  } else {
#line 299
    packet_len = (ssize_t )((int )header[2] * 256 + (int )header[3]);
#line 305
    if (packet_len < 20L) {
      {
#line 306
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 308
      return ((ssize_t )1);
    } else
#line 314
    if (packet_len > 4096L) {
      {
#line 315
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 317
      return ((ssize_t )1);
    }
  }
  {
#line 324
  tmp___1 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, src_port);
  }
#line 324
  if (! tmp___1) {
    {
#line 325
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 327
    return ((ssize_t )1);
  }
#line 330
  *code = (int )header[0];
#line 336
  return (packet_len);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                            uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                        uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                        size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                               size_t inlen , size_t room , char const   *secret ,
                               uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset;
#line 615
  salt_offset ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                        char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                        size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                  (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                  (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_vp2attr(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                char const   *secret , VALUE_PAIR const   *vp , uint8_t *start ) 
{ 
  int vendorcode ;
  int len ;
  int total_length ;
  uint32_t lvalue ;
  uint8_t *ptr ;
  uint8_t *length_ptr ;
  uint8_t *vsa_length_ptr ;
  uint8_t *tlv_length_ptr ;
  uint8_t *end ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  int vsa_tlen ;
  int vsa_llen ;
  int vsa_offset ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___1 ;
  uint8_t *tmp___2 ;
  uint8_t *tmp___3 ;
  int tmp___4 ;
  uint8_t *tmp___5 ;
  uint8_t *tmp___6 ;

  {
#line 964
  ptr = start;
#line 965
  end = ptr + 255;
#line 966
  total_length = 0;
#line 966
  vendorcode = total_length;
#line 967
  tlv_length_ptr = (uint8_t *)((void *)0);
#line 967
  vsa_length_ptr = tlv_length_ptr;
#line 967
  length_ptr = vsa_length_ptr;
#line 973
  vendorcode = (int )((vp->attribute >> 16) & 65535);
#line 973
  if (vendorcode == 0) {
#line 974
    tmp = ptr;
#line 974
    ptr ++;
#line 974
    *tmp = (uint8_t )(vp->attribute & 255);
#line 975
    length_ptr = ptr;
#line 976
    tmp___0 = ptr;
#line 976
    ptr ++;
#line 976
    *tmp___0 = (uint8_t )2;
#line 977
    total_length += 2;
  } else {
    {
#line 980
    vsa_tlen = 1;
#line 981
    vsa_llen = 1;
#line 982
    vsa_offset = 0;
#line 983
    tmp___1 = dict_vendorbyvalue(vendorcode);
#line 983
    dv = tmp___1;
    }
#line 991
    if (dv) {
#line 992
      vsa_tlen = dv->type;
#line 993
      vsa_llen = dv->length;
#line 994
      if (dv->flags) {
#line 994
        vsa_offset = 1;
      }
    }
    {
#line 1000
    tmp___2 = ptr;
#line 1000
    ptr ++;
#line 1000
    *tmp___2 = (uint8_t )26;
#line 1001
    vsa_length_ptr = ptr;
#line 1002
    tmp___3 = ptr;
#line 1002
    ptr ++;
#line 1002
    *tmp___3 = (uint8_t )6;
#line 1003
    lvalue = htonl((uint32_t )vendorcode);
#line 1004
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(& lvalue),
           (size_t )4);
#line 1005
    ptr += 4;
#line 1006
    total_length += 6;
    }
    {
#line 1009
    if (vsa_tlen == 1) {
#line 1009
      goto case_1;
    }
#line 1013
    if (vsa_tlen == 2) {
#line 1013
      goto case_2;
    }
#line 1018
    if (vsa_tlen == 4) {
#line 1018
      goto case_4;
    }
#line 1025
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1010
    *(ptr + 0) = (uint8_t )(vp->attribute & 255);
#line 1011
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1014
    *(ptr + 0) = (uint8_t )((vp->attribute >> 8) & 255);
#line 1015
    *(ptr + 1) = (uint8_t )(vp->attribute & 255);
#line 1016
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1019
    *(ptr + 0) = (uint8_t )0;
#line 1020
    *(ptr + 1) = (uint8_t )0;
#line 1021
    *(ptr + 2) = (uint8_t )((vp->attribute >> 8) & 255);
#line 1022
    *(ptr + 3) = (uint8_t )(vp->attribute & 255);
#line 1023
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1026
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1028
    ptr += vsa_tlen;
    {
#line 1031
    if (vsa_llen == 0) {
#line 1031
      goto case_0;
    }
#line 1035
    if (vsa_llen == 1) {
#line 1035
      goto case_1___0;
    }
#line 1039
    if (vsa_llen == 2) {
#line 1039
      goto case_2___0;
    }
#line 1045
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 1032
    length_ptr = vsa_length_ptr;
#line 1033
    vsa_length_ptr = (uint8_t *)((void *)0);
#line 1034
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 1036
    *(ptr + 0) = (uint8_t )0;
#line 1037
    length_ptr = ptr;
#line 1038
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1040
    *(ptr + 0) = (uint8_t )0;
#line 1041
    *(ptr + 1) = (uint8_t )0;
#line 1042
    length_ptr = ptr + 1;
#line 1043
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1046
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 1048
    ptr += vsa_llen;
#line 1053
    if (vsa_offset) {
#line 1060
      if (vp->length > (size_t const   )(254UL - (size_t )(ptr - start))) {
        {
#line 1061
        tmp___4 = rad_vp2continuation(vp, start, ptr);
        }
#line 1061
        return (tmp___4);
      }
#line 1064
      *(ptr + 0) = (uint8_t )0;
#line 1065
      ptr ++;
#line 1070
      if (vp->flags.is_tlv) {
#line 1071
        tmp___5 = ptr;
#line 1071
        ptr ++;
#line 1071
        *tmp___5 = (uint8_t )((vp->attribute & 65280) >> 8);
#line 1072
        tlv_length_ptr = ptr;
#line 1073
        tmp___6 = ptr;
#line 1073
        ptr ++;
#line 1073
        *tmp___6 = (uint8_t )2;
#line 1074
        vsa_offset += 2;
      }
    }
#line 1078
    total_length += (vsa_tlen + vsa_llen) + vsa_offset;
#line 1079
    if (vsa_length_ptr) {
#line 1079
      *vsa_length_ptr = (uint8_t )((int )*vsa_length_ptr + ((vsa_tlen + vsa_llen) + vsa_offset));
    }
#line 1080
    *length_ptr = (uint8_t )((int )*length_ptr + ((vsa_tlen + vsa_llen) + vsa_offset));
  }
#line 1087
  if (vp->flags.has_tag) {
#line 1087
    if (vp->type == 0) {
#line 1087
      if ((int const   )vp->flags.tag > 0) {
#line 1087
        if ((int const   )vp->flags.tag < 32) {
          {
#line 1090
          *(ptr + 0) = (uint8_t )vp->flags.tag;
#line 1091
          end = vp2data(packet, original, secret, vp, ptr + 1, (size_t )((end - ptr) - 1L));
          }
        } else {
#line 1087
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1087
      if ((int const   )vp->flags.encrypt == 2) {
        {
#line 1090
        *(ptr + 0) = (uint8_t )vp->flags.tag;
#line 1091
        end = vp2data(packet, original, secret, vp, ptr + 1, (size_t )((end - ptr) - 1L));
        }
      } else {
        {
#line 1094
        end = vp2data(packet, original, secret, vp, ptr, (size_t )(end - ptr));
        }
      }
    } else {
      {
#line 1094
      end = vp2data(packet, original, secret, vp, ptr, (size_t )(end - ptr));
      }
    }
  } else {
    {
#line 1094
    end = vp2data(packet, original, secret, vp, ptr, (size_t )(end - ptr));
    }
  }
#line 1097
  if (! end) {
#line 1097
    return (-1);
  }
#line 1103
  if (vp->flags.has_tag) {
#line 1103
    if (vp->type == 1) {
#line 1104
      *(ptr + 0) = (uint8_t )vp->flags.tag;
    }
  }
#line 1115
  if ((unsigned long )end == (unsigned long )ptr) {
#line 1115
    if (vp->attribute != 89) {
#line 1116
      return (0);
    }
  }
#line 1118
  len = (int )(end - ptr);
#line 1123
  *length_ptr = (uint8_t )((int )*length_ptr + len);
#line 1124
  if (vsa_length_ptr) {
#line 1124
    *vsa_length_ptr = (uint8_t )((int )*vsa_length_ptr + len);
  }
#line 1125
  if (tlv_length_ptr) {
#line 1125
    *tlv_length_ptr = (uint8_t )((int )*tlv_length_ptr + len);
  }
#line 1126
  ptr += len;
#line 1127
  total_length += len;
#line 1129
  return (total_length);
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_encode(RADIUS_PACKET *packet , RADIUS_PACKET const   *original , char const   *secret ) 
{ 
  radius_packet_t *hdr ;
  uint8_t *ptr ;
  uint16_t total_length ;
  int len ;
  VALUE_PAIR *reply ;
  char const   *what ;
  char ip_buffer[128] ;
  uint32_t data[1088] ;
  char const   *tmp ;
  VALUE_PAIR *tlv ;
  VALUE_PAIR *tmp___0 ;
  void *tmp___1 ;

  {
#line 1156
  if (packet->code > 0U) {
#line 1156
    if (packet->code < 52U) {
#line 1157
      what = fr_packet_codes[packet->code];
    } else {
#line 1159
      what = "Reply";
    }
  } else {
#line 1159
    what = "Reply";
  }
#line 1162
  if (fr_debug_flag) {
#line 1162
    if (fr_log_fp) {
      {
#line 1162
      tmp = inet_ntop(packet->dst_ipaddr.af, (void const   */* __restrict  */)(& packet->dst_ipaddr.ipaddr),
                      (char */* __restrict  */)(ip_buffer), (socklen_t )sizeof(ip_buffer));
#line 1162
      fr_printf_log("Sending %s of id %d to %s port %d\n", what, packet->id, tmp,
                    (int )packet->dst_port);
      }
    }
  }
  {
#line 1175
  if (packet->code == 11U) {
#line 1175
    goto case_11;
  }
#line 1175
  if (packet->code == 3U) {
#line 1175
    goto case_11;
  }
#line 1175
  if (packet->code == 2U) {
#line 1175
    goto case_11;
  }
#line 1187
  if (packet->code == 43U) {
#line 1187
    goto case_43;
  }
#line 1187
  if (packet->code == 40U) {
#line 1187
    goto case_43;
  }
#line 1187
  if (packet->code == 4U) {
#line 1187
    goto case_43;
  }
#line 1191
  goto switch_default;
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1176
  if (! original) {
    {
#line 1177
    fr_strerror_printf("ERROR: Cannot sign response packet without a request packet.");
    }
#line 1178
    return (-1);
  }
#line 1180
  goto switch_break;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1188
  memset((void *)(packet->vector), 0, sizeof(packet->vector));
  }
#line 1189
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1192
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1199
  hdr = (radius_packet_t *)(data);
#line 1204
  hdr->code = (uint8_t )packet->code;
#line 1205
  hdr->id = (uint8_t )packet->id;
#line 1207
  memcpy((void */* __restrict  */)(hdr->vector), (void const   */* __restrict  */)(packet->vector),
         sizeof(hdr->vector));
#line 1209
  total_length = (uint16_t )20;
#line 1214
  ptr = hdr->data;
#line 1215
  packet->offset = (ssize_t )0;
#line 1229
  reply = packet->vps;
  }
  {
#line 1229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1229
    if (! reply) {
#line 1229
      goto while_break;
    }
#line 1233
    if (((reply->attribute >> 16) & 65535) == 0) {
#line 1233
      if ((reply->attribute & 65535) > 255) {
#line 1246
        goto __Cont;
      }
    }
#line 1253
    if (reply->attribute == 80) {
      {
#line 1254
      reply->length = (size_t )16;
#line 1255
      memset((void *)(reply->data.strvalue), 0, (size_t )16);
#line 1261
      packet->offset = (ssize_t )total_length;
      }
    }
    {
#line 1269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1269
      if (fr_debug_flag) {
#line 1269
        if (fr_log_fp) {
          {
#line 1269
          vp_print(fr_log_fp, reply);
          }
        }
      }
#line 1269
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1275
    len = 0;
#line 1276
    if (reply->flags.encoded) {
#line 1276
      goto next;
    }
#line 1278
    if (reply->flags.is_tlv) {
      {
#line 1279
      tmp___0 = rad_vp2tlv(reply);
#line 1279
      tlv = tmp___0;
      }
#line 1280
      if (tlv) {
#line 1281
        tlv->next = reply->next;
#line 1282
        reply->next = tlv;
      }
#line 1288
      reply = reply->next;
    }
    {
#line 1291
    len = rad_vp2attr((RADIUS_PACKET const   *)packet, original, secret, (VALUE_PAIR const   *)reply,
                      ptr);
    }
#line 1293
    if (len < 0) {
#line 1293
      return (-1);
    }
#line 1303
    if ((int )total_length + len > 4096) {
#line 1304
      if (fr_debug_flag) {
#line 1304
        if (fr_log_fp) {
          {
#line 1304
          fr_printf_log("WARNING: Attributes are too long for packet.  Discarding data past %d bytes",
                        (int )total_length);
          }
        }
      }
#line 1305
      goto while_break;
    }
    next: 
#line 1309
    ptr += len;
#line 1310
    total_length = (uint16_t )((int )total_length + len);
    __Cont: /* CIL Label */ 
#line 1229
    reply = reply->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1321
  packet->data_len = (int )total_length;
#line 1322
  tmp___1 = malloc((size_t )packet->data_len);
#line 1322
  packet->data = (uint8_t *)tmp___1;
  }
#line 1323
  if (! packet->data) {
    {
#line 1324
    fr_strerror_printf("Out of memory");
    }
#line 1325
    return (-1);
  }
  {
#line 1328
  memcpy((void */* __restrict  */)packet->data, (void const   */* __restrict  */)hdr,
         (size_t )packet->data_len);
#line 1329
  hdr = (radius_packet_t *)packet->data;
#line 1331
  total_length = htons(total_length);
#line 1332
  memcpy((void */* __restrict  */)(hdr->length), (void const   */* __restrict  */)(& total_length),
         sizeof(total_length));
  }
#line 1334
  return (0);
}
}
#line 1341 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_sign(RADIUS_PACKET *packet , RADIUS_PACKET const   *original , char const   *secret ) 
{ 
  radius_packet_t *hdr ;
  uint8_t calc_auth_vector[16] ;
  size_t tmp ;
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp___0 ;

  {
#line 1344
  hdr = (radius_packet_t *)packet->data;
#line 1349
  if (packet->id < 0) {
    {
#line 1350
    fr_strerror_printf("ERROR: RADIUS packets must be assigned an Id.");
    }
#line 1351
    return (-1);
  }
#line 1354
  if (! packet->data) {
    {
#line 1356
    fr_strerror_printf("ERROR: You must call rad_encode() before rad_sign()");
    }
#line 1357
    return (-1);
  } else
#line 1354
  if (packet->data_len < 20) {
    {
#line 1356
    fr_strerror_printf("ERROR: You must call rad_encode() before rad_sign()");
    }
#line 1357
    return (-1);
  } else
#line 1354
  if (packet->offset < 0L) {
    {
#line 1356
    fr_strerror_printf("ERROR: You must call rad_encode() before rad_sign()");
    }
#line 1357
    return (-1);
  }
#line 1364
  if (packet->offset > 0L) {
    {
#line 1368
    if (packet->code == 5U) {
#line 1368
      goto case_5;
    }
#line 1379
    if (packet->code == 45U) {
#line 1379
      goto case_45;
    }
#line 1379
    if (packet->code == 44U) {
#line 1379
      goto case_45;
    }
#line 1379
    if (packet->code == 43U) {
#line 1379
      goto case_45;
    }
#line 1379
    if (packet->code == 42U) {
#line 1379
      goto case_45;
    }
#line 1379
    if (packet->code == 41U) {
#line 1379
      goto case_45;
    }
#line 1379
    if (packet->code == 40U) {
#line 1379
      goto case_45;
    }
#line 1379
    if (packet->code == 4U) {
#line 1379
      goto case_45;
    }
#line 1386
    if (packet->code == 11U) {
#line 1386
      goto do_ack;
    }
#line 1386
    if (packet->code == 3U) {
#line 1386
      goto do_ack;
    }
#line 1386
    if (packet->code == 2U) {
#line 1386
      goto do_ack;
    }
#line 1395
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1369
    if (original) {
#line 1369
      if (original->code == 12U) {
#line 1370
        goto do_ack;
      }
    }
    case_45: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 1380
    memset((void *)(hdr->vector), 0, (size_t )16);
    }
#line 1381
    goto switch_break;
    do_ack: 
    case_11: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1387
    if (! original) {
      {
#line 1388
      fr_strerror_printf("ERROR: Cannot sign response packet without a request packet.");
      }
#line 1389
      return (-1);
    }
    {
#line 1391
    memcpy((void */* __restrict  */)(hdr->vector), (void const   */* __restrict  */)(original->vector),
           (size_t )16);
    }
#line 1393
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1396
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1406
    tmp = strlen(secret);
#line 1406
    fr_hmac_md5((uint8_t const   *)packet->data, packet->data_len, (uint8_t const   *)secret,
                (int )tmp, calc_auth_vector);
#line 1409
    memcpy((void */* __restrict  */)((packet->data + packet->offset) + 2), (void const   */* __restrict  */)(calc_auth_vector),
           (size_t )16);
#line 1416
    memcpy((void */* __restrict  */)(hdr->vector), (void const   */* __restrict  */)(packet->vector),
           (size_t )16);
    }
  }
  {
#line 1429
  if (packet->code == 12U) {
#line 1429
    goto case_12;
  }
#line 1429
  if (packet->code == 1U) {
#line 1429
    goto case_12;
  }
#line 1436
  goto switch_default___0;
  case_12: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1430
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1441
  fr_MD5Init(& context);
#line 1442
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1443
  tmp___0 = strlen(secret);
#line 1443
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___0);
#line 1445
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1447
  memcpy((void */* __restrict  */)(hdr->vector), (void const   */* __restrict  */)(digest),
         (size_t )16);
#line 1448
  memcpy((void */* __restrict  */)(packet->vector), (void const   */* __restrict  */)(digest),
         (size_t )16);
  }
#line 1449
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1453
  return (0);
}
}
#line 1460 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_send(RADIUS_PACKET *packet , RADIUS_PACKET const   *original , char const   *secret ) 
{ 
  VALUE_PAIR *reply ;
  char const   *what ;
  char ip_buffer[128] ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1470
  if (! packet) {
#line 1471
    return (0);
  } else
#line 1470
  if (packet->sockfd < 0) {
#line 1471
    return (0);
  }
#line 1474
  if (packet->code > 0U) {
#line 1474
    if (packet->code < 52U) {
#line 1475
      what = fr_packet_codes[packet->code];
    } else {
#line 1477
      what = "Reply";
    }
  } else {
#line 1477
    what = "Reply";
  }
#line 1483
  if (! packet->data) {
    {
#line 1487
    tmp = rad_encode(packet, original, secret);
    }
#line 1487
    if (tmp < 0) {
#line 1488
      return (-1);
    }
    {
#line 1495
    tmp___0 = rad_sign(packet, original, secret);
    }
#line 1495
    if (tmp___0 < 0) {
#line 1496
      return (-1);
    }
  } else
#line 1503
  if (fr_debug_flag) {
#line 1504
    if (fr_debug_flag) {
#line 1504
      if (fr_log_fp) {
        {
#line 1504
        tmp___1 = inet_ntop(packet->dst_ipaddr.af, (void const   */* __restrict  */)(& packet->dst_ipaddr.ipaddr),
                            (char */* __restrict  */)(ip_buffer), (socklen_t )sizeof(ip_buffer));
#line 1504
        fr_printf_log("Sending %s of id %d to %s port %d\n", what, packet->id, tmp___1,
                      (int )packet->dst_port);
        }
      }
    }
#line 1510
    reply = packet->vps;
    {
#line 1510
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1510
      if (! reply) {
#line 1510
        goto while_break;
      }
#line 1511
      if (((reply->attribute >> 16) & 65535) == 0) {
#line 1511
        if ((reply->attribute & 65535) > 255) {
#line 1512
          goto __Cont;
        }
      }
      {
#line 1513
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1513
        if (fr_debug_flag) {
#line 1513
          if (fr_log_fp) {
            {
#line 1513
            vp_print(fr_log_fp, reply);
            }
          }
        }
#line 1513
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 1510
      reply = reply->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1520
  tmp___2 = rad_sendto(packet->sockfd, (void *)packet->data, (size_t )packet->data_len,
                       0, & packet->src_ipaddr, (int )packet->src_port, & packet->dst_ipaddr,
                       (int )packet->dst_port);
  }
#line 1520
  return (tmp___2);
}
}
#line 1533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_digest_cmp(uint8_t const   *a , uint8_t const   *b , size_t length ) 
{ 
  int result ;
  size_t i ;

  {
#line 1535
  result = 0;
#line 1538
  i = (size_t )0;
  {
#line 1538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1538
    if (! (i < length)) {
#line 1538
      goto while_break;
    }
#line 1539
    result |= (int )((int const   )*(a + i) ^ (int const   )*(b + i));
#line 1538
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1542
  return (result);
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest(RADIUS_PACKET *packet , RADIUS_PACKET *original , char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 1628 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_packet_ok(RADIUS_PACKET *packet , int flags ) 
{ 
  uint8_t *attr ;
  int totallen ;
  int count ;
  radius_packet_t *hdr ;
  char host_ipaddr[128] ;
  int require_ma ;
  int seen_ma ;
  int num_attributes ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 1635
  require_ma = 0;
#line 1636
  seen_ma = 0;
#line 1646
  if (packet->data_len < 20) {
    {
#line 1647
    tmp = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                    (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1647
    fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: too short (received %d < minimum %d)",
                       tmp, packet->data_len, 20);
    }
#line 1652
    return (0);
  }
#line 1660
  if (packet->data_len > 4096) {
    {
#line 1661
    tmp___0 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1661
    fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: too long (received %d > maximum %d)",
                       tmp___0, packet->data_len, 4096);
    }
#line 1666
    return (0);
  }
#line 1674
  totallen = ((int )*(packet->data + 2) << 8) | (int )*(packet->data + 3);
#line 1675
  hdr = (radius_packet_t *)packet->data;
#line 1681
  if ((int )hdr->code == 0) {
    {
#line 1683
    tmp___1 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1683
    fr_strerror_printf("WARNING: Bad RADIUS packet from host %s: unknown packet code%d ",
                       tmp___1, (int )hdr->code);
    }
#line 1688
    return (0);
  } else
#line 1681
  if ((int )hdr->code >= 52) {
    {
#line 1683
    tmp___1 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1683
    fr_strerror_printf("WARNING: Bad RADIUS packet from host %s: unknown packet code%d ",
                       tmp___1, (int )hdr->code);
    }
#line 1688
    return (0);
  }
#line 1695
  if ((int )hdr->code == 12) {
#line 1695
    require_ma = 1;
  }
#line 1700
  if (flags) {
#line 1700
    require_ma = 1;
  }
#line 1713
  if (totallen < 20) {
    {
#line 1714
    tmp___2 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1714
    fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: too short (length %d < minimum %d)",
                       tmp___2, totallen, 20);
    }
#line 1719
    return (0);
  }
#line 1729
  if (totallen > 4096) {
    {
#line 1730
    tmp___3 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1730
    fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: too long (length %d > maximum %d)",
                       tmp___3, totallen, 4096);
    }
#line 1735
    return (0);
  }
#line 1746
  if (packet->data_len < totallen) {
    {
#line 1747
    tmp___4 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1747
    fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: received %d octets, packet length says %d",
                       tmp___4, packet->data_len, totallen);
    }
#line 1752
    return (0);
  }
#line 1761
  if (packet->data_len > totallen) {
    {
#line 1766
    memset((void *)(packet->data + totallen), 0, (size_t )(packet->data_len - totallen));
#line 1767
    packet->data_len = totallen;
    }
  }
#line 1782
  attr = hdr->data;
#line 1783
  count = totallen - 20;
#line 1784
  num_attributes = 0;
  {
#line 1786
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1786
    if (! (count > 0)) {
#line 1786
      goto while_break;
    }
#line 1791
    if (count < 2) {
      {
#line 1792
      tmp___5 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                          (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1792
      fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: attribute header overflows the packet",
                         tmp___5);
      }
#line 1796
      return (0);
    }
#line 1802
    if ((int )*(attr + 0) == 0) {
      {
#line 1803
      tmp___6 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                          (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1803
      fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: Invalid attribute 0",
                         tmp___6);
      }
#line 1807
      return (0);
    }
#line 1814
    if ((int )*(attr + 1) < 2) {
      {
#line 1815
      tmp___7 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                          (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1815
      fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: attribute %u too short",
                         tmp___7, (int )*(attr + 0));
      }
#line 1820
      return (0);
    }
#line 1827
    if (count < (int )*(attr + 1)) {
      {
#line 1828
      tmp___8 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                          (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1828
      fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: attribute %u data overflows the packet",
                         tmp___8, (int )*(attr + 0));
      }
#line 1833
      return (0);
    }
    {
#line 1847
    if ((int )*(attr + 0) == 79) {
#line 1847
      goto case_79;
    }
#line 1851
    if ((int )*(attr + 0) == 80) {
#line 1851
      goto case_80;
    }
#line 1840
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 1841
    goto switch_break;
    case_79: /* CIL Label */ 
#line 1848
    require_ma = 1;
#line 1849
    goto switch_break;
    case_80: /* CIL Label */ 
#line 1852
    if ((int )*(attr + 1) != 18) {
      {
#line 1853
      tmp___9 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                          (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1853
      fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: Message-Authenticator has invalid length %d",
                         tmp___9, (int )*(attr + 1) - 2);
      }
#line 1858
      return (0);
    }
#line 1860
    seen_ma = 1;
#line 1861
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1870
    count -= (int )*(attr + 1);
#line 1871
    attr += (int )*(attr + 1);
#line 1872
    num_attributes ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1880
  if (count != 0) {
    {
#line 1881
    tmp___10 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                         (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1881
    fr_strerror_printf("WARNING: Malformed RADIUS packet from host %s: packet attributes do NOT exactly fill the packet",
                       tmp___10);
    }
#line 1885
    return (0);
  }
#line 1893
  if (fr_max_attributes > 0) {
#line 1893
    if (num_attributes > fr_max_attributes) {
      {
#line 1895
      tmp___11 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                           (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1895
      fr_strerror_printf("WARNING: Possible DoS attack from host %s: Too many attributes in request (received %d, max %d are allowed).",
                         tmp___11, num_attributes, fr_max_attributes);
      }
#line 1900
      return (0);
    }
  }
#line 1914
  if (require_ma) {
#line 1914
    if (! seen_ma) {
      {
#line 1915
      tmp___12 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                           (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 1915
      fr_strerror_printf("WARNING: Insecure packet from host %s:  Packet does not contain required Message-Authenticator attribute",
                         tmp___12);
      }
#line 1919
      return (0);
    }
  }
  {
#line 1925
  packet->code = (unsigned int )hdr->code;
#line 1926
  packet->id = (int )hdr->id;
#line 1927
  memcpy((void */* __restrict  */)(packet->vector), (void const   */* __restrict  */)(hdr->vector),
         (size_t )16);
  }
#line 1929
  return (1);
}
}
#line 1937 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
RADIUS_PACKET *rad_recv(int fd , int flags ) 
{ 
  int sock_flags ;
  RADIUS_PACKET *packet ;
  void *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char host_ipaddr[128] ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 1939
  sock_flags = 0;
#line 1945
  tmp = malloc(sizeof(*packet));
#line 1945
  packet = (RADIUS_PACKET *)tmp;
  }
#line 1945
  if ((unsigned long )packet == (unsigned long )((void *)0)) {
    {
#line 1946
    fr_strerror_printf("out of memory");
    }
#line 1947
    return ((RADIUS_PACKET *)((void *)0));
  }
  {
#line 1949
  memset((void *)packet, 0, sizeof(*packet));
  }
#line 1951
  if (flags & 2) {
#line 1952
    sock_flags = 2;
#line 1953
    flags &= -3;
  }
  {
#line 1956
  tmp___0 = rad_recvfrom(fd, & packet->data, sock_flags, & packet->src_ipaddr, & packet->src_port,
                         & packet->dst_ipaddr, & packet->dst_port);
#line 1956
  packet->data_len = (int )tmp___0;
  }
#line 1963
  if (packet->data_len < 0) {
    {
#line 1964
    tmp___1 = __errno_location();
#line 1964
    tmp___2 = strerror(*tmp___1);
#line 1964
    fr_strerror_printf("Error receiving packet: %s", tmp___2);
#line 1966
    free((void *)packet);
    }
#line 1967
    return ((RADIUS_PACKET *)((void *)0));
  }
#line 1975
  if (packet->data_len > 4096) {
    {
#line 1976
    fr_strerror_printf("Discarding packet: Larger than RFC limitation of 4096 bytes.");
#line 1978
    free((void *)packet);
    }
#line 1979
    return ((RADIUS_PACKET *)((void *)0));
  }
#line 1988
  if (packet->data_len == 0) {
    {
#line 1989
    fr_strerror_printf("Empty packet: Socket is not ready.");
#line 1990
    free((void *)packet);
    }
#line 1991
    return ((RADIUS_PACKET *)((void *)0));
  } else
#line 1988
  if (! packet->data) {
    {
#line 1989
    fr_strerror_printf("Empty packet: Socket is not ready.");
#line 1990
    free((void *)packet);
    }
#line 1991
    return ((RADIUS_PACKET *)((void *)0));
  }
  {
#line 1997
  tmp___3 = rad_packet_ok(packet, flags);
  }
#line 1997
  if (! tmp___3) {
    {
#line 1998
    rad_free(& packet);
    }
#line 1999
    return ((RADIUS_PACKET *)((void *)0));
  }
#line 2005
  packet->sockfd = fd;
#line 2016
  packet->vps = (VALUE_PAIR *)((void *)0);
#line 2018
  if (fr_debug_flag) {
#line 2021
    if (packet->code > 0U) {
#line 2021
      if (packet->code < 52U) {
#line 2022
        if (fr_debug_flag) {
#line 2022
          if (fr_log_fp) {
            {
#line 2022
            tmp___4 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                                (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 2022
            fr_printf_log("rad_recv: %s packet from host %s port %d", fr_packet_codes[packet->code],
                          tmp___4, (int )packet->src_port);
            }
          }
        }
      } else {
#line 2021
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2029
    if (fr_debug_flag) {
#line 2029
      if (fr_log_fp) {
        {
#line 2029
        tmp___5 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                            (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 2029
        fr_printf_log("rad_recv: Packet from host %s port %d code=%d", tmp___5, (int )packet->src_port,
                      packet->code);
        }
      }
    }
#line 2036
    if (fr_debug_flag) {
#line 2036
      if (fr_log_fp) {
        {
#line 2036
        fr_printf_log(", id=%d, length=%d\n", packet->id, packet->data_len);
        }
      }
    }
  }
#line 2039
  return (packet);
}
}
#line 2046 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_verify(RADIUS_PACKET *packet , RADIUS_PACKET *original , char const   *secret ) 
{ 
  uint8_t *ptr ;
  int length ;
  int attrlen ;
  uint8_t msg_auth_vector[16] ;
  uint8_t calc_auth_vector[16] ;
  size_t tmp ;
  char buffer[32] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char buffer___0[32] ;
  char const   *tmp___2 ;
  int rcode ;
  char buffer___1[32] ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 2053
  if (! packet) {
#line 2053
    return (-1);
  } else
#line 2053
  if (! packet->data) {
#line 2053
    return (-1);
  }
#line 2059
  ptr = packet->data + 20;
#line 2060
  length = packet->data_len - 20;
  {
#line 2061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2061
    if (! (length > 0)) {
#line 2061
      goto while_break;
    }
#line 2065
    attrlen = (int )*(ptr + 1);
    {
#line 2075
    if ((int )*(ptr + 0) == 80) {
#line 2075
      goto case_80;
    }
#line 2068
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 2069
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 2076
    memcpy((void */* __restrict  */)(msg_auth_vector), (void const   */* __restrict  */)(ptr + 2),
           sizeof(msg_auth_vector));
#line 2077
    memset((void *)(ptr + 2), 0, (size_t )16);
    }
    {
#line 2083
    if (packet->code == 5U) {
#line 2083
      goto case_5;
    }
#line 2095
    if (packet->code == 45U) {
#line 2095
      goto case_45;
    }
#line 2095
    if (packet->code == 44U) {
#line 2095
      goto case_45;
    }
#line 2095
    if (packet->code == 43U) {
#line 2095
      goto case_45;
    }
#line 2095
    if (packet->code == 42U) {
#line 2095
      goto case_45;
    }
#line 2095
    if (packet->code == 41U) {
#line 2095
      goto case_45;
    }
#line 2095
    if (packet->code == 40U) {
#line 2095
      goto case_45;
    }
#line 2095
    if (packet->code == 4U) {
#line 2095
      goto case_45;
    }
#line 2102
    if (packet->code == 11U) {
#line 2102
      goto do_ack;
    }
#line 2102
    if (packet->code == 3U) {
#line 2102
      goto do_ack;
    }
#line 2102
    if (packet->code == 2U) {
#line 2102
      goto do_ack;
    }
#line 2080
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
#line 2081
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 2084
    if (original) {
#line 2084
      if (original->code == 12U) {
#line 2086
        goto do_ack;
      }
    }
    case_45: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 2096
    memset((void *)(packet->data + 4), 0, (size_t )16);
    }
#line 2097
    goto switch_break___0;
    do_ack: 
    case_11: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 2103
    if (! original) {
      {
#line 2104
      fr_strerror_printf("ERROR: Cannot validate Message-Authenticator in response packet without a request packet.");
      }
#line 2105
      return (-1);
    }
    {
#line 2107
    memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
           (size_t )16);
    }
#line 2108
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 2111
    tmp = strlen(secret);
#line 2111
    fr_hmac_md5((uint8_t const   *)packet->data, packet->data_len, (uint8_t const   *)secret,
                (int )tmp, calc_auth_vector);
#line 2114
    tmp___1 = rad_digest_cmp((uint8_t const   *)(calc_auth_vector), (uint8_t const   *)(msg_auth_vector),
                             sizeof(calc_auth_vector));
    }
#line 2114
    if (tmp___1 != 0) {
      {
#line 2117
      tmp___0 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                          (char */* __restrict  */)(buffer), (socklen_t )sizeof(buffer));
#line 2117
      fr_strerror_printf("Received packet from %s with invalid Message-Authenticator!  (Shared secret is incorrect.)",
                         tmp___0);
      }
#line 2122
      return (-1);
    }
    {
#line 2128
    memcpy((void */* __restrict  */)(ptr + 2), (void const   */* __restrict  */)(msg_auth_vector),
           (size_t )16);
#line 2129
    memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
           (size_t )16);
    }
#line 2130
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2133
    ptr += attrlen;
#line 2134
    length -= attrlen;
  }
  while_break: /* CIL Label */ ;
  }
#line 2141
  if (packet->code == 0U) {
    {
#line 2143
    tmp___2 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(buffer___0), (socklen_t )sizeof(buffer___0));
#line 2143
    fr_strerror_printf("Received Unknown packet code %d from client %s port %d: Cannot validate signature.",
                       packet->code, tmp___2, (int )packet->src_port);
    }
#line 2150
    return (-1);
  } else
#line 2141
  if (packet->code >= 52U) {
    {
#line 2143
    tmp___2 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(buffer___0), (socklen_t )sizeof(buffer___0));
#line 2143
    fr_strerror_printf("Received Unknown packet code %d from client %s port %d: Cannot validate signature.",
                       packet->code, tmp___2, (int )packet->src_port);
    }
#line 2150
    return (-1);
  }
  {
#line 2161
  if (packet->code == 12U) {
#line 2161
    goto case_12;
  }
#line 2161
  if (packet->code == 1U) {
#line 2161
    goto case_12;
  }
#line 2170
  if (packet->code == 4U) {
#line 2170
    goto case_4___0;
  }
#line 2170
  if (packet->code == 40U) {
#line 2170
    goto case_4___0;
  }
#line 2170
  if (packet->code == 43U) {
#line 2170
    goto case_4___0;
  }
#line 2190
  if (packet->code == 45U) {
#line 2190
    goto case_45___0;
  }
#line 2190
  if (packet->code == 44U) {
#line 2190
    goto case_45___0;
  }
#line 2190
  if (packet->code == 42U) {
#line 2190
    goto case_45___0;
  }
#line 2190
  if (packet->code == 41U) {
#line 2190
    goto case_45___0;
  }
#line 2190
  if (packet->code == 5U) {
#line 2190
    goto case_45___0;
  }
#line 2190
  if (packet->code == 11U) {
#line 2190
    goto case_45___0;
  }
#line 2190
  if (packet->code == 3U) {
#line 2190
    goto case_45___0;
  }
#line 2190
  if (packet->code == 2U) {
#line 2190
    goto case_45___0;
  }
#line 2204
  goto switch_default___1;
  case_12: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 2166
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
  case_40___0: /* CIL Label */ 
  case_43___0: /* CIL Label */ 
  {
#line 2171
  tmp___4 = calc_acctdigest(packet, secret);
  }
#line 2171
  if (tmp___4 > 1) {
    {
#line 2172
    tmp___3 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(buffer___1), (socklen_t )sizeof(buffer___1));
#line 2172
    fr_strerror_printf("Received %s packet from client %s with invalid signature!  (Shared secret is incorrect.)",
                       fr_packet_codes[packet->code], tmp___3);
    }
#line 2178
    return (-1);
  }
#line 2180
  goto switch_break___1;
  case_45___0: /* CIL Label */ 
  case_44___0: /* CIL Label */ 
  case_42___0: /* CIL Label */ 
  case_41___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
  case_11___0: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  {
#line 2191
  rcode = calc_replydigest(packet, original, secret);
  }
#line 2192
  if (rcode > 1) {
    {
#line 2193
    tmp___5 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                        (char */* __restrict  */)(buffer___1), (socklen_t )sizeof(buffer___1));
#line 2193
    fr_strerror_printf("Received %s packet from home server %s port %d with invalid signature!  (Shared secret is incorrect.)",
                       fr_packet_codes[packet->code], tmp___5, (int )packet->src_port);
    }
#line 2200
    return (-1);
  }
#line 2202
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
  {
#line 2205
  tmp___6 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                      (char */* __restrict  */)(buffer___1), (socklen_t )sizeof(buffer___1));
#line 2205
  fr_strerror_printf("Received Unknown packet code %d from client %s port %d: Cannot validate signature",
                     packet->code, tmp___6, (int )packet->src_port);
  }
#line 2212
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
#line 2215
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                           char const   *secret , unsigned int attribute , size_t length ,
                           uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce(unsigned int attribute , size_t length , uint8_t *data ,
                             size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                       char const   *secret , int attribute , int length ,
                                       uint8_t *data , size_t packet_length , int flag ,
                                       DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce((unsigned int )attribute, (size_t )length, data, packet_length,
                            & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                 (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 2723 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
VALUE_PAIR *rad_attr2vp(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                        char const   *secret , int attribute , int length , uint8_t const   *data ) 
{ 
  VALUE_PAIR *vp ;
  VALUE_PAIR *tmp ;

  {
  {
#line 2729
  vp = paircreate(attribute, 5);
  }
#line 2730
  if (! vp) {
#line 2730
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2732
  tmp = data2vp(packet, original, secret, (unsigned int )attribute, (size_t )length,
                data, vp);
  }
#line 2732
  return (tmp);
}
}
#line 2742 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_decode(RADIUS_PACKET *packet , RADIUS_PACKET *original , char const   *secret ) 
{ 
  uint32_t lvalue ;
  uint32_t vendorcode ;
  VALUE_PAIR **tail ;
  VALUE_PAIR *pair ;
  uint8_t *ptr ;
  uint8_t *vsa_ptr ;
  int packet_length ;
  int attribute ;
  int attrlen ;
  int vendorlen ;
  radius_packet_t *hdr ;
  int vsa_tlen ;
  int vsa_llen ;
  int vsa_offset ;
  DICT_VENDOR *dv ;
  int num_attributes ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *subptr ;
  int sublen ;
  int myvendor ;
  uint32_t tmp___1 ;
  int myattr ;
  DICT_ATTR *da ;
  char host_ipaddr[128] ;
  char const   *tmp___2 ;

  {
#line 2756
  dv = (DICT_VENDOR *)((void *)0);
#line 2757
  num_attributes = 0;
#line 2762
  hdr = (radius_packet_t *)packet->data;
#line 2763
  ptr = hdr->data;
#line 2764
  packet_length = packet->data_len - 20;
#line 2770
  tail = & packet->vps;
  {
#line 2770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2770
    if (! ((unsigned long )*tail != (unsigned long )((void *)0))) {
#line 2770
      goto while_break;
    }
#line 2770
    tail = & (*tail)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2774
  vendorcode = (uint32_t )0;
#line 2775
  vendorlen = 0;
#line 2776
  vsa_llen = 1;
#line 2776
  vsa_tlen = vsa_llen;
#line 2777
  vsa_offset = 0;
  {
#line 2784
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2784
    if (! (packet_length > 0)) {
#line 2784
      goto while_break___0;
    }
#line 2785
    attribute = -1;
#line 2786
    attrlen = -1;
#line 2791
    if (vendorcode == 0U) {
#line 2798
      if (packet_length < 2) {
#line 2800
        goto while_break___0;
      } else
#line 2798
      if ((int )*(ptr + 0) == 0) {
#line 2800
        goto while_break___0;
      } else
#line 2798
      if ((int )*(ptr + 1) < 2) {
#line 2800
        goto while_break___0;
      } else
#line 2798
      if ((int )*(ptr + 1) > packet_length) {
#line 2800
        goto while_break___0;
      }
#line 2802
      tmp = ptr;
#line 2802
      ptr ++;
#line 2802
      attribute = (int )*tmp;
#line 2803
      tmp___0 = ptr;
#line 2803
      ptr ++;
#line 2803
      attrlen = (int )*tmp___0;
#line 2805
      attrlen -= 2;
#line 2806
      packet_length -= 2;
#line 2808
      if (attribute != 26) {
#line 2808
        goto create_pair;
      }
#line 2813
      if (attrlen <= 4) {
#line 2813
        goto create_pair;
      }
#line 2815
      vendorlen = 0;
    }
#line 2821
    if (vendorlen == 0) {
      {
#line 2829
      memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)ptr,
             (size_t )4);
#line 2830
      tmp___1 = ntohl(lvalue);
#line 2830
      myvendor = (int )tmp___1;
      }
#line 2835
      if (myvendor == 0) {
#line 2835
        goto create_pair;
      }
#line 2844
      if (myvendor > 65535) {
#line 2844
        goto create_pair;
      }
      {
#line 2846
      vsa_llen = 1;
#line 2846
      vsa_tlen = vsa_llen;
#line 2847
      vsa_offset = 0;
#line 2848
      dv = dict_vendorbyvalue(myvendor);
      }
#line 2849
      if (dv) {
#line 2850
        vsa_tlen = dv->type;
#line 2851
        vsa_llen = dv->length;
#line 2852
        if (dv->flags) {
#line 2852
          vsa_offset = 1;
        }
      }
#line 2862
      subptr = ptr + 4;
#line 2863
      sublen = attrlen - 4;
      {
#line 2868
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2869
        myattr = 0;
#line 2875
        if (sublen < (vsa_tlen + vsa_llen) + vsa_offset) {
#line 2875
          goto create_pair;
        }
        {
#line 2882
        if (vsa_tlen == 1) {
#line 2882
          goto case_1;
        }
#line 2886
        if (vsa_tlen == 2) {
#line 2886
          goto case_2;
        }
#line 2890
        if (vsa_tlen == 4) {
#line 2890
          goto case_4;
        }
#line 2900
        goto switch_default;
        case_1: /* CIL Label */ 
#line 2883
        myattr = (int )*(subptr + 0);
#line 2884
        goto switch_break;
        case_2: /* CIL Label */ 
#line 2887
        myattr = ((int )*(subptr + 0) << 8) | (int )*(subptr + 1);
#line 2888
        goto switch_break;
        case_4: /* CIL Label */ 
#line 2891
        if ((int )*(subptr + 0) != 0) {
#line 2892
          goto create_pair;
        } else
#line 2891
        if ((int )*(subptr + 1) != 0) {
#line 2892
          goto create_pair;
        }
#line 2894
        myattr = ((int )*(subptr + 2) << 8) | (int )*(subptr + 3);
#line 2895
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2901
        goto create_pair;
        switch_break: /* CIL Label */ ;
        }
        {
#line 2905
        if (vsa_llen == 0) {
#line 2905
          goto case_0;
        }
#line 2912
        if (vsa_llen == 1) {
#line 2912
          goto case_1___0;
        }
#line 2932
        if (vsa_llen == 2) {
#line 2932
          goto case_2___0;
        }
#line 2946
        goto switch_default___0;
        case_0: /* CIL Label */ 
#line 2906
        attribute = (myvendor << 16) | myattr;
#line 2907
        ptr += 4 + vsa_tlen;
#line 2908
        attrlen -= 4 + vsa_tlen;
#line 2909
        packet_length -= 4 + vsa_tlen;
#line 2910
        goto create_pair;
        case_1___0: /* CIL Label */ 
#line 2913
        if ((int )*(subptr + vsa_tlen) < (vsa_tlen + vsa_llen) + vsa_offset) {
#line 2914
          goto create_pair;
        }
#line 2916
        if ((int )*(subptr + vsa_tlen) > sublen) {
#line 2917
          goto create_pair;
        }
#line 2924
        if (vsa_offset) {
#line 2924
          if (((int )*(subptr + (vsa_tlen + vsa_llen)) & 127) != 0) {
#line 2926
            goto create_pair;
          }
        }
#line 2928
        sublen -= (int )*(subptr + vsa_tlen);
#line 2929
        subptr += (int )*(subptr + vsa_tlen);
#line 2930
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
#line 2933
        if ((int )*(subptr + vsa_tlen) != 0) {
#line 2933
          goto create_pair;
        }
#line 2934
        if ((int )*(subptr + (vsa_tlen + 1)) < vsa_tlen + vsa_llen) {
#line 2935
          goto create_pair;
        }
#line 2936
        if ((int )*(subptr + (vsa_tlen + 1)) > sublen) {
#line 2937
          goto create_pair;
        }
#line 2938
        sublen -= (int )*(subptr + (vsa_tlen + 1));
#line 2939
        subptr += (int )*(subptr + (vsa_tlen + 1));
#line 2940
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 2947
        goto create_pair;
        switch_break___0: /* CIL Label */ ;
        }
#line 2868
        if (! (sublen > 0)) {
#line 2868
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2951
      vendorcode = (uint32_t )myvendor;
#line 2952
      vendorlen = attrlen - 4;
#line 2953
      packet_length -= 4;
#line 2955
      ptr += 4;
    }
    {
#line 2964
    if (vsa_tlen == 1) {
#line 2964
      goto case_1___1;
    }
#line 2968
    if (vsa_tlen == 2) {
#line 2968
      goto case_2___1;
    }
#line 2972
    goto switch_default___1;
    case_1___1: /* CIL Label */ 
#line 2965
    attribute = (int )*(ptr + 0);
#line 2966
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
#line 2969
    attribute = ((int )*(ptr + 0) << 8) | (int )*(ptr + 1);
#line 2970
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 2973
    return (-1);
    switch_break___1: /* CIL Label */ ;
    }
#line 2975
    attribute = (int )((unsigned int )attribute | (vendorcode << 16));
#line 2976
    vsa_ptr = ptr;
#line 2977
    ptr += vsa_tlen;
    {
#line 2980
    if (vsa_llen == 1) {
#line 2980
      goto case_1___2;
    }
#line 2984
    if (vsa_llen == 2) {
#line 2984
      goto case_2___2;
    }
#line 2988
    goto switch_default___2;
    case_1___2: /* CIL Label */ 
#line 2981
    attrlen = (int )*(ptr + 0) - ((vsa_tlen + vsa_llen) + vsa_offset);
#line 2982
    goto switch_break___2;
    case_2___2: /* CIL Label */ 
#line 2985
    attrlen = (int )*(ptr + 1) - (vsa_tlen + vsa_llen);
#line 2986
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 2989
    return (-1);
    switch_break___2: /* CIL Label */ ;
    }
#line 2992
    ptr += vsa_llen + vsa_offset;
#line 2993
    vendorlen -= ((vsa_tlen + vsa_llen) + vsa_offset) + attrlen;
#line 2994
    if (vendorlen == 0) {
#line 2994
      vendorcode = (uint32_t )0;
    }
#line 2995
    packet_length -= (vsa_tlen + vsa_llen) + vsa_offset;
#line 3000
    if (attrlen == 0) {
#line 3000
      goto next;
    }
#line 3007
    if (attribute == 1622474752) {
#line 3007
      goto next;
    }
#line 3009
    if (vsa_offset) {
      {
#line 3012
      da = dict_attrbyvalue((unsigned int )attribute);
      }
#line 3019
      if (((int )*(vsa_ptr + 2) & 128) == 0) {
#line 3019
        if (da) {
#line 3019
          if (da->type != 14) {
#line 3020
            goto create_pair;
          }
        }
      }
      {
#line 3026
      pair = rad_continuation2vp((RADIUS_PACKET const   *)packet, (RADIUS_PACKET const   *)original,
                                 secret, attribute, attrlen, ptr, (size_t )packet_length,
                                 ((int )*(vsa_ptr + 2) & 128) != 0, da);
      }
#line 3031
      goto created_pair;
    }
    create_pair: 
#line 3045
    if (! attrlen) {
#line 3045
      if (attribute != 89) {
#line 3046
        goto next;
      }
    }
    {
#line 3048
    pair = rad_attr2vp((RADIUS_PACKET const   *)packet, (RADIUS_PACKET const   *)original,
                       secret, attribute, attrlen, (uint8_t const   *)ptr);
    }
#line 3050
    if (! pair) {
      {
#line 3051
      pairfree(& packet->vps);
#line 3052
      fr_strerror_printf("out of memory");
      }
#line 3053
      return (-1);
    }
    created_pair: 
#line 3057
    *tail = pair;
    {
#line 3058
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3058
      if (! pair) {
#line 3058
        goto while_break___2;
      }
#line 3059
      num_attributes ++;
      {
#line 3060
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3060
        if (fr_debug_flag) {
#line 3060
          if (fr_log_fp) {
            {
#line 3060
            vp_print(fr_log_fp, pair);
            }
          }
        }
#line 3060
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3061
      tail = & pair->next;
#line 3062
      pair = pair->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3071
    if (fr_max_attributes > 0) {
#line 3071
      if (num_attributes > fr_max_attributes) {
        {
#line 3075
        pairfree(& packet->vps);
#line 3076
        tmp___2 = inet_ntop(packet->src_ipaddr.af, (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr),
                            (char */* __restrict  */)(host_ipaddr), (socklen_t )sizeof(host_ipaddr));
#line 3076
        fr_strerror_printf("WARNING: Possible DoS attack from host %s: Too many attributes in request (received %d, max %d are allowed).",
                           tmp___2, num_attributes, fr_max_attributes);
        }
#line 3081
        return (-1);
      }
    }
    next: 
#line 3085
    ptr += attrlen;
#line 3086
    packet_length -= attrlen;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3093
  fr_rand_seed((void const   *)packet->data, (size_t )20);
  }
#line 3095
  return (0);
}
}
#line 3110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_pwencode(char *passwd , size_t *pwlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  int i ;
  int n ;
  int secretlen ;
  int len ;
  size_t tmp ;

  {
#line 3126
  len = (int )*pwlen;
#line 3128
  if (len > 128) {
#line 3128
    len = 128;
  }
#line 3130
  if (len == 0) {
    {
#line 3131
    memset((void *)passwd, 0, (size_t )16);
#line 3132
    len = 16;
    }
  } else
#line 3133
  if (len % 16 != 0) {
    {
#line 3134
    memset((void *)(passwd + len), 0, (size_t )(16 - len % 16));
#line 3135
    len += 16 - len % 16;
    }
  }
  {
#line 3137
  *pwlen = (size_t )len;
#line 3142
  tmp = strlen(secret);
#line 3142
  secretlen = (int )tmp;
#line 3144
  fr_MD5Init(& context);
#line 3145
  fr_MD5Update(& context, (uint8_t const   *)secret, (size_t )secretlen);
#line 3146
  old = context;
#line 3152
  n = 0;
  }
  {
#line 3152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3152
    if (! (n < len)) {
#line 3152
      goto while_break;
    }
#line 3153
    if (n == 0) {
      {
#line 3154
      fr_MD5Update(& context, vector, (size_t )16);
#line 3155
      fr_MD5Final((uint8_t *)(digest), & context);
      }
    } else {
      {
#line 3157
      context = old;
#line 3158
      fr_MD5Update(& context, (uint8_t const   *)(((uint8_t *)passwd + n) - 16), (size_t )16);
#line 3161
      fr_MD5Final((uint8_t *)(digest), & context);
      }
    }
#line 3164
    i = 0;
    {
#line 3164
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3164
      if (! (i < 16)) {
#line 3164
        goto while_break___0;
      }
#line 3165
      *(passwd + (i + n)) = (char )((int )*(passwd + (i + n)) ^ (int )digest[i]);
#line 3164
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3152
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 3169
  return (0);
}
}
#line 3175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_pwdecode(char *passwd , size_t pwlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  int i ;
  size_t n ;
  size_t secretlen ;
  size_t tmp ;

  {
#line 3188
  if (pwlen > 128UL) {
#line 3188
    pwlen = (size_t )128;
  }
#line 3193
  if (pwlen == 0UL) {
#line 3193
    goto done;
  }
  {
#line 3198
  secretlen = strlen(secret);
#line 3200
  fr_MD5Init(& context);
#line 3201
  fr_MD5Update(& context, (uint8_t const   *)secret, secretlen);
#line 3202
  old = context;
#line 3207
  n = (size_t )0;
  }
  {
#line 3207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3207
    if (! (n < pwlen)) {
#line 3207
      goto while_break;
    }
#line 3208
    if (n == 0UL) {
      {
#line 3209
      fr_MD5Update(& context, vector, (size_t )16);
#line 3210
      fr_MD5Final((uint8_t *)(digest), & context);
#line 3212
      context = old;
      }
#line 3213
      if (pwlen > 16UL) {
        {
#line 3214
        fr_MD5Update(& context, (uint8_t const   *)((uint8_t *)passwd), (size_t )16);
        }
      }
    } else {
      {
#line 3218
      fr_MD5Final((uint8_t *)(digest), & context);
#line 3220
      context = old;
      }
#line 3221
      if (pwlen > n + 16UL) {
        {
#line 3222
        fr_MD5Update(& context, (uint8_t const   *)((uint8_t *)passwd + n), (size_t )16);
        }
      }
    }
#line 3227
    i = 0;
    {
#line 3227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3227
      if (! (i < 16)) {
#line 3227
        goto while_break___0;
      }
#line 3228
      *(passwd + ((size_t )i + n)) = (char )((int )*(passwd + ((size_t )i + n)) ^ (int )digest[i]);
#line 3227
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3207
    n += 16UL;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 3233
  *(passwd + pwlen) = (char )'\000';
#line 3234
  tmp = strlen((char const   *)passwd);
  }
#line 3234
  return ((int )tmp);
}
}
#line 3247 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_tunnel_pwencode(char *passwd , size_t *pwlen , char const   *secret , uint8_t const   *vector ) 
{ 
  uint8_t buffer[273] ;
  unsigned char digest[16] ;
  char *salt ;
  int i ;
  int n ;
  int secretlen ;
  unsigned int len ;
  unsigned int n2 ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 3256
  len = (unsigned int )*pwlen;
#line 3258
  if (len > 127U) {
#line 3258
    len = 127U;
  }
#line 3264
  n = (int )len;
  {
#line 3264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3264
    if (! (n >= 0)) {
#line 3264
      goto while_break;
    }
#line 3264
    *(passwd + (n + 3)) = *(passwd + n);
#line 3264
    n --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3265
  salt = passwd;
#line 3266
  passwd += 2;
#line 3270
  *passwd = (char )len;
#line 3271
  len ++;
#line 3283
  tmp = salt_offset;
#line 3283
  salt_offset ++;
#line 3283
  tmp___0 = fr_rand();
#line 3283
  *(salt + 0) = (char )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 3285
  tmp___1 = fr_rand();
#line 3285
  *(salt + 1) = (char )tmp___1;
#line 3290
  n = (int )(len % 16U);
  }
#line 3291
  if (n) {
#line 3292
    n = 16 - n;
    {
#line 3293
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3293
      if (! (n > 0)) {
#line 3293
        goto while_break___0;
      }
#line 3294
      *(passwd + len) = (char)0;
#line 3293
      n --;
#line 3293
      len ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 3297
  *pwlen = (size_t )(len + 2U);
#line 3302
  tmp___2 = strlen(secret);
#line 3302
  secretlen = (int )tmp___2;
#line 3303
  memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)secret,
         (size_t )secretlen);
#line 3305
  n2 = 0U;
  }
  {
#line 3305
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3305
    if (! (n2 < len)) {
#line 3305
      goto while_break___1;
    }
#line 3306
    if (! n2) {
      {
#line 3307
      memcpy((void */* __restrict  */)(buffer + secretlen), (void const   */* __restrict  */)vector,
             (size_t )16);
#line 3308
      memcpy((void */* __restrict  */)((buffer + secretlen) + 16), (void const   */* __restrict  */)salt,
             (size_t )2);
#line 3309
      fr_md5_calc(digest, (uint8_t const   *)(buffer), (unsigned int )((secretlen + 16) + 2));
      }
    } else {
      {
#line 3311
      memcpy((void */* __restrict  */)(buffer + secretlen), (void const   */* __restrict  */)((passwd + n2) - 16),
             (size_t )16);
#line 3312
      fr_md5_calc(digest, (uint8_t const   *)(buffer), (unsigned int )(secretlen + 16));
      }
    }
#line 3315
    i = 0;
    {
#line 3315
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3315
      if (! (i < 16)) {
#line 3315
        goto while_break___2;
      }
#line 3316
      *(passwd + ((unsigned int )i + n2)) = (char )((int )*(passwd + ((unsigned int )i + n2)) ^ (int )digest[i]);
#line 3315
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3305
    n2 += 16U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3319
  *(passwd + n2) = (char)0;
#line 3320
  return (0);
}
}
#line 3330 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_tunnel_pwdecode(uint8_t *passwd , size_t *pwlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  int secretlen ;
  unsigned int i ;
  unsigned int n ;
  unsigned int len ;
  unsigned int reallen ;
  size_t tmp ;
  int base ;

  {
#line 3338
  len = (unsigned int )*pwlen;
#line 3343
  if (len < 2U) {
    {
#line 3344
    fr_strerror_printf("tunnel password is too short");
    }
#line 3345
    return (-1);
  }
#line 3358
  if (len <= 3U) {
#line 3359
    *(passwd + 0) = (uint8_t )0;
#line 3360
    *pwlen = (size_t )0;
#line 3361
    return (0);
  }
  {
#line 3364
  len -= 2U;
#line 3369
  tmp = strlen(secret);
#line 3369
  secretlen = (int )tmp;
#line 3371
  fr_MD5Init(& context);
#line 3372
  fr_MD5Update(& context, (uint8_t const   *)secret, (size_t )secretlen);
#line 3373
  old = context;
#line 3380
  fr_MD5Update(& context, vector, (size_t )16);
#line 3381
  fr_MD5Update(& context, (uint8_t const   *)passwd, (size_t )2);
#line 3383
  reallen = 0U;
#line 3384
  n = 0U;
  }
  {
#line 3384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3384
    if (! (n < len)) {
#line 3384
      goto while_break;
    }
#line 3385
    base = 0;
#line 3387
    if (n == 0U) {
      {
#line 3388
      fr_MD5Final((uint8_t *)(digest), & context);
#line 3390
      context = old;
#line 3397
      reallen = (unsigned int )((int )*(passwd + 2) ^ (int )digest[0]);
      }
#line 3398
      if (reallen >= len) {
        {
#line 3399
        fr_strerror_printf("tunnel password is too long for the attribute");
        }
#line 3400
        return (-1);
      }
      {
#line 3403
      fr_MD5Update(& context, (uint8_t const   *)(passwd + 2), (size_t )16);
#line 3405
      base = 1;
      }
    } else {
      {
#line 3407
      fr_MD5Final((uint8_t *)(digest), & context);
#line 3409
      context = old;
#line 3410
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) + 2), (size_t )16);
      }
    }
#line 3413
    i = (unsigned int )base;
    {
#line 3413
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3413
      if (! (i < 16U)) {
#line 3413
        goto while_break___0;
      }
#line 3414
      *(passwd + ((n + i) - 1U)) = (uint8_t )((int )*(passwd + ((n + i) + 2U)) ^ (int )digest[i]);
#line 3413
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3384
    n += 16U;
  }
  while_break: /* CIL Label */ ;
  }
#line 3421
  if (reallen > 239U) {
#line 3421
    reallen = 239U;
  }
#line 3423
  *pwlen = (size_t )reallen;
#line 3424
  *(passwd + reallen) = (uint8_t )0;
#line 3426
  return ((int )reallen);
}
}
#line 3436 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
int rad_chap_encode(RADIUS_PACKET *packet , uint8_t *output , int id , VALUE_PAIR *password ) 
{ 
  int i ;
  uint8_t *ptr ;
  uint8_t string[509] ;
  VALUE_PAIR *challenge ;
  uint8_t *tmp ;

  {
#line 3447
  if ((unsigned long )packet == (unsigned long )((void *)0)) {
#line 3448
    return (-1);
  } else
#line 3447
  if ((unsigned long )password == (unsigned long )((void *)0)) {
#line 3448
    return (-1);
  }
  {
#line 3458
  i = 0;
#line 3459
  ptr = string;
#line 3460
  tmp = ptr;
#line 3460
  ptr ++;
#line 3460
  *tmp = (uint8_t )id;
#line 3462
  i ++;
#line 3463
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(password->data.strvalue),
         password->length);
#line 3464
  ptr += password->length;
#line 3465
  i = (int )((size_t )i + password->length);
#line 3471
  challenge = pairfind(packet->vps, 60);
  }
#line 3472
  if (challenge) {
    {
#line 3473
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(challenge->data.strvalue),
           challenge->length);
#line 3474
    i = (int )((size_t )i + challenge->length);
    }
  } else {
    {
#line 3476
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(packet->vector),
           (size_t )16);
#line 3477
    i += 16;
    }
  }
  {
#line 3480
  *output = (uint8_t )id;
#line 3481
  fr_md5_calc(output + 1, (uint8_t const   *)(string), (unsigned int )i);
  }
#line 3483
  return (0);
}
}
#line 3492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
void fr_rand_seed(void const   *data , size_t size ) 
{ 
  uint32_t hash ;
  int fd ;
  size_t total ;
  ssize_t this ;
  int *tmp ;
  time_t tmp___0 ;
  int *tmp___1 ;

  {
#line 3499
  if (! fr_rand_initialized) {
    {
#line 3502
    memset((void *)(& fr_rand_pool), 0, sizeof(fr_rand_pool));
#line 3504
    fd = open("/dev/urandom", 0);
    }
#line 3505
    if (fd >= 0) {
#line 3509
      this = (ssize_t )0;
#line 3509
      total = (size_t )this;
      {
#line 3510
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3510
        if (! (total < sizeof(fr_rand_pool.randrsl))) {
#line 3510
          goto while_break;
        }
        {
#line 3511
        this = read(fd, (void *)(fr_rand_pool.randrsl), sizeof(fr_rand_pool.randrsl) - total);
        }
#line 3513
        if (this < 0L) {
          {
#line 3513
          tmp = __errno_location();
          }
#line 3513
          if (*tmp != 4) {
#line 3513
            goto while_break;
          }
        }
#line 3514
        if (this > 0L) {
#line 3514
          total += (size_t )this;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3516
      close(fd);
      }
    } else {
      {
#line 3518
      fr_rand_pool.randrsl[0] = (uint32_t )fd;
#line 3519
      tmp___0 = time((time_t *)((void *)0));
#line 3519
      fr_rand_pool.randrsl[1] = (uint32_t )tmp___0;
#line 3520
      tmp___1 = __errno_location();
#line 3520
      fr_rand_pool.randrsl[2] = (uint32_t )*tmp___1;
      }
    }
    {
#line 3523
    fr_randinit(& fr_rand_pool, 1);
#line 3524
    fr_rand_pool.randcnt = (uint32_t )0;
#line 3525
    fr_rand_initialized = 1;
    }
  }
#line 3528
  if (! data) {
#line 3528
    return;
  }
  {
#line 3533
  hash = fr_rand();
  }
#line 3534
  if (! hash) {
    {
#line 3534
    hash = fr_rand();
    }
  }
  {
#line 3535
  hash = fr_hash_update(data, size, hash);
#line 3537
  fr_rand_pool.randmem[fr_rand_pool.randcnt] ^= hash;
  }
#line 3538
  return;
}
}
#line 3544 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
uint32_t fr_rand(void) 
{ 
  uint32_t num ;
  uint32_t tmp ;

  {
#line 3551
  if (! fr_rand_initialized) {
    {
#line 3552
    fr_rand_seed((void const   *)((void *)0), (size_t )0);
    }
  }
#line 3555
  tmp = fr_rand_pool.randcnt;
#line 3555
  (fr_rand_pool.randcnt) ++;
#line 3555
  num = fr_rand_pool.randrsl[tmp];
#line 3556
  if (fr_rand_pool.randcnt >= 256U) {
    {
#line 3557
    fr_rand_pool.randcnt = (uint32_t )0;
#line 3558
    fr_isaac(& fr_rand_pool);
    }
  }
#line 3561
  return (num);
}
}
#line 3568 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
RADIUS_PACKET *rad_alloc(int newvector ) 
{ 
  RADIUS_PACKET *rp ;
  void *tmp ;
  int i ;
  uint32_t hash ;
  uint32_t base ;
  uint32_t tmp___0 ;

  {
  {
#line 3572
  tmp = malloc(sizeof(RADIUS_PACKET ));
#line 3572
  rp = (RADIUS_PACKET *)tmp;
  }
#line 3572
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 3573
    fr_strerror_printf("out of memory");
    }
#line 3574
    return ((RADIUS_PACKET *)((void *)0));
  }
  {
#line 3576
  memset((void *)rp, 0, sizeof(*rp));
#line 3577
  rp->id = -1;
#line 3578
  rp->offset = (ssize_t )-1;
  }
#line 3580
  if (newvector) {
    {
#line 3588
    base = fr_rand();
#line 3589
    i = 0;
    }
    {
#line 3589
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3589
      if (! (i < 16)) {
#line 3589
        goto while_break;
      }
      {
#line 3590
      tmp___0 = fr_rand();
#line 3590
      hash = tmp___0 ^ base;
#line 3591
      memcpy((void */* __restrict  */)(rp->vector + i), (void const   */* __restrict  */)(& hash),
             sizeof(hash));
#line 3589
      i = (int )((unsigned long )i + sizeof(uint32_t ));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 3594
  fr_rand();
  }
#line 3596
  return (rp);
}
}
#line 3599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
RADIUS_PACKET *rad_alloc_reply(RADIUS_PACKET *packet ) 
{ 
  RADIUS_PACKET *reply ;

  {
#line 3603
  if (! packet) {
#line 3603
    return ((RADIUS_PACKET *)((void *)0));
  }
  {
#line 3605
  reply = rad_alloc(0);
  }
#line 3606
  if (! reply) {
#line 3606
    return ((RADIUS_PACKET *)((void *)0));
  }
  {
#line 3611
  reply->sockfd = packet->sockfd;
#line 3612
  reply->dst_ipaddr = packet->src_ipaddr;
#line 3613
  reply->src_ipaddr = packet->dst_ipaddr;
#line 3614
  reply->dst_port = packet->src_port;
#line 3615
  reply->src_port = packet->dst_port;
#line 3616
  reply->id = packet->id;
#line 3617
  reply->code = 0U;
#line 3618
  memcpy((void */* __restrict  */)(reply->vector), (void const   */* __restrict  */)(packet->vector),
         sizeof(reply->vector));
#line 3620
  reply->vps = (VALUE_PAIR *)((void *)0);
#line 3621
  reply->data = (uint8_t *)((void *)0);
#line 3622
  reply->data_len = 0;
  }
#line 3624
  return (reply);
}
}
#line 3631 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
void rad_free(RADIUS_PACKET **radius_packet_ptr ) 
{ 
  RADIUS_PACKET *radius_packet ;

  {
#line 3635
  if (! radius_packet_ptr) {
#line 3635
    return;
  } else
#line 3635
  if (! *radius_packet_ptr) {
#line 3635
    return;
  }
  {
#line 3636
  radius_packet = *radius_packet_ptr;
#line 3638
  free((void *)radius_packet->data);
#line 3640
  pairfree(& radius_packet->vps);
#line 3642
  free((void *)radius_packet);
#line 3644
  *radius_packet_ptr = (RADIUS_PACKET *)((void *)0);
  }
#line 3645
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___22[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
void fr_hmac_md5(uint8_t const   *text , int text_len , uint8_t const   *key , int key_len ,
                 unsigned char *digest ) 
{ 
  FR_MD5_CTX context ;
  uint8_t k_ipad[65] ;
  uint8_t k_opad[65] ;
  uint8_t tk[16] ;
  int i ;
  FR_MD5_CTX tctx ;

  {
#line 57
  if (key_len > 64) {
    {
#line 61
    fr_MD5Init(& tctx);
#line 62
    fr_MD5Update(& tctx, key, (size_t )key_len);
#line 63
    fr_MD5Final((uint8_t *)(tk), & tctx);
#line 65
    key = (uint8_t const   *)(tk);
#line 66
    key_len = 16;
    }
  }
  {
#line 82
  memset((void *)(k_ipad), 0, sizeof(k_ipad));
#line 83
  memset((void *)(k_opad), 0, sizeof(k_opad));
#line 84
  memcpy((void */* __restrict  */)(k_ipad), (void const   */* __restrict  */)key,
         (size_t )key_len);
#line 85
  memcpy((void */* __restrict  */)(k_opad), (void const   */* __restrict  */)key,
         (size_t )key_len);
#line 88
  i = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < 64)) {
#line 88
      goto while_break;
    }
#line 89
    k_ipad[i] = (uint8_t )((int )k_ipad[i] ^ 54);
#line 90
    k_opad[i] = (uint8_t )((int )k_opad[i] ^ 92);
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  fr_MD5Init(& context);
#line 97
  fr_MD5Update(& context, (uint8_t const   *)(k_ipad), (size_t )64);
#line 98
  fr_MD5Update(& context, text, (size_t )text_len);
#line 99
  fr_MD5Final((uint8_t *)digest, & context);
#line 103
  fr_MD5Init(& context);
#line 105
  fr_MD5Update(& context, (uint8_t const   *)(k_opad), (size_t )64);
#line 106
  fr_MD5Update(& context, (uint8_t const   *)digest, (size_t )16);
#line 108
  fr_MD5Final((uint8_t *)digest, & context);
  }
#line 109
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___23[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___21[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___24[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___22[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___21[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 34
uint32_t fr_request_packet_hash(RADIUS_PACKET const   *packet ) ;
#line 35
uint32_t fr_reply_packet_hash(RADIUS_PACKET const   *packet ) ;
#line 36
int fr_packet_cmp(RADIUS_PACKET const   *a , RADIUS_PACKET const   *b ) ;
#line 37
int fr_inaddr_any(fr_ipaddr_t *ipaddr ) ;
#line 38
void fr_request_from_reply(RADIUS_PACKET *request , RADIUS_PACKET const   *reply ) ;
#line 40
int fr_socket(fr_ipaddr_t *ipaddr , int port ) ;
#line 44
fr_packet_list_t *fr_packet_list_create(int alloc_id ) ;
#line 45
void fr_packet_list_free(fr_packet_list_t *pl ) ;
#line 46
int fr_packet_list_insert(fr_packet_list_t *pl , RADIUS_PACKET **request_p ) ;
#line 49
RADIUS_PACKET **fr_packet_list_find(fr_packet_list_t *pl , RADIUS_PACKET *request ) ;
#line 51
RADIUS_PACKET **fr_packet_list_find_byreply(fr_packet_list_t *pl , RADIUS_PACKET *reply ) ;
#line 53
RADIUS_PACKET **fr_packet_list_yank(fr_packet_list_t *pl , RADIUS_PACKET *request ) ;
#line 55
int fr_packet_list_num_elements(fr_packet_list_t *pl ) ;
#line 56
int fr_packet_list_id_alloc(fr_packet_list_t *pl , RADIUS_PACKET *request ) ;
#line 58
int fr_packet_list_id_free(fr_packet_list_t *pl , RADIUS_PACKET *request ) ;
#line 60
int fr_packet_list_socket_add(fr_packet_list_t *pl , int sockfd ) ;
#line 61
int fr_packet_list_socket_remove(fr_packet_list_t *pl , int sockfd ) ;
#line 62
int fr_packet_list_walk(fr_packet_list_t *pl , void *ctx , int (*callback)(void * ,
                                                                           void * ) ) ;
#line 64
int fr_packet_list_fd_set(fr_packet_list_t *pl , fd_set *set ) ;
#line 65
RADIUS_PACKET *fr_packet_list_recv(fr_packet_list_t *pl , fd_set *set ) ;
#line 67
int fr_packet_list_num_incoming(fr_packet_list_t *pl ) ;
#line 68
int fr_packet_list_num_outgoing(fr_packet_list_t *pl ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
uint32_t fr_request_packet_hash(RADIUS_PACKET const   *packet ) 
{ 
  uint32_t hash ;
  uint32_t tmp ;

  {
#line 40
  if (packet->hash) {
#line 40
    return ((uint32_t )packet->hash);
  }
  {
#line 42
  hash = fr_hash((void const   *)(& packet->sockfd), sizeof(packet->sockfd));
#line 43
  hash = fr_hash_update((void const   *)(& packet->src_port), sizeof(packet->src_port),
                        hash);
#line 45
  hash = fr_hash_update((void const   *)(& packet->dst_port), sizeof(packet->dst_port),
                        hash);
#line 47
  hash = fr_hash_update((void const   *)(& packet->src_ipaddr.af), sizeof(packet->src_ipaddr.af),
                        hash);
  }
  {
#line 54
  if (packet->src_ipaddr.af == 2) {
#line 54
    goto case_2;
  }
#line 62
  if (packet->src_ipaddr.af == 10) {
#line 62
    goto case_10;
  }
#line 70
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 55
  hash = fr_hash_update((void const   *)(& packet->src_ipaddr.ipaddr.ip4addr), sizeof(packet->src_ipaddr.ipaddr.ip4addr),
                        hash);
#line 58
  hash = fr_hash_update((void const   *)(& packet->dst_ipaddr.ipaddr.ip4addr), sizeof(packet->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 61
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 63
  hash = fr_hash_update((void const   *)(& packet->src_ipaddr.ipaddr.ip6addr), sizeof(packet->src_ipaddr.ipaddr.ip6addr),
                        hash);
#line 66
  hash = fr_hash_update((void const   *)(& packet->dst_ipaddr.ipaddr.ip6addr), sizeof(packet->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 69
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 71
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 74
  tmp = fr_hash_update((void const   *)(& packet->id), sizeof(packet->id), hash);
  }
#line 74
  return (tmp);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
uint32_t fr_reply_packet_hash(RADIUS_PACKET const   *packet ) 
{ 
  uint32_t hash ;
  uint32_t tmp ;

  {
  {
#line 91
  hash = fr_hash((void const   *)(& packet->sockfd), sizeof(packet->sockfd));
#line 92
  hash = fr_hash_update((void const   *)(& packet->id), sizeof(packet->id), hash);
#line 93
  hash = fr_hash_update((void const   *)(& packet->src_port), sizeof(packet->src_port),
                        hash);
#line 95
  hash = fr_hash_update((void const   *)(& packet->dst_port), sizeof(packet->dst_port),
                        hash);
#line 97
  hash = fr_hash_update((void const   *)(& packet->src_ipaddr.af), sizeof(packet->src_ipaddr.af),
                        hash);
  }
  {
#line 104
  if (packet->src_ipaddr.af == 2) {
#line 104
    goto case_2;
  }
#line 112
  if (packet->src_ipaddr.af == 10) {
#line 112
    goto case_10;
  }
#line 120
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 105
  hash = fr_hash_update((void const   *)(& packet->dst_ipaddr.ipaddr.ip4addr), sizeof(packet->dst_ipaddr.ipaddr.ip4addr),
                        hash);
#line 108
  hash = fr_hash_update((void const   *)(& packet->src_ipaddr.ipaddr.ip4addr), sizeof(packet->src_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 111
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 113
  hash = fr_hash_update((void const   *)(& packet->dst_ipaddr.ipaddr.ip6addr), sizeof(packet->dst_ipaddr.ipaddr.ip6addr),
                        hash);
#line 116
  hash = fr_hash_update((void const   *)(& packet->src_ipaddr.ipaddr.ip6addr), sizeof(packet->src_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 119
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 124
  tmp = fr_hash_update((void const   *)(& packet->id), sizeof(packet->id), hash);
  }
#line 124
  return (tmp);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_cmp(RADIUS_PACKET const   *a , RADIUS_PACKET const   *b ) 
{ 
  int rcode ;
  int tmp ;

  {
#line 139
  if (a->sockfd < b->sockfd) {
#line 139
    return (-1);
  }
#line 140
  if (a->sockfd > b->sockfd) {
#line 140
    return (1);
  }
#line 142
  if (a->id < b->id) {
#line 142
    return (-1);
  }
#line 143
  if (a->id > b->id) {
#line 143
    return (1);
  }
#line 145
  if ((int const   )a->src_port < (int const   )b->src_port) {
#line 145
    return (-1);
  }
#line 146
  if ((int const   )a->src_port > (int const   )b->src_port) {
#line 146
    return (1);
  }
#line 148
  if ((int const   )a->dst_port < (int const   )b->dst_port) {
#line 148
    return (-1);
  }
#line 149
  if ((int const   )a->dst_port > (int const   )b->dst_port) {
#line 149
    return (1);
  }
  {
#line 151
  rcode = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 152
  if (rcode != 0) {
#line 152
    return (rcode);
  }
  {
#line 153
  tmp = fr_ipaddr_cmp(& a->src_ipaddr, & b->src_ipaddr);
  }
#line 153
  return (tmp);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_inaddr_any(fr_ipaddr_t *ipaddr ) 
{ 
  struct in6_addr  const  *__a ;
  int tmp ;

  {
#line 160
  if (ipaddr->af == 2) {
#line 161
    if (ipaddr->ipaddr.ip4addr.s_addr == 0U) {
#line 162
      return (1);
    }
  } else
#line 166
  if (ipaddr->af == 10) {
#line 167
    __a = (struct in6_addr  const  *)(& ipaddr->ipaddr.ip6addr);
#line 167
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 167
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 167
        if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 167
          if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 167
            tmp = 1;
          } else {
#line 167
            tmp = 0;
          }
        } else {
#line 167
          tmp = 0;
        }
      } else {
#line 167
        tmp = 0;
      }
    } else {
#line 167
      tmp = 0;
    }
#line 167
    if (tmp) {
#line 168
      return (1);
    }
  } else {
    {
#line 173
    fr_strerror_printf("Unknown address family");
    }
#line 174
    return (-1);
  }
#line 177
  return (0);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
void fr_request_from_reply(RADIUS_PACKET *request , RADIUS_PACKET const   *reply ) 
{ 


  {
#line 187
  request->sockfd = (int )reply->sockfd;
#line 188
  request->id = (int )reply->id;
#line 189
  request->src_port = (uint16_t )reply->dst_port;
#line 190
  request->dst_port = (uint16_t )reply->src_port;
#line 191
  request->src_ipaddr = (fr_ipaddr_t )reply->dst_ipaddr;
#line 192
  request->dst_ipaddr = (fr_ipaddr_t )reply->src_ipaddr;
#line 193
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_socket(fr_ipaddr_t *ipaddr , int port ) 
{ 
  int sockfd ;
  struct sockaddr_storage salocal ;
  socklen_t salen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int on ;
  struct in6_addr  const  *__a ;
  int tmp___2 ;
  int flag  __attribute__((__unused__)) ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 205
  if (port < 0) {
    {
#line 206
    fr_strerror_printf("Port %d is out of allowed bounds", port);
    }
#line 207
    return (-1);
  } else
#line 205
  if (port > 65535) {
    {
#line 206
    fr_strerror_printf("Port %d is out of allowed bounds", port);
    }
#line 207
    return (-1);
  }
  {
#line 210
  sockfd = socket(ipaddr->af, 2, 0);
  }
#line 211
  if (sockfd < 0) {
    {
#line 212
    tmp = __errno_location();
#line 212
    tmp___0 = strerror(*tmp);
#line 212
    fr_strerror_printf("cannot open socket: %s", tmp___0);
    }
#line 213
    return (sockfd);
  }
  {
#line 228
  tmp___1 = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)ipaddr, port, & salocal, & salen);
  }
#line 228
  if (! tmp___1) {
#line 229
    return (sockfd);
  }
#line 233
  if (ipaddr->af == 10) {
#line 242
    __a = (struct in6_addr  const  *)(& ipaddr->ipaddr.ip6addr);
#line 242
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 242
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 242
        if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 242
          if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 242
            tmp___2 = 1;
          } else {
#line 242
            tmp___2 = 0;
          }
        } else {
#line 242
          tmp___2 = 0;
        }
      } else {
#line 242
        tmp___2 = 0;
      }
    } else {
#line 242
      tmp___2 = 0;
    }
#line 242
    if (tmp___2) {
      {
#line 243
      on = 1;
#line 245
      setsockopt(sockfd, 41, 26, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
      }
    }
  }
#line 252
  if (ipaddr->af == 2) {
    {
#line 261
    flag = 0;
#line 262
    setsockopt(sockfd, 0, 10, (void const   *)(& flag), (socklen_t )sizeof(flag));
    }
  }
  {
#line 276
  tmp___5 = bind(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& salocal)),
                 salen);
  }
#line 276
  if (tmp___5 < 0) {
    {
#line 277
    close(sockfd);
#line 278
    tmp___3 = __errno_location();
#line 278
    tmp___4 = strerror(*tmp___3);
#line 278
    fr_strerror_printf("cannot bind socket: %s", tmp___4);
    }
#line 279
    return (-1);
  }
#line 282
  return (sockfd);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_socket_remove(fr_packet_list_t *pl , int sockfd ) 
{ 
  fr_packet_socket_t *ps ;

  {
#line 349
  if (! pl) {
#line 349
    return (0);
  }
  {
#line 351
  ps = fr_socket_find(pl, sockfd);
  }
#line 352
  if (! ps) {
#line 352
    return (0);
  }
#line 357
  if (ps->num_outgoing != 0) {
#line 357
    return (0);
  }
#line 359
  ps->sockfd = -1;
#line 360
  pl->mask &= (unsigned int )(~ (1 << ps->offset));
#line 363
  return (1);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_socket_add(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;
  struct sockaddr_storage src ;
  socklen_t sizeof_src ;
  fr_packet_socket_t *ps ;
  int tmp ;
  int tmp___0 ;
  struct in6_addr  const  *__a ;
  int tmp___1 ;

  {
#line 370
  sizeof_src = (socklen_t )sizeof(src);
#line 373
  if (! pl) {
#line 373
    return (0);
  }
#line 375
  ps = (fr_packet_socket_t *)((void *)0);
#line 376
  start = sockfd * 16777619 & 31;
#line 376
  i = start;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (pl->sockets[i].sockfd == -1) {
#line 380
      ps = & pl->sockets[i];
#line 381
      start = i;
#line 382
      goto while_break;
    }
#line 385
    i = (i + 1) & 31;
#line 378
    if (! (i != start)) {
#line 378
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  if (! ps) {
#line 389
    return (0);
  }
  {
#line 392
  memset((void *)ps, 0, sizeof(*ps));
#line 393
  ps->sockfd = sockfd;
#line 394
  ps->offset = start;
#line 403
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 404
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                    (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 404
  if (tmp < 0) {
#line 406
    return (0);
  }
  {
#line 409
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               & ps->ipaddr, & ps->port);
  }
#line 409
  if (! tmp___0) {
#line 410
    return (0);
  }
#line 416
  if ((int )src.ss_family == 2) {
#line 417
    if (ps->ipaddr.ipaddr.ip4addr.s_addr == 0U) {
#line 418
      ps->inaddr_any = 1;
    }
  } else
#line 422
  if ((int )src.ss_family == 10) {
#line 423
    __a = (struct in6_addr  const  *)(& ps->ipaddr.ipaddr.ip6addr);
#line 423
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 423
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 423
        if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 423
          if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 423
            tmp___1 = 1;
          } else {
#line 423
            tmp___1 = 0;
          }
        } else {
#line 423
          tmp___1 = 0;
        }
      } else {
#line 423
        tmp___1 = 0;
      }
    } else {
#line 423
      tmp___1 = 0;
    }
#line 423
    if (tmp___1) {
#line 424
      ps->inaddr_any = 1;
    }
  } else {
#line 428
    return (0);
  }
#line 431
  pl->mask |= (unsigned int )(1 << ps->offset);
#line 432
  return (1);
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
void fr_packet_list_free(fr_packet_list_t *pl ) 
{ 


  {
#line 511
  if (! pl) {
#line 511
    return;
  }
  {
#line 513
  rbtree_free(pl->tree);
#line 514
  fr_hash_table_free(pl->dst2id_ht);
#line 515
  free((void *)pl);
  }
#line 516
  return;
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
fr_packet_list_t *fr_packet_list_create(int alloc_id ) 
{ 
  int i ;
  fr_packet_list_t *pl ;
  void *tmp ;

  {
  {
#line 527
  tmp = malloc(sizeof(*pl));
#line 527
  pl = (fr_packet_list_t *)tmp;
  }
#line 528
  if (! pl) {
#line 528
    return ((fr_packet_list_t *)((void *)0));
  }
  {
#line 529
  memset((void *)pl, 0, sizeof(*pl));
#line 531
  pl->tree = rbtree_create(& packet_entry_cmp, (void (*)(void * ))((void *)0), 0);
  }
#line 532
  if (! pl->tree) {
    {
#line 533
    fr_packet_list_free(pl);
    }
#line 534
    return ((fr_packet_list_t *)((void *)0));
  }
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < 32)) {
#line 537
      goto while_break;
    }
#line 538
    pl->sockets[i].sockfd = -1;
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  if (alloc_id) {
    {
#line 542
    pl->alloc_id = 1;
#line 544
    pl->dst2id_ht = fr_hash_table_create(& packet_dst2id_hash, & packet_dst2id_cmp,
                                         & packet_dst2id_free);
    }
#line 547
    if (! pl->dst2id_ht) {
      {
#line 548
      fr_packet_list_free(pl);
      }
#line 549
      return ((fr_packet_list_t *)((void *)0));
    }
  }
#line 553
  return (pl);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_insert(fr_packet_list_t *pl , RADIUS_PACKET **request_p ) 
{ 
  int tmp ;

  {
#line 564
  if (! pl) {
#line 564
    return (0);
  } else
#line 564
  if (! request_p) {
#line 564
    return (0);
  } else
#line 564
  if (! *request_p) {
#line 564
    return (0);
  }
  {
#line 566
  tmp = rbtree_insert(pl->tree, (void *)request_p);
  }
#line 566
  return (tmp);
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
RADIUS_PACKET **fr_packet_list_find(fr_packet_list_t *pl , RADIUS_PACKET *request ) 
{ 
  void *tmp ;

  {
#line 572
  if (! pl) {
#line 572
    return ((RADIUS_PACKET **)0);
  } else
#line 572
  if (! request) {
#line 572
    return ((RADIUS_PACKET **)0);
  }
  {
#line 574
  tmp = rbtree_finddata(pl->tree, (void const   *)(& request));
  }
#line 574
  return ((RADIUS_PACKET **)tmp);
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
RADIUS_PACKET **fr_packet_list_find_byreply(fr_packet_list_t *pl , RADIUS_PACKET *reply ) 
{ 
  RADIUS_PACKET my_request ;
  RADIUS_PACKET *request ;
  fr_packet_socket_t *ps ;
  void *tmp ;

  {
#line 588
  if (! pl) {
#line 588
    return ((RADIUS_PACKET **)((void *)0));
  } else
#line 588
  if (! reply) {
#line 588
    return ((RADIUS_PACKET **)((void *)0));
  }
  {
#line 590
  ps = fr_socket_find(pl, reply->sockfd);
  }
#line 591
  if (! ps) {
#line 591
    return ((RADIUS_PACKET **)((void *)0));
  }
#line 599
  my_request.sockfd = reply->sockfd;
#line 600
  my_request.id = reply->id;
#line 602
  if (ps->inaddr_any) {
#line 603
    my_request.src_ipaddr = ps->ipaddr;
  } else {
#line 605
    my_request.src_ipaddr = reply->dst_ipaddr;
  }
  {
#line 607
  my_request.src_port = (uint16_t )ps->port;
#line 609
  my_request.dst_ipaddr = reply->src_ipaddr;
#line 610
  my_request.dst_port = reply->src_port;
#line 612
  request = & my_request;
#line 614
  tmp = rbtree_finddata(pl->tree, (void const   *)(& request));
  }
#line 614
  return ((RADIUS_PACKET **)tmp);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
RADIUS_PACKET **fr_packet_list_yank(fr_packet_list_t *pl , RADIUS_PACKET *request ) 
{ 
  RADIUS_PACKET **packet_p ;
  void *tmp ;

  {
#line 623
  if (! pl) {
#line 623
    return ((RADIUS_PACKET **)((void *)0));
  } else
#line 623
  if (! request) {
#line 623
    return ((RADIUS_PACKET **)((void *)0));
  }
  {
#line 625
  tmp = rbtree_finddata(pl->tree, (void const   *)(& request));
#line 625
  packet_p = (RADIUS_PACKET **)tmp;
  }
#line 626
  if (! packet_p) {
#line 626
    return ((RADIUS_PACKET **)((void *)0));
  }
  {
#line 628
  rbtree_deletebydata(pl->tree, (void const   *)packet_p);
  }
#line 629
  return (packet_p);
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_num_elements(fr_packet_list_t *pl ) 
{ 
  int tmp ;

  {
#line 635
  if (! pl) {
#line 635
    return (0);
  }
  {
#line 637
  tmp = rbtree_num_elements(pl->tree);
  }
#line 637
  return (tmp);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_id_alloc(fr_packet_list_t *pl , RADIUS_PACKET *request ) 
{ 
  int i ;
  int id ;
  int start ;
  int src_any ;
  uint32_t free_mask ;
  fr_packet_dst2id_t my_pd ;
  fr_packet_dst2id_t *pd ;
  fr_packet_socket_t *ps ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 658
  src_any = 0;
#line 663
  if (! pl) {
    {
#line 664
    fr_strerror_printf("Invalid arguments");
    }
#line 665
    return (0);
  } else
#line 663
  if (! pl->alloc_id) {
    {
#line 664
    fr_strerror_printf("Invalid arguments");
    }
#line 665
    return (0);
  } else
#line 663
  if (! request) {
    {
#line 664
    fr_strerror_printf("Invalid arguments");
    }
#line 665
    return (0);
  }
#line 671
  if (request->dst_ipaddr.af == 0) {
    {
#line 673
    fr_strerror_printf("No destination address/port specified");
    }
#line 674
    return (0);
  } else
#line 671
  if ((int )request->dst_port == 0) {
    {
#line 673
    fr_strerror_printf("No destination address/port specified");
    }
#line 674
    return (0);
  }
#line 680
  if (request->src_ipaddr.af == 0) {
    {
#line 681
    memset((void *)(& request->src_ipaddr), 0, sizeof(request->src_ipaddr));
#line 682
    request->src_ipaddr.af = request->dst_ipaddr.af;
    }
  }
  {
#line 685
  src_any = fr_inaddr_any(& request->src_ipaddr);
  }
#line 686
  if (src_any < 0) {
    {
#line 687
    fr_strerror_printf("Error checking src IP address");
    }
#line 688
    return (0);
  }
  {
#line 694
  tmp = fr_inaddr_any(& request->dst_ipaddr);
  }
#line 694
  if (tmp != 0) {
    {
#line 695
    fr_strerror_printf("Error checking dst IP address");
    }
#line 696
    return (0);
  }
  {
#line 699
  my_pd.dst_ipaddr = request->dst_ipaddr;
#line 700
  my_pd.dst_port = (int )request->dst_port;
#line 702
  tmp___0 = fr_hash_table_finddata(pl->dst2id_ht, (void const   *)(& my_pd));
#line 702
  pd = (fr_packet_dst2id_t *)tmp___0;
  }
#line 703
  if (! pd) {
    {
#line 704
    tmp___1 = malloc(sizeof(*pd) + 255UL * sizeof(pd->id[0]));
#line 704
    pd = (fr_packet_dst2id_t *)tmp___1;
    }
#line 705
    if (! pd) {
#line 705
      return (0);
    }
    {
#line 707
    memset((void *)pd, 0, sizeof(*pd) + 255UL * sizeof(pd->id[0]));
#line 709
    pd->dst_ipaddr = request->dst_ipaddr;
#line 710
    pd->dst_port = (int )request->dst_port;
#line 712
    tmp___2 = fr_hash_table_insert(pl->dst2id_ht, (void *)pd);
    }
#line 712
    if (! tmp___2) {
      {
#line 713
      free((void *)pd);
#line 714
      fr_strerror_printf("Failed inserting into hash");
      }
#line 715
      return (0);
    }
  }
  {
#line 730
  tmp___3 = fr_rand();
#line 730
  start = (int )tmp___3 & 255;
#line 730
  id = start;
  }
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 732
    if (! (pd->id[id] == pl->mask)) {
#line 732
      goto while_break;
    }
#line 733
    id ++;
#line 734
    id &= 255;
#line 735
    if (id == start) {
      {
#line 736
      fr_strerror_printf("All IDs are being used");
      }
#line 737
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 741
  free_mask = ~ (~ pd->id[id] & pl->mask);
#line 743
  start = -1;
#line 744
  i = 0;
  {
#line 744
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 744
    if (! (i < 32)) {
#line 744
      goto while_break___0;
    }
#line 745
    if (pl->sockets[i].sockfd == -1) {
#line 745
      goto __Cont;
    }
#line 747
    ps = & pl->sockets[i];
#line 752
    if (ps->ipaddr.af != request->dst_ipaddr.af) {
#line 752
      goto __Cont;
    }
#line 758
    if (ps->inaddr_any) {
#line 758
      if (! src_any) {
#line 758
        goto __Cont;
      }
    }
#line 765
    if (! ps->inaddr_any) {
#line 765
      if (! src_any) {
        {
#line 765
        tmp___4 = fr_ipaddr_cmp((fr_ipaddr_t const   *)(& request->src_ipaddr), (fr_ipaddr_t const   *)(& ps->ipaddr));
        }
#line 765
        if (tmp___4 != 0) {
#line 767
          goto __Cont;
        }
      }
    }
#line 769
    if ((free_mask & (unsigned int )(1 << i)) == 0U) {
#line 770
      start = i;
#line 771
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 744
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 775
  if (start < 0) {
    {
#line 776
    fr_strerror_printf("Internal sanity check failed");
    }
#line 777
    return (0);
  }
#line 780
  pd->id[id] |= (unsigned int )(1 << start);
#line 781
  ps = & pl->sockets[start];
#line 783
  (ps->num_outgoing) ++;
#line 784
  (pl->num_outgoing) ++;
#line 789
  request->id = id;
#line 791
  request->sockfd = ps->sockfd;
#line 792
  request->src_ipaddr = ps->ipaddr;
#line 793
  request->src_port = (uint16_t )ps->port;
#line 795
  return (1);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_id_free(fr_packet_list_t *pl , RADIUS_PACKET *request ) 
{ 
  fr_packet_socket_t *ps ;
  fr_packet_dst2id_t my_pd ;
  fr_packet_dst2id_t *pd ;
  void *tmp ;

  {
#line 808
  if (! pl) {
#line 808
    return (0);
  } else
#line 808
  if (! request) {
#line 808
    return (0);
  }
  {
#line 810
  ps = fr_socket_find(pl, request->sockfd);
  }
#line 811
  if (! ps) {
#line 811
    return (0);
  }
  {
#line 813
  my_pd.dst_ipaddr = request->dst_ipaddr;
#line 814
  my_pd.dst_port = (int )request->dst_port;
#line 816
  tmp = fr_hash_table_finddata(pl->dst2id_ht, (void const   *)(& my_pd));
#line 816
  pd = (fr_packet_dst2id_t *)tmp;
  }
#line 817
  if (! pd) {
#line 817
    return (0);
  }
#line 819
  pd->id[request->id] &= (unsigned int )(~ (1 << ps->offset));
#line 821
  (ps->num_outgoing) --;
#line 822
  (pl->num_outgoing) --;
#line 824
  return (1);
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_walk(fr_packet_list_t *pl , void *ctx , int (*callback)(void * ,
                                                                           void * ) ) 
{ 
  int tmp ;

  {
#line 830
  if (! pl) {
#line 830
    return (0);
  } else
#line 830
  if (! callback) {
#line 830
    return (0);
  }
  {
#line 832
  tmp = rbtree_walk(pl->tree, (RBTREE_ORDER )1, callback, ctx);
  }
#line 832
  return (tmp);
}
}
#line 835 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_fd_set(fr_packet_list_t *pl , fd_set *set ) 
{ 
  int i ;
  int maxfd ;

  {
#line 839
  if (! pl) {
#line 839
    return (0);
  } else
#line 839
  if (! set) {
#line 839
    return (0);
  }
#line 841
  maxfd = -1;
#line 843
  i = 0;
  {
#line 843
  while (1) {
    while_continue: /* CIL Label */ ;
#line 843
    if (! (i < 32)) {
#line 843
      goto while_break;
    }
#line 844
    if (pl->sockets[i].sockfd == -1) {
#line 844
      goto __Cont;
    }
#line 845
    set->fds_bits[pl->sockets[i].sockfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << pl->sockets[i].sockfd % (8 * (int )sizeof(__fd_mask ));
#line 846
    if (pl->sockets[i].sockfd > maxfd) {
#line 847
      maxfd = pl->sockets[i].sockfd;
    }
    __Cont: /* CIL Label */ 
#line 843
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 851
  if (maxfd < 0) {
#line 851
    return (-1);
  }
#line 853
  return (maxfd + 1);
}
}
#line 862 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
RADIUS_PACKET *fr_packet_list_recv(fr_packet_list_t *pl , fd_set *set ) 
{ 
  int start ;
  RADIUS_PACKET *packet ;

  {
#line 867
  if (! pl) {
#line 867
    return ((RADIUS_PACKET *)((void *)0));
  } else
#line 867
  if (! set) {
#line 867
    return ((RADIUS_PACKET *)((void *)0));
  }
#line 869
  start = pl->last_recv;
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 871
    start ++;
#line 872
    start &= 31;
#line 874
    if (pl->sockets[start].sockfd == -1) {
#line 874
      goto __Cont;
    }
#line 876
    if (! ((set->fds_bits[pl->sockets[start].sockfd / (8 * (int )sizeof(__fd_mask ))] & (1L << pl->sockets[start].sockfd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 876
      goto __Cont;
    }
    {
#line 878
    packet = rad_recv(pl->sockets[start].sockfd, 0);
    }
#line 879
    if (! packet) {
#line 879
      goto __Cont;
    }
#line 886
    pl->last_recv = start;
#line 887
    return (packet);
    __Cont: /* CIL Label */ 
#line 870
    if (! (start != pl->last_recv)) {
#line 870
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 890
  return ((RADIUS_PACKET *)((void *)0));
}
}
#line 893 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_num_incoming(fr_packet_list_t *pl ) 
{ 
  int num_elements ;

  {
#line 897
  if (! pl) {
#line 897
    return (0);
  }
  {
#line 899
  num_elements = rbtree_num_elements(pl->tree);
  }
#line 900
  if (num_elements < pl->num_outgoing) {
#line 900
    return (0);
  }
#line 902
  return (num_elements - pl->num_outgoing);
}
}
#line 905 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
int fr_packet_list_num_outgoing(fr_packet_list_t *pl ) 
{ 


  {
#line 907
  if (! pl) {
#line 907
    return (0);
  }
#line 909
  return (pl->num_outgoing);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___25[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___21[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___23[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___21[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___21[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___22[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___21[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___26[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___22[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___24[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___22[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___22[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___23[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___22[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble(fr_heap_t *hp , int child ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
void fr_heap_delete(fr_heap_t *hp ) 
{ 


  {
#line 39
  if (! hp) {
#line 39
    return;
  }
  {
#line 41
  free((void *)hp->p);
#line 42
  free((void *)hp);
  }
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
fr_heap_t *fr_heap_create(int (*cmp)(void const   * , void const   * ) , size_t offset ) 
{ 
  fr_heap_t *fh ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 49
  if (! cmp) {
#line 49
    return ((fr_heap_t *)((void *)0));
  }
  {
#line 51
  tmp = malloc(sizeof(*fh));
#line 51
  fh = (fr_heap_t *)tmp;
  }
#line 52
  if (! fh) {
#line 52
    return ((fr_heap_t *)((void *)0));
  }
  {
#line 54
  memset((void *)fh, 0, sizeof(*fh));
#line 56
  fh->size = 2048;
#line 57
  tmp___0 = malloc(sizeof(*(fh->p)) * (unsigned long )fh->size);
#line 57
  fh->p = (void **)tmp___0;
  }
#line 58
  if (! fh->p) {
    {
#line 59
    free((void *)fh);
    }
#line 60
    return ((fr_heap_t *)((void *)0));
  }
#line 63
  fh->cmp = cmp;
#line 64
  fh->offset = offset;
#line 66
  return (fh);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
int fr_heap_insert(fr_heap_t *hp , void *data ) 
{ 
  int child ;
  void **p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 95
  child = hp->num_elements;
#line 100
  if (child == hp->size) {
    {
#line 103
    tmp = malloc((unsigned long )(2 * hp->size) * sizeof(*p));
#line 103
    p = (void **)tmp;
    }
#line 104
    if (! p) {
#line 104
      return (0);
    }
    {
#line 106
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)hp->p, sizeof(*p) * (unsigned long )hp->size);
#line 107
    free((void *)hp->p);
#line 108
    hp->p = p;
#line 109
    hp->size *= 2;
    }
  }
  {
#line 112
  *(hp->p + child) = data;
#line 113
  (hp->num_elements) ++;
#line 115
  tmp___0 = fr_heap_bubble(hp, child);
  }
#line 115
  return (tmp___0);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
int fr_heap_extract(fr_heap_t *hp , void *data ) 
{ 
  int child ;
  int parent ;
  int max ;
  int tmp ;
  int tmp___0 ;

  {
#line 153
  if (! hp) {
#line 153
    return (0);
  } else
#line 153
  if (hp->num_elements == 0) {
#line 153
    return (0);
  }
#line 155
  max = hp->num_elements - 1;
#line 160
  if (! data) {
#line 161
    parent = 0;
  } else {
#line 164
    if (! hp->offset) {
#line 164
      return (0);
    }
#line 166
    parent = *((int *)((uint8_t *)data + hp->offset));
#line 171
    if (parent < 0) {
#line 171
      return (0);
    } else
#line 171
    if (parent >= hp->num_elements) {
#line 171
      return (0);
    }
  }
#line 174
  if (hp->offset) {
#line 174
    *((int *)((uint8_t *)*(hp->p + parent) + hp->offset)) = -1;
  }
#line 175
  child = 2 * parent + 1;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (child <= max)) {
#line 176
      goto while_break;
    }
#line 180
    if (child != max) {
      {
#line 180
      tmp = (*(hp->cmp))((void const   *)*(hp->p + (child + 1)), (void const   *)*(hp->p + child));
      }
#line 180
      if (tmp < 0) {
#line 182
        child ++;
      }
    }
#line 184
    *(hp->p + parent) = *(hp->p + child);
#line 185
    if (hp->offset) {
#line 185
      *((int *)((uint8_t *)*(hp->p + parent) + hp->offset)) = parent;
    }
#line 186
    parent = child;
#line 187
    child = 2 * child + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  (hp->num_elements) --;
#line 195
  if (parent != max) {
    {
#line 200
    *(hp->p + parent) = *(hp->p + max);
#line 201
    tmp___0 = fr_heap_bubble(hp, parent);
    }
#line 201
    return (tmp___0);
  }
#line 204
  return (1);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
void *fr_heap_peek(fr_heap_t *hp ) 
{ 


  {
#line 210
  if (! hp) {
#line 210
    return ((void *)0);
  } else
#line 210
  if (hp->num_elements == 0) {
#line 210
    return ((void *)0);
  }
#line 215
  return (*(hp->p + 0));
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
int fr_heap_num_elements(fr_heap_t *hp ) 
{ 


  {
#line 220
  if (! hp) {
#line 220
    return (0);
  }
#line 222
  return (hp->num_elements);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___27[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___23[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___25[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___23[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___23[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___24[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___23[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___28[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___24[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___26[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___24[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___24[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___25[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___24[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___29[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___25[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___27[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___25[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___25[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___26[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___25[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___0  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___0  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___0  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___0(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___0(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___0(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___0(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___0(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___0;
#line 615
  salt_offset___0 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___0(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___0(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___0(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___0(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___0(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___0(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___0((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___0(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___0(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___0(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___0(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___0(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___0(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___0(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___0(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___0((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___0(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___0(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___30[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___26[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___28[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___26[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___26[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___27[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___26[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___31[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___27[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___29[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___27[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___27[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___28[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___27[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___0[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___0(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___32[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___28[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___30[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___28[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___28[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___29[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___28[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___0  =    {& Sentinel___0, & Sentinel___0, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___0(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___0)) {
    {
#line 60
    FreeWalker___0(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___0)) {
    {
#line 61
    FreeWalker___0(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___0(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___0)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___0)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___0)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___0(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___0)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___0)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___0)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___0(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___0(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___0(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___0(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___0(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___0(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___0(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___0)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___0)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___0(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___0)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___0(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___0(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___0)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___0)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___0(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___0)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___0(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___0(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___0)) {
    {
#line 523
    rcode = WalkNodePreOrder___0(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___0)) {
    {
#line 528
    rcode = WalkNodePreOrder___0(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___0(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___0)) {
    {
#line 545
    rcode = WalkNodeInOrder___0(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___0)) {
    {
#line 555
    rcode = WalkNodeInOrder___0(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___0(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___0)) {
    {
#line 572
    rcode = WalkNodeInOrder___0(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___0)) {
    {
#line 577
    rcode = WalkNodeInOrder___0(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___33[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___29[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___31[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___29[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___29[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___30[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___29[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___0(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___0(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___0[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acctlog/rlm_acctlog.c"
static char const   rcsid___34[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___30[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___32[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___30[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___30[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___31[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___30[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 57
extern int cf_section_parse(CONF_SECTION * , void *base , CONF_PARSER const   *variables ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 500 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
extern void *rad_malloc(size_t size ) ;
#line 543
extern int ( /* format attribute */  radlog)(int  , char const   *  , ...) ;
#line 597
extern int radius_xlat(char *out , int outlen , char const   *fmt , REQUEST *request ,
                       size_t (*func)(char *out , size_t outlen , char const   *in ) ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acctlog/rlm_acctlog.c"
static CONF_PARSER const   module_config[6]  = {      {"acctlog_update", 100, (unsigned long )(& ((rlm_acctlog_t *)0)->acctupdate),
      (void *)0, ""}, 
        {"acctlog_start", 100, (unsigned long )(& ((rlm_acctlog_t *)0)->acctstart), (void *)0,
      ""}, 
        {"acctlog_stop", 100, (unsigned long )(& ((rlm_acctlog_t *)0)->acctstop), (void *)0,
      ""}, 
        {"acctlog_on", 100, (unsigned long )(& ((rlm_acctlog_t *)0)->accton), (void *)0,
      ""}, 
        {"acctlog_off", 100, (unsigned long )(& ((rlm_acctlog_t *)0)->acctoff), (void *)0,
      ""}, 
        {(char const   *)((void *)0), -1, (size_t )0, (void *)0, (char const   *)((void *)0)}};
#line 50 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acctlog/rlm_acctlog.c"
static int acctlog_detach(void *instance ) 
{ 
  rlm_acctlog_t *inst ;

  {
  {
#line 52
  inst = (rlm_acctlog_t *)instance;
#line 55
  free((void *)inst);
  }
#line 56
  return (0);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acctlog/rlm_acctlog.c"
static int acctlog_instantiate(CONF_SECTION *conf , void **instance ) 
{ 
  rlm_acctlog_t *inst ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 63
  tmp = rad_malloc(sizeof(*inst));
#line 63
  inst = (rlm_acctlog_t *)tmp;
#line 64
  memset((void *)inst, 0, sizeof(*inst));
#line 66
  tmp___0 = cf_section_parse(conf, (void *)inst, module_config);
  }
#line 66
  if (tmp___0 < 0) {
    {
#line 67
    acctlog_detach((void *)inst);
    }
#line 68
    return (-1);
  }
#line 71
  *instance = (void *)inst;
#line 73
  return (0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acctlog/rlm_acctlog.c"
static int do_acctlog_acct(void *instance , REQUEST *request ) 
{ 
  rlm_acctlog_t *inst ;
  VALUE_PAIR *pair ;
  char logstr[1024] ;
  int acctstatustype ;
  size_t tmp ;

  {
  {
#line 83
  acctstatustype = 0;
#line 86
  inst = (rlm_acctlog_t *)instance;
#line 88
  pair = pairfind((request->packet)->vps, 40);
  }
#line 88
  if ((unsigned long )pair != (unsigned long )((void *)0)) {
#line 89
    acctstatustype = (int )pair->lvalue;
  } else {
    {
#line 91
    radius_xlat(logstr, (int )sizeof(logstr), "packet has no accounting status type. [user \'%{User-Name}\', nas \'%{NAS-IP-Address}\']",
                request, (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
#line 92
    radlog(4, "rlm_acctlog (%s)", logstr);
    }
#line 93
    return (4);
  }
  {
#line 97
  if (acctstatustype == 1) {
#line 97
    goto case_1;
  }
#line 100
  if (acctstatustype == 2) {
#line 100
    goto case_2;
  }
#line 103
  if (acctstatustype == 3) {
#line 103
    goto case_3;
  }
#line 106
  if (acctstatustype == 7) {
#line 106
    goto case_7;
  }
#line 109
  if (acctstatustype == 8) {
#line 109
    goto case_8;
  }
#line 96
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 98
  radius_xlat(logstr, (int )sizeof(logstr), (char const   *)inst->acctstart, request,
              (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
  }
#line 99
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 101
  radius_xlat(logstr, (int )sizeof(logstr), (char const   *)inst->acctstop, request,
              (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
  }
#line 102
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 104
  radius_xlat(logstr, (int )sizeof(logstr), (char const   *)inst->acctupdate, request,
              (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
  }
#line 105
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 107
  radius_xlat(logstr, (int )sizeof(logstr), (char const   *)inst->accton, request,
              (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
  }
#line 108
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 110
  radius_xlat(logstr, (int )sizeof(logstr), (char const   *)inst->acctoff, request,
              (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
  }
#line 111
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 115
  tmp = strlen((char const   *)(logstr));
  }
#line 115
  if (tmp) {
    {
#line 116
    radlog(6, "%s", logstr);
    }
  }
#line 118
  return (2);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acctlog/rlm_acctlog.c"
module_t rlm_acctlog  =    {4109257426U, "acctlog", 1 << 1, & acctlog_instantiate, & acctlog_detach, {(packetmethod )((void *)0),
                                                                              (packetmethod )((void *)0),
                                                                              (packetmethod )((void *)0),
                                                                              & do_acctlog_acct,
                                                                              (packetmethod )((void *)0),
                                                                              (packetmethod )((void *)0),
                                                                              (packetmethod )((void *)0),
                                                                              (packetmethod )((void *)0)}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___35[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___36[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___31[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___33[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___31[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___31[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___32[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___31[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___0(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___37[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___32[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___34[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___32[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___32[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___33[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___32[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___0[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___0[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___0[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___0[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___0[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___1(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___0(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___0, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___0, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___0, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___0(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___0, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___0(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___0(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___0(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___0(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___0, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___0, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___0(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___0, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___0(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___0(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___0(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___0(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___0, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___0(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___0, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___0[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___0[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___38[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___33[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___35[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___33[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___33[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___34[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___33[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___0  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___0  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___0(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___0, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___39[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___34[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___36[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___34[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___34[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___35[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___34[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___40[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___35[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___37[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___35[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___35[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___36[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___35[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___41[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___36[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___38[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___36[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___36[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___37[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___36[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___0[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___0(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___0(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___0(& p, " \t");
#line 726
  f[1] = mystrtok___0(& p, " \t");
#line 727
  f[2] = mystrtok___0(& p, " \t");
#line 728
  f[3] = mystrtok___0(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___0[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___1  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___0(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___0(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___0(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___0[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___42[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___37[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___39[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___37[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___37[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___38[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___37[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___43[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___39[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___44[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___38[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___40[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___38[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___38[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___40[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___38[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___0[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___45[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___39[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___41[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___39[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___39[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___41[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___39[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___0(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___0(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___0(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___46[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___40[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___42[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___40[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___40[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___42[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___40[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___0  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___0  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___0  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___0  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___0  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___0  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___0[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___0  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___0  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___0  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___0  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___0  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___0[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___0(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___0(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___0((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___0(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___0(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___0(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___0(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___0((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___0(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___0(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___0(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___0(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___0((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___0(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___0(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___0(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___0(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___0);
#line 240
  stat_root_dir___0 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___0);
#line 242
  stat_root_file___0 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___0) {
#line 245
    stat_tail___0 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___0 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___0 = stat_tail___0;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___0(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___0) {
#line 274
    stat_tail___0 = this;
#line 274
    stat_head___0 = stat_tail___0;
  } else {
#line 276
    stat_tail___0->next = this;
#line 277
    stat_tail___0 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___0(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___0) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___0) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___0);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___0);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___0) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___0  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___0(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___0(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___0(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___0) {
    {
#line 359
    dict_pool___0 = fr_pool_create___0();
    }
#line 360
    if (! dict_pool___0) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___0->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___0->page_free)->page_end)) {
    {
#line 368
    (dict_pool___0->page_free)->page_next = fr_pool_create___0();
    }
#line 369
    if (! (dict_pool___0->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___0->page_free = (dict_pool___0->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___0->page_free)->free_ptr;
#line 374
  (dict_pool___0->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___0->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___0(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___0  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___0  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___0  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___0(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___0(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___0((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___0, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___0, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___0(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___0((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___0(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___0(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___0, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___0((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___0(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___2(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___0(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___0(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___2(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___0(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___0(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___0(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___0(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___0(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___0(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___47[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___41[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___43[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___41[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___41[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___43[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___41[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___0(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___0(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___48[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___42[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___44[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___42[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___42[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___44[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___42[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___49[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___43[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___45[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___43[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___43[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___45[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___43[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___0[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___2  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___50[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___46[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___51[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___44[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___47[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___44[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___44[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___46[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___44[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___0(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___0(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___0(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___0(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___0(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___52[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___45[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___48[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___45[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___45[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___47[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___45[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___0[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___0[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___0(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___0[key & 255U] << 24) | ((int const   )reversed_byte___0[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___0[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___0[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___0(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___0[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___0[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___0[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___0[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___0(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___0(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___0(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___0(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___0(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___0(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___0(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___0(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___0(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___0(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___0(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___0(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___53[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___49[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___54[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___46[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___50[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___46[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___46[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___48[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___46[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___0[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___55[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___47[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___51[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___47[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___47[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___49[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___47[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___56[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___48[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___52[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___48[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___48[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___50[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___48[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___57[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___49[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___53[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___49[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___49[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___51[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___49[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___58[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___50[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___54[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___50[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___50[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___52[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___50[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___1  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___1  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___1  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___1(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___1(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___1(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___1(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___1(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___1;
#line 615
  salt_offset___1 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___1(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___1(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___1(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___1(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___1(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___1(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___1((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___1(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___1(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___1(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___1(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___1(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___1(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___1(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___1(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___1((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___1(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___1(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___59[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___51[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___55[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___51[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___51[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___53[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___51[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___60[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___52[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___56[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___52[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___52[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___54[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___52[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___1[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___1(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___61[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___53[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___57[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___53[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___53[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___55[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___53[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___1  =    {& Sentinel___1, & Sentinel___1, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___1(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___1)) {
    {
#line 60
    FreeWalker___1(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___1)) {
    {
#line 61
    FreeWalker___1(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___1(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___1)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___1)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___1)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___1(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___1)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___1)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___1)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___1(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___1(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___1(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___1(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___1(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___1(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___1(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___1)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___1)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___1(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___1)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___1(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___1(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___1)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___1)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___1(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___1)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___1(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___1(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___1)) {
    {
#line 523
    rcode = WalkNodePreOrder___1(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___1)) {
    {
#line 528
    rcode = WalkNodePreOrder___1(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___1(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___1)) {
    {
#line 545
    rcode = WalkNodeInOrder___1(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___1)) {
    {
#line 555
    rcode = WalkNodeInOrder___1(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___1(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___1)) {
    {
#line 572
    rcode = WalkNodeInOrder___1(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___1)) {
    {
#line 577
    rcode = WalkNodeInOrder___1(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___62[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___54[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___58[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___54[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___54[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___56[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___54[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___1(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___1(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___1[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___63[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___64[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___55[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___59[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___55[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___55[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___57[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___55[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___1(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_digest/rlm_digest.c"
static char const   rcsid___65[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___56[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___60[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___56[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___56[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___58[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___56[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 453 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
extern int debug_flag ;
#line 554
extern void ( /* format attribute */  radlog_request)(int lvl , int priority , REQUEST *request ,
                                                      char const   *msg  , ...) ;
#line 588
extern VALUE_PAIR *radius_paircreate(REQUEST *request , VALUE_PAIR **vps , int attribute ,
                                     int type ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_digest/rlm_digest.c"
static int digest_fix(REQUEST *request ) 
{ 
  VALUE_PAIR *vp ;
  int length ;
  int attrlen ;
  uint8_t *p ;
  int length___0 ;
  int attrlen___0 ;
  uint8_t *p___0 ;
  VALUE_PAIR *sub ;

  {
  {
#line 37
  vp = pairfind((request->packet)->vps, 206);
  }
#line 38
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
#line 39
    return (7);
  }
#line 45
  if (vp->length != 32UL) {
#line 46
    return (7);
  }
  {
#line 52
  vp = pairfind((request->packet)->vps, 207);
  }
#line 53
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
#line 54
    return (7);
  }
#line 60
  if (request) {
#line 60
    if (request->radlog) {
      {
#line 60
      (*(request->radlog))(1, 1, request, "Checking for correctly formatted Digest-Attributes");
      }
    }
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! vp) {
#line 61
      goto while_break;
    }
#line 62
    length = (int )vp->length;
#line 64
    p = & vp->data.octets[0];
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 69
      if (! (length > 0)) {
#line 69
        goto while_break___0;
      }
#line 73
      if ((int )*(p + 0) == 0) {
#line 73
        goto _L;
      } else
#line 73
      if ((int )*(p + 0) > 10) {
        _L: /* CIL Label */ 
#line 74
        if (request) {
#line 74
          if (request->radlog) {
            {
#line 74
            (*(request->radlog))(1, 1, request, "Not formatted as Digest-Attributes");
            }
          }
        }
#line 75
        return (7);
      }
#line 78
      attrlen = (int )*(p + 1);
#line 83
      if (attrlen < 3) {
#line 84
        if (request) {
#line 84
          if (request->radlog) {
            {
#line 84
            (*(request->radlog))(1, 1, request, "Not formatted as Digest-Attributes");
            }
          }
        }
#line 85
        return (7);
      }
#line 91
      if (attrlen > length) {
#line 92
        if (request) {
#line 92
          if (request->radlog) {
            {
#line 92
            (*(request->radlog))(1, 1, request, "Not formatted as Digest-Attributes");
            }
          }
        }
#line 93
        return (7);
      }
#line 96
      length -= attrlen;
#line 97
      p += attrlen;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 103
    vp = pairfind(vp->next, 207);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  if (request) {
#line 109
    if (request->radlog) {
      {
#line 109
      (*(request->radlog))(1, 1, request, "Digest-Attributes look OK.  Converting them to something more usful.");
      }
    }
  }
  {
#line 110
  vp = pairfind((request->packet)->vps, 207);
  }
  {
#line 111
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 111
    if (! vp) {
#line 111
      goto while_break___1;
    }
#line 112
    length___0 = (int )vp->length;
#line 114
    p___0 = & vp->data.octets[0];
    {
#line 120
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 120
      if (! (length___0 > 0)) {
#line 120
        goto while_break___2;
      }
#line 124
      if ((int )*(p___0 + 0) == 0) {
#line 124
        goto _L___0;
      } else
#line 124
      if ((int )*(p___0 + 0) > 10) {
        _L___0: /* CIL Label */ 
#line 125
        if (request) {
#line 125
          if (request->radlog) {
            {
#line 125
            (*(request->radlog))(1, 1, request, "ERROR: Received Digest-Attributes with invalid sub-attribute %d",
                                 (int )*(p___0 + 0));
            }
          }
        }
#line 126
        return (4);
      }
#line 129
      attrlen___0 = (int )*(p___0 + 1);
#line 134
      if (attrlen___0 < 3) {
#line 135
        if (request) {
#line 135
          if (request->radlog) {
            {
#line 135
            (*(request->radlog))(1, 1, request, "ERROR: Received Digest-Attributes with short sub-attribute %d, of length %d",
                                 (int )*(p___0 + 0), attrlen___0);
            }
          }
        }
#line 136
        return (4);
      }
#line 142
      if (attrlen___0 > length___0) {
#line 143
        if (request) {
#line 143
          if (request->radlog) {
            {
#line 143
            (*(request->radlog))(1, 1, request, "ERROR: Received Digest-Attributes with long sub-attribute %d, of length %d",
                                 (int )*(p___0 + 0), attrlen___0);
            }
          }
        }
#line 144
        return (4);
      }
      {
#line 153
      sub = radius_paircreate(request, & (request->packet)->vps, 1062 + (int )*(p___0 + 0),
                              0);
#line 156
      memcpy((void */* __restrict  */)(& sub->data.octets[0]), (void const   */* __restrict  */)(p___0 + 2),
             (size_t )(attrlen___0 - 2));
#line 157
      sub->data.octets[attrlen___0 - 2] = (uint8_t )'\000';
#line 158
      sub->length = (size_t )(attrlen___0 - 2);
      }
#line 160
      if (debug_flag > 1) {
#line 160
        if (fr_log_fp) {
          {
#line 161
          vp_print(fr_log_fp, sub);
          }
        }
      }
#line 169
      length___0 -= attrlen___0;
#line 170
      p___0 += attrlen___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 176
    vp = pairfind(vp->next, 207);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 179
  return (2);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_digest/rlm_digest.c"
static int digest_authorize(void *instance , REQUEST *request ) 
{ 
  int rcode ;
  VALUE_PAIR *tmp ;
  VALUE_PAIR *tmp___0 ;

  {
  {
#line 187
  instance = instance;
#line 192
  rcode = digest_fix(request);
  }
#line 193
  if (rcode != 2) {
#line 193
    return (rcode);
  }
  {
#line 196
  tmp = pairfind(request->config_items, 1000);
  }
#line 196
  if (tmp) {
#line 197
    if (request) {
#line 197
      if (request->radlog) {
        {
#line 197
        (*(request->radlog))(1, 2, request, "WARNING: Auth-Type already set.  Not setting to DIGEST");
        }
      }
    }
#line 198
    return (7);
  }
#line 204
  if (request) {
#line 204
    if (request->radlog) {
      {
#line 204
      (*(request->radlog))(1, 1, request, "Adding Auth-Type = DIGEST");
      }
    }
  }
  {
#line 205
  tmp___0 = pairmake("Auth-Type", "DIGEST", 11);
#line 205
  pairadd(& request->config_items, tmp___0);
  }
#line 208
  return (2);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_digest/rlm_digest.c"
static int digest_authenticate(void *instance , REQUEST *request ) 
{ 
  int i ;
  size_t a1_len ;
  size_t a2_len ;
  size_t kd_len ;
  uint8_t a1[1275] ;
  uint8_t a2[765] ;
  uint8_t kd[1275] ;
  uint8_t hash[16] ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *passwd ;
  VALUE_PAIR *algo ;
  VALUE_PAIR *qop ;
  VALUE_PAIR *nonce ;
  int rcode ;
  VALUE_PAIR *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  VALUE_PAIR *body ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 225
  instance = instance;
#line 231
  passwd = pairfind(request->config_items, 1081);
  }
#line 232
  if (passwd) {
#line 233
    if (passwd->length != 32UL) {
      {
#line 234
      radlog_request(2, 0, request, "Digest-HA1 has invalid length, authentication failed.");
      }
#line 235
      return (4);
    }
  } else {
    {
#line 238
    passwd = pairfind(request->config_items, 1100);
    }
  }
#line 240
  if (! passwd) {
    {
#line 241
    radlog_request(2, 0, request, "Cleartext-Password or Digest-HA1 is required for authentication.");
    }
#line 242
    return (4);
  }
  {
#line 248
  vp = pairfind((request->packet)->vps, 207);
  }
#line 249
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    error: 
#line 251
    if (request) {
#line 251
      if (request->radlog) {
        {
#line 251
        (*(request->radlog))(1, 1, request, "ERROR: You set \'Auth-Type = Digest\' for a request that does not contain any digest attributes!");
        }
      }
    }
#line 252
    return (4);
  }
  {
#line 262
  tmp = pairfind((request->packet)->vps, 1064);
  }
#line 262
  if (! tmp) {
    {
#line 265
    rcode = digest_fix(request);
    }
#line 271
    if (rcode == 7) {
#line 271
      goto error;
    }
#line 273
    if (rcode != 2) {
#line 273
      return (rcode);
    }
  }
  {
#line 279
  nonce = pairfind((request->packet)->vps, 1064);
  }
#line 280
  if (! nonce) {
#line 281
    if (request) {
#line 281
      if (request->radlog) {
        {
#line 281
        (*(request->radlog))(1, 1, request, "ERROR: No Digest-Nonce: Cannot perform Digest authentication");
        }
      }
    }
#line 282
    return (4);
  }
  {
#line 288
  vp = pairfind((request->packet)->vps, 1072);
  }
#line 289
  if (! vp) {
#line 290
    if (request) {
#line 290
      if (request->radlog) {
        {
#line 290
        (*(request->radlog))(1, 1, request, "ERROR: No Digest-User-Name: Cannot perform Digest authentication");
        }
      }
    }
#line 291
    return (4);
  }
  {
#line 293
  memcpy((void */* __restrict  */)(& a1[0]), (void const   */* __restrict  */)(& vp->data.octets[0]),
         vp->length);
#line 294
  a1_len = vp->length;
#line 296
  a1[a1_len] = (uint8_t )':';
#line 297
  a1_len ++;
#line 299
  vp = pairfind((request->packet)->vps, 1063);
  }
#line 300
  if (! vp) {
#line 301
    if (request) {
#line 301
      if (request->radlog) {
        {
#line 301
        (*(request->radlog))(1, 1, request, "ERROR: No Digest-Realm: Cannot perform Digest authentication");
        }
      }
    }
#line 302
    return (4);
  }
  {
#line 304
  memcpy((void */* __restrict  */)(& a1[a1_len]), (void const   */* __restrict  */)(& vp->data.octets[0]),
         vp->length);
#line 305
  a1_len += vp->length;
#line 307
  a1[a1_len] = (uint8_t )':';
#line 308
  a1_len ++;
  }
#line 310
  if (passwd->attribute == 1100) {
    {
#line 311
    memcpy((void */* __restrict  */)(& a1[a1_len]), (void const   */* __restrict  */)(& passwd->data.octets[0]),
           passwd->length);
#line 312
    a1_len += passwd->length;
#line 313
    a1[a1_len] = (uint8_t )'\000';
    }
#line 314
    if (request) {
#line 314
      if (request->radlog) {
        {
#line 314
        (*(request->radlog))(1, 2, request, "A1 = %s", a1);
        }
      }
    }
  } else {
#line 316
    a1[a1_len] = (uint8_t )'\000';
#line 317
    if (request) {
#line 317
      if (request->radlog) {
        {
#line 317
        (*(request->radlog))(1, 2, request, "A1 = %s (using Digest-HA1)", a1);
        }
      }
    }
#line 318
    a1_len = (size_t )16;
  }
  {
#line 325
  algo = pairfind((request->packet)->vps, 1068);
  }
#line 326
  if ((unsigned long )algo == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else {
    {
#line 326
    tmp___3 = strcasecmp((char const   *)(algo->data.strvalue), "MD5");
    }
#line 326
    if (tmp___3 == 0) {
      _L: /* CIL Label */ 
#line 331
      if (passwd->attribute == 1081) {
        {
#line 332
        tmp___0 = fr_hex2bin((char const   *)(passwd->data.strvalue), & a1[0], (size_t )16);
        }
#line 332
        if (tmp___0 != 16UL) {
#line 333
          if (request) {
#line 333
            if (request->radlog) {
              {
#line 333
              (*(request->radlog))(1, 2, request, "Invalid text in Digest-HA1");
              }
            }
          }
#line 334
          return (4);
        }
      }
    } else {
      {
#line 338
      tmp___2 = strcasecmp((char const   *)(algo->data.strvalue), "MD5-sess");
      }
#line 338
      if (tmp___2 == 0) {
#line 345
        if (passwd->attribute == 1100) {
          {
#line 346
          fr_md5_calc(hash, (uint8_t const   *)(& a1[0]), (unsigned int )a1_len);
#line 347
          fr_bin2hex((uint8_t const   *)(hash), (char *)(& a1[0]), (size_t )16);
          }
        } else {
          {
#line 349
          memcpy((void */* __restrict  */)(& a1[0]), (void const   */* __restrict  */)(passwd->data.strvalue),
                 (size_t )32);
          }
        }
#line 351
        a1_len = (size_t )32;
#line 353
        a1[a1_len] = (uint8_t )':';
#line 354
        a1_len ++;
#line 359
        if ((nonce->length & 1UL) != 0UL) {
#line 360
          if (request) {
#line 360
            if (request->radlog) {
              {
#line 360
              (*(request->radlog))(1, 1, request, "ERROR: Received Digest-Nonce hex string with invalid length: Cannot perform Digest authentication");
              }
            }
          }
#line 361
          return (4);
        }
        {
#line 363
        memcpy((void */* __restrict  */)(& a1[a1_len]), (void const   */* __restrict  */)(& nonce->data.octets[0]),
               nonce->length);
#line 364
        a1_len += nonce->length;
#line 366
        a1[a1_len] = (uint8_t )':';
#line 367
        a1_len ++;
#line 369
        vp = pairfind((request->packet)->vps, 1070);
        }
#line 370
        if (! vp) {
#line 371
          if (request) {
#line 371
            if (request->radlog) {
              {
#line 371
              (*(request->radlog))(1, 1, request, "ERROR: No Digest-CNonce: Cannot perform Digest authentication");
              }
            }
          }
#line 372
          return (4);
        }
#line 378
        if ((vp->length & 1UL) != 0UL) {
#line 379
          if (request) {
#line 379
            if (request->radlog) {
              {
#line 379
              (*(request->radlog))(1, 1, request, "ERROR: Received Digest-CNonce hex string with invalid length: Cannot perform Digest authentication");
              }
            }
          }
#line 380
          return (4);
        }
        {
#line 382
        memcpy((void */* __restrict  */)(& a1[a1_len]), (void const   */* __restrict  */)(& vp->data.octets[0]),
               vp->length);
#line 383
        a1_len += vp->length;
        }
      } else
#line 385
      if ((unsigned long )algo != (unsigned long )((void *)0)) {
        {
#line 385
        tmp___1 = strcasecmp((char const   *)(algo->data.strvalue), "MD5");
        }
#line 385
        if (tmp___1 != 0) {
#line 391
          if (request) {
#line 391
            if (request->radlog) {
              {
#line 391
              (*(request->radlog))(1, 1, request, "ERROR: Unknown Digest-Algorithm \"%s\": Cannot perform Digest authentication",
                                   vp->data.strvalue);
              }
            }
          }
#line 392
          return (4);
        }
      }
    }
  }
  {
#line 398
  vp = pairfind((request->packet)->vps, 1065);
  }
#line 399
  if (! vp) {
#line 400
    if (request) {
#line 400
      if (request->radlog) {
        {
#line 400
        (*(request->radlog))(1, 1, request, "ERROR: No Digest-Method: Cannot perform Digest authentication");
        }
      }
    }
#line 401
    return (4);
  }
  {
#line 403
  memcpy((void */* __restrict  */)(& a2[0]), (void const   */* __restrict  */)(& vp->data.octets[0]),
         vp->length);
#line 404
  a2_len = vp->length;
#line 406
  a2[a2_len] = (uint8_t )':';
#line 407
  a2_len ++;
#line 409
  vp = pairfind((request->packet)->vps, 1066);
  }
#line 410
  if (! vp) {
#line 411
    if (request) {
#line 411
      if (request->radlog) {
        {
#line 411
        (*(request->radlog))(1, 1, request, "ERROR: No Digest-URI: Cannot perform Digest authentication");
        }
      }
    }
#line 412
    return (4);
  }
  {
#line 414
  memcpy((void */* __restrict  */)(& a2[a2_len]), (void const   */* __restrict  */)(& vp->data.octets[0]),
         vp->length);
#line 415
  a2_len += vp->length;
#line 420
  qop = pairfind((request->packet)->vps, 1067);
  }
#line 421
  if ((unsigned long )qop != (unsigned long )((void *)0)) {
    {
#line 421
    tmp___5 = strcasecmp((char const   *)(qop->data.strvalue), "auth-int");
    }
#line 421
    if (tmp___5 == 0) {
      {
#line 428
      a2[a2_len] = (uint8_t )':';
#line 429
      a2_len ++;
#line 434
      body = pairfind((request->packet)->vps, 1069);
      }
#line 435
      if (! body) {
#line 436
        if (request) {
#line 436
          if (request->radlog) {
            {
#line 436
            (*(request->radlog))(1, 1, request, "ERROR: No Digest-Body-Digest: Cannot perform Digest authentication");
            }
          }
        }
#line 437
        return (4);
      }
#line 440
      if (a2_len + body->length > sizeof(a2)) {
#line 441
        if (request) {
#line 441
          if (request->radlog) {
            {
#line 441
            (*(request->radlog))(1, 1, request, "ERROR: Digest-Body-Digest is too long");
            }
          }
        }
#line 442
        return (4);
      }
      {
#line 445
      memcpy((void */* __restrict  */)(a2 + a2_len), (void const   */* __restrict  */)(body->data.octets),
             body->length);
#line 446
      a2_len += body->length;
      }
    } else {
#line 421
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 448
  if ((unsigned long )qop != (unsigned long )((void *)0)) {
    {
#line 448
    tmp___4 = strcasecmp((char const   *)(qop->data.strvalue), "auth");
    }
#line 448
    if (tmp___4 != 0) {
#line 450
      if (request) {
#line 450
        if (request->radlog) {
          {
#line 450
          (*(request->radlog))(1, 1, request, "ERROR: Unknown Digest-QOP \"%s\": Cannot perform Digest authentication",
                               qop->data.strvalue);
          }
        }
      }
#line 451
      return (4);
    }
  }
#line 454
  a2[a2_len] = (uint8_t )'\000';
#line 455
  if (request) {
#line 455
    if (request->radlog) {
      {
#line 455
      (*(request->radlog))(1, 2, request, "A2 = %s", a2);
      }
    }
  }
#line 462
  if ((unsigned long )algo != (unsigned long )((void *)0)) {
    {
#line 462
    tmp___6 = strcasecmp((char const   *)(algo->data.strvalue), "MD5-Sess");
    }
#line 462
    if (tmp___6 == 0) {
      {
#line 465
      a1[a1_len] = (uint8_t )'\000';
#line 466
      fr_md5_calc(& hash[0], (uint8_t const   *)(& a1[0]), (unsigned int )a1_len);
      }
    } else {
#line 462
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 462
  if (passwd->attribute == 1100) {
    {
#line 465
    a1[a1_len] = (uint8_t )'\000';
#line 466
    fr_md5_calc(& hash[0], (uint8_t const   *)(& a1[0]), (unsigned int )a1_len);
    }
  } else {
    {
#line 468
    memcpy((void */* __restrict  */)(& hash[0]), (void const   */* __restrict  */)(& a1[0]),
           a1_len);
    }
  }
  {
#line 470
  fr_bin2hex((uint8_t const   *)(hash), (char *)(kd), sizeof(hash));
  }
#line 473
  if (debug_flag > 1) {
    {
#line 474
    fr_printf_log("H(A1) = ");
#line 475
    i = 0;
    }
    {
#line 475
    while (1) {
      while_continue: /* CIL Label */ ;
#line 475
      if (! (i < 16)) {
#line 475
        goto while_break;
      }
      {
#line 476
      fr_printf_log("%02x", (int )hash[i]);
#line 475
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 478
    fr_printf_log("\n");
    }
  }
  {
#line 481
  kd_len = (size_t )32;
#line 483
  kd[kd_len] = (uint8_t )':';
#line 484
  kd_len ++;
#line 486
  memcpy((void */* __restrict  */)(& kd[kd_len]), (void const   */* __restrict  */)(nonce->data.octets),
         nonce->length);
#line 487
  kd_len += nonce->length;
  }
#line 492
  if (! (! qop)) {
    {
#line 502
    kd[kd_len] = (uint8_t )':';
#line 503
    kd_len ++;
#line 505
    vp = pairfind((request->packet)->vps, 1071);
    }
#line 506
    if (! vp) {
#line 507
      if (request) {
#line 507
        if (request->radlog) {
          {
#line 507
          (*(request->radlog))(1, 1, request, "ERROR: No Digest-Nonce-Count: Cannot perform Digest authentication");
          }
        }
      }
#line 508
      return (4);
    }
    {
#line 510
    memcpy((void */* __restrict  */)(& kd[kd_len]), (void const   */* __restrict  */)(& vp->data.octets[0]),
           vp->length);
#line 511
    kd_len += vp->length;
#line 513
    kd[kd_len] = (uint8_t )':';
#line 514
    kd_len ++;
#line 516
    vp = pairfind((request->packet)->vps, 1070);
    }
#line 517
    if (! vp) {
#line 518
      if (request) {
#line 518
        if (request->radlog) {
          {
#line 518
          (*(request->radlog))(1, 1, request, "ERROR: No Digest-CNonce: Cannot perform Digest authentication");
          }
        }
      }
#line 519
      return (4);
    }
    {
#line 521
    memcpy((void */* __restrict  */)(& kd[kd_len]), (void const   */* __restrict  */)(& vp->data.octets[0]),
           vp->length);
#line 522
    kd_len += vp->length;
#line 524
    kd[kd_len] = (uint8_t )':';
#line 525
    kd_len ++;
#line 527
    memcpy((void */* __restrict  */)(& kd[kd_len]), (void const   */* __restrict  */)(& qop->data.octets[0]),
           qop->length);
#line 528
    kd_len += qop->length;
    }
  }
  {
#line 534
  kd[kd_len] = (uint8_t )':';
#line 535
  kd_len ++;
#line 537
  fr_md5_calc(& hash[0], (uint8_t const   *)(& a2[0]), (unsigned int )a2_len);
#line 539
  fr_bin2hex((uint8_t const   *)(hash), (char *)(kd) + kd_len, sizeof(hash));
  }
#line 542
  if (debug_flag > 1) {
    {
#line 543
    fr_printf_log("H(A2) = ");
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
      {
#line 545
      fr_printf_log("%02x", (int )hash[i]);
#line 544
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 547
    fr_printf_log("\n");
    }
  }
#line 550
  kd_len += 32UL;
#line 552
  kd[kd_len] = (uint8_t )0;
#line 554
  if (request) {
#line 554
    if (request->radlog) {
      {
#line 554
      (*(request->radlog))(1, 2, request, "KD = %s\n", & kd[0]);
      }
    }
  }
  {
#line 559
  fr_md5_calc(& hash[0], (uint8_t const   *)(& kd[0]), (unsigned int )kd_len);
#line 560
  memcpy((void */* __restrict  */)(& kd[0]), (void const   */* __restrict  */)(& hash[0]),
         (size_t )16);
#line 565
  vp = pairfind((request->packet)->vps, 206);
  }
#line 566
  if (! vp) {
#line 567
    if (request) {
#line 567
      if (request->radlog) {
        {
#line 567
        (*(request->radlog))(1, 1, request, "ERROR: No Digest-Response attribute in the request.  Cannot perform digest authentication");
        }
      }
    }
#line 568
    return (4);
  }
  {
#line 571
  tmp___7 = fr_hex2bin((char const   *)(& vp->data.strvalue[0]), & hash[0], vp->length >> 1);
  }
#line 571
  if (tmp___7 != vp->length >> 1) {
#line 572
    if (request) {
#line 572
      if (request->radlog) {
        {
#line 572
        (*(request->radlog))(1, 2, request, "Invalid text in Digest-Response");
        }
      }
    }
#line 573
    return (4);
  }
#line 577
  if (debug_flag > 1) {
    {
#line 578
    fr_printf_log("EXPECTED ");
#line 579
    i = 0;
    }
    {
#line 579
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 579
      if (! (i < 16)) {
#line 579
        goto while_break___1;
      }
      {
#line 580
      fr_printf_log("%02x", (int )kd[i]);
#line 579
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 582
    fr_printf_log("\n");
#line 584
    fr_printf_log("RECEIVED ");
#line 585
    i = 0;
    }
    {
#line 585
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 585
      if (! (i < 16)) {
#line 585
        goto while_break___2;
      }
      {
#line 586
      fr_printf_log("%02x", (int )hash[i]);
#line 585
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 588
    fr_printf_log("\n");
    }
  }
  {
#line 595
  tmp___8 = memcmp((void const   *)(& kd[0]), (void const   *)(& hash[0]), (size_t )16);
  }
#line 595
  if (tmp___8 == 0) {
#line 596
    return (2);
  }
#line 599
  if (request) {
#line 599
    if (request->radlog) {
      {
#line 599
      (*(request->radlog))(1, 1, request, "FAILED authentication");
      }
    }
  }
#line 600
  return (0);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_digest/rlm_digest.c"
module_t rlm_digest  =    {4109257426U, "digest", 1 << 1, (int (*)(CONF_SECTION *mod_cs , void **instance ))((void *)0),
    (int (*)(void *instance ))((void *)0), {& digest_authenticate, & digest_authorize,
                                            (packetmethod )((void *)0), (packetmethod )((void *)0),
                                            (packetmethod )((void *)0), (packetmethod )((void *)0),
                                            (packetmethod )((void *)0), (packetmethod )((void *)0)}};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___66[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___57[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___61[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___57[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___57[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___59[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___57[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___1[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___1[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___1[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___1[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___1[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___3(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___1(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___1, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___1, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___1, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___1(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___1, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___1(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___1(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___1(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___1(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___1, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___1, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___1(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___1, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___1(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___1(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___1(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___1(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___1, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___1(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___1, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___1[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___1[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___67[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___58[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___62[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___58[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___58[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___60[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___58[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___1  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___1  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___1(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___1, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___68[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___59[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___63[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___59[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___59[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___61[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___59[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___69[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___60[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___64[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___60[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___60[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___62[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___60[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___70[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___61[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___65[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___61[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___61[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___63[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___61[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___1[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___1(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___1(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___1(& p, " \t");
#line 726
  f[1] = mystrtok___1(& p, " \t");
#line 727
  f[2] = mystrtok___1(& p, " \t");
#line 728
  f[3] = mystrtok___1(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___1[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___3  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___1(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___1(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___1(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___1[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___71[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___62[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___66[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___62[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___62[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___64[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___62[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___72[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___65[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___73[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___63[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___67[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___63[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___63[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___66[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___63[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___1[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___74[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___64[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___68[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___64[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___64[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___67[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___64[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___1(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___1(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___1(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___75[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___65[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___69[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___65[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___65[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___68[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___65[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___1  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___1  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___1  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___1  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___1  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___1  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___1[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___1  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___1  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___1  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___1  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___1  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___1[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___1(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___1(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___1((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___1(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___1(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___1(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___1(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___1((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___1(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___1(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___1(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___1(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___1((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___1(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___1(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___1(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___1(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___1);
#line 240
  stat_root_dir___1 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___1);
#line 242
  stat_root_file___1 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___1) {
#line 245
    stat_tail___1 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___1;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___1 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___1 = stat_tail___1;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___1(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___1) {
#line 274
    stat_tail___1 = this;
#line 274
    stat_head___1 = stat_tail___1;
  } else {
#line 276
    stat_tail___1->next = this;
#line 277
    stat_tail___1 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___1(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___1) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___1) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___1);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___1);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___1) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___1;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___1  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___1(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___1(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___1(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___1) {
    {
#line 359
    dict_pool___1 = fr_pool_create___1();
    }
#line 360
    if (! dict_pool___1) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___1->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___1->page_free)->page_end)) {
    {
#line 368
    (dict_pool___1->page_free)->page_next = fr_pool_create___1();
    }
#line 369
    if (! (dict_pool___1->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___1->page_free = (dict_pool___1->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___1->page_free)->free_ptr;
#line 374
  (dict_pool___1->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___1->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___1(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___1  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___1  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___1  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___1(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___1(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___1((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___1, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___1, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___1(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___1((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___1(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___1(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___1, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___1((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___1(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___4(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___1(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___1(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___4(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___1(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___1(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___1(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___1(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___1(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___1(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___76[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___66[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___70[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___66[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___66[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___69[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___66[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___1(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___1(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___77[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___67[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___71[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___67[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___67[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___70[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___67[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___78[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___68[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___72[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___68[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___68[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___71[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___68[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___1[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___4  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___79[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___73[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___80[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___69[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___74[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___69[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___69[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___72[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___69[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___1(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___1(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___1(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___1(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___1(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___81[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___70[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___75[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___70[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___70[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___73[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___70[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___1[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___1[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___1(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___1[key & 255U] << 24) | ((int const   )reversed_byte___1[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___1[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___1[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___1(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___1[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___1[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___1[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___1[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___1(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___1(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___1(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___1(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___1(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___1(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___1(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___1(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___1(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___1(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___1(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___1(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___82[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___76[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___83[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___71[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___77[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___71[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___71[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___74[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___71[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___1[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___84[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___72[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___78[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___72[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___72[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___75[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___72[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___85[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___73[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___79[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___73[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___73[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___76[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___73[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___86[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___74[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___80[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___74[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___74[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___77[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___74[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___87[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___75[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___81[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___75[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___75[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___78[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___75[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___2  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___2  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___2  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___2(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___2(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___2(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___2(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___2(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___2;
#line 615
  salt_offset___2 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___2(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___2(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___2(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___2(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___2(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___2(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___2((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___2(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___2(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___2(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___2(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___2(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___2(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___2(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___2(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___2((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___2(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___2(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___88[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___76[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___82[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___76[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___76[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___79[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___76[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___89[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___77[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___83[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___77[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___77[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___80[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___77[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___2[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___2(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___90[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___78[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___84[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___78[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___78[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___81[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___78[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___2  =    {& Sentinel___2, & Sentinel___2, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___2(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___2)) {
    {
#line 60
    FreeWalker___2(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___2)) {
    {
#line 61
    FreeWalker___2(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___2(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___2)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___2)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___2)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___2(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___2)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___2)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___2)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___2(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___2(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___2(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___2(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___2(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___2(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___2(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___2)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___2)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___2(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___2)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___2(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___2(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___2)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___2)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___2(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___2)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___2(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___2(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___2)) {
    {
#line 523
    rcode = WalkNodePreOrder___2(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___2)) {
    {
#line 528
    rcode = WalkNodePreOrder___2(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___2(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___2)) {
    {
#line 545
    rcode = WalkNodeInOrder___2(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___2)) {
    {
#line 555
    rcode = WalkNodeInOrder___2(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___2(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___2)) {
    {
#line 572
    rcode = WalkNodeInOrder___2(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___2)) {
    {
#line 577
    rcode = WalkNodeInOrder___2(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___91[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___79[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___85[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___79[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___79[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___82[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___79[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___2(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___2(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___2[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___92[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___93[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___80[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___86[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___80[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___80[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___83[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___80[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___2(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___94[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___81[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___87[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___81[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___81[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___84[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___81[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___2[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___2[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___2[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___2[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___2[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___5(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___2(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___2, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___2, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___2, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___2(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___2, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___2(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___2(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___2(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___2(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___2, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___2, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___2(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___2, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___2(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___2(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___2(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___2(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___2, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___2(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___2, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___2[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___2[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___95[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___82[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___88[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___82[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___82[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___85[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___82[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___2  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___2  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___2(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___2, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___96[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___83[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___89[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___83[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___83[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___86[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___83[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___97[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___84[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___90[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___84[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___84[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___87[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___84[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___98[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___85[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___91[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___85[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___85[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___88[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___85[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___2[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___2(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___2(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___2(& p, " \t");
#line 726
  f[1] = mystrtok___2(& p, " \t");
#line 727
  f[2] = mystrtok___2(& p, " \t");
#line 728
  f[3] = mystrtok___2(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___2[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___5  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___2(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___2(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___2(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___2[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___99[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___86[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___92[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___86[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___86[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___89[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___86[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___100[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___90[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___101[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___87[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___93[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___87[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___87[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___91[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___87[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___2[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___102[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___88[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___94[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___88[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___88[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___92[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___88[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___2(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___2(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___2(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___103[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___89[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___95[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___89[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___89[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___93[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___89[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___2  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___2  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___2  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___2  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___2  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___2  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___2[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___2  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___2  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___2  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___2  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___2  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___2[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___2(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___2(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___2((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___2(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___2(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___2(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___2(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___2((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___2(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___2(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___2(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___2(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___2((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___2(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___2(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___2(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___2(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___2);
#line 240
  stat_root_dir___2 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___2);
#line 242
  stat_root_file___2 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___2) {
#line 245
    stat_tail___2 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___2;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___2 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___2 = stat_tail___2;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___2(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___2) {
#line 274
    stat_tail___2 = this;
#line 274
    stat_head___2 = stat_tail___2;
  } else {
#line 276
    stat_tail___2->next = this;
#line 277
    stat_tail___2 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___2(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___2) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___2) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___2);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___2);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___2) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___2;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___2  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___2(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___2(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___2(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___2) {
    {
#line 359
    dict_pool___2 = fr_pool_create___2();
    }
#line 360
    if (! dict_pool___2) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___2->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___2->page_free)->page_end)) {
    {
#line 368
    (dict_pool___2->page_free)->page_next = fr_pool_create___2();
    }
#line 369
    if (! (dict_pool___2->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___2->page_free = (dict_pool___2->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___2->page_free)->free_ptr;
#line 374
  (dict_pool___2->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___2->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___2(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___2  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___2  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___2  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___2(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___2(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___2((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___2, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___2, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___2(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___2((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___2(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___2(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___2, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___2((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___2(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___6(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___2(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___2(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___6(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___2(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___2(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___2(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___2(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___2(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___2(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static char const   rcsid___104[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___90[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___96[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___90[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___90[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___94[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___90[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69
extern CONF_SECTION *cf_section_sub_find(CONF_SECTION const   * , char const   *name ) ;
#line 77
extern char const   *cf_pair_attr(CONF_PAIR *pair ) ;
#line 93
extern CONF_ITEM *cf_item_find_next(CONF_SECTION *section , CONF_ITEM *item ) ;
#line 96
extern int cf_item_is_pair(CONF_ITEM *item ) ;
#line 97
extern CONF_PAIR *cf_itemtopair(CONF_ITEM *item ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 498 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
extern int rad_mkdir(char *directory , int mode ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h___1[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/rad_assert.h"
static char const   rcsid_rad_assert_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/detail.h"
static char const   rcsid_detail_h[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static CONF_PARSER const   module_config___0[7]  = {      {"detailfile", 100, (unsigned long )(& ((struct detail_instance *)0)->detailfile),
      (void *)0, "%A/%{Client-IP-Address}/detail"}, 
        {"header", 100, (unsigned long )(& ((struct detail_instance *)0)->header), (void *)0,
      "%t"}, 
        {"detailperm", 1, (unsigned long )(& ((struct detail_instance *)0)->detailperm),
      (void *)0, "0600"}, 
        {"dirperm", 1, (unsigned long )(& ((struct detail_instance *)0)->dirperm), (void *)0,
      "0755"}, 
        {"locking", 101, (unsigned long )(& ((struct detail_instance *)0)->locking),
      (void *)0, "no"}, 
        {"log_packet_header", 101, (unsigned long )(& ((struct detail_instance *)0)->log_srcdst),
      (void *)0, "no"}, 
        {(char const   *)((void *)0), -1, (size_t )0, (void *)0, (char const   *)((void *)0)}};
#line 83 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_detach(void *instance ) 
{ 
  struct detail_instance *inst ;

  {
#line 85
  inst = (struct detail_instance *)instance;
#line 86
  if (inst->ht) {
    {
#line 86
    fr_hash_table_free(inst->ht);
    }
  }
  {
#line 88
  free((void *)inst);
  }
#line 89
  return (0);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static uint32_t detail_hash(void const   *data ) 
{ 
  DICT_ATTR const   *da ;
  uint32_t tmp ;

  {
  {
#line 95
  da = (DICT_ATTR const   *)data;
#line 96
  tmp = fr_hash((void const   *)(& da->attr), sizeof(da->attr));
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_cmp(void const   *a , void const   *b ) 
{ 


  {
#line 101
  return ((int )(((DICT_ATTR const   *)a)->attr - ((DICT_ATTR const   *)b)->attr));
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_instantiate(CONF_SECTION *conf , void **instance ) 
{ 
  struct detail_instance *inst ;
  CONF_SECTION *cs ;
  void *tmp ;
  int tmp___0 ;
  CONF_ITEM *ci ;
  char const   *attr ;
  DICT_ATTR *da ;
  int tmp___1 ;
  CONF_PAIR *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 113
  tmp = rad_malloc(sizeof(*inst));
#line 113
  inst = (struct detail_instance *)tmp;
  }
#line 114
  if (! inst) {
#line 115
    return (-1);
  }
  {
#line 117
  memset((void *)inst, 0, sizeof(*inst));
#line 119
  tmp___0 = cf_section_parse(conf, (void *)inst, module_config___0);
  }
#line 119
  if (tmp___0 < 0) {
    {
#line 120
    detail_detach((void *)inst);
    }
#line 121
    return (-1);
  }
  {
#line 127
  cs = cf_section_sub_find((CONF_SECTION const   *)conf, "suppress");
  }
#line 128
  if (cs) {
    {
#line 131
    inst->ht = fr_hash_table_create(& detail_hash, & detail_cmp, (void (*)(void * ))((void *)0));
#line 134
    ci = cf_item_find_next(cs, (CONF_ITEM *)((void *)0));
    }
    {
#line 134
    while (1) {
      while_continue: /* CIL Label */ ;
#line 134
      if (! ((unsigned long )ci != (unsigned long )((void *)0))) {
#line 134
        goto while_break;
      }
      {
#line 140
      tmp___1 = cf_item_is_pair(ci);
      }
#line 140
      if (! tmp___1) {
#line 140
        goto __Cont;
      }
      {
#line 142
      tmp___2 = cf_itemtopair(ci);
#line 142
      attr = cf_pair_attr(tmp___2);
      }
#line 143
      if (! attr) {
#line 143
        goto __Cont;
      }
      {
#line 145
      da = dict_attrbyname(attr);
      }
#line 146
      if (! da) {
        {
#line 147
        radlog(3, "rlm_detail: WARNING: No such attribute %s: Cannot suppress printing it.",
               attr);
        }
#line 148
        goto __Cont;
      }
      {
#line 157
      tmp___3 = fr_hash_table_insert(inst->ht, (void *)da);
      }
#line 157
      if (! tmp___3) {
        {
#line 158
        radlog(4, "rlm_detail: Failed trying to remember %s", attr);
#line 159
        detail_detach((void *)inst);
        }
#line 160
        return (-1);
      }
      __Cont: /* CIL Label */ 
      {
#line 134
      ci = cf_item_find_next(cs, ci);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 166
  *instance = (void *)inst;
#line 167
  return (0);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int do_detail(void *instance , REQUEST *request , RADIUS_PACKET *packet , int compat ) 
{ 
  int outfd ;
  char timestamp[256] ;
  char buffer[8192] ;
  char *p ;
  struct stat st ;
  int locked ;
  int lock_count ;
  struct timeval tv ;
  VALUE_PAIR *pair ;
  off_t fsize ;
  FILE *fp ;
  struct detail_instance *inst ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  VALUE_PAIR src_vp ;
  VALUE_PAIR dst_vp ;
  DICT_ATTR da ;
  void *tmp___13 ;
  char proxy_buffer[128] ;
  int tmp___14 ;

  {
#line 188
  inst = (struct detail_instance *)instance;
#line 195
  if (! packet) {
#line 196
    return (7);
  }
  {
#line 207
  tmp = radius_xlat(buffer, (int )sizeof(buffer), (char const   *)inst->detailfile,
                    request, (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
  }
#line 207
  if (tmp == 0) {
    {
#line 208
    radlog_request(4, 0, request, "rlm_detail: Failed to expand detail file %s", inst->detailfile);
    }
#line 210
    return (1);
  }
#line 212
  if (request) {
#line 212
    if (request->radlog) {
      {
#line 212
      (*(request->radlog))(1, 2, request, "%s expands to %s", inst->detailfile, buffer);
      }
    }
  }
#line 222
  if ((unsigned long )request->listener == 4UL) {
    {
#line 222
    tmp___0 = fnmatch((char const   *)((listen_detail_t *)(request->listener)->data)->filename,
                      (char const   *)(buffer), 1 | (1 << 2));
    }
#line 222
    if (tmp___0 == 0) {
#line 225
      if (request) {
#line 225
        if (request->radlog) {
          {
#line 225
          (*(request->radlog))(1, 2, request, "WARNING: Suppressing infinite loop.");
          }
        }
      }
#line 226
      return (7);
    }
  }
  {
#line 234
  p = strrchr((char const   *)(buffer), '/');
  }
#line 240
  if (p) {
    {
#line 241
    *p = (char )'\000';
#line 251
    tmp___3 = rad_mkdir(buffer, inst->dirperm);
    }
#line 251
    if (tmp___3 < 0) {
      {
#line 252
      tmp___1 = __errno_location();
#line 252
      tmp___2 = strerror(*tmp___1);
#line 252
      radlog_request(4, 0, request, "rlm_detail: Failed to create directory %s: %s",
                     buffer, tmp___2);
      }
#line 253
      return (1);
    }
#line 256
    *p = (char )'/';
  }
#line 259
  locked = 0;
#line 260
  lock_count = 0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 266
    outfd = open((char const   *)(buffer), 1089, inst->detailperm);
    }
#line 266
    if (outfd < 0) {
      {
#line 268
      tmp___4 = __errno_location();
#line 268
      tmp___5 = strerror(*tmp___4);
#line 268
      radlog_request(4, 0, request, "rlm_detail: Couldn\'t open file %s: %s", buffer,
                     tmp___5);
      }
#line 270
      return (1);
    }
#line 277
    if (inst->locking) {
      {
#line 278
      lseek(outfd, 0L, 0);
#line 279
      tmp___6 = rad_lockfd_nonblock(outfd, 0);
      }
#line 279
      if (tmp___6 < 0) {
        {
#line 280
        close(outfd);
#line 281
        tv.tv_sec = (__time_t )0;
#line 282
        tv.tv_usec = (__suseconds_t )25000;
#line 283
        select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 284
        lock_count ++;
        }
#line 285
        goto __Cont;
      }
      {
#line 293
      tmp___9 = fstat(outfd, & st);
      }
#line 293
      if (tmp___9 != 0) {
        {
#line 294
        tmp___7 = __errno_location();
#line 294
        tmp___8 = strerror(*tmp___7);
#line 294
        radlog_request(4, 0, request, "rlm_detail: Couldn\'t stat file %s: %s", buffer,
                       tmp___8);
#line 296
        close(outfd);
        }
#line 297
        return (1);
      }
#line 299
      if (st.st_nlink == 0UL) {
#line 300
        if (request) {
#line 300
          if (request->radlog) {
            {
#line 300
            (*(request->radlog))(1, 2, request, "File %s removed by another program, retrying",
                                 buffer);
            }
          }
        }
        {
#line 302
        close(outfd);
#line 303
        lock_count = 0;
        }
#line 304
        goto __Cont;
      }
#line 307
      if (request) {
#line 307
        if (request->radlog) {
          {
#line 307
          (*(request->radlog))(1, 2, request, "Acquired filelock, tried %d time(s)",
                               lock_count + 1);
          }
        }
      }
#line 309
      locked = 1;
    }
    __Cont: /* CIL Label */ 
#line 261
    if (inst->locking) {
#line 261
      if (! locked) {
#line 261
        if (! (lock_count < 80)) {
#line 261
          goto while_break;
        }
      } else {
#line 261
        goto while_break;
      }
    } else {
#line 261
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (inst->locking) {
#line 313
    if (! locked) {
      {
#line 314
      close(outfd);
#line 315
      radlog_request(4, 0, request, "rlm_detail: Failed to acquire filelock for %s, giving up",
                     buffer);
      }
#line 317
      return (1);
    }
  }
  {
#line 323
  fsize = lseek(outfd, 0L, 2);
  }
#line 324
  if (fsize < 0L) {
    {
#line 325
    radlog_request(4, 0, request, "rlm_detail: Failed to seek to the end of detail file %s",
                   buffer);
#line 327
    close(outfd);
    }
#line 328
    return (1);
  }
  {
#line 331
  tmp___10 = radius_xlat(timestamp, (int )sizeof(timestamp), (char const   *)inst->header,
                         request, (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
  }
#line 331
  if (tmp___10 == 0) {
    {
#line 332
    radlog_request(4, 0, request, "rlm_detail: Unable to expand detail header format %s",
                   inst->header);
#line 334
    close(outfd);
    }
#line 335
    return (1);
  }
  {
#line 341
  fp = fdopen(outfd, "a");
  }
#line 341
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 342
    tmp___11 = __errno_location();
#line 342
    tmp___12 = strerror(*tmp___11);
#line 342
    radlog_request(4, 0, request, "rlm_detail: Couldn\'t open file %s: %s", buffer,
                   tmp___12);
#line 344
    close(outfd);
    }
#line 345
    return (1);
  }
  {
#line 348
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n", timestamp);
  }
#line 353
  if (! compat) {
#line 358
    if (packet->code > 0U) {
#line 358
      if (packet->code < 52U) {
        {
#line 360
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tPacket-Type = %s\n",
                fr_packet_codes[packet->code]);
        }
      } else {
        {
#line 363
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tPacket-Type = %d\n",
                packet->code);
        }
      }
    } else {
      {
#line 363
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tPacket-Type = %d\n",
              packet->code);
      }
    }
  }
#line 367
  if (inst->log_srcdst) {
    {
#line 370
    memset((void *)(& src_vp), 0, sizeof(src_vp));
#line 371
    memset((void *)(& dst_vp), 0, sizeof(dst_vp));
#line 372
    dst_vp.operator = (FR_TOKEN )11;
#line 372
    src_vp.operator = dst_vp.operator;
    }
    {
#line 375
    if (packet->src_ipaddr.af == 2) {
#line 375
      goto case_2;
    }
#line 385
    if (packet->src_ipaddr.af == 10) {
#line 385
      goto case_10;
    }
#line 399
    goto switch_default;
    case_2: /* CIL Label */ 
#line 376
    src_vp.name = "Packet-Src-IP-Address";
#line 377
    src_vp.type = 2;
#line 378
    src_vp.attribute = 1084;
#line 379
    src_vp.lvalue = packet->src_ipaddr.ipaddr.ip4addr.s_addr;
#line 380
    dst_vp.name = "Packet-Dst-IP-Address";
#line 381
    dst_vp.type = 2;
#line 382
    dst_vp.attribute = 1085;
#line 383
    dst_vp.lvalue = packet->dst_ipaddr.ipaddr.ip4addr.s_addr;
#line 384
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 386
    src_vp.name = "Packet-Src-IPv6-Address";
#line 387
    src_vp.type = 7;
#line 388
    src_vp.attribute = 1097;
#line 389
    memcpy((void */* __restrict  */)(src_vp.data.strvalue), (void const   */* __restrict  */)(& packet->src_ipaddr.ipaddr.ip6addr),
           sizeof(packet->src_ipaddr.ipaddr.ip6addr));
#line 392
    dst_vp.name = "Packet-Dst-IPv6-Address";
#line 393
    dst_vp.type = 7;
#line 394
    dst_vp.attribute = 1098;
#line 395
    memcpy((void */* __restrict  */)(dst_vp.data.strvalue), (void const   */* __restrict  */)(& packet->dst_ipaddr.ipaddr.ip6addr),
           sizeof(packet->dst_ipaddr.ipaddr.ip6addr));
    }
#line 398
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 400
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 403
    vp_print(fp, & src_vp);
#line 404
    vp_print(fp, & dst_vp);
#line 406
    src_vp.name = "Packet-Src-IP-Port";
#line 407
    src_vp.attribute = 1086;
#line 408
    src_vp.type = 1;
#line 409
    src_vp.lvalue = (uint32_t )packet->src_port;
#line 410
    dst_vp.name = "Packet-Dst-IP-Port";
#line 411
    dst_vp.attribute = 1087;
#line 412
    dst_vp.type = 1;
#line 413
    dst_vp.lvalue = (uint32_t )packet->dst_port;
#line 415
    vp_print(fp, & src_vp);
#line 416
    vp_print(fp, & dst_vp);
    }
  }
#line 420
  pair = packet->vps;
  {
#line 420
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 420
    if (! ((unsigned long )pair != (unsigned long )((void *)0))) {
#line 420
      goto while_break___0;
    }
#line 422
    da.attr = (unsigned int )pair->attribute;
#line 424
    if (inst->ht) {
      {
#line 424
      tmp___13 = fr_hash_table_finddata(inst->ht, (void const   *)(& da));
      }
#line 424
      if (tmp___13) {
#line 425
        goto __Cont___0;
      }
    }
#line 430
    if (compat) {
#line 430
      if (pair->attribute == 2) {
#line 430
        goto __Cont___0;
      }
    }
    {
#line 435
    vp_print(fp, pair);
    }
    __Cont___0: /* CIL Label */ 
#line 420
    pair = pair->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 441
  if (compat) {
#line 442
    if (request->proxy) {
      {
#line 445
      inet_ntop((request->proxy)->dst_ipaddr.af, (void const   */* __restrict  */)(& (request->proxy)->dst_ipaddr.ipaddr),
                (char */* __restrict  */)(proxy_buffer), (socklen_t )sizeof(proxy_buffer));
#line 448
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tFreeradius-Proxied-To = %s\n",
              proxy_buffer);
      }
#line 450
      if (request) {
#line 450
        if (request->radlog) {
          {
#line 450
          (*(request->radlog))(1, 1, request, "Freeradius-Proxied-To = %s", proxy_buffer);
          }
        }
      }
    }
    {
#line 454
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tTimestamp = %ld\n",
            (unsigned long )request->timestamp);
    }
  }
  {
#line 458
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 464
  tmp___14 = fflush(fp);
  }
#line 464
  if (tmp___14 != 0) {
    {
#line 465
    ftruncate(outfd, fsize);
#line 466
    fclose(fp);
    }
#line 467
    return (1);
  }
  {
#line 470
  fclose(fp);
  }
#line 475
  return (2);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_accounting(void *instance , REQUEST *request ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 483
  if ((unsigned int )(request->listener)->type == 4U) {
    {
#line 483
    tmp = strcmp((char const   *)((struct detail_instance *)instance)->detailfile,
                 (char const   *)((listen_detail_t *)(request->listener)->data)->filename);
    }
#line 483
    if (tmp == 0) {
#line 486
      if (request) {
#line 486
        if (request->radlog) {
          {
#line 486
          (*(request->radlog))(1, 1, request, "Suppressing writes to detail file as the request was just read from a detail file.");
          }
        }
      }
#line 487
      return (7);
    }
  }
  {
#line 490
  tmp___0 = do_detail(instance, request, request->packet, 1);
  }
#line 490
  return (tmp___0);
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_authorize(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 498
  tmp = do_detail(instance, request, request->packet, 0);
  }
#line 498
  return (tmp);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_postauth(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 506
  tmp = do_detail(instance, request, request->reply, 0);
  }
#line 506
  return (tmp);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_recv_coa(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 515
  tmp = do_detail(instance, request, request->packet, 0);
  }
#line 515
  return (tmp);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_send_coa(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 523
  tmp = do_detail(instance, request, request->reply, 0);
  }
#line 523
  return (tmp);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_pre_proxy(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
#line 532
  if (request->proxy) {
#line 532
    if ((request->proxy)->vps) {
      {
#line 534
      tmp = do_detail(instance, request, request->proxy, 0);
      }
#line 534
      return (tmp);
    }
  }
#line 537
  return (7);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
static int detail_post_proxy(void *instance , REQUEST *request ) 
{ 
  int tmp ;
  int rcode ;

  {
#line 546
  if (request->proxy_reply) {
#line 546
    if ((request->proxy_reply)->vps) {
      {
#line 548
      tmp = do_detail(instance, request, request->proxy_reply, 0);
      }
#line 548
      return (tmp);
    }
  }
#line 558
  if (! request->proxy_reply) {
    {
#line 561
    rcode = detail_accounting(instance, request);
    }
#line 562
    if (rcode == 2) {
#line 563
      (request->reply)->code = 5U;
    }
#line 565
    return (rcode);
  }
#line 568
  return (7);
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_detail/rlm_detail.c"
module_t rlm_detail  =    {4109257426U, "detail", (1 | (1 << 1)) | (1 << 2), & detail_instantiate, & detail_detach,
    {(packetmethod )((void *)0), & detail_authorize, (packetmethod )((void *)0), & detail_accounting,
     (packetmethod )((void *)0), & detail_pre_proxy, & detail_post_proxy, & detail_postauth,
     & detail_recv_coa, & detail_send_coa}};
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___105[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___91[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___97[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___91[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___91[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___95[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___91[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___2(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___2(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___106[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___92[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___98[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___92[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___92[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___96[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___92[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___107[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___93[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___99[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___93[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___93[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___97[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___93[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___2[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___6  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___108[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___100[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___109[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___94[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___101[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___94[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___94[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___98[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___94[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___2(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___2(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___2(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___2(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___2(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___110[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___95[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___102[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___95[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___95[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___99[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___95[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___2[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___2[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___2(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___2[key & 255U] << 24) | ((int const   )reversed_byte___2[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___2[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___2[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___2(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___2[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___2[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___2[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___2[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___2(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___2(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___2(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___2(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___2(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___2(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___2(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___2(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___2(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___2(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___2(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___2(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___111[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___103[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___112[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___96[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___104[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___96[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___96[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___100[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___96[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___2[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___113[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___97[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___105[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___97[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___97[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___101[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___97[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___114[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___98[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___106[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___98[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___98[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___102[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___98[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___115[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___99[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___107[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___99[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___99[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___103[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___99[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___116[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___100[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___108[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___100[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___100[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___104[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___100[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___3  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___3  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___3  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___3(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___3(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___3(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___3(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___3(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___3;
#line 615
  salt_offset___3 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___3(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___3(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___3(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___3(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___3(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___3(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___3((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___3(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___3(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___3(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___3(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___3(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___3(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___3(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___3(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___3((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___3(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___3(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___117[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___101[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___109[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___101[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___101[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___105[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___101[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___118[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___102[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___110[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___102[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___102[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___106[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___102[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___3[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___3(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___119[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___103[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___111[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___103[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___103[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___107[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___103[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___3  =    {& Sentinel___3, & Sentinel___3, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___3(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___3)) {
    {
#line 60
    FreeWalker___3(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___3)) {
    {
#line 61
    FreeWalker___3(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___3(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___3)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___3)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___3)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___3(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___3)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___3)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___3)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___3(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___3(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___3(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___3(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___3(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___3(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___3(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___3)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___3)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___3(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___3)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___3(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___3(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___3)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___3)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___3(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___3)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___3(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___3(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___3)) {
    {
#line 523
    rcode = WalkNodePreOrder___3(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___3)) {
    {
#line 528
    rcode = WalkNodePreOrder___3(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___3(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___3)) {
    {
#line 545
    rcode = WalkNodeInOrder___3(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___3)) {
    {
#line 555
    rcode = WalkNodeInOrder___3(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___3(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___3)) {
    {
#line 572
    rcode = WalkNodeInOrder___3(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___3)) {
    {
#line 577
    rcode = WalkNodeInOrder___3(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___120[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___104[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___112[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___104[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___104[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___108[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___104[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___3(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___3(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___3[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___121[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___122[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___105[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___113[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___105[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___105[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___109[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___105[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___3(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___123[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___106[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___114[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___106[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___106[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___110[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___106[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___3[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___3[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___3[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___3[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___3[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___7(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___3(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___3, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___3, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___3, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___3(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___3, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___3(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___3(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___3(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___3(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___3, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___3, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___3(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___3, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___3(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___3(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___3(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___3(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___3, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___3(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___3, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___3[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___3[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___124[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___107[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___115[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___107[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___107[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___111[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___107[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___3  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___3  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___3(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___3, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static char const   rcsid___125[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___108[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___116[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___108[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___108[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___112[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___108[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 81
extern char const   *cf_section_name2(CONF_SECTION const   * ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 504 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
extern int request_data_add(REQUEST *request , void *unique_ptr , int unique_int ,
                            void *opaque , void (*free_opaque)(void * ) ) ;
#line 507
extern void *request_data_get(REQUEST *request , void *unique_ptr , int unique_int ) ;
#line 548
extern int ( /* format attribute */  log_debug)(char const   *  , ...) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h___2[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static CONF_PARSER const   module_config___1[9]  = 
#line 56 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
  {      {"attribute", 100, (unsigned long )(& ((rlm_attr_rewrite_t *)0)->attribute),
      (void *)0, (char const   *)((void *)0)}, 
        {"searchfor", 100, (unsigned long )(& ((rlm_attr_rewrite_t *)0)->search), (void *)0,
      (char const   *)((void *)0)}, 
        {"searchin", 100, (unsigned long )(& ((rlm_attr_rewrite_t *)0)->searchin_str),
      (void *)0, "packet"}, 
        {"replacewith", 100, (unsigned long )(& ((rlm_attr_rewrite_t *)0)->replace),
      (void *)0, (char const   *)((void *)0)}, 
        {"append", 101, (unsigned long )(& ((rlm_attr_rewrite_t *)0)->append), (void *)0,
      "no"}, 
        {"ignore_case", 101, (unsigned long )(& ((rlm_attr_rewrite_t *)0)->nocase), (void *)0,
      "yes"}, 
        {"new_attribute", 101, (unsigned long )(& ((rlm_attr_rewrite_t *)0)->new_attr),
      (void *)0, "no"}, 
        {"max_matches", 1, (unsigned long )(& ((rlm_attr_rewrite_t *)0)->num_matches),
      (void *)0, "10"}, 
        {(char const   *)((void *)0), -1, (size_t )0, (void *)0, (char const   *)((void *)0)}};
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_instantiate(CONF_SECTION *conf , void **instance ) 
{ 
  rlm_attr_rewrite_t *data ;
  DICT_ATTR *dattr ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 76
  tmp = rad_malloc(sizeof(*data));
#line 76
  data = (rlm_attr_rewrite_t *)tmp;
  }
#line 77
  if (! data) {
#line 78
    return (-1);
  }
  {
#line 80
  memset((void *)data, 0, sizeof(*data));
#line 86
  tmp___0 = cf_section_parse(conf, (void *)data, module_config___1);
  }
#line 86
  if (tmp___0 < 0) {
    {
#line 87
    free((void *)data);
    }
#line 88
    return (-1);
  }
#line 94
  if ((unsigned long )data->attribute == (unsigned long )((void *)0)) {
    {
#line 95
    radlog(4, "rlm_attr_rewrite: \'attribute\' must be set.");
    }
#line 96
    return (-1);
  }
#line 98
  if ((unsigned long )data->search == (unsigned long )((void *)0)) {
    {
#line 99
    radlog(4, "rlm_attr_rewrite: search/replace strings must be set.");
    }
#line 100
    return (-1);
  } else
#line 98
  if ((unsigned long )data->replace == (unsigned long )((void *)0)) {
    {
#line 99
    radlog(4, "rlm_attr_rewrite: search/replace strings must be set.");
    }
#line 100
    return (-1);
  }
  {
#line 102
  tmp___1 = strlen((char const   *)data->search);
#line 102
  data->search_len = (int )tmp___1;
#line 103
  tmp___2 = strlen((char const   *)data->replace);
#line 103
  data->replace_len = (int )tmp___2;
  }
#line 105
  if (data->replace_len == 0) {
#line 105
    if (data->new_attr) {
      {
#line 106
      radlog(4, "rlm_attr_rewrite: replace string must not be zero length in order to create new attribute.");
      }
#line 107
      return (-1);
    }
  }
#line 110
  if (data->num_matches < 1) {
    {
#line 111
    radlog(4, "rlm_attr_rewrite: Illegal range for match number.");
    }
#line 112
    return (-1);
  } else
#line 110
  if (data->num_matches > 254) {
    {
#line 111
    radlog(4, "rlm_attr_rewrite: Illegal range for match number.");
    }
#line 112
    return (-1);
  }
#line 114
  if ((unsigned long )data->searchin_str == (unsigned long )((void *)0)) {
    {
#line 115
    radlog(4, "rlm_attr_rewrite: Illegal searchin directive given. Assuming packet.");
#line 116
    data->searchin = (char)0;
    }
  } else {
    {
#line 119
    tmp___8 = strcmp((char const   *)data->searchin_str, "packet");
    }
#line 119
    if (tmp___8 == 0) {
#line 120
      data->searchin = (char)0;
    } else {
      {
#line 121
      tmp___7 = strcmp((char const   *)data->searchin_str, "config");
      }
#line 121
      if (tmp___7 == 0) {
#line 122
        data->searchin = (char)1;
      } else {
        {
#line 123
        tmp___6 = strcmp((char const   *)data->searchin_str, "control");
        }
#line 123
        if (tmp___6 == 0) {
#line 124
          data->searchin = (char)1;
        } else {
          {
#line 125
          tmp___5 = strcmp((char const   *)data->searchin_str, "reply");
          }
#line 125
          if (tmp___5 == 0) {
#line 126
            data->searchin = (char)2;
          } else {
            {
#line 127
            tmp___4 = strcmp((char const   *)data->searchin_str, "proxy");
            }
#line 127
            if (tmp___4 == 0) {
#line 128
              data->searchin = (char)3;
            } else {
              {
#line 129
              tmp___3 = strcmp((char const   *)data->searchin_str, "proxy_reply");
              }
#line 129
              if (tmp___3 == 0) {
#line 130
                data->searchin = (char)4;
              } else {
                {
#line 132
                radlog(4, "rlm_attr_rewrite: Illegal searchin directive given. Assuming packet.");
#line 133
                data->searchin = (char)0;
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 136
  dattr = dict_attrbyname((char const   *)data->attribute);
  }
#line 137
  if ((unsigned long )dattr == (unsigned long )((void *)0)) {
    {
#line 138
    radlog(4, "rlm_attr_rewrite: No such attribute %s", data->attribute);
    }
#line 140
    return (-1);
  }
  {
#line 142
  data->attr_num = (int )dattr->attr;
#line 144
  data->name = cf_section_name2((CONF_SECTION const   *)conf);
#line 146
  *instance = (void *)data;
  }
#line 148
  return (0);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int do_attr_rewrite(void *instance , REQUEST *request ) 
{ 
  rlm_attr_rewrite_t *data ;
  int ret ;
  VALUE_PAIR *attr_vp ;
  VALUE_PAIR *tmp ;
  regex_t preg ;
  regmatch_t pmatch[9] ;
  int cflags ;
  int err ;
  char done_xlat ;
  unsigned int len ;
  char err_msg[254] ;
  unsigned int i ;
  unsigned int j ;
  unsigned int counter ;
  char new_str[254] ;
  char *ptr ;
  char *ptr2 ;
  char search_STR[254] ;
  char replace_STR[254] ;
  int tmp___0 ;
  int tmp___1 ;
  int replace_len ;
  int tmp___2 ;
  char *p ;
  char buffer[sizeof(attr_vp->data.strvalue)] ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  VALUE_PAIR *tmp___8 ;

  {
  {
#line 153
  data = (rlm_attr_rewrite_t *)instance;
#line 154
  ret = 7;
#line 155
  attr_vp = (VALUE_PAIR *)((void *)0);
#line 156
  tmp = (VALUE_PAIR *)((void *)0);
#line 159
  cflags = 0;
#line 160
  err = 0;
#line 161
  done_xlat = (char)0;
#line 162
  len = 0U;
#line 164
  i = 0U;
#line 165
  j = 0U;
#line 166
  counter = 0U;
#line 172
  attr_vp = pairfind(request->config_items, 1078);
  }
#line 172
  if ((unsigned long )attr_vp != (unsigned long )((void *)0)) {
#line 173
    if ((unsigned long )data->name == (unsigned long )((void *)0)) {
#line 174
      return (7);
    } else {
      {
#line 173
      tmp___0 = strcmp(data->name, (char const   *)(attr_vp->data.strvalue));
      }
#line 173
      if (tmp___0) {
#line 174
        return (7);
      }
    }
  }
#line 177
  if (data->new_attr) {
    {
#line 179
    tmp___1 = radius_xlat(replace_STR, (int )sizeof(replace_STR), (char const   *)data->replace,
                          request, (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
    }
#line 179
    if (! tmp___1) {
#line 180
      if (debug_flag > 1) {
        {
#line 180
        log_debug("%s: xlat on replace string failed.", data->name);
        }
      }
#line 181
      return (ret);
    }
    {
#line 183
    attr_vp = pairmake((char const   *)data->attribute, (char const   *)(replace_STR),
                       0);
    }
#line 184
    if ((unsigned long )attr_vp == (unsigned long )((void *)0)) {
#line 185
      if (debug_flag > 1) {
        {
#line 185
        log_debug("%s: Could not add new attribute %s with value \'%s\'", data->name,
                  data->attribute, replace_STR);
        }
      }
#line 187
      return (ret);
    }
    {
#line 190
    if ((int )data->searchin == 0) {
#line 190
      goto case_0;
    }
#line 193
    if ((int )data->searchin == 1) {
#line 193
      goto case_1;
    }
#line 196
    if ((int )data->searchin == 2) {
#line 196
      goto case_2;
    }
#line 199
    if ((int )data->searchin == 3) {
#line 199
      goto case_3;
    }
#line 206
    if ((int )data->searchin == 4) {
#line 206
      goto case_4;
    }
#line 213
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 191
    pairadd(& (request->packet)->vps, attr_vp);
    }
#line 192
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 194
    pairadd(& request->config_items, attr_vp);
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 197
    pairadd(& (request->reply)->vps, attr_vp);
    }
#line 198
    goto switch_break;
    case_3: /* CIL Label */ 
#line 200
    if (! request->proxy) {
      {
#line 201
      pairbasicfree(attr_vp);
      }
#line 202
      return (7);
    }
    {
#line 204
    pairadd(& (request->proxy)->vps, attr_vp);
    }
#line 205
    goto switch_break;
    case_4: /* CIL Label */ 
#line 207
    if (! request->proxy_reply) {
      {
#line 208
      pairbasicfree(attr_vp);
      }
#line 209
      return (7);
    }
    {
#line 211
    pairadd(& (request->proxy_reply)->vps, attr_vp);
    }
#line 212
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 214
    radlog(4, "%s: Illegal value for searchin. Changing to packet.", data->name);
#line 215
    data->searchin = (char)0;
#line 216
    pairadd(& (request->packet)->vps, attr_vp);
    }
#line 217
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 219
    if (debug_flag > 1) {
      {
#line 219
      log_debug("%s: Added attribute %s with value \'%s\'", data->name, data->attribute,
                replace_STR);
      }
    }
#line 220
    ret = 2;
  } else {
#line 222
    replace_len = 0;
    {
#line 226
    if ((int )data->searchin == 0) {
#line 226
      goto case_0___0;
    }
#line 234
    if ((int )data->searchin == 1) {
#line 234
      goto case_1___0;
    }
#line 237
    if ((int )data->searchin == 2) {
#line 237
      goto case_2___0;
    }
#line 240
    if ((int )data->searchin == 4) {
#line 240
      goto case_4___0;
    }
#line 245
    if ((int )data->searchin == 3) {
#line 245
      goto case_3___0;
    }
#line 250
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
#line 227
    if (data->attr_num == 1) {
#line 228
      attr_vp = request->username;
    } else
#line 229
    if (data->attr_num == 2) {
#line 230
      attr_vp = request->password;
    } else {
#line 232
      tmp = (request->packet)->vps;
    }
#line 233
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 235
    tmp = request->config_items;
#line 236
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 238
    tmp = (request->reply)->vps;
#line 239
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 241
    if (! request->proxy_reply) {
#line 242
      return (7);
    }
#line 243
    tmp = (request->proxy_reply)->vps;
#line 244
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 246
    if (! request->proxy) {
#line 247
      return (7);
    }
#line 248
    tmp = (request->proxy)->vps;
#line 249
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 251
    radlog(4, "%s: Illegal value for searchin. Changing to packet.", data->name);
#line 252
    data->searchin = (char)0;
#line 253
    attr_vp = pairfind((request->packet)->vps, data->attr_num);
    }
#line 254
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    do_again: 
#line 257
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 258
      attr_vp = pairfind(tmp, data->attr_num);
      }
    }
#line 259
    if ((unsigned long )attr_vp == (unsigned long )((void *)0)) {
#line 260
      if (debug_flag > 1) {
        {
#line 260
        log_debug("%s: Could not find value pair for attribute %s", data->name, data->attribute);
        }
      }
#line 261
      return (ret);
    }
#line 263
    if ((unsigned long )(attr_vp->data.strvalue) == (unsigned long )((void *)0)) {
#line 263
      goto _L;
    } else
#line 263
    if (attr_vp->length == 0UL) {
      _L: /* CIL Label */ 
#line 264
      if (debug_flag > 1) {
        {
#line 264
        log_debug("%s: Attribute %s string value NULL or of zero length", data->name,
                  data->attribute);
        }
      }
#line 265
      return (ret);
    }
#line 267
    cflags |= 1;
#line 268
    if (data->nocase) {
#line 269
      cflags |= 1 << 1;
    }
    {
#line 271
    tmp___2 = radius_xlat(search_STR, (int )sizeof(search_STR), (char const   *)data->search,
                          request, (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
    }
#line 271
    if (! tmp___2) {
#line 271
      if (data->search_len != 0) {
#line 272
        if (debug_flag > 1) {
          {
#line 272
          log_debug("%s: xlat on search string failed.", data->name);
          }
        }
#line 273
        return (ret);
      }
    }
    {
#line 276
    err = regcomp((regex_t */* __restrict  */)(& preg), (char const   */* __restrict  */)(search_STR),
                  cflags);
    }
#line 276
    if (err) {
      {
#line 277
      regerror(err, (regex_t const   */* __restrict  */)(& preg), (char */* __restrict  */)(err_msg),
               (size_t )254);
      }
#line 278
      if (debug_flag > 1) {
        {
#line 278
        log_debug("%s: regcomp() returned error: %s", data->name, err_msg);
        }
      }
#line 279
      return (ret);
    }
#line 282
    if (attr_vp->type == 2) {
#line 282
      if ((int )attr_vp->data.strvalue[0] == 0) {
        {
#line 284
        inet_ntop(2, (void const   */* __restrict  */)(& attr_vp->lvalue), (char */* __restrict  */)(attr_vp->data.strvalue),
                  (socklen_t )sizeof(attr_vp->data.strvalue));
        }
      }
    }
#line 289
    ptr = new_str;
#line 290
    ptr2 = attr_vp->data.strvalue;
#line 291
    counter = 0U;
#line 293
    i = 0U;
    {
#line 293
    while (1) {
      while_continue: /* CIL Label */ ;
#line 293
      if (! (i < (unsigned int )data->num_matches)) {
#line 293
        goto while_break;
      }
      {
#line 294
      err = regexec((regex_t const   */* __restrict  */)(& preg), (char const   */* __restrict  */)ptr2,
                    (size_t )8, (regmatch_t */* __restrict  */)(pmatch), 0);
      }
#line 295
      if (err == 1) {
#line 296
        if (i == 0U) {
#line 297
          if (debug_flag > 1) {
            {
#line 297
            log_debug("%s: Does not match: %s = %s", data->name, data->attribute,
                      attr_vp->data.strvalue);
            }
          }
          {
#line 299
          regfree(& preg);
          }
#line 300
          goto to_do_again;
        } else {
#line 302
          goto while_break;
        }
      }
#line 304
      if (err != 0) {
        {
#line 305
        regfree(& preg);
#line 306
        radlog(4, "%s: match failure for attribute %s with value \'%s\'", data->name,
               data->attribute, attr_vp->data.strvalue);
        }
#line 308
        return (ret);
      }
#line 310
      if (pmatch[0].rm_so == -1) {
#line 311
        goto while_break;
      }
#line 312
      len = (unsigned int )pmatch[0].rm_so;
#line 313
      if (data->append) {
#line 314
        len += (unsigned int )(pmatch[0].rm_eo - pmatch[0].rm_so);
      }
#line 316
      counter += len;
#line 317
      if (counter >= 254U) {
        {
#line 318
        regfree(& preg);
        }
#line 319
        if (debug_flag > 1) {
          {
#line 319
          log_debug("%s: Replacement out of limits for attribute %s with value \'%s\'",
                    data->name, data->attribute, attr_vp->data.strvalue);
          }
        }
#line 321
        return (ret);
      }
      {
#line 324
      memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)ptr2,
             (size_t )len);
#line 325
      ptr += len;
#line 326
      *ptr = (char )'\000';
#line 327
      ptr2 += pmatch[0].rm_eo;
      }
#line 329
      if (i == 0U) {
#line 333
        j = 0U;
        {
#line 333
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 333
          if (! (j <= 8U)) {
#line 333
            goto while_break___0;
          }
#line 345
          if (pmatch[j].rm_so == -1) {
            {
#line 346
            tmp___3 = request_data_get(request, (void *)request, (int )(2914971392U | j));
#line 346
            p = (char *)tmp___3;
            }
#line 347
            if (p) {
              {
#line 348
              free((void *)p);
              }
#line 349
              goto __Cont;
            }
#line 351
            goto while_break___0;
          }
          {
#line 353
          memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)(attr_vp->data.strvalue + pmatch[j].rm_so),
                 (size_t )(pmatch[j].rm_eo - pmatch[j].rm_so));
#line 356
          buffer[pmatch[j].rm_eo - pmatch[j].rm_so] = (char )'\000';
#line 357
          p = strdup((char const   *)(buffer));
#line 358
          request_data_add(request, (void *)request, (int )(2914971392U | j), (void *)p,
                           (void (*)(void * ))(& free));
          }
          __Cont: /* CIL Label */ 
#line 333
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 362
      if (! done_xlat) {
#line 363
        if (data->replace_len != 0) {
          {
#line 363
          tmp___4 = radius_xlat(replace_STR, (int )sizeof(replace_STR), (char const   *)data->replace,
                                request, (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
          }
#line 363
          if (tmp___4 == 0) {
#line 365
            if (debug_flag > 1) {
              {
#line 365
              log_debug("%s: xlat on replace string failed.", data->name);
              }
            }
#line 366
            return (ret);
          }
        }
#line 368
        if (data->replace_len != 0) {
          {
#line 368
          tmp___5 = strlen((char const   *)(replace_STR));
#line 368
          replace_len = (int )tmp___5;
          }
        } else {
#line 368
          replace_len = 0;
        }
#line 369
        done_xlat = (char)1;
      }
#line 372
      counter += (unsigned int )replace_len;
#line 373
      if (counter >= 254U) {
        {
#line 374
        regfree(& preg);
        }
#line 375
        if (debug_flag > 1) {
          {
#line 375
          log_debug("%s: Replacement out of limits for attribute %s with value \'%s\'",
                    data->name, data->attribute, attr_vp->data.strvalue);
          }
        }
#line 377
        return (ret);
      }
#line 379
      if (replace_len) {
        {
#line 380
        memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(replace_STR),
               (size_t )replace_len);
#line 381
        ptr += replace_len;
#line 382
        *ptr = (char )'\000';
        }
      }
#line 293
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 385
    regfree(& preg);
#line 386
    tmp___6 = strlen((char const   *)ptr2);
#line 386
    len = (unsigned int )(tmp___6 + 1UL);
#line 387
    counter += len;
    }
#line 388
    if (counter >= 254U) {
#line 389
      if (debug_flag > 1) {
        {
#line 389
        log_debug("%s: Replacement out of limits for attribute %s with value \'%s\'",
                  data->name, data->attribute, attr_vp->data.strvalue);
        }
      }
#line 391
      return (ret);
    }
    {
#line 393
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)ptr2, (size_t )len);
#line 394
    *(ptr + len) = (char )'\000';
    }
#line 396
    if (debug_flag > 1) {
      {
#line 396
      log_debug("%s: Changed value for attribute %s from \'%s\' to \'%s\'", data->name,
                data->attribute, attr_vp->data.strvalue, new_str);
      }
    }
    {
#line 398
    tmp___8 = pairparsevalue(attr_vp, (char const   *)(new_str));
    }
#line 398
    if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 399
      if (debug_flag > 1) {
        {
#line 399
        tmp___7 = fr_strerror();
#line 399
        log_debug("%s: Could not write value \'%s\' into attribute %s: %s", data->name,
                  new_str, data->attribute, tmp___7);
        }
      }
#line 400
      return (ret);
    }
    to_do_again: 
#line 404
    ret = 2;
#line 406
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 407
      tmp = attr_vp->next;
#line 408
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 409
        goto do_again;
      }
    }
  }
#line 413
  return (ret);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_accounting(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 418
  tmp = do_attr_rewrite(instance, request);
  }
#line 418
  return (tmp);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_authorize(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 423
  tmp = do_attr_rewrite(instance, request);
  }
#line 423
  return (tmp);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_authenticate(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 428
  tmp = do_attr_rewrite(instance, request);
  }
#line 428
  return (tmp);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_preacct(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 433
  tmp = do_attr_rewrite(instance, request);
  }
#line 433
  return (tmp);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_checksimul(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 438
  tmp = do_attr_rewrite(instance, request);
  }
#line 438
  return (tmp);
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_preproxy(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 443
  tmp = do_attr_rewrite(instance, request);
  }
#line 443
  return (tmp);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_postproxy(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 448
  tmp = do_attr_rewrite(instance, request);
  }
#line 448
  return (tmp);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_postauth(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 453
  tmp = do_attr_rewrite(instance, request);
  }
#line 453
  return (tmp);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
static int attr_rewrite_detach(void *instance ) 
{ 


  {
  {
#line 458
  free(instance);
  }
#line 459
  return (0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_rewrite/rlm_attr_rewrite.c"
module_t rlm_attr_rewrite  =    {4109257426U, "attr_rewrite", 1, & attr_rewrite_instantiate, & attr_rewrite_detach,
    {& attr_rewrite_authenticate, & attr_rewrite_authorize, & attr_rewrite_preacct,
     & attr_rewrite_accounting, & attr_rewrite_checksimul, & attr_rewrite_preproxy,
     & attr_rewrite_postproxy, & attr_rewrite_postauth}};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___126[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___109[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___117[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___109[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___109[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___113[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___109[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___127[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___110[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___118[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___110[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___110[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___114[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___110[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___128[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___111[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___119[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___111[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___111[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___115[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___111[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___3[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___3(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___3(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___3(& p, " \t");
#line 726
  f[1] = mystrtok___3(& p, " \t");
#line 727
  f[2] = mystrtok___3(& p, " \t");
#line 728
  f[3] = mystrtok___3(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___3[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___7  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___3(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___3(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___3(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___3[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___129[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___112[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___120[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___112[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___112[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___116[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___112[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___130[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___117[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___131[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___113[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___121[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___113[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___113[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___118[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___113[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___3[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___132[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___114[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___122[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___114[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___114[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___119[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___114[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___3(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___3(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___3(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___133[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___115[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___123[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___115[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___115[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___120[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___115[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___3  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___3  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___3  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___3  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___3  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___3  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___3[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___3  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___3  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___3  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___3  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___3  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___3[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___3(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___3(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___3((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___3(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___3(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___3(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___3(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___3((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___3(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___3(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___3(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___3(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___3((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___3(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___3(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___3(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___3(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___3);
#line 240
  stat_root_dir___3 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___3);
#line 242
  stat_root_file___3 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___3) {
#line 245
    stat_tail___3 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___3;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___3 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___3 = stat_tail___3;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___3(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___3) {
#line 274
    stat_tail___3 = this;
#line 274
    stat_head___3 = stat_tail___3;
  } else {
#line 276
    stat_tail___3->next = this;
#line 277
    stat_tail___3 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___3(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___3) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___3) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___3);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___3);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___3) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___3;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___3  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___3(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___3(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___3(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___3) {
    {
#line 359
    dict_pool___3 = fr_pool_create___3();
    }
#line 360
    if (! dict_pool___3) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___3->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___3->page_free)->page_end)) {
    {
#line 368
    (dict_pool___3->page_free)->page_next = fr_pool_create___3();
    }
#line 369
    if (! (dict_pool___3->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___3->page_free = (dict_pool___3->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___3->page_free)->free_ptr;
#line 374
  (dict_pool___3->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___3->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___3(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___3  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___3  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___3  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___3(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___3(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___3((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___3, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___3, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___3(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___3((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___3(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___3(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___3, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___3((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___3(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___8(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___3(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___3(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___8(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___3(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___3(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___3(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___3(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___3(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___3(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___134[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___116[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___124[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___116[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___116[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___121[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___116[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___3(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___3(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___135[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___117[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___125[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___117[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___117[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___122[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___117[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___136[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___118[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___126[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___118[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___118[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___123[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___118[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___3[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___8  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___137[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___127[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___138[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___119[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___128[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___119[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___119[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___124[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___119[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___3(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___3(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___3(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___3(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___3(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___139[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___120[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___129[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___120[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___120[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___125[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___120[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___3[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___3[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___3(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___3[key & 255U] << 24) | ((int const   )reversed_byte___3[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___3[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___3[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___3(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___3[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___3[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___3[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___3[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___3(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___3(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___3(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___3(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___3(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___3(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___3(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___3(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___3(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___3(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___3(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___3(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___140[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___130[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___141[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___121[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___131[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___121[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___121[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___126[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___121[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___3[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___142[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___122[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___132[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___122[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___122[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___127[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___122[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___143[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___123[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___133[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___123[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___123[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___128[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___123[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___144[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___124[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___134[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___124[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___124[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___129[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___124[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___145[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___125[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___135[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___125[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___125[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___130[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___125[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___4  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___4  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___4  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___4(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___4(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___4(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___4(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___4(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___4;
#line 615
  salt_offset___4 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___4(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___4(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___4(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___4(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___4(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___4(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___4((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___4(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___4(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___4(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___4(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___4(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___4(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___4(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___4(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___4((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___4(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___4(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___146[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___126[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___136[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___126[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___126[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___131[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___126[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___147[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___127[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___137[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___127[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___127[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___132[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___127[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___4[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___4(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___148[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___128[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___138[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___128[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___128[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___133[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___128[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___4  =    {& Sentinel___4, & Sentinel___4, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___4(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___4)) {
    {
#line 60
    FreeWalker___4(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___4)) {
    {
#line 61
    FreeWalker___4(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___4(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___4)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___4)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___4)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___4(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___4)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___4)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___4)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___4(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___4(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___4(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___4(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___4(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___4(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___4(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___4)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___4)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___4(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___4)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___4(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___4(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___4)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___4)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___4(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___4)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___4(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___4(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___4)) {
    {
#line 523
    rcode = WalkNodePreOrder___4(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___4)) {
    {
#line 528
    rcode = WalkNodePreOrder___4(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___4(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___4)) {
    {
#line 545
    rcode = WalkNodeInOrder___4(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___4)) {
    {
#line 555
    rcode = WalkNodeInOrder___4(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___4(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___4)) {
    {
#line 572
    rcode = WalkNodeInOrder___4(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___4)) {
    {
#line 577
    rcode = WalkNodeInOrder___4(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___149[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___129[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___139[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___129[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___129[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___134[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___129[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___4(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___4(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___4[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___150[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___151[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___130[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___140[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___130[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___130[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___135[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___130[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___4(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___152[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___131[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___141[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___131[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___131[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___136[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___131[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___4[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___4[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___4[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___4[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___4[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___9(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___4(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___4, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___4, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___4, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___4(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___4, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___4(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___4(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___4(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___4(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___4, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___4, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___4(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___4, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___4(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___4(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___4(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___4(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___4, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___4(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___4, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___4[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___4[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___153[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___132[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___142[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___132[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___132[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___137[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___132[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___4  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___4  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___4(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___4, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___154[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___133[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___143[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___133[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___133[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___138[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___133[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___155[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___134[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___144[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___134[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___134[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___139[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___134[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___156[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___135[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___145[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___135[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___135[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___140[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___135[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___4[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___4(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___4(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___4(& p, " \t");
#line 726
  f[1] = mystrtok___4(& p, " \t");
#line 727
  f[2] = mystrtok___4(& p, " \t");
#line 728
  f[3] = mystrtok___4(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___4[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___9  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___4(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___4(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___4(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___4[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___157[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___136[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___146[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___136[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___136[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___141[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___136[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___158[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___142[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___159[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___137[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___147[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___137[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___137[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___143[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___137[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___4[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___160[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___138[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___148[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___138[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___138[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___144[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___138[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___4(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___4(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___4(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___161[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___139[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___149[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___139[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___139[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___145[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___139[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___4  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___4  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___4  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___4  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___4  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___4  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___4[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___4  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___4  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___4  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___4  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___4  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___4[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___4(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___4(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___4((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___4(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___4(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___4(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___4(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___4((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___4(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___4(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___4(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___4(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___4((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___4(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___4(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___4(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___4(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___4);
#line 240
  stat_root_dir___4 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___4);
#line 242
  stat_root_file___4 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___4) {
#line 245
    stat_tail___4 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___4;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___4 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___4 = stat_tail___4;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___4(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___4) {
#line 274
    stat_tail___4 = this;
#line 274
    stat_head___4 = stat_tail___4;
  } else {
#line 276
    stat_tail___4->next = this;
#line 277
    stat_tail___4 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___4(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___4) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___4) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___4);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___4);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___4) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___4;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___4  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___4(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___4(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___4(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___4) {
    {
#line 359
    dict_pool___4 = fr_pool_create___4();
    }
#line 360
    if (! dict_pool___4) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___4->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___4->page_free)->page_end)) {
    {
#line 368
    (dict_pool___4->page_free)->page_next = fr_pool_create___4();
    }
#line 369
    if (! (dict_pool___4->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___4->page_free = (dict_pool___4->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___4->page_free)->free_ptr;
#line 374
  (dict_pool___4->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___4->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___4(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___4  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___4  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___4  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___4(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___4(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___4((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___4, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___4, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___4(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___4((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___4(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___4(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___4, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___4((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___4(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___10(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___4(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___4(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___10(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___4(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___4(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___4(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___4(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___4(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___4(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
static char const   rcsid___162[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___140[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___150[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___140[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___140[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___146[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___140[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h___3[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
static CONF_PARSER const   module_config___2[5]  = {      {"item-name", 100, (unsigned long )(& ((rlm_checkval_t *)0)->item_name), (void *)0,
      (char const   *)((void *)0)}, 
        {"check-name", 100, (unsigned long )(& ((rlm_checkval_t *)0)->check_name), (void *)0,
      (char const   *)((void *)0)}, 
        {"data-type", 100, (unsigned long )(& ((rlm_checkval_t *)0)->data_type), (void *)0,
      "integer"}, 
        {"notfound-reject", 101, (unsigned long )(& ((rlm_checkval_t *)0)->notfound_reject),
      (void *)0, "no"}, 
        {(char const   *)((void *)0), -1, (size_t )0, (void *)0, (char const   *)((void *)0)}};
#line 75 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
static int checkval_detach(void *instance ) 
{ 


  {
  {
#line 77
  free(instance);
  }
#line 78
  return (0);
}
}
#line 97
static int checkval_instantiate(CONF_SECTION *conf , void **instance ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
static FR_NAME_NUMBER const   names[8]  = 
#line 97
  {      {"string", 0}, 
        {"integer", 1}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 5}, 
        {"octets", 5}, 
        {"binary", 5}, 
        {(char const   *)((void *)0), 0}};
#line 91 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
static int checkval_instantiate(CONF_SECTION *conf , void **instance ) 
{ 
  rlm_checkval_t *data ;
  DICT_ATTR *dattr ;
  ATTR_FLAGS flags ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 111
  tmp = rad_malloc(sizeof(*data));
#line 111
  data = (rlm_checkval_t *)tmp;
  }
#line 112
  if (! data) {
#line 113
    return (-1);
  }
  {
#line 115
  memset((void *)data, 0, sizeof(*data));
#line 121
  tmp___0 = cf_section_parse(conf, (void *)data, module_config___2);
  }
#line 121
  if (tmp___0 < 0) {
    {
#line 122
    checkval_detach((void *)data);
    }
#line 123
    return (-1);
  }
#line 129
  if (! data->data_type) {
    {
#line 130
    radlog(4, "rlm_checkval: Data type not defined");
#line 131
    checkval_detach((void *)data);
    }
#line 132
    return (-1);
  } else {
    {
#line 129
    tmp___1 = strlen((char const   *)data->data_type);
    }
#line 129
    if (! tmp___1) {
      {
#line 130
      radlog(4, "rlm_checkval: Data type not defined");
#line 131
      checkval_detach((void *)data);
      }
#line 132
      return (-1);
    }
  }
#line 134
  if (! data->item_name) {
    {
#line 135
    radlog(4, "rlm_checkval: Item name not defined");
#line 136
    checkval_detach((void *)data);
    }
#line 137
    return (-1);
  } else {
    {
#line 134
    tmp___2 = strlen((char const   *)data->item_name);
    }
#line 134
    if (! tmp___2) {
      {
#line 135
      radlog(4, "rlm_checkval: Item name not defined");
#line 136
      checkval_detach((void *)data);
      }
#line 137
      return (-1);
    }
  }
#line 139
  if (! data->check_name) {
    {
#line 140
    radlog(4, "rlm_checkval: Check item name not defined");
#line 141
    checkval_detach((void *)data);
    }
#line 142
    return (-1);
  } else {
    {
#line 139
    tmp___3 = strlen((char const   *)data->check_name);
    }
#line 139
    if (! tmp___3) {
      {
#line 140
      radlog(4, "rlm_checkval: Check item name not defined");
#line 141
      checkval_detach((void *)data);
      }
#line 142
      return (-1);
    }
  }
  {
#line 148
  dattr = dict_attrbyname((char const   *)data->item_name);
  }
#line 149
  if (! dattr) {
    {
#line 150
    radlog(4, "rlm_checkval: No such attribute %s", data->item_name);
#line 152
    checkval_detach((void *)data);
    }
#line 153
    return (-1);
  }
  {
#line 155
  data->item_attr = (int )dattr->attr;
#line 162
  memset((void *)(& flags), 0, sizeof(flags));
#line 163
  dict_addattr((char const   *)data->check_name, 0, 0, -1, flags);
#line 164
  dattr = dict_attrbyname((char const   *)data->check_name);
  }
#line 165
  if (! dattr) {
    {
#line 166
    radlog(4, "rlm_checkval: No such attribute %s", data->check_name);
#line 168
    checkval_detach((void *)data);
    }
#line 169
    return (-1);
  }
#line 171
  data->chk_attr = (int )dattr->attr;
#line 172
  if (debug_flag > 1) {
    {
#line 172
    log_debug("rlm_checkval: Registered name %s for attribute %d", dattr->name, dattr->attr);
    }
  }
  {
#line 180
  data->dat_type = fr_str2int(names, (char const   *)data->data_type, -1);
  }
#line 181
  if (data->dat_type < 0) {
    {
#line 182
    radlog(4, "rlm_checkval: Data type %s in not known", data->data_type);
#line 183
    checkval_detach((void *)data);
    }
#line 184
    return (-1);
  }
#line 187
  *instance = (void *)data;
#line 189
  return (0);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
static int do_checkval(void *instance , REQUEST *request ) 
{ 
  rlm_checkval_t *data ;
  int ret ;
  VALUE_PAIR *chk_vp ;
  VALUE_PAIR *item_vp ;
  VALUE_PAIR *tmp ;
  char found ;
  int tmp___0 ;
  regex_t reg ;
  int err ;
  char err_msg[254] ;
  int tmp___1 ;
  char module_fmsg[254] ;
  VALUE_PAIR *module_fmsg_vp ;
  char module_fmsg___0[254] ;
  VALUE_PAIR *module_fmsg_vp___0 ;

  {
  {
#line 194
  data = (rlm_checkval_t *)instance;
#line 195
  ret = 7;
#line 198
  found = (char)0;
#line 201
  instance = instance;
#line 202
  request = request;
#line 209
  item_vp = pairfind((request->packet)->vps, data->item_attr);
  }
#line 209
  if (! item_vp) {
#line 210
    if (debug_flag > 1) {
      {
#line 210
      log_debug("rlm_checkval: Could not find item named %s in request", data->item_name);
      }
    }
#line 211
    if (data->notfound_reject) {
#line 212
      ret = 0;
    } else {
#line 214
      ret = 6;
    }
  }
#line 216
  if (item_vp) {
#line 217
    if (debug_flag > 1) {
      {
#line 217
      log_debug("rlm_checkval: Item Name: %s, Value: %s", data->item_name, item_vp->data.strvalue);
      }
    }
  }
#line 218
  tmp = request->config_items;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 220
    chk_vp = pairfind(tmp, data->chk_attr);
    }
#line 220
    if (! chk_vp) {
#line 221
      if (! found) {
#line 222
        if (debug_flag > 1) {
          {
#line 222
          log_debug("rlm_checkval: Could not find attribute named %s in check pairs",
                    data->check_name);
          }
        }
#line 223
        ret = 6;
      }
#line 225
      goto while_break;
    }
#line 227
    if (! item_vp) {
#line 228
      goto while_break;
    }
#line 229
    if (debug_flag > 1) {
      {
#line 229
      log_debug("rlm_checkval: Value Name: %s, Value: %s", data->check_name, chk_vp->data.strvalue);
      }
    }
#line 236
    found = (char)1;
#line 237
    if (data->dat_type == 0) {
#line 237
      goto _L;
    } else
#line 237
    if (data->dat_type == 5) {
      _L: /* CIL Label */ 
#line 239
      if (item_vp->length != chk_vp->length) {
#line 240
        ret = 0;
      } else {
        {
#line 242
        tmp___0 = memcmp((void const   *)(item_vp->data.strvalue), (void const   *)(chk_vp->data.strvalue),
                         chk_vp->length);
        }
#line 242
        if (tmp___0) {
#line 247
          ret = 0;
        } else {
#line 245
          ret = 2;
        }
      }
    } else
#line 249
    if (data->dat_type == 3) {
#line 250
      if (item_vp->lvalue == chk_vp->lvalue) {
#line 251
        ret = 2;
      } else {
#line 253
        ret = 0;
      }
    } else
#line 254
    if (data->dat_type == 1) {
#line 255
      if (item_vp->lvalue == chk_vp->lvalue) {
#line 256
        ret = 2;
      } else {
#line 258
        ret = 0;
      }
    }
#line 261
    if (ret == 0) {
#line 261
      if ((unsigned int )chk_vp->operator == 17U) {
#line 267
        if (debug_flag) {
          {
#line 267
          log_debug("rlm_checkval: Doing regex");
          }
        }
        {
#line 268
        err = regcomp((regex_t */* __restrict  */)(& reg), (char const   */* __restrict  */)(chk_vp->data.strvalue),
                      1 | (((1 << 1) << 1) << 1));
        }
#line 269
        if (err) {
          {
#line 270
          regerror(err, (regex_t const   */* __restrict  */)(& reg), (char */* __restrict  */)(err_msg),
                   (size_t )254);
          }
#line 271
          if (debug_flag) {
            {
#line 271
            log_debug("rlm_checkval: regcomp() returned error: %s", err_msg);
            }
          }
#line 272
          return (1);
        }
        {
#line 274
        tmp___1 = regexec((regex_t const   */* __restrict  */)(& reg), (char const   */* __restrict  */)(item_vp->data.strvalue),
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
        }
#line 274
        if (tmp___1 == 0) {
#line 275
          ret = 2;
        } else {
#line 277
          ret = 0;
        }
        {
#line 278
        regfree(& reg);
        }
      }
    }
#line 281
    tmp = chk_vp->next;
#line 219
    if (ret == 0) {
#line 219
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 219
        goto while_break;
      }
    } else {
#line 219
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if (ret == 0) {
#line 286
    if (! item_vp) {
#line 286
      if (data->notfound_reject) {
        {
#line 290
        snprintf((char */* __restrict  */)(module_fmsg), sizeof(module_fmsg), (char const   */* __restrict  */)"rlm_checkval: Could not find item named %s in request",
                 data->item_name);
#line 292
        module_fmsg_vp = pairmake("Module-Failure-Message", (char const   *)(module_fmsg),
                                  11);
#line 293
        pairadd(& (request->packet)->vps, module_fmsg_vp);
        }
      } else {
        {
#line 299
        snprintf((char */* __restrict  */)(module_fmsg___0), sizeof(module_fmsg___0),
                 (char const   */* __restrict  */)"rlm_checkval: This %s is not allowed for the user",
                 data->item_name);
#line 301
        module_fmsg_vp___0 = pairmake("Module-Failure-Message", (char const   *)(module_fmsg___0),
                                      11);
#line 302
        pairadd(& (request->packet)->vps, module_fmsg_vp___0);
        }
      }
    } else {
      {
#line 299
      snprintf((char */* __restrict  */)(module_fmsg___0), sizeof(module_fmsg___0),
               (char const   */* __restrict  */)"rlm_checkval: This %s is not allowed for the user",
               data->item_name);
#line 301
      module_fmsg_vp___0 = pairmake("Module-Failure-Message", (char const   *)(module_fmsg___0),
                                    11);
#line 302
      pairadd(& (request->packet)->vps, module_fmsg_vp___0);
      }
    }
  }
#line 307
  return (ret);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
static int checkval_authorize(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 314
  tmp = do_checkval(instance, request);
  }
#line 314
  return (tmp);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
static int checkval_accounting(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 319
  tmp = do_checkval(instance, request);
  }
#line 319
  return (tmp);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_checkval/rlm_checkval.c"
module_t rlm_checkval  =    {4109257426U, "checkval", 0, & checkval_instantiate, & checkval_detach, {(packetmethod )((void *)0),
                                                                            & checkval_authorize,
                                                                            (packetmethod )((void *)0),
                                                                            & checkval_accounting,
                                                                            (packetmethod )((void *)0),
                                                                            (packetmethod )((void *)0),
                                                                            (packetmethod )((void *)0),
                                                                            (packetmethod )((void *)0)}};
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___163[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___141[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___151[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___141[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___141[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___147[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___141[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___4(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___4(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___164[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___142[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___152[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___142[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___142[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___148[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___142[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___165[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___143[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___153[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___143[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___143[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___149[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___143[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___4[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___10  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___166[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___154[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___167[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___144[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___155[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___144[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___144[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___150[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___144[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___4(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___4(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___4(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___4(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___4(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___168[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___145[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___156[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___145[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___145[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___151[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___145[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___4[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___4[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___4(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___4[key & 255U] << 24) | ((int const   )reversed_byte___4[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___4[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___4[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___4(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___4[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___4[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___4[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___4[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___4(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___4(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___4(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___4(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___4(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___4(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___4(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___4(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___4(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___4(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___4(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___4(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___169[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___157[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___170[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___146[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___158[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___146[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___146[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___152[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___146[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___4[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___171[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___147[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___159[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___147[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___147[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___153[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___147[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___172[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___148[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___160[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___148[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___148[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___154[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___148[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___173[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___149[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___161[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___149[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___149[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___155[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___149[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___174[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___150[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___162[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___150[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___150[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___156[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___150[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___5  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___5  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___5  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___5(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___5(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___5(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___5(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___5(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___5;
#line 615
  salt_offset___5 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___5(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___5(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___5(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___5(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___5(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___5(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___5((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___5(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___5(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___5(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___5(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___5(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___5(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___5(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___5(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___5((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___5(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___5(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___175[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___151[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___163[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___151[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___151[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___157[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___151[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___176[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___152[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___164[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___152[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___152[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___158[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___152[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___5[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___5(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___177[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___153[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___165[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___153[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___153[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___159[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___153[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___5  =    {& Sentinel___5, & Sentinel___5, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___5(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___5)) {
    {
#line 60
    FreeWalker___5(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___5)) {
    {
#line 61
    FreeWalker___5(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___5(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___5)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___5)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___5)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___5(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___5)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___5)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___5)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___5(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___5(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___5(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___5(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___5(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___5(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___5(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___5)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___5)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___5(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___5)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___5(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___5(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___5)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___5)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___5(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___5)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___5(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___5(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___5)) {
    {
#line 523
    rcode = WalkNodePreOrder___5(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___5)) {
    {
#line 528
    rcode = WalkNodePreOrder___5(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___5(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___5)) {
    {
#line 545
    rcode = WalkNodeInOrder___5(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___5)) {
    {
#line 555
    rcode = WalkNodeInOrder___5(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___5(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___5)) {
    {
#line 572
    rcode = WalkNodeInOrder___5(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___5)) {
    {
#line 577
    rcode = WalkNodeInOrder___5(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___178[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___154[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___166[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___154[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___154[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___160[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___154[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___5(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___5(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___5[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___179[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___180[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___155[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___167[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___155[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___155[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___161[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___155[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___10[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___5(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___181[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___156[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___168[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___156[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___156[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___162[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___156[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___5[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___5[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___5[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___5[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___5[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___11(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___5(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___5, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___5, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___5, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___5(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___5, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___5(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___5(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___5(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___5(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___5, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___5, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___5(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___5, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___5(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___5(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___5(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___5(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___5, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___5(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___5, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___5[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___5[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___182[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___157[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___169[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___157[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___157[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___163[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___157[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___5  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___5  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___5(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___5, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___183[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___158[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___170[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___158[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___158[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___164[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___158[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___184[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___159[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___171[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___159[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___159[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___165[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___159[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_chap/rlm_chap.c"
static char const   rcsid___185[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___160[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___172[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___160[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___160[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___166[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___160[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___11[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h___4[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_chap/rlm_chap.c"
static int chap_authorize(void *instance , REQUEST *request ) 
{ 
  VALUE_PAIR *tmp ;
  VALUE_PAIR *tmp___0 ;
  VALUE_PAIR *tmp___1 ;

  {
  {
#line 38
  instance = instance;
#line 39
  request = request;
#line 41
  tmp = pairfind((request->packet)->vps, 3);
  }
#line 41
  if (! tmp) {
#line 42
    return (7);
  }
  {
#line 45
  tmp___0 = pairfind(request->config_items, 1000);
  }
#line 45
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 46
    if (request) {
#line 46
      if (request->radlog) {
        {
#line 46
        (*(request->radlog))(1, 2, request, "WARNING: Auth-Type already set.  Not setting to CHAP");
        }
      }
    }
#line 47
    return (7);
  }
#line 50
  if (request) {
#line 50
    if (request->radlog) {
      {
#line 50
      (*(request->radlog))(1, 1, request, "Setting \'Auth-Type := CHAP\'");
      }
    }
  }
  {
#line 51
  tmp___1 = pairmake("Auth-Type", "CHAP", 11);
#line 51
  pairadd(& request->config_items, tmp___1);
  }
#line 53
  return (2);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_chap/rlm_chap.c"
static int chap_authenticate(void *instance , REQUEST *request ) 
{ 
  VALUE_PAIR *passwd_item ;
  VALUE_PAIR *chap ;
  uint8_t pass_str[254] ;
  VALUE_PAIR *module_fmsg_vp ;
  char module_fmsg[254] ;
  int tmp ;

  {
#line 71
  instance = instance;
#line 72
  request = request;
#line 74
  if (! request->username) {
    {
#line 75
    radlog_request(2, 0, request, "rlm_chap: Attribute \"User-Name\" is required for authentication.\n");
    }
#line 76
    return (4);
  }
  {
#line 79
  chap = pairfind((request->packet)->vps, 3);
  }
#line 80
  if (! chap) {
#line 81
    if (request) {
#line 81
      if (request->radlog) {
        {
#line 81
        (*(request->radlog))(1, 1, request, "ERROR: You set \'Auth-Type = CHAP\' for a request that does not contain a CHAP-Password attribute!");
        }
      }
    }
#line 82
    return (4);
  }
#line 85
  if (chap->length == 0UL) {
#line 86
    if (request) {
#line 86
      if (request->radlog) {
        {
#line 86
        (*(request->radlog))(1, 1, request, "ERROR: CHAP-Password is empty");
        }
      }
    }
#line 87
    return (4);
  }
#line 90
  if (chap->length != 17UL) {
#line 91
    if (request) {
#line 91
      if (request->radlog) {
        {
#line 91
        (*(request->radlog))(1, 1, request, "ERROR: CHAP-Password has invalid length");
        }
      }
    }
#line 92
    return (4);
  }
#line 98
  if (request) {
#line 98
    if (request->radlog) {
      {
#line 98
      (*(request->radlog))(1, 1, request, "login attempt by \"%s\" with CHAP password",
                           (request->username)->data.strvalue);
      }
    }
  }
  {
#line 101
  passwd_item = pairfind(request->config_items, 1100);
  }
#line 101
  if ((unsigned long )passwd_item == (unsigned long )((void *)0)) {
#line 102
    if (request) {
#line 102
      if (request->radlog) {
        {
#line 102
        (*(request->radlog))(1, 1, request, "Cleartext-Password is required for authentication");
        }
      }
    }
    {
#line 103
    snprintf((char */* __restrict  */)(module_fmsg), sizeof(module_fmsg), (char const   */* __restrict  */)"rlm_chap: Clear text password not available");
#line 105
    module_fmsg_vp = pairmake("Module-Failure-Message", (char const   *)(module_fmsg),
                              11);
#line 107
    pairadd(& (request->packet)->vps, module_fmsg_vp);
    }
#line 108
    return (4);
  }
#line 111
  if (request) {
#line 111
    if (request->radlog) {
      {
#line 111
      (*(request->radlog))(1, 1, request, "Using clear text password \"%s\" for user %s authentication.",
                           passwd_item->data.strvalue, (request->username)->data.strvalue);
      }
    }
  }
  {
#line 114
  rad_chap_encode(request->packet, pass_str, (int )chap->data.octets[0], passwd_item);
#line 117
  tmp = rad_digest_cmp((uint8_t const   *)(pass_str + 1), (uint8_t const   *)(chap->data.octets + 1),
                       (size_t )16);
  }
#line 117
  if (tmp != 0) {
#line 119
    if (request) {
#line 119
      if (request->radlog) {
        {
#line 119
        (*(request->radlog))(1, 1, request, "Password check failed");
        }
      }
    }
    {
#line 120
    snprintf((char */* __restrict  */)(module_fmsg), sizeof(module_fmsg), (char const   */* __restrict  */)"rlm_chap: Wrong user password");
#line 122
    module_fmsg_vp = pairmake("Module-Failure-Message", (char const   *)(module_fmsg),
                              11);
#line 124
    pairadd(& (request->packet)->vps, module_fmsg_vp);
    }
#line 125
    return (0);
  }
#line 128
  if (request) {
#line 128
    if (request->radlog) {
      {
#line 128
      (*(request->radlog))(1, 1, request, "chap user %s authenticated succesfully",
                           (request->username)->data.strvalue);
      }
    }
  }
#line 131
  return (2);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_chap/rlm_chap.c"
module_t rlm_chap  =    {4109257426U, "CHAP", 1 << 1, (int (*)(CONF_SECTION *mod_cs , void **instance ))((void *)0),
    (int (*)(void *instance ))((void *)0), {& chap_authenticate, & chap_authorize,
                                            (packetmethod )((void *)0), (packetmethod )((void *)0),
                                            (packetmethod )((void *)0), (packetmethod )((void *)0),
                                            (packetmethod )((void *)0), (packetmethod )((void *)0)}};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___186[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___161[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___173[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___161[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___161[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___167[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___161[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___5[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___5(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___5(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___5(& p, " \t");
#line 726
  f[1] = mystrtok___5(& p, " \t");
#line 727
  f[2] = mystrtok___5(& p, " \t");
#line 728
  f[3] = mystrtok___5(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___5[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___11  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___5(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___5(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___5(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___5[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___187[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___162[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___174[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___162[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___162[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___168[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___162[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___188[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___169[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___189[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___163[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___175[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___163[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___163[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___170[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___163[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___5[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___190[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___164[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___176[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___164[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___164[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___171[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___164[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___5(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___5(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___5(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___191[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___165[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___177[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___165[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___165[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___172[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___165[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___5  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___5  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___5  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___5  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___5  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___5  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___5[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___5  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___5  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___5  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___5  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___5  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___5[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___5(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___5(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___5((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___5(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___5(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___5(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___5(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___5((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___5(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___5(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___5(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___5(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___5((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___5(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___5(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___5(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___5(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___5);
#line 240
  stat_root_dir___5 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___5);
#line 242
  stat_root_file___5 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___5) {
#line 245
    stat_tail___5 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___5;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___5 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___5 = stat_tail___5;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___5(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___5) {
#line 274
    stat_tail___5 = this;
#line 274
    stat_head___5 = stat_tail___5;
  } else {
#line 276
    stat_tail___5->next = this;
#line 277
    stat_tail___5 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___5(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___5) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___5) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___5);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___5);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___5) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___5;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___5  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___5(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___5(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___5(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___5) {
    {
#line 359
    dict_pool___5 = fr_pool_create___5();
    }
#line 360
    if (! dict_pool___5) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___5->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___5->page_free)->page_end)) {
    {
#line 368
    (dict_pool___5->page_free)->page_next = fr_pool_create___5();
    }
#line 369
    if (! (dict_pool___5->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___5->page_free = (dict_pool___5->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___5->page_free)->free_ptr;
#line 374
  (dict_pool___5->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___5->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___5(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___5  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___5  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___5  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___5(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___5(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___5((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___5, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___5, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___5(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___5((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___5(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___5(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___5, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___5((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___5(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___12(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___5(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___5(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___12(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___5(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___5(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___5(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___5(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___5(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___5(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___192[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___166[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___178[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___166[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___166[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___173[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___166[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___5(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___5(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___193[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___167[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___179[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___167[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___167[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___174[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___167[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___194[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___168[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___180[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___168[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___168[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___175[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___168[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___5[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___12  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___195[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___181[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___196[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___169[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___182[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___169[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___169[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___176[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___169[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___5(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___5(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___5(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___5(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___5(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___197[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___170[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___183[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___170[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___170[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___177[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___170[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___5[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___5[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___5(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___5[key & 255U] << 24) | ((int const   )reversed_byte___5[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___5[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___5[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___5(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___5[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___5[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___5[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___5[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___5(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___5(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___5(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___5(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___5(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___5(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___5(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___5(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___5(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___5(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___5(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___5(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___198[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___184[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___199[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___171[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___185[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___171[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___171[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___178[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___171[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___5[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___200[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___172[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___186[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___172[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___172[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___179[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___172[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___201[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___173[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___187[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___173[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___173[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___180[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___173[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___202[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___174[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___188[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___174[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___174[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___181[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___174[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___203[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___175[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___189[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___175[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___175[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___182[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___175[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___21[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___6  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___6  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___6  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___6(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___6(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___6(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___6(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___6(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___6;
#line 615
  salt_offset___6 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___6(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___6(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___6(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___6(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___6(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___6(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___6((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___6(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___6(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___6(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___6(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___6(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___6(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___6(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___6(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___6((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___6(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___6(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___204[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___176[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___190[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___176[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___176[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___183[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___176[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___205[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___177[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___191[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___177[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___177[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___184[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___177[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___6[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___6(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___206[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___178[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___192[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___178[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___178[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___185[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___178[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___6  =    {& Sentinel___6, & Sentinel___6, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___6(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___6)) {
    {
#line 60
    FreeWalker___6(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___6)) {
    {
#line 61
    FreeWalker___6(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___6(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___6)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___6)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___6)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___6(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___6)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___6)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___6)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___6(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___6(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___6(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___6(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___6(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___6(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___6(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___6)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___6)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___6(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___6)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___6(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___6(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___6)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___6)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___6(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___6)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___6(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___6(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___6)) {
    {
#line 523
    rcode = WalkNodePreOrder___6(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___6)) {
    {
#line 528
    rcode = WalkNodePreOrder___6(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___6(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___6)) {
    {
#line 545
    rcode = WalkNodeInOrder___6(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___6)) {
    {
#line 555
    rcode = WalkNodeInOrder___6(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___6(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___6)) {
    {
#line 572
    rcode = WalkNodeInOrder___6(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___6)) {
    {
#line 577
    rcode = WalkNodeInOrder___6(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___207[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___179[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___193[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___179[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___179[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___186[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___179[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___6(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___6(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___6[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___208[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 22 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
static char const   rcsid___209[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___180[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___194[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___180[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___180[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___187[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___180[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___12[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h___5[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 47 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
static CONF_PARSER const   module_config___3[4]  = {      {"rcode", 100, (unsigned long )(& ((rlm_always_t *)0)->rcode_str), (void *)0,
      "fail"}, 
        {"simulcount", 1, (unsigned long )(& ((rlm_always_t *)0)->simulcount), (void *)0,
      "0"}, 
        {"mpp", 101, (unsigned long )(& ((rlm_always_t *)0)->mpp), (void *)0, "no"}, 
        {(char const   *)((void *)0), -1, (size_t )0, (void *)0, (char const   *)((void *)0)}};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
static int str2rcode(char const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 60
  tmp___7 = strcasecmp(s, "reject");
  }
#line 60
  if (tmp___7) {
    {
#line 62
    tmp___6 = strcasecmp(s, "fail");
    }
#line 62
    if (tmp___6) {
      {
#line 64
      tmp___5 = strcasecmp(s, "ok");
      }
#line 64
      if (tmp___5) {
        {
#line 66
        tmp___4 = strcasecmp(s, "handled");
        }
#line 66
        if (tmp___4) {
          {
#line 68
          tmp___3 = strcasecmp(s, "invalid");
          }
#line 68
          if (tmp___3) {
            {
#line 70
            tmp___2 = strcasecmp(s, "userlock");
            }
#line 70
            if (tmp___2) {
              {
#line 72
              tmp___1 = strcasecmp(s, "notfound");
              }
#line 72
              if (tmp___1) {
                {
#line 74
                tmp___0 = strcasecmp(s, "noop");
                }
#line 74
                if (tmp___0) {
                  {
#line 76
                  tmp = strcasecmp(s, "updated");
                  }
#line 76
                  if (tmp) {
                    {
#line 79
                    radlog(132, "rlm_always: Unknown module rcode \'%s\'.\n", s);
                    }
#line 81
                    return (-1);
                  } else {
#line 77
                    return (8);
                  }
                } else {
#line 75
                  return (7);
                }
              } else {
#line 73
                return (6);
              }
            } else {
#line 71
              return (5);
            }
          } else {
#line 69
            return (4);
          }
        } else {
#line 67
          return (3);
        }
      } else {
#line 65
        return (2);
      }
    } else {
#line 63
      return (1);
    }
  } else {
#line 61
    return (0);
  }
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
static int always_instantiate(CONF_SECTION *conf , void **instance ) 
{ 
  rlm_always_t *data ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 92
  tmp = rad_malloc(sizeof(*data));
#line 92
  data = (rlm_always_t *)tmp;
  }
#line 93
  if (! data) {
#line 94
    return (-1);
  }
  {
#line 96
  memset((void *)data, 0, sizeof(*data));
#line 102
  tmp___0 = cf_section_parse(conf, (void *)data, module_config___3);
  }
#line 102
  if (tmp___0 < 0) {
    {
#line 103
    free((void *)data);
    }
#line 104
    return (-1);
  }
  {
#line 110
  data->rcode = str2rcode((char const   *)data->rcode_str);
  }
#line 111
  if (data->rcode == -1) {
    {
#line 112
    free((void *)data);
    }
#line 113
    return (-1);
  }
#line 116
  *instance = (void *)data;
#line 118
  return (0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
static int always_return(void *instance , REQUEST *request ) 
{ 


  {
#line 128
  request = request;
#line 130
  return (((struct rlm_always_t *)instance)->rcode);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
static int always_checksimul(void *instance , REQUEST *request ) 
{ 
  struct rlm_always_t *inst ;

  {
#line 138
  inst = (struct rlm_always_t *)instance;
#line 140
  request->simul_count = inst->simulcount;
#line 142
  if (inst->mpp) {
#line 143
    request->simul_mpp = 2;
  }
#line 145
  return (inst->rcode);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
static int always_detach(void *instance ) 
{ 


  {
  {
#line 150
  free(instance);
  }
#line 151
  return (0);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_always/rlm_always.c"
module_t rlm_always  =    {4109257426U, "always", 1 << 1, & always_instantiate, & always_detach, {& always_return,
                                                                           & always_return,
                                                                           & always_return,
                                                                           & always_return,
                                                                           & always_checksimul,
                                                                           & always_return,
                                                                           & always_return,
                                                                           & always_return,
                                                                           & always_return,
                                                                           & always_return}};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___210[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___181[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___195[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___181[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___181[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___188[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___181[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___13[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___6(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___211[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___182[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___196[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___182[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___182[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___189[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___182[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___6[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___6[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___6[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___6[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___6[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___13(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___6(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___6, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___6, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___6, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___6(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___6, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___6(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___6(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___6(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___6(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___6, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___6, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___6(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___6, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___6(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___6(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___6(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___6(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___6, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___6(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___6, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___6[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___6[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___212[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___183[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___197[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___183[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___183[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___190[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___183[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___6  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___6  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___6(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___6, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___213[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___184[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___198[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___184[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___184[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___191[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___184[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___21[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___214[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___185[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___199[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___185[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___185[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___192[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___185[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___215[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___186[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___200[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___186[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___186[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___193[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___186[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___6[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___6(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___6(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___6(& p, " \t");
#line 726
  f[1] = mystrtok___6(& p, " \t");
#line 727
  f[2] = mystrtok___6(& p, " \t");
#line 728
  f[3] = mystrtok___6(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___6[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___13  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___6(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___6(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___6(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___6[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___216[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___22[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___187[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___201[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___187[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___187[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___194[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___187[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___217[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___195[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___218[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___188[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___202[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___188[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___188[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___196[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___188[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___6[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___219[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___189[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___203[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___189[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___189[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___197[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___189[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___6(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___6(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___6(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___220[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___190[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___204[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___190[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___190[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___198[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___190[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___6  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___6  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___6  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___6  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___6  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___6  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___6[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___6  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___6  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___6  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___6  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___6  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___6[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___6(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___6(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___6((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___6(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___6(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___6(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___6(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___6((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___6(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___6(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___6(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___6(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___6((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___6(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___6(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___6(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___6(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___6);
#line 240
  stat_root_dir___6 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___6);
#line 242
  stat_root_file___6 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___6) {
#line 245
    stat_tail___6 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___6;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___6 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___6 = stat_tail___6;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___6(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___6) {
#line 274
    stat_tail___6 = this;
#line 274
    stat_head___6 = stat_tail___6;
  } else {
#line 276
    stat_tail___6->next = this;
#line 277
    stat_tail___6 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___6(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___6) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___6) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___6);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___6);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___6) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___6;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___6  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___6(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___6(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___6(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___6) {
    {
#line 359
    dict_pool___6 = fr_pool_create___6();
    }
#line 360
    if (! dict_pool___6) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___6->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___6->page_free)->page_end)) {
    {
#line 368
    (dict_pool___6->page_free)->page_next = fr_pool_create___6();
    }
#line 369
    if (! (dict_pool___6->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___6->page_free = (dict_pool___6->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___6->page_free)->free_ptr;
#line 374
  (dict_pool___6->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___6->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___6(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___6  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___6  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___6  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___6(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___6(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___6((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___6, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___6, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___6(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___6((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___6(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___6(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___6, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___6((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___6(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___14(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___6(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___6(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___14(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___6(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___6(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___6(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___6(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___6(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___6(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___221[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___191[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___205[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___191[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___191[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___199[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___191[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___6(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___6(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___222[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___192[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___206[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___192[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___192[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___200[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___192[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___223[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___193[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___207[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___193[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___193[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___201[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___193[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___6[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___14  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___224[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___208[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___225[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___194[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___209[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___194[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___194[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___202[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___194[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___6(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___6(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___6(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___6(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___6(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___226[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___195[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___210[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___195[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___195[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___203[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___195[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___6[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___6[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___6(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___6[key & 255U] << 24) | ((int const   )reversed_byte___6[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___6[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___6[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___6(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___6[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___6[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___6[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___6[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___6(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___6(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___6(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___6(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___6(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___6(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___6(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___6(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___6(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___6(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___6(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___6(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___227[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___211[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___228[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___196[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___212[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___196[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___196[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___204[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___196[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___22[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___6[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___229[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___197[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___213[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___197[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___197[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___205[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___197[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___230[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___198[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___214[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___198[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___198[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___206[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___198[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___231[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___199[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___215[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___199[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___199[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___207[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___199[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___23[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___232[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___200[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___216[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___200[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___200[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___208[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___200[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___24[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___7  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___7  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___7  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___7(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___7(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___7(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___7(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___7(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___7;
#line 615
  salt_offset___7 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___7(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___7(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___7(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___7(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___7(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___7(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___7((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___7(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___7(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___7(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___7(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___7(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___7(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___7(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___7(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___7((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___7(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___7(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___233[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___201[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___217[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___201[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___201[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___209[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___201[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___234[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___202[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___218[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___202[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___202[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___210[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___202[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___7[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___7(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___235[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___203[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___219[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___203[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___203[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___211[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___203[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___7  =    {& Sentinel___7, & Sentinel___7, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___7(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___7)) {
    {
#line 60
    FreeWalker___7(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___7)) {
    {
#line 61
    FreeWalker___7(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___7(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___7)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___7)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___7)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___7(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___7)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___7)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___7)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___7(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___7(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___7(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___7(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___7(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___7(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___7(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___7)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___7)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___7(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___7)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___7(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___7(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___7)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___7)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___7(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___7)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___7(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___7(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___7)) {
    {
#line 523
    rcode = WalkNodePreOrder___7(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___7)) {
    {
#line 528
    rcode = WalkNodePreOrder___7(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___7(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___7)) {
    {
#line 545
    rcode = WalkNodeInOrder___7(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___7)) {
    {
#line 555
    rcode = WalkNodeInOrder___7(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___7(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___7)) {
    {
#line 572
    rcode = WalkNodeInOrder___7(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___7)) {
    {
#line 577
    rcode = WalkNodeInOrder___7(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___236[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___204[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___220[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___204[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___204[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___212[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___204[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___23[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___7(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___7(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___7[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___237[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static char const   rcsid___238[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___205[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___221[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___205[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___205[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___213[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___205[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___14[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 535 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
extern int pairlist_read(char const   *file , PAIR_LIST **list , int complain ) ;
#line 536
extern void pairlist_free(PAIR_LIST ** ) ;
#line 582
extern void pairxlatmove(REQUEST * , VALUE_PAIR **to , VALUE_PAIR **from ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h___6[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/rad_assert.h"
static char const   rcsid_rad_assert_h___0[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 50 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static CONF_PARSER const   module_config___4[4]  = {      {"attrsfile", 103, (unsigned long )(& ((struct attr_filter_instance *)0)->attrsfile),
      (void *)0, "${raddbdir}/attrs"}, 
        {"key", 100, (unsigned long )(& ((struct attr_filter_instance *)0)->key), (void *)0,
      "%{Realm}"}, 
        {"relaxed", 101, (unsigned long )(& ((struct attr_filter_instance *)0)->relaxed),
      (void *)0, "no"}, 
        {(char const   *)((void *)0), -1, (size_t )0, (void *)0, (char const   *)((void *)0)}};
#line 60 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static void check_pair(VALUE_PAIR *check_item , VALUE_PAIR *reply_item , int *pass ,
                       int *fail ) 
{ 
  int compare ;

  {
#line 65
  if ((unsigned int )check_item->operator == 10U) {
#line 65
    return;
  }
  {
#line 67
  compare = paircmp(check_item, reply_item);
  }
#line 68
  if (compare == 1) {
#line 69
    (*pass) ++;
  } else {
#line 71
    (*fail) ++;
  }
#line 74
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int getattrsfile(char const   *filename , PAIR_LIST **pair_list ) 
{ 
  int rcode ;
  PAIR_LIST *attrs ;
  PAIR_LIST *entry ;
  VALUE_PAIR *vp ;

  {
  {
#line 81
  attrs = (PAIR_LIST *)((void *)0);
#line 85
  rcode = pairlist_read(filename, & attrs, 1);
  }
#line 86
  if (rcode < 0) {
#line 87
    return (-1);
  }
#line 94
  entry = attrs;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! entry) {
#line 95
      goto while_break;
    }
#line 97
    entry->check = entry->reply;
#line 98
    entry->reply = (VALUE_PAIR *)((void *)0);
#line 100
    vp = entry->check;
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 100
        goto while_break___0;
      }
#line 108
      if (! (vp->attribute & -65536)) {
#line 108
        if (vp->attribute > 255) {
#line 108
          if (vp->attribute > 1000) {
            {
#line 111
            log_debug("[%s]:%d WARNING! Check item \"%s\"\n\tfound in filter list for realm \"%s\".\n",
                      filename, entry->lineno, vp->name, entry->name);
            }
          }
        }
      }
#line 100
      vp = vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 118
    entry = entry->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  *pair_list = attrs;
#line 122
  return (0);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int attr_filter_detach(void *instance ) 
{ 
  struct attr_filter_instance *inst ;

  {
  {
#line 131
  inst = (struct attr_filter_instance *)instance;
#line 132
  pairlist_free(& inst->attrs);
#line 133
  free((void *)inst);
  }
#line 134
  return (0);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int attr_filter_instantiate(CONF_SECTION *conf , void **instance ) 
{ 
  struct attr_filter_instance *inst ;
  int rcode ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 146
  tmp = rad_malloc(sizeof(*inst));
#line 146
  inst = (struct attr_filter_instance *)tmp;
  }
#line 147
  if (! inst) {
#line 148
    return (-1);
  }
  {
#line 150
  memset((void *)inst, 0, sizeof(*inst));
#line 152
  tmp___0 = cf_section_parse(conf, (void *)inst, module_config___4);
  }
#line 152
  if (tmp___0 < 0) {
    {
#line 153
    attr_filter_detach((void *)inst);
    }
#line 154
    return (-1);
  }
  {
#line 157
  rcode = getattrsfile((char const   *)inst->attrsfile, & inst->attrs);
  }
#line 158
  if (rcode != 0) {
    {
#line 159
    radlog(132, "Errors reading %s", inst->attrsfile);
#line 160
    attr_filter_detach((void *)inst);
    }
#line 161
    return (-1);
  }
#line 163
  *instance = (void *)inst;
#line 164
  return (0);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int attr_filter_common(void *instance , REQUEST *request , RADIUS_PACKET *packet ) 
{ 
  struct attr_filter_instance *inst ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *output ;
  VALUE_PAIR **output_tail ;
  VALUE_PAIR *check_item ;
  PAIR_LIST *pl ;
  int found ;
  int pass ;
  int fail ;
  char *keyname ;
  VALUE_PAIR **input ;
  char buffer[256] ;
  VALUE_PAIR *namepair ;
  int len ;
  int fall_through ;
  int relax_filter ;
  int tmp ;
  int tmp___0 ;

  {
#line 174
  inst = (struct attr_filter_instance *)instance;
#line 180
  found = 0;
#line 181
  fail = 0;
#line 182
  keyname = (char *)((void *)0);
#line 186
  if (! packet) {
#line 186
    return (7);
  }
#line 188
  input = & packet->vps;
#line 190
  if (! inst->key) {
    {
#line 193
    namepair = pairfind((request->packet)->vps, 1045);
    }
#line 194
    if (! namepair) {
#line 195
      return (7);
    }
#line 197
    keyname = namepair->data.strvalue;
  } else {
    {
#line 201
    len = radius_xlat(buffer, (int )sizeof(buffer), (char const   *)inst->key, request,
                      (size_t (*)(char *out , size_t outlen , char const   *in ))((void *)0));
    }
#line 203
    if (! len) {
#line 204
      return (7);
    }
#line 206
    keyname = buffer;
  }
#line 209
  output = (VALUE_PAIR *)((void *)0);
#line 210
  output_tail = & output;
#line 215
  pl = inst->attrs;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! pl) {
#line 215
      goto while_break;
    }
    {
#line 216
    fall_through = 0;
#line 217
    relax_filter = inst->relaxed;
#line 224
    tmp = strcmp(pl->name, "DEFAULT");
    }
#line 224
    if (tmp != 0) {
      {
#line 224
      tmp___0 = strcmp((char const   *)keyname, pl->name);
      }
#line 224
      if (tmp___0 != 0) {
#line 226
        goto __Cont;
      }
    }
#line 229
    if (debug_flag > 1) {
      {
#line 229
      log_debug("attr_filter: Matched entry %s at line %d", pl->name, pl->lineno);
      }
    }
#line 231
    found = 1;
#line 233
    check_item = pl->check;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! ((unsigned long )check_item != (unsigned long )((void *)0))) {
#line 233
        goto while_break___0;
      }
#line 236
      if (check_item->attribute == 500) {
#line 236
        if (check_item->lvalue == 1U) {
#line 238
          fall_through = 1;
#line 239
          goto __Cont___0;
        } else {
#line 236
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 241
      if (check_item->attribute == 501) {
#line 242
        relax_filter = (int )check_item->lvalue;
#line 243
        goto __Cont___0;
      }
#line 250
      if ((unsigned int )check_item->operator == 10U) {
        {
#line 251
        vp = paircopyvp((VALUE_PAIR const   *)check_item);
        }
#line 252
        if (! vp) {
          {
#line 253
          pairfree(& output);
          }
#line 254
          return (1);
        }
        {
#line 256
        pairxlatmove(request, output_tail, & vp);
#line 257
        output_tail = & (*output_tail)->next;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 233
      check_item = check_item->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 269
    vp = *input;
    {
#line 269
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 269
      if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 269
        goto while_break___1;
      }
#line 271
      fail = 0;
#line 271
      pass = fail;
#line 277
      check_item = pl->check;
      {
#line 277
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 277
        if (! ((unsigned long )check_item != (unsigned long )((void *)0))) {
#line 277
          goto while_break___2;
        }
#line 285
        if (check_item->attribute == 26) {
#line 285
          if (((vp->attribute >> 16) & 65535) != 0) {
#line 285
            if ((unsigned int )check_item->operator == 19U) {
#line 288
              pass ++;
#line 289
              goto __Cont___1;
            }
          }
        }
#line 292
        if (vp->attribute == check_item->attribute) {
          {
#line 293
          check_pair(check_item, vp, & pass, & fail);
          }
        }
        __Cont___1: /* CIL Label */ 
#line 277
        check_item = check_item->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 303
      if (fail == 0) {
#line 303
        if (pass > 0) {
#line 303
          goto _L___0;
        } else
#line 303
        if (relax_filter) {
          _L___0: /* CIL Label */ 
#line 304
          if (! pass) {
#line 305
            if (debug_flag > 2) {
              {
#line 305
              log_debug("attr_filter: Attribute (%s) allowed by relaxed mode", vp->name);
              }
            }
          }
          {
#line 307
          *output_tail = paircopyvp((VALUE_PAIR const   *)vp);
          }
#line 308
          if (! *output_tail) {
            {
#line 309
            pairfree(& output);
            }
#line 310
            return (1);
          }
#line 312
          output_tail = & (*output_tail)->next;
        }
      }
#line 269
      vp = vp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 317
    if (! fall_through) {
#line 318
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 215
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  if (! found) {
#line 326
    return (7);
  }
  {
#line 329
  pairfree(input);
#line 330
  *input = output;
  }
#line 332
  if ((request->packet)->code == 1U) {
    {
#line 333
    request->username = pairfind((request->packet)->vps, 1043);
    }
#line 335
    if (! request->username) {
      {
#line 336
      request->username = pairfind((request->packet)->vps, 1);
      }
    }
    {
#line 338
    request->password = pairfind((request->packet)->vps, 2);
    }
  }
#line 342
  return (8);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int attr_filter_preacct(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 347
  tmp = attr_filter_common(instance, request, request->packet);
  }
#line 347
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int attr_filter_accounting(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 352
  tmp = attr_filter_common(instance, request, request->reply);
  }
#line 352
  return (tmp);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int attr_filter_preproxy(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 357
  tmp = attr_filter_common(instance, request, request->proxy);
  }
#line 357
  return (tmp);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int attr_filter_postproxy(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 362
  tmp = attr_filter_common(instance, request, request->proxy_reply);
  }
#line 362
  return (tmp);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int attr_filter_postauth(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 367
  tmp = attr_filter_common(instance, request, request->reply);
  }
#line 367
  return (tmp);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
static int attr_filter_authorize(void *instance , REQUEST *request ) 
{ 
  int tmp ;

  {
  {
#line 372
  tmp = attr_filter_common(instance, request, request->packet);
  }
#line 372
  return (tmp);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_attr_filter/rlm_attr_filter.c"
module_t rlm_attr_filter  =    {4109257426U, "attr_filter", (1 << 1) | (1 << 2), & attr_filter_instantiate, & attr_filter_detach,
    {(packetmethod )((void *)0), & attr_filter_authorize, & attr_filter_preacct, & attr_filter_accounting,
     (packetmethod )((void *)0), & attr_filter_preproxy, & attr_filter_postproxy,
     & attr_filter_postauth}};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___239[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___206[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___222[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___206[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___206[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___214[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___206[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___15[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___7(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___240[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___207[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___223[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___207[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___207[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___215[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___207[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___7[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___7[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___7[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___7[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___7[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___15(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___7(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___7, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___7, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___7, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___7(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___7, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___7(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___7(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___7(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___7(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___7, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___7, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___7(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___7, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___7(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___7(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___7(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___7(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___7, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___7(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___7, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___7[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___7[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___241[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___208[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___224[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___208[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___208[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___216[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___208[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___7  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___7  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___7(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___7, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___242[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___209[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___225[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___209[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___209[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___217[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___209[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___24[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___243[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___210[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___226[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___210[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___210[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___218[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___210[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___244[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___211[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___227[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___211[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___211[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___219[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___211[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___7[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___7(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___7(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___7(& p, " \t");
#line 726
  f[1] = mystrtok___7(& p, " \t");
#line 727
  f[2] = mystrtok___7(& p, " \t");
#line 728
  f[3] = mystrtok___7(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___7[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___15  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___7(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___7(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___7(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___7[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___245[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___25[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___212[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___228[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___212[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___212[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___220[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___212[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___246[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___221[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___247[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___213[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___229[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___213[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___213[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___222[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___213[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___7[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___248[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___214[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___230[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___214[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___214[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___223[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___214[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___7(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___7(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___7(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___249[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___215[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___231[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___215[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___215[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___224[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___215[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___7  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___7  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___7  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___7  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___7  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___7  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___7[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___7  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___7  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___7  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___7  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___7  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___7[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___7(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___7(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___7((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___7(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___7(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___7(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___7(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___7((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___7(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___7(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___7(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___7(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___7((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___7(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___7(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___7(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___7(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___7);
#line 240
  stat_root_dir___7 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___7);
#line 242
  stat_root_file___7 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___7) {
#line 245
    stat_tail___7 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___7;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___7 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___7 = stat_tail___7;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___7(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___7) {
#line 274
    stat_tail___7 = this;
#line 274
    stat_head___7 = stat_tail___7;
  } else {
#line 276
    stat_tail___7->next = this;
#line 277
    stat_tail___7 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___7(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___7) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___7) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___7);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___7);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___7) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___7;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___7  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___7(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___7(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___7(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___7) {
    {
#line 359
    dict_pool___7 = fr_pool_create___7();
    }
#line 360
    if (! dict_pool___7) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___7->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___7->page_free)->page_end)) {
    {
#line 368
    (dict_pool___7->page_free)->page_next = fr_pool_create___7();
    }
#line 369
    if (! (dict_pool___7->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___7->page_free = (dict_pool___7->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___7->page_free)->free_ptr;
#line 374
  (dict_pool___7->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___7->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___7(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___7  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___7  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___7  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___7(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___7(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___7((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___7, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___7, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___7(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___7((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___7(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___7(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___7, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___7((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___7(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___16(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___7(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___7(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___16(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___7(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___7(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___7(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___7(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___7(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___7(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___250[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___216[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___232[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___216[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___216[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___225[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___216[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___7(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___7(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___251[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___217[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___233[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___217[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___217[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___226[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___217[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___252[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___218[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___234[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___218[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___218[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___227[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___218[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___7[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___16  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___253[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___235[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___254[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___219[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___236[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___219[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___219[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___228[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___219[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___7(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___7(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___7(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___7(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___7(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___255[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___220[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___237[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___220[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___220[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___229[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___220[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___7[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___7[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___7(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___7[key & 255U] << 24) | ((int const   )reversed_byte___7[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___7[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___7[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___7(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___7[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___7[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___7[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___7[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___7(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___7(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___7(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___7(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___7(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___7(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___7(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___7(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___7(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___7(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___7(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___7(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___256[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___238[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___257[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___221[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___239[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___221[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___221[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___230[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___221[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___25[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___7[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___258[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___222[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___240[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___222[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___222[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___231[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___222[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___259[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___223[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___241[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___223[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___223[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___232[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___223[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___260[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___224[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___242[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___224[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___224[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___233[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___224[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___26[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___261[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___225[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___243[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___225[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___225[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___234[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___225[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___27[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___8  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___8  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___8  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___8(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___8(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___8(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___8(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___8(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___8;
#line 615
  salt_offset___8 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___8(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___8(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___8(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___8(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___8(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___8(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___8((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___8(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___8(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___8(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___8(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___8(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___8(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___8(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___8(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___8((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___8(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___8(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___262[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___226[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___244[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___226[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___226[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___235[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___226[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___263[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___227[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___245[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___227[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___227[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___236[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___227[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___8[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___8(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___264[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___228[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___246[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___228[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___228[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___237[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___228[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___8  =    {& Sentinel___8, & Sentinel___8, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___8(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___8)) {
    {
#line 60
    FreeWalker___8(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___8)) {
    {
#line 61
    FreeWalker___8(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___8(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___8)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___8)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___8)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___8(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___8)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___8)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___8)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___8(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___8(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___8(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___8(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___8(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___8(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___8(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___8)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___8)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___8(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___8)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___8(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___8(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___8)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___8)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___8(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___8)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___8(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___8(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___8)) {
    {
#line 523
    rcode = WalkNodePreOrder___8(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___8)) {
    {
#line 528
    rcode = WalkNodePreOrder___8(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___8(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___8)) {
    {
#line 545
    rcode = WalkNodeInOrder___8(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___8)) {
    {
#line 555
    rcode = WalkNodeInOrder___8(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___8(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___8)) {
    {
#line 572
    rcode = WalkNodeInOrder___8(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___8)) {
    {
#line 577
    rcode = WalkNodeInOrder___8(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___265[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___229[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___247[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___229[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___229[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___238[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___229[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___26[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___8(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___8(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___8[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___266[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___267[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___230[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___248[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___230[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___230[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___239[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___230[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___16[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___8(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___268[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___231[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___249[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___231[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___231[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___240[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___231[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___8[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___8[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___8[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___8[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___8[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___17(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___8(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___8, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___8, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___8, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___8(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___8, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___8(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___8(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___8(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___8(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___8, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___8, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___8(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___8, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___8(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___8(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___8(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___8(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___8, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___8(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___8, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___8[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___8[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___269[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___232[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___250[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___232[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___232[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___241[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___232[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___8  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___8  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___8(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___8, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___270[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___233[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___251[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___233[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___233[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___242[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___233[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___27[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___271[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___234[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___252[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___234[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___234[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___243[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___234[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___272[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___235[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___253[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___235[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___235[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___244[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___235[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___8[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___8(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___8(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___8(& p, " \t");
#line 726
  f[1] = mystrtok___8(& p, " \t");
#line 727
  f[2] = mystrtok___8(& p, " \t");
#line 728
  f[3] = mystrtok___8(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___8[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___17  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___8(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___8(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___8(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___8[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___273[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___28[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___236[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___254[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___236[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___236[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___245[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___236[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___274[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___246[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___275[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___237[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___255[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___237[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___237[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___247[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___237[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___8[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___276[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___238[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___256[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___238[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___238[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___248[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___238[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___8(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___8(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___8(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___277[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___239[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___257[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___239[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___239[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___249[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___239[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___8  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___8  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___8  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___8  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___8  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___8  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___8[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___8  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___8  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___8  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___8  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___8  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___8[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___8(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___8(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___8((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___8(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___8(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___8(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___8(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___8((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___8(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___8(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___8(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___8(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___8((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___8(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___8(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___8(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___8(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___8);
#line 240
  stat_root_dir___8 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___8);
#line 242
  stat_root_file___8 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___8) {
#line 245
    stat_tail___8 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___8;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___8 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___8 = stat_tail___8;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___8(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___8) {
#line 274
    stat_tail___8 = this;
#line 274
    stat_head___8 = stat_tail___8;
  } else {
#line 276
    stat_tail___8->next = this;
#line 277
    stat_tail___8 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___8(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___8) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___8) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___8);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___8);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___8) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___8;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___8  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___8(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___8(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___8(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___8) {
    {
#line 359
    dict_pool___8 = fr_pool_create___8();
    }
#line 360
    if (! dict_pool___8) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___8->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___8->page_free)->page_end)) {
    {
#line 368
    (dict_pool___8->page_free)->page_next = fr_pool_create___8();
    }
#line 369
    if (! (dict_pool___8->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___8->page_free = (dict_pool___8->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___8->page_free)->free_ptr;
#line 374
  (dict_pool___8->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___8->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___8(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___8  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___8  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___8  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___8(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___8(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___8((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___8, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___8, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___8(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___8((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___8(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___8(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___8, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___8((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___8(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___18(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___8(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___8(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___18(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___8(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___8(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___8(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___8(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___8(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___8(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___278[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___240[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___258[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___240[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___240[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___250[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___240[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___8(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___8(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___279[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___241[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___259[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___241[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___241[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___251[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___241[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___280[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___242[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___260[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___242[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___242[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___252[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___242[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___8[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___18  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___281[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___261[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___282[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___243[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___262[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___243[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___243[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___253[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___243[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___8(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___8(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___8(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___8(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___8(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
static char const   rcsid___283[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___244[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___263[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___244[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___244[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___254[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___244[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___17[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h___7[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 44 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
static CONF_PARSER const   module_config___5[2]  = {      {"key", 100, (unsigned long )(& ((rlm_acct_unique_t *)0)->key), (void *)0, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      -1, (size_t )0, (void *)0, (char const   *)((void *)0)}};
#line 52 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
static void unique_add_attr(rlm_acct_unique_t *inst , DICT_ATTR *dattr ) 
{ 
  rlm_acct_unique_list_t *new ;
  void *tmp ;

  {
  {
#line 56
  tmp = rad_malloc(sizeof(*new));
#line 56
  new = (rlm_acct_unique_list_t *)tmp;
#line 57
  memset((void *)new, 0, sizeof(*new));
#line 60
  new->dattr = dattr;
#line 62
  new->next = inst->head;
#line 63
  inst->head = new;
  }
#line 64
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
static int unique_parse_key(rlm_acct_unique_t *inst , char *key ) 
{ 
  char *ptr ;
  char *prev ;
  char *keyptr ;
  DICT_ATTR *a ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 74
  prev = key;
#line 75
  ptr = key;
#line 75
  keyptr = ptr;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! *keyptr) {
#line 78
      goto while_break;
    }
    {
#line 79
    tmp___1 = __ctype_b_loc();
    }
#line 79
    if ((int const   )*(*tmp___1 + (int )*keyptr) & 8192) {
#line 80
      keyptr ++;
    } else {
#line 82
      tmp = ptr;
#line 82
      ptr ++;
#line 82
      tmp___0 = keyptr;
#line 82
      keyptr ++;
#line 82
      *tmp = *tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  *ptr = (char )'\000';
#line 87
  ptr = key;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! ptr) {
#line 88
      goto while_break___0;
    }
    {
#line 90
    if ((int )*ptr == 44) {
#line 90
      goto case_44;
    }
#line 100
    if ((int )*ptr == 0) {
#line 100
      goto case_0;
    }
#line 108
    if ((int )*ptr == 32) {
#line 108
      goto case_32;
    }
#line 89
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 91
    *ptr = (char )'\000';
#line 92
    a = dict_attrbyname((char const   *)prev);
    }
#line 92
    if ((unsigned long )a == (unsigned long )((void *)0)) {
      {
#line 93
      radlog(4, "rlm_acct_unique: Cannot find attribute \'%s\' in dictionary", prev);
      }
#line 94
      return (-1);
    }
    {
#line 96
    *ptr = (char )',';
#line 97
    prev = ptr + 1;
#line 98
    unique_add_attr(inst, a);
    }
#line 99
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 101
    a = dict_attrbyname((char const   *)prev);
    }
#line 101
    if ((unsigned long )a == (unsigned long )((void *)0)) {
      {
#line 102
      radlog(4, "rlm_acct_unique: Cannot find attribute \'%s\' in dictionary", prev);
      }
#line 103
      return (-1);
    }
    {
#line 105
    unique_add_attr(inst, a);
    }
#line 106
    return (0);
#line 107
    goto switch_break;
    case_32: /* CIL Label */ 
#line 109
    goto while_continue___0;
#line 110
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 112
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 115
  return (0);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
static int unique_detach(void *instance ) 
{ 
  rlm_acct_unique_t *inst ;
  rlm_acct_unique_list_t *this ;
  rlm_acct_unique_list_t *next ;

  {
#line 123
  inst = (rlm_acct_unique_t *)instance;
#line 126
  this = inst->head;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 126
      goto while_break;
    }
    {
#line 127
    next = this->next;
#line 128
    free((void *)this);
#line 126
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  free((void *)inst);
  }
#line 132
  return (0);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
static int unique_instantiate(CONF_SECTION *conf , void **instance ) 
{ 
  rlm_acct_unique_t *inst ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 142
  tmp = rad_malloc(sizeof(*inst));
#line 142
  inst = (rlm_acct_unique_t *)tmp;
#line 143
  memset((void *)inst, 0, sizeof(*inst));
#line 145
  tmp___0 = cf_section_parse(conf, (void *)inst, module_config___5);
  }
#line 145
  if (tmp___0 < 0) {
    {
#line 146
    free((void *)inst);
    }
#line 147
    return (-1);
  }
#line 153
  if (! inst->key) {
    {
#line 154
    radlog(4, "rlm_acct_unique: Cannot find value for \'key\' in configuration.");
#line 155
    free((void *)inst);
    }
#line 156
    return (-1);
  }
  {
#line 162
  tmp___1 = unique_parse_key(inst, inst->key);
  }
#line 162
  if (tmp___1 < 0) {
    {
#line 163
    unique_detach((void *)inst);
    }
#line 164
    return (-1);
  }
#line 167
  *instance = (void *)inst;
#line 169
  return (0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
static int add_unique_id(void *instance , REQUEST *request ) 
{ 
  char buffer[4096] ;
  u_char md5_buf[16] ;
  VALUE_PAIR *vp ;
  char *p ;
  int length ;
  int left ;
  rlm_acct_unique_t *inst ;
  rlm_acct_unique_list_t *cur ;
  VALUE_PAIR hack ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 184
  inst = (rlm_acct_unique_t *)instance;
#line 188
  p = buffer;
#line 189
  left = 4096;
#line 190
  cur = inst->head;
#line 195
  vp = pairfind((request->packet)->vps, 1051);
  }
#line 196
  if (vp) {
#line 197
    return (7);
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! cur) {
#line 201
      goto while_break;
    }
    {
#line 204
    vp = pairfind((request->packet)->vps, (int )(cur->dattr)->attr);
    }
#line 205
    if (! vp) {
#line 210
      if ((cur->dattr)->attr == 1052U) {
#line 210
        if ((request->packet)->src_ipaddr.af == 2) {
          {
#line 212
          memset((void *)(& hack), 0, sizeof(hack));
#line 213
          hack.name = (char const   *)((cur->dattr)->name);
#line 214
          hack.attribute = (int )(cur->dattr)->attr;
#line 215
          hack.type = (cur->dattr)->type;
#line 216
          hack.operator = (FR_TOKEN )11;
#line 217
          hack.length = (size_t )4;
#line 218
          hack.lvalue = (request->packet)->src_ipaddr.ipaddr.ip4addr.s_addr;
#line 219
          vp = & hack;
          }
        } else {
#line 210
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 221
      if (request) {
#line 221
        if (request->radlog) {
          {
#line 221
          (*(request->radlog))(1, 2, request, "WARNING: Attribute %s was not found in request, unique ID MAY be inconsistent",
                               (cur->dattr)->name);
          }
        }
      }
    }
    {
#line 224
    length = vp_prints(p, (size_t )left, vp);
#line 225
    left -= length + 1;
#line 226
    p += length;
#line 227
    tmp = p;
#line 227
    p ++;
#line 227
    *tmp = (char )',';
#line 228
    cur = cur->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  buffer[(4096 - left) - 1] = (char )'\000';
#line 232
  if (request) {
#line 232
    if (request->radlog) {
      {
#line 232
      (*(request->radlog))(1, 2, request, "Hashing \'%s\'", buffer);
      }
    }
  }
  {
#line 234
  fr_md5_calc(md5_buf, (uint8_t const   *)((u_char *)(buffer)), (unsigned int )(p - buffer));
#line 235
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%02x%02x%02x%02x%02x%02x%02x%02x",
          (int )md5_buf[0], (int )md5_buf[1], (int )md5_buf[2], (int )md5_buf[3],
          (int )md5_buf[4], (int )md5_buf[5], (int )md5_buf[6], (int )md5_buf[7]);
  }
#line 239
  if (request) {
#line 239
    if (request->radlog) {
      {
#line 239
      (*(request->radlog))(1, 2, request, "Acct-Unique-Session-ID = \"%s\".", buffer);
      }
    }
  }
  {
#line 241
  vp = pairmake("Acct-Unique-Session-Id", (char const   *)(buffer), 0);
  }
#line 242
  if (! vp) {
    {
#line 243
    tmp___0 = fr_strerror();
#line 243
    radlog(4, "%s", tmp___0);
    }
#line 244
    return (1);
  }
  {
#line 248
  pairadd(& (request->packet)->vps, vp);
  }
#line 250
  return (2);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_acct_unique/rlm_acct_unique.c"
module_t rlm_acct_unique  =    {4109257426U, "Acct-Unique-Session-Id", 1 << 1, & unique_instantiate, & unique_detach,
    {(packetmethod )((void *)0), & add_unique_id, & add_unique_id, & add_unique_id,
     (packetmethod )((void *)0), (packetmethod )((void *)0), (packetmethod )((void *)0),
     (packetmethod )((void *)0)}};
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___284[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___245[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___264[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___245[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___245[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___255[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___245[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___8[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___8[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___8(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___8[key & 255U] << 24) | ((int const   )reversed_byte___8[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___8[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___8[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___8(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___8[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___8[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___8[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___8[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___8(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___8(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___8(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___8(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___8(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___8(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___8(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___8(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___8(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___8(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___8(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___8(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___285[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___265[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___286[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___246[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___266[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___246[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___246[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___256[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___246[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___28[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___8[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___287[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___247[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___267[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___247[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___247[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___257[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___247[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/getaddrinfo.c"
static char const   rcsid___288[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___248[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___268[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___248[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___248[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___258[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___248[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmac.c"
static char const   rcsid___289[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___249[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___269[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___249[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___249[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___259[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___249[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___29[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static char const   rcsid___290[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___250[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___270[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___250[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___250[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___260[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___250[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md5.h"
static char const   rcsid_md5_h___30[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static fr_randctx fr_rand_pool___9  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int fr_rand_initialized___9  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static unsigned int salt_offset___9  =    0U;
#line 209 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_sendto___9(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , int src_port , fr_ipaddr_t *dst_ipaddr ,
                          int dst_port ) 
{ 
  int rcode ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  src_port = src_port;
#line 226
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 226
  if (! tmp) {
#line 227
    return (-1);
  }
  {
#line 244
  src_ipaddr = src_ipaddr;
#line 250
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
#line 250
  rcode = (int )tmp___0;
  }
#line 253
  if (rcode < 0) {
#line 254
    if (fr_debug_flag) {
#line 254
      if (fr_log_fp) {
        {
#line 254
        tmp___1 = __errno_location();
#line 254
        tmp___2 = strerror(*tmp___1);
#line 254
        fr_printf_log("rad_send() failed: %s\n", tmp___2);
        }
      }
    }
  }
#line 257
  return (rcode);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static ssize_t rad_recvfrom___9(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  sizeof_src = (socklen_t )sizeof(src);
#line 351
  sizeof_dst = (socklen_t )sizeof(dst);
#line 358
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 359
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 368
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 368
  if (tmp < 0) {
#line 369
    return ((ssize_t )-1);
  }
  {
#line 376
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 378
  if (data_len < 0L) {
    {
#line 379
    tmp___0 = __errno_location();
    }
#line 379
    if (*tmp___0 == 11) {
#line 379
      return ((ssize_t )0);
    } else {
      {
#line 379
      tmp___1 = __errno_location();
      }
#line 379
      if (*tmp___1 == 4) {
#line 379
        return ((ssize_t )0);
      }
    }
#line 380
    return ((ssize_t )-1);
  }
#line 386
  if (data_len < 4L) {
    {
#line 387
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 389
    return ((ssize_t )0);
  } else {
#line 395
    len = (size_t )((int )header[2] * 256 + (int )header[3]);
#line 401
    if (len < 20UL) {
      {
#line 402
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 404
      return ((ssize_t )0);
    } else
#line 410
    if (len > 4096UL) {
      {
#line 411
      recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
               (socklen_t */* __restrict  */)(& sizeof_src));
      }
#line 413
      return ((ssize_t )len);
    }
  }
  {
#line 417
  buf = malloc(len);
  }
#line 418
  if (! buf) {
#line 418
    return ((ssize_t )-1);
  }
  {
#line 434
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 436
  if (data_len < 0L) {
    {
#line 437
    free(buf);
    }
#line 438
    return (data_len);
  }
  {
#line 441
  tmp___2 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 441
  if (! tmp___2) {
    {
#line 442
    free(buf);
    }
#line 443
    return ((ssize_t )-1);
  }
  {
#line 445
  *src_port = (uint16_t )port;
#line 447
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 448
  *dst_port = (uint16_t )port;
  }
#line 453
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 454
    free(buf);
    }
#line 455
    return ((ssize_t )-1);
  }
#line 461
  *pbuf = (uint8_t *)buf;
#line 463
  return (data_len);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_secret___9(uint8_t *digest , uint8_t const   *vector , char const   *secret ,
                            uint8_t const   *value ) 
{ 
  FR_MD5_CTX context ;
  int i ;
  size_t tmp ;

  {
  {
#line 485
  fr_MD5Init(& context);
#line 486
  fr_MD5Update(& context, vector, (size_t )16);
#line 487
  tmp = strlen(secret);
#line 487
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 488
  fr_MD5Final((uint8_t *)digest, & context);
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 16)) {
#line 490
      goto while_break;
    }
#line 491
    *(digest + i) = (uint8_t )((int )*(digest + i) ^ (int )*(value + i));
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_passwd___9(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                            size_t inlen , char const   *secret , uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[128] ;
  int i ;
  int n ;
  int len ;
  size_t tmp ;

  {
#line 509
  len = (int )inlen;
#line 511
  if (len > 128) {
#line 511
    len = 128;
  }
  {
#line 513
  memcpy((void */* __restrict  */)(passwd), (void const   */* __restrict  */)input,
         (size_t )len);
#line 514
  memset((void *)(passwd + len), 0, sizeof(passwd) - (unsigned long )len);
  }
#line 516
  if (len == 0) {
#line 517
    len = 16;
  } else
#line 520
  if ((len & 15) != 0) {
#line 521
    len += 15;
#line 522
    len &= -16;
  }
  {
#line 524
  *outlen = (size_t )len;
#line 526
  fr_MD5Init(& context);
#line 527
  tmp = strlen(secret);
#line 527
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 528
  old = context;
#line 533
  fr_MD5Update(& context, vector, (size_t )16);
#line 535
  n = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (n < len)) {
#line 535
      goto while_break;
    }
#line 536
    if (n > 0) {
      {
#line 537
      context = old;
#line 538
      fr_MD5Update(& context, (uint8_t const   *)((passwd + n) - 16), (size_t )16);
      }
    }
    {
#line 543
    fr_MD5Final((uint8_t *)(digest), & context);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (i < 16)) {
#line 544
        goto while_break___0;
      }
#line 545
      passwd[i + n] = (uint8_t )((int )passwd[i + n] ^ (int )digest[i]);
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )len);
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void make_tunnel_passwd___9(uint8_t *output , size_t *outlen , uint8_t const   *input ,
                                   size_t inlen , size_t room , char const   *secret ,
                                   uint8_t const   *vector ) 
{ 
  FR_MD5_CTX context ;
  FR_MD5_CTX old ;
  uint8_t digest[16] ;
  uint8_t passwd[270] ;
  int i ;
  int n ;
  int len ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 565
  if (room > 253UL) {
#line 565
    room = (size_t )253;
  }
#line 583
  room -= 2UL;
#line 584
  room -= room & 15UL;
#line 585
  room --;
#line 587
  if (inlen > room) {
#line 587
    inlen = room;
  }
#line 593
  len = (int )(inlen + 1UL);
#line 594
  if ((len & 15) != 0) {
#line 595
    len += 15;
#line 596
    len &= -16;
  }
  {
#line 598
  *outlen = (size_t )(len + 2);
#line 603
  memcpy((void */* __restrict  */)(passwd + 3), (void const   */* __restrict  */)input,
         inlen);
#line 604
  memset((void *)((passwd + 3) + inlen), 0, (sizeof(passwd) - 3UL) - inlen);
#line 615
  tmp = salt_offset___9;
#line 615
  salt_offset___9 ++;
#line 615
  tmp___0 = fr_rand();
#line 615
  passwd[0] = (uint8_t )((128U | ((tmp & 15U) << 3)) | (tmp___0 & 7U));
#line 617
  tmp___1 = fr_rand();
#line 617
  passwd[1] = (uint8_t )tmp___1;
#line 618
  passwd[2] = (uint8_t )inlen;
#line 620
  fr_MD5Init(& context);
#line 621
  tmp___2 = strlen(secret);
#line 621
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp___2);
#line 622
  old = context;
#line 624
  fr_MD5Update(& context, vector, (size_t )16);
#line 625
  fr_MD5Update(& context, (uint8_t const   *)(& passwd[0]), (size_t )2);
#line 627
  n = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (n < len)) {
#line 627
      goto while_break;
    }
#line 628
    if (n > 0) {
      {
#line 629
      context = old;
#line 630
      fr_MD5Update(& context, (uint8_t const   *)(((passwd + 2) + n) - 16), (size_t )16);
      }
    }
    {
#line 635
    fr_MD5Final((uint8_t *)(digest), & context);
#line 636
    i = 0;
    }
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! (i < 16)) {
#line 636
        goto while_break___0;
      }
#line 637
      passwd[(i + 2) + n] = (uint8_t )((int )passwd[(i + 2) + n] ^ (int )digest[i]);
#line 636
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    n += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)(passwd),
         (size_t )(len + 2));
  }
#line 641
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *vp2data___9(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                            char const   *secret , VALUE_PAIR const   *vp , uint8_t *ptr ,
                            size_t room ) 
{ 
  uint32_t lvalue ;
  size_t len ;
  uint8_t const   *data ;
  uint8_t array[4] ;
  int32_t slvalue ;
  uint32_t tmp ;

  {
#line 659
  data = (uint8_t const   *)(vp->data.octets);
#line 660
  len = (size_t )vp->length;
  {
#line 668
  if (vp->type == 4) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 8) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 7) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 6) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 5) {
#line 668
    goto case_4;
  }
#line 668
  if (vp->type == 0) {
#line 668
    goto case_4;
  }
#line 672
  if (vp->type == 9) {
#line 672
    goto case_9;
  }
#line 678
  if (vp->type == 10) {
#line 678
    goto case_10;
  }
#line 685
  if (vp->type == 1) {
#line 685
    goto case_1;
  }
#line 692
  if (vp->type == 2) {
#line 692
    goto case_2;
  }
#line 700
  if (vp->type == 3) {
#line 700
    goto case_3;
  }
#line 706
  if (vp->type == 12) {
#line 706
    goto case_12;
  }
#line 716
  if (vp->type == 14) {
#line 716
    goto case_14;
  }
#line 724
  goto switch_default;
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 670
  goto switch_break;
  case_9: /* CIL Label */ 
#line 673
  len = (size_t )1;
#line 674
  array[0] = (uint8_t )(vp->lvalue & 255U);
#line 675
  data = (uint8_t const   *)(array);
#line 676
  goto switch_break;
  case_10: /* CIL Label */ 
#line 679
  len = (size_t )2;
#line 680
  array[0] = (uint8_t )((vp->lvalue >> 8) & 255U);
#line 681
  array[1] = (uint8_t )(vp->lvalue & 255U);
#line 682
  data = (uint8_t const   *)(array);
#line 683
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 686
  len = (size_t )4;
#line 687
  lvalue = htonl((uint32_t )vp->lvalue);
#line 688
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& lvalue),
         sizeof(lvalue));
#line 689
  data = (uint8_t const   *)(array);
  }
#line 690
  goto switch_break;
  case_2: /* CIL Label */ 
#line 693
  data = (uint8_t const   *)(& vp->lvalue);
#line 694
  len = (size_t )4;
#line 695
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 701
  lvalue = htonl((uint32_t )vp->lvalue);
#line 702
  data = (uint8_t const   *)(& lvalue);
#line 703
  len = (size_t )4;
  }
#line 704
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 710
  len = (size_t )4;
#line 711
  tmp = htonl((uint32_t )vp->data.sinteger);
#line 711
  slvalue = (int32_t )tmp;
#line 712
  memcpy((void */* __restrict  */)(array), (void const   */* __restrict  */)(& slvalue),
         sizeof(slvalue));
  }
#line 713
  goto switch_break;
  case_14: /* CIL Label */ 
#line 717
  data = (uint8_t const   *)vp->data.tlv;
#line 718
  if (! data) {
    {
#line 719
    fr_strerror_printf("ERROR: Cannot encode NULL TLV");
    }
#line 720
    return ((uint8_t *)((void *)0));
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 725
  fr_strerror_printf("ERROR: Unknown attribute type %d", vp->type);
  }
#line 726
  return ((uint8_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 732
  if (len > room) {
#line 732
    len = room;
  }
  {
#line 741
  if ((int const   )vp->flags.encrypt == 1) {
#line 741
    goto case_1___0;
  }
#line 746
  if ((int const   )vp->flags.encrypt == 2) {
#line 746
    goto case_2___0;
  }
#line 781
  if ((int const   )vp->flags.encrypt == 3) {
#line 781
    goto case_3___0;
  }
#line 787
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 742
  make_passwd___9(ptr, & len, data, len, secret, (uint8_t const   *)(packet->vector));
  }
#line 744
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 754
  if (room < 18UL) {
#line 754
    return (ptr);
  }
  {
#line 770
  if (packet->code == 43U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 40U) {
#line 770
    goto case_43;
  }
#line 770
  if (packet->code == 4U) {
#line 770
    goto case_43;
  }
#line 760
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 761
  if (! original) {
    {
#line 762
    fr_strerror_printf("ERROR: No request packet, cannot encrypt %s attribute in the vp.",
                       vp->name);
    }
#line 763
    return ((uint8_t *)((void *)0));
  }
  {
#line 765
  make_tunnel_passwd___9(ptr, & len, data, len, room, secret, (uint8_t const   *)(original->vector));
  }
#line 767
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 771
  make_tunnel_passwd___9(ptr, & len, data, len, room, secret, (uint8_t const   *)(packet->vector));
  }
#line 773
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 775
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 782
  make_secret___9(ptr, (uint8_t const   *)(packet->vector), secret, data);
#line 783
  len = (size_t )16;
  }
#line 784
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 791
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, len);
  }
#line 792
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 795
  return (ptr + len);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_vp2tlv___9(VALUE_PAIR *vps ) 
{ 
  int maxattr ;
  int length ;
  unsigned int attribute ;
  uint8_t *ptr ;
  uint8_t *end ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *tlv ;
  void *tmp ;

  {
  {
#line 801
  maxattr = 0;
#line 807
  attribute = (unsigned int )vps->attribute & 4294902015U;
#line 808
  maxattr = vps->attribute & 255;
#line 810
  tlv = paircreate((int )attribute, 14);
  }
#line 811
  if (! tlv) {
#line 811
    return ((VALUE_PAIR *)((void *)0));
  }
#line 813
  tlv->length = (size_t )0;
#line 814
  vp = vps;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 814
      goto while_break;
    }
#line 819
    if (! vp->flags.is_tlv) {
#line 824
      goto while_break;
    } else
#line 819
    if (vp->flags.encoded) {
#line 824
      goto while_break;
    } else
#line 819
    if ((int )vp->flags.encrypt != 0) {
#line 824
      goto while_break;
    } else
#line 819
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 824
      goto while_break;
    } else
#line 819
    if ((vp->attribute & 65280) <= maxattr) {
#line 824
      goto while_break;
    }
#line 827
    maxattr = vp->attribute & 65280;
#line 828
    tlv->length += vp->length + 2UL;
#line 814
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (! tlv->length) {
    {
#line 832
    pairfree(& tlv);
    }
#line 833
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 836
  tmp = malloc(tlv->length);
#line 836
  tlv->data.tlv = (uint8_t *)tmp;
  }
#line 837
  if (! tlv->data.tlv) {
    {
#line 838
    pairfree(& tlv);
    }
#line 839
    return ((VALUE_PAIR *)((void *)0));
  }
#line 842
  ptr = tlv->data.tlv;
#line 843
  maxattr = vps->attribute & 255;
#line 844
  vp = vps;
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 844
      goto while_break___0;
    }
#line 845
    if (! vp->flags.is_tlv) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (vp->flags.encoded) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((int )vp->flags.encrypt != 0) {
#line 850
      goto while_break___0;
    } else
#line 845
    if (((unsigned int )vp->attribute & 4294902015U) != attribute) {
#line 850
      goto while_break___0;
    } else
#line 845
    if ((vp->attribute & 65280) <= maxattr) {
#line 850
      goto while_break___0;
    }
    {
#line 853
    maxattr = vp->attribute & 65280;
#line 854
    end = vp2data___9((RADIUS_PACKET const   *)((void *)0), (RADIUS_PACKET const   *)((void *)0),
                      (char const   *)((void *)0), (VALUE_PAIR const   *)vp, ptr + 2,
                      (size_t )((tlv->data.tlv + tlv->length) - ptr));
    }
#line 856
    if (! end) {
#line 857
      vp->length = (size_t )(ptr - vp->data.tlv);
#line 858
      return (tlv);
    }
#line 861
    length = (int )(end - ptr);
#line 862
    if (length > 255) {
#line 862
      return ((VALUE_PAIR *)((void *)0));
    }
#line 867
    *(ptr + 0) = (uint8_t )((vp->attribute & 65280) >> 8);
#line 868
    *(ptr + 1) = (uint8_t )length;
#line 870
    ptr += (int )*(ptr + 1);
#line 871
    vp->flags.encoded = 1U;
#line 844
    vp = vp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 874
  return (tlv);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int rad_vp2continuation___9(VALUE_PAIR const   *vp , uint8_t *start , uint8_t *ptr ) 
{ 
  size_t left ;
  size_t piece ;
  size_t hsize ;
  uint8_t *this ;
  uint8_t const   *data ;
  uint8_t header[16] ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 886
  hsize = (size_t )(ptr - start);
#line 887
  this = start;
#line 894
  if ((int const   )vp->flags.encrypt != 0) {
#line 895
    return (0);
  }
  {
#line 898
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)start,
         hsize);
#line 900
  left = (size_t )vp->length;
  }
  {
#line 903
  if (vp->type == 14) {
#line 903
    goto case_14;
  }
#line 908
  if (vp->type == 0) {
#line 908
    goto case_0;
  }
#line 908
  if (vp->type == 5) {
#line 908
    goto case_0;
  }
#line 915
  goto switch_default;
  case_14: /* CIL Label */ 
#line 904
  data = (uint8_t const   *)vp->data.tlv;
#line 905
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 909
  data = (uint8_t const   *)(vp->data.octets);
#line 910
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 916
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (left > 0UL)) {
#line 919
      goto while_break;
    }
    {
#line 920
    memcpy((void */* __restrict  */)this, (void const   */* __restrict  */)(header),
           hsize);
#line 921
    ptr = this + hsize;
    }
#line 927
    if (left > 254UL - hsize) {
#line 928
      piece = 254UL - hsize;
#line 929
      tmp = ptr;
#line 929
      ptr ++;
#line 929
      *tmp = (uint8_t )128;
    } else {
#line 931
      piece = left;
#line 932
      tmp___0 = ptr;
#line 932
      ptr ++;
#line 932
      *tmp___0 = (uint8_t )0;
    }
    {
#line 935
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data, piece);
#line 936
    *(this + 1) = (uint8_t )((hsize + piece) + 1UL);
#line 941
    *(this + (hsize - 1UL)) = (uint8_t )(((hsize - 6UL) + 1UL) + piece);
#line 942
    data += piece;
#line 943
    ptr += piece;
#line 944
    left -= piece;
#line 945
    this = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  return ((int )(ptr - start));
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_acctdigest___9(RADIUS_PACKET *packet , char const   *secret ) 
{ 
  uint8_t digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1561
  memset((void *)(packet->data + 4), 0, (size_t )16);
#line 1566
  fr_MD5Init(& context);
#line 1567
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1568
  tmp = strlen(secret);
#line 1568
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1569
  fr_MD5Final((uint8_t *)(digest), & context);
#line 1574
  tmp___0 = rad_digest_cmp((uint8_t const   *)(digest), (uint8_t const   *)(packet->vector),
                           (size_t )16);
  }
#line 1574
  if (tmp___0 != 0) {
#line 1574
    return (2);
  }
#line 1575
  return (0);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static int calc_replydigest___9(RADIUS_PACKET *packet , RADIUS_PACKET *original ,
                                char const   *secret ) 
{ 
  uint8_t calc_digest[16] ;
  FR_MD5_CTX context ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1592
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 1593
    return (3);
  }
  {
#line 1599
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(original->vector),
         (size_t )16);
#line 1604
  fr_MD5Init(& context);
#line 1605
  fr_MD5Update(& context, (uint8_t const   *)packet->data, (size_t )packet->data_len);
#line 1606
  tmp = strlen(secret);
#line 1606
  fr_MD5Update(& context, (uint8_t const   *)secret, tmp);
#line 1607
  fr_MD5Final((uint8_t *)(calc_digest), & context);
#line 1612
  memcpy((void */* __restrict  */)(packet->data + 4), (void const   */* __restrict  */)(packet->vector),
         (size_t )16);
#line 1617
  tmp___0 = rad_digest_cmp((uint8_t const   *)(packet->vector), (uint8_t const   *)(calc_digest),
                           (size_t )16);
  }
#line 1617
  if (tmp___0 != 0) {
#line 1617
    return (2);
  }
#line 1618
  return (0);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *data2vp___9(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                               char const   *secret , unsigned int attribute , size_t length ,
                               uint8_t const   *data , VALUE_PAIR *vp ) 
{ 
  int offset ;
  int tmp ;
  uint8_t my_digest[16] ;
  DICT_VALUE *dval ;
  void *tmp___0 ;
  VALUE_PAIR *vp2 ;
  VALUE_PAIR *tmp___1 ;

  {
#line 2225
  offset = 0;
#line 2231
  if (length > 253UL) {
#line 2231
    length = (size_t )253;
  }
#line 2233
  vp->length = length;
#line 2234
  vp->operator = (FR_TOKEN )11;
#line 2235
  vp->next = (struct value_pair *)((void *)0);
#line 2240
  if (vp->flags.has_tag) {
#line 2241
    if ((int const   )*(data + 0) > 0) {
#line 2241
      if ((int const   )*(data + 0) < 32) {
#line 2241
        goto _L;
      } else {
#line 2241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2241
    if ((int )vp->flags.encrypt == 2) {
      _L: /* CIL Label */ 
#line 2247
      vp->flags.tag = (int8_t )*(data + 0);
#line 2249
      if (vp->type == 0) {
#line 2250
        offset = 1;
      } else
#line 2249
      if (vp->type == 5) {
#line 2250
        offset = 1;
      }
    }
  }
  {
#line 2257
  memcpy((void */* __restrict  */)(& vp->data.octets[0]), (void const   */* __restrict  */)(data + offset),
         length - (size_t )offset);
#line 2258
  vp->length -= (size_t )offset;
  }
#line 2263
  if (secret) {
    {
#line 2267
    if ((int )vp->flags.encrypt == 1) {
#line 2267
      goto case_1;
    }
#line 2286
    if ((int )vp->flags.encrypt == 2) {
#line 2286
      goto case_2;
    }
#line 2299
    if ((int )vp->flags.encrypt == 3) {
#line 2299
      goto case_3;
    }
#line 2314
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2268
    if (original) {
      {
#line 2269
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(original->vector));
      }
    } else {
      {
#line 2273
      rad_pwdecode(vp->data.strvalue, vp->length, secret, (uint8_t const   *)(packet->vector));
      }
    }
#line 2277
    if (vp->attribute == 2) {
      {
#line 2278
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2280
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2287
    if (! original) {
#line 2287
      goto raw;
    }
    {
#line 2289
    tmp = rad_tunnel_pwdecode(vp->data.octets, & vp->length, secret, (uint8_t const   *)(original->vector));
    }
#line 2289
    if (tmp < 0) {
#line 2291
      goto raw;
    }
#line 2293
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2300
    if (! original) {
#line 2301
      goto raw;
    } else {
      {
#line 2304
      make_secret___9(my_digest, (uint8_t const   *)(original->vector), secret, data);
#line 2307
      memcpy((void */* __restrict  */)(vp->data.strvalue), (void const   */* __restrict  */)(my_digest),
             (size_t )16);
#line 2309
      vp->data.strvalue[16] = (char )'\000';
#line 2310
      vp->length = strlen((char const   *)(vp->data.strvalue));
      }
    }
#line 2312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2322
  if (vp->type == 4) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 5) {
#line 2322
    goto case_4;
  }
#line 2322
  if (vp->type == 0) {
#line 2322
    goto case_4;
  }
#line 2326
  if (vp->type == 9) {
#line 2326
    goto case_9;
  }
#line 2333
  if (vp->type == 10) {
#line 2333
    goto case_10;
  }
#line 2339
  if (vp->type == 1) {
#line 2339
    goto case_1___0;
  }
#line 2362
  if (vp->type == 3) {
#line 2362
    goto case_3___0;
  }
#line 2370
  if (vp->type == 2) {
#line 2370
    goto case_2___0;
  }
#line 2379
  if (vp->type == 6) {
#line 2379
    goto case_6;
  }
#line 2387
  if (vp->type == 7) {
#line 2387
    goto case_7;
  }
#line 2401
  if (vp->type == 8) {
#line 2401
    goto case_8;
  }
#line 2415
  if (vp->type == 12) {
#line 2415
    goto case_12;
  }
#line 2427
  if (vp->type == 14) {
#line 2427
    goto case_14;
  }
#line 2438
  if (vp->type == 13) {
#line 2438
    goto case_13;
  }
#line 2452
  goto raw;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2324
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 2327
  if (vp->length != 1UL) {
#line 2327
    goto raw;
  }
#line 2329
  vp->lvalue = (uint32_t )vp->data.octets[0];
#line 2330
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 2334
  if (vp->length != 2UL) {
#line 2334
    goto raw;
  }
#line 2336
  vp->lvalue = (uint32_t )(((int )vp->data.octets[0] << 8) | (int )vp->data.octets[1]);
#line 2337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 2340
  if (vp->length != 4UL) {
#line 2340
    goto raw;
  }
  {
#line 2342
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2343
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2345
  if (vp->flags.has_tag) {
#line 2345
    vp->lvalue &= 16777215U;
  }
  {
#line 2352
  dval = dict_valbyattr((unsigned int )vp->attribute, (int )vp->lvalue);
  }
#line 2354
  if (dval) {
    {
#line 2355
    strlcpy(vp->data.strvalue, (char const   *)(dval->name), sizeof(vp->data.strvalue));
    }
  }
#line 2360
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 2363
  if (vp->length != 4UL) {
#line 2363
    goto raw;
  }
  {
#line 2365
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2366
  vp->lvalue = ntohl(vp->lvalue);
  }
#line 2367
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2371
  if (vp->length != 4UL) {
#line 2371
    goto raw;
  }
  {
#line 2373
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
  }
#line 2374
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 2380
  if (vp->length != 8UL) {
#line 2380
    goto raw;
  }
#line 2382
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2388
  if (vp->length != 16UL) {
#line 2388
    goto raw;
  }
#line 2390
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 2402
  if (vp->length < 2UL) {
#line 2402
    goto raw;
  } else
#line 2402
  if (vp->length > 18UL) {
#line 2402
    goto raw;
  }
#line 2403
  if ((int )vp->data.octets[1] > 128) {
#line 2403
    goto raw;
  }
#line 2409
  if (vp->length < 18UL) {
    {
#line 2410
    memset((void *)(vp->data.octets + vp->length), 0, 18UL - vp->length);
    }
  }
#line 2413
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 2416
  if (vp->length != 4UL) {
#line 2416
    goto raw;
  }
  {
#line 2422
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         (size_t )4);
#line 2423
  vp->lvalue = ntohl(vp->lvalue);
#line 2424
  memcpy((void */* __restrict  */)(& vp->data.sinteger), (void const   */* __restrict  */)(& vp->lvalue),
         (size_t )4);
  }
#line 2425
  goto switch_break___0;
  case_14: /* CIL Label */ 
  {
#line 2428
  vp->length = length;
#line 2429
  tmp___0 = malloc(length);
#line 2429
  vp->data.tlv = (uint8_t *)tmp___0;
  }
#line 2430
  if (! vp->data.tlv) {
    {
#line 2431
    pairfree(& vp);
#line 2432
    fr_strerror_printf("No memory");
    }
#line 2433
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2435
  memcpy((void */* __restrict  */)vp->data.tlv, (void const   */* __restrict  */)data,
         length);
  }
#line 2436
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 2439
  if (vp->length == 4UL) {
    {
#line 2440
    vp->type = 2;
#line 2441
    memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
           (size_t )4);
    }
#line 2442
    goto switch_break___0;
  } else
#line 2444
  if (vp->length == 16UL) {
#line 2445
    vp->type = 7;
#line 2447
    goto switch_break___0;
  }
  raw: 
  switch_default___0: /* CIL Label */ 
  {
#line 2461
  vp2 = pairalloc((DICT_ATTR *)((void *)0));
  }
#line 2462
  if (! vp2) {
    {
#line 2463
    pairfree(& vp);
    }
#line 2464
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2466
  pairfree(& vp);
#line 2467
  vp = vp2;
#line 2473
  tmp___1 = paircreate_raw((int )attribute, 5, vp);
  }
#line 2473
  if (! tmp___1) {
#line 2474
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 2477
  vp->length = length;
#line 2478
  memcpy((void */* __restrict  */)(vp->data.octets), (void const   */* __restrict  */)data,
         length);
  }
#line 2480
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2483
  return (vp);
}
}
#line 2486 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static void rad_sortvp___9(VALUE_PAIR **head ) 
{ 
  int swapped ;
  VALUE_PAIR *vp ;
  VALUE_PAIR **tail ;

  {
  {
#line 2497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2498
    swapped = 0;
#line 2499
    tail = head;
    {
#line 2500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2500
      if (! *tail) {
#line 2500
        goto while_break___0;
      }
#line 2501
      vp = *tail;
#line 2502
      if (! vp->next) {
#line 2502
        goto while_break___0;
      }
#line 2504
      if (vp->attribute > (vp->next)->attribute) {
#line 2505
        *tail = vp->next;
#line 2506
        vp->next = (*tail)->next;
#line 2507
        (*tail)->next = vp;
#line 2508
        swapped = 1;
      }
#line 2510
      tail = & vp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    if (! swapped) {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static uint8_t *rad_coalesce___9(unsigned int attribute , size_t length , uint8_t *data ,
                                 size_t packet_length , size_t *ptlv_length ) 
{ 
  uint32_t lvalue ;
  size_t tlv_length ;
  uint8_t *ptr ;
  uint8_t *tlv ;
  uint8_t *tlv_data ;
  void *tmp ;
  int this_length ;

  {
#line 2533
  tlv_length = length;
#line 2536
  ptr = data + length;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2536
      goto while_break;
    }
#line 2539
    if ((int )*(ptr + 0) != 26) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 1) < 9) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 2) != 0) {
#line 2542
      goto __Cont;
    } else
#line 2539
    if ((int )*(ptr + 3) != 0) {
#line 2542
      goto __Cont;
    }
    {
#line 2545
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2546
    lvalue = ntohl(lvalue);
#line 2547
    lvalue <<= 16;
#line 2548
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2549
    if (lvalue != attribute) {
#line 2549
      goto __Cont;
    }
#line 2555
    if ((int )*(ptr + 7) < 3) {
#line 2555
      goto while_break;
    }
#line 2557
    tlv_length += (size_t )((int )*(ptr + 7) - 3);
#line 2558
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2558
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2536
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp = malloc(tlv_length);
#line 2561
  tlv_data = (uint8_t *)tmp;
#line 2561
  tlv = tlv_data;
  }
#line 2562
  if (! tlv_data) {
#line 2562
    return ((uint8_t *)((void *)0));
  }
  {
#line 2564
  memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)data, length);
#line 2565
  tlv += length;
#line 2571
  ptr = data + length;
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! ((unsigned long )ptr != (unsigned long )(data + packet_length))) {
#line 2571
      goto while_break___0;
    }
#line 2576
    if ((int )*(ptr + 0) != 26) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 1) < 9) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 2) != 0) {
#line 2579
      goto __Cont___0;
    } else
#line 2576
    if ((int )*(ptr + 3) != 0) {
#line 2579
      goto __Cont___0;
    }
    {
#line 2582
    memcpy((void */* __restrict  */)(& lvalue), (void const   */* __restrict  */)(ptr + 2),
           (size_t )4);
#line 2583
    lvalue = ntohl(lvalue);
#line 2584
    lvalue <<= 16;
#line 2585
    lvalue |= (unsigned int )*(ptr + 6);
    }
#line 2586
    if (lvalue != attribute) {
#line 2586
      goto __Cont___0;
    }
#line 2592
    if ((int )*(ptr + 7) < 3) {
#line 2592
      goto while_break___0;
    }
    {
#line 2594
    this_length = (int )*(ptr + 7) - 3;
#line 2595
    memcpy((void */* __restrict  */)tlv, (void const   */* __restrict  */)(((ptr + 2) + 4) + 3),
           (size_t )this_length);
#line 2596
    tlv += this_length;
#line 2598
    *(ptr + 6) = (uint8_t )0;
    }
#line 2599
    if (((int )*(ptr + 8) & 128) == 0) {
#line 2599
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 2571
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  *ptlv_length = tlv_length;
#line 2603
  return (tlv_data);
}
}
#line 2611 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/radius.c"
static VALUE_PAIR *rad_continuation2vp___9(RADIUS_PACKET const   *packet , RADIUS_PACKET const   *original ,
                                           char const   *secret , int attribute ,
                                           int length , uint8_t *data , size_t packet_length ,
                                           int flag , DICT_ATTR *da ) 
{ 
  size_t tlv_length ;
  size_t left ;
  uint8_t *ptr ;
  uint8_t *tlv_data ;
  VALUE_PAIR *vp ;
  VALUE_PAIR *head ;
  VALUE_PAIR **tail ;
  void *tmp ;

  {
#line 2627
  if (flag) {
    {
#line 2628
    tlv_data = rad_coalesce___9((unsigned int )attribute, (size_t )length, data, packet_length,
                                & tlv_length);
    }
#line 2630
    if (! tlv_data) {
#line 2630
      return ((VALUE_PAIR *)((void *)0));
    }
  } else {
#line 2632
    tlv_data = data;
#line 2633
    tlv_length = (size_t )length;
  }
#line 2647
  if (! da) {
#line 2647
    goto not_well_formed;
  } else
#line 2647
  if (da->type != 14) {
    not_well_formed: 
#line 2649
    if ((unsigned long )tlv_data == (unsigned long )data) {
      {
#line 2650
      tmp = malloc(tlv_length);
#line 2650
      tlv_data = (uint8_t *)tmp;
      }
#line 2651
      if (! tlv_data) {
#line 2651
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 2652
      memcpy((void */* __restrict  */)tlv_data, (void const   */* __restrict  */)data,
             tlv_length);
      }
    }
    {
#line 2655
    vp = paircreate(attribute, 5);
    }
#line 2656
    if (! vp) {
#line 2656
      return ((VALUE_PAIR *)((void *)0));
    }
#line 2658
    vp->type = 14;
#line 2659
    vp->flags.encrypt = (uint8_t )0;
#line 2660
    vp->flags.has_tag = 0U;
#line 2661
    vp->flags.is_tlv = 0U;
#line 2662
    vp->data.tlv = tlv_data;
#line 2663
    vp->length = tlv_length;
#line 2664
    return (vp);
  }
#line 2671
  left = tlv_length;
#line 2672
  ptr = tlv_data;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2672
      goto while_break;
    }
#line 2675
    if (left < 2UL) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((int )*(ptr + 1) < 2) {
#line 2678
      goto not_well_formed;
    } else
#line 2675
    if ((size_t )*(ptr + 1) > left) {
#line 2678
      goto not_well_formed;
    }
#line 2680
    left -= (size_t )*(ptr + 1);
#line 2672
    ptr += (int )*(ptr + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2686
  head = (VALUE_PAIR *)((void *)0);
#line 2687
  tail = & head;
#line 2689
  ptr = tlv_data;
  {
#line 2689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2689
    if (! ((unsigned long )ptr != (unsigned long )(tlv_data + tlv_length))) {
#line 2689
      goto while_break___0;
    }
    {
#line 2692
    vp = paircreate(attribute | ((int )*(ptr + 0) << 8), 5);
    }
#line 2693
    if (! vp) {
      {
#line 2694
      pairfree(& head);
      }
#line 2695
      goto not_well_formed;
    }
    {
#line 2698
    vp = data2vp___9(packet, original, secret, (unsigned int )*(ptr + 0), (size_t )((int )*(ptr + 1) - 2),
                     (uint8_t const   *)(ptr + 2), vp);
    }
#line 2700
    if (! vp) {
      {
#line 2701
      pairfree(& head);
      }
#line 2702
      goto not_well_formed;
    }
#line 2705
    *tail = vp;
#line 2706
    tail = & vp->next;
#line 2689
    ptr += (int )*(ptr + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )tlv_data != (unsigned long )data) {
    {
#line 2712
    free((void *)tlv_data);
    }
  }
#line 2714
  if (head->next) {
    {
#line 2714
    rad_sortvp___9(& head);
    }
  }
#line 2716
  return (head);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hmacsha1.c"
static char const   rcsid___291[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___251[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___271[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___251[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___251[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___261[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___251[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static char const   rcsid___292[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___252[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___272[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___252[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___252[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___262[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___252[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_NAME_NUMBER const   tokens___9[22]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
  {      {"=~", 17}, 
        {"!~", 18}, 
        {"{", 2}, 
        {"}", 3}, 
        {"(", 4}, 
        {")", 5}, 
        {",", 6}, 
        {"+=", 8}, 
        {"-=", 9}, 
        {":=", 10}, 
        {"=*", 19}, 
        {"!*", 20}, 
        {"==", 21}, 
        {"=", 11}, 
        {"!=", 12}, 
        {">=", 13}, 
        {">", 14}, 
        {"<=", 15}, 
        {"<", 16}, 
        {"#", 22}, 
        {";", 7}, 
        {(char const   *)((void *)0), 0}};
#line 72 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/token.c"
static FR_TOKEN getthing___9(char const   **ptr , char *buf , int buflen , int tok ,
                             FR_NAME_NUMBER const   *tokenlist ) 
{ 
  char *s ;
  char const   *p ;
  int quote ;
  int end ;
  int escape ;
  unsigned int x ;
  FR_NAME_NUMBER const   *t ;
  FR_TOKEN rcode ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 77
  end = 0;
#line 83
  *(buf + 0) = (char)0;
#line 86
  p = *ptr;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*p) {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int const   )*p == 0) {
#line 91
    *ptr = p;
#line 92
    return ((FR_TOKEN )1);
  }
#line 98
  if (tok) {
#line 98
    t = tokenlist;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! t->name) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 99
        if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 99
          goto _L;
        } else
#line 99
        if ((int const   )*(t->name + 1) == 0) {
          _L: /* CIL Label */ 
          {
#line 100
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)t->name);
#line 101
          tmp___0 = strlen((char const   *)t->name);
#line 101
          p += tmp___0;
          }
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 102
            tmp___1 = __ctype_b_loc();
            }
#line 102
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 102
              goto while_break___1;
            }
#line 103
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 104
          *ptr = p;
#line 105
          return ((FR_TOKEN )t->number);
        }
      }
#line 98
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 110
  quote = 0;
#line 111
  if ((int const   )*p == 34) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 39) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  } else
#line 111
  if ((int const   )*p == 96) {
#line 114
    quote = (int )*p;
#line 115
    end = 0;
#line 116
    p ++;
  }
#line 118
  s = buf;
#line 119
  escape = 0;
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (*p) {
#line 121
      tmp___12 = buflen;
#line 121
      buflen --;
#line 121
      if (! (tmp___12 > 1)) {
#line 121
        goto while_break___2;
      }
    } else {
#line 121
      goto while_break___2;
    }
#line 122
    if (quote) {
#line 122
      if ((int const   )*p == 92) {
#line 123
        p ++;
        {
#line 126
        if ((int const   )*p == 114) {
#line 126
          goto case_114;
        }
#line 129
        if ((int const   )*p == 110) {
#line 129
          goto case_110;
        }
#line 132
        if ((int const   )*p == 116) {
#line 132
          goto case_116;
        }
#line 135
        if ((int const   )*p == 0) {
#line 135
          goto case_0;
        }
#line 139
        goto switch_default;
        case_114: /* CIL Label */ 
#line 127
        tmp___2 = s;
#line 127
        s ++;
#line 127
        *tmp___2 = (char )'\r';
#line 128
        goto switch_break;
        case_110: /* CIL Label */ 
#line 130
        tmp___3 = s;
#line 130
        s ++;
#line 130
        *tmp___3 = (char )'\n';
#line 131
        goto switch_break;
        case_116: /* CIL Label */ 
#line 133
        tmp___4 = s;
#line 133
        s ++;
#line 133
        *tmp___4 = (char )'\t';
#line 134
        goto switch_break;
        case_0: /* CIL Label */ 
#line 136
        tmp___5 = s;
#line 136
        s ++;
#line 136
        *tmp___5 = (char )'\\';
#line 137
        p --;
#line 138
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 140
        if ((int const   )*p >= 48) {
#line 140
          if ((int const   )*p <= 57) {
            {
#line 140
            tmp___8 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%3o",
                             & x);
            }
#line 140
            if (tmp___8 == 1) {
#line 142
              tmp___6 = s;
#line 142
              s ++;
#line 142
              *tmp___6 = (char )x;
#line 143
              p += 2;
            } else {
#line 145
              tmp___7 = s;
#line 145
              s ++;
#line 145
              *tmp___7 = (char )*p;
            }
          } else {
#line 145
            tmp___7 = s;
#line 145
            s ++;
#line 145
            *tmp___7 = (char )*p;
          }
        } else {
#line 145
          tmp___7 = s;
#line 145
          s ++;
#line 145
          *tmp___7 = (char )*p;
        }
#line 146
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 148
        p ++;
#line 149
        goto while_continue___2;
      }
    }
#line 151
    if (quote) {
#line 151
      if ((int const   )*p == (int const   )quote) {
#line 152
        end = 1;
#line 153
        p ++;
#line 154
        goto while_break___2;
      }
    }
#line 156
    if (! quote) {
      {
#line 157
      tmp___9 = __ctype_b_loc();
      }
#line 157
      if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 158
        goto while_break___2;
      }
#line 159
      if (tok) {
#line 160
        t = tokenlist;
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (! t->name) {
#line 160
            goto while_break___3;
          }
#line 161
          if ((int const   )*(t->name + 0) == (int const   )*(p + 0)) {
#line 161
            if ((int const   )*(t->name + 1) == (int const   )*(p + 1)) {
#line 162
              goto while_break___3;
            } else
#line 161
            if ((int const   )*(t->name + 1) == 0) {
#line 162
              goto while_break___3;
            }
          }
#line 160
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 163
        if ((unsigned long )t->name != (unsigned long )((void *)0)) {
#line 164
          goto while_break___2;
        }
      }
    }
#line 167
    tmp___10 = s;
#line 167
    s ++;
#line 167
    tmp___11 = p;
#line 167
    p ++;
#line 167
    *tmp___10 = (char )*tmp___11;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  tmp___13 = s;
#line 169
  s ++;
#line 169
  *tmp___13 = (char)0;
#line 171
  if (quote) {
#line 171
    if (! end) {
      {
#line 172
      fr_strerror_printf("Unterminated string");
      }
#line 173
      return ((FR_TOKEN )0);
    }
  }
  {
#line 177
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 177
    if (*p) {
      {
#line 177
      tmp___14 = __ctype_b_loc();
      }
#line 177
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 177
        goto while_break___4;
      }
    } else {
#line 177
      goto while_break___4;
    }
#line 178
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 179
  *ptr = p;
  {
#line 187
  if (quote == 39) {
#line 187
    goto case_39;
  }
#line 191
  if (quote == 34) {
#line 191
    goto case_34;
  }
#line 195
  if (quote == 96) {
#line 195
    goto case_96;
  }
#line 183
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 184
  rcode = (FR_TOKEN )23;
#line 185
  goto switch_break___0;
  case_39: /* CIL Label */ 
#line 188
  rcode = (FR_TOKEN )25;
#line 189
  goto switch_break___0;
  case_34: /* CIL Label */ 
#line 192
  rcode = (FR_TOKEN )24;
#line 193
  goto switch_break___0;
  case_96: /* CIL Label */ 
#line 196
  rcode = (FR_TOKEN )26;
#line 197
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 200
  return (rcode);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static char const   rcsid___293[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___253[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___273[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___253[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___253[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___263[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___253[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static rbnode_t Sentinel___9  =    {& Sentinel___9, & Sentinel___9, (rbnode_t *)((void *)0), (NodeColor )0, (void *)0};
#line 58 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void FreeWalker___9(rbtree_t *tree , rbnode_t *X ) 
{ 


  {
#line 60
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___9)) {
    {
#line 60
    FreeWalker___9(tree, X->Left);
    }
  }
#line 61
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___9)) {
    {
#line 61
    FreeWalker___9(tree, X->Right);
    }
  }
#line 63
  if (tree->freeNode) {
    {
#line 63
    (*(tree->freeNode))(X->Data);
    }
  }
  {
#line 64
  free((void *)X);
  }
#line 65
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateLeft___9(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 116
  Y = X->Right;
#line 119
  X->Right = Y->Left;
#line 120
  if ((unsigned long )Y->Left != (unsigned long )(& Sentinel___9)) {
#line 120
    (Y->Left)->Parent = X;
  }
#line 123
  if ((unsigned long )Y != (unsigned long )(& Sentinel___9)) {
#line 123
    Y->Parent = X->Parent;
  }
#line 124
  if (X->Parent) {
#line 125
    if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
#line 126
      (X->Parent)->Left = Y;
    } else {
#line 128
      (X->Parent)->Right = Y;
    }
  } else {
#line 130
    tree->Root = Y;
  }
#line 134
  Y->Left = X;
#line 135
  if ((unsigned long )X != (unsigned long )(& Sentinel___9)) {
#line 135
    X->Parent = Y;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void RotateRight___9(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;

  {
#line 144
  Y = X->Left;
#line 147
  X->Left = Y->Right;
#line 148
  if ((unsigned long )Y->Right != (unsigned long )(& Sentinel___9)) {
#line 148
    (Y->Right)->Parent = X;
  }
#line 151
  if ((unsigned long )Y != (unsigned long )(& Sentinel___9)) {
#line 151
    Y->Parent = X->Parent;
  }
#line 152
  if (X->Parent) {
#line 153
    if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
#line 154
      (X->Parent)->Right = Y;
    } else {
#line 156
      (X->Parent)->Left = Y;
    }
  } else {
#line 158
    tree->Root = Y;
  }
#line 162
  Y->Right = X;
#line 163
  if ((unsigned long )X != (unsigned long )(& Sentinel___9)) {
#line 163
    X->Parent = Y;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void InsertFixup___9(rbtree_t *tree , rbnode_t *X ) 
{ 
  rbnode_t *Y ;
  rbnode_t *Y___0 ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 174
      if (! ((unsigned int )(X->Parent)->Color == 1U)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
#line 176
    if ((unsigned long )X->Parent == (unsigned long )((X->Parent)->Parent)->Left) {
#line 177
      Y = ((X->Parent)->Parent)->Right;
#line 178
      if ((unsigned int )Y->Color == 1U) {
#line 181
        (X->Parent)->Color = (NodeColor )0;
#line 182
        Y->Color = (NodeColor )0;
#line 183
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 184
        X = (X->Parent)->Parent;
      } else {
#line 188
        if ((unsigned long )X == (unsigned long )(X->Parent)->Right) {
          {
#line 190
          X = X->Parent;
#line 191
          RotateLeft___9(tree, X);
          }
        }
        {
#line 195
        (X->Parent)->Color = (NodeColor )0;
#line 196
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 197
        RotateRight___9(tree, (X->Parent)->Parent);
        }
      }
    } else {
#line 202
      Y___0 = ((X->Parent)->Parent)->Left;
#line 203
      if ((unsigned int )Y___0->Color == 1U) {
#line 206
        (X->Parent)->Color = (NodeColor )0;
#line 207
        Y___0->Color = (NodeColor )0;
#line 208
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 209
        X = (X->Parent)->Parent;
      } else {
#line 213
        if ((unsigned long )X == (unsigned long )(X->Parent)->Left) {
          {
#line 214
          X = X->Parent;
#line 215
          RotateRight___9(tree, X);
          }
        }
        {
#line 217
        (X->Parent)->Color = (NodeColor )0;
#line 218
        ((X->Parent)->Parent)->Color = (NodeColor )1;
#line 219
        RotateLeft___9(tree, (X->Parent)->Parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  (tree->Root)->Color = (NodeColor )0;
#line 225
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static void DeleteFixup___9(rbtree_t *tree , rbnode_t *X , rbnode_t *Parent ) 
{ 
  rbnode_t *W ;
  rbnode_t *W___0 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned long )X != (unsigned long )tree->Root) {
#line 310
      if (! ((unsigned int )X->Color == 0U)) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
#line 311
    if ((unsigned long )X == (unsigned long )Parent->Left) {
#line 312
      W = Parent->Right;
#line 313
      if ((unsigned int )W->Color == 1U) {
        {
#line 314
        W->Color = (NodeColor )0;
#line 315
        Parent->Color = (NodeColor )1;
#line 316
        RotateLeft___9(tree, Parent);
#line 317
        W = Parent->Right;
        }
      }
#line 319
      if ((unsigned int )(W->Left)->Color == 0U) {
#line 319
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 320
          if ((unsigned long )W != (unsigned long )(& Sentinel___9)) {
#line 320
            W->Color = (NodeColor )1;
          }
#line 321
          X = Parent;
#line 322
          Parent = X->Parent;
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 324
        if ((unsigned int )(W->Right)->Color == 0U) {
#line 325
          if ((unsigned long )W->Left != (unsigned long )(& Sentinel___9)) {
#line 325
            (W->Left)->Color = (NodeColor )0;
          }
          {
#line 326
          W->Color = (NodeColor )1;
#line 327
          RotateRight___9(tree, W);
#line 328
          W = Parent->Right;
          }
        }
#line 330
        W->Color = Parent->Color;
#line 331
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___9)) {
#line 331
          Parent->Color = (NodeColor )0;
        }
#line 332
        if ((unsigned int )(W->Right)->Color != 0U) {
#line 333
          (W->Right)->Color = (NodeColor )0;
        }
        {
#line 335
        RotateLeft___9(tree, Parent);
#line 336
        X = tree->Root;
        }
      }
    } else {
#line 339
      W___0 = Parent->Left;
#line 340
      if ((unsigned int )W___0->Color == 1U) {
        {
#line 341
        W___0->Color = (NodeColor )0;
#line 342
        Parent->Color = (NodeColor )1;
#line 343
        RotateRight___9(tree, Parent);
#line 344
        W___0 = Parent->Left;
        }
      }
#line 346
      if ((unsigned int )(W___0->Right)->Color == 0U) {
#line 346
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 347
          if ((unsigned long )W___0 != (unsigned long )(& Sentinel___9)) {
#line 347
            W___0->Color = (NodeColor )1;
          }
#line 348
          X = Parent;
#line 349
          Parent = X->Parent;
        } else {
#line 346
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 351
        if ((unsigned int )(W___0->Left)->Color == 0U) {
#line 352
          if ((unsigned long )W___0->Right != (unsigned long )(& Sentinel___9)) {
#line 352
            (W___0->Right)->Color = (NodeColor )0;
          }
          {
#line 353
          W___0->Color = (NodeColor )1;
#line 354
          RotateLeft___9(tree, W___0);
#line 355
          W___0 = Parent->Left;
          }
        }
#line 357
        W___0->Color = Parent->Color;
#line 358
        if ((unsigned long )Parent != (unsigned long )(& Sentinel___9)) {
#line 358
          Parent->Color = (NodeColor )0;
        }
#line 359
        if ((unsigned int )(W___0->Left)->Color != 0U) {
#line 360
          (W___0->Left)->Color = (NodeColor )0;
        }
        {
#line 362
        RotateRight___9(tree, Parent);
#line 363
        X = tree->Root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  X->Color = (NodeColor )0;
#line 368
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePreOrder___9(rbnode_t *X , int (*callback)(void * , void * ) ,
                                void *context ) 
{ 
  int rcode ;
  rbnode_t *Left ;
  rbnode_t *Right ;

  {
  {
#line 516
  Left = X->Left;
#line 517
  Right = X->Right;
#line 519
  rcode = (*callback)(context, X->Data);
  }
#line 520
  if (rcode != 0) {
#line 520
    return (rcode);
  }
#line 522
  if ((unsigned long )Left != (unsigned long )(& Sentinel___9)) {
    {
#line 523
    rcode = WalkNodePreOrder___9(Left, callback, context);
    }
#line 524
    if (rcode != 0) {
#line 524
      return (rcode);
    }
  }
#line 527
  if ((unsigned long )Right != (unsigned long )(& Sentinel___9)) {
    {
#line 528
    rcode = WalkNodePreOrder___9(Right, callback, context);
    }
#line 529
    if (rcode != 0) {
#line 529
      return (rcode);
    }
  }
#line 532
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodeInOrder___9(rbnode_t *X , int (*callback)(void * , void * ) , void *context ) 
{ 
  int rcode ;
  rbnode_t *Right ;

  {
#line 544
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___9)) {
    {
#line 545
    rcode = WalkNodeInOrder___9(X->Left, callback, context);
    }
#line 546
    if (rcode != 0) {
#line 546
      return (rcode);
    }
  }
  {
#line 549
  Right = X->Right;
#line 551
  rcode = (*callback)(context, X->Data);
  }
#line 552
  if (rcode != 0) {
#line 552
    return (rcode);
  }
#line 554
  if ((unsigned long )Right != (unsigned long )(& Sentinel___9)) {
    {
#line 555
    rcode = WalkNodeInOrder___9(Right, callback, context);
    }
#line 556
    if (rcode != 0) {
#line 556
      return (rcode);
    }
  }
#line 559
  return (0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/rbtree.c"
static int WalkNodePostOrder___9(rbnode_t *X , int (*callback)(void * , void * ) ,
                                 void *context ) 
{ 
  int rcode ;

  {
#line 571
  if ((unsigned long )X->Left != (unsigned long )(& Sentinel___9)) {
    {
#line 572
    rcode = WalkNodeInOrder___9(X->Left, callback, context);
    }
#line 573
    if (rcode != 0) {
#line 573
      return (rcode);
    }
  }
#line 576
  if ((unsigned long )X->Right != (unsigned long )(& Sentinel___9)) {
    {
#line 577
    rcode = WalkNodeInOrder___9(X->Right, callback, context);
    }
#line 578
    if (rcode != 0) {
#line 578
      return (rcode);
    }
  }
  {
#line 581
  rcode = (*callback)(context, X->Data);
  }
#line 582
  if (rcode != 0) {
#line 582
    return (rcode);
  }
#line 584
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static char const   rcsid___294[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___254[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___274[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___254[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___254[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___264[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___254[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___29[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/vqp.h"
static char const   rcsid_vqp_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int vqp_sendto___9(int sockfd , void *data , size_t data_len , int flags ,
                          fr_ipaddr_t *src_ipaddr , fr_ipaddr_t *dst_ipaddr , int dst_port ) 
{ 
  struct sockaddr_storage dst ;
  socklen_t sizeof_dst ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 91
  src_ipaddr = src_ipaddr;
#line 94
  tmp = fr_ipaddr2sockaddr((fr_ipaddr_t const   *)dst_ipaddr, dst_port, & dst, & sizeof_dst);
  }
#line 94
  if (! tmp) {
#line 95
    return (-1);
  }
  {
#line 112
  src_ipaddr = src_ipaddr;
#line 118
  tmp___0 = sendto(sockfd, (void const   *)data, data_len, flags, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                   sizeof_dst);
  }
#line 118
  return ((int )tmp___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static ssize_t vqp_recvfrom___9(int sockfd , uint8_t **pbuf , int flags , fr_ipaddr_t *src_ipaddr ,
                                uint16_t *src_port , fr_ipaddr_t *dst_ipaddr , uint16_t *dst_port ) 
{ 
  struct sockaddr_storage src ;
  struct sockaddr_storage dst ;
  socklen_t sizeof_src ;
  socklen_t sizeof_dst ;
  ssize_t data_len ;
  uint8_t header[4] ;
  void *buf ;
  size_t len ;
  int port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  sizeof_src = (socklen_t )sizeof(src);
#line 135
  sizeof_dst = (socklen_t )sizeof(dst);
#line 142
  memset((void *)(& src), 0, (size_t )sizeof_src);
#line 143
  memset((void *)(& dst), 0, (size_t )sizeof_dst);
#line 152
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dst)),
                    (socklen_t */* __restrict  */)(& sizeof_dst));
  }
#line 152
  if (tmp < 0) {
#line 153
    return ((ssize_t )-1);
  }
  {
#line 160
  data_len = recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), 2,
                      (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 162
  if (data_len < 0L) {
#line 162
    return ((ssize_t )-1);
  }
#line 167
  if (data_len < 4L) {
    {
#line 168
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 170
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[0] != 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] < 1) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[1] > 4) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  } else
#line 176
  if ((int )header[3] > 12) {
    {
#line 180
    recvfrom(sockfd, (void */* __restrict  */)(header), sizeof(header), flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
             (socklen_t */* __restrict  */)(& sizeof_src));
    }
#line 182
    return ((ssize_t )0);
  }
  {
#line 222
  len = (size_t )3132;
#line 224
  buf = malloc(len);
  }
#line 225
  if (! buf) {
#line 225
    return ((ssize_t )-1);
  }
  {
#line 241
  data_len = recvfrom(sockfd, (void */* __restrict  */)buf, len, flags, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                      (socklen_t */* __restrict  */)(& sizeof_src));
  }
#line 243
  if (data_len < 0L) {
    {
#line 244
    free(buf);
    }
#line 245
    return (data_len);
  }
  {
#line 248
  tmp___0 = fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& src), sizeof_src,
                               src_ipaddr, & port);
  }
#line 248
  if (! tmp___0) {
    {
#line 249
    free(buf);
    }
#line 250
    return ((ssize_t )-1);
  }
  {
#line 252
  *src_port = (uint16_t )port;
#line 254
  fr_sockaddr2ipaddr((struct sockaddr_storage  const  *)(& dst), sizeof_dst, dst_ipaddr,
                     & port);
#line 255
  *dst_port = (uint16_t )port;
  }
#line 260
  if ((int )src.ss_family != (int )dst.ss_family) {
    {
#line 261
    free(buf);
    }
#line 262
    return ((ssize_t )-1);
  }
#line 268
  *pbuf = (uint8_t *)buf;
#line 270
  return (data_len);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/vqp.c"
static int contents___9[5][12]  = { {        0,        0,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3077}, 
   {        3075,        3080,        0,        0, 
            0,        0}, 
   {        3073,        3074,        3075,        3076, 
            3079,        3080}, 
   {        3075,        3080,        0,        0, 
            0,        0}};
#line 53 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/snprintf.c"
static char const   rcsid___295[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static char const   rcsid___296[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___255[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___275[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___255[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___255[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___265[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___255[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___18[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/event.c"
static int fr_event_list_time_cmp___9(void const   *one , void const   *two ) 
{ 
  fr_event_t const   *a ;
  fr_event_t const   *b ;

  {
#line 72
  a = (fr_event_t const   *)one;
#line 73
  b = (fr_event_t const   *)two;
#line 75
  if (a->when.tv_sec < b->when.tv_sec) {
#line 75
    return (-1);
  }
#line 76
  if (a->when.tv_sec > b->when.tv_sec) {
#line 76
    return (1);
  }
#line 78
  if (a->when.tv_usec < b->when.tv_usec) {
#line 78
    return (-1);
  }
#line 79
  if (a->when.tv_usec > b->when.tv_usec) {
#line 79
    return (1);
  }
#line 81
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   rcsid___297[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___256[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___276[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___256[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___256[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___266[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___256[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterPortType___9[19]  = 
#line 231 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
  {      {"ftp-data", 20}, 
        {"ftp", 21}, 
        {"telnet", 23}, 
        {"smtp", 25}, 
        {"nameserver", 42}, 
        {"domain", 53}, 
        {"tftp", 69}, 
        {"gopher", 70}, 
        {"finger", 79}, 
        {"www", 80}, 
        {"kerberos", 88}, 
        {"hostname", 101}, 
        {"nntp", 119}, 
        {"ntp", 123}, 
        {"exec", 512}, 
        {"login", 513}, 
        {"cmd", 514}, 
        {"talk", 517}, 
        {(char const   *)((void *)0), 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterType___9[4]  = {      {"generic", 0}, 
        {"ip", 1}, 
        {"ipx", 2}, 
        {(char const   *)((void *)0), 0}};
#line 289 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterKeywords___9[22]  = 
#line 289
  {      {"ip", 1}, 
        {"generic", 0}, 
        {"in", 2}, 
        {"out", 3}, 
        {"forward", 4}, 
        {"drop", 5}, 
        {"dstip", 12}, 
        {"srcip", 13}, 
        {"dstport", 15}, 
        {"srcport", 16}, 
        {"est", 17}, 
        {"more", 11}, 
        {"!=", 9}, 
        {"==", 10}, 
        {"ipx", 18}, 
        {"dstipxnet", 19}, 
        {"dstipxnode", 20}, 
        {"dstipxsock", 21}, 
        {"srcipxnet", 22}, 
        {"srcipxnode", 23}, 
        {"srcipxsock", 24}, 
        {(char const   *)((void *)0), -1}};
#line 321 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterProtoName___9[6]  = {      {"tcp", 6}, 
        {"udp", 17}, 
        {"ospf", 89}, 
        {"icmp", 1}, 
        {"0", 0}, 
        {(char const   *)((void *)0), -1}};
#line 344 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static FR_NAME_NUMBER const   filterCompare___9[5]  = {      {"<", 1}, 
        {"=", 2}, 
        {">", 3}, 
        {"!=", 4}, 
        {(char const   *)((void *)0), 0}};
#line 357 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int str2argv___19(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 359
  argc = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! *str) {
#line 361
      goto while_break;
    }
#line 362
    if (argc >= max_argc) {
#line 362
      return (argc);
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )*str == 32)) {
#line 364
        goto while_break___0;
      }
#line 364
      tmp = str;
#line 364
      str ++;
#line 364
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if (! *str) {
#line 366
      return (argc);
    }
#line 368
    *(argv + argc) = str;
#line 369
    argc ++;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (*str) {
#line 371
        if (! ((int )*str != 32)) {
#line 371
          goto while_break___1;
        }
      } else {
#line 371
        goto while_break___1;
      }
#line 371
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return (argc);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx_net___9(int argc , char **argv , ascend_ipx_net_t *net ,
                                    uint8_t *comp ) 
{ 
  int token ;
  char const   *p ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 389
  if (argc < 3) {
#line 389
    return (-1);
  }
  {
#line 394
  tmp = strtol((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)((void *)0),
               16);
#line 394
  net->net = htonl((uint32_t )tmp);
#line 399
  token = fr_str2int(filterKeywords___9, (char const   *)*(argv + 1), -1);
  }
  {
#line 402
  if (token == 20) {
#line 402
    goto case_20;
  }
#line 402
  if (token == 23) {
#line 402
    goto case_20;
  }
#line 405
  goto switch_default;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  p = (char const   *)*(argv + 2);
#line 413
  tmp___0 = memcmp((void const   *)p, (void const   *)"0X", (size_t )2);
  }
#line 413
  if (tmp___0 == 0) {
#line 414
    p += 2;
  } else {
    {
#line 413
    tmp___1 = memcmp((void const   *)p, (void const   *)"0x", (size_t )2);
    }
#line 413
    if (tmp___1 == 0) {
#line 414
      p += 2;
    }
  }
  {
#line 419
  tmp___2 = fr_hex2bin(p, net->node, (size_t )6);
#line 419
  token = (int )tmp___2;
  }
#line 420
  if (token != 6) {
#line 420
    return (-1);
  }
#line 425
  if (argc == 3) {
#line 425
    return (3);
  }
#line 430
  if (argc != 6) {
#line 430
    return (-1);
  }
  {
#line 435
  token = fr_str2int(filterKeywords___9, (char const   *)*(argv + 3), -1);
  }
  {
#line 438
  if (token == 21) {
#line 438
    goto case_21;
  }
#line 438
  if (token == 24) {
#line 438
    goto case_21;
  }
#line 441
  goto switch_default___0;
  case_21: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 439
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 448
  token = fr_str2int(filterCompare___9, (char const   *)*(argv + 4), -1);
  }
  {
#line 453
  if (token == 4) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 3) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 2) {
#line 453
    goto case_4;
  }
#line 453
  if (token == 1) {
#line 453
    goto case_4;
  }
#line 457
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 454
  *comp = (uint8_t )token;
#line 455
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 458
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 464
  tmp___3 = strtoul((char const   */* __restrict  */)*(argv + 5), (char **/* __restrict  */)((void *)0),
                    16);
#line 464
  token = (int )tmp___3;
  }
#line 465
  if (token > 65535) {
#line 465
    return (-1);
  }
  {
#line 467
  net->socket = (uint16_t )token;
#line 468
  net->socket = htons(net->socket);
  }
#line 474
  return (6);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipx___9(int argc , char **argv , ascend_ipx_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;

  {
#line 519
  flags = 0;
#line 524
  if (argc == 0) {
#line 524
    return (0);
  }
#line 529
  if (argc < 4) {
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (argc > 0) {
#line 531
      if (! (flags != 3)) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
    {
#line 532
    token = fr_str2int(filterKeywords___9, (char const   *)*(argv + 0), -1);
    }
    {
#line 534
    if (token == 22) {
#line 534
      goto case_22;
    }
#line 545
    if (token == 19) {
#line 545
      goto case_19;
    }
#line 556
    goto switch_default;
    case_22: /* CIL Label */ 
#line 535
    if (flags & 1) {
#line 535
      return (-1);
    }
    {
#line 536
    rcode = ascend_parse_ipx_net___9(argc - 1, argv + 1, & filter->src, & filter->srcSocComp);
    }
#line 539
    if (rcode < 0) {
#line 539
      return (-1);
    }
#line 540
    argc -= rcode + 1;
#line 541
    argv += rcode + 1;
#line 542
    flags |= 1;
#line 543
    goto switch_break;
    case_19: /* CIL Label */ 
#line 546
    if (flags & 2) {
#line 546
      return (-1);
    }
    {
#line 547
    rcode = ascend_parse_ipx_net___9(argc - 1, argv + 1, & filter->dst, & filter->dstSocComp);
    }
#line 550
    if (rcode < 0) {
#line 550
      return (-1);
    }
#line 551
    argc -= rcode + 1;
#line 552
    argv += rcode + 1;
#line 553
    flags |= 2;
#line 554
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    fr_strerror_printf("Unknown string \"%s\" in IPX data filter", *(argv + 0));
    }
#line 559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if (argc != 0) {
#line 566
    return (-1);
  }
#line 571
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ipaddr___9(uint32_t *ipaddr , char *str ) 
{ 
  int count ;
  int ip[4] ;
  int masklen ;
  uint32_t netmask ;
  size_t tmp ;

  {
#line 585
  count = 0;
#line 588
  netmask = (uint32_t )0;
#line 593
  count = 0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*str) {
#line 594
      if (count < 4) {
#line 594
        if (! (netmask == 0U)) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
    next: 
#line 596
    ip[count] = 0;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! *str) {
#line 598
        goto while_break___0;
      }
      {
#line 602
      if ((int )*str == 57) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 56) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 55) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 54) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 53) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 52) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 51) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 50) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 49) {
#line 602
        goto case_57;
      }
#line 602
      if ((int )*str == 48) {
#line 602
        goto case_57;
      }
#line 609
      if ((int )*str == 46) {
#line 609
        goto case_46;
      }
#line 620
      if ((int )*str == 47) {
#line 620
        goto case_47;
      }
#line 629
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 603
      ip[count] *= 10;
#line 604
      ip[count] += (int )*str - 48;
#line 605
      str ++;
#line 606
      goto switch_break;
      case_46: /* CIL Label */ 
#line 610
      str ++;
#line 611
      if (ip[count] > 255) {
#line 611
        return (-1);
      }
#line 616
      *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
#line 617
      count ++;
#line 618
      goto next;
      case_47: /* CIL Label */ 
      {
#line 621
      str ++;
#line 622
      masklen = atoi((char const   *)str);
      }
#line 623
      if (masklen < 0) {
#line 623
        return (-1);
      } else
#line 623
      if (masklen > 32) {
#line 623
        return (-1);
      }
      {
#line 624
      tmp = strspn((char const   *)str, "0123456789");
#line 624
      str += tmp;
#line 625
      netmask = (uint32_t )masklen;
      }
#line 626
      goto finalize;
#line 627
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 630
      fr_strerror_printf("Invalid character in IP address");
      }
#line 631
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (count == 3) {
    finalize: 
#line 641
    if (ip[count] > 255) {
#line 641
      return (-1);
    }
#line 646
    *ipaddr |= (unsigned int )(ip[count] << 8 * (3 - count));
  }
#line 653
  if (*str) {
#line 653
    return (-1);
  }
#line 658
  if (! netmask) {
#line 659
    if (! *ipaddr) {
#line 660
      netmask = (uint32_t )0;
    } else
#line 661
    if ((*ipaddr & 2147483648U) == 0U) {
#line 662
      netmask = (uint32_t )8;
    } else
#line 663
    if ((*ipaddr & 3221225472U) == 2147483648U) {
#line 664
      netmask = (uint32_t )16;
    } else
#line 665
    if ((*ipaddr & 3758096384U) == 3221225472U) {
#line 666
      netmask = (uint32_t )24;
    } else {
#line 668
      netmask = (uint32_t )32;
    }
  }
  {
#line 672
  *ipaddr = htonl(*ipaddr);
  }
#line 673
  return ((int )netmask);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_port___9(uint16_t *port , char *compare , char *str ) 
{ 
  int rcode ;
  int token ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 683
  token = -1;
#line 688
  rcode = fr_str2int(filterCompare___9, (char const   *)compare, -1);
  }
#line 689
  if (rcode < 0) {
#line 689
    return (rcode);
  }
  {
#line 691
  tmp = strspn((char const   *)str, "0123456789");
#line 691
  tmp___0 = strlen((char const   *)str);
  }
#line 691
  if (tmp == tmp___0) {
    {
#line 692
    token = atoi((char const   *)str);
    }
  } else {
    {
#line 694
    token = fr_str2int(filterPortType___9, (char const   *)str, -1);
    }
  }
#line 697
  if (token < 0) {
#line 697
    return (-1);
  } else
#line 697
  if (token > 65535) {
#line 697
    return (-1);
  }
  {
#line 699
  *port = (uint16_t )token;
#line 700
  *port = htons(*port);
  }
#line 702
  return (rcode);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_ip___9(int argc , char **argv , ascend_ip_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 757
  if (argc == 0) {
#line 757
    return (0);
  }
#line 762
  flags = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (argc > 0) {
#line 763
      if (! (flags != (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
    {
#line 764
    token = fr_str2int(filterKeywords___9, (char const   *)*(argv + 0), -1);
    }
    {
#line 766
    if (token == 13) {
#line 766
      goto case_13;
    }
#line 779
    if (token == 12) {
#line 779
      goto case_12;
    }
#line 792
    if (token == 16) {
#line 792
      goto case_16;
    }
#line 806
    if (token == 15) {
#line 806
      goto case_15;
    }
#line 820
    if (token == 17) {
#line 820
      goto case_17;
    }
#line 828
    goto switch_default;
    case_13: /* CIL Label */ 
#line 767
    if (flags & 1) {
#line 767
      return (-1);
    }
#line 768
    if (argc < 2) {
#line 768
      return (-1);
    }
    {
#line 770
    rcode = ascend_parse_ipaddr___9(& filter->srcip, *(argv + 1));
    }
#line 771
    if (rcode < 0) {
#line 771
      return (rcode);
    }
#line 773
    filter->srcmask = (uint8_t )rcode;
#line 774
    flags |= 1;
#line 775
    argv += 2;
#line 776
    argc -= 2;
#line 777
    goto switch_break;
    case_12: /* CIL Label */ 
#line 780
    if (flags & (1 << 1)) {
#line 780
      return (-1);
    }
#line 781
    if (argc < 2) {
#line 781
      return (-1);
    }
    {
#line 783
    rcode = ascend_parse_ipaddr___9(& filter->dstip, *(argv + 1));
    }
#line 784
    if (rcode < 0) {
#line 784
      return (rcode);
    }
#line 786
    filter->dstmask = (uint8_t )rcode;
#line 787
    flags |= 1 << 1;
#line 788
    argv += 2;
#line 789
    argc -= 2;
#line 790
    goto switch_break;
    case_16: /* CIL Label */ 
#line 793
    if (flags & (1 << 2)) {
#line 793
      return (-1);
    }
#line 794
    if (argc < 3) {
#line 794
      return (-1);
    }
    {
#line 796
    rcode = ascend_parse_port___9(& filter->srcport, *(argv + 1), *(argv + 2));
    }
#line 798
    if (rcode < 0) {
#line 798
      return (rcode);
    }
#line 799
    filter->srcPortComp = (uint8_t )rcode;
#line 801
    flags |= 1 << 2;
#line 802
    argv += 3;
#line 803
    argc -= 3;
#line 804
    goto switch_break;
    case_15: /* CIL Label */ 
#line 807
    if (flags & (1 << 3)) {
#line 807
      return (-1);
    }
#line 808
    if (argc < 3) {
#line 808
      return (-1);
    }
    {
#line 810
    rcode = ascend_parse_port___9(& filter->dstport, *(argv + 1), *(argv + 2));
    }
#line 812
    if (rcode < 0) {
#line 812
      return (rcode);
    }
#line 813
    filter->dstPortComp = (uint8_t )rcode;
#line 815
    flags |= 1 << 3;
#line 816
    argv += 3;
#line 817
    argc -= 3;
#line 818
    goto switch_break;
    case_17: /* CIL Label */ 
#line 821
    if (flags & (1 << 5)) {
#line 821
      return (-1);
    }
#line 822
    filter->established = (uint8_t )1;
#line 823
    argv ++;
#line 824
    argc --;
#line 825
    flags |= 1 << 5;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    if (flags & (1 << 4)) {
#line 829
      return (-1);
    }
    {
#line 830
    tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 830
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 830
    if (tmp == tmp___0) {
      {
#line 831
      token = atoi((char const   *)*(argv + 0));
      }
    } else {
      {
#line 833
      token = fr_str2int(filterProtoName___9, (char const   *)*(argv + 0), -1);
      }
#line 834
      if (token == -1) {
        {
#line 835
        fr_strerror_printf("Unknown IP protocol \"%s\" in IP data filter", *(argv + 0));
        }
#line 837
        return (-1);
      }
    }
#line 840
    filter->proto = (uint8_t )token;
#line 841
    flags |= 1 << 4;
#line 843
    argv ++;
#line 844
    argc --;
#line 845
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (argc != 0) {
    {
#line 853
    fr_strerror_printf("Unknown extra string \"%s\" in IP data filter", *(argv + 0));
    }
#line 855
    return (-1);
  }
#line 858
  return (0);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static int ascend_parse_generic___9(int argc , char **argv , ascend_generic_filter_t *filter ) 
{ 
  int rcode ;
  int token ;
  int flags ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 895
  if (argc == 0) {
#line 895
    return (0);
  }
#line 900
  if (argc < 3) {
#line 900
    return (-1);
  }
#line 905
  if (argc > 5) {
#line 905
    return (-1);
  }
  {
#line 910
  tmp = strspn((char const   *)*(argv + 0), "0123456789");
#line 910
  tmp___0 = strlen((char const   *)*(argv + 0));
  }
#line 910
  if (tmp != tmp___0) {
#line 910
    return (-1);
  }
  {
#line 912
  rcode = atoi((char const   *)*(argv + 0));
  }
#line 913
  if (rcode > 65535) {
#line 913
    return (-1);
  }
  {
#line 915
  filter->offset = (uint16_t )rcode;
#line 916
  filter->offset = htons(filter->offset);
#line 918
  tmp___1 = fr_hex2bin((char const   *)*(argv + 1), filter->mask, sizeof(filter->mask));
#line 918
  rcode = (int )tmp___1;
  }
#line 919
  if ((unsigned long )rcode != sizeof(filter->mask)) {
#line 919
    return (-1);
  }
  {
#line 921
  tmp___2 = fr_hex2bin((char const   *)*(argv + 2), filter->value, sizeof(filter->value));
#line 921
  token = (int )tmp___2;
  }
#line 922
  if ((unsigned long )token != sizeof(filter->value)) {
#line 922
    return (-1);
  }
#line 927
  if (rcode != token) {
#line 927
    return (-1);
  }
  {
#line 929
  filter->len = (uint16_t )rcode;
#line 930
  filter->len = htons(filter->len);
  }
#line 935
  if (argc == 3) {
#line 935
    return (0);
  }
#line 937
  argc -= 3;
#line 938
  argv += 3;
#line 939
  flags = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (argc >= 1)) {
#line 941
      goto while_break;
    }
    {
#line 942
    token = fr_str2int(filterKeywords___9, (char const   *)*(argv + 0), -1);
    }
    {
#line 944
    if (token == 9) {
#line 944
      goto case_9;
    }
#line 949
    if (token == 10) {
#line 949
      goto case_10;
    }
#line 955
    if (token == 11) {
#line 955
      goto case_11;
    }
#line 961
    goto switch_default;
    case_9: /* CIL Label */ 
#line 945
    if (flags & 1) {
#line 945
      return (-1);
    }
#line 946
    filter->compNeq = (uint8_t )1;
#line 947
    flags |= 1;
#line 948
    goto switch_break;
    case_10: /* CIL Label */ 
#line 950
    if (flags & 1) {
#line 950
      return (-1);
    }
#line 951
    filter->compNeq = (uint8_t )0;
#line 952
    flags |= 1;
#line 953
    goto switch_break;
    case_11: /* CIL Label */ 
#line 956
    if (flags & 2) {
#line 956
      return (-1);
    }
    {
#line 957
    filter->more = htons((uint16_t )1);
#line 958
    flags |= 2;
    }
#line 959
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 962
    fr_strerror_printf("Invalid string \"%s\" in generic data filter", *(argv + 0));
    }
#line 964
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 967
    argc --;
#line 968
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (0);
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *action___9[2]  = {      "drop",      "forward"};
#line 1152 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/filters.c"
static char const   *direction___9[2]  = {      "out",      "in"};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_copy_packet/rlm_copy_packet.c"
static char const   rcsid___298[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/radiusd.h"
static char const   rcsid_radiusd_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___257[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___277[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___257[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___257[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___267[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___257[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/conffile.h"
static char const   rcsid_conffile_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/event.h"
static char const   rcsid_event_h___19[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/stats.h"
static char const   rcsid_stats_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/realms.h"
static char const   rcsid_realms_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 12 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/modules.h"
static char const   rcsid_modules_h___8[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_copy_packet/rlm_copy_packet.c"
static CONF_PARSER const   module_config___6[2]  = {      {"string", 100, (unsigned long )(& ((rlm_packet_t *)0)->string), (void *)0, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      -1, (size_t )0, (void *)0, (char const   *)((void *)0)}};
#line 56 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_copy_packet/rlm_copy_packet.c"
static int packet_detach(void *instance ) 
{ 


  {
  {
#line 58
  free(instance);
  }
#line 59
  return (0);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_copy_packet/rlm_copy_packet.c"
static int packet_instantiate(CONF_SECTION *conf , void **instance ) 
{ 
  rlm_packet_t *inst ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 80
  tmp = rad_malloc(sizeof(*inst));
#line 80
  inst = (rlm_packet_t *)tmp;
  }
#line 81
  if (! inst) {
#line 82
    return (-1);
  }
  {
#line 84
  memset((void *)inst, 0, sizeof(*inst));
#line 90
  tmp___0 = cf_section_parse(conf, (void *)inst, module_config___6);
  }
#line 90
  if (tmp___0 < 0) {
    {
#line 91
    packet_detach((void *)inst);
    }
#line 92
    return (-1);
  }
#line 95
  *instance = (void *)inst;
#line 97
  return (0);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_copy_packet/rlm_copy_packet.c"
static int packet_authorize(void *instance , REQUEST *request ) 
{ 
  VALUE_PAIR *vps ;

  {
  {
#line 108
  instance = instance;
#line 110
  vps = paircopy((request->packet)->vps);
#line 111
  pairadd(& (request->reply)->vps, vps);
  }
#line 112
  return (8);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/modules/rlm_copy_packet/rlm_copy_packet.c"
module_t rlm_copy_packet  =    {4109257426U, "copy_packet", 0, & packet_instantiate, & packet_detach, {(packetmethod )((void *)0),
                                                                           & packet_authorize,
                                                                           (packetmethod )((void *)0),
                                                                           (packetmethod )((void *)0),
                                                                           (packetmethod )((void *)0),
                                                                           (packetmethod )((void *)0),
                                                                           (packetmethod )((void *)0),
                                                                           (packetmethod )((void *)0)}};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static char const   rcsid___299[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___258[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___278[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___258[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___258[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___268[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___258[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_key_t fr_strerror_key___9  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static pthread_once_t fr_strerror_once___9  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/log.c"
static void fr_strerror_make_key___9(void) 
{ 


  {
  {
#line 75
  pthread_key_create(& fr_strerror_key___9, (void (*)(void * ))((void *)0));
  }
#line 76
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dhcp.c"
static char const   rcsid___300[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___259[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___279[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___259[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___259[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___269[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___259[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___30[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/dhcp.h"
static char const   rcsid_dhcp_h___9[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 14 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/isaac.c"
static char const   rcsid___301[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___260[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___280[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___260[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___260[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___270[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___260[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   rcsid___302[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___261[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___281[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___261[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___261[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___271[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___261[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *months___9[12]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
  {      "jan",      "feb",      "mar",      "apr", 
        "may",      "jun",      "jul",      "aug", 
        "sep",      "oct",      "nov",      "dec"};
#line 678 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char *mystrtok___9(char **ptr , char const   *sep ) 
{ 
  char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 682
  if ((int )*(*ptr) == 0) {
#line 683
    return ((char *)((void *)0));
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (*(*ptr)) {
      {
#line 684
      tmp = strchr(sep, (int )*(*ptr));
      }
#line 684
      if (! tmp) {
#line 684
        goto while_break;
      }
    } else {
#line 684
      goto while_break;
    }
#line 685
    (*ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((int )*(*ptr) == 0) {
#line 687
    return ((char *)((void *)0));
  }
#line 688
  res = *ptr;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (*(*ptr)) {
      {
#line 689
      tmp___0 = strchr(sep, (int )*(*ptr));
      }
#line 689
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 689
        goto while_break___0;
      }
    } else {
#line 689
      goto while_break___0;
    }
#line 690
    (*ptr) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  if ((int )*(*ptr) != 0) {
#line 692
    tmp___1 = *ptr;
#line 692
    (*ptr) ++;
#line 692
    *tmp___1 = (char)0;
  }
#line 693
  return (res);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int gettime___9(char const   *valstr , time_t *date ) 
{ 
  int i ;
  time_t t ;
  struct tm *tm ;
  struct tm s_tm ;
  char buf[64] ;
  char *p ;
  char *f[4] ;
  char *tail ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 708
  tail = (char *)'\000';
#line 713
  tmp = strtoul((char const   */* __restrict  */)valstr, (char **/* __restrict  */)(& tail),
                10);
#line 713
  *date = (time_t )tmp;
  }
#line 714
  if ((int )*tail == 0) {
#line 715
    return (0);
  }
  {
#line 718
  tm = & s_tm;
#line 719
  memset((void *)tm, 0, sizeof(*tm));
#line 720
  tm->tm_isdst = -1;
#line 722
  strlcpy(buf, valstr, sizeof(buf));
#line 724
  p = buf;
#line 725
  f[0] = mystrtok___9(& p, " \t");
#line 726
  f[1] = mystrtok___9(& p, " \t");
#line 727
  f[2] = mystrtok___9(& p, " \t");
#line 728
  f[3] = mystrtok___9(& p, " \t");
  }
#line 729
  if (! f[0]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[1]) {
#line 729
    return (-1);
  } else
#line 729
  if (! f[2]) {
#line 729
    return (-1);
  }
#line 735
  if (f[3]) {
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! (i < 3)) {
#line 736
        goto while_break;
      }
      {
#line 737
      tmp___0 = strchr((char const   *)f[i], ':');
      }
#line 737
      if (tmp___0) {
#line 738
        p = f[3];
#line 739
        f[3] = f[i];
#line 740
        f[i] = p;
#line 741
        goto while_break;
      }
#line 736
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  tm->tm_mon = 12;
#line 750
  i = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (! (i < 3)) {
#line 750
      goto while_break___0;
    }
    {
#line 751
    tmp___2 = __ctype_b_loc();
    }
#line 751
    if ((int const   )*(*tmp___2 + (int )*(f[i])) & 1024) {
#line 755
      p = f[0];
#line 756
      f[0] = f[i];
#line 757
      f[i] = p;
#line 759
      i = 0;
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! (i < 12)) {
#line 759
          goto while_break___1;
        }
        {
#line 760
        tmp___1 = strncasecmp(months___9[i], (char const   *)f[0], (size_t )3);
        }
#line 760
        if (tmp___1 == 0) {
#line 761
          tm->tm_mon = i;
#line 762
          goto while_break___1;
        }
#line 759
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 750
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 769
  if (tm->tm_mon == 12) {
#line 769
    return (-1);
  }
  {
#line 774
  tm->tm_year = atoi((char const   *)f[1]);
#line 775
  tm->tm_mday = atoi((char const   *)f[2]);
  }
#line 777
  if (tm->tm_year >= 1900) {
#line 778
    tm->tm_year -= 1900;
  } else {
#line 785
    if (tm->tm_mday < 1900) {
#line 785
      return (-1);
    }
#line 790
    i = tm->tm_year;
#line 791
    tm->tm_year = tm->tm_mday - 1900;
#line 792
    tm->tm_mday = i;
  }
#line 798
  if (tm->tm_mday < 1) {
#line 799
    return (-1);
  } else
#line 798
  if (tm->tm_mday > 31) {
#line 799
    return (-1);
  }
#line 805
  if (f[3]) {
    {
#line 806
    f[0] = f[3];
#line 807
    f[1] = strchr((char const   *)f[0], ':');
    }
#line 808
    if (! f[1]) {
#line 808
      return (-1);
    }
    {
#line 810
    tmp___3 = f[1];
#line 810
    (f[1]) ++;
#line 810
    *tmp___3 = (char )'\000';
#line 812
    f[2] = strchr((char const   *)f[1], ':');
    }
#line 813
    if (f[2]) {
      {
#line 814
      tmp___4 = f[2];
#line 814
      (f[2]) ++;
#line 814
      *tmp___4 = (char )'\000';
#line 815
      tm->tm_sec = atoi((char const   *)f[2]);
      }
    }
    {
#line 818
    tm->tm_hour = atoi((char const   *)f[0]);
#line 819
    tm->tm_min = atoi((char const   *)f[1]);
    }
  }
  {
#line 825
  t = mktime(tm);
  }
#line 826
  if (t == -1L) {
#line 826
    return (-1);
  }
#line 828
  *date = t;
#line 830
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static char const   *hextab___19  =    "0123456789abcdef";
#line 843 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static uint32_t getint___9(char const   *value , char **end ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 845
  if ((int const   )*(value + 0) == 48) {
#line 845
    if ((int const   )*(value + 1) == 120) {
      {
#line 846
      tmp = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    16);
      }
#line 846
      return ((uint32_t )tmp);
    }
  }
  {
#line 849
  tmp___0 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)end,
                    10);
  }
#line 849
  return ((uint32_t )tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int check_for_whitespace___9(char const   *value ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! *value) {
#line 854
      goto while_break;
    }
    {
#line 855
    tmp = __ctype_b_loc();
    }
#line 855
    if (! ((int const   )*(*tmp + (int )*value) & 8192)) {
#line 855
      return (0);
    }
#line 857
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (1);
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static VALUE_PAIR *pairmake_any___9(char const   *attribute , char const   *value ,
                                    int operator ) 
{ 
  int attr ;
  int vendor ;
  size_t size ;
  char const   *p ;
  char *q ;
  VALUE_PAIR *vp ;
  int tmp ;
  long tmp___0 ;
  char buffer[256] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  DICT_VENDOR *dv ;
  DICT_VENDOR *tmp___5 ;
  size_t tmp___6 ;

  {
#line 1284
  p = attribute;
#line 1291
  if (value) {
    {
#line 1291
    tmp = strncasecmp(value, "0x", (size_t )2);
    }
#line 1291
    if (tmp != 0) {
      {
#line 1292
      fr_strerror_printf("Unknown attribute \"%s\" requires a hex string, not \"%s\"",
                         attribute, value);
      }
#line 1293
      return ((VALUE_PAIR *)((void *)0));
    }
  }
  {
#line 1296
  vendor = 0;
#line 1301
  tmp___2 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1301
  if (tmp___2 != 0) {
    {
#line 1302
    tmp___1 = strncasecmp(p, "Vendor-", (size_t )7);
    }
#line 1302
    if (tmp___1 == 0) {
      {
#line 1303
      tmp___0 = strtol((char const   */* __restrict  */)(p + 7), (char **/* __restrict  */)(& q),
                       10);
#line 1303
      vendor = (int )tmp___0;
      }
#line 1304
      if (vendor == 0) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      } else
#line 1304
      if (vendor > 65535) {
        {
#line 1305
        fr_strerror_printf("Invalid vendor value in attribute name \"%s\"", attribute);
        }
#line 1306
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1309
      p = (char const   *)q;
    } else {
      {
#line 1314
      q = strchr(p, '-');
      }
#line 1316
      if (! q) {
        {
#line 1317
        fr_strerror_printf("Invalid vendor name in attribute name \"%s\"", attribute);
        }
#line 1318
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1321
      if ((size_t )(q - (char *)p) >= sizeof(buffer)) {
        {
#line 1322
        fr_strerror_printf("Vendor name too long in attribute name \"%s\"", attribute);
        }
#line 1323
        return ((VALUE_PAIR *)((void *)0));
      }
      {
#line 1326
      memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)p,
             (size_t )(q - (char *)p));
#line 1327
      buffer[q - (char *)p] = (char )'\000';
#line 1329
      vendor = dict_vendorbyname((char const   *)(buffer));
      }
#line 1330
      if (! vendor) {
        {
#line 1331
        fr_strerror_printf("Unknown vendor name in attribute name \"%s\"", attribute);
        }
#line 1332
        return ((VALUE_PAIR *)((void *)0));
      }
#line 1335
      p = (char const   *)q;
    }
#line 1338
    if ((int const   )*p != 45) {
      {
#line 1339
      fr_strerror_printf("Invalid text following vendor definition in attribute name \"%s\"",
                         attribute);
      }
#line 1340
      return ((VALUE_PAIR *)((void *)0));
    }
#line 1342
    p ++;
  }
  {
#line 1348
  tmp___3 = strncasecmp(p, "Attr-", (size_t )5);
  }
#line 1348
  if (tmp___3 != 0) {
    {
#line 1349
    fr_strerror_printf("Invalid format in attribute name \"%s\"", attribute);
    }
#line 1350
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1353
  tmp___4 = strtol((char const   */* __restrict  */)(p + 5), (char **/* __restrict  */)(& q),
                   10);
#line 1353
  attr = (int )tmp___4;
  }
#line 1358
  if (attr == 0) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  } else
#line 1358
  if (*q) {
    {
#line 1359
    fr_strerror_printf("Invalid value in attribute name \"%s\"", attribute);
    }
#line 1360
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1366
  if (vendor) {
    {
#line 1367
    tmp___5 = dict_vendorbyvalue(vendor);
#line 1367
    dv = tmp___5;
    }
#line 1369
    if (! dv) {
#line 1370
      if (attr > 255) {
        attr_error: 
        {
#line 1372
        fr_strerror_printf("Invalid attribute number in attribute name \"%s\"", attribute);
        }
#line 1373
        return ((VALUE_PAIR *)((void *)0));
      }
    } else {
      {
#line 1377
      if (dv->type == 1) {
#line 1377
        goto case_1;
      }
#line 1381
      if (dv->type == 2) {
#line 1381
        goto case_2;
      }
#line 1385
      if (dv->type == 4) {
#line 1385
        goto case_4;
      }
#line 1389
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1378
      if (attr > 255) {
#line 1378
        goto attr_error;
      }
#line 1379
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1382
      if (attr > 65535) {
#line 1382
        goto attr_error;
      }
#line 1383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1386
      if (attr > 65535) {
#line 1386
        goto attr_error;
      }
#line 1387
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1390
      fr_strerror_printf("Internal sanity check failed");
      }
#line 1391
      return ((VALUE_PAIR *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1395
  attr |= vendor << 16;
#line 1402
  vp = paircreate(attr, 5);
  }
#line 1402
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
#line 1403
    fr_strerror_printf("out of memory");
    }
#line 1404
    return ((VALUE_PAIR *)((void *)0));
  }
#line 1407
  if (operator == 0) {
#line 1407
    vp->operator = (FR_TOKEN )11;
  } else {
#line 1407
    vp->operator = (FR_TOKEN )operator;
  }
#line 1408
  if (! value) {
#line 1408
    return (vp);
  }
  {
#line 1410
  size = strlen(value + 2);
  }
  {
#line 1424
  if (vp->type == 4) {
#line 1424
    goto case_4___0;
  }
#line 1424
  if (vp->type == 5) {
#line 1424
    goto case_4___0;
  }
#line 1431
  if (vp->type == 0) {
#line 1431
    goto case_0;
  }
#line 1418
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1419
  if (size == vp->length * 2UL) {
#line 1419
    goto switch_break___0;
  }
#line 1420
  vp->type = 5;
  case_4___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1425
  vp->length = size >> 1;
#line 1426
  if (vp->length > sizeof(vp->data.octets)) {
#line 1427
    vp->length = sizeof(vp->data.octets);
  }
#line 1429
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1432
  vp->length = size >> 1;
#line 1433
  memset((void *)(& vp->data.strvalue), 0, sizeof(vp->data.strvalue));
  }
#line 1434
  if (vp->length >= sizeof(vp->data.strvalue)) {
#line 1435
    vp->length = sizeof(vp->data.strvalue) - 1UL;
  }
#line 1437
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1440
  tmp___6 = fr_hex2bin(value + 2, vp->data.octets, size);
  }
#line 1440
  if (tmp___6 != vp->length) {
    {
#line 1441
    fr_strerror_printf("Invalid hex string");
#line 1442
    free((void *)vp);
    }
#line 1443
    return ((VALUE_PAIR *)((void *)0));
  }
  {
#line 1453
  if (vp->type == 1) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 2) {
#line 1453
    goto case_1___0;
  }
#line 1453
  if (vp->type == 3) {
#line 1453
    goto case_1___0;
  }
#line 1458
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1454
  memcpy((void */* __restrict  */)(& vp->lvalue), (void const   */* __restrict  */)(vp->data.octets),
         sizeof(vp->lvalue));
#line 1455
  vp->data.strvalue[0] = (char )'\000';
  }
#line 1456
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1459
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1462
  return (vp);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/valuepair.c"
static int const   valid_attr_name___9[256]  = 
#line 1621
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/udpfromto.c"
static char const   rcsid___303[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 9 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/udpfromto.h"
static char const   rcsid_udpfromtoh___31[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___262[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___282[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___262[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___262[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___272[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___262[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md4.c"
static char const   rcsid___304[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md4.h"
static char const   rcsid_md4_h___273[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   rcsid___305[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___263[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___283[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___263[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___263[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___274[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___263[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
static char const   *vp_tokens___9[27]  = 
#line 361 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/print.c"
  {      "?",      "EOL",      "{",      "}", 
        "(",      ")",      ",",      ";", 
        "+=",      "-=",      ":=",      "=", 
        "!=",      ">=",      ">",      "<=", 
        "<",      "=~",      "!~",      "=*", 
        "!*",      "==",      "#",      "<BARE-WORD>", 
        "<\"STRING\">",      "<\'STRING\'>",      "<`STRING`>"};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static char const   rcsid___306[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___264[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___284[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___264[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___264[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___275[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___264[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entries___9(fr_fifo_t *fi , fr_fifo_entry_t *head ) 
{ 
  fr_fifo_entry_t *next ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! head) {
#line 66
      goto while_break;
    }
#line 67
    next = head->next;
#line 69
    if (fi->freeNode) {
#line 69
      if (head->data) {
        {
#line 69
        (*(fi->freeNode))(head->data);
        }
      }
    }
    {
#line 70
    free((void *)head);
#line 72
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static fr_fifo_entry_t *fr_fifo_alloc_entry___9(fr_fifo_t *fi ) 
{ 
  fr_fifo_entry_t *entry ;
  void *tmp ;

  {
#line 90
  if (fi->freelist) {
#line 91
    entry = fi->freelist;
#line 92
    fi->freelist = entry->next;
  } else {
    {
#line 94
    tmp = malloc(sizeof(*entry));
#line 94
    entry = (fr_fifo_entry_t *)tmp;
    }
#line 95
    if (! entry) {
#line 95
      return ((fr_fifo_entry_t *)((void *)0));
    }
  }
  {
#line 98
  memset((void *)entry, 0, sizeof(*entry));
  }
#line 99
  return (entry);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/fifo.c"
static void fr_fifo_free_entry___9(fr_fifo_t *fi , fr_fifo_entry_t *entry ) 
{ 


  {
#line 128
  entry->data = (void *)0;
#line 129
  entry->next = fi->freelist;
#line 130
  fi->freelist = entry;
#line 131
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char const   rcsid___307[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___265[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___285[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___265[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___265[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___276[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___265[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byname___9  =    (fr_hash_table_t *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *vendors_byvalue___9  =    (fr_hash_table_t *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byname___9  =    (fr_hash_table_t *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *attributes_byvalue___9  =    (fr_hash_table_t *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byvalue___9  =    (fr_hash_table_t *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_hash_table_t *values_byname___9  =    (fr_hash_table_t *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *dict_base_attrs___9[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_dir___9  =    (char *)((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static char *stat_root_file___9  =    (char *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_head___9  =    (dict_stat_t *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static dict_stat_t *stat_tail___9  =    (dict_stat_t *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static value_fixup_t *value_fixup___9  =    (value_fixup_t *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static FR_NAME_NUMBER const   type_table___9[16]  = 
#line 81
  {      {"integer", 1}, 
        {"string", 0}, 
        {"ipaddr", 2}, 
        {"date", 3}, 
        {"abinary", 4}, 
        {"octets", 5}, 
        {"ifid", 6}, 
        {"ipv6addr", 7}, 
        {"ipv6prefix", 8}, 
        {"byte", 9}, 
        {"short", 10}, 
        {"ether", 11}, 
        {"combo-ip", 13}, 
        {"tlv", 14}, 
        {"signed", 12}, 
        {(char const   *)((void *)0), 0}};
#line 109 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_hashname___9(char const   *name ) 
{ 
  uint32_t hash ;
  char const   *p ;
  int c ;
  unsigned short const   **tmp ;

  {
#line 111
  hash = 2166136261U;
#line 114
  p = name;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int const   )*p != 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    c = (int )*((unsigned char const   *)p);
#line 116
    tmp = __ctype_b_loc();
    }
#line 116
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 116
      c = tolower(c);
      }
    }
#line 118
    hash *= 16777619U;
#line 119
    hash ^= (uint32_t )(c & 255);
#line 114
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (hash);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_name_hash___9(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 131
  tmp = dict_hashname___9((char const   *)(((DICT_ATTR const   *)data)->name));
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_name_cmp___9(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;
  int tmp ;

  {
  {
#line 136
  a = (DICT_ATTR const   *)one;
#line 137
  b = (DICT_ATTR const   *)two;
#line 139
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_attr_value_hash___9(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_ATTR const   *attr ;
  uint32_t tmp ;

  {
  {
#line 145
  attr = (DICT_ATTR const   *)data;
#line 147
  hash = fr_hash((void const   *)(& attr->vendor), sizeof(attr->vendor));
#line 148
  tmp = fr_hash_update((void const   *)(& attr->attr), sizeof(attr->attr), hash);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_attr_value_cmp___9(void const   *one , void const   *two ) 
{ 
  DICT_ATTR const   *a ;
  DICT_ATTR const   *b ;

  {
#line 153
  a = (DICT_ATTR const   *)one;
#line 154
  b = (DICT_ATTR const   *)two;
#line 156
  if (a->vendor < b->vendor) {
#line 156
    return (-1);
  }
#line 157
  if (a->vendor > b->vendor) {
#line 157
    return (1);
  }
#line 159
  return ((int )(a->attr - b->attr));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_name_hash___9(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 164
  tmp = dict_hashname___9((char const   *)(((DICT_VENDOR const   *)data)->name));
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_name_cmp___9(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;
  int tmp ;

  {
  {
#line 169
  a = (DICT_VENDOR const   *)one;
#line 170
  b = (DICT_VENDOR const   *)two;
#line 172
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_vendor_value_hash___9(void const   *data ) 
{ 
  uint32_t tmp ;

  {
  {
#line 177
  tmp = fr_hash((void const   *)(& ((DICT_VENDOR const   *)data)->vendorpec), sizeof(((DICT_VENDOR const   *)data)->vendorpec));
  }
#line 177
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_vendor_value_cmp___9(void const   *one , void const   *two ) 
{ 
  DICT_VENDOR const   *a ;
  DICT_VENDOR const   *b ;

  {
#line 183
  a = (DICT_VENDOR const   *)one;
#line 184
  b = (DICT_VENDOR const   *)two;
#line 186
  return ((int )(a->vendorpec - b->vendorpec));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_name_hash___9(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 192
  dval = (DICT_VALUE const   *)data;
#line 194
  hash = dict_hashname___9((char const   *)(dval->name));
#line 195
  tmp = fr_hash_update((void const   *)(& dval->attr), sizeof(dval->attr), hash);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_name_cmp___9(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;
  int tmp ;

  {
#line 201
  a = (DICT_VALUE const   *)one;
#line 202
  b = (DICT_VALUE const   *)two;
#line 204
  rcode = (int )(a->attr - b->attr);
#line 205
  if (rcode != 0) {
#line 205
    return (rcode);
  }
  {
#line 207
  tmp = strcasecmp((char const   *)(a->name), (char const   *)(b->name));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static uint32_t dict_value_value_hash___9(void const   *data ) 
{ 
  uint32_t hash ;
  DICT_VALUE const   *dval ;
  uint32_t tmp ;

  {
  {
#line 213
  dval = (DICT_VALUE const   *)data;
#line 215
  hash = fr_hash((void const   *)(& dval->attr), sizeof(dval->attr));
#line 216
  tmp = fr_hash_update((void const   *)(& dval->value), sizeof(dval->value), hash);
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_value_value_cmp___9(void const   *one , void const   *two ) 
{ 
  int rcode ;
  DICT_VALUE const   *a ;
  DICT_VALUE const   *b ;

  {
#line 222
  a = (DICT_VALUE const   *)one;
#line 223
  b = (DICT_VALUE const   *)two;
#line 225
  rcode = (int )(a->attr - b->attr);
#line 226
  if (rcode != 0) {
#line 226
    return (rcode);
  }
#line 228
  return ((int )(a->value - b->value));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_free___9(void) 
{ 
  dict_stat_t *this ;
  dict_stat_t *next ;

  {
  {
#line 239
  free((void *)stat_root_dir___9);
#line 240
  stat_root_dir___9 = (char *)((void *)0);
#line 241
  free((void *)stat_root_file___9);
#line 242
  stat_root_file___9 = (char *)((void *)0);
  }
#line 244
  if (! stat_head___9) {
#line 245
    stat_tail___9 = (dict_stat_t *)((void *)0);
#line 246
    return;
  }
#line 249
  this = stat_head___9;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    next = this->next;
#line 251
    free((void *)this->name);
#line 252
    free((void *)this);
#line 249
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  stat_tail___9 = (dict_stat_t *)((void *)0);
#line 255
  stat_head___9 = stat_tail___9;
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void dict_stat_add___9(char const   *name , struct stat  const  *stat_buf ) 
{ 
  dict_stat_t *this ;
  void *tmp ;

  {
  {
#line 266
  tmp = malloc(sizeof(*this));
#line 266
  this = (dict_stat_t *)tmp;
  }
#line 267
  if (! this) {
#line 267
    return;
  }
  {
#line 268
  memset((void *)this, 0, sizeof(*this));
#line 270
  this->name = strdup(name);
#line 271
  this->mtime = (time_t )stat_buf->st_mtim.tv_sec;
  }
#line 273
  if (! stat_head___9) {
#line 274
    stat_tail___9 = this;
#line 274
    stat_head___9 = stat_tail___9;
  } else {
#line 276
    stat_tail___9->next = this;
#line 277
    stat_tail___9 = this;
  }
#line 279
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int dict_stat_check___9(char const   *root_dir , char const   *root_file ) 
{ 
  struct stat buf ;
  dict_stat_t *this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 291
  if (! stat_root_dir___9) {
#line 291
    return (0);
  }
#line 292
  if (! stat_root_file___9) {
#line 292
    return (0);
  }
  {
#line 294
  tmp = strcmp(root_dir, (char const   *)stat_root_dir___9);
  }
#line 294
  if (tmp != 0) {
#line 294
    return (0);
  }
  {
#line 295
  tmp___0 = strcmp(root_file, (char const   *)stat_root_file___9);
  }
#line 295
  if (tmp___0 != 0) {
#line 295
    return (0);
  }
#line 297
  if (! stat_head___9) {
#line 297
    return (0);
  }
#line 299
  this = stat_head___9;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___1 = stat((char const   */* __restrict  */)this->name, (struct stat */* __restrict  */)(& buf));
    }
#line 300
    if (tmp___1 < 0) {
#line 300
      return (0);
    }
#line 302
    if (buf.st_mtim.tv_sec != this->mtime) {
#line 302
      return (0);
    }
#line 299
    this = this->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *dict_pool___9  =    (fr_pool_t *)((void *)0);
#line 320 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static fr_pool_t *fr_pool_create___9(void) 
{ 
  fr_pool_t *fp ;
  void *tmp ;

  {
  {
#line 322
  tmp = malloc((size_t )32768);
#line 322
  fp = (fr_pool_t *)tmp;
  }
#line 324
  if (! fp) {
#line 324
    return ((fr_pool_t *)((void *)0));
  }
  {
#line 326
  memset((void *)fp, 0, (size_t )32768);
#line 328
  fp->page_end = (void *)((uint8_t *)fp + 32768);
#line 329
  fp->free_ptr = (void *)((uint8_t *)fp + sizeof(*fp));
#line 330
  fp->page_free = fp;
#line 331
  fp->page_next = (struct fr_pool_t *)((void *)0);
  }
#line 332
  return (fp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_delete___9(fr_pool_t **pfp ) 
{ 
  fr_pool_t *fp ;
  fr_pool_t *next ;

  {
#line 339
  if (! pfp) {
#line 339
    return;
  } else
#line 339
  if (! *pfp) {
#line 339
    return;
  }
#line 341
  fp = *pfp;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 341
      goto while_break;
    }
    {
#line 342
    next = fp->page_next;
#line 343
    fp->page_next = (struct fr_pool_t *)((void *)0);
#line 344
    free((void *)fp);
#line 341
    fp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *pfp = (fr_pool_t *)((void *)0);
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void *fr_pool_alloc___9(size_t size ) 
{ 
  void *ptr ;

  {
#line 354
  if (size == 0UL) {
#line 354
    return ((void *)0);
  }
#line 356
  if (size > 256UL) {
#line 356
    return ((void *)0);
  }
#line 358
  if (! dict_pool___9) {
    {
#line 359
    dict_pool___9 = fr_pool_create___9();
    }
#line 360
    if (! dict_pool___9) {
#line 360
      return ((void *)0);
    }
  }
#line 363
  if ((size & 7UL) != 0UL) {
#line 364
    size += 8UL - (size & 7UL);
  }
#line 367
  if ((unsigned long )((uint8_t *)(dict_pool___9->page_free)->free_ptr + size) > (unsigned long )((uint8_t *)(dict_pool___9->page_free)->page_end)) {
    {
#line 368
    (dict_pool___9->page_free)->page_next = fr_pool_create___9();
    }
#line 369
    if (! (dict_pool___9->page_free)->page_next) {
#line 369
      return ((void *)0);
    }
#line 370
    dict_pool___9->page_free = (dict_pool___9->page_free)->page_next;
  }
#line 373
  ptr = (dict_pool___9->page_free)->free_ptr;
#line 374
  (dict_pool___9->page_free)->free_ptr = (void *)((uint8_t *)(dict_pool___9->page_free)->free_ptr + size);
#line 376
  return (ptr);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static void fr_pool_free___9(void *ptr  __attribute__((__unused__)) ) 
{ 


  {
#line 385
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int max_attr___9  =    0;
#line 533 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_VENDOR *last_vendor___9  =    (DICT_VENDOR *)((void *)0);
#line 670 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static DICT_ATTR *last_attr___9  =    (DICT_ATTR *)((void *)0);
#line 813 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int sscanf_i___9(char const   *str , int *pvalue ) 
{ 
  int rcode ;
  int base ;
  char const   *tab ;
  char const   *c ;
  int tmp ;
  void *tmp___0 ;

  {
#line 815
  rcode = 0;
#line 816
  base = 10;
#line 817
  tab = "0123456789";
#line 819
  if ((int const   )*(str + 0) == 48) {
#line 819
    if ((int const   )*(str + 1) == 120) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    } else
#line 819
    if ((int const   )*(str + 1) == 88) {
#line 821
      tab = "0123456789abcdef";
#line 822
      base = 16;
#line 824
      str += 2;
    }
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! *str) {
#line 827
      goto while_break;
    }
    {
#line 830
    tmp = tolower((int )*str);
#line 830
    tmp___0 = memchr((void const   *)tab, tmp, (size_t )base);
#line 830
    c = (char const   *)tmp___0;
    }
#line 831
    if (! c) {
#line 831
      return (0);
    }
#line 833
    rcode *= base;
#line 834
    rcode = (int )((long )rcode + (c - tab));
#line 835
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  *pvalue = rcode;
#line 839
  return (1);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_attribute___9(char const   *fn , int const   line , int const   block_vendor ,
                                 DICT_ATTR *block_tlv , char **argv , int argc ) 
{ 
  int vendor ;
  int value ;
  int type ;
  ATTR_FLAGS flags ;
  int tmp ;
  char *key ;
  char *next ;
  char *last ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char buffer[256] ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 850
  vendor = 0;
#line 855
  if (argc < 3) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  } else
#line 855
  if (argc > 4) {
    {
#line 856
    fr_strerror_printf("dict_init: %s[%d]: invalid ATTRIBUTE line", fn, line);
    }
#line 858
    return (-1);
  }
  {
#line 864
  tmp = sscanf_i___9((char const   *)*(argv + 1), & value);
  }
#line 864
  if (! tmp) {
    {
#line 865
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 866
    return (-1);
  }
  {
#line 872
  type = fr_str2int(type_table___9, (char const   *)*(argv + 2), -1);
  }
#line 873
  if (type < 0) {
    {
#line 874
    fr_strerror_printf("dict_init: %s[%d]: invalid type \"%s\"", fn, line, *(argv + 2));
    }
#line 876
    return (-1);
  }
  {
#line 883
  memset((void *)(& flags), 0, sizeof(flags));
  }
#line 884
  if (argc == 4) {
#line 887
    key = *(argv + 3);
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 889
      next = strchr((char const   *)key, ',');
      }
#line 890
      if (next) {
#line 890
        tmp___0 = next;
#line 890
        next ++;
#line 890
        *tmp___0 = (char )'\000';
      }
      {
#line 892
      tmp___4 = strcmp((char const   *)key, "has_tag");
      }
#line 892
      if (tmp___4 == 0) {
#line 896
        flags.has_tag = 1U;
      } else {
        {
#line 892
        tmp___5 = strcmp((char const   *)key, "has_tag=1");
        }
#line 892
        if (tmp___5 == 0) {
#line 896
          flags.has_tag = 1U;
        } else {
          {
#line 898
          tmp___3 = strncmp((char const   *)key, "encrypt=", (size_t )8);
          }
#line 898
          if (tmp___3 == 0) {
            {
#line 903
            tmp___1 = strtol((char const   */* __restrict  */)(key + 8), (char **/* __restrict  */)(& last),
                             0);
#line 903
            flags.encrypt = (uint8_t )tmp___1;
            }
#line 904
            if (*last) {
              {
#line 905
              fr_strerror_printf("dict_init: %s[%d] invalid option %s", fn, line,
                                 key);
              }
#line 907
              return (-1);
            }
          } else {
            {
#line 910
            tmp___2 = strncmp((char const   *)key, "array", (size_t )8);
            }
#line 910
            if (tmp___2 == 0) {
#line 911
              flags.array = 1U;
              {
#line 918
              if (type == 3) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 1) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 10) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 9) {
#line 918
                goto case_3;
              }
#line 918
              if (type == 2) {
#line 918
                goto case_3;
              }
#line 921
              goto switch_default;
              case_3: /* CIL Label */ 
              case_1: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 919
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 922
              fr_strerror_printf("dict_init: %s[%d] Only IP addresses can have the \"array\" flag set.",
                                 fn, line);
              }
#line 924
              return (-1);
              switch_break: /* CIL Label */ ;
              }
            } else
#line 931
            if ((unsigned long )key == (unsigned long )*(argv + 3)) {
#line 931
              if (! next) {
#line 931
                if (! block_vendor) {
                  {
#line 931
                  vendor = dict_vendorbyname((char const   *)key);
                  }
#line 931
                  if (vendor != 0) {
#line 933
                    goto while_break;
                  } else {
                    {
#line 936
                    fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"",
                                       fn, line, key);
                    }
#line 938
                    return (-1);
                  }
                } else {
                  {
#line 936
                  fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                     line, key);
                  }
#line 938
                  return (-1);
                }
              } else {
                {
#line 936
                fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn,
                                   line, key);
                }
#line 938
                return (-1);
              }
            } else {
              {
#line 936
              fr_strerror_printf("dict_init: %s[%d]: unknown option \"%s\"", fn, line,
                                 key);
              }
#line 938
              return (-1);
            }
          }
        }
      }
#line 941
      key = next;
#line 942
      if (key) {
#line 942
        if (! *key) {
#line 942
          goto while_break;
        }
      }
#line 888
      if (! key) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 946
  if (block_vendor) {
#line 946
    vendor = (int )block_vendor;
  }
#line 952
  if (flags.has_tag) {
    {
#line 958
    if (type == 1) {
#line 958
      goto case_1___0;
    }
#line 958
    if (type == 0) {
#line 958
      goto case_1___0;
    }
#line 961
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 962
    tmp___6 = fr_int2str(type_table___9, type, "?Unknown?");
#line 962
    fr_strerror_printf("dict_init: %s[%d]: Attributes of type %s cannot be tagged.",
                       fn, line, tmp___6);
    }
#line 965
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 970
  if (type == 14) {
#line 971
    flags.has_tlv = 1U;
  }
#line 974
  if (block_tlv) {
#line 978
    if (value <= 0) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    } else
#line 978
    if (value > 255) {
      {
#line 979
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot have value > 255",
                         fn, line);
      }
#line 981
      return (-1);
    }
#line 984
    if ((int )flags.encrypt != 0) {
      {
#line 985
      fr_strerror_printf("dict_init: %s[%d]: sub-tlv\'s cannot be encrypted", fn,
                         line);
      }
#line 987
      return (-1);
    }
#line 993
    value <<= 8;
#line 994
    value = (int )((unsigned int )value | (block_tlv->attr & 65535U));
#line 995
    flags.is_tlv = 1U;
  }
  {
#line 1013
  tmp___8 = dict_addattr((char const   *)*(argv + 0), vendor, type, value, flags);
  }
#line 1013
  if (tmp___8 < 0) {
    {
#line 1016
    tmp___7 = fr_strerror();
#line 1016
    strlcpy(buffer, tmp___7, sizeof(buffer));
#line 1018
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1020
    return (-1);
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value___9(char const   *fn , int const   line , char **argv , int argc ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  char buffer[256] ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1035
  if (argc != 3) {
    {
#line 1036
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE line", fn, line);
    }
#line 1038
    return (-1);
  }
  {
#line 1043
  tmp = strcasecmp((char const   *)*(argv + 0), "Server-Config");
  }
#line 1043
  if (tmp == 0) {
#line 1044
    return (0);
  }
  {
#line 1049
  tmp___0 = sscanf_i___9((char const   *)*(argv + 2), & value);
  }
#line 1049
  if (! tmp___0) {
    {
#line 1050
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = dict_addvalue((char const   *)*(argv + 1), (char const   *)*(argv + 0),
                          value);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1058
    tmp___1 = fr_strerror();
#line 1058
    strlcpy(buffer, tmp___1, sizeof(buffer));
#line 1060
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_value_alias___9(char const   *fn , int const   line , char **argv ,
                                   int argc ) 
{ 
  DICT_ATTR *my_da ;
  DICT_ATTR *da ;
  DICT_VALUE *dval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1081
  if (argc != 2) {
    {
#line 1082
    fr_strerror_printf("dict_init: %s[%d]: invalid VALUE-ALIAS line", fn, line);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  my_da = dict_attrbyname((char const   *)*(argv + 0));
  }
#line 1088
  if (! my_da) {
    {
#line 1089
    fr_strerror_printf("dict_init: %s[%d]: ATTRIBUTE \"%s\" does not exist", fn, line,
                       *(argv + 1));
    }
#line 1091
    return (-1);
  }
#line 1094
  if (my_da->flags.has_value) {
    {
#line 1095
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE",
                       fn, line, *(argv + 0));
    }
#line 1097
    return (-1);
  }
#line 1100
  if (my_da->flags.has_value_alias) {
    {
#line 1101
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" with pre-existing VALUE-ALIAS",
                       fn, line, *(argv + 0));
    }
#line 1103
    return (-1);
  }
  {
#line 1106
  da = dict_attrbyname((char const   *)*(argv + 1));
  }
#line 1107
  if (! da) {
    {
#line 1108
    fr_strerror_printf("dict_init: %s[%d]: Cannot find ATTRIBUTE \"%s\" for alias",
                       fn, line, *(argv + 1));
    }
#line 1110
    return (-1);
  }
#line 1113
  if (! da->flags.has_value) {
    {
#line 1114
    fr_strerror_printf("dict_init: %s[%d]: VALUE-ALIAS cannot refer to ATTRIBUTE %s: It has no values",
                       fn, line, *(argv + 1));
    }
#line 1116
    return (-1);
  }
#line 1119
  if (da->flags.has_value_alias) {
    {
#line 1120
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS to ATTRIBUTE \"%s\" which itself has a VALUE-ALIAS",
                       fn, line, *(argv + 1));
    }
#line 1122
    return (-1);
  }
#line 1125
  if (my_da->type != da->type) {
    {
#line 1126
    fr_strerror_printf("dict_init: %s[%d]: Cannot add VALUE-ALIAS between attributes of differing type",
                       fn, line);
    }
#line 1128
    return (-1);
  }
  {
#line 1131
  tmp = fr_pool_alloc___9(sizeof(*dval));
#line 1131
  dval = (DICT_VALUE *)tmp;
  }
#line 1131
  if ((unsigned long )dval == (unsigned long )((void *)0)) {
    {
#line 1132
    fr_strerror_printf("dict_addvalue: out of memory");
    }
#line 1133
    return (-1);
  }
  {
#line 1136
  dval->name[0] = (char )'\000';
#line 1137
  dval->attr = my_da->attr;
#line 1138
  dval->value = (int )da->attr;
#line 1140
  tmp___0 = fr_hash_table_insert(values_byname___9, (void *)dval);
  }
#line 1140
  if (! tmp___0) {
    {
#line 1141
    fr_strerror_printf("dict_init: %s[%d]: Error create alias", fn, line);
#line 1143
    fr_pool_free___9((void *)dval);
    }
#line 1144
    return (-1);
  }
#line 1147
  return (0);
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int process_vendor___9(char const   *fn , int const   line , char **argv ,
                              int argc ) 
{ 
  int value ;
  int continuation ;
  char const   *format ;
  unsigned short const   **tmp ;
  char buffer[256] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int type ;
  int length ;
  char const   *p ;
  DICT_VENDOR *dv ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1158
  continuation = 0;
#line 1159
  format = (char const   *)((void *)0);
#line 1161
  if (argc < 2) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  } else
#line 1161
  if (argc > 3) {
    {
#line 1162
    fr_strerror_printf("dict_init: %s[%d] invalid VENDOR entry", fn, line);
    }
#line 1164
    return (-1);
  }
  {
#line 1170
  tmp = __ctype_b_loc();
  }
#line 1170
  if (! ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048)) {
    {
#line 1171
    fr_strerror_printf("dict_init: %s[%d]: invalid value", fn, line);
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  value = atoi((char const   *)*(argv + 1));
#line 1178
  tmp___1 = dict_addvendor((char const   *)*(argv + 0), value);
  }
#line 1178
  if (tmp___1 < 0) {
    {
#line 1181
    tmp___0 = fr_strerror();
#line 1181
    strlcpy(buffer, tmp___0, sizeof(buffer));
#line 1183
    fr_strerror_printf("dict_init: %s[%d]: %s", fn, line, buffer);
    }
#line 1185
    return (-1);
  }
#line 1191
  if (argc == 3) {
#line 1192
    format = (char const   *)*(argv + 2);
  } else
#line 1194
  if (value == 429) {
#line 1195
    format = "format=4,0";
  } else
#line 1197
  if (value == 4846) {
#line 1198
    format = "format=2,1";
  } else
#line 1200
  if (value == 8164) {
#line 1201
    format = "format=2,2";
  }
#line 1205
  if (format) {
    {
#line 1210
    tmp___2 = strncasecmp(format, "format=", (size_t )7);
    }
#line 1210
    if (tmp___2 != 0) {
      {
#line 1211
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected \"format=\", got \"%s\"",
                         fn, line, format);
      }
#line 1213
      return (-1);
    }
    {
#line 1216
    p = format + 7;
#line 1217
    tmp___3 = strlen(p);
    }
#line 1217
    if (tmp___3 < 3UL) {
      {
#line 1222
      fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                         fn, line, p);
      }
#line 1224
      return (-1);
    } else {
      {
#line 1217
      tmp___4 = __ctype_b_loc();
      }
#line 1217
      if ((int const   )*(*tmp___4 + (int )*(p + 0)) & 2048) {
#line 1217
        if ((int const   )*(p + 1) != 44) {
          {
#line 1222
          fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                             fn, line, p);
          }
#line 1224
          return (-1);
        } else {
          {
#line 1217
          tmp___5 = __ctype_b_loc();
          }
#line 1217
          if ((int const   )*(*tmp___5 + (int )*(p + 2)) & 2048) {
#line 1217
            if (*(p + 3)) {
#line 1217
              if ((int const   )*(p + 3) != 44) {
                {
#line 1222
                fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                                   fn, line, p);
                }
#line 1224
                return (-1);
              }
            }
          } else {
            {
#line 1222
            fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                               fn, line, p);
            }
#line 1224
            return (-1);
          }
        }
      } else {
        {
#line 1222
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1224
        return (-1);
      }
    }
#line 1227
    type = (int )((int const   )*(p + 0) - 48);
#line 1228
    length = (int )((int const   )*(p + 2) - 48);
#line 1230
    if ((int const   )*(p + 3) == 44) {
#line 1231
      if ((int const   )*(p + 4) != 99) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      } else
#line 1231
      if ((int const   )*(p + 5) != 0) {
        {
#line 1233
        fr_strerror_printf("dict_init: %s[%d]: Invalid format for VENDOR.  Expected text like \"1,1\", got \"%s\"",
                           fn, line, p);
        }
#line 1235
        return (-1);
      }
#line 1237
      continuation = 1;
    }
    {
#line 1240
    dv = dict_vendorbyvalue(value);
    }
#line 1241
    if (! dv) {
      {
#line 1242
      fr_strerror_printf("dict_init: %s[%d]: Failed adding format for VENDOR", fn,
                         line);
      }
#line 1244
      return (-1);
    }
#line 1247
    if (type != 1) {
#line 1247
      if (type != 2) {
#line 1247
        if (type != 4) {
          {
#line 1248
          fr_strerror_printf("dict_init: %s[%d]: invalid type value %d for VENDOR",
                             fn, line, type);
          }
#line 1250
          return (-1);
        }
      }
    }
#line 1253
    if (length != 0) {
#line 1253
      if (length != 1) {
#line 1253
        if (length != 2) {
          {
#line 1254
          fr_strerror_printf("dict_init: %s[%d]: invalid length value %d for VENDOR",
                             fn, line, length);
          }
#line 1256
          return (-1);
        }
      }
    }
#line 1259
    dv->type = type;
#line 1260
    dv->length = length;
#line 1261
    dv->flags = continuation;
  }
#line 1264
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int str2argv___20(char *str , char **argv , int max_argc ) 
{ 
  int argc ;
  char *tmp ;

  {
#line 1273
  argc = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! *str) {
#line 1275
      goto while_break;
    }
#line 1276
    if (argc >= max_argc) {
#line 1276
      return (argc);
    }
#line 1281
    if ((int )*str == 35) {
#line 1282
      *str = (char )'\000';
#line 1283
      goto while_break;
    }
    {
#line 1286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((int )*str == 32)) {
#line 1286
        if (! ((int )*str == 9)) {
#line 1286
          if (! ((int )*str == 13)) {
#line 1286
            if (! ((int )*str == 10)) {
#line 1286
              goto while_break___0;
            }
          }
        }
      }
#line 1289
      tmp = str;
#line 1289
      str ++;
#line 1289
      *tmp = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if (! *str) {
#line 1291
      return (argc);
    }
#line 1293
    *(argv + argc) = str;
#line 1294
    argc ++;
    {
#line 1296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1296
      if (*str) {
#line 1296
        if ((int )*str != 32) {
#line 1296
          if ((int )*str != 9) {
#line 1296
            if ((int )*str != 13) {
#line 1296
              if (! ((int )*str != 10)) {
#line 1296
                goto while_break___1;
              }
            } else {
#line 1296
              goto while_break___1;
            }
          } else {
#line 1296
            goto while_break___1;
          }
        } else {
#line 1296
          goto while_break___1;
        }
      } else {
#line 1296
        goto while_break___1;
      }
#line 1300
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (argc);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int my_dict_init___9(char const   *dir , char const   *fn , char const   *src_file ,
                            int src_line ) 
{ 
  FILE *fp ;
  char dirtmp[256] ;
  char buf[256] ;
  char *p ;
  int line ;
  int vendor ;
  int block_vendor ;
  struct stat statbuf ;
  char *argv[16] ;
  int argc ;
  DICT_ATTR *da ;
  DICT_ATTR *block_tlv ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 1318
  line = 0;
#line 1324
  block_tlv = (DICT_ATTR *)((void *)0);
#line 1326
  tmp = strlen(fn);
  }
#line 1326
  if (tmp >= sizeof(dirtmp) / 2UL) {
    {
#line 1328
    fr_strerror_printf("dict_init: filename name too long");
    }
#line 1329
    return (-1);
  } else {
    {
#line 1326
    tmp___0 = strlen(dir);
    }
#line 1326
    if (tmp___0 >= sizeof(dirtmp) / 2UL) {
      {
#line 1328
      fr_strerror_printf("dict_init: filename name too long");
      }
#line 1329
      return (-1);
    }
  }
  {
#line 1336
  p = strrchr(fn, '/');
  }
#line 1336
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1337
    strcpy((char */* __restrict  */)(dirtmp), (char const   */* __restrict  */)fn);
#line 1338
    dirtmp[p - (char *)fn] = (char)0;
#line 1339
    dir = (char const   *)(dirtmp);
    }
  } else
#line 1340
  if (dir) {
#line 1340
    if (*(dir + 0)) {
      {
#line 1340
      tmp___1 = strcmp(dir, ".");
      }
#line 1340
      if (tmp___1 != 0) {
        {
#line 1341
        snprintf((char */* __restrict  */)(dirtmp), sizeof(dirtmp), (char const   */* __restrict  */)"%s/%s",
                 dir, fn);
#line 1342
        fn = (char const   *)(dirtmp);
        }
      }
    }
  }
  {
#line 1345
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 1345
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1346
    if (! src_file) {
      {
#line 1347
      tmp___2 = __errno_location();
#line 1347
      tmp___3 = strerror(*tmp___2);
#line 1347
      fr_strerror_printf("dict_init: Couldn\'t open dictionary \"%s\": %s", fn, tmp___3);
      }
    } else {
      {
#line 1350
      tmp___4 = __errno_location();
#line 1350
      tmp___5 = strerror(*tmp___4);
#line 1350
      fr_strerror_printf("dict_init: %s[%d]: Couldn\'t open dictionary \"%s\": %s",
                         src_file, src_line, fn, tmp___5);
      }
    }
#line 1353
    return (-1);
  }
  {
#line 1356
  stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1357
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 1358
    fclose(fp);
#line 1359
    fr_strerror_printf("dict_init: Dictionary \"%s\" is not a regular file", fn);
    }
#line 1361
    return (-1);
  }
#line 1369
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
    {
#line 1370
    fclose(fp);
#line 1371
    fr_strerror_printf("dict_init: Dictionary \"%s\" is globally writable.  Refusing to start due to insecure configuration.",
                       fn);
    }
#line 1373
    return (-1);
  }
  {
#line 1377
  dict_stat_add___9(fn, (struct stat  const  *)(& statbuf));
#line 1382
  fr_rand_seed((void const   *)(& statbuf), sizeof(statbuf));
#line 1384
  block_vendor = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1386
    tmp___20 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1386
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 1386
      goto while_break;
    }
#line 1387
    line ++;
#line 1388
    if ((int )buf[0] == 35) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 0) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 10) {
#line 1390
      goto while_continue;
    } else
#line 1388
    if ((int )buf[0] == 13) {
#line 1390
      goto while_continue;
    }
    {
#line 1396
    p = strchr((char const   *)(buf), '#');
    }
#line 1397
    if (p) {
#line 1397
      *p = (char )'\000';
    }
    {
#line 1399
    argc = str2argv___20(buf, argv, 16);
    }
#line 1400
    if (argc == 0) {
#line 1400
      goto while_continue;
    }
#line 1402
    if (argc == 1) {
      {
#line 1403
      fr_strerror_printf("dict_init: %s[%d] invalid entry", fn, line);
#line 1405
      fclose(fp);
      }
#line 1406
      return (-1);
    }
    {
#line 1412
    tmp___7 = strcasecmp((char const   *)argv[0], "VALUE");
    }
#line 1412
    if (tmp___7 == 0) {
      {
#line 1413
      tmp___6 = process_value___9(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1413
      if (tmp___6 == -1) {
        {
#line 1415
        fclose(fp);
        }
#line 1416
        return (-1);
      }
#line 1418
      goto while_continue;
    }
    {
#line 1424
    tmp___9 = strcasecmp((char const   *)argv[0], "ATTRIBUTE");
    }
#line 1424
    if (tmp___9 == 0) {
      {
#line 1425
      tmp___8 = process_attribute___9(fn, (int const   )line, (int const   )block_vendor,
                                      block_tlv, argv + 1, argc - 1);
      }
#line 1425
      if (tmp___8 == -1) {
        {
#line 1428
        fclose(fp);
        }
#line 1429
        return (-1);
      }
#line 1431
      goto while_continue;
    }
    {
#line 1437
    tmp___11 = strcasecmp((char const   *)argv[0], "$INCLUDE");
    }
#line 1437
    if (tmp___11 == 0) {
      {
#line 1438
      tmp___10 = my_dict_init___9(dir, (char const   *)argv[1], fn, line);
      }
#line 1438
      if (tmp___10 < 0) {
        {
#line 1439
        fclose(fp);
        }
#line 1440
        return (-1);
      }
#line 1442
      goto while_continue;
    }
    {
#line 1445
    tmp___13 = strcasecmp((char const   *)argv[0], "VALUE-ALIAS");
    }
#line 1445
    if (tmp___13 == 0) {
      {
#line 1446
      tmp___12 = process_value_alias___9(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1446
      if (tmp___12 == -1) {
        {
#line 1448
        fclose(fp);
        }
#line 1449
        return (-1);
      }
#line 1451
      goto while_continue;
    }
    {
#line 1457
    tmp___15 = strcasecmp((char const   *)argv[0], "VENDOR");
    }
#line 1457
    if (tmp___15 == 0) {
      {
#line 1458
      tmp___14 = process_vendor___9(fn, (int const   )line, argv + 1, argc - 1);
      }
#line 1458
      if (tmp___14 == -1) {
        {
#line 1460
        fclose(fp);
        }
#line 1461
        return (-1);
      }
#line 1463
      goto while_continue;
    }
    {
#line 1466
    tmp___16 = strcasecmp((char const   *)argv[0], "BEGIN-TLV");
    }
#line 1466
    if (tmp___16 == 0) {
#line 1467
      if (argc != 2) {
        {
#line 1468
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-TLV entry", fn, line);
#line 1471
        fclose(fp);
        }
#line 1472
        return (-1);
      }
      {
#line 1475
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1476
      if (! da) {
        {
#line 1477
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1480
        fclose(fp);
        }
#line 1481
        return (-1);
      }
#line 1484
      if (da->type != 14) {
        {
#line 1485
        fr_strerror_printf("dict_init: %s[%d]: attribute %s is not of type tlv", fn,
                           line, argv[1]);
#line 1488
        fclose(fp);
        }
#line 1489
        return (-1);
      }
#line 1492
      if (block_tlv) {
        {
#line 1493
        fr_strerror_printf("dict_init: %s[%d]: Cannot nest TLVs", fn, line);
#line 1496
        fclose(fp);
        }
#line 1497
        return (-1);
      }
#line 1500
      block_tlv = da;
#line 1501
      goto while_continue;
    }
    {
#line 1504
    tmp___17 = strcasecmp((char const   *)argv[0], "END-TLV");
    }
#line 1504
    if (tmp___17 == 0) {
#line 1505
      if (argc != 2) {
        {
#line 1506
        fr_strerror_printf("dict_init: %s[%d] invalid END-TLV entry", fn, line);
#line 1509
        fclose(fp);
        }
#line 1510
        return (-1);
      }
      {
#line 1513
      da = dict_attrbyname((char const   *)argv[1]);
      }
#line 1514
      if (! da) {
        {
#line 1515
        fr_strerror_printf("dict_init: %s[%d]: unknown attribute %s", fn, line, argv[1]);
#line 1518
        fclose(fp);
        }
#line 1519
        return (-1);
      }
#line 1522
      if ((unsigned long )da != (unsigned long )block_tlv) {
        {
#line 1523
        fr_strerror_printf("dict_init: %s[%d]: END-TLV %s does not match any previous BEGIN-TLV",
                           fn, line, argv[1]);
#line 1526
        fclose(fp);
        }
#line 1527
        return (-1);
      }
#line 1529
      block_tlv = (DICT_ATTR *)((void *)0);
#line 1530
      goto while_continue;
    }
    {
#line 1533
    tmp___18 = strcasecmp((char const   *)argv[0], "BEGIN-VENDOR");
    }
#line 1533
    if (tmp___18 == 0) {
#line 1534
      if (argc != 2) {
        {
#line 1535
        fr_strerror_printf("dict_init: %s[%d] invalid BEGIN-VENDOR entry", fn, line);
#line 1538
        fclose(fp);
        }
#line 1539
        return (-1);
      }
      {
#line 1542
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1543
      if (! vendor) {
        {
#line 1544
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1547
        fclose(fp);
        }
#line 1548
        return (-1);
      }
#line 1550
      block_vendor = vendor;
#line 1551
      goto while_continue;
    }
    {
#line 1554
    tmp___19 = strcasecmp((char const   *)argv[0], "END-VENDOR");
    }
#line 1554
    if (tmp___19 == 0) {
#line 1555
      if (argc != 2) {
        {
#line 1556
        fr_strerror_printf("dict_init: %s[%d] invalid END-VENDOR entry", fn, line);
#line 1559
        fclose(fp);
        }
#line 1560
        return (-1);
      }
      {
#line 1563
      vendor = dict_vendorbyname((char const   *)argv[1]);
      }
#line 1564
      if (! vendor) {
        {
#line 1565
        fr_strerror_printf("dict_init: %s[%d]: unknown vendor %s", fn, line, argv[1]);
#line 1568
        fclose(fp);
        }
#line 1569
        return (-1);
      }
#line 1572
      if (vendor != block_vendor) {
        {
#line 1573
        fr_strerror_printf("dict_init: %s[%d]: END-VENDOR %s does not match any previous BEGIN-VENDOR",
                           fn, line, argv[1]);
#line 1576
        fclose(fp);
        }
#line 1577
        return (-1);
      }
#line 1579
      block_vendor = 0;
#line 1580
      goto while_continue;
    }
    {
#line 1586
    fr_strerror_printf("dict_init: %s[%d] invalid keyword \"%s\"", fn, line, argv[0]);
#line 1588
    fclose(fp);
    }
#line 1589
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  fclose(fp);
  }
#line 1592
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/dict.c"
static int null_callback___9(void *ctx , void *data ) 
{ 


  {
#line 1601
  ctx = ctx;
#line 1602
  data = data;
#line 1604
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static char const   rcsid___308[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___266[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___286[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___266[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___266[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___277[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___266[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 26 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/heap.h"
static char const   rcsid_heap_h___20[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___9(fr_heap_t *hp , int child ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/heap.c"
static int fr_heap_bubble___9(fr_heap_t *hp , int child ) 
{ 
  int parent ;
  int tmp ;
  void *_tmp ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (child > 0)) {
#line 124
      goto while_break;
    }
    {
#line 125
    parent = (child - 1) / 2;
#line 130
    tmp = (*(hp->cmp))((void const   *)*(hp->p + parent), (void const   *)*(hp->p + child));
    }
#line 130
    if (tmp < 0) {
#line 130
      goto while_break;
    }
#line 135
    _tmp = *(hp->p + child);
#line 135
    *(hp->p + child) = *(hp->p + parent);
#line 135
    *(hp->p + parent) = _tmp;
#line 136
    if (hp->offset) {
#line 136
      *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
    }
#line 137
    child = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (hp->offset) {
#line 139
    *((int *)((uint8_t *)*(hp->p + child) + hp->offset)) = child;
  }
#line 141
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/sha1.c"
static char const   rcsid___309[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___267[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___287[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___267[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___267[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___278[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___267[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   rcsid___310[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___268[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___288[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___268[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___268[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___279[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___268[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   xdigits___9[17]  = 
#line 149 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 472 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/misc.c"
static char const   *hextab___20  =    "0123456789abcdef";
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcpy.c"
static char const   rcsid___311[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___289[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static char const   rcsid___312[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___269[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___290[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___269[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___269[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___280[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___269[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 329 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static fr_packet_socket_t *fr_socket_find___9(fr_packet_list_t *pl , int sockfd ) 
{ 
  int i ;
  int start ;

  {
#line 334
  start = sockfd * 16777619 & 31;
#line 334
  i = start;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (pl->sockets[i].sockfd == sockfd) {
#line 337
      return (& pl->sockets[i]);
    }
#line 339
    i = (i + 1) & 31;
#line 336
    if (! (i != start)) {
#line 336
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((fr_packet_socket_t *)((void *)0));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_entry_cmp___9(void const   *one , void const   *two ) 
{ 
  RADIUS_PACKET const   * const  *a ;
  RADIUS_PACKET const   * const  *b ;
  int tmp ;

  {
#line 437
  a = (RADIUS_PACKET const   * const  *)one;
#line 438
  b = (RADIUS_PACKET const   * const  *)two;
#line 440
  if (! a) {
#line 440
    return (-1);
  } else
#line 440
  if (! *a) {
#line 440
    return (-1);
  } else
#line 440
  if (! b) {
#line 440
    return (-1);
  } else
#line 440
  if (! *b) {
#line 440
    return (-1);
  }
  {
#line 442
  tmp = fr_packet_cmp((RADIUS_PACKET const   *)*a, (RADIUS_PACKET const   *)*b);
  }
#line 442
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static uint32_t packet_dst2id_hash___9(void const   *data ) 
{ 
  uint32_t hash ;
  fr_packet_dst2id_t const   *pd ;

  {
  {
#line 470
  pd = (fr_packet_dst2id_t const   *)data;
#line 472
  hash = fr_hash((void const   *)(& pd->dst_port), sizeof(pd->dst_port));
  }
  {
#line 475
  if (pd->dst_ipaddr.af == 2) {
#line 475
    goto case_2;
  }
#line 480
  if (pd->dst_ipaddr.af == 10) {
#line 480
    goto case_10;
  }
#line 485
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 476
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip4addr), sizeof(pd->dst_ipaddr.ipaddr.ip4addr),
                        hash);
  }
#line 479
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 481
  hash = fr_hash_update((void const   *)(& pd->dst_ipaddr.ipaddr.ip6addr), sizeof(pd->dst_ipaddr.ipaddr.ip6addr),
                        hash);
  }
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (hash);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static int packet_dst2id_cmp___9(void const   *one , void const   *two ) 
{ 
  fr_packet_dst2id_t const   *a ;
  fr_packet_dst2id_t const   *b ;
  int tmp ;

  {
#line 494
  a = (fr_packet_dst2id_t const   *)one;
#line 495
  b = (fr_packet_dst2id_t const   *)two;
#line 497
  if (a->dst_port < b->dst_port) {
#line 497
    return (-1);
  }
#line 498
  if (a->dst_port > b->dst_port) {
#line 498
    return (1);
  }
  {
#line 500
  tmp = fr_ipaddr_cmp(& a->dst_ipaddr, & b->dst_ipaddr);
  }
#line 500
  return (tmp);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/packet.c"
static void packet_dst2id_free___9(void *data ) 
{ 


  {
  {
#line 505
  free(data);
  }
#line 506
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static char const   rcsid___313[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___270[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___291[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___270[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___270[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___281[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___270[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t const   reversed_byte___9[256]  = 
#line 77 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
  {      (uint8_t const   )0,      (uint8_t const   )128,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )32,      (uint8_t const   )160,      (uint8_t const   )96,      (uint8_t const   )224, 
        (uint8_t const   )16,      (uint8_t const   )144,      (uint8_t const   )80,      (uint8_t const   )208, 
        (uint8_t const   )48,      (uint8_t const   )176,      (uint8_t const   )112,      (uint8_t const   )240, 
        (uint8_t const   )8,      (uint8_t const   )136,      (uint8_t const   )72,      (uint8_t const   )200, 
        (uint8_t const   )40,      (uint8_t const   )168,      (uint8_t const   )104,      (uint8_t const   )232, 
        (uint8_t const   )24,      (uint8_t const   )152,      (uint8_t const   )88,      (uint8_t const   )216, 
        (uint8_t const   )56,      (uint8_t const   )184,      (uint8_t const   )120,      (uint8_t const   )248, 
        (uint8_t const   )4,      (uint8_t const   )132,      (uint8_t const   )68,      (uint8_t const   )196, 
        (uint8_t const   )36,      (uint8_t const   )164,      (uint8_t const   )100,      (uint8_t const   )228, 
        (uint8_t const   )20,      (uint8_t const   )148,      (uint8_t const   )84,      (uint8_t const   )212, 
        (uint8_t const   )52,      (uint8_t const   )180,      (uint8_t const   )116,      (uint8_t const   )244, 
        (uint8_t const   )12,      (uint8_t const   )140,      (uint8_t const   )76,      (uint8_t const   )204, 
        (uint8_t const   )44,      (uint8_t const   )172,      (uint8_t const   )108,      (uint8_t const   )236, 
        (uint8_t const   )28,      (uint8_t const   )156,      (uint8_t const   )92,      (uint8_t const   )220, 
        (uint8_t const   )60,      (uint8_t const   )188,      (uint8_t const   )124,      (uint8_t const   )252, 
        (uint8_t const   )2,      (uint8_t const   )130,      (uint8_t const   )66,      (uint8_t const   )194, 
        (uint8_t const   )34,      (uint8_t const   )162,      (uint8_t const   )98,      (uint8_t const   )226, 
        (uint8_t const   )18,      (uint8_t const   )146,      (uint8_t const   )82,      (uint8_t const   )210, 
        (uint8_t const   )50,      (uint8_t const   )178,      (uint8_t const   )114,      (uint8_t const   )242, 
        (uint8_t const   )10,      (uint8_t const   )138,      (uint8_t const   )74,      (uint8_t const   )202, 
        (uint8_t const   )42,      (uint8_t const   )170,      (uint8_t const   )106,      (uint8_t const   )234, 
        (uint8_t const   )26,      (uint8_t const   )154,      (uint8_t const   )90,      (uint8_t const   )218, 
        (uint8_t const   )58,      (uint8_t const   )186,      (uint8_t const   )122,      (uint8_t const   )250, 
        (uint8_t const   )6,      (uint8_t const   )134,      (uint8_t const   )70,      (uint8_t const   )198, 
        (uint8_t const   )38,      (uint8_t const   )166,      (uint8_t const   )102,      (uint8_t const   )230, 
        (uint8_t const   )22,      (uint8_t const   )150,      (uint8_t const   )86,      (uint8_t const   )214, 
        (uint8_t const   )54,      (uint8_t const   )182,      (uint8_t const   )118,      (uint8_t const   )246, 
        (uint8_t const   )14,      (uint8_t const   )142,      (uint8_t const   )78,      (uint8_t const   )206, 
        (uint8_t const   )46,      (uint8_t const   )174,      (uint8_t const   )110,      (uint8_t const   )238, 
        (uint8_t const   )30,      (uint8_t const   )158,      (uint8_t const   )94,      (uint8_t const   )222, 
        (uint8_t const   )62,      (uint8_t const   )190,      (uint8_t const   )126,      (uint8_t const   )254, 
        (uint8_t const   )1,      (uint8_t const   )129,      (uint8_t const   )65,      (uint8_t const   )193, 
        (uint8_t const   )33,      (uint8_t const   )161,      (uint8_t const   )97,      (uint8_t const   )225, 
        (uint8_t const   )17,      (uint8_t const   )145,      (uint8_t const   )81,      (uint8_t const   )209, 
        (uint8_t const   )49,      (uint8_t const   )177,      (uint8_t const   )113,      (uint8_t const   )241, 
        (uint8_t const   )9,      (uint8_t const   )137,      (uint8_t const   )73,      (uint8_t const   )201, 
        (uint8_t const   )41,      (uint8_t const   )169,      (uint8_t const   )105,      (uint8_t const   )233, 
        (uint8_t const   )25,      (uint8_t const   )153,      (uint8_t const   )89,      (uint8_t const   )217, 
        (uint8_t const   )57,      (uint8_t const   )185,      (uint8_t const   )121,      (uint8_t const   )249, 
        (uint8_t const   )5,      (uint8_t const   )133,      (uint8_t const   )69,      (uint8_t const   )197, 
        (uint8_t const   )37,      (uint8_t const   )165,      (uint8_t const   )101,      (uint8_t const   )229, 
        (uint8_t const   )21,      (uint8_t const   )149,      (uint8_t const   )85,      (uint8_t const   )213, 
        (uint8_t const   )53,      (uint8_t const   )181,      (uint8_t const   )117,      (uint8_t const   )245, 
        (uint8_t const   )13,      (uint8_t const   )141,      (uint8_t const   )77,      (uint8_t const   )205, 
        (uint8_t const   )45,      (uint8_t const   )173,      (uint8_t const   )109,      (uint8_t const   )237, 
        (uint8_t const   )29,      (uint8_t const   )157,      (uint8_t const   )93,      (uint8_t const   )221, 
        (uint8_t const   )61,      (uint8_t const   )189,      (uint8_t const   )125,      (uint8_t const   )253, 
        (uint8_t const   )3,      (uint8_t const   )131,      (uint8_t const   )67,      (uint8_t const   )195, 
        (uint8_t const   )35,      (uint8_t const   )163,      (uint8_t const   )99,      (uint8_t const   )227, 
        (uint8_t const   )19,      (uint8_t const   )147,      (uint8_t const   )83,      (uint8_t const   )211, 
        (uint8_t const   )51,      (uint8_t const   )179,      (uint8_t const   )115,      (uint8_t const   )243, 
        (uint8_t const   )11,      (uint8_t const   )139,      (uint8_t const   )75,      (uint8_t const   )203, 
        (uint8_t const   )43,      (uint8_t const   )171,      (uint8_t const   )107,      (uint8_t const   )235, 
        (uint8_t const   )27,      (uint8_t const   )155,      (uint8_t const   )91,      (uint8_t const   )219, 
        (uint8_t const   )59,      (uint8_t const   )187,      (uint8_t const   )123,      (uint8_t const   )251, 
        (uint8_t const   )7,      (uint8_t const   )135,      (uint8_t const   )71,      (uint8_t const   )199, 
        (uint8_t const   )39,      (uint8_t const   )167,      (uint8_t const   )103,      (uint8_t const   )231, 
        (uint8_t const   )23,      (uint8_t const   )151,      (uint8_t const   )87,      (uint8_t const   )215, 
        (uint8_t const   )55,      (uint8_t const   )183,      (uint8_t const   )119,      (uint8_t const   )247, 
        (uint8_t const   )15,      (uint8_t const   )143,      (uint8_t const   )79,      (uint8_t const   )207, 
        (uint8_t const   )47,      (uint8_t const   )175,      (uint8_t const   )111,      (uint8_t const   )239, 
        (uint8_t const   )31,      (uint8_t const   )159,      (uint8_t const   )95,      (uint8_t const   )223, 
        (uint8_t const   )63,      (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255};
#line 116 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint8_t parent_byte___9[256]  = 
#line 116
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )11, 
        (uint8_t )12,      (uint8_t )13,      (uint8_t )14,      (uint8_t )15, 
        (uint8_t )16,      (uint8_t )17,      (uint8_t )18,      (uint8_t )19, 
        (uint8_t )20,      (uint8_t )21,      (uint8_t )22,      (uint8_t )23, 
        (uint8_t )24,      (uint8_t )25,      (uint8_t )26,      (uint8_t )27, 
        (uint8_t )28,      (uint8_t )29,      (uint8_t )30,      (uint8_t )31, 
        (uint8_t )32,      (uint8_t )33,      (uint8_t )34,      (uint8_t )35, 
        (uint8_t )36,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )47, 
        (uint8_t )48,      (uint8_t )49,      (uint8_t )50,      (uint8_t )51, 
        (uint8_t )52,      (uint8_t )53,      (uint8_t )54,      (uint8_t )55, 
        (uint8_t )56,      (uint8_t )57,      (uint8_t )58,      (uint8_t )59, 
        (uint8_t )60,      (uint8_t )61,      (uint8_t )62,      (uint8_t )63, 
        (uint8_t )64,      (uint8_t )65,      (uint8_t )66,      (uint8_t )67, 
        (uint8_t )68,      (uint8_t )69,      (uint8_t )70,      (uint8_t )71, 
        (uint8_t )72,      (uint8_t )73,      (uint8_t )74,      (uint8_t )75, 
        (uint8_t )76,      (uint8_t )77,      (uint8_t )78,      (uint8_t )79, 
        (uint8_t )80,      (uint8_t )81,      (uint8_t )82,      (uint8_t )83, 
        (uint8_t )84,      (uint8_t )85,      (uint8_t )86,      (uint8_t )87, 
        (uint8_t )88,      (uint8_t )89,      (uint8_t )90,      (uint8_t )91, 
        (uint8_t )92,      (uint8_t )93,      (uint8_t )94,      (uint8_t )95, 
        (uint8_t )96,      (uint8_t )97,      (uint8_t )98,      (uint8_t )99, 
        (uint8_t )100,      (uint8_t )101,      (uint8_t )102,      (uint8_t )103, 
        (uint8_t )104,      (uint8_t )105,      (uint8_t )106,      (uint8_t )107, 
        (uint8_t )108,      (uint8_t )109,      (uint8_t )110,      (uint8_t )111, 
        (uint8_t )112,      (uint8_t )113,      (uint8_t )114,      (uint8_t )115, 
        (uint8_t )116,      (uint8_t )117,      (uint8_t )118,      (uint8_t )119, 
        (uint8_t )120,      (uint8_t )121,      (uint8_t )122,      (uint8_t )123, 
        (uint8_t )124,      (uint8_t )125,      (uint8_t )126,      (uint8_t )127};
#line 155 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t reverse___9(uint32_t key ) 
{ 


  {
#line 157
  return ((uint32_t )(((((int const   )reversed_byte___9[key & 255U] << 24) | ((int const   )reversed_byte___9[(key >> 8) & 255U] << 16)) | ((int const   )reversed_byte___9[(key >> 16) & 255U] << 8)) | (int const   )reversed_byte___9[(key >> 24) & 255U]));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static uint32_t parent_of___9(uint32_t key ) 
{ 


  {
#line 168
  if (key > 16777215U) {
#line 169
    return ((key & 16777215U) | (unsigned int )((int )parent_byte___9[key >> 24] << 24));
  }
#line 171
  if (key > 65535U) {
#line 172
    return ((key & 65535U) | (unsigned int )((int )parent_byte___9[key >> 16] << 16));
  }
#line 174
  if (key > 255U) {
#line 175
    return ((key & 255U) | (unsigned int )((int )parent_byte___9[key >> 8] << 8));
  }
#line 177
  return ((uint32_t )parent_byte___9[key]);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *list_find___9(fr_hash_table_t *ht , fr_hash_entry_t *head ,
                                      uint32_t reversed , void const   *data ) 
{ 
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 188
  cur = head;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 188
      goto while_break;
    }
#line 189
    if (cur->reversed == reversed) {
#line 190
      if (ht->cmp) {
        {
#line 191
        tmp = (*(ht->cmp))(data, (void const   *)cur->data);
#line 191
        cmp = tmp;
        }
#line 192
        if (cmp > 0) {
#line 192
          goto while_break;
        }
#line 193
        if (cmp < 0) {
#line 193
          goto __Cont;
        }
      }
#line 195
      return (cur);
    }
#line 197
    if (cur->reversed > reversed) {
#line 197
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 188
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((fr_hash_entry_t *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_insert___9(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  int cmp ;
  int tmp ;

  {
#line 212
  last = head;
#line 214
  cur = *head;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 214
      goto while_break;
    }
#line 215
    if (cur->reversed > node->reversed) {
#line 215
      goto while_break;
    }
#line 216
    last = & cur->next;
#line 218
    if (cur->reversed == node->reversed) {
#line 219
      if (ht->cmp) {
        {
#line 220
        tmp = (*(ht->cmp))((void const   *)node->data, (void const   *)cur->data);
#line 220
        cmp = tmp;
        }
#line 221
        if (cmp > 0) {
#line 221
          goto while_break;
        }
#line 222
        if (cmp < 0) {
#line 222
          goto __Cont;
        }
      }
#line 224
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 214
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  node->next = *last;
#line 229
  *last = node;
#line 231
  return (1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static int list_delete___9(fr_hash_table_t *ht , fr_hash_entry_t **head , fr_hash_entry_t *node ) 
{ 
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;

  {
#line 243
  last = head;
#line 245
  cur = *head;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 245
      goto while_break;
    }
#line 246
    if ((unsigned long )cur == (unsigned long )node) {
#line 246
      goto while_break;
    }
#line 247
    last = & cur->next;
#line 245
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *last = node->next;
#line 251
  return (1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_fixup___9(fr_hash_table_t *ht , uint32_t entry ) 
{ 
  uint32_t parent_entry ;
  uint32_t tmp ;
  fr_hash_entry_t **last ;
  fr_hash_entry_t *cur ;
  uint32_t this ;
  uint32_t real_entry ;

  {
  {
#line 314
  tmp = parent_of___9(entry);
#line 314
  parent_entry = tmp;
#line 318
  parent_entry = parent_of___9(entry);
  }
#line 322
  if (! *(ht->buckets + parent_entry)) {
    {
#line 323
    fr_hash_table_fixup___9(ht, parent_entry);
    }
  }
#line 331
  last = ht->buckets + parent_entry;
#line 332
  this = parent_entry;
#line 334
  cur = *last;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )cur != (unsigned long )(& ht->null))) {
#line 334
      goto while_break;
    }
#line 337
    real_entry = cur->key & (unsigned int )ht->mask;
#line 338
    if (real_entry != this) {
#line 339
      *last = & ht->null;
#line 340
      *(ht->buckets + real_entry) = cur;
#line 341
      this = real_entry;
    }
#line 344
    last = & cur->next;
#line 334
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (! *(ht->buckets + entry)) {
#line 350
    *(ht->buckets + entry) = & ht->null;
  }
#line 351
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static void fr_hash_table_grow___9(fr_hash_table_t *ht ) 
{ 
  fr_hash_entry_t **buckets ;
  void *tmp ;

  {
  {
#line 366
  tmp = malloc((sizeof(*buckets) * 2UL) * (unsigned long )ht->num_buckets);
#line 366
  buckets = (fr_hash_entry_t **)tmp;
  }
#line 367
  if (! buckets) {
#line 367
    return;
  }
  {
#line 369
  memcpy((void */* __restrict  */)buckets, (void const   */* __restrict  */)ht->buckets,
         sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 371
  memset((void *)(buckets + ht->num_buckets), 0, sizeof(*buckets) * (unsigned long )ht->num_buckets);
#line 374
  free((void *)ht->buckets);
#line 375
  ht->buckets = buckets;
#line 376
  ht->num_buckets *= 2;
#line 377
  ht->next_grow *= 2;
#line 378
  ht->mask = ht->num_buckets - 1;
  }
#line 383
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/hash.c"
static fr_hash_entry_t *fr_hash_table_find___9(fr_hash_table_t *ht , void const   *data ) 
{ 
  uint32_t key ;
  uint32_t entry ;
  uint32_t reversed ;
  fr_hash_entry_t *tmp ;

  {
#line 446
  if (! ht) {
#line 446
    return ((fr_hash_entry_t *)((void *)0));
  }
  {
#line 448
  key = (*(ht->hash))(data);
#line 449
  entry = key & (unsigned int )ht->mask;
#line 450
  reversed = reverse___9(key);
  }
#line 452
  if (! *(ht->buckets + entry)) {
    {
#line 452
    fr_hash_table_fixup___9(ht, entry);
    }
  }
  {
#line 454
  tmp = list_find___9(ht, *(ht->buckets + entry), reversed, data);
  }
#line 454
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/strlcat.c"
static char const   rcsid___314[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___292[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 11 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static char const   rcsid___315[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___271[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___293[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___271[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___271[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___282[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___271[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/../include/md5.h"
static char const   rcsid_md5_h___31[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
static uint8_t const   PADDING___9[64]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/md5.c"
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 25 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/lib/missing.c"
static char const   rcsid___316[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/libradius.h"
static char const   rcsid_libradius_h___272[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/missing.h"
static char const   rcsid_missing_h___294[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/token.h"
static char const   rcsid_token_h___272[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/hash.h"
static char const   rcsid_hash_h___272[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 13 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/md4.h"
static char const   rcsid_md4_h___283[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/freeradius-2.1.12+dfsg/src/freeradius-devel/packet.h"
static char const   rcsid_packet_h___272[5]  __attribute__((__used__))  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
