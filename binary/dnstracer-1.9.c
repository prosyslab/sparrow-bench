/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_6 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_6 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_47 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_47 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 71 "/usr/include/resolv.h"
enum __anonenum_res_sendhookact_53 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 71 "/usr/include/resolv.h"
typedef enum __anonenum_res_sendhookact_53 res_sendhookact;
#line 104 "/usr/include/resolv.h"
struct __anonstruct_sort_list_54 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 104 "/usr/include/resolv.h"
struct __anonstruct__ext_56 {
   u_int16_t nscount ;
   u_int16_t nsmap[3] ;
   int nssocks[3] ;
   u_int16_t nscount6 ;
   u_int16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int _initstamp[2] ;
};
#line 104 "/usr/include/resolv.h"
union __anonunion__u_55 {
   char pad[52] ;
   struct __anonstruct__ext_56 _ext ;
};
#line 104 "/usr/include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   unsigned int ipv6_unavail : 1 ;
   unsigned int unused : 23 ;
   struct __anonstruct_sort_list_54 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr_in * const  *__ns , u_char const   **__query ,
                            int *__querylen , u_char *__ans , int __anssiz , int *__resplen ) ;
   res_sendhookact (*rhook)(struct sockaddr_in  const  *__ns , u_char const   *__query ,
                            int __querylen , u_char *__ans , int __anssiz , int *__resplen ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   union __anonunion__u_55 _u ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct arecord {
   char *server_name ;
   char *server_ip ;
   int type ;
   char *rr_name ;
   char *rr_data ;
   struct arecord *next ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct busy {
   char *server ;
   struct busy *next ;
};
#line 99 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct answer {
   char *server ;
   struct answer *next ;
};
#line 104
struct dnsheader;
#line 104
struct dnsquestion;
#line 104
struct dnsrr;
#line 104 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct dnssession {
   struct dnsheader *send_header ;
   struct dnsquestion *send_question ;
   struct dnsheader *recv_header ;
   struct dnsquestion *recv_question ;
   struct dnsrr *answer ;
   struct dnsrr *authority ;
   struct dnsrr *additional ;
   struct dnssession *next ;
   char *server ;
   char *host ;
   int recv_len ;
   char *recv_pkt ;
   char *recv_pkt_header ;
   char *recv_pkt_question ;
   char *recv_pkt_answer ;
   char *recv_pkt_authority ;
   char *recv_pkt_additional ;
   int socket ;
   int ipv6 ;
};
#line 129 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct bit {
   unsigned char rcode : 4 ;
   unsigned char zero : 3 ;
   unsigned char ra : 1 ;
   unsigned char rd : 1 ;
   unsigned char tc : 1 ;
   unsigned char aa : 1 ;
   unsigned char opcode : 4 ;
   unsigned char qr : 1 ;
};
#line 129 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
union __anonunion_flags_64 {
   unsigned short flags ;
   struct bit bit ;
};
#line 129 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct dnsheader {
   unsigned short identification ;
   union __anonunion_flags_64 flags ;
   unsigned short nquestions ;
   unsigned short nanswerRR ;
   unsigned short nauthorityRR ;
   unsigned short nadditionalRR ;
};
#line 161 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct dnsquestion {
   unsigned int querylength ;
   unsigned char *query ;
   unsigned short type ;
   unsigned short class ;
};
#line 168 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct dnsrr {
   unsigned char *domainname ;
   unsigned char *domainname_string ;
   unsigned short type ;
   unsigned short class ;
   unsigned int ttl ;
   unsigned short datalength ;
   unsigned char *data ;
   unsigned char *data_string ;
   struct dnsrr *next ;
};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 23 "./getopt.h"
extern char *optarg ;
#line 24
extern int optind ;
#line 28
extern int getopt(int argc , char **argv , char *optstring ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 155 "/usr/include/netdb.h"
extern struct hostent *gethostbyname2(char const   *__name , int __af ) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 249 "/usr/include/resolv.h"
extern struct __res_state *__res_state(void)  __attribute__((__const__)) ;
#line 273
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_init)(void) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 321
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int verbose  =    0;
#line 74 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int global_overview  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int global_retries  =    3;
#line 76 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int global_caching  =    1;
#line 77 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int global_negative_caching  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int global_querytype  =    1;
#line 79 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int global_noipv6  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int global_timeout  =    0;
#line 81 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
char *global_source_address  =    (char *)((void *)0);
#line 180 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
char *rr_types[256]  = 
#line 180
  {      (char *)"#0x00",      (char *)"a",      (char *)"ns",      (char *)"#0x03", 
        (char *)"#0x04",      (char *)"cname",      (char *)"soa",      (char *)"#0x07", 
        (char *)"#0x08",      (char *)"#0x09",      (char *)"#0x0a",      (char *)"#0x0b", 
        (char *)"#ptr",      (char *)"#hinfo",      (char *)"#0x0e",      (char *)"#mx", 
        (char *)"#txt",      (char *)"#0x11",      (char *)"#0x12",      (char *)"#0x13", 
        (char *)"#0x14",      (char *)"#0x15",      (char *)"#0x16",      (char *)"#0x17", 
        (char *)"#0x18",      (char *)"#0x19",      (char *)"#0x1a",      (char *)"#0x1b", 
        (char *)"#0x1c",      (char *)"#0x1d",      (char *)"#0x1e",      (char *)"#0x1f", 
        (char *)"#0x20",      (char *)"#0x21",      (char *)"#0x22",      (char *)"#0x23", 
        (char *)"#0x24",      (char *)"#0x25",      (char *)"#0x26",      (char *)"#0x27", 
        (char *)"#0x28",      (char *)"#0x29",      (char *)"#0x2a",      (char *)"#0x2b", 
        (char *)"#0x2c",      (char *)"#0x2d",      (char *)"#0x2e",      (char *)"#0x2f", 
        (char *)"#0x30",      (char *)"#0x31",      (char *)"#0x32",      (char *)"#0x33", 
        (char *)"#0x34",      (char *)"#0x35",      (char *)"#0x36",      (char *)"#0x37", 
        (char *)"#0x38",      (char *)"#0x39",      (char *)"#0x3a",      (char *)"#0x3b", 
        (char *)"#0x3c",      (char *)"#0x3d",      (char *)"#0x3e",      (char *)"#0x3f", 
        (char *)"#0x40",      (char *)"#0x41",      (char *)"#0x42",      (char *)"#0x43", 
        (char *)"#0x44",      (char *)"#0x45",      (char *)"#0x46",      (char *)"#0x47", 
        (char *)"#0x48",      (char *)"#0x49",      (char *)"#0x4a",      (char *)"#0x4b", 
        (char *)"#0x4c",      (char *)"#0x4d",      (char *)"#0x4e",      (char *)"#0x4f", 
        (char *)"#0x50",      (char *)"#0x51",      (char *)"#0x52",      (char *)"#0x53", 
        (char *)"#0x54",      (char *)"#0x55",      (char *)"#0x56",      (char *)"#0x57", 
        (char *)"#0x58",      (char *)"#0x59",      (char *)"#0x5a",      (char *)"#0x5b", 
        (char *)"#0x5c",      (char *)"#0x5d",      (char *)"#0x5e",      (char *)"#0x5f", 
        (char *)"#0x60",      (char *)"#0x61",      (char *)"#0x62",      (char *)"#0x63", 
        (char *)"#0x64",      (char *)"#0x65",      (char *)"#0x66",      (char *)"#0x67", 
        (char *)"#0x68",      (char *)"#0x69",      (char *)"#0x6a",      (char *)"#0x6b", 
        (char *)"#0x6c",      (char *)"#0x6d",      (char *)"#0x6e",      (char *)"#0x6f", 
        (char *)"#0x70",      (char *)"#0x71",      (char *)"#0x72",      (char *)"#0x73", 
        (char *)"#0x74",      (char *)"#0x75",      (char *)"#0x76",      (char *)"#0x77", 
        (char *)"#0x78",      (char *)"#0x79",      (char *)"#0x7a",      (char *)"#0x7b", 
        (char *)"#0x7c",      (char *)"#0x7d",      (char *)"#0x7e",      (char *)"#0x7f", 
        (char *)"#0x80",      (char *)"#0x81",      (char *)"#0x82",      (char *)"#0x83", 
        (char *)"#0x84",      (char *)"#0x85",      (char *)"#0x86",      (char *)"#0x87", 
        (char *)"#0x88",      (char *)"#0x89",      (char *)"#0x8a",      (char *)"#0x8b", 
        (char *)"#0x8c",      (char *)"#0x8d",      (char *)"#0x8e",      (char *)"#0x8f", 
        (char *)"#0x90",      (char *)"#0x91",      (char *)"#0x92",      (char *)"#0x93", 
        (char *)"#0x94",      (char *)"#0x95",      (char *)"#0x96",      (char *)"#0x97", 
        (char *)"#0x98",      (char *)"#0x99",      (char *)"#0x9a",      (char *)"#0x9b", 
        (char *)"#0x9c",      (char *)"#0x9d",      (char *)"#0x9e",      (char *)"#0x9f", 
        (char *)"#0xa0",      (char *)"#0xa1",      (char *)"#0xa2",      (char *)"#0xa3", 
        (char *)"#0xa4",      (char *)"#0xa5",      (char *)"#0xa6",      (char *)"#0xa7", 
        (char *)"#0xa8",      (char *)"#0xa9",      (char *)"#0xaa",      (char *)"#0xab", 
        (char *)"#0xac",      (char *)"#0xad",      (char *)"#0xae",      (char *)"#0xaf", 
        (char *)"#0xb0",      (char *)"#0xb1",      (char *)"#0xb2",      (char *)"#0xb3", 
        (char *)"#0xb4",      (char *)"#0xb5",      (char *)"#0xb6",      (char *)"#0xb7", 
        (char *)"#0xb8",      (char *)"#0xb9",      (char *)"#0xba",      (char *)"#0xbb", 
        (char *)"#0xbc",      (char *)"#0xbd",      (char *)"#0xbe",      (char *)"#0xbf", 
        (char *)"#0xc0",      (char *)"#0xc1",      (char *)"#0xc2",      (char *)"#0xc3", 
        (char *)"#0xc4",      (char *)"#0xc5",      (char *)"#0xc6",      (char *)"#0xc7", 
        (char *)"#0xc8",      (char *)"#0xc9",      (char *)"#0xca",      (char *)"#0xcb", 
        (char *)"#0xcc",      (char *)"#0xcd",      (char *)"#0xce",      (char *)"#0xcf", 
        (char *)"#0xd0",      (char *)"#0xd1",      (char *)"#0xd2",      (char *)"#0xd3", 
        (char *)"#0xd4",      (char *)"#0xd5",      (char *)"#0xd6",      (char *)"#0xd7", 
        (char *)"#0xd8",      (char *)"#0xd9",      (char *)"#0xda",      (char *)"#0xdb", 
        (char *)"#0xdc",      (char *)"#0xdd",      (char *)"#0xde",      (char *)"#0xdf", 
        (char *)"#0xe0",      (char *)"#0xe1",      (char *)"#0xe2",      (char *)"#0xe3", 
        (char *)"#0xe4",      (char *)"#0xe5",      (char *)"#0xe6",      (char *)"#0xe7", 
        (char *)"#0xe8",      (char *)"#0xe9",      (char *)"#0xea",      (char *)"#0xeb", 
        (char *)"#0xec",      (char *)"#0xed",      (char *)"#0xee",      (char *)"#0xef", 
        (char *)"#0xf0",      (char *)"#0xf1",      (char *)"#0xf2",      (char *)"#0xf3", 
        (char *)"#0xf4",      (char *)"#0xf5",      (char *)"#0xf6",      (char *)"#0xf7", 
        (char *)"#0xf8",      (char *)"#0xf9",      (char *)"#0xfa",      (char *)"#0xfb", 
        (char *)"#0xfc",      (char *)"#0xfd",      (char *)"#0xfe",      (char *)"#0xff"};
#line 217
char *get_resource(int type , struct dnssession *session , char *buffer , int dots ) ;
#line 218
char *printablename(char *name , int withdots ) ;
#line 226 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int strnrcasecmp(char const   *big , char const   *little , size_t len ) 
{ 
  char *p ;
  size_t lenl ;
  size_t lenb ;
  int tmp ;

  {
  {
#line 232
  lenl = strlen(little);
#line 233
  lenb = strlen(big);
  }
#line 235
  if (lenl > lenb) {
#line 236
    return (-1);
  }
#line 237
  if (len > lenl) {
#line 238
    return (-1);
  }
  {
#line 240
  p = ((char *)big + lenb) - len;
#line 241
  tmp = strncasecmp((char const   *)p, little, len);
  }
#line 241
  return (tmp);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
unsigned int getlong(unsigned char *s ) 
{ 


  {
#line 247
  return ((unsigned int )(((16777216 * (int )*(s + 0) + 65536 * (int )*(s + 1)) + 256 * (int )*(s + 2)) + (int )*(s + 3)));
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
unsigned short getshort(unsigned char *s ) 
{ 


  {
#line 253
  return ((unsigned short )(256 * (int )*(s + 0) + (int )*(s + 1)));
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
static char hostname[1025]  ;
#line 256 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
char *getname(struct dnssession *session , char **thisname ) 
{ 
  int compressing ;
  char *p ;
  unsigned int offset ;
  char oldp ;
  unsigned short tmp ;
  size_t tmp___0 ;

  {
#line 259
  compressing = 0;
#line 270
  if ((int )*(*(thisname + 0)) == 0) {
    {
#line 271
    strcpy((char */* __restrict  */)(hostname), (char const   */* __restrict  */)"\001.");
#line 272
    (*thisname) ++;
    }
#line 273
    return (hostname);
  }
  {
#line 276
  p = *thisname;
#line 277
  memset((void *)(hostname), 0, sizeof(hostname));
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! ((int )*(p + 0) != 0)) {
#line 278
      goto while_break;
    }
#line 285
    if (((int )*(p + 0) & 192) != 0) {
      {
#line 289
      oldp = *(p + 0);
#line 290
      *(p + 0) = (char )((int )*(p + 0) & 63);
#line 291
      tmp = getshort((unsigned char *)p);
#line 291
      offset = (unsigned int )tmp;
#line 292
      *(p + 0) = oldp;
#line 293
      p = session->recv_pkt + offset;
      }
#line 294
      if (compressing == 0) {
#line 294
        *thisname += 2;
      }
#line 296
      compressing = 1;
#line 297
      goto while_continue;
    }
    {
#line 308
    tmp___0 = strlen((char const   *)(hostname));
#line 308
    memcpy((void */* __restrict  */)(hostname + tmp___0), (void const   */* __restrict  */)p,
           (size_t )((int )*(p + 0) + 1));
    }
#line 309
    if (compressing == 0) {
#line 310
      *thisname += (int )*(p + 0) + 1;
#line 311
      if ((int )*(*(thisname + 0)) == 0) {
#line 311
        (*thisname) ++;
      }
    }
#line 313
    p += (int )*(p + 0) + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return (hostname);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
char *extract_rr(struct dnssession *session , char *thisrr , struct dnsrr **rr ) 
{ 
  struct dnsrr *RR ;
  char *domainname ;
  char *p ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 326
  tmp = calloc((size_t )1, sizeof(struct dnsrr ));
#line 326
  RR = (struct dnsrr *)tmp;
#line 327
  RR->next = *rr;
#line 334
  domainname = getname(session, & thisrr);
#line 335
  tmp___0 = strdup((char const   *)domainname);
#line 335
  RR->domainname = (unsigned char *)tmp___0;
#line 336
  tmp___1 = printablename(domainname, 1);
#line 336
  tmp___2 = strdup((char const   *)tmp___1);
#line 336
  RR->domainname_string = (unsigned char *)tmp___2;
#line 337
  RR->type = getshort((unsigned char *)thisrr);
#line 338
  RR->class = getshort((unsigned char *)(thisrr + 2));
#line 339
  RR->ttl = getlong((unsigned char *)(thisrr + 4));
#line 340
  RR->datalength = getshort((unsigned char *)(thisrr + 8));
#line 341
  tmp___3 = calloc((size_t )1, (size_t )RR->datalength);
#line 341
  RR->data = (unsigned char *)tmp___3;
#line 342
  memcpy((void */* __restrict  */)RR->data, (void const   */* __restrict  */)(thisrr + 10),
         (size_t )RR->datalength);
#line 344
  p = thisrr + 10;
#line 345
  tmp___4 = get_resource((int )RR->type, session, p, 1);
#line 345
  tmp___5 = strdup((char const   *)tmp___4);
#line 345
  RR->data_string = (unsigned char *)tmp___5;
#line 346
  thisrr += 10 + (int )RR->datalength;
#line 348
  *rr = RR;
  }
#line 349
  return (thisrr);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void extract_data(struct dnssession *session ) 
{ 
  struct dnsheader *header ;
  struct dnsquestion *question ;
  struct dnsrr *answer ;
  struct dnsrr *authority ;
  struct dnsrr *additional ;
  char *pheader ;
  char *pquestion ;
  char *panswer ;
  char *pauthority ;
  char *padditional ;
  char *pbuffer ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 355
  header = (struct dnsheader *)((void *)0);
#line 356
  question = (struct dnsquestion *)((void *)0);
#line 357
  answer = (struct dnsrr *)((void *)0);
#line 358
  authority = (struct dnsrr *)((void *)0);
#line 359
  additional = (struct dnsrr *)((void *)0);
#line 370
  pbuffer = session->recv_pkt;
#line 375
  session->recv_pkt_header = pbuffer;
#line 376
  pheader = pbuffer;
#line 377
  tmp = calloc((size_t )1, sizeof(struct dnsheader ));
#line 377
  header = (struct dnsheader *)tmp;
#line 378
  memcpy((void */* __restrict  */)header, (void const   */* __restrict  */)session->recv_pkt,
         sizeof(struct dnsheader ));
#line 379
  header->identification = ntohs(header->identification);
#line 380
  header->flags.flags = ntohs(header->flags.flags);
#line 381
  header->nquestions = ntohs(header->nquestions);
#line 382
  header->nanswerRR = ntohs(header->nanswerRR);
#line 383
  header->nauthorityRR = ntohs(header->nauthorityRR);
#line 384
  header->nadditionalRR = ntohs(header->nadditionalRR);
#line 385
  pbuffer += sizeof(struct dnsheader );
#line 390
  session->recv_pkt_question = pbuffer;
#line 391
  pquestion = pbuffer;
#line 392
  tmp___0 = calloc((size_t )1, sizeof(struct dnsquestion ));
#line 392
  question = (struct dnsquestion *)tmp___0;
#line 393
  tmp___1 = getname(session, & pquestion);
#line 393
  tmp___2 = strdup((char const   *)tmp___1);
#line 393
  question->query = (unsigned char *)tmp___2;
#line 394
  question->type = getshort((unsigned char *)pquestion);
#line 395
  question->class = getshort((unsigned char *)(pquestion + 2));
#line 396
  pbuffer = pquestion + 4;
#line 401
  session->recv_pkt_answer = pbuffer;
#line 402
  i = 0;
  }
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! (i < (int )header->nanswerRR)) {
#line 402
      goto while_break;
    }
    {
#line 403
    panswer = pbuffer;
#line 404
    pbuffer = extract_rr(session, panswer, & answer);
#line 402
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  session->recv_pkt_authority = pbuffer;
#line 411
  i = 0;
  {
#line 411
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 411
    if (! (i < (int )header->nauthorityRR)) {
#line 411
      goto while_break___0;
    }
    {
#line 412
    pauthority = pbuffer;
#line 413
    pbuffer = extract_rr(session, pauthority, & authority);
#line 411
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 419
  session->recv_pkt_additional = pbuffer;
#line 420
  i = 0;
  {
#line 420
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 420
    if (! (i < (int )header->nadditionalRR)) {
#line 420
      goto while_break___1;
    }
    {
#line 421
    padditional = pbuffer;
#line 422
    pbuffer = extract_rr(session, padditional, & additional);
#line 420
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 425
  session->recv_header = header;
#line 426
  session->recv_question = question;
#line 427
  session->answer = answer;
#line 428
  session->additional = additional;
#line 429
  session->authority = authority;
#line 430
  return;
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
static char hostname___0[1025]  ;
#line 438 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
char *printablename(char *name , int withdots ) 
{ 
  char *p ;
  char q ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 448
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 448
    goto _L;
  } else
#line 448
  if ((int )*(name + 0) == 0) {
    _L: /* CIL Label */ 
#line 449
    if (withdots == 0) {
      {
#line 450
      strcpy((char */* __restrict  */)(hostname___0), (char const   */* __restrict  */)"(0)root");
      }
    } else {
      {
#line 452
      strcpy((char */* __restrict  */)(hostname___0), (char const   */* __restrict  */)".");
      }
    }
#line 453
    return (hostname___0);
  }
#line 456
  hostname___0[0] = (char)0;
#line 457
  p = name;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! ((int )*(p + 0) != 0)) {
#line 458
      goto while_break;
    }
#line 459
    if (withdots == 0) {
      {
#line 460
      tmp = strlen((char const   *)(hostname___0));
#line 460
      sprintf((char */* __restrict  */)(hostname___0 + tmp), (char const   */* __restrict  */)"(%d)",
              (int )*(p + 0));
      }
    } else {
      {
#line 462
      strcat((char */* __restrict  */)(hostname___0), (char const   */* __restrict  */)".");
      }
    }
    {
#line 463
    q = *(p + ((int )*(p + 0) + 1));
#line 464
    *(p + ((int )*(p + 0) + 1)) = (char)0;
#line 465
    tmp___0 = strlen((char const   *)(hostname___0));
#line 465
    sprintf((char */* __restrict  */)(hostname___0 + tmp___0), (char const   */* __restrict  */)"%s",
            p + 1);
#line 466
    p = (p + (int )*(p + 0)) + 1;
#line 467
    *(p + 0) = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  if (withdots == 0) {
#line 471
    return (hostname___0);
  } else {
#line 473
    return (hostname___0 + 1);
  }
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
char *get_class(int class ) 
{ 


  {
  {
#line 480
  if (class == 1) {
#line 480
    goto case_1;
  }
#line 481
  if (class == 3) {
#line 481
    goto case_3;
  }
#line 482
  if (class == 4) {
#line 482
    goto case_4;
  }
#line 483
  if (class == 254) {
#line 483
    goto case_254;
  }
#line 484
  if (class == 255) {
#line 484
    goto case_255;
  }
#line 485
  goto switch_default;
  case_1: /* CIL Label */ 
#line 480
  return ((char *)"Internet");
  case_3: /* CIL Label */ 
#line 481
  return ((char *)"MIT Chaos-net");
  case_4: /* CIL Label */ 
#line 482
  return ((char *)"MIT Hesiod");
  case_254: /* CIL Label */ 
#line 483
  return ((char *)"Pre-req in update");
  case_255: /* CIL Label */ 
#line 484
  return ((char *)"Wildcard");
  switch_default: /* CIL Label */ 
#line 485
  return ((char *)"unknown");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
char *get_type(int type ) 
{ 


  {
  {
#line 493
  if (type == 1) {
#line 493
    goto case_1;
  }
#line 494
  if (type == 2) {
#line 494
    goto case_2;
  }
#line 495
  if (type == 5) {
#line 495
    goto case_5;
  }
#line 496
  if (type == 6) {
#line 496
    goto case_6;
  }
#line 497
  if (type == 12) {
#line 497
    goto case_12;
  }
#line 498
  goto switch_default;
  case_1: /* CIL Label */ 
#line 493
  return ((char *)"A");
  case_2: /* CIL Label */ 
#line 494
  return ((char *)"NS");
  case_5: /* CIL Label */ 
#line 495
  return ((char *)"CNAME");
  case_6: /* CIL Label */ 
#line 496
  return ((char *)"SOA");
  case_12: /* CIL Label */ 
#line 497
  return ((char *)"PTR");
  switch_default: /* CIL Label */ 
#line 498
  return ((char *)"unknown");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
static char retval[1025]  ;
#line 502 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
char *get_ttl(int ttl ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 511
  retval[0] = (char)0;
#line 512
  if (ttl > 604800) {
    {
#line 513
    sprintf((char */* __restrict  */)(retval), (char const   */* __restrict  */)"%dw",
            ttl / 604800);
#line 514
    ttl %= 604800;
    }
  }
#line 516
  if (ttl > 86400) {
    {
#line 517
    tmp = strlen((char const   *)(retval));
#line 517
    sprintf((char */* __restrict  */)(retval + tmp), (char const   */* __restrict  */)"%dd",
            ttl / 86400);
#line 518
    ttl %= 86400;
    }
  }
#line 520
  if (ttl > 3600) {
    {
#line 521
    tmp___0 = strlen((char const   *)(retval));
#line 521
    sprintf((char */* __restrict  */)(retval + tmp___0), (char const   */* __restrict  */)"%dh",
            ttl / 3600);
#line 522
    ttl %= 3600;
    }
  }
#line 524
  if (ttl > 60) {
    {
#line 525
    tmp___1 = strlen((char const   *)(retval));
#line 525
    sprintf((char */* __restrict  */)(retval + tmp___1), (char const   */* __restrict  */)"%dm",
            ttl / 60);
#line 526
    ttl %= 60;
    }
  }
#line 528
  if (ttl > 0) {
    {
#line 529
    tmp___2 = strlen((char const   *)(retval));
#line 529
    sprintf((char */* __restrict  */)(retval + tmp___2), (char const   */* __restrict  */)"%ds",
            ttl);
    }
  }
#line 532
  return (retval);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
static char retval___0[1025]  ;
#line 601 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
static char retval___1[3075]  ;
#line 535 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
char *get_resource(int type , struct dnssession *session , char *buffer , int dots ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short us ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char mname[1025] ;
  char rname[1025] ;
  unsigned long ul ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned int tmp___15 ;

  {
  {
#line 546
  if (type == 1) {
#line 546
    goto case_1;
  }
#line 554
  if (type == 28) {
#line 554
    goto case_28;
  }
#line 569
  if (type == 5) {
#line 569
    goto case_5;
  }
#line 573
  if (type == 16) {
#line 573
    goto case_16;
  }
#line 577
  if (type == 15) {
#line 577
    goto case_15;
  }
#line 587
  if (type == 13) {
#line 587
    goto case_13;
  }
#line 591
  if (type == 2) {
#line 591
    goto case_2;
  }
#line 595
  if (type == 12) {
#line 595
    goto case_12;
  }
#line 599
  if (type == 6) {
#line 599
    goto case_6;
  }
#line 614
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 547
  sprintf((char */* __restrict  */)(retval___0), (char const   */* __restrict  */)"%hu.%hu.%hu.%hu",
          (int )((unsigned char )*(buffer + 0)), (int )((unsigned char )*(buffer + 1)),
          (int )((unsigned char )*(buffer + 2)), (int )((unsigned char )*(buffer + 3)));
  }
#line 552
  return (retval___0);
  case_28: /* CIL Label */ 
  {
#line 555
  sprintf((char */* __restrict  */)(retval___0), (char const   */* __restrict  */)"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
          (int )((unsigned char )*(buffer + 0)), (int )((unsigned char )*(buffer + 1)),
          (int )((unsigned char )*(buffer + 2)), (int )((unsigned char )*(buffer + 3)),
          (int )((unsigned char )*(buffer + 4)), (int )((unsigned char )*(buffer + 5)),
          (int )((unsigned char )*(buffer + 6)), (int )((unsigned char )*(buffer + 7)),
          (int )((unsigned char )*(buffer + 8)), (int )((unsigned char )*(buffer + 9)),
          (int )((unsigned char )*(buffer + 10)), (int )((unsigned char )*(buffer + 11)),
          (int )((unsigned char )*(buffer + 12)), (int )((unsigned char )*(buffer + 13)),
          (int )((unsigned char )*(buffer + 14)), (int )((unsigned char )*(buffer + 15)));
  }
#line 567
  return (retval___0);
  case_5: /* CIL Label */ 
  {
#line 570
  tmp = getname(session, & buffer);
#line 570
  tmp___0 = printablename(tmp, dots);
#line 570
  strcpy((char */* __restrict  */)(retval___0), (char const   */* __restrict  */)tmp___0);
  }
#line 571
  return (retval___0);
  case_16: /* CIL Label */ 
  {
#line 574
  tmp___1 = getname(session, & buffer);
#line 574
  tmp___2 = printablename(tmp___1, dots);
#line 574
  strcpy((char */* __restrict  */)(retval___0), (char const   */* __restrict  */)tmp___2);
  }
#line 575
  return (retval___0);
  case_15: /* CIL Label */ 
  {
#line 581
  us = getshort((unsigned char *)buffer);
#line 582
  buffer += 2;
#line 583
  tmp___3 = getname(session, & buffer);
#line 583
  tmp___4 = printablename(tmp___3, dots);
#line 583
  sprintf((char */* __restrict  */)(retval___0), (char const   */* __restrict  */)"%hu %s",
          (int )us, tmp___4);
  }
#line 584
  return (retval___0);
  case_13: /* CIL Label */ 
  {
#line 588
  tmp___5 = getname(session, & buffer);
#line 588
  tmp___6 = printablename(tmp___5, dots);
#line 588
  strcpy((char */* __restrict  */)(retval___0), (char const   */* __restrict  */)tmp___6);
  }
#line 589
  return (retval___0);
  case_2: /* CIL Label */ 
  {
#line 592
  tmp___7 = getname(session, & buffer);
#line 592
  tmp___8 = printablename(tmp___7, dots);
#line 592
  strcpy((char */* __restrict  */)(retval___0), (char const   */* __restrict  */)tmp___8);
  }
#line 593
  return (retval___0);
  case_12: /* CIL Label */ 
  {
#line 596
  tmp___9 = getname(session, & buffer);
#line 596
  tmp___10 = printablename(tmp___9, dots);
#line 596
  strcpy((char */* __restrict  */)(retval___0), (char const   */* __restrict  */)tmp___10);
  }
#line 597
  return (retval___0);
  case_6: /* CIL Label */ 
  {
#line 606
  tmp___11 = getname(session, & buffer);
#line 606
  tmp___12 = printablename(tmp___11, dots);
#line 606
  strcpy((char */* __restrict  */)(mname), (char const   */* __restrict  */)tmp___12);
#line 607
  tmp___13 = getname(session, & buffer);
#line 607
  tmp___14 = printablename(tmp___13, dots);
#line 607
  strcpy((char */* __restrict  */)(rname), (char const   */* __restrict  */)tmp___14);
#line 609
  tmp___15 = getlong((unsigned char *)buffer);
#line 609
  ul = (unsigned long )tmp___15;
#line 610
  sprintf((char */* __restrict  */)(retval___1), (char const   */* __restrict  */)"serial: %ld mname: %s rname: %s",
          ul, mname, rname);
  }
#line 611
  return (retval___1);
  switch_default: /* CIL Label */ 
#line 614
  return ((char *)"unknown");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void dump_question(struct dnsquestion *question ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 622
  tmp = printablename((char *)question->query, 0);
#line 622
  printf((char const   */* __restrict  */)"- Queryname:            %s\n", tmp);
#line 623
  tmp___0 = get_type((int )question->type);
#line 623
  printf((char const   */* __restrict  */)"- Type:                 %hu (%s)\n", (int )question->type,
         tmp___0);
#line 625
  tmp___1 = get_class((int )question->class);
#line 625
  printf((char const   */* __restrict  */)"- Class:                %hu (%s)\n", (int )question->class,
         tmp___1);
  }
#line 627
  return;
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void dump_header(struct dnsheader *header ) 
{ 


  {
  {
#line 632
  printf((char const   */* __restrict  */)"- Identifier:           0x%04hX\n", (int )header->identification);
#line 633
  printf((char const   */* __restrict  */)"- Flags:                0x%02hX (", (int )header->flags.flags);
  }
#line 635
  if (header->flags.bit.qr) {
    {
#line 635
    printf((char const   */* __restrict  */)"R ");
    }
  } else {
    {
#line 635
    printf((char const   */* __restrict  */)"Q ");
    }
  }
#line 636
  if (header->flags.bit.aa) {
    {
#line 636
    printf((char const   */* __restrict  */)"AA ");
    }
  }
#line 637
  if (header->flags.bit.tc) {
    {
#line 637
    printf((char const   */* __restrict  */)"TC ");
    }
  }
#line 638
  if (header->flags.bit.rd) {
    {
#line 638
    printf((char const   */* __restrict  */)"RD ");
    }
  }
#line 639
  if (header->flags.bit.ra) {
    {
#line 639
    printf((char const   */* __restrict  */)"RA ");
    }
  }
  {
#line 640
  printf((char const   */* __restrict  */)")\n");
#line 642
  printf((char const   */* __restrict  */)"- Opcode:               %hu ", (int )header->flags.bit.opcode);
  }
  {
#line 644
  if ((int )header->flags.bit.opcode == 0) {
#line 644
    goto case_0;
  }
#line 645
  if ((int )header->flags.bit.opcode == 1) {
#line 645
    goto case_1;
  }
#line 646
  if ((int )header->flags.bit.opcode == 2) {
#line 646
    goto case_2;
  }
#line 647
  if ((int )header->flags.bit.opcode == 4) {
#line 647
    goto case_4;
  }
#line 648
  if ((int )header->flags.bit.opcode == 5) {
#line 648
    goto case_5;
  }
#line 649
  if ((int )header->flags.bit.opcode == 14) {
#line 649
    goto case_14;
  }
#line 650
  if ((int )header->flags.bit.opcode == 15) {
#line 650
    goto case_15;
  }
#line 651
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 644
  printf((char const   */* __restrict  */)"(Standard query)\n");
  }
#line 644
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 645
  printf((char const   */* __restrict  */)"(Inverse query)\n");
  }
#line 645
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 646
  printf((char const   */* __restrict  */)"(Server status request)\n");
  }
#line 646
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 647
  printf((char const   */* __restrict  */)"(Notify)\n");
  }
#line 647
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 648
  printf((char const   */* __restrict  */)"(Update)\n");
  }
#line 648
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 649
  printf((char const   */* __restrict  */)"(Zone init)\n");
  }
#line 649
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 650
  printf((char const   */* __restrict  */)"(Zone Ref)\n");
  }
#line 650
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 651
  printf((char const   */* __restrict  */)"(unknown)\n");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 654
  printf((char const   */* __restrict  */)"- Return code:          %hu ", (int )header->flags.bit.rcode);
  }
  {
#line 656
  if ((int )header->flags.bit.rcode == 0) {
#line 656
    goto case_0___0;
  }
#line 657
  if ((int )header->flags.bit.rcode == 1) {
#line 657
    goto case_1___0;
  }
#line 658
  if ((int )header->flags.bit.rcode == 2) {
#line 658
    goto case_2___0;
  }
#line 659
  if ((int )header->flags.bit.rcode == 3) {
#line 659
    goto case_3;
  }
#line 660
  if ((int )header->flags.bit.rcode == 4) {
#line 660
    goto case_4___0;
  }
#line 661
  if ((int )header->flags.bit.rcode == 5) {
#line 661
    goto case_5___0;
  }
#line 662
  if ((int )header->flags.bit.rcode == 6) {
#line 662
    goto case_6;
  }
#line 663
  if ((int )header->flags.bit.rcode == 7) {
#line 663
    goto case_7;
  }
#line 664
  if ((int )header->flags.bit.rcode == 8) {
#line 664
    goto case_8;
  }
#line 665
  if ((int )header->flags.bit.rcode == 9) {
#line 665
    goto case_9;
  }
#line 666
  if ((int )header->flags.bit.rcode == 10) {
#line 666
    goto case_10;
  }
#line 667
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 656
  printf((char const   */* __restrict  */)"(No error)\n");
  }
#line 656
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 657
  printf((char const   */* __restrict  */)"(Format error)\n");
  }
#line 657
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 658
  printf((char const   */* __restrict  */)"(Server failure)\n");
  }
#line 658
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 659
  printf((char const   */* __restrict  */)"(Name error)\n");
  }
#line 659
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 660
  printf((char const   */* __restrict  */)"(Not implemented)\n");
  }
#line 660
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
  {
#line 661
  printf((char const   */* __restrict  */)"(Refused)\n");
  }
#line 661
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 662
  printf((char const   */* __restrict  */)"(Name exists)\n");
  }
#line 662
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 663
  printf((char const   */* __restrict  */)"(RRset exists)\n");
  }
#line 663
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 664
  printf((char const   */* __restrict  */)"(RRset does not exist)\n");
  }
#line 664
  goto switch_break___0;
  case_9: /* CIL Label */ 
  {
#line 665
  printf((char const   */* __restrict  */)"(Not authoritive)\n");
  }
#line 665
  goto switch_break___0;
  case_10: /* CIL Label */ 
  {
#line 666
  printf((char const   */* __restrict  */)"(Zone of record different from zone section)\n");
  }
#line 666
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 667
  printf((char const   */* __restrict  */)"(unknown)\n");
  }
#line 667
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 670
  printf((char const   */* __restrict  */)"- Number questions:     %hu\n", (int )header->nquestions);
#line 671
  printf((char const   */* __restrict  */)"- Number answer RR:     %hu\n", (int )header->nanswerRR);
#line 672
  printf((char const   */* __restrict  */)"- Number authority RR:  %hu\n", (int )header->nauthorityRR);
#line 673
  printf((char const   */* __restrict  */)"- Number additional RR: %hu\n", (int )header->nadditionalRR);
  }
#line 674
  return;
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void dump_rr(struct dnsrr *rr , struct dnssession *session ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 679
  tmp = printablename((char *)rr->domainname, 0);
#line 679
  printf((char const   */* __restrict  */)"- Domainname:           %s\n", tmp);
#line 680
  tmp___0 = get_type((int )rr->type);
#line 680
  printf((char const   */* __restrict  */)"- Type:                 %hu (%s)\n", (int )rr->type,
         tmp___0);
#line 682
  tmp___1 = get_class((int )rr->class);
#line 682
  printf((char const   */* __restrict  */)"- Class:                %hu (%s)\n", (int )rr->class,
         tmp___1);
#line 684
  tmp___2 = get_ttl((int )rr->ttl);
#line 684
  printf((char const   */* __restrict  */)"- TTL:                  %u (%s)\n", rr->ttl,
         tmp___2);
#line 686
  printf((char const   */* __restrict  */)"- Resource length:      %hu\n", (int )rr->datalength);
#line 687
  tmp___3 = get_resource((int )rr->type, session, (char *)rr->data, 0);
#line 687
  printf((char const   */* __restrict  */)"- Resource data:        %s\n", tmp___3);
  }
#line 689
  return;
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void dump_data(struct sockaddr_in *dest4 , struct sockaddr_in6 *dest6 , struct dnssession *session ) 
{ 
  struct dnsrr *answerrr ;
  struct dnsrr *authorityrr ;
  struct dnsrr *additionalrr ;
  char *tmp ;

  {
#line 698
  if (verbose == 0) {
#line 698
    return;
  }
#line 704
  if ((unsigned long )dest4 != (unsigned long )((void *)0)) {
    {
#line 705
    printf((char const   */* __restrict  */)"IP HEADER\n");
#line 706
    tmp = inet_ntoa(dest4->sin_addr);
#line 706
    printf((char const   */* __restrict  */)"- Destination address:  %s\n", tmp);
    }
  }
#line 708
  if ((unsigned long )dest6 != (unsigned long )((void *)0)) {
    {
#line 709
    printf((char const   */* __restrict  */)"IP HEADER\n");
#line 710
    printf((char const   */* __restrict  */)"- Destination address:  %s\n", "XXX");
    }
  }
#line 713
  if ((unsigned long )session->send_header != (unsigned long )((void *)0)) {
#line 713
    if ((unsigned long )session->recv_header == (unsigned long )((void *)0)) {
      {
#line 714
      printf((char const   */* __restrict  */)"DNS HEADER (send)\n");
#line 715
      dump_header(session->send_header);
      }
    }
  }
#line 718
  if ((unsigned long )session->recv_header != (unsigned long )((void *)0)) {
    {
#line 719
    printf((char const   */* __restrict  */)"DNS HEADER (recv)\n");
#line 720
    dump_header(session->recv_header);
    }
  }
#line 723
  if ((unsigned long )session->send_question != (unsigned long )((void *)0)) {
#line 723
    if ((unsigned long )session->recv_question == (unsigned long )((void *)0)) {
      {
#line 724
      printf((char const   */* __restrict  */)"QUESTIONS (send)\n");
#line 725
      dump_question(session->send_question);
      }
    }
  }
#line 727
  if ((unsigned long )session->recv_question != (unsigned long )((void *)0)) {
    {
#line 728
    printf((char const   */* __restrict  */)"QUESTIONS (recv)\n");
#line 729
    dump_question(session->recv_question);
    }
  }
#line 732
  answerrr = session->answer;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! ((unsigned long )answerrr != (unsigned long )((void *)0))) {
#line 733
      goto while_break;
    }
    {
#line 734
    printf((char const   */* __restrict  */)"ANSWER RR\n");
#line 735
    dump_rr(answerrr, session);
#line 736
    answerrr = answerrr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  authorityrr = session->authority;
  {
#line 740
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 740
    if (! ((unsigned long )authorityrr != (unsigned long )((void *)0))) {
#line 740
      goto while_break___0;
    }
    {
#line 741
    printf((char const   */* __restrict  */)"AUTHORITY RR\n");
#line 742
    dump_rr(authorityrr, session);
#line 743
    authorityrr = authorityrr->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 746
  additionalrr = session->additional;
  {
#line 747
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 747
    if (! ((unsigned long )additionalrr != (unsigned long )((void *)0))) {
#line 747
      goto while_break___1;
    }
    {
#line 748
    printf((char const   */* __restrict  */)"ADDITIONAL RR\n");
#line 749
    dump_rr(additionalrr, session);
#line 750
    additionalrr = additionalrr->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 752
  return;
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
unsigned char *create_packet(struct dnssession *session ) 
{ 
  unsigned char *pkt ;
  struct dnsheader nheader ;
  struct dnsquestion nquestion ;
  int len ;
  void *tmp ;

  {
  {
#line 773
  len = (int )((sizeof(struct dnsheader ) + (unsigned long )(session->send_question)->querylength) + 4UL);
#line 774
  tmp = calloc((size_t )1, (size_t )len);
#line 774
  pkt = (unsigned char *)tmp;
#line 776
  memcpy((void */* __restrict  */)(& nheader), (void const   */* __restrict  */)session->send_header,
         sizeof(struct dnsheader ));
#line 777
  memcpy((void */* __restrict  */)(& nquestion), (void const   */* __restrict  */)session->send_question,
         sizeof(struct dnsquestion ));
#line 779
  nheader.identification = htons((session->send_header)->identification);
#line 780
  nheader.flags.flags = htons((session->send_header)->flags.flags);
#line 781
  nheader.nquestions = htons((session->send_header)->nquestions);
#line 782
  nheader.nanswerRR = htons((session->send_header)->nanswerRR);
#line 783
  nheader.nauthorityRR = htons((session->send_header)->nauthorityRR);
#line 784
  nheader.nadditionalRR = htons((session->send_header)->nadditionalRR);
#line 786
  nquestion.type = htons((session->send_question)->type);
#line 787
  nquestion.class = htons((session->send_question)->class);
#line 789
  memcpy((void */* __restrict  */)pkt, (void const   */* __restrict  */)(& nheader),
         sizeof(struct dnsheader ));
#line 790
  memcpy((void */* __restrict  */)(pkt + sizeof(struct dnsheader )), (void const   */* __restrict  */)nquestion.query,
         (size_t )nquestion.querylength);
#line 791
  memcpy((void */* __restrict  */)((pkt + sizeof(struct dnsheader )) + nquestion.querylength),
         (void const   */* __restrict  */)(& nquestion.type), (size_t )4);
  }
#line 793
  return (pkt);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int create_socket(int PF ) 
{ 
  int s ;
  struct addrinfo hints ;
  struct addrinfo *src_res ;
  int error ;
  int tmp ;

  {
  {
#line 807
  s = socket(PF, 2, 0);
  }
#line 807
  if (s < 0) {
    {
#line 808
    perror("create_socket/socket");
#line 809
    printf((char const   */* __restrict  */)"If this is an IPv6 problem, run configure with --disable-ipv6\n");
#line 810
    exit(1);
    }
  }
#line 813
  if ((unsigned long )global_source_address != (unsigned long )((void *)0)) {
    {
#line 818
    memset((void *)(& hints), 0, sizeof(hints));
#line 819
    hints.ai_flags = 4;
#line 820
    hints.ai_family = 2;
#line 821
    hints.ai_socktype = 2;
#line 822
    error = getaddrinfo((char const   */* __restrict  */)global_source_address, (char const   */* __restrict  */)0,
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& src_res));
    }
#line 823
    if (error == -2) {
      {
#line 824
      hints.ai_flags = 0;
#line 825
      error = getaddrinfo((char const   */* __restrict  */)global_source_address,
                          (char const   */* __restrict  */)0, (struct addrinfo  const  */* __restrict  */)(& hints),
                          (struct addrinfo **/* __restrict  */)(& src_res));
      }
    }
#line 827
    if (error != 0) {
      {
#line 828
      perror((char const   *)global_source_address);
      }
#line 829
      if (error == -11) {
        {
#line 830
        perror((char const   *)global_source_address);
        }
      }
      {
#line 831
      exit(1);
      }
    }
    {
#line 834
    tmp = bind(s, (struct sockaddr  const  *)src_res->ai_addr, src_res->ai_addrlen);
    }
#line 834
    if (tmp < 0) {
      {
#line 835
      perror("create_socket/bind");
#line 836
      exit(1);
      }
    }
  }
#line 840
  return (s);
}
}
#line 843 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int send_data(char *server , struct dnssession *session ) 
{ 
  int cc ;
  char *pkt ;
  int len ;
  struct sockaddr_in dest4 ;
  struct sockaddr_in6 dest6 ;
  unsigned char *tmp ;
  unsigned long tmp___0 ;
  struct sockaddr *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 854
  len = (int )((sizeof(struct dnsheader ) + (unsigned long )(session->send_question)->querylength) + 4UL);
#line 857
  if (session->ipv6) {
    {
#line 858
    memset((void *)(& dest6), 0, sizeof(struct sockaddr_in6 ));
#line 859
    dest6.sin6_family = (sa_family_t )10;
#line 860
    dest6.sin6_port = htons((uint16_t )53);
#line 861
    inet_pton(10, (char const   */* __restrict  */)server, (void */* __restrict  */)(& dest6.sin6_addr));
#line 863
    dump_data((struct sockaddr_in *)((void *)0), & dest6, session);
    }
  } else {
    {
#line 868
    memset((void *)(& dest4), 0, sizeof(struct sockaddr_in ));
#line 869
    dest4.sin_family = (sa_family_t )2;
#line 870
    dest4.sin_port = htons((uint16_t )53);
#line 871
    dest4.sin_addr.s_addr = inet_addr((char const   *)server);
#line 873
    dump_data(& dest4, (struct sockaddr_in6 *)((void *)0), session);
    }
  }
  {
#line 876
  tmp = create_packet(session);
#line 876
  pkt = (char *)tmp;
  }
#line 877
  if (session->ipv6) {
#line 877
    tmp___0 = sizeof(struct sockaddr_in6 );
  } else {
#line 877
    tmp___0 = sizeof(struct sockaddr_in );
  }
#line 877
  if (session->ipv6) {
#line 877
    tmp___1 = (struct sockaddr *)(& dest6);
  } else {
#line 877
    tmp___1 = (struct sockaddr *)(& dest4);
  }
  {
#line 877
  tmp___2 = sendto(session->socket, (void const   *)pkt, (size_t )len, 0, (struct sockaddr  const  *)tmp___1,
                   (socklen_t )tmp___0);
#line 877
  cc = (int )tmp___2;
  }
#line 877
  if (cc == -1) {
    {
#line 885
    perror("send_data/sendto");
    }
  }
  {
#line 888
  free((void *)pkt);
  }
#line 889
  return (cc);
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int receive_data(struct dnssession *session , int retry ) 
{ 
  char buffer[2048] ;
  int len ;
  fd_set in_set ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  ssize_t tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  void *tmp___3 ;

  {
#line 900
  timeout.tv_sec = (__time_t )(5 * (1 << retry));
#line 901
  timeout.tv_usec = (__suseconds_t )0;
#line 902
  if (global_timeout) {
#line 902
    if (timeout.tv_sec > (__time_t )global_timeout) {
#line 903
      timeout.tv_sec = (__time_t )global_timeout;
    }
  }
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
#line 905
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& in_set.__fds_bits[0]): "memory");
#line 905
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 906
  in_set.__fds_bits[session->socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << session->socket % (8 * (int )sizeof(__fd_mask ));
#line 908
  tmp = select(session->socket + 1, (fd_set */* __restrict  */)(& in_set), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
  }
#line 908
  if (tmp < 0) {
#line 909
    return (2);
  }
#line 910
  if (! ((in_set.__fds_bits[session->socket / (8 * (int )sizeof(__fd_mask ))] & (1L << session->socket % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 911
    return (3);
  }
  {
#line 912
  tmp___0 = recv(session->socket, (void *)(buffer), sizeof(buffer), 0);
#line 912
  len = (int )tmp___0;
  }
#line 912
  if (len == -1) {
#line 913
    return (1);
  }
  {
#line 915
  tmp___2 = getshort((unsigned char *)(buffer));
  }
#line 915
  if ((int )tmp___2 != (int )(session->send_header)->identification) {
    {
#line 916
    tmp___1 = getshort((unsigned char *)(buffer));
#line 916
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected id: %hx, received id: %hx\n",
            (int )(session->send_header)->identification, (int )tmp___1);
    }
#line 918
    return (4);
  }
  {
#line 921
  session->recv_len = len;
#line 922
  tmp___3 = calloc((size_t )1, (size_t )len);
#line 922
  session->recv_pkt = (char *)tmp___3;
#line 923
  memcpy((void */* __restrict  */)session->recv_pkt, (void const   */* __restrict  */)(buffer),
         (size_t )len);
#line 924
  extract_data(session);
#line 925
  dump_data((struct sockaddr_in *)((void *)0), (struct sockaddr_in6 *)((void *)0),
            session);
  }
#line 926
  return (0);
}
}
#line 935 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void create_header(struct dnssession *session ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 939
  tmp = calloc((size_t )1, sizeof(struct dnsheader ));
#line 939
  session->send_header = (struct dnsheader *)tmp;
#line 947
  tmp___0 = random();
#line 947
  (session->send_header)->identification = (unsigned short )(tmp___0 & 32639L);
#line 948
  (session->send_header)->nquestions = (unsigned short)1;
  }
#line 949
  return;
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void create_question(struct dnssession *session , char *name ) 
{ 
  char *p ;
  char *q ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 956
  tmp = calloc((size_t )1, sizeof(struct dnsquestion ));
#line 956
  session->send_question = (struct dnsquestion *)tmp;
#line 959
  tmp___0 = strlen((char const   *)name);
#line 959
  (session->send_question)->querylength = (unsigned int )(tmp___0 + 2UL);
#line 960
  tmp___1 = calloc((size_t )1, (size_t )((session->send_question)->querylength + 2U));
#line 960
  (session->send_question)->query = (unsigned char *)tmp___1;
#line 962
  strcpy((char */* __restrict  */)((session->send_question)->query + 1), (char const   */* __restrict  */)name);
#line 964
  p = (char *)((session->send_question)->query + 1);
#line 965
  q = (char *)(session->send_question)->query;
  }
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 966
    if (! ((int )*(p + 0) != 0)) {
#line 966
      goto while_break;
    }
#line 967
    if ((int )*(p + 0) == 46) {
#line 968
      *(q + 0) = (char )((p - q) - 1L);
#line 969
      q = p;
    }
#line 971
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 973
  *(q + 0) = (char )((p - q) - 1L);
#line 975
  (session->send_question)->type = (unsigned short )global_querytype;
#line 976
  (session->send_question)->class = (unsigned short)1;
#line 977
  return;
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct arecord *arecords  =    (struct arecord *)((void *)0);
#line 989 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void add_arecord(struct dnssession *session , struct dnsrr *rr , char *server_name ,
                 char *server_ip ) 
{ 
  struct arecord *arecord ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 994
  tmp = calloc((size_t )1, sizeof(struct arecord ));
#line 994
  arecord = (struct arecord *)tmp;
#line 995
  arecord->server_name = strdup((char const   *)server_name);
#line 996
  arecord->server_ip = strdup((char const   *)server_ip);
#line 997
  tmp___0 = printablename((char *)rr->domainname, 1);
#line 997
  arecord->rr_name = strdup((char const   *)tmp___0);
  }
#line 999
  if ((unsigned long )rr->data_string == (unsigned long )((void *)0)) {
#line 1000
    arecord->rr_data = (char *)((void *)0);
  } else {
    {
#line 1002
    arecord->rr_data = strdup((char const   *)rr->data_string);
    }
  }
#line 1004
  arecord->next = arecords;
#line 1005
  arecords = arecord;
#line 1006
  return;
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void display_arecords(void) 
{ 
  struct arecord *arecord ;
  int i ;
  char s[10] ;

  {
#line 1015
  arecord = arecords;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    if (! ((unsigned long )arecord != (unsigned long )((void *)0))) {
#line 1016
      goto while_break;
    }
    {
#line 1017
    printf((char const   */* __restrict  */)"%s (%s)%n", arecord->server_name, arecord->server_ip,
           & i);
    }
#line 1019
    if (40 - i < 1) {
      {
#line 1020
      printf((char const   */* __restrict  */)" ");
      }
    } else {
      {
#line 1022
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%%%ds",
              40 - i);
#line 1023
      printf((char const   */* __restrict  */)(s), " ");
      }
    }
    {
#line 1025
    printf((char const   */* __restrict  */)"%s -> %s\n", arecord->rr_name, arecord->rr_data);
#line 1026
    arecord = arecord->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1028
  return;
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct answer *answers  =    (struct answer *)((void *)0);
#line 1040 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void add_answer(char *server ) 
{ 
  struct answer *answer ;
  void *tmp ;

  {
  {
#line 1045
  tmp = calloc((size_t )1, sizeof(struct answer ));
#line 1045
  answer = (struct answer *)tmp;
#line 1046
  answer->server = strdup((char const   *)server);
#line 1047
  answer->next = answers;
#line 1048
  answers = answer;
  }
#line 1049
  return;
}
}
#line 1051 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int has_answer(char *server ) 
{ 
  struct answer *answer ;
  int tmp ;

  {
#line 1056
  answer = answers;
  {
#line 1057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1057
    if (! ((unsigned long )answer != (unsigned long )((void *)0))) {
#line 1057
      goto while_break;
    }
    {
#line 1058
    tmp = strcmp((char const   *)answer->server, (char const   *)server);
    }
#line 1058
    if (tmp == 0) {
#line 1059
      return (1);
    }
#line 1060
    answer = answer->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1062
  return (0);
}
}
#line 1074 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
struct busy *busies  =    (struct busy *)((void *)0);
#line 1076 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void add_busy(char *server ) 
{ 
  struct busy *busy ;
  void *tmp ;

  {
  {
#line 1081
  tmp = calloc((size_t )1, sizeof(struct busy ));
#line 1081
  busy = (struct busy *)tmp;
#line 1082
  busy->server = strdup((char const   *)server);
#line 1083
  busy->next = busies;
#line 1084
  busies = busy;
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void remove_busy(char *server ) 
{ 
  struct busy *busy ;
  struct busy *prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1092
  tmp = strcmp((char const   *)busies->server, (char const   *)server);
  }
#line 1092
  if (tmp == 0) {
    {
#line 1093
    busy = busies;
#line 1094
    busies = busies->next;
#line 1095
    free((void *)busy);
    }
#line 1096
    return;
  }
#line 1099
  prev = busies;
#line 1100
  busy = prev->next;
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1101
    if (! ((unsigned long )busy != (unsigned long )((void *)0))) {
#line 1101
      goto while_break;
    }
    {
#line 1102
    tmp___0 = strcmp((char const   *)busy->server, (char const   *)server);
    }
#line 1102
    if (tmp___0 == 0) {
      {
#line 1103
      prev->next = busy->next;
#line 1104
      free((void *)busy);
      }
#line 1105
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  return;
}
}
#line 1110 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int is_busy(char *server ) 
{ 
  struct busy *busy ;
  int tmp ;

  {
#line 1115
  busy = busies;
  {
#line 1116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1116
    if (! ((unsigned long )busy != (unsigned long )((void *)0))) {
#line 1116
      goto while_break;
    }
    {
#line 1117
    tmp = strcmp((char const   *)busy->server, (char const   *)server);
    }
#line 1117
    if (tmp == 0) {
#line 1118
      return (1);
    }
#line 1119
    busy = busy->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1121
  return (0);
}
}
#line 1130 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int create_session(char *host , char *server_ip , int ipv6 , char *server_name , char *server_authfor ,
                   int depth , char *prefix , int last ) 
{ 
  struct dnssession *session ;
  struct dnsrr *rrauth ;
  struct dnsrr *rradd ;
  int i ;
  int retval___2 ;
  int errorcode ;
  int refersbackwards ;
  char s[1025] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  struct dnsrr *answer ;
  int tmp___4 ;
  int found ;
  char nextserver_ip[1025] ;
  char nextserver_name[1025] ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int ip ;
  int ipfound ;
  int count ;
  int i___0 ;
  struct hostent *h ;
  char **addr_list ;
  int tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  unsigned char *s___0 ;
  unsigned char *s___1 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
#line 1137
  refersbackwards = 0;
#line 1143
  if (depth != 0) {
#line 1144
    if (last == 1) {
#line 1144
      tmp = ' ';
    } else {
#line 1144
      tmp = '|';
    }
    {
#line 1144
    printf((char const   */* __restrict  */)"%s%c", prefix, tmp);
#line 1145
    printf((char const   */* __restrict  */)"\\___ ");
    }
  }
  {
#line 1148
  printf((char const   */* __restrict  */)"%s ", server_name);
  }
#line 1150
  if ((unsigned long )server_authfor != (unsigned long )((void *)0)) {
    {
#line 1151
    printf((char const   */* __restrict  */)"[%s] ", server_authfor);
    }
  }
#line 1153
  if ((int )*(server_ip + 0) == 0) {
    {
#line 1154
    printf((char const   */* __restrict  */)"(No IP address)");
    }
#line 1155
    return (1);
  }
#line 1158
  if (global_noipv6) {
#line 1158
    if (ipv6) {
      {
#line 1159
      printf((char const   */* __restrict  */)"(%s) Not queried", server_ip);
      }
#line 1160
      return (1);
    }
  }
  {
#line 1169
  printf((char const   */* __restrict  */)"(%s) ", server_ip);
#line 1170
  fflush(stdout);
#line 1177
  tmp___0 = is_busy(server_ip);
  }
#line 1177
  if (tmp___0 == 1) {
    {
#line 1178
    printf((char const   */* __restrict  */)"Lame server ");
#line 1179
    fflush(stdout);
    }
#line 1180
    return (0);
  }
#line 1186
  if (global_caching) {
    {
#line 1186
    tmp___1 = has_answer(server_ip);
    }
#line 1186
    if (tmp___1) {
      {
#line 1187
      printf((char const   */* __restrict  */)"(cached)");
      }
#line 1188
      return (0);
    }
  }
  {
#line 1194
  add_busy(server_ip);
#line 1200
  tmp___2 = calloc((size_t )1, sizeof(struct dnssession ));
#line 1200
  session = (struct dnssession *)tmp___2;
  }
#line 1201
  if (ipv6) {
#line 1201
    tmp___3 = 10;
  } else {
#line 1201
    tmp___3 = 2;
  }
  {
#line 1201
  session->socket = create_socket(tmp___3);
#line 1202
  session->ipv6 = ipv6;
#line 1203
  session->server = strdup((char const   *)server_ip);
#line 1204
  session->host = strdup((char const   *)host);
#line 1205
  create_header(session);
#line 1206
  create_question(session, host);
#line 1211
  errorcode = 0;
#line 1212
  i = 0;
  }
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1212
    if (! (i < global_retries)) {
#line 1212
      goto while_break;
    }
    {
#line 1213
    send_data(server_ip, session);
#line 1214
    errorcode = receive_data(session, i);
    }
#line 1214
    if (errorcode == 0) {
#line 1215
      goto while_break;
    }
    {
#line 1216
    printf((char const   */* __restrict  */)"* ");
#line 1217
    fflush(stdout);
#line 1212
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1219
  close(session->socket);
  }
#line 1224
  if (errorcode != 0) {
    {
#line 1225
    remove_busy(server_ip);
    }
#line 1226
    if (global_negative_caching) {
      {
#line 1226
      add_answer(server_ip);
      }
    }
#line 1227
    return (1);
  }
#line 1234
  if ((int )(session->recv_header)->nanswerRR != 0) {
#line 1237
    if ((session->recv_header)->flags.bit.aa) {
      {
#line 1238
      printf((char const   */* __restrict  */)"Got authoritative answer ");
      }
    } else {
      {
#line 1240
      printf((char const   */* __restrict  */)"Got answer ");
      }
    }
#line 1242
    answer = session->answer;
    {
#line 1243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1243
      if (! ((unsigned long )answer != (unsigned long )((void *)0))) {
#line 1243
        goto while_break___0;
      }
#line 1244
      if ((int )answer->type != global_querytype) {
        {
#line 1245
        printf((char const   */* __restrict  */)"[received type is %s] ", rr_types[answer->type]);
        }
      }
      {
#line 1246
      add_arecord(session, answer, server_name, server_ip);
#line 1247
      answer = answer->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1249
    if (global_caching) {
      {
#line 1249
      add_answer(server_ip);
      }
    }
  }
#line 1256
  if ((unsigned long )session->authority != (unsigned long )((void *)0)) {
#line 1256
    if ((unsigned long )server_authfor != (unsigned long )((void *)0)) {
#line 1257
      if ((int )(session->recv_header)->flags.bit.aa == 0) {
        {
#line 1257
        tmp___4 = strcasecmp((char const   *)server_authfor, (char const   *)(session->authority)->domainname_string);
        }
#line 1257
        if (tmp___4 == 0) {
          {
#line 1260
          printf((char const   */* __restrict  */)"Lame server ");
#line 1261
          remove_busy(server_ip);
          }
#line 1262
          return (0);
        }
      }
    }
  }
#line 1271
  if ((session->recv_header)->flags.bit.aa) {
    {
#line 1272
    remove_busy(server_ip);
    }
#line 1273
    return (0);
  }
#line 1283
  retval___2 = 0;
#line 1284
  rrauth = session->authority;
  {
#line 1285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1285
    if (! ((unsigned long )rrauth != (unsigned long )((void *)0))) {
#line 1285
      goto while_break___1;
    }
#line 1286
    found = 0;
#line 1293
    if ((int )rrauth->type != 2) {
#line 1294
      rrauth = rrauth->next;
#line 1295
      goto while_continue___1;
    }
    {
#line 1303
    tmp___6 = strcmp((char const   *)rrauth->domainname_string, ".");
    }
#line 1303
    if (tmp___6 == 0) {
#line 1304
      rrauth = rrauth->next;
#line 1305
      tmp___5 = refersbackwards;
#line 1305
      refersbackwards ++;
#line 1305
      if (! tmp___5) {
        {
#line 1306
        printf((char const   */* __restrict  */)"Refers backwards ");
        }
      }
#line 1307
      goto while_continue___1;
    }
#line 1310
    if ((unsigned long )server_authfor != (unsigned long )((void *)0)) {
      {
#line 1310
      tmp___8 = strcmp((char const   *)server_authfor, ".");
      }
#line 1310
      if (tmp___8 != 0) {
        {
#line 1310
        tmp___9 = strlen((char const   *)server_authfor);
#line 1310
        tmp___10 = strnrcasecmp((char const   *)rrauth->domainname_string, (char const   *)server_authfor,
                                tmp___9);
        }
#line 1310
        if (tmp___10 != 0) {
#line 1313
          tmp___7 = refersbackwards;
#line 1313
          refersbackwards ++;
#line 1313
          if (! tmp___7) {
            {
#line 1314
            printf((char const   */* __restrict  */)"Refers backwards ");
            }
          }
#line 1315
          rrauth = rrauth->next;
#line 1316
          goto while_continue___1;
        }
      }
    }
#line 1323
    rradd = session->additional;
    {
#line 1324
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1324
      if (! ((unsigned long )rradd != (unsigned long )((void *)0))) {
#line 1324
        goto while_break___2;
      }
      {
#line 1325
      tmp___11 = printablename((char *)rradd->domainname, 1);
#line 1325
      tmp___12 = strcmp((char const   *)tmp___11, (char const   *)rrauth->data_string);
      }
#line 1325
      if (tmp___12 == 0) {
#line 1327
        found ++;
      }
#line 1328
      rradd = rradd->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1331
    rradd = session->additional;
    {
#line 1332
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1336
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1336
        if (! ((unsigned long )rradd != (unsigned long )((void *)0))) {
#line 1336
          goto while_break___4;
        }
        {
#line 1337
        tmp___13 = printablename((char *)rradd->domainname, 1);
#line 1337
        tmp___14 = strcmp((char const   *)tmp___13, (char const   *)rrauth->data_string);
        }
#line 1337
        if (tmp___14 == 0) {
#line 1339
          goto while_break___4;
        }
#line 1340
        rradd = rradd->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1346
      if (depth == 0) {
#line 1346
        tmp___15 = "";
      } else {
#line 1346
        tmp___15 = "     ";
      }
#line 1346
      if (last == 1) {
#line 1346
        tmp___16 = ' ';
      } else {
#line 1346
        tmp___16 = '|';
      }
      {
#line 1346
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s%c%s",
              prefix, tmp___16, tmp___15);
      }
#line 1352
      if ((unsigned long )rradd != (unsigned long )((void *)0)) {
        {
#line 1357
        printf((char const   */* __restrict  */)"\n");
#line 1359
        tmp___17 = printablename((char *)rradd->domainname, 1);
#line 1359
        strcpy((char */* __restrict  */)(nextserver_name), (char const   */* __restrict  */)tmp___17);
#line 1360
        strcpy((char */* __restrict  */)(nextserver_ip), (char const   */* __restrict  */)rradd->data_string);
        }
#line 1361
        if ((unsigned long )rrauth->next == (unsigned long )((void *)0)) {
#line 1361
          if (found <= 1) {
#line 1361
            tmp___18 = 1;
          } else {
#line 1361
            tmp___18 = 0;
          }
        } else {
#line 1361
          tmp___18 = 0;
        }
#line 1361
        if ((int )rradd->type == 28) {
#line 1361
          tmp___19 = 1;
        } else {
#line 1361
          tmp___19 = 0;
        }
        {
#line 1361
        tmp___20 = create_session(host, nextserver_ip, tmp___19, nextserver_name,
                                  (char *)rrauth->domainname_string, depth + 1, s,
                                  tmp___18);
#line 1361
        retval___2 += tmp___20;
        }
      } else {
        {
#line 1367
        ipfound = 0;
#line 1369
        strcpy((char */* __restrict  */)(nextserver_name), (char const   */* __restrict  */)rrauth->data_string);
#line 1374
        ip = 0;
        }
        {
#line 1374
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1374
          if (! (ip < 2)) {
#line 1374
            goto while_break___5;
          }
#line 1378
          addr_list = (char **)((void *)0);
#line 1380
          if (ip == 0) {
#line 1380
            tmp___21 = 2;
          } else {
#line 1380
            tmp___21 = 10;
          }
          {
#line 1380
          h = gethostbyname2((char const   *)(nextserver_name), tmp___21);
          }
#line 1382
          if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1382
            goto __Cont;
          }
#line 1389
          count = 0;
          {
#line 1390
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1390
            if (! ((unsigned long )*(h->h_addr_list + count) != (unsigned long )((void *)0))) {
#line 1390
              goto while_break___6;
            }
#line 1390
            count ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 1391
          tmp___22 = calloc((size_t )count, sizeof(char *));
#line 1391
          addr_list = (char **)tmp___22;
#line 1392
          i___0 = 0;
          }
          {
#line 1392
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1392
            if (! (i___0 < count)) {
#line 1392
              goto while_break___7;
            }
            {
#line 1393
            tmp___23 = calloc((size_t )1, (size_t )h->h_length);
#line 1393
            *(addr_list + i___0) = (char *)tmp___23;
#line 1394
            memcpy((void */* __restrict  */)*(addr_list + i___0), (void const   */* __restrict  */)*(h->h_addr_list + i___0),
                   (size_t )h->h_length);
#line 1392
            i___0 ++;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1397
          i___0 = 0;
          {
#line 1397
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1397
            if (! (i___0 < count)) {
#line 1397
              goto while_break___8;
            }
#line 1398
            if (ip == 0) {
              {
#line 1399
              s___0 = (unsigned char *)*(addr_list + i___0);
#line 1400
              sprintf((char */* __restrict  */)(nextserver_ip), (char const   */* __restrict  */)"%hu.%hu.%hu.%hu",
                      (int )*(s___0 + 0), (int )*(s___0 + 1), (int )*(s___0 + 2),
                      (int )*(s___0 + 3));
#line 1402
              ipv6 = 0;
              }
            } else {
              {
#line 1404
              s___1 = (unsigned char *)*(addr_list + i___0);
#line 1405
              sprintf((char */* __restrict  */)(nextserver_ip), (char const   */* __restrict  */)"%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx",
                      (int )*(s___1 + 0), (int )*(s___1 + 1), (int )*(s___1 + 2),
                      (int )*(s___1 + 3), (int )*(s___1 + 4), (int )*(s___1 + 5),
                      (int )*(s___1 + 6), (int )*(s___1 + 7), (int )*(s___1 + 8),
                      (int )*(s___1 + 9), (int )*(s___1 + 10), (int )*(s___1 + 11),
                      (int )*(s___1 + 12), (int )*(s___1 + 13), (int )*(s___1 + 14),
                      (int )*(s___1 + 15));
#line 1410
              ipv6 = 1;
              }
            }
            {
#line 1412
            printf((char const   */* __restrict  */)"\n");
            }
#line 1414
            if ((unsigned long )rrauth->next == (unsigned long )((void *)0)) {
#line 1414
              if (found <= 1) {
#line 1414
                tmp___24 = 1;
              } else {
#line 1414
                tmp___24 = 0;
              }
            } else {
#line 1414
              tmp___24 = 0;
            }
            {
#line 1414
            tmp___25 = create_session(host, nextserver_ip, ip == 1, nextserver_name,
                                      (char *)rrauth->domainname_string, depth + 1,
                                      s, tmp___24);
#line 1414
            retval___2 += tmp___25;
#line 1419
            ipfound ++;
#line 1397
            i___0 ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          __Cont: /* CIL Label */ 
#line 1374
          ip ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1423
        if (ipfound == 0) {
          {
#line 1429
          printf((char const   */* __restrict  */)"\n");
#line 1430
          nextserver_ip[0] = (char)0;
          }
#line 1431
          if ((unsigned long )rrauth->next == (unsigned long )((void *)0)) {
#line 1431
            if (found <= 1) {
#line 1431
              tmp___26 = 1;
            } else {
#line 1431
              tmp___26 = 0;
            }
          } else {
#line 1431
            tmp___26 = 0;
          }
          {
#line 1431
          tmp___27 = create_session(host, nextserver_ip, 0, nextserver_name, (char *)rrauth->domainname_string,
                                    depth + 1, s, tmp___26);
#line 1431
          retval___2 += tmp___27;
          }
        }
      }
#line 1443
      found --;
#line 1443
      if (found <= 0) {
#line 1444
        goto while_break___3;
      }
#line 1445
      if ((unsigned long )rradd != (unsigned long )((void *)0)) {
#line 1446
        rradd = rradd->next;
      }
#line 1332
      if (! ((unsigned long )rradd != (unsigned long )((void *)0))) {
#line 1332
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1448
    rrauth = rrauth->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1455
  if (global_caching) {
#line 1455
    if (retval___2 == 0) {
      {
#line 1455
      add_answer(server_ip);
      }
    }
  }
  {
#line 1456
  remove_busy(server_ip);
  }
#line 1458
  return (retval___2);
}
}
#line 1468 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
void usage(void) 
{ 


  {
  {
#line 1471
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DNSTRACER version 1.8.1 - (c) Edwin Groothuis - http://www.mavetju.org\nUsage: dnstracer [options] [host]\n\t-c: disable local caching, default enabled\n\t-C: enable negative caching, default disabled\n\t-o: enable overview of received answers, default disabled\n\t-q <querytype>: query-type to use for the DNS requests, default A\n\t-r <retries>: amount of retries for DNS requests, default 3\n\t-s <server>: use this server for the initial request, default localhost\n\t             If . is specified, A.ROOT-SERVERS.NET will be used.\n\t-t <maximum timeout>: Limit time to wait per try\n\t-v: verbose\n\t-S <ip address>: use this source address.\n");
#line 1486
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-4: don\'t query IPv6 servers\n");
#line 1490
  exit(1);
  }
}
}
#line 1508 "/home/june/repo/benchmarks/collector/temp/dnstracer-1.9/dnstracer.c"
int main(int argc , char **argv ) 
{ 
  int ch ;
  char *server_name ;
  char *server_ip ;
  char ipaddress[1025] ;
  char argv0[1025] ;
  int server_root ;
  int ipv6 ;
  struct __res_state *tmp ;
  struct __res_state *tmp___0 ;
  char *tmp___1 ;
  struct __res_state *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  time_t tmp___16 ;
  struct hostent *h ;
  unsigned char *s ;
  unsigned char *s___0 ;
  char const   *tmp___17 ;

  {
  {
#line 1512
  server_name = (char *)"127.0.0.1";
#line 1513
  server_ip = (char *)"0000:0000:0000:0000:0000:0000:0000:0000";
#line 1516
  server_root = 0;
#line 1517
  ipv6 = 0;
#line 1525
  tmp = __res_state();
  }
#line 1525
  if (! (tmp->options & 1UL)) {
    {
#line 1526
    __res_init();
    }
  }
  {
#line 1528
  tmp___2 = __res_state();
  }
#line 1528
  if (tmp___2->nscount > 0) {
    {
#line 1529
    tmp___0 = __res_state();
#line 1529
    tmp___1 = inet_ntoa(tmp___0->nsaddr_list[0].sin_addr);
#line 1529
    server_ip = strdup((char const   *)tmp___1);
#line 1530
    server_name = strdup((char const   *)server_ip);
    }
  }
  {
#line 1538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1538
    ch = getopt(argc, argv, (char *)"4cCoq:r:S:s:t:v");
    }
#line 1538
    if (! (ch != -1)) {
#line 1538
      goto while_break;
    }
    {
#line 1540
    if (ch == 52) {
#line 1540
      goto case_52;
    }
#line 1548
    if (ch == 99) {
#line 1548
      goto case_99;
    }
#line 1552
    if (ch == 67) {
#line 1552
      goto case_67;
    }
#line 1556
    if (ch == 111) {
#line 1556
      goto case_111;
    }
#line 1560
    if (ch == 113) {
#line 1560
      goto case_113;
    }
#line 1584
    if (ch == 114) {
#line 1584
      goto case_114;
    }
#line 1592
    if (ch == 83) {
#line 1592
      goto case_83;
    }
#line 1596
    if (ch == 115) {
#line 1596
      goto case_115;
    }
#line 1604
    if (ch == 116) {
#line 1604
      goto case_116;
    }
#line 1608
    if (ch == 118) {
#line 1608
      goto case_118;
    }
#line 1612
    goto switch_default;
    case_52: /* CIL Label */ 
#line 1542
    global_noipv6 = 1;
#line 1546
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1549
    global_caching = 0;
#line 1550
    goto switch_break;
    case_67: /* CIL Label */ 
#line 1553
    global_negative_caching = 1;
#line 1554
    goto switch_break;
    case_111: /* CIL Label */ 
#line 1557
    global_overview = 1;
#line 1558
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 1561
    global_querytype = atoi((char const   *)optarg);
    }
#line 1561
    if (global_querytype < 1) {
      {
#line 1565
      tmp___3 = strcmp("a", (char const   *)optarg);
      }
#line 1565
      if (tmp___3 == 0) {
#line 1565
        global_querytype = 1;
      }
      {
#line 1566
      tmp___4 = strcmp("aaaa", (char const   *)optarg);
      }
#line 1566
      if (tmp___4 == 0) {
#line 1566
        global_querytype = 28;
      }
      {
#line 1567
      tmp___5 = strcmp("a6", (char const   *)optarg);
      }
#line 1567
      if (tmp___5 == 0) {
#line 1567
        global_querytype = 28;
      }
      {
#line 1568
      tmp___6 = strcmp("ptr", (char const   *)optarg);
      }
#line 1568
      if (tmp___6 == 0) {
#line 1568
        global_querytype = 12;
      }
      {
#line 1569
      tmp___7 = strcmp("cname", (char const   *)optarg);
      }
#line 1569
      if (tmp___7 == 0) {
#line 1569
        global_querytype = 5;
      }
      {
#line 1570
      tmp___8 = strcmp("hinfo", (char const   *)optarg);
      }
#line 1570
      if (tmp___8 == 0) {
#line 1570
        global_querytype = 13;
      }
      {
#line 1571
      tmp___9 = strcmp("mx", (char const   *)optarg);
      }
#line 1571
      if (tmp___9 == 0) {
#line 1571
        global_querytype = 15;
      }
      {
#line 1572
      tmp___10 = strcmp("ns", (char const   *)optarg);
      }
#line 1572
      if (tmp___10 == 0) {
#line 1572
        global_querytype = 2;
      }
      {
#line 1573
      tmp___11 = strcmp("txt", (char const   *)optarg);
      }
#line 1573
      if (tmp___11 == 0) {
#line 1573
        global_querytype = 16;
      }
      {
#line 1574
      tmp___12 = strcmp("soa", (char const   *)optarg);
      }
#line 1574
      if (tmp___12 == 0) {
#line 1574
        global_querytype = 6;
      }
#line 1576
      if (global_querytype < 1) {
        {
#line 1577
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Strange querytype, setting to default\n");
#line 1579
        global_querytype = 1;
        }
      }
    }
#line 1582
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 1585
    global_retries = atoi((char const   *)optarg);
    }
#line 1585
    if (global_retries < 1) {
      {
#line 1586
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Strange amount of retries, setting to default\n");
#line 1588
      global_retries = 3;
      }
    }
#line 1590
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1593
    global_source_address = optarg;
#line 1594
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1597
    server_name = optarg;
#line 1598
    tmp___13 = strcmp((char const   *)server_name, ".");
    }
#line 1598
    if (tmp___13 == 0) {
      {
#line 1599
      server_name = strdup("A.ROOT-SERVERS.NET");
#line 1600
      server_root = 1;
      }
    }
#line 1602
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1605
    global_timeout = atoi((char const   *)optarg);
    }
#line 1606
    goto switch_break;
    case_118: /* CIL Label */ 
#line 1609
    verbose = 1;
#line 1610
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1613
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1616
  argc -= optind;
#line 1617
  argv += optind;
#line 1619
  if ((unsigned long )*(argv + 0) == (unsigned long )((void *)0)) {
    {
#line 1619
    usage();
    }
  }
  {
#line 1622
  strcpy((char */* __restrict  */)(argv0), (char const   */* __restrict  */)*(argv + 0));
#line 1623
  tmp___15 = strlen((char const   *)*(argv + 0));
  }
#line 1623
  if ((int )argv0[tmp___15 - 1UL] == 46) {
    {
#line 1623
    tmp___14 = strlen((char const   *)*(argv + 0));
#line 1623
    argv0[tmp___14 - 1UL] = (char)0;
    }
  }
  {
#line 1625
  printf((char const   */* __restrict  */)"Tracing to %s[%s] via %s, maximum of %d retries\n",
         argv0, rr_types[global_querytype], server_name, global_retries);
#line 1628
  tmp___16 = time((time_t *)((void *)0));
#line 1628
  srandom((unsigned int )tmp___16);
#line 1631
  h = (struct hostent *)((void *)0);
#line 1634
  h = gethostbyname2((char const   *)server_name, 10);
  }
#line 1636
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 1637
    h = gethostbyname2((char const   *)server_name, 2);
    }
  } else
#line 1636
  if (global_noipv6) {
    {
#line 1637
    h = gethostbyname2((char const   *)server_name, 2);
    }
  }
#line 1638
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 1639
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot find IP address for %s\n",
            server_name);
    }
#line 1640
    return (1);
  }
#line 1642
  if (h->h_addrtype == 2) {
    {
#line 1643
    s = (unsigned char *)*(h->h_addr_list + 0);
#line 1644
    sprintf((char */* __restrict  */)(ipaddress), (char const   */* __restrict  */)"%hu.%hu.%hu.%hu",
            (int )*(s + 0), (int )*(s + 1), (int )*(s + 2), (int )*(s + 3));
#line 1645
    ipv6 = 0;
    }
  } else {
    {
#line 1647
    s___0 = (unsigned char *)*(h->h_addr_list + 0);
#line 1648
    sprintf((char */* __restrict  */)(ipaddress), (char const   */* __restrict  */)"%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx:%02hx%02hx",
            (int )*(s___0 + 0), (int )*(s___0 + 1), (int )*(s___0 + 2), (int )*(s___0 + 3),
            (int )*(s___0 + 4), (int )*(s___0 + 5), (int )*(s___0 + 6), (int )*(s___0 + 7),
            (int )*(s___0 + 8), (int )*(s___0 + 9), (int )*(s___0 + 10), (int )*(s___0 + 11),
            (int )*(s___0 + 12), (int )*(s___0 + 13), (int )*(s___0 + 14), (int )*(s___0 + 15));
#line 1653
    ipv6 = 1;
    }
  }
#line 1657
  if (server_root == 0) {
#line 1657
    tmp___17 = (char const   *)((void *)0);
  } else {
#line 1657
    tmp___17 = ".";
  }
  {
#line 1657
  create_session(argv0, ipaddress, ipv6, server_name, (char *)tmp___17, 0, (char *)"",
                 1);
#line 1660
  printf((char const   */* __restrict  */)"\n");
  }
#line 1662
  if (global_overview != 0) {
    {
#line 1663
    printf((char const   */* __restrict  */)"\n");
#line 1664
    display_arecords();
    }
  }
#line 1667
  return (0);
}
}
